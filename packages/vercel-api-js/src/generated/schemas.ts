/**
 * Generated by Kubb (https://kubb.dev/).
 * Do not edit manually.
 */

import type {
  ACLAction,
  FlagJSONValue,
  Pagination,
  EdgeConfigItemValue,
  EdgeConfigItem,
  EdgeConfigToken,
  UserEvent,
  Team,
  TeamLimited,
  AuthToken,
  AuthUser,
  AuthUserLimited,
  FileTree,
  ReadAccessGroupPathParams,
  ReadAccessGroupQueryParams,
  ReadAccessGroup200,
  ReadAccessGroup400,
  ReadAccessGroup401,
  ReadAccessGroup403,
  ReadAccessGroupQueryResponse,
  UpdateAccessGroupPathParams,
  UpdateAccessGroupQueryParams,
  UpdateAccessGroup200,
  UpdateAccessGroup400,
  UpdateAccessGroup401,
  UpdateAccessGroup403,
  UpdateAccessGroupMutationRequest,
  UpdateAccessGroupMutationResponse,
  DeleteAccessGroupPathParams,
  DeleteAccessGroupQueryParams,
  DeleteAccessGroup200,
  DeleteAccessGroup400,
  DeleteAccessGroup401,
  DeleteAccessGroup403,
  DeleteAccessGroupMutationResponse,
  ListAccessGroupMembersPathParams,
  ListAccessGroupMembersQueryParams,
  ListAccessGroupMembers200,
  ListAccessGroupMembers400,
  ListAccessGroupMembers401,
  ListAccessGroupMembers403,
  ListAccessGroupMembersQueryResponse,
  ListAccessGroupsQueryParams,
  ListAccessGroups200,
  ListAccessGroups400,
  ListAccessGroups401,
  ListAccessGroups403,
  ListAccessGroupsQueryResponse,
  CreateAccessGroupQueryParams,
  CreateAccessGroup200,
  CreateAccessGroup400,
  CreateAccessGroup401,
  CreateAccessGroup403,
  CreateAccessGroupMutationRequest,
  CreateAccessGroupMutationResponse,
  ListAccessGroupProjectsPathParams,
  ListAccessGroupProjectsQueryParams,
  ListAccessGroupProjects200,
  ListAccessGroupProjects400,
  ListAccessGroupProjects401,
  ListAccessGroupProjects403,
  ListAccessGroupProjectsQueryResponse,
  CreateAccessGroupProjectPathParams,
  CreateAccessGroupProjectQueryParams,
  CreateAccessGroupProject200,
  CreateAccessGroupProject400,
  CreateAccessGroupProject401,
  CreateAccessGroupProject403,
  CreateAccessGroupProjectMutationRequest,
  CreateAccessGroupProjectMutationResponse,
  ReadAccessGroupProjectPathParams,
  ReadAccessGroupProjectQueryParams,
  ReadAccessGroupProject200,
  ReadAccessGroupProject400,
  ReadAccessGroupProject401,
  ReadAccessGroupProject403,
  ReadAccessGroupProjectQueryResponse,
  UpdateAccessGroupProjectPathParams,
  UpdateAccessGroupProjectQueryParams,
  UpdateAccessGroupProject200,
  UpdateAccessGroupProject400,
  UpdateAccessGroupProject401,
  UpdateAccessGroupProject403,
  UpdateAccessGroupProjectMutationRequest,
  UpdateAccessGroupProjectMutationResponse,
  DeleteAccessGroupProjectPathParams,
  DeleteAccessGroupProjectQueryParams,
  DeleteAccessGroupProject200,
  DeleteAccessGroupProject400,
  DeleteAccessGroupProject401,
  DeleteAccessGroupProject403,
  DeleteAccessGroupProjectMutationResponse,
  RecordEventsQueryParams,
  RecordEventsHeaderParams,
  RecordEvents200,
  RecordEvents400,
  RecordEvents401,
  RecordEvents402,
  RecordEvents403,
  RecordEventsMutationRequest,
  RecordEventsMutationResponse,
  StatusQueryParams,
  Status200,
  Status400,
  Status401,
  Status402,
  Status403,
  StatusQueryResponse,
  UploadArtifactPathParams,
  UploadArtifactQueryParams,
  UploadArtifactHeaderParams,
  UploadArtifact202,
  UploadArtifact400,
  UploadArtifact401,
  UploadArtifact402,
  UploadArtifact403,
  UploadArtifactMutationResponse,
  DownloadArtifactPathParams,
  DownloadArtifactQueryParams,
  DownloadArtifactHeaderParams,
  DownloadArtifact200,
  DownloadArtifact400,
  DownloadArtifact401,
  DownloadArtifact402,
  DownloadArtifact403,
  DownloadArtifact404,
  DownloadArtifactQueryResponse,
  ArtifactExistsPathParams,
  ArtifactExistsQueryParams,
  ArtifactExists200,
  ArtifactExists400,
  ArtifactExists401,
  ArtifactExists402,
  ArtifactExists403,
  ArtifactExists404,
  ArtifactExistsMutationResponse,
  ArtifactQueryQueryParams,
  ArtifactQuery200,
  ArtifactQuery400,
  ArtifactQuery401,
  ArtifactQuery402,
  ArtifactQuery403,
  ArtifactQueryMutationRequest,
  ArtifactQueryMutationResponse,
  CreateCheckPathParams,
  CreateCheckQueryParams,
  CreateCheck200,
  CreateCheck400,
  CreateCheck401,
  CreateCheck403,
  CreateCheck404,
  CreateCheckMutationRequest,
  CreateCheckMutationResponse,
  GetAllChecksPathParams,
  GetAllChecksQueryParams,
  GetAllChecks200,
  GetAllChecks400,
  GetAllChecks401,
  GetAllChecks403,
  GetAllChecks404,
  GetAllChecksQueryResponse,
  GetCheckPathParams,
  GetCheckQueryParams,
  GetCheck200,
  GetCheck400,
  GetCheck401,
  GetCheck403,
  GetCheck404,
  GetCheckQueryResponse,
  UpdateCheckPathParams,
  UpdateCheckQueryParams,
  UpdateCheck200,
  UpdateCheck400,
  UpdateCheck401,
  UpdateCheck403,
  UpdateCheck404,
  UpdateCheck413,
  UpdateCheckMutationRequest,
  UpdateCheckMutationResponse,
  RerequestCheckPathParams,
  RerequestCheckQueryParams,
  RerequestCheck200,
  RerequestCheck400,
  RerequestCheck401,
  RerequestCheck403,
  RerequestCheck404,
  RerequestCheckMutationResponse,
  DeletedataCachepurgeAllQueryParams,
  DeletedataCachepurgeAll200,
  DeletedataCachepurgeAll400,
  DeletedataCachepurgeAll401,
  DeletedataCachepurgeAll403,
  DeletedataCachepurgeAll404,
  DeletedataCachepurgeAllMutationResponse,
  PatchdataCachebillingSettings200,
  PatchdataCachebillingSettings400,
  PatchdataCachebillingSettings401,
  PatchdataCachebillingSettings403,
  PatchdataCachebillingSettings404,
  PatchdataCachebillingSettingsMutationRequest,
  PatchdataCachebillingSettingsMutationResponse,
  UpdateProjectDataCachePathParams,
  UpdateProjectDataCacheQueryParams,
  UpdateProjectDataCache200,
  UpdateProjectDataCache400,
  UpdateProjectDataCache401,
  UpdateProjectDataCache403,
  UpdateProjectDataCache404,
  UpdateProjectDataCacheMutationRequest,
  UpdateProjectDataCacheMutationResponse,
  GetDeploymentEventsPathParams,
  GetDeploymentEventsQueryParams,
  GetDeploymentEvents200,
  GetDeploymentEvents400,
  GetDeploymentEvents401,
  GetDeploymentEvents403,
  GetDeploymentEvents500,
  GetDeploymentEventsQueryResponse,
  UpdateIntegrationDeploymentActionPathParams,
  UpdateIntegrationDeploymentAction202,
  UpdateIntegrationDeploymentAction400,
  UpdateIntegrationDeploymentAction401,
  UpdateIntegrationDeploymentAction403,
  UpdateIntegrationDeploymentActionMutationRequest,
  UpdateIntegrationDeploymentActionMutationResponse,
  GetDeploymentPathParams,
  GetDeploymentQueryParams,
  GetDeployment200,
  GetDeployment400,
  GetDeployment403,
  GetDeployment404,
  GetDeploymentQueryResponse,
  CreateDeploymentQueryParams,
  CreateDeployment200,
  CreateDeployment400,
  CreateDeployment401,
  CreateDeployment402,
  CreateDeployment403,
  CreateDeployment404,
  CreateDeployment409,
  CreateDeployment500,
  CreateDeploymentMutationRequest,
  CreateDeploymentMutationResponse,
  CancelDeploymentPathParams,
  CancelDeploymentQueryParams,
  CancelDeployment200,
  CancelDeployment400,
  CancelDeployment401,
  CancelDeployment403,
  CancelDeployment404,
  CancelDeploymentMutationResponse,
  BuyDomainQueryParams,
  BuyDomain201,
  BuyDomain202,
  BuyDomain400,
  BuyDomain401,
  BuyDomain403,
  BuyDomain409,
  BuyDomain429,
  BuyDomainMutationRequest,
  BuyDomainMutationResponse,
  CheckDomainPriceQueryParams,
  CheckDomainPrice200,
  CheckDomainPrice400,
  CheckDomainPrice401,
  CheckDomainPrice403,
  CheckDomainPriceQueryResponse,
  CheckDomainStatusQueryParams,
  CheckDomainStatus200,
  CheckDomainStatus400,
  CheckDomainStatus401,
  CheckDomainStatus403,
  CheckDomainStatus408,
  CheckDomainStatus500,
  CheckDomainStatusQueryResponse,
  GetRecordsPathParams,
  GetRecordsQueryParams,
  GetRecords200,
  GetRecords400,
  GetRecords401,
  GetRecords403,
  GetRecords404,
  GetRecordsQueryResponse,
  CreateRecordPathParams,
  CreateRecordQueryParams,
  CreateRecord200,
  CreateRecord400,
  CreateRecord401,
  CreateRecord402,
  CreateRecord403,
  CreateRecord404,
  CreateRecord409,
  CreateRecordMutationRequest,
  CreateRecordMutationResponse,
  UpdateRecordPathParams,
  UpdateRecordQueryParams,
  UpdateRecord200,
  UpdateRecord400,
  UpdateRecord401,
  UpdateRecord402,
  UpdateRecord403,
  UpdateRecord404,
  UpdateRecord409,
  UpdateRecordMutationRequest,
  UpdateRecordMutationResponse,
  RemoveRecordPathParams,
  RemoveRecordQueryParams,
  RemoveRecord200,
  RemoveRecord400,
  RemoveRecord401,
  RemoveRecord403,
  RemoveRecord404,
  RemoveRecordMutationResponse,
  GetDomainTransferQueryParams,
  GetDomainTransfer200,
  GetDomainTransfer400,
  GetDomainTransfer401,
  GetDomainTransfer403,
  GetDomainTransferQueryResponse,
  GetDomainConfigPathParams,
  GetDomainConfigQueryParams,
  GetDomainConfig200,
  GetDomainConfig400,
  GetDomainConfig401,
  GetDomainConfig403,
  GetDomainConfig500,
  GetDomainConfigQueryResponse,
  GetDomainPathParams,
  GetDomainQueryParams,
  GetDomain200,
  GetDomain400,
  GetDomain401,
  GetDomain403,
  GetDomain404,
  GetDomainQueryResponse,
  GetDomainsQueryParams,
  GetDomains200,
  GetDomains400,
  GetDomains401,
  GetDomains403,
  GetDomains409,
  GetDomainsQueryResponse,
  CreateOrTransferDomainQueryParams,
  CreateOrTransferDomain200,
  CreateOrTransferDomain400,
  CreateOrTransferDomain401,
  CreateOrTransferDomain402,
  CreateOrTransferDomain403,
  CreateOrTransferDomain404,
  CreateOrTransferDomain409,
  CreateOrTransferDomain500,
  CreateOrTransferDomainMutationRequest,
  CreateOrTransferDomainMutationResponse,
  PatchDomainPathParams,
  PatchDomainQueryParams,
  PatchDomain200,
  PatchDomain400,
  PatchDomain401,
  PatchDomain403,
  PatchDomain404,
  PatchDomain409,
  PatchDomainMutationRequest,
  PatchDomainMutationResponse,
  DeleteDomainPathParams,
  DeleteDomainQueryParams,
  DeleteDomain200,
  DeleteDomain400,
  DeleteDomain401,
  DeleteDomain403,
  DeleteDomain404,
  DeleteDomain409,
  DeleteDomainMutationResponse,
  GetEdgeConfigsQueryParams,
  GetEdgeConfigs200,
  GetEdgeConfigs400,
  GetEdgeConfigs401,
  GetEdgeConfigs403,
  GetEdgeConfigsQueryResponse,
  CreateEdgeConfigQueryParams,
  CreateEdgeConfig201,
  CreateEdgeConfig400,
  CreateEdgeConfig401,
  CreateEdgeConfig402,
  CreateEdgeConfig403,
  CreateEdgeConfigMutationRequest,
  CreateEdgeConfigMutationResponse,
  GetEdgeConfigPathParams,
  GetEdgeConfigQueryParams,
  GetEdgeConfig200,
  GetEdgeConfig400,
  GetEdgeConfig401,
  GetEdgeConfig403,
  GetEdgeConfig404,
  GetEdgeConfigQueryResponse,
  UpdateEdgeConfigPathParams,
  UpdateEdgeConfigQueryParams,
  UpdateEdgeConfig200,
  UpdateEdgeConfig400,
  UpdateEdgeConfig401,
  UpdateEdgeConfig402,
  UpdateEdgeConfig403,
  UpdateEdgeConfig404,
  UpdateEdgeConfigMutationRequest,
  UpdateEdgeConfigMutationResponse,
  DeleteEdgeConfigPathParams,
  DeleteEdgeConfigQueryParams,
  DeleteEdgeConfig204,
  DeleteEdgeConfig400,
  DeleteEdgeConfig401,
  DeleteEdgeConfig403,
  DeleteEdgeConfig404,
  DeleteEdgeConfigMutationResponse,
  GetEdgeConfigItemsPathParams,
  GetEdgeConfigItemsQueryParams,
  GetEdgeConfigItems200,
  GetEdgeConfigItems400,
  GetEdgeConfigItems401,
  GetEdgeConfigItems403,
  GetEdgeConfigItems404,
  GetEdgeConfigItemsQueryResponse,
  PatchEdgeConfigItemsPathParams,
  PatchEdgeConfigItemsQueryParams,
  PatchEdgeConfigItems200,
  PatchEdgeConfigItems400,
  PatchEdgeConfigItems401,
  PatchEdgeConfigItems402,
  PatchEdgeConfigItems403,
  PatchEdgeConfigItems404,
  PatchEdgeConfigItems409,
  PatchEdgeConfigItemsMutationRequest,
  PatchEdgeConfigItemsMutationResponse,
  GetEdgeConfigSchemaPathParams,
  GetEdgeConfigSchemaQueryParams,
  GetEdgeConfigSchema200,
  GetEdgeConfigSchema400,
  GetEdgeConfigSchema401,
  GetEdgeConfigSchema403,
  GetEdgeConfigSchema404,
  GetEdgeConfigSchemaQueryResponse,
  PatchEdgeConfigSchemaPathParams,
  PatchEdgeConfigSchemaQueryParams,
  PatchEdgeConfigSchema200,
  PatchEdgeConfigSchema400,
  PatchEdgeConfigSchema401,
  PatchEdgeConfigSchema402,
  PatchEdgeConfigSchema403,
  PatchEdgeConfigSchema404,
  PatchEdgeConfigSchemaMutationRequest,
  PatchEdgeConfigSchemaMutationResponse,
  DeleteEdgeConfigSchemaPathParams,
  DeleteEdgeConfigSchemaQueryParams,
  DeleteEdgeConfigSchema204,
  DeleteEdgeConfigSchema400,
  DeleteEdgeConfigSchema401,
  DeleteEdgeConfigSchema402,
  DeleteEdgeConfigSchema403,
  DeleteEdgeConfigSchema404,
  DeleteEdgeConfigSchemaMutationResponse,
  GetEdgeConfigItemPathParams,
  GetEdgeConfigItemQueryParams,
  GetEdgeConfigItem200,
  GetEdgeConfigItem400,
  GetEdgeConfigItem401,
  GetEdgeConfigItem403,
  GetEdgeConfigItem404,
  GetEdgeConfigItemQueryResponse,
  GetEdgeConfigTokensPathParams,
  GetEdgeConfigTokensQueryParams,
  GetEdgeConfigTokens200,
  GetEdgeConfigTokens400,
  GetEdgeConfigTokens401,
  GetEdgeConfigTokens403,
  GetEdgeConfigTokens404,
  GetEdgeConfigTokensQueryResponse,
  DeleteEdgeConfigTokensPathParams,
  DeleteEdgeConfigTokensQueryParams,
  DeleteEdgeConfigTokens204,
  DeleteEdgeConfigTokens400,
  DeleteEdgeConfigTokens401,
  DeleteEdgeConfigTokens402,
  DeleteEdgeConfigTokens403,
  DeleteEdgeConfigTokens404,
  DeleteEdgeConfigTokensMutationRequest,
  DeleteEdgeConfigTokensMutationResponse,
  GetEdgeConfigTokenPathParams,
  GetEdgeConfigTokenQueryParams,
  GetEdgeConfigToken200,
  GetEdgeConfigToken400,
  GetEdgeConfigToken401,
  GetEdgeConfigToken403,
  GetEdgeConfigToken404,
  GetEdgeConfigTokenQueryResponse,
  CreateEdgeConfigTokenPathParams,
  CreateEdgeConfigTokenQueryParams,
  CreateEdgeConfigToken201,
  CreateEdgeConfigToken400,
  CreateEdgeConfigToken401,
  CreateEdgeConfigToken402,
  CreateEdgeConfigToken403,
  CreateEdgeConfigToken404,
  CreateEdgeConfigTokenMutationRequest,
  CreateEdgeConfigTokenMutationResponse,
  GetEdgeConfigBackupPathParams,
  GetEdgeConfigBackupQueryParams,
  GetEdgeConfigBackup200,
  GetEdgeConfigBackup400,
  GetEdgeConfigBackup401,
  GetEdgeConfigBackup403,
  GetEdgeConfigBackup404,
  GetEdgeConfigBackupQueryResponse,
  GetEdgeConfigBackupsPathParams,
  GetEdgeConfigBackupsQueryParams,
  GetEdgeConfigBackups200,
  GetEdgeConfigBackups400,
  GetEdgeConfigBackups401,
  GetEdgeConfigBackups403,
  GetEdgeConfigBackups404,
  GetEdgeConfigBackupsQueryResponse,
  ListUserEventsQueryParams,
  ListUserEvents200,
  ListUserEvents400,
  ListUserEvents401,
  ListUserEvents403,
  ListUserEventsQueryResponse,
  GetAccountInfoPathParams,
  GetAccountInfo200,
  GetAccountInfo400,
  GetAccountInfo401,
  GetAccountInfo403,
  GetAccountInfo404,
  GetAccountInfoQueryResponse,
  GetMemberPathParams,
  GetMember200,
  GetMember400,
  GetMember401,
  GetMember403,
  GetMember404,
  GetMemberQueryResponse,
  CreateEventPathParams,
  CreateEvent201,
  CreateEvent400,
  CreateEvent401,
  CreateEvent403,
  CreateEvent404,
  CreateEventMutationRequest,
  CreateEventMutationResponse,
  GetIntegrationResourcesPathParams,
  GetIntegrationResources200,
  GetIntegrationResources400,
  GetIntegrationResources401,
  GetIntegrationResources403,
  GetIntegrationResources404,
  GetIntegrationResourcesQueryResponse,
  GetIntegrationResourcePathParams,
  GetIntegrationResource200,
  GetIntegrationResource400,
  GetIntegrationResource401,
  GetIntegrationResource403,
  GetIntegrationResource404,
  GetIntegrationResourceQueryResponse,
  DeleteIntegrationResourcePathParams,
  DeleteIntegrationResource204,
  DeleteIntegrationResource400,
  DeleteIntegrationResource401,
  DeleteIntegrationResource403,
  DeleteIntegrationResource404,
  DeleteIntegrationResourceMutationResponse,
  ImportResourcePathParams,
  ImportResource200,
  ImportResource400,
  ImportResource401,
  ImportResource403,
  ImportResource404,
  ImportResourceMutationRequest,
  ImportResourceMutationResponse,
  SubmitBillingDataPathParams,
  SubmitBillingData201,
  SubmitBillingData400,
  SubmitBillingData401,
  SubmitBillingData403,
  SubmitBillingData404,
  SubmitBillingDataMutationRequest,
  SubmitBillingDataMutationResponse,
  SubmitInvoicePathParams,
  SubmitInvoice200,
  SubmitInvoice400,
  SubmitInvoice401,
  SubmitInvoice403,
  SubmitInvoice404,
  SubmitInvoiceMutationRequest,
  SubmitInvoiceMutationResponse,
  GetInvoicePathParams,
  GetInvoice200,
  GetInvoice400,
  GetInvoice401,
  GetInvoice403,
  GetInvoice404,
  GetInvoiceQueryResponse,
  UpdateInvoicePathParams,
  UpdateInvoice204,
  UpdateInvoice400,
  UpdateInvoice401,
  UpdateInvoice403,
  UpdateInvoice404,
  UpdateInvoiceMutationRequest,
  UpdateInvoiceMutationResponse,
  SubmitPrepaymentBalancesPathParams,
  SubmitPrepaymentBalances201,
  SubmitPrepaymentBalances400,
  SubmitPrepaymentBalances401,
  SubmitPrepaymentBalances403,
  SubmitPrepaymentBalances404,
  SubmitPrepaymentBalancesMutationRequest,
  SubmitPrepaymentBalancesMutationResponse,
  UpdateResourceSecretsPathParams,
  UpdateResourceSecrets201,
  UpdateResourceSecrets400,
  UpdateResourceSecrets401,
  UpdateResourceSecrets403,
  UpdateResourceSecrets404,
  UpdateResourceSecretsMutationRequest,
  UpdateResourceSecretsMutationResponse,
  UpdateResourceSecretsByIdPathParams,
  UpdateResourceSecretsById201,
  UpdateResourceSecretsById400,
  UpdateResourceSecretsById401,
  UpdateResourceSecretsById403,
  UpdateResourceSecretsById404,
  UpdateResourceSecretsById422,
  UpdateResourceSecretsByIdMutationRequest,
  UpdateResourceSecretsByIdMutationResponse,
  GetConfigurationsQueryParams,
  GetConfigurations200,
  GetConfigurations400,
  GetConfigurations401,
  GetConfigurations403,
  GetConfigurationsQueryResponse,
  GetConfigurationPathParams,
  GetConfigurationQueryParams,
  GetConfiguration200,
  GetConfiguration400,
  GetConfiguration401,
  GetConfiguration403,
  GetConfiguration404,
  GetConfigurationQueryResponse,
  DeleteConfigurationPathParams,
  DeleteConfigurationQueryParams,
  DeleteConfiguration204,
  DeleteConfiguration400,
  DeleteConfiguration401,
  DeleteConfiguration403,
  DeleteConfiguration404,
  DeleteConfigurationMutationResponse,
  ExchangeSsoToken200,
  ExchangeSsoToken400,
  ExchangeSsoToken404,
  ExchangeSsoToken500,
  ExchangeSsoTokenMutationRequest,
  ExchangeSsoTokenMutationResponse,
  GetIntegrationLogDrainsQueryParams,
  GetIntegrationLogDrains200,
  GetIntegrationLogDrains400,
  GetIntegrationLogDrains401,
  GetIntegrationLogDrains403,
  GetIntegrationLogDrainsQueryResponse,
  CreateLogDrainQueryParams,
  CreateLogDrain200,
  CreateLogDrain400,
  CreateLogDrain401,
  CreateLogDrain403,
  CreateLogDrainMutationRequest,
  CreateLogDrainMutationResponse,
  DeleteIntegrationLogDrainPathParams,
  DeleteIntegrationLogDrainQueryParams,
  DeleteIntegrationLogDrain204,
  DeleteIntegrationLogDrain400,
  DeleteIntegrationLogDrain401,
  DeleteIntegrationLogDrain403,
  DeleteIntegrationLogDrain404,
  DeleteIntegrationLogDrainMutationResponse,
  GetRuntimeLogsPathParams,
  GetRuntimeLogsQueryParams,
  GetRuntimeLogs200,
  GetRuntimeLogs400,
  GetRuntimeLogs401,
  GetRuntimeLogs403,
  GetRuntimeLogsQueryResponse,
  Postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsPathParams,
  Postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitems204,
  Postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitems400,
  Postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitems401,
  Postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitems403,
  Postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitems404,
  Postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsMutationRequest,
  Postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsMutationResponse,
  Patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemIdPathParams,
  Patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId204,
  Patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId400,
  Patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId401,
  Patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId403,
  Patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId404,
  Patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemIdMutationRequest,
  Patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemIdMutationResponse,
  Deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemIdPathParams,
  Deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId204,
  Deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId400,
  Deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId401,
  Deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId403,
  Deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId404,
  Deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemIdMutationResponse,
  HeadV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfigPathParams,
  HeadV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig200,
  HeadV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig304,
  HeadV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig400,
  HeadV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig401,
  HeadV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig403,
  HeadV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig404,
  HeadV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfigMutationResponse,
  Putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfigPathParams,
  Putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig200,
  Putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig400,
  Putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig401,
  Putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig403,
  Putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig404,
  Putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig412,
  Putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfigMutationRequest,
  Putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfigMutationResponse,
  GetProjectMembersPathParams,
  GetProjectMembersQueryParams,
  GetProjectMembers200,
  GetProjectMembers400,
  GetProjectMembers401,
  GetProjectMembers403,
  GetProjectMembersQueryResponse,
  AddProjectMemberPathParams,
  AddProjectMemberQueryParams,
  AddProjectMember200,
  AddProjectMember400,
  AddProjectMember401,
  AddProjectMember403,
  AddProjectMember500,
  AddProjectMemberMutationRequest,
  AddProjectMemberMutationResponse,
  RemoveProjectMemberPathParams,
  RemoveProjectMemberQueryParams,
  RemoveProjectMember200,
  RemoveProjectMember400,
  RemoveProjectMember401,
  RemoveProjectMember403,
  RemoveProjectMemberMutationResponse,
  GetProjectsQueryParams,
  GetProjects200,
  GetProjects400,
  GetProjects401,
  GetProjects403,
  GetProjectsQueryResponse,
  CreateProjectQueryParams,
  CreateProject200,
  CreateProject400,
  CreateProject401,
  CreateProject402,
  CreateProject403,
  CreateProject409,
  CreateProjectMutationRequest,
  CreateProjectMutationResponse,
  GetProjectPathParams,
  GetProjectQueryParams,
  GetProject200,
  GetProject400,
  GetProject401,
  GetProject403,
  GetProjectQueryResponse,
  UpdateProjectPathParams,
  UpdateProjectQueryParams,
  UpdateProject200,
  UpdateProject400,
  UpdateProject401,
  UpdateProject402,
  UpdateProject403,
  UpdateProject404,
  UpdateProject409,
  UpdateProject428,
  UpdateProjectMutationRequest,
  UpdateProjectMutationResponse,
  DeleteProjectPathParams,
  DeleteProjectQueryParams,
  DeleteProject204,
  DeleteProject400,
  DeleteProject401,
  DeleteProject403,
  DeleteProject409,
  DeleteProjectMutationResponse,
  CreateCustomEnvironmentPathParams,
  CreateCustomEnvironmentQueryParams,
  CreateCustomEnvironment201,
  CreateCustomEnvironment400,
  CreateCustomEnvironment401,
  CreateCustomEnvironment402,
  CreateCustomEnvironment403,
  CreateCustomEnvironment500,
  CreateCustomEnvironmentMutationRequest,
  CreateCustomEnvironmentMutationResponse,
  Getv9ProjectsidOrNamecustomEnvironmentsPathParams,
  Getv9ProjectsidOrNamecustomEnvironmentsQueryParams,
  Getv9ProjectsidOrNamecustomEnvironments200,
  Getv9ProjectsidOrNamecustomEnvironments400,
  Getv9ProjectsidOrNamecustomEnvironments401,
  Getv9ProjectsidOrNamecustomEnvironments403,
  Getv9ProjectsidOrNamecustomEnvironmentsQueryResponse,
  GetCustomEnvironmentPathParams,
  GetCustomEnvironmentQueryParams,
  GetCustomEnvironment200,
  GetCustomEnvironment400,
  GetCustomEnvironment401,
  GetCustomEnvironment403,
  GetCustomEnvironment404,
  GetCustomEnvironmentQueryResponse,
  UpdateCustomEnvironmentPathParams,
  UpdateCustomEnvironmentQueryParams,
  UpdateCustomEnvironment200,
  UpdateCustomEnvironment400,
  UpdateCustomEnvironment401,
  UpdateCustomEnvironment402,
  UpdateCustomEnvironment403,
  UpdateCustomEnvironment500,
  UpdateCustomEnvironmentMutationRequest,
  UpdateCustomEnvironmentMutationResponse,
  RemoveCustomEnvironmentPathParams,
  RemoveCustomEnvironmentQueryParams,
  RemoveCustomEnvironment200,
  RemoveCustomEnvironment400,
  RemoveCustomEnvironment401,
  RemoveCustomEnvironment403,
  RemoveCustomEnvironmentMutationRequest,
  RemoveCustomEnvironmentMutationResponse,
  GetProjectDomainsPathParams,
  GetProjectDomainsQueryParams,
  GetProjectDomains200,
  GetProjectDomains400,
  GetProjectDomains401,
  GetProjectDomains403,
  GetProjectDomainsQueryResponse,
  GetProjectDomainPathParams,
  GetProjectDomainQueryParams,
  GetProjectDomain200,
  GetProjectDomain400,
  GetProjectDomain401,
  GetProjectDomain403,
  GetProjectDomainQueryResponse,
  UpdateProjectDomainPathParams,
  UpdateProjectDomainQueryParams,
  UpdateProjectDomain200,
  UpdateProjectDomain400,
  UpdateProjectDomain401,
  UpdateProjectDomain403,
  UpdateProjectDomain409,
  UpdateProjectDomainMutationRequest,
  UpdateProjectDomainMutationResponse,
  RemoveProjectDomainPathParams,
  RemoveProjectDomainQueryParams,
  RemoveProjectDomain200,
  RemoveProjectDomain400,
  RemoveProjectDomain401,
  RemoveProjectDomain403,
  RemoveProjectDomain404,
  RemoveProjectDomain409,
  RemoveProjectDomainMutationRequest,
  RemoveProjectDomainMutationResponse,
  AddProjectDomainPathParams,
  AddProjectDomainQueryParams,
  AddProjectDomain200,
  AddProjectDomain400,
  AddProjectDomain401,
  AddProjectDomain402,
  AddProjectDomain403,
  AddProjectDomain409,
  AddProjectDomainMutationRequest,
  AddProjectDomainMutationResponse,
  MoveProjectDomainPathParams,
  MoveProjectDomainQueryParams,
  MoveProjectDomain200,
  MoveProjectDomain400,
  MoveProjectDomain401,
  MoveProjectDomain403,
  MoveProjectDomain409,
  MoveProjectDomainMutationRequest,
  MoveProjectDomainMutationResponse,
  VerifyProjectDomainPathParams,
  VerifyProjectDomainQueryParams,
  VerifyProjectDomain200,
  VerifyProjectDomain400,
  VerifyProjectDomain401,
  VerifyProjectDomain403,
  VerifyProjectDomainMutationResponse,
  FilterProjectEnvsPathParams,
  FilterProjectEnvsQueryParams,
  FilterProjectEnvs200,
  FilterProjectEnvs400,
  FilterProjectEnvs401,
  FilterProjectEnvs403,
  FilterProjectEnvsQueryResponse,
  CreateProjectEnvPathParams,
  CreateProjectEnvQueryParams,
  CreateProjectEnv201,
  CreateProjectEnv400,
  CreateProjectEnv401,
  CreateProjectEnv402,
  CreateProjectEnv403,
  CreateProjectEnv409,
  CreateProjectEnvMutationRequest,
  CreateProjectEnvMutationResponse,
  GetProjectEnvPathParams,
  GetProjectEnvQueryParams,
  GetProjectEnv200,
  GetProjectEnv400,
  GetProjectEnv401,
  GetProjectEnv403,
  GetProjectEnvQueryResponse,
  RemoveProjectEnvPathParams,
  RemoveProjectEnvQueryParams,
  RemoveProjectEnv200,
  RemoveProjectEnv400,
  RemoveProjectEnv401,
  RemoveProjectEnv403,
  RemoveProjectEnv404,
  RemoveProjectEnv409,
  RemoveProjectEnvMutationResponse,
  EditProjectEnvPathParams,
  EditProjectEnvQueryParams,
  EditProjectEnv200,
  EditProjectEnv400,
  EditProjectEnv401,
  EditProjectEnv403,
  EditProjectEnv409,
  EditProjectEnvMutationRequest,
  EditProjectEnvMutationResponse,
  GetRollingReleaseBillingStatusPathParams,
  GetRollingReleaseBillingStatusQueryParams,
  GetRollingReleaseBillingStatus200,
  GetRollingReleaseBillingStatus400,
  GetRollingReleaseBillingStatus401,
  GetRollingReleaseBillingStatus403,
  GetRollingReleaseBillingStatus404,
  GetRollingReleaseBillingStatusQueryResponse,
  GetRollingReleaseConfigPathParams,
  GetRollingReleaseConfigQueryParams,
  GetRollingReleaseConfig200,
  GetRollingReleaseConfig400,
  GetRollingReleaseConfig401,
  GetRollingReleaseConfig403,
  GetRollingReleaseConfig404,
  GetRollingReleaseConfigQueryResponse,
  DeleteRollingReleaseConfigPathParams,
  DeleteRollingReleaseConfigQueryParams,
  DeleteRollingReleaseConfig200,
  DeleteRollingReleaseConfig400,
  DeleteRollingReleaseConfig401,
  DeleteRollingReleaseConfig403,
  DeleteRollingReleaseConfig404,
  DeleteRollingReleaseConfigMutationResponse,
  UpdateRollingReleaseConfigPathParams,
  UpdateRollingReleaseConfigQueryParams,
  UpdateRollingReleaseConfig200,
  UpdateRollingReleaseConfig400,
  UpdateRollingReleaseConfig401,
  UpdateRollingReleaseConfig403,
  UpdateRollingReleaseConfig404,
  UpdateRollingReleaseConfigMutationResponse,
  GetRollingReleasePathParams,
  GetRollingReleaseQueryParams,
  GetRollingRelease200,
  GetRollingRelease400,
  GetRollingRelease401,
  GetRollingRelease403,
  GetRollingRelease404,
  GetRollingReleaseQueryResponse,
  ApproveRollingReleaseStagePathParams,
  ApproveRollingReleaseStageQueryParams,
  ApproveRollingReleaseStage200,
  ApproveRollingReleaseStage400,
  ApproveRollingReleaseStage401,
  ApproveRollingReleaseStage403,
  ApproveRollingReleaseStage404,
  ApproveRollingReleaseStage500,
  ApproveRollingReleaseStageMutationRequest,
  ApproveRollingReleaseStageMutationResponse,
  CompleteRollingReleasePathParams,
  CompleteRollingReleaseQueryParams,
  CompleteRollingRelease200,
  CompleteRollingRelease400,
  CompleteRollingRelease401,
  CompleteRollingRelease403,
  CompleteRollingRelease404,
  CompleteRollingReleaseMutationRequest,
  CompleteRollingReleaseMutationResponse,
  CreateProjectTransferRequestPathParams,
  CreateProjectTransferRequestQueryParams,
  CreateProjectTransferRequest200,
  CreateProjectTransferRequest400,
  CreateProjectTransferRequest401,
  CreateProjectTransferRequest403,
  CreateProjectTransferRequestMutationRequest,
  CreateProjectTransferRequestMutationResponse,
  AcceptProjectTransferRequestPathParams,
  AcceptProjectTransferRequestQueryParams,
  AcceptProjectTransferRequest202,
  AcceptProjectTransferRequest400,
  AcceptProjectTransferRequest401,
  AcceptProjectTransferRequest403,
  AcceptProjectTransferRequest404,
  AcceptProjectTransferRequest422,
  AcceptProjectTransferRequestMutationRequest,
  AcceptProjectTransferRequestMutationResponse,
  UpdateProjectProtectionBypassPathParams,
  UpdateProjectProtectionBypassQueryParams,
  UpdateProjectProtectionBypass200,
  UpdateProjectProtectionBypass400,
  UpdateProjectProtectionBypass401,
  UpdateProjectProtectionBypass403,
  UpdateProjectProtectionBypass404,
  UpdateProjectProtectionBypass409,
  UpdateProjectProtectionBypassMutationRequest,
  UpdateProjectProtectionBypassMutationResponse,
  RequestPromotePathParams,
  RequestPromoteQueryParams,
  RequestPromote201,
  RequestPromote202,
  RequestPromote400,
  RequestPromote401,
  RequestPromote403,
  RequestPromote409,
  RequestPromoteMutationResponse,
  ListPromoteAliasesPathParams,
  ListPromoteAliasesQueryParams,
  ListPromoteAliases200,
  ListPromoteAliases400,
  ListPromoteAliases401,
  ListPromoteAliases403,
  ListPromoteAliases404,
  ListPromoteAliasesQueryResponse,
  PauseProjectPathParams,
  PauseProjectQueryParams,
  PauseProject200,
  PauseProject400,
  PauseProject401,
  PauseProject402,
  PauseProject403,
  PauseProject500,
  PauseProjectMutationResponse,
  UnpauseProjectPathParams,
  UnpauseProjectQueryParams,
  UnpauseProject200,
  UnpauseProject400,
  UnpauseProject401,
  UnpauseProject403,
  UnpauseProject500,
  UnpauseProjectMutationResponse,
  UpdateAttackChallengeModeQueryParams,
  UpdateAttackChallengeMode200,
  UpdateAttackChallengeMode400,
  UpdateAttackChallengeMode401,
  UpdateAttackChallengeMode403,
  UpdateAttackChallengeMode404,
  UpdateAttackChallengeModeMutationRequest,
  UpdateAttackChallengeModeMutationResponse,
  PutFirewallConfigQueryParams,
  PutFirewallConfig200,
  PutFirewallConfig400,
  PutFirewallConfig401,
  PutFirewallConfig402,
  PutFirewallConfig403,
  PutFirewallConfig404,
  PutFirewallConfig500,
  PutFirewallConfigMutationRequest,
  PutFirewallConfigMutationResponse,
  UpdateFirewallConfigQueryParams,
  UpdateFirewallConfig200,
  UpdateFirewallConfig400,
  UpdateFirewallConfig401,
  UpdateFirewallConfig402,
  UpdateFirewallConfig403,
  UpdateFirewallConfig404,
  UpdateFirewallConfig500,
  UpdateFirewallConfigMutationRequest,
  UpdateFirewallConfigMutationResponse,
  GetFirewallConfigQueryParams,
  GetFirewallConfig200,
  GetFirewallConfig400,
  GetFirewallConfig401,
  GetFirewallConfig403,
  GetFirewallConfig404,
  GetFirewallConfigQueryResponse,
  GetActiveAttackStatusQueryParams,
  GetActiveAttackStatus200,
  GetActiveAttackStatus400,
  GetActiveAttackStatus401,
  GetActiveAttackStatus403,
  GetActiveAttackStatus404,
  GetActiveAttackStatusQueryResponse,
  GetBypassIpQueryParams,
  GetBypassIp200,
  GetBypassIp400,
  GetBypassIp401,
  GetBypassIp403,
  GetBypassIp404,
  GetBypassIp500,
  GetBypassIpQueryResponse,
  AddBypassIpQueryParams,
  AddBypassIp200,
  AddBypassIp400,
  AddBypassIp401,
  AddBypassIp403,
  AddBypassIp404,
  AddBypassIp500,
  AddBypassIpMutationRequest,
  AddBypassIpMutationResponse,
  RemoveBypassIpQueryParams,
  RemoveBypassIp200,
  RemoveBypassIp400,
  RemoveBypassIp401,
  RemoveBypassIp403,
  RemoveBypassIp404,
  RemoveBypassIp500,
  RemoveBypassIpMutationRequest,
  RemoveBypassIpMutationResponse,
  GetTeamMembersQueryParams,
  GetTeamMembers200,
  GetTeamMembers400,
  GetTeamMembers401,
  GetTeamMembers403,
  GetTeamMembers404,
  GetTeamMembersQueryResponse,
  InviteUserToTeam200,
  InviteUserToTeam400,
  InviteUserToTeam401,
  InviteUserToTeam403,
  InviteUserToTeam503,
  InviteUserToTeamMutationRequest,
  InviteUserToTeamMutationResponse,
  RequestAccessToTeam200,
  RequestAccessToTeam400,
  RequestAccessToTeam401,
  RequestAccessToTeam403,
  RequestAccessToTeam404,
  RequestAccessToTeam503,
  RequestAccessToTeamMutationRequest,
  RequestAccessToTeamMutationResponse,
  GetTeamAccessRequestPathParams,
  GetTeamAccessRequest200,
  GetTeamAccessRequest400,
  GetTeamAccessRequest401,
  GetTeamAccessRequest403,
  GetTeamAccessRequest404,
  GetTeamAccessRequestQueryResponse,
  JoinTeam200,
  JoinTeam400,
  JoinTeam401,
  JoinTeam402,
  JoinTeam403,
  JoinTeam404,
  JoinTeamMutationRequest,
  JoinTeamMutationResponse,
  UpdateTeamMemberPathParams,
  UpdateTeamMember200,
  UpdateTeamMember400,
  UpdateTeamMember401,
  UpdateTeamMember402,
  UpdateTeamMember403,
  UpdateTeamMember404,
  UpdateTeamMember500,
  UpdateTeamMemberMutationRequest,
  UpdateTeamMemberMutationResponse,
  RemoveTeamMemberPathParams,
  RemoveTeamMemberQueryParams,
  RemoveTeamMember200,
  RemoveTeamMember400,
  RemoveTeamMember401,
  RemoveTeamMember403,
  RemoveTeamMember404,
  RemoveTeamMember503,
  RemoveTeamMemberMutationResponse,
  GetTeamPathParams,
  GetTeamQueryParams,
  GetTeam200,
  GetTeam400,
  GetTeam401,
  GetTeam403,
  GetTeam404,
  GetTeamQueryResponse,
  PatchTeamPathParams,
  PatchTeamQueryParams,
  PatchTeam200,
  PatchTeam400,
  PatchTeam401,
  PatchTeam402,
  PatchTeam403,
  PatchTeam428,
  PatchTeamMutationRequest,
  PatchTeamMutationResponse,
  GetTeamsQueryParams,
  GetTeams200,
  GetTeams400,
  GetTeams401,
  GetTeams403,
  GetTeamsQueryResponse,
  CreateTeam200,
  CreateTeam400,
  CreateTeam401,
  CreateTeam403,
  CreateTeamMutationRequest,
  CreateTeamMutationResponse,
  DeleteTeamPathParams,
  DeleteTeamQueryParams,
  DeleteTeam200,
  DeleteTeam400,
  DeleteTeam401,
  DeleteTeam402,
  DeleteTeam403,
  DeleteTeam409,
  DeleteTeamMutationRequest,
  DeleteTeamMutationResponse,
  DeleteTeamInviteCodePathParams,
  DeleteTeamInviteCode200,
  DeleteTeamInviteCode400,
  DeleteTeamInviteCode401,
  DeleteTeamInviteCode403,
  DeleteTeamInviteCode404,
  DeleteTeamInviteCodeMutationResponse,
  UploadFileQueryParams,
  UploadFileHeaderParams,
  UploadFile200,
  UploadFile400,
  UploadFile401,
  UploadFile403,
  UploadFileMutationResponse,
  ListAuthTokens200,
  ListAuthTokens400,
  ListAuthTokens401,
  ListAuthTokens403,
  ListAuthTokensQueryResponse,
  CreateAuthTokenQueryParams,
  CreateAuthToken200,
  CreateAuthToken400,
  CreateAuthToken401,
  CreateAuthToken403,
  CreateAuthTokenMutationRequest,
  CreateAuthTokenMutationResponse,
  GetAuthTokenPathParams,
  GetAuthToken200,
  GetAuthToken400,
  GetAuthToken401,
  GetAuthToken403,
  GetAuthToken404,
  GetAuthTokenQueryResponse,
  DeleteAuthTokenPathParams,
  DeleteAuthToken200,
  DeleteAuthToken400,
  DeleteAuthToken401,
  DeleteAuthToken403,
  DeleteAuthToken404,
  DeleteAuthTokenMutationResponse,
  GetAuthUser200,
  GetAuthUser400,
  GetAuthUser401,
  GetAuthUser403,
  GetAuthUser409,
  GetAuthUserQueryResponse,
  RequestDelete202,
  RequestDelete400,
  RequestDelete401,
  RequestDelete402,
  RequestDelete403,
  RequestDeleteMutationRequest,
  RequestDeleteMutationResponse,
  CreateWebhookQueryParams,
  CreateWebhook200,
  CreateWebhook400,
  CreateWebhook401,
  CreateWebhook403,
  CreateWebhookMutationRequest,
  CreateWebhookMutationResponse,
  GetWebhooksQueryParams,
  GetWebhooks200,
  GetWebhooks400,
  GetWebhooks401,
  GetWebhooks403,
  GetWebhooksQueryResponse,
  GetWebhookPathParams,
  GetWebhookQueryParams,
  GetWebhook200,
  GetWebhook400,
  GetWebhook401,
  GetWebhook403,
  GetWebhookQueryResponse,
  DeleteWebhookPathParams,
  DeleteWebhookQueryParams,
  DeleteWebhook204,
  DeleteWebhook400,
  DeleteWebhook401,
  DeleteWebhook403,
  DeleteWebhookMutationResponse,
  ListDeploymentAliasesPathParams,
  ListDeploymentAliasesQueryParams,
  ListDeploymentAliases200,
  ListDeploymentAliases400,
  ListDeploymentAliases401,
  ListDeploymentAliases403,
  ListDeploymentAliases404,
  ListDeploymentAliasesQueryResponse,
  AssignAliasPathParams,
  AssignAliasQueryParams,
  AssignAlias200,
  AssignAlias400,
  AssignAlias401,
  AssignAlias402,
  AssignAlias403,
  AssignAlias404,
  AssignAlias409,
  AssignAliasMutationRequest,
  AssignAliasMutationResponse,
  ListAliasesQueryParams,
  ListAliases200,
  ListAliases400,
  ListAliases401,
  ListAliases403,
  ListAliases404,
  ListAliasesQueryResponse,
  GetAliasPathParams,
  GetAliasQueryParams,
  GetAlias200,
  GetAlias400,
  GetAlias401,
  GetAlias403,
  GetAlias404,
  GetAliasQueryResponse,
  DeleteAliasPathParams,
  DeleteAliasQueryParams,
  DeleteAlias200,
  DeleteAlias400,
  DeleteAlias401,
  DeleteAlias403,
  DeleteAlias404,
  DeleteAliasMutationResponse,
  PatchUrlProtectionBypassPathParams,
  PatchUrlProtectionBypassQueryParams,
  PatchUrlProtectionBypass200,
  PatchUrlProtectionBypass400,
  PatchUrlProtectionBypass401,
  PatchUrlProtectionBypass403,
  PatchUrlProtectionBypass404,
  PatchUrlProtectionBypass409,
  PatchUrlProtectionBypass428,
  PatchUrlProtectionBypass500,
  PatchUrlProtectionBypassMutationRequest,
  PatchUrlProtectionBypassMutationResponse,
  Getcerts200,
  Getcerts400,
  Getcerts401,
  Getcerts403,
  GetcertsQueryResponse,
  GetCertByIdPathParams,
  GetCertByIdQueryParams,
  GetCertById200,
  GetCertById400,
  GetCertById401,
  GetCertById403,
  GetCertById404,
  GetCertByIdQueryResponse,
  RemoveCertPathParams,
  RemoveCertQueryParams,
  RemoveCert200,
  RemoveCert400,
  RemoveCert401,
  RemoveCert403,
  RemoveCert404,
  RemoveCertMutationResponse,
  IssueCertQueryParams,
  IssueCert200,
  IssueCert400,
  IssueCert401,
  IssueCert402,
  IssueCert403,
  IssueCert404,
  IssueCert449,
  IssueCert500,
  IssueCertMutationRequest,
  IssueCertMutationResponse,
  UploadCertQueryParams,
  UploadCert200,
  UploadCert400,
  UploadCert401,
  UploadCert402,
  UploadCert403,
  UploadCertMutationRequest,
  UploadCertMutationResponse,
  ListDeploymentFilesPathParams,
  ListDeploymentFilesQueryParams,
  ListDeploymentFiles200,
  ListDeploymentFiles400,
  ListDeploymentFiles401,
  ListDeploymentFiles403,
  ListDeploymentFiles404,
  ListDeploymentFilesQueryResponse,
  GetDeploymentFileContentsPathParams,
  GetDeploymentFileContentsQueryParams,
  GetDeploymentFileContents400,
  GetDeploymentFileContents401,
  GetDeploymentFileContents403,
  GetDeploymentFileContents404,
  GetDeploymentFileContents410,
  GetDeploymentFileContentsQueryResponse,
  GetDeploymentsQueryParams,
  GetDeployments200,
  GetDeployments400,
  GetDeployments401,
  GetDeployments403,
  GetDeployments404,
  GetDeployments422,
  GetDeploymentsQueryResponse,
  DeleteDeploymentPathParams,
  DeleteDeploymentQueryParams,
  DeleteDeployment200,
  DeleteDeployment400,
  DeleteDeployment401,
  DeleteDeployment403,
  DeleteDeployment404,
  DeleteDeploymentMutationResponse,
  GetSecretsQueryParams,
  GetSecrets200,
  GetSecrets400,
  GetSecrets401,
  GetSecrets403,
  GetSecrets410,
  GetSecretsQueryResponse,
  CreateSecretQueryParams,
  CreateSecret200,
  CreateSecret400,
  CreateSecret401,
  CreateSecret402,
  CreateSecret403,
  CreateSecret410,
  CreateSecretMutationRequest,
  CreateSecretMutationResponse,
  RenameSecretPathParams,
  RenameSecretQueryParams,
  RenameSecret200,
  RenameSecret400,
  RenameSecret401,
  RenameSecret403,
  RenameSecret410,
  RenameSecretMutationRequest,
  RenameSecretMutationResponse,
  GetSecretPathParams,
  GetSecretQueryParams,
  GetSecret200,
  GetSecret400,
  GetSecret401,
  GetSecret403,
  GetSecret404,
  GetSecret410,
  GetSecretQueryResponse,
  DeleteSecretPathParams,
  DeleteSecretQueryParams,
  DeleteSecret200,
  DeleteSecret400,
  DeleteSecret401,
  DeleteSecret403,
  DeleteSecret410,
  DeleteSecretMutationResponse,
} from './types.ts'
import type { ToZod } from '@kubb/plugin-zod/utils'
import { z } from 'zod'

/**
 * @description Enum containing the actions that can be performed against a resource. Group operations are included.
 */
export const ACLActionSchema = z
  .enum(['create', 'delete', 'list', 'read', 'update'])
  .describe('Enum containing the actions that can be performed against a resource. Group operations are included.') as unknown as ToZod<ACLAction>

export const flagJSONValueSchema = z
  .union([
    z.boolean(),
    z.array(z.lazy(() => flagJSONValueSchema).nullable()),
    z.string(),
    z.number(),
    z.object({}).catchall(z.lazy(() => flagJSONValueSchema).nullable()),
  ])
  .nullable() as unknown as ToZod<FlagJSONValue>

/**
 * @description This object contains information related to the pagination of the current request, including the necessary parameters to get the next or previous page of data.
 */
export const paginationSchema = z
  .object({
    count: z.number().describe('Amount of items in the current page.'),
    next: z.number().describe('Timestamp that must be used to request the next page.').nullable(),
    prev: z.number().describe('Timestamp that must be used to request the previous page.').nullable(),
  })
  .describe(
    'This object contains information related to the pagination of the current request, including the necessary parameters to get the next or previous page of data.',
  ) as unknown as ToZod<Pagination>

export const edgeConfigItemValueSchema = z
  .union([
    z.boolean(),
    z.array(z.lazy(() => edgeConfigItemValueSchema).nullable()),
    z.string(),
    z.number(),
    z.object({}).catchall(z.lazy(() => edgeConfigItemValueSchema).nullable()),
  ])
  .nullable() as unknown as ToZod<EdgeConfigItemValue>

/**
 * @description The EdgeConfig.
 */
export const edgeConfigItemSchema = z
  .object({
    key: z.string(),
    value: z.lazy(() => edgeConfigItemValueSchema).nullable(),
    description: z.string().optional(),
    edgeConfigId: z.string(),
    createdAt: z.number(),
    updatedAt: z.number(),
  })
  .describe('The EdgeConfig.') as unknown as ToZod<EdgeConfigItem>

/**
 * @description The EdgeConfig.
 */
export const edgeConfigTokenSchema = z
  .object({
    token: z.string(),
    label: z.string(),
    id: z.string().describe('This is not the token itself, but rather an id to identify the token by'),
    edgeConfigId: z.string(),
    createdAt: z.number(),
  })
  .describe('The EdgeConfig.') as unknown as ToZod<EdgeConfigToken>

/**
 * @description Array of events generated by the User.
 */
export const userEventSchema = z
  .object({
    id: z.string().describe('The unique identifier of the Event.'),
    text: z.string().describe('The human-readable text of the Event.'),
    entities: z
      .array(
        z
          .object({
            type: z
              .enum([
                'author',
                'bitbucket_login',
                'bold',
                'deployment_host',
                'dns_record',
                'edge-config',
                'env_var_name',
                'flag',
                'flags-segment',
                'flags-settings',
                'git_link',
                'github_login',
                'gitlab_login',
                'hook_name',
                'integration',
                'link',
                'project_name',
                'scaling_rules',
                'store',
                'system',
                'target',
              ])
              .describe('The type of entity.'),
            start: z.number().describe('The index of where the entity begins within the `text` (inclusive).'),
            end: z.number().describe('The index of where the entity ends within the `text` (non-inclusive).'),
          })
          .describe('A list of "entities" within the event `text`. Useful for enhancing the displayed text with additional styling and links.'),
      )
      .describe('A list of "entities" within the event `text`. Useful for enhancing the displayed text with additional styling and links.'),
    createdAt: z.number().describe('Timestamp (in milliseconds) of when the event was generated.'),
    user: z
      .object({
        username: z.string(),
        avatar: z.string(),
        email: z.string(),
        slug: z.string().optional(),
        uid: z.string(),
      })
      .describe('Metadata for {@link userId}.')
      .optional(),
    principal: z
      .union([
        z.object({
          type: z.enum(['user']).optional(),
          avatar: z.string(),
          email: z.string(),
          slug: z.string().optional(),
          uid: z.string(),
          username: z.string(),
        }),
        z.object({
          type: z.enum(['app']),
          clientId: z.string(),
          name: z.string(),
        }),
      ])
      .optional(),
    via: z
      .array(
        z.union([
          z.object({
            type: z.enum(['user']).optional(),
            avatar: z.string(),
            email: z.string(),
            slug: z.string().optional(),
            uid: z.string(),
            username: z.string(),
          }),
          z.object({
            type: z.enum(['app']),
            clientId: z.string(),
            name: z.string(),
          }),
        ]),
      )
      .describe('Metadata for {@link viaIds}.')
      .optional(),
    userId: z.string().describe('When the principal who generated the event is a user, this is their ID; otherwise, it is empty.'),
    principalId: z
      .string()
      .describe(
        'The ID of the principal who generated the event. The principal is typically a user, but it could also be an app, an integration, etc. The principal may have delegated its authority to an acting party, and so {@link viaIds} should be checked as well.',
      ),
    viaIds: z
      .array(z.string())
      .describe(
        'If the principal delegated its authority (for example, a user delegating to an app), then this array contains the ID of the current actor. For example, if `principalId` is "user123" and `viaIds` is `["app456"]`, we can say the event was triggered by - "app456 on behalf of user123", or - "user123 via app4556". Both are equivalent. Arbitrarily long chains of delegation can be represented. For example, if `principalId` is "user123" and `viaIds` is `["service1", "service2"]`, we can say the event was triggered by "user123 via service1 via service2".',
      )
      .optional(),
    payload: z
      .union([
        z.object({}),
        z.object({
          action: z.enum(['created', 'updated', 'deleted', 'archived', 'unarchived']),
          id: z.string(),
          slug: z.string(),
          projectId: z.string(),
        }),
        z.object({
          accessGroup: z.object({
            id: z.string(),
            name: z.string(),
          }),
        }),
        z.object({
          author: z.string(),
          accessGroup: z.object({
            id: z.string(),
            name: z.string(),
          }),
        }),
        z.object({
          accessGroup: z.object({
            id: z.string(),
            name: z.string().optional(),
          }),
          user: z.object({
            id: z.string(),
            username: z.string().optional(),
          }),
          directoryType: z.string().optional(),
        }),
        z.object({
          accessGroup: z.object({
            id: z.string(),
            name: z.string(),
          }),
          project: z.object({
            id: z.string(),
            name: z.string().optional(),
          }),
          next_role: z.enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER']).nullable().nullish(),
          previous_role: z.enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER']).optional(),
        }),
        z.object({
          alias: z.string().optional(),
          deployment: z
            .object({
              id: z.string(),
              name: z.string(),
              url: z.string(),
              meta: z.object({}).catchall(z.string()),
            })
            .nullable()
            .nullish(),
          ruleCount: z.number().optional(),
          deploymentUrl: z.string().optional(),
          aliasId: z.string().optional(),
          deploymentId: z.string().nullable().nullish(),
          oldDeploymentId: z.string().nullable().nullish(),
          redirect: z.string().optional(),
          redirectStatusCode: z.number().nullable().nullish(),
          target: z.string().nullable().nullish(),
          system: z.boolean().optional(),
          aliasUpdatedAt: z.number().optional(),
        }),
        z.object({
          aliasId: z.string().optional(),
          alias: z.string().optional(),
          projectName: z.string().optional(),
        }),
        z.object({
          alias: z.string().optional(),
        }),
        z.object({
          alias: z.string().optional(),
          userId: z.string().optional(),
          username: z.string().optional(),
        }),
        z.object({
          alias: z.string().optional(),
          aliasId: z.string().optional(),
          userId: z.string().optional(),
          username: z.string().optional(),
        }),
        z.object({
          projectName: z.string(),
          alias: z.string(),
          action: z.enum(['created', 'removed']),
        }),
        z.object({
          alias: z.string().optional(),
          email: z.string().optional(),
          username: z.string().optional(),
        }),
        z.object({
          alias: z.string().optional(),
          email: z.string().optional(),
        }),
        z.object({
          name: z.string().optional(),
          alias: z.string(),
          oldTeam: z
            .object({
              name: z.string(),
            })
            .optional(),
          newTeam: z
            .object({
              name: z.string(),
            })
            .optional(),
        }),
        z.object({
          name: z.string().optional(),
          alias: z.string(),
          aliasId: z.string(),
          deploymentId: z.string().nullable(),
        }),
        z.object({
          alias: z.string(),
          deploymentUrl: z.string(),
        }),
        z.object({
          projectName: z.string(),
          autoExposeSystemEnvs: z.boolean(),
        }),
        z.object({
          avatar: z.string().optional(),
        }),
        z.object({
          cn: z.string().optional(),
          cns: z.array(z.string()).optional(),
          custom: z.boolean(),
          id: z.string().optional(),
        }),
        z.object({
          cn: z.string().optional(),
          cns: z.array(z.string()).optional(),
          id: z.string().optional(),
        }),
        z.object({
          id: z.string(),
          oldTeam: z
            .object({
              name: z.string(),
            })
            .optional(),
          newTeam: z
            .object({
              name: z.string(),
            })
            .optional(),
        }),
        z.object({
          src: z.string(),
          dst: z.string(),
        }),
        z.object({
          id: z.string(),
          cn: z.string().optional(),
          cns: z.array(z.string()).optional(),
        }),
        z.object({
          cn: z.string().optional(),
          cns: z.array(z.string()).optional(),
        }),
        z.object({
          reason: z.string().optional(),
          suffix: z.string(),
        }),
        z.object({
          status: z.string(),
          suffix: z.string(),
        }),
        z.object({
          suffix: z.string(),
        }),
        z.object({
          team: z.object({
            id: z.string(),
            name: z.string(),
          }),
          configuration: z.object({
            id: z.string(),
            name: z.string().optional(),
          }),
          project: z.object({
            id: z.string(),
            name: z.string().optional(),
          }),
          buildsEnabled: z.boolean().optional(),
        }),
        z.object({
          team: z.object({
            id: z.string(),
            name: z.string(),
          }),
          configuration: z.object({
            id: z.string(),
            name: z.string().optional(),
          }),
          project: z.object({
            id: z.string(),
            name: z.string().optional(),
          }),
          buildsEnabled: z.boolean().optional(),
          passive: z.boolean().optional(),
        }),
        z.object({
          team: z.object({
            id: z.string(),
            name: z.string(),
          }),
          configuration: z.object({
            id: z.string(),
            name: z.string().optional(),
          }),
          project: z.object({
            id: z.string(),
            name: z.string().optional(),
          }),
        }),
        z.object({
          team: z.object({
            id: z.string(),
            name: z.string(),
          }),
          configuration: z.object({
            id: z.string(),
            name: z.string().optional(),
          }),
          newName: z.string(),
        }),
        z.object({
          githubLogin: z.string(),
        }),
        z.object({
          gitlabLogin: z.string(),
          gitlabEmail: z.string(),
          gitlabName: z.string().optional(),
        }),
        z.object({
          bitbucketEmail: z.string(),
          bitbucketLogin: z.string(),
          bitbucketName: z.string().optional(),
        }),
        z.object({
          project: z.object({
            name: z.string(),
          }),
          job: z.object({
            deployHook: z.object({
              createdAt: z.number(),
              id: z.string(),
              name: z.string(),
              ref: z.string(),
            }),
            state: z.string(),
          }),
        }),
        z.object({
          name: z.string().optional(),
          alias: z.array(z.string()).optional(),
          target: z.string().nullable().nullish(),
          deployment: z
            .object({
              id: z.string(),
              name: z.string(),
              url: z.string(),
              meta: z.object({}).catchall(z.string()),
            })
            .nullable()
            .nullish(),
          url: z.string(),
          forced: z.boolean().optional(),
          deploymentId: z.string().optional(),
          plan: z.string().optional(),
          project: z.string().optional(),
          projectId: z.string().optional(),
          regions: z.array(z.string()).optional(),
          type: z.string().optional(),
        }),
        z.object({
          url: z.string(),
          oldTeam: z
            .object({
              name: z.string(),
            })
            .optional(),
          newTeam: z
            .object({
              name: z.string(),
            })
            .optional(),
        }),
        z.object({
          deployment: z.object({
            id: z.string(),
            name: z.string(),
            url: z.string(),
            meta: z.object({}).catchall(z.string()),
          }),
          deploymentId: z.string(),
          url: z.string(),
        }),
        z.object({
          id: z.string(),
          value: z.string(),
          name: z.string(),
          domain: z.string(),
          type: z.string(),
          mxPriority: z.number().optional(),
        }),
        z.object({
          id: z.string(),
          domain: z.string(),
        }),
        z.object({
          id: z.string(),
          value: z.string(),
          name: z.string(),
          domain: z.string(),
          type: z.string(),
        }),
        z.object({
          name: z.string(),
        }),
        z.object({
          name: z.string(),
          price: z.number(),
          currency: z.string().optional(),
        }),
        z.object({
          name: z.string(),
          cdnEnabled: z.boolean(),
        }),
        z.object({
          name: z.string(),
          userId: z.string(),
          teamId: z.string(),
          ownerName: z.string(),
        }),
        z.object({
          name: z.string(),
          oldTeam: z
            .object({
              name: z.string(),
            })
            .optional(),
          newTeam: z
            .object({
              name: z.string(),
            })
            .optional(),
        }),
        z.object({
          domainId: z.string(),
          name: z.string(),
        }),
        z.object({
          name: z.string(),
          fromId: z.string().nullable(),
          fromName: z.string().nullable(),
        }),
        z.object({
          name: z.string(),
          destinationId: z.string().nullable(),
          destinationName: z.string().nullable(),
        }),
        z.object({
          name: z.string(),
          destinationId: z.string(),
          destinationName: z.string(),
        }),
        z.object({
          renew: z.boolean().optional(),
          domain: z.string(),
        }),
        z.object({
          name: z.string(),
          price: z.number().optional(),
          currency: z.string().optional(),
        }),
        z.object({
          sha: z.string(),
          gitUserPlatform: z.string(),
          projectName: z.string(),
        }),
        z.object({
          email: z.string(),
          name: z.string(),
        }),
        z.object({
          key: z.string().optional(),
          projectId: z.string().optional(),
          projectName: z.string().optional(),
          target: z.union([z.array(z.string()), z.string()]).optional(),
          id: z.string().optional(),
          gitBranch: z.string().optional(),
          edgeConfigId: z.string().nullable().nullish(),
          edgeConfigTokenId: z.string().nullable().nullish(),
          source: z.string().optional(),
        }),
        z.object({
          created: z.date().describe('The date when the Shared Env Var was created.').optional(),
          key: z.string().describe('The name of the Shared Env Var.').optional(),
          ownerId: z.string().describe('The unique identifier of the owner (team) the Shared Env Var was created for.').nullable().nullish(),
          id: z.string().describe('The unique identifier of the Shared Env Var.').optional(),
          createdBy: z.string().describe('The unique identifier of the user who created the Shared Env Var.').nullable().nullish(),
          deletedBy: z.string().describe('The unique identifier of the user who deleted the Shared Env Var.').nullable().nullish(),
          updatedBy: z.string().describe('The unique identifier of the user who last updated the Shared Env Var.').nullable().nullish(),
          createdAt: z.number().describe('Timestamp for when the Shared Env Var was created.').optional(),
          deletedAt: z.number().describe('Timestamp for when the Shared Env Var was (soft) deleted.').optional(),
          updatedAt: z.number().describe('Timestamp for when the Shared Env Var was last updated.').optional(),
          value: z.string().describe('The value of the Shared Env Var.').optional(),
          projectId: z.array(z.string()).describe('The unique identifiers of the projects which the Shared Env Var is linked to.').optional(),
          type: z.enum(['system', 'encrypted', 'plain', 'sensitive']).describe('The type of this cosmos doc instance, if blank, assume secret.').optional(),
          target: z
            .array(z.enum(['production', 'preview', 'development']).describe('environments this env variable targets'))
            .describe('environments this env variable targets')
            .optional(),
          applyToAllCustomEnvironments: z.boolean().describe('whether or not this env varible applies to custom environments').optional(),
          decrypted: z.boolean().describe('whether or not this env variable is decrypted').optional(),
          comment: z.string().describe('A user provided comment that describes what this Shared Env Var is for.').optional(),
          lastEditedByDisplayName: z.string().describe('The last editor full name or username.').optional(),
          projectNames: z.array(z.string()).optional(),
        }),
        z.object({
          oldEnvVar: z
            .object({
              created: z.date().describe('The date when the Shared Env Var was created.').optional(),
              key: z.string().describe('The name of the Shared Env Var.').optional(),
              ownerId: z.string().describe('The unique identifier of the owner (team) the Shared Env Var was created for.').nullable().nullish(),
              id: z.string().describe('The unique identifier of the Shared Env Var.').optional(),
              createdBy: z.string().describe('The unique identifier of the user who created the Shared Env Var.').nullable().nullish(),
              deletedBy: z.string().describe('The unique identifier of the user who deleted the Shared Env Var.').nullable().nullish(),
              updatedBy: z.string().describe('The unique identifier of the user who last updated the Shared Env Var.').nullable().nullish(),
              createdAt: z.number().describe('Timestamp for when the Shared Env Var was created.').optional(),
              deletedAt: z.number().describe('Timestamp for when the Shared Env Var was (soft) deleted.').optional(),
              updatedAt: z.number().describe('Timestamp for when the Shared Env Var was last updated.').optional(),
              value: z.string().describe('The value of the Shared Env Var.').optional(),
              projectId: z.array(z.string()).describe('The unique identifiers of the projects which the Shared Env Var is linked to.').optional(),
              type: z.enum(['system', 'encrypted', 'plain', 'sensitive']).describe('The type of this cosmos doc instance, if blank, assume secret.').optional(),
              target: z
                .array(z.enum(['production', 'preview', 'development']).describe('environments this env variable targets'))
                .describe('environments this env variable targets')
                .optional(),
              applyToAllCustomEnvironments: z.boolean().describe('whether or not this env varible applies to custom environments').optional(),
              decrypted: z.boolean().describe('whether or not this env variable is decrypted').optional(),
              comment: z.string().describe('A user provided comment that describes what this Shared Env Var is for.').optional(),
              lastEditedByDisplayName: z.string().describe('The last editor full name or username.').optional(),
            })
            .optional(),
          newEnvVar: z
            .object({
              created: z.date().describe('The date when the Shared Env Var was created.').optional(),
              key: z.string().describe('The name of the Shared Env Var.').optional(),
              ownerId: z.string().describe('The unique identifier of the owner (team) the Shared Env Var was created for.').nullable().nullish(),
              id: z.string().describe('The unique identifier of the Shared Env Var.').optional(),
              createdBy: z.string().describe('The unique identifier of the user who created the Shared Env Var.').nullable().nullish(),
              deletedBy: z.string().describe('The unique identifier of the user who deleted the Shared Env Var.').nullable().nullish(),
              updatedBy: z.string().describe('The unique identifier of the user who last updated the Shared Env Var.').nullable().nullish(),
              createdAt: z.number().describe('Timestamp for when the Shared Env Var was created.').optional(),
              deletedAt: z.number().describe('Timestamp for when the Shared Env Var was (soft) deleted.').optional(),
              updatedAt: z.number().describe('Timestamp for when the Shared Env Var was last updated.').optional(),
              value: z.string().describe('The value of the Shared Env Var.').optional(),
              projectId: z.array(z.string()).describe('The unique identifiers of the projects which the Shared Env Var is linked to.').optional(),
              type: z.enum(['system', 'encrypted', 'plain', 'sensitive']).describe('The type of this cosmos doc instance, if blank, assume secret.').optional(),
              target: z
                .array(z.enum(['production', 'preview', 'development']).describe('environments this env variable targets'))
                .describe('environments this env variable targets')
                .optional(),
              applyToAllCustomEnvironments: z.boolean().describe('whether or not this env varible applies to custom environments').optional(),
              decrypted: z.boolean().describe('whether or not this env variable is decrypted').optional(),
              comment: z.string().describe('A user provided comment that describes what this Shared Env Var is for.').optional(),
              lastEditedByDisplayName: z.string().describe('The last editor full name or username.').optional(),
            })
            .optional(),
          updateDiff: z
            .object({
              id: z.string(),
              key: z.string().optional(),
              newKey: z.string().optional(),
              oldTarget: z.array(z.enum(['production', 'preview', 'development'])).optional(),
              newTarget: z.array(z.enum(['production', 'preview', 'development'])).optional(),
              oldType: z.string().optional(),
              newType: z.string().optional(),
              oldProjects: z
                .array(
                  z.object({
                    projectName: z.string().optional(),
                    projectId: z.string(),
                  }),
                )
                .optional(),
              newProjects: z
                .array(
                  z.object({
                    projectName: z.string().optional(),
                    projectId: z.string(),
                  }),
                )
                .optional(),
              changedValue: z.boolean(),
            })
            .optional(),
        }),
        z.object({
          projectId: z.string(),
          restore: z.boolean(),
          configVersion: z.number(),
          configChangeCount: z.number(),
          configChanges: z.array(z.object({})),
        }),
        z.object({
          projectId: z.string(),
          scope: z.string(),
          source: z.string(),
        }),
        z.object({
          projectId: z.string(),
          rulesetName: z.string(),
          active: z.boolean(),
          action: z.enum(['log', 'challenge', 'deny']).optional(),
        }),
        z.object({
          projectId: z.string(),
          rulesetName: z.string(),
          ruleGroups: z.object({}).catchall(
            z.object({
              active: z.boolean(),
              action: z.enum(['log', 'challenge', 'deny']).optional(),
            }),
          ),
        }),
        z.object({
          integrationId: z.string(),
          integrationSlug: z.string(),
          integrationName: z.string(),
        }),
        z.object({
          userId: z.string(),
          integrationId: z.string(),
          configurationId: z.string(),
          integrationSlug: z.string(),
          integrationName: z.string().optional(),
          newOwner: z
            .object({
              abuse: z
                .object({
                  blockHistory: z
                    .array(
                      z
                        .object({
                          action: z.enum(['hard-blocked', 'soft-blocked', 'unblocked']),
                          createdAt: z.number(),
                          caseId: z.string().optional(),
                          reason: z.string(),
                          actor: z.string().optional(),
                          statusCode: z.number().optional(),
                          comment: z.string().optional(),
                        })
                        .describe('Since June 2023'),
                    )
                    .describe('Since June 2023')
                    .optional(),
                  gitAuthHistory: z
                    .array(z.string())
                    .describe('Since March 2022. Helps abuse checks by tracking git auths. Format: `<platform>:<detail>:<value>`')
                    .optional(),
                  history: z
                    .array(
                      z
                        .object({
                          scanner: z.string(),
                          reason: z.string(),
                          by: z.string(),
                          byId: z.string(),
                          at: z.number(),
                        })
                        .describe('(scanner history). Since November 2021. First element is newest.'),
                    )
                    .describe('(scanner history). Since November 2021. First element is newest.')
                    .optional(),
                  gitLineageBlocks: z
                    .number()
                    .describe('Since September 2023. How often did this owner trigger an actual git lineage deploy block?')
                    .optional(),
                  gitLineageBlocksDry: z
                    .number()
                    .describe('Since September 2023. How often did this owner trigger a git lineage deploy block dry run?')
                    .optional(),
                  scanner: z.string().describe('Since November 2021. Guides the abuse scanner in build container.').optional(),
                  updatedAt: z.number().describe('Since November 2021').optional(),
                  creationUserAgent: z.string().optional(),
                  creationIp: z.string().optional(),
                  removedPhoneNumbers: z.string().optional(),
                })
                .optional(),
              acceptanceState: z.string().optional(),
              acceptedAt: z.number().optional(),
              avatar: z.string().optional(),
              billing: z.object({
                plan: z.enum(['pro', 'enterprise', 'hobby']),
              }),
              blocked: z.number().nullable(),
              blockReason: z.string().optional(),
              created: z.number().optional(),
              createdAt: z.number(),
              credentials: z
                .array(
                  z.union([
                    z.object({
                      type: z.enum(['gitlab', 'bitbucket', 'google', 'github-oauth', 'github-app']),
                      id: z.string(),
                    }),
                    z.object({
                      type: z.enum(['github-oauth-custom-host', 'github-app-custom-host']),
                      host: z.string(),
                      id: z.string(),
                    }),
                  ]),
                )
                .optional(),
              customerId: z.string().nullable().nullish(),
              orbCustomerId: z.string().nullable().nullish(),
              dataCache: z
                .object({
                  excessBillingEnabled: z.boolean().optional(),
                })
                .optional(),
              deletedAt: z.number().nullable().nullish(),
              deploymentSecret: z.string(),
              dismissedTeams: z.array(z.string()).optional(),
              dismissedToasts: z
                .array(
                  z.object({
                    name: z.string(),
                    dismissals: z.array(
                      z.object({
                        scopeId: z.string(),
                        createdAt: z.number(),
                      }),
                    ),
                  }),
                )
                .optional(),
              favoriteProjectsAndSpaces: z
                .array(
                  z.object({
                    teamId: z.string(),
                    projectId: z.string(),
                  }),
                )
                .optional(),
              email: z.string(),
              id: z.string(),
              importFlowGitNamespace: z.union([z.string(), z.number()]).nullable().nullish(),
              importFlowGitNamespaceId: z.union([z.string(), z.number()]).nullable().nullish(),
              importFlowGitProvider: z.enum(['github', 'gitlab', 'bitbucket', 'github-custom-host']).nullable().nullish(),
              preferredScopesAndGitNamespaces: z
                .array(
                  z.object({
                    scopeId: z.string(),
                    gitNamespaceId: z.union([z.string(), z.number()]).nullable(),
                  }),
                )
                .optional(),
              isDomainReseller: z.boolean().optional(),
              isZeitPub: z.boolean().optional(),
              maxActiveSlots: z.number().optional(),
              name: z.string().optional(),
              phoneNumber: z.string().optional(),
              platformVersion: z.number().nullable(),
              preventAutoBlocking: z.union([z.boolean(), z.number()]).optional(),
              projectDomainsLimit: z.number().describe('Overrides our DEFAULT project domains limit per account or per project.').optional(),
              remoteCaching: z
                .object({
                  enabled: z.boolean().optional(),
                })
                .describe('Represents configuration for remote caching')
                .optional(),
              removedAliasesAt: z.number().optional(),
              removedBillingSubscriptionAt: z.number().optional(),
              removedConfigurationsAt: z.number().optional(),
              removedDeploymentsAt: z.number().optional(),
              removedDomiansAt: z.number().optional(),
              removedEventsAt: z.number().optional(),
              removedProjectsAt: z.number().optional(),
              removedSecretsAt: z.number().optional(),
              removedSharedEnvVarsAt: z.number().optional(),
              removedEdgeConfigsAt: z.number().optional(),
              resourceConfig: z
                .object({
                  nodeType: z.string().optional(),
                  concurrentBuilds: z.number().optional(),
                  elasticConcurrencyEnabled: z.boolean().optional(),
                  buildEntitlements: z
                    .object({
                      enhancedBuilds: z.boolean().optional(),
                    })
                    .optional(),
                  awsAccountType: z.string().optional(),
                  awsAccountIds: z.array(z.string()).optional(),
                  cfZoneName: z.string().optional(),
                  imageOptimizationType: z.string().optional(),
                  edgeConfigs: z.number().optional(),
                  edgeConfigSize: z.number().optional(),
                  edgeFunctionMaxSizeBytes: z.number().optional(),
                  edgeFunctionExecutionTimeoutMs: z.number().optional(),
                  serverlessFunctionMaxMemorySize: z.number().optional(),
                  kvDatabases: z.number().optional(),
                  postgresDatabases: z.number().optional(),
                  blobStores: z.number().optional(),
                  integrationStores: z.number().optional(),
                  cronJobs: z.number().optional(),
                  cronJobsPerProject: z.number().optional(),
                  microfrontendGroupsPerTeam: z.number().optional(),
                  microfrontendProjectsPerGroup: z.number().optional(),
                  flagsExplorerOverridesThreshold: z.number().optional(),
                  flagsExplorerUnlimitedOverrides: z.boolean().optional(),
                  customEnvironmentsPerProject: z.number().optional(),
                  buildMachine: z
                    .object({
                      purchaseType: z.enum(['enhanced', 'turbo']).optional(),
                      isDefaultBuildMachine: z.boolean().optional(),
                      cores: z.number().optional(),
                      memory: z.number().optional(),
                    })
                    .optional(),
                })
                .optional(),
              resourceLimits: z
                .object({})
                .catchall(
                  z.object({
                    max: z.number(),
                    duration: z.number(),
                  }),
                )
                .describe('User | Team resource limits')
                .optional(),
              activeDashboardViews: z
                .array(
                  z.object({
                    scopeId: z.string(),
                    viewPreference: z.enum(['cards', 'list']).nullable().nullish(),
                    favoritesViewPreference: z.enum(['open', 'closed']).nullable().nullish(),
                    recentsViewPreference: z.enum(['open', 'closed']).nullable().nullish(),
                  }),
                )
                .optional(),
              secondaryEmails: z
                .array(
                  z.object({
                    email: z.string(),
                    verified: z.boolean(),
                  }),
                )
                .optional(),
              emailNotifications: z
                .object({
                  rules: z
                    .object({})
                    .catchall(
                      z.object({
                        email: z.string(),
                      }),
                    )
                    .optional(),
                })
                .optional(),
              siftScore: z.number().optional(),
              siftScores: z
                .object({})
                .catchall(
                  z.object({
                    score: z.number(),
                    reasons: z.array(
                      z.object({
                        name: z.string(),
                        value: z.string(),
                      }),
                    ),
                  }),
                )
                .optional(),
              siftRoute: z
                .object({
                  name: z.enum(['string']),
                })
                .optional(),
              sfdcId: z.string().optional(),
              softBlock: z
                .object({
                  blockedAt: z.number(),
                  reason: z.enum([
                    'SUBSCRIPTION_CANCELED',
                    'SUBSCRIPTION_EXPIRED',
                    'UNPAID_INVOICE',
                    'ENTERPRISE_TRIAL_ENDED',
                    'FAIR_USE_LIMITS_EXCEEDED',
                    'BLOCKED_FOR_PLATFORM_ABUSE',
                  ]),
                  blockedDueToOverageType: z
                    .enum([
                      'analyticsUsage',
                      'artifacts',
                      'bandwidth',
                      'blobTotalAdvancedRequests',
                      'blobTotalAvgSizeInBytes',
                      'blobTotalGetResponseObjectSizeInBytes',
                      'blobTotalSimpleRequests',
                      'connectDataTransfer',
                      'dataCacheRead',
                      'dataCacheWrite',
                      'edgeConfigRead',
                      'edgeConfigWrite',
                      'edgeFunctionExecutionUnits',
                      'edgeMiddlewareInvocations',
                      'edgeRequestAdditionalCpuDuration',
                      'edgeRequest',
                      'elasticConcurrencyBuildSlots',
                      'fastDataTransfer',
                      'fastOriginTransfer',
                      'fluidCpuDuration',
                      'fluidDuration',
                      'functionDuration',
                      'functionInvocation',
                      'imageOptimizationCacheRead',
                      'imageOptimizationCacheWrite',
                      'imageOptimizationTransformation',
                      'logDrainsVolume',
                      'monitoringMetric',
                      'blobDataTransfer',
                      'observabilityEvent',
                      'onDemandConcurrencyMinutes',
                      'runtimeCacheRead',
                      'runtimeCacheWrite',
                      'serverlessFunctionExecution',
                      'sourceImages',
                      'wafOwaspExcessBytes',
                      'wafOwaspRequests',
                      'wafRateLimitRequest',
                      'webAnalyticsEvent',
                    ])
                    .optional(),
                })
                .nullable()
                .nullish(),
              stagingPrefix: z.string(),
              sysToken: z.string(),
              teams: z
                .array(
                  z.object({
                    created: z.number().optional(),
                    createdAt: z.number().optional(),
                    teamId: z.string(),
                    role: z.enum(['OWNER', 'MEMBER', 'DEVELOPER', 'SECURITY', 'BILLING', 'VIEWER', 'CONTRIBUTOR']).optional(),
                    confirmed: z.boolean().optional(),
                    confirmedAt: z.number().optional(),
                    accessRequestedAt: z.number().optional(),
                    teamRoles: z.array(z.enum(['OWNER', 'MEMBER', 'DEVELOPER', 'SECURITY', 'BILLING', 'VIEWER', 'CONTRIBUTOR'])).optional(),
                    teamPermissions: z
                      .array(z.enum(['CreateProject', 'FullProductionDeployment', 'UsageViewer', 'EnvVariableManager', 'EnvironmentManager']))
                      .optional(),
                    joinedFrom: z
                      .object({
                        origin: z.enum(['teams', 'saml', 'link', 'github', 'gitlab', 'bitbucket', 'mail', 'import', 'dsync', 'feedback', 'organization-teams']),
                        commitId: z.string().optional(),
                        repoId: z.string().optional(),
                        repoPath: z.string().optional(),
                        gitUserId: z.union([z.string(), z.number()]).optional(),
                        gitUserLogin: z.string().optional(),
                        ssoUserId: z.string().optional(),
                        ssoConnectedAt: z.number().optional(),
                        idpUserId: z.string().optional(),
                        dsyncUserId: z.string().optional(),
                        dsyncConnectedAt: z.number().optional(),
                      })
                      .optional(),
                  }),
                )
                .describe(
                  'A helper that allows to describe a relationship attribute. It receives the shape of a relationship plus the foreignKey name to make it mandatory in the resulting type.',
                )
                .optional(),
              trialTeamIds: z
                .array(z.string())
                .describe(
                  'Introduced 2022-04-12 An array of teamIds (for trial teams created after 2022-04-01), created by the user in question. Used in determining whether the team has a trial available in utils/api-teams/user-has-trial-available.ts.',
                )
                .optional(),
              maxTrials: z
                .number()
                .describe(
                  'Introduced 2022-04-19 Number of maximum trials to allocate to a user. When undefined, defaults to MAX_TRIALS in utils/api-teams/user-has-trial-available.ts. This is set to trialTeamIds + 1 by services/api-backoffice/src/handlers/add-additional-trial.ts.',
                )
                .optional(),
              trialTeamId: z
                .string()
                .describe('Deprecated on 2022-04-12 in favor of trialTeamIds and using utils/api-teams/user-has-trial-available.ts.')
                .optional(),
              type: z.enum(['user']),
              usageAlerts: z
                .object({
                  warningAt: z.number().nullable().nullish(),
                  blockingAt: z.number().nullable().nullish(),
                })
                .describe('Contains the timestamps when a user was notified about their usage')
                .nullable()
                .nullish(),
              overageUsageAlerts: z
                .object({
                  analyticsUsage: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  artifacts: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  bandwidth: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  blobTotalAdvancedRequests: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  blobTotalAvgSizeInBytes: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  blobTotalGetResponseObjectSizeInBytes: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  blobTotalSimpleRequests: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  connectDataTransfer: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  dataCacheRead: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  dataCacheWrite: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  edgeConfigRead: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  edgeConfigWrite: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  edgeFunctionExecutionUnits: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  edgeMiddlewareInvocations: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  edgeRequestAdditionalCpuDuration: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  edgeRequest: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  elasticConcurrencyBuildSlots: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  fastDataTransfer: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  fastOriginTransfer: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  fluidCpuDuration: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  fluidDuration: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  functionDuration: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  functionInvocation: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  imageOptimizationCacheRead: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  imageOptimizationCacheWrite: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  imageOptimizationTransformation: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  logDrainsVolume: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  monitoringMetric: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  blobDataTransfer: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  observabilityEvent: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  onDemandConcurrencyMinutes: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  runtimeCacheRead: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  runtimeCacheWrite: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  serverlessFunctionExecution: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  sourceImages: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  wafOwaspExcessBytes: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  wafOwaspRequests: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  wafRateLimitRequest: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                  webAnalyticsEvent: z
                    .object({
                      currentThreshold: z.number(),
                      warningAt: z.number().nullable().nullish(),
                      blockedAt: z.number().nullable().nullish(),
                    })
                    .optional(),
                })
                .optional(),
              overageMetadata: z
                .object({
                  firstTimeOnDemandNotificationSentAt: z.number().describe('Tracks if the first time on-demand overage email has been sent.').optional(),
                  dailyOverageSummaryEmailSentAt: z.number().describe('Tracks the last time we sent a daily summary email.').optional(),
                  weeklyOverageSummaryEmailSentAt: z.number().describe('Tracks the last time we sent a weekly summary email.').optional(),
                  overageSummaryExpiresAt: z
                    .number()
                    .describe(
                      'Tracks when the overage summary email will stop auto-sending. We currently lock the user into email for a month after the last on-demand usage.',
                    )
                    .optional(),
                  increasedOnDemandEmailSentAt: z.number().describe('Tracks the last time we sent a increased on-demand email.').optional(),
                  increasedOnDemandEmailAttemptedAt: z
                    .number()
                    .describe('Tracks the last time we attempted to send an increased on-demand email. This check is to limit the number of attempts per day.')
                    .optional(),
                })
                .describe('Contains the timestamps for usage summary emails.')
                .optional(),
              username: z.string(),
              updatedAt: z.number(),
              enablePreviewFeedback: z
                .enum(['default', 'on', 'off', 'on-force', 'off-force', 'default-force'])
                .describe('Whether the Vercel Toolbar is enabled for preview deployments.')
                .optional(),
              featureBlocks: z
                .object({
                  webAnalytics: z
                    .object({
                      updatedAt: z.number().optional(),
                      blockedFrom: z.number().optional(),
                      blockedUntil: z.number().optional(),
                      blockReason: z.enum(['admin_override', 'limits_exceeded']).optional(),
                      graceEmailSentAt: z.number().optional(),
                    })
                    .optional(),
                  monitoring: z
                    .object({
                      updatedAt: z.number().optional(),
                      blockedFrom: z.number().optional(),
                      blockedUntil: z.number().optional(),
                      blockReason: z.enum(['admin_override', 'limits_exceeded']).optional(),
                      blockType: z.enum(['soft', 'hard']),
                    })
                    .describe(
                      'A soft block indicates a temporary pause in data collection (ex limit exceeded for the current cycle) A hard block indicates a stoppage in data collection that requires manual intervention (ex upgrading a pro trial)',
                    )
                    .optional(),
                  observabilityPlus: z
                    .object({
                      updatedAt: z.number().optional(),
                      blockedFrom: z.number().optional(),
                      blockedUntil: z.number().optional(),
                      blockReason: z.enum(['admin_override', 'limits_exceeded']).optional(),
                      blockType: z.enum(['soft', 'hard']),
                    })
                    .optional(),
                  dataCache: z
                    .object({
                      updatedAt: z.number(),
                      blockedFrom: z.number().optional(),
                      blockedUntil: z.number().optional(),
                      blockReason: z.enum(['admin_override', 'limits_exceeded']),
                    })
                    .optional(),
                  imageOptimizationTransformation: z
                    .object({
                      updatedAt: z.number(),
                      blockedFrom: z.number().optional(),
                      blockedUntil: z.number().optional(),
                      blockReason: z.enum(['admin_override', 'limits_exceeded']),
                    })
                    .optional(),
                  sourceImages: z
                    .object({
                      updatedAt: z.number(),
                      blockedFrom: z.number().optional(),
                      blockedUntil: z.number().optional(),
                      blockReason: z.enum(['admin_override', 'limits_exceeded']),
                    })
                    .optional(),
                  blob: z
                    .object({
                      updatedAt: z.number().optional(),
                      blockedFrom: z.number().optional(),
                      blockedUntil: z.number().optional(),
                      blockReason: z.enum(['admin_override', 'limits_exceeded']).optional(),
                      overageReason: z.enum([
                        'analyticsUsage',
                        'artifacts',
                        'bandwidth',
                        'blobTotalAdvancedRequests',
                        'blobTotalAvgSizeInBytes',
                        'blobTotalGetResponseObjectSizeInBytes',
                        'blobTotalSimpleRequests',
                        'connectDataTransfer',
                        'dataCacheRead',
                        'dataCacheWrite',
                        'edgeConfigRead',
                        'edgeConfigWrite',
                        'edgeFunctionExecutionUnits',
                        'edgeMiddlewareInvocations',
                        'edgeRequestAdditionalCpuDuration',
                        'edgeRequest',
                        'elasticConcurrencyBuildSlots',
                        'fastDataTransfer',
                        'fastOriginTransfer',
                        'fluidCpuDuration',
                        'fluidDuration',
                        'functionDuration',
                        'functionInvocation',
                        'imageOptimizationCacheRead',
                        'imageOptimizationCacheWrite',
                        'imageOptimizationTransformation',
                        'logDrainsVolume',
                        'monitoringMetric',
                        'blobDataTransfer',
                        'observabilityEvent',
                        'onDemandConcurrencyMinutes',
                        'runtimeCacheRead',
                        'runtimeCacheWrite',
                        'serverlessFunctionExecution',
                        'sourceImages',
                        'wafOwaspExcessBytes',
                        'wafOwaspRequests',
                        'wafRateLimitRequest',
                        'webAnalyticsEvent',
                      ]),
                    })
                    .optional(),
                  postgres: z
                    .object({
                      updatedAt: z.number().optional(),
                      blockedFrom: z.number().optional(),
                      blockedUntil: z.number().optional(),
                      blockReason: z.enum(['admin_override', 'limits_exceeded']).optional(),
                      overageReason: z.enum([
                        'analyticsUsage',
                        'artifacts',
                        'bandwidth',
                        'blobTotalAdvancedRequests',
                        'blobTotalAvgSizeInBytes',
                        'blobTotalGetResponseObjectSizeInBytes',
                        'blobTotalSimpleRequests',
                        'connectDataTransfer',
                        'dataCacheRead',
                        'dataCacheWrite',
                        'edgeConfigRead',
                        'edgeConfigWrite',
                        'edgeFunctionExecutionUnits',
                        'edgeMiddlewareInvocations',
                        'edgeRequestAdditionalCpuDuration',
                        'edgeRequest',
                        'elasticConcurrencyBuildSlots',
                        'fastDataTransfer',
                        'fastOriginTransfer',
                        'fluidCpuDuration',
                        'fluidDuration',
                        'functionDuration',
                        'functionInvocation',
                        'imageOptimizationCacheRead',
                        'imageOptimizationCacheWrite',
                        'imageOptimizationTransformation',
                        'logDrainsVolume',
                        'monitoringMetric',
                        'blobDataTransfer',
                        'observabilityEvent',
                        'onDemandConcurrencyMinutes',
                        'runtimeCacheRead',
                        'runtimeCacheWrite',
                        'serverlessFunctionExecution',
                        'sourceImages',
                        'wafOwaspExcessBytes',
                        'wafOwaspRequests',
                        'wafRateLimitRequest',
                        'webAnalyticsEvent',
                      ]),
                    })
                    .optional(),
                  redis: z
                    .object({
                      updatedAt: z.number().optional(),
                      blockedFrom: z.number().optional(),
                      blockedUntil: z.number().optional(),
                      blockReason: z.enum(['admin_override', 'limits_exceeded']).optional(),
                      overageReason: z.enum([
                        'analyticsUsage',
                        'artifacts',
                        'bandwidth',
                        'blobTotalAdvancedRequests',
                        'blobTotalAvgSizeInBytes',
                        'blobTotalGetResponseObjectSizeInBytes',
                        'blobTotalSimpleRequests',
                        'connectDataTransfer',
                        'dataCacheRead',
                        'dataCacheWrite',
                        'edgeConfigRead',
                        'edgeConfigWrite',
                        'edgeFunctionExecutionUnits',
                        'edgeMiddlewareInvocations',
                        'edgeRequestAdditionalCpuDuration',
                        'edgeRequest',
                        'elasticConcurrencyBuildSlots',
                        'fastDataTransfer',
                        'fastOriginTransfer',
                        'fluidCpuDuration',
                        'fluidDuration',
                        'functionDuration',
                        'functionInvocation',
                        'imageOptimizationCacheRead',
                        'imageOptimizationCacheWrite',
                        'imageOptimizationTransformation',
                        'logDrainsVolume',
                        'monitoringMetric',
                        'blobDataTransfer',
                        'observabilityEvent',
                        'onDemandConcurrencyMinutes',
                        'runtimeCacheRead',
                        'runtimeCacheWrite',
                        'serverlessFunctionExecution',
                        'sourceImages',
                        'wafOwaspExcessBytes',
                        'wafOwaspRequests',
                        'wafRateLimitRequest',
                        'webAnalyticsEvent',
                      ]),
                    })
                    .optional(),
                })
                .describe(
                  'Information about which features are blocked for a user. Blocks can be either soft (the user can still access the feature, but with a warning, e.g. prompting an upgrade) or hard (the user cannot access the feature at all).',
                )
                .optional(),
              defaultTeamId: z.string().optional(),
              version: z.enum(['northstar']),
              northstarMigration: z
                .object({
                  teamId: z.string().describe('The ID of the team we created for this user.'),
                  projects: z.number().describe('The number of projects migrated for this user.'),
                  stores: z.number().describe('The number of stores migrated for this user.'),
                  integrationConfigurations: z.number().describe('The number of integration configurations migrated for this user.'),
                  integrationClients: z.number().describe('The number of integration clients migrated for this user.'),
                  startTime: z.number().describe('The migration start time timestamp for this user.'),
                  endTime: z.number().describe('The migration end time timestamp for this user.'),
                })
                .describe('An archive of information about the Northstar migration, derived from the old (deprecated) property, `northstarMigrationEvents`.')
                .optional(),
              opportunityId: z
                .string()
                .describe(
                  "The salesforce opportunity ID that this user is linked to. This is used to automatically associate a team of the user's choosing with the opportunity.",
                )
                .optional(),
              mfaConfiguration: z
                .object({
                  enabled: z.boolean(),
                  enabledAt: z.number().optional(),
                  recoveryCodes: z.array(z.string()),
                  totp: z
                    .object({
                      secret: z.string(),
                      createdAt: z.number(),
                    })
                    .optional(),
                })
                .describe('MFA configuration. When enabled, the user will be required to provide a second factor of authentication when logging in.')
                .optional(),
            })
            .nullable(),
        }),
        z.object({
          configurations: z.array(
            z.object({
              integrationId: z.string(),
              configurationId: z.string(),
              integrationSlug: z.string(),
              integrationName: z.string().optional(),
            }),
          ),
          ownerId: z.string(),
        }),
        z.object({
          integrationId: z.string(),
          configurationId: z.string(),
          integrationSlug: z.string(),
          integrationName: z.string(),
          ownerId: z.string(),
          billingPlanId: z.string(),
          billingPlanName: z.string().optional(),
        }),
        z.object({
          integrationId: z.string(),
          configurationId: z.string(),
          integrationSlug: z.string(),
          integrationName: z.string(),
          ownerId: z.string(),
          projectIds: z.array(z.string()).optional(),
        }),
        z.object({
          projectId: z.string(),
          fromDeploymentId: z.string(),
          toDeploymentId: z.string(),
          projectName: z.string(),
          reason: z.string().optional(),
        }),
        z.object({
          integrationId: z.string(),
          configurationId: z.string(),
          integrationSlug: z.string(),
          integrationName: z.string(),
          ownerId: z.string(),
          projectIds: z.array(z.string()).optional(),
          confirmedScopes: z.array(z.string()),
        }),
        z.object({
          userAgent: z
            .object({
              browser: z.object({
                name: z.enum(['iphone', 'ipad', 'ipod', 'chrome', 'firefox', 'mozilla', 'unknown']),
              }),
              ua: z.string(),
              program: z.string(),
              os: z.object({
                name: z.enum(['unknown', 'darwin', 'win32', 'win', 'windows', 'linux', 'freebsd', 'sunos', 'mac', 'ios', 'android', 'Mac OS', 'OS X']),
              }),
            })
            .optional(),
          geolocation: z
            .object({
              city: z
                .object({
                  names: z.object({
                    en: z.string(),
                  }),
                })
                .optional(),
              country: z.object({
                names: z.object({
                  en: z.string(),
                }),
              }),
              most_specific_subdivision: z
                .object({
                  names: z.object({
                    en: z.string(),
                  }),
                })
                .optional(),
              regionName: z.string().optional(),
            })
            .nullable()
            .nullish(),
          viaGithub: z.boolean(),
          viaGitlab: z.boolean(),
          viaBitbucket: z.boolean(),
          viaGoogle: z.boolean(),
          viaSamlSso: z.boolean(),
          viaPasskey: z.boolean(),
          ssoType: z.string().optional(),
          env: z.string().optional(),
          os: z.string().optional(),
          username: z.string().optional(),
        }),
        z.object({
          logDrainUrl: z.string().nullable(),
          integrationName: z.string().optional(),
        }),
        z.object({
          logDrainUrl: z.string(),
          integrationName: z.string().optional(),
        }),
        z.object({
          drainUrl: z.string().nullable(),
          integrationName: z.string().optional(),
        }),
        z.object({
          projectId: z.string(),
          toDeploymentId: z.string(),
          projectName: z.string(),
        }),
        z.object({
          projectName: z.string(),
        }),
        z.object({
          plan: z.string(),
          removedUsers: z
            .object({})
            .catchall(
              z.object({
                role: z.enum(['OWNER', 'MEMBER', 'DEVELOPER', 'SECURITY', 'BILLING', 'VIEWER', 'CONTRIBUTOR']),
                confirmed: z.boolean(),
                confirmedAt: z.number().optional(),
                joinedFrom: z
                  .object({
                    origin: z.enum(['teams', 'saml', 'link', 'github', 'gitlab', 'bitbucket', 'mail', 'import', 'dsync', 'feedback', 'organization-teams']),
                    commitId: z.string().optional(),
                    repoId: z.string().optional(),
                    repoPath: z.string().optional(),
                    gitUserId: z.union([z.string(), z.number()]).optional(),
                    gitUserLogin: z.string().optional(),
                    ssoUserId: z.string().optional(),
                    ssoConnectedAt: z.number().optional(),
                    idpUserId: z.string().optional(),
                    dsyncUserId: z.string().optional(),
                    dsyncConnectedAt: z.number().optional(),
                  })
                  .optional(),
              }),
            )
            .optional(),
          priorPlan: z.string().optional(),
          isDowngrade: z.boolean().optional(),
          userAgent: z.string().optional(),
          isReactivate: z.boolean().optional(),
          isTrialUpgrade: z.boolean().optional(),
        }),
        z.object({
          projectName: z.string().optional(),
          projectId: z.string(),
          projectAnalytics: z
            .object({
              id: z.string(),
              canceledAt: z.number().nullable().nullish(),
              disabledAt: z.number(),
              enabledAt: z.number(),
              paidAt: z.number().optional(),
              sampleRatePercent: z.number().nullable().nullish(),
              spendLimitInDollars: z.number().nullable().nullish(),
            })
            .nullable(),
          prevProjectAnalytics: z
            .object({
              id: z.string(),
              canceledAt: z.number().nullable().nullish(),
              disabledAt: z.number(),
              enabledAt: z.number(),
              paidAt: z.number().optional(),
              sampleRatePercent: z.number().nullable().nullish(),
              spendLimitInDollars: z.number().nullable().nullish(),
            })
            .nullable(),
        }),
        z.object({
          projectName: z.string().optional(),
          projectId: z.string(),
          projectAnalytics: z.object({}).catchall(z.unknown()).optional(),
          prevProjectAnalytics: z.object({}).catchall(z.unknown()).nullable().nullish(),
        }),
        z.object({
          projectName: z.string().optional(),
          projectId: z.string(),
        }),
        z.object({
          projectName: z.string(),
          ssoProtection: z
            .union([
              z.object({
                deploymentType: z.enum(['all', 'preview', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains']),
              }),
              z.enum(['all', 'preview', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains']),
            ])
            .nullable(),
          oldSsoProtection: z
            .union([
              z.object({
                deploymentType: z.enum(['all', 'preview', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains']),
              }),
              z.enum(['all', 'preview', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains']),
            ])
            .nullable(),
        }),
        z.object({
          projectName: z.string(),
          passwordProtection: z
            .union([
              z.object({
                deploymentType: z.enum(['all', 'preview', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains']),
              }),
              z.enum(['all', 'preview', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains']),
            ])
            .nullable(),
          oldPasswordProtection: z
            .union([
              z.object({
                deploymentType: z.enum(['all', 'preview', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains']),
              }),
              z.enum(['all', 'preview', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains']),
            ])
            .nullable(),
        }),
        z.object({
          projectName: z.string(),
          trustedIps: z.enum(['all', 'preview', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains', 'production']).nullable().nullish(),
          oldTrustedIps: z.enum(['all', 'preview', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains', 'production']).nullable().nullish(),
          addedAddresses: z.array(z.string()).nullable().nullish(),
          removedAddresses: z.array(z.string()).nullable().nullish(),
        }),
        z.object({
          projectName: z.string(),
          optionsAllowlist: z
            .object({
              paths: z.array(
                z.object({
                  value: z.string(),
                }),
              ),
            })
            .nullable()
            .nullish(),
          oldOptionsAllowlist: z
            .object({
              paths: z.array(
                z.object({
                  value: z.string(),
                }),
              ),
            })
            .nullable()
            .nullish(),
        }),
        z.object({
          projectName: z.string(),
          action: z.enum(['enabled', 'disabled', 'regenerated']),
        }),
        z.object({
          name: z.string(),
          ownerId: z.string(),
        }),
        z.object({
          team: z.object({
            id: z.string(),
            name: z.string(),
          }),
          project: z.object({
            id: z.string(),
            name: z.string().optional(),
            oldConnectConfigurations: z
              .array(
                z.object({
                  envId: z.union([z.string(), z.enum(['preview', 'production'])]),
                  connectConfigurationId: z.string(),
                  passive: z.boolean(),
                  buildsEnabled: z.boolean(),
                  aws: z
                    .object({
                      subnetIds: z.array(z.string()),
                      securityGroupId: z.string(),
                    })
                    .optional(),
                  createdAt: z.number(),
                  updatedAt: z.number(),
                }),
              )
              .nullable(),
            newConnectConfigurations: z
              .array(
                z.object({
                  envId: z.union([z.string(), z.enum(['preview', 'production'])]),
                  connectConfigurationId: z.string(),
                  passive: z.boolean(),
                  buildsEnabled: z.boolean(),
                  aws: z
                    .object({
                      subnetIds: z.array(z.string()),
                      securityGroupId: z.string(),
                    })
                    .optional(),
                  createdAt: z.number(),
                  updatedAt: z.number(),
                }),
              )
              .nullable(),
          }),
        }),
        z.object({
          projectId: z.string(),
        }),
        z.object({
          projectId: z.string(),
          projectName: z.string(),
        }),
        z.object({
          projectId: z.string().optional(),
          projectName: z.string().optional(),
          newTargetPercentage: z.number().optional(),
        }),
        z.object({
          gitProvider: z.string(),
          gitProviderGroupDescriptor: z.string(),
          gitScope: z.string(),
        }),
        z.object({
          instances: z.number(),
          url: z.string(),
        }),
        z.object({
          email: z.string(),
          verified: z.boolean(),
        }),
        z.object({
          email: z.string(),
        }),
        z.object({
          team: z.object({
            id: z.string(),
            name: z.string().optional(),
          }),
          previousRule: z
            .object({
              email: z.string(),
            })
            .optional(),
          nextRule: z
            .object({
              email: z.string(),
            })
            .optional(),
        }),
        z.object({
          team: z.object({
            id: z.string(),
            name: z.string().optional(),
          }),
          previousRule: z.object({
            email: z.string(),
          }),
        }),
        z.object({
          uid: z.string(),
          name: z.union([
            z.string(),
            z.object({
              name: z.string(),
            }),
          ]),
        }),
        z.object({
          oldName: z.string(),
          newName: z.string(),
          uid: z.string().optional(),
        }),
        z.object({
          bio: z.string(),
        }),
        z.object({
          scalingRules: z.object({}).catchall(
            z.object({
              min: z.number(),
              max: z.number(),
            }),
          ),
          min: z.number(),
          max: z.number(),
          url: z.string(),
        }),
        z.object({
          webhookUrl: z.string().optional(),
        }),
        z.object({
          budget: z
            .object({
              type: z.enum(['fixed']).describe('The budget type'),
              fixedBudget: z.number().describe('Budget amount'),
              previousSpend: z.array(z.number()).describe('Array of the last 3 months of spend data'),
              notifiedAt: z.array(z.number()).describe('Array of 50, 75, 100 to keep track of notifications sent out'),
              webhookId: z.string().describe('Webhook id that corresponds to a webhook in Cosmos webhook collection').optional(),
              webhookNotified: z.boolean().describe('Keep track if the webhook has been called for the month').optional(),
              createdAt: z.number().describe('Date time when budget is created'),
              updatedAt: z.number().describe('Date time when budget is updated last').optional(),
              isActive: z.boolean().describe('Is the budget currently active for a customer'),
              pauseProjects: z.boolean().describe('Should all projects be paused if budget is exceeded').optional(),
              pricingPlan: z.enum(['legacy', 'unbundled']).describe('The acive pricing plan the team is billed with').optional(),
              teamId: z.string().describe('Partition key'),
              id: z.string().describe('Sort key that needs to be unique per teamId'),
            })
            .describe('Represents a budget for tracking and notifying teams on their spending.'),
        }),
        z.object({
          budget: z.object({
            budgetItem: z
              .object({
                type: z.enum(['fixed']).describe('The budget type'),
                fixedBudget: z.number().describe('Budget amount'),
                previousSpend: z.array(z.number()).describe('Array of the last 3 months of spend data'),
                notifiedAt: z.array(z.number()).describe('Array of 50, 75, 100 to keep track of notifications sent out'),
                webhookId: z.string().describe('Webhook id that corresponds to a webhook in Cosmos webhook collection').optional(),
                webhookNotified: z.boolean().describe('Keep track if the webhook has been called for the month').optional(),
                createdAt: z.number().describe('Date time when budget is created'),
                updatedAt: z.number().describe('Date time when budget is updated last').optional(),
                isActive: z.boolean().describe('Is the budget currently active for a customer'),
                pauseProjects: z.boolean().describe('Should all projects be paused if budget is exceeded').optional(),
                pricingPlan: z.enum(['legacy', 'unbundled']).describe('The acive pricing plan the team is billed with').optional(),
                teamId: z.string().describe('Partition key'),
                id: z.string().describe('Sort key that needs to be unique per teamId'),
              })
              .describe('Represents a budget for tracking and notifying teams on their spending.'),
          }),
        }),
        z.object({
          id: z.string(),
          name: z.string().optional(),
          computeUnitsMax: z.number().optional(),
          computeUnitsMin: z.number().optional(),
          suspendTimeoutSeconds: z.number().optional(),
          type: z.enum(['redis', 'postgres', 'edge-config', 'blob', 'integration']),
        }),
        z.object({
          storeType: z.enum(['redis', 'postgres']),
        }),
        z.object({
          store: z.object({
            name: z.string(),
            id: z.string(),
          }),
          ownerId: z.string().optional(),
        }),
        z.object({
          slug: z.string(),
        }),
        z.object({
          slug: z.string(),
          teamId: z.string(),
          by: z.string(),
          reasons: z
            .array(
              z.object({
                slug: z.string(),
                description: z.string(),
              }),
            )
            .optional(),
        }),
        z.object({
          directoryType: z.string().optional(),
          ssoType: z.string().optional(),
          invitedUser: z
            .object({
              username: z.string(),
              email: z.string(),
            })
            .optional(),
          invitedEmail: z.string().optional(),
          invitationRole: z.string().optional(),
          entitlements: z.array(z.string()).optional(),
          invitedUid: z.string().optional(),
        }),
        z.object({
          deletedUser: z
            .object({
              username: z.string(),
              email: z.string(),
            })
            .optional(),
          deletedUid: z.string().optional(),
          githubUsername: z.string().nullable().nullish(),
          gitlabUsername: z.string().nullable().nullish(),
          bitbucketUsername: z.string().nullable().nullish(),
          directoryType: z.string().optional(),
        }),
        z.object({
          role: z.string().optional(),
          uid: z.string(),
          origin: z.string().optional(),
        }),
        z.object({
          directoryType: z.string().optional(),
          updatedUser: z
            .object({
              username: z.string(),
              email: z.string(),
            })
            .optional(),
          role: z.string().optional(),
          previousRole: z.string(),
          updatedUid: z.string().optional(),
        }),
        z.object({
          entitlement: z.string(),
          user: z.object({
            id: z.string(),
            username: z.string(),
          }),
        }),
        z.object({
          entitlement: z.string(),
          user: z.object({
            id: z.string(),
            username: z.string(),
          }),
          previousCanceledAt: z.string().optional(),
        }),
        z.object({
          enforced: z.boolean(),
        }),
        z.object({
          name: z.string().optional(),
        }),
        z.object({
          slug: z.string().optional(),
        }),
        z.object({
          remoteCaching: z
            .object({
              enabled: z.boolean().optional(),
            })
            .describe('Represents configuration for remote caching')
            .optional(),
        }),
        z.object({
          previous: z.object({
            enabled: z.boolean(),
            totpVerified: z.boolean(),
          }),
          next: z.object({
            enabled: z.boolean(),
            totpVerified: z.boolean(),
          }),
        }),
        z.object({
          enabled: z.boolean(),
          totpVerified: z.boolean(),
        }),
        z.object({
          mfaEnabled: z.boolean(),
        }),
        z.object({
          email: z.string(),
          prevEmail: z.string(),
        }),
        z.object({
          username: z.string(),
        }),
        z.object({
          price: z.number().optional(),
          currency: z.string().optional(),
          enabled: z.boolean().optional(),
        }),
        z.object({
          previewDeploymentSuffix: z.string().nullable().nullish(),
          previousPreviewDeploymentSuffix: z.string().nullable().nullish(),
        }),
        z.object({
          price: z.number().optional(),
          currency: z.string().optional(),
        }),
        z.object({
          teamName: z.string(),
          username: z.string().optional(),
          gitUsername: z.string().optional(),
          githubUsername: z.string().nullable().nullish(),
          gitlabUsername: z.string().nullable().nullish(),
          bitbucketUsername: z.string().nullable().nullish(),
          updatedUid: z.string().optional(),
          teamId: z.string().optional(),
        }),
        z.object({
          teamName: z.string(),
          username: z.string().optional(),
          gitUsername: z.string().nullable().nullish(),
          githubUsername: z.string().nullable().nullish(),
          gitlabUsername: z.string().nullable().nullish(),
          bitbucketUsername: z.string().nullable().nullish(),
        }),
        z.object({
          requestedTeamName: z.string(),
          requestedUserName: z.string().optional(),
          gitUsername: z.string().optional(),
          githubUsername: z.string().optional(),
          gitlabUsername: z.string().optional(),
          bitbucketUsername: z.string().optional(),
        }),
        z.object({
          projectId: z.string(),
          projectName: z.string(),
          originAccountName: z.string(),
          destinationAccountName: z.string(),
          destinationAccountId: z.string(),
          transferId: z.string().optional(),
        }),
        z.object({
          projectName: z.string(),
          destinationAccountName: z.string().nullable(),
          transferId: z.string().optional(),
        }),
        z.object({
          previousProjectName: z.string(),
          newProjectName: z.string(),
          destinationAccountName: z.string(),
          transferId: z.string().optional(),
        }),
        z.object({
          previousProjectName: z.string(),
          newProjectName: z.string(),
          originAccountName: z.string(),
          transferId: z.string().optional(),
        }),
        z.object({
          project: z.object({
            name: z.string(),
            id: z.string().optional(),
          }),
          projectMembership: z
            .object({
              role: z.enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER']).optional(),
              uid: z.string().optional(),
              createdAt: z.number().optional(),
              username: z.string().optional(),
            })
            .nullable(),
        }),
        z.object({
          project: z.object({
            name: z.string(),
            id: z.string().optional(),
          }),
          removedMembership: z.object({
            role: z.enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER']).optional(),
            uid: z.string().optional(),
            createdAt: z.number().optional(),
            username: z.string().optional(),
          }),
        }),
        z.object({
          project: z.object({
            id: z.string(),
            name: z.string(),
          }),
          projectMembership: z.object({
            role: z.enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER']).optional(),
            uid: z.string().optional(),
            createdAt: z.number().optional(),
            username: z.string().optional(),
            previousRole: z.enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER']).optional(),
          }),
        }),
        z.object({
          project: z.object({
            name: z.string(),
            role: z.enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER']),
            invitedUserName: z.string(),
            id: z.string().optional(),
            invitedUserId: z.string().optional(),
          }),
        }),
        z.object({
          edgeConfigId: z.string(),
          edgeConfigSlug: z.string(),
          edgeConfigDigest: z.string(),
        }),
        z.object({
          edgeConfigId: z.string(),
          edgeConfigSlug: z.string(),
          edgeConfigTokenId: z.string(),
          label: z.string(),
        }),
        z.object({
          edgeConfigId: z.string(),
          edgeConfigSlug: z.string(),
          edgeConfigTokenIds: z.array(z.string()).describe('ids of deleted tokens'),
        }),
        z.object({
          action: z.enum(['enable', 'disable']),
        }),
        z.object({
          id: z.string(),
          slug: z.string(),
          name: z.string(),
        }),
        z.object({
          id: z.string(),
          slug: z.string().optional(),
          name: z.string().optional(),
          fallbackEnvironment: z.string().optional(),
          prev: z.object({
            name: z.string(),
            slug: z.string(),
            fallbackEnvironment: z.string().optional(),
          }),
        }),
        z.object({
          project: z.object({
            id: z.string(),
            name: z.string(),
          }),
          group: z.object({
            id: z.string(),
            slug: z.string(),
            name: z.string(),
          }),
        }),
        z.object({
          project: z.object({
            id: z.string(),
            name: z.string(),
            microfrontends: z
              .union([
                z.object({
                  updatedAt: z.number().describe('Timestamp when the microfrontends settings were last updated.'),
                  groupIds: z
                    .array(z.union([z.string(), z.string()]))
                    .min(2)
                    .max(2)
                    .describe(
                      'The group IDs of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.',
                    ),
                  enabled: z.boolean().describe('Whether microfrontends are enabled for this project.'),
                  isDefaultApp: z
                    .boolean()
                    .describe(
                      'Whether this project is the default application for the microfrontends group. The default application is the one that is used as the top level shell for the microfrontends group and hosts the other microfrontends.',
                    )
                    .optional(),
                  defaultRoute: z
                    .string()
                    .describe(
                      'A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI. Includes the leading slash, e.g. `/docs`',
                    )
                    .optional(),
                  routeObservabilityToThisProject: z
                    .boolean()
                    .describe('Whether observability data should be routed to this microfrontend project or a root project.')
                    .optional(),
                }),
                z.object({
                  updatedAt: z.number(),
                  groupIds: z
                    .array(z.union([z.string(), z.string()]))
                    .min(2)
                    .max(2),
                  enabled: z.boolean(),
                }),
              ])
              .optional(),
          }),
          prev: z.object({
            project: z.object({
              microfrontends: z
                .union([
                  z.object({
                    updatedAt: z.number().describe('Timestamp when the microfrontends settings were last updated.'),
                    groupIds: z
                      .array(z.union([z.string(), z.string()]))
                      .min(2)
                      .max(2)
                      .describe(
                        'The group IDs of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.',
                      ),
                    enabled: z.boolean().describe('Whether microfrontends are enabled for this project.'),
                    isDefaultApp: z
                      .boolean()
                      .describe(
                        'Whether this project is the default application for the microfrontends group. The default application is the one that is used as the top level shell for the microfrontends group and hosts the other microfrontends.',
                      )
                      .optional(),
                    defaultRoute: z
                      .string()
                      .describe(
                        'A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI. Includes the leading slash, e.g. `/docs`',
                      )
                      .optional(),
                    routeObservabilityToThisProject: z
                      .boolean()
                      .describe('Whether observability data should be routed to this microfrontend project or a root project.')
                      .optional(),
                  }),
                  z.object({
                    updatedAt: z.number(),
                    groupIds: z
                      .array(z.union([z.string(), z.string()]))
                      .min(2)
                      .max(2),
                    enabled: z.boolean(),
                  }),
                ])
                .optional(),
            }),
          }),
          group: z.object({
            id: z.string(),
            slug: z.string(),
            name: z.string(),
          }),
        }),
        z.object({
          projectId: z.string(),
          projectName: z.string(),
          projectWebAnalytics: z
            .object({
              id: z.string(),
              disabledAt: z.number().optional(),
              canceledAt: z.number().optional(),
              enabledAt: z.number().optional(),
              hasData: z.boolean().optional(),
            })
            .optional(),
          prevProjectWebAnalytics: z
            .object({
              id: z.string(),
              disabledAt: z.number().optional(),
              canceledAt: z.number().optional(),
              enabledAt: z.number().optional(),
              hasData: z.boolean().optional(),
            })
            .nullable()
            .nullish(),
        }),
        z.object({
          tier: z.enum(['pro', 'plus']),
        }),
        z.object({
          oldName: z.string(),
          newName: z.string(),
        }),
        z.object({
          appName: z.string(),
          scopes: z.array(z.string()),
        }),
        z.object({
          appName: z.string(),
          nextScopes: z.array(z.string()),
        }),
        z.object({
          appName: z.string(),
        }),
        z.object({
          team: z.object({
            id: z.string(),
            name: z.string(),
          }),
          configuration: z.object({
            id: z.string(),
            name: z.string().optional(),
          }),
          peering: z.object({
            id: z.string(),
            accountId: z.string(),
            region: z.string(),
            vpcId: z.string(),
          }),
        }),
        z.object({
          team: z.object({
            id: z.string(),
            name: z.string(),
          }),
          configuration: z.object({
            id: z.string(),
            name: z.string().optional(),
          }),
          peering: z.object({
            id: z.string(),
            name: z.string().optional(),
          }),
        }),
        z.object({
          team: z.object({
            id: z.string(),
            name: z.string(),
          }),
          configuration: z.object({
            id: z.string(),
            name: z.string().optional(),
          }),
          peering: z.object({
            id: z.string(),
            name: z.string().optional(),
          }),
          newName: z.string().optional(),
        }),
        z.object({
          grantType: z.enum(['authorization_code', 'refresh_token', 'urn:ietf:params:oauth:grant-type:device_code', 'client_credentials']),
          appName: z.string(),
          atTTL: z.number().describe('access_token TTL'),
          rtTTL: z.number().describe('refresh_token TTL').optional(),
          scope: z.string(),
          authMethod: z.enum(['email', 'saml', 'github', 'gitlab', 'bitbucket', 'manual', 'passkey', 'otp', 'sms', 'invite', 'google']),
        }),
      ])
      .optional(),
  })
  .describe('Array of events generated by the User.') as unknown as ToZod<UserEvent>

/**
 * @description Data representing a Team.
 */
export const teamSchema = z
  .object({
    connect: z
      .object({
        enabled: z.boolean().optional(),
      })
      .optional(),
    creatorId: z.string().describe('The ID of the user who created the Team.'),
    updatedAt: z.number().describe('Timestamp (in milliseconds) of when the Team was last updated.'),
    emailDomain: z.string().describe("Hostname that'll be matched with emails on sign-up to automatically join the Team.").nullable().nullish(),
    saml: z
      .object({
        connection: z
          .object({
            type: z.string().describe('The Identity Provider "type", for example Okta.'),
            status: z.string().describe('Current status of the connection.'),
            state: z.string().describe('Current state of the connection.'),
            connectedAt: z.number().describe('Timestamp (in milliseconds) of when the configuration was connected.'),
            lastReceivedWebhookEvent: z.number().describe('Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.').optional(),
          })
          .describe('Information for the SAML Single Sign-On configuration.')
          .optional(),
        directory: z
          .object({
            type: z.string().describe('The Identity Provider "type", for example Okta.'),
            state: z.string().describe('Current state of the connection.'),
            connectedAt: z.number().describe('Timestamp (in milliseconds) of when the configuration was connected.'),
            lastReceivedWebhookEvent: z.number().describe('Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.').optional(),
          })
          .describe('Information for the Directory Sync configuration.')
          .optional(),
        enforced: z
          .boolean()
          .describe(
            "When `true`, interactions with the Team **must** be done with an authentication token that has been authenticated with the Team's SAML Single Sign-On provider.",
          ),
        roles: z
          .object({})
          .catchall(
            z.union([
              z.object({
                accessGroupId: z.string(),
              }),
              z.enum(['OWNER', 'MEMBER', 'DEVELOPER', 'SECURITY', 'BILLING', 'VIEWER', 'CONTRIBUTOR']),
            ]),
          )
          .describe(
            'When "Directory Sync" is configured, this object contains a mapping of which Directory Group (by ID) should be assigned to which Vercel Team "role".',
          )
          .optional(),
      })
      .describe('When "Single Sign-On (SAML)" is configured, this object contains information regarding the configuration of the Identity Provider (IdP).')
      .optional(),
    inviteCode: z.string().describe('Code that can be used to join this Team. Only visible to Team owners.').optional(),
    description: z.string().describe('A short description of the Team.').nullable(),
    stagingPrefix: z.string().describe('The prefix that is prepended to automatic aliases.'),
    resourceConfig: z
      .object({
        concurrentBuilds: z.number().describe('The total amount of concurrent builds that can be used.').optional(),
        elasticConcurrencyEnabled: z.boolean().describe('Whether every build for this team / user has elastic concurrency enabled automatically.').optional(),
        edgeConfigSize: z.number().describe('The maximum size in kilobytes of an Edge Config. Only specified if a custom limit is set.').optional(),
        edgeConfigs: z.number().describe('The maximum number of edge configs an account can create.').optional(),
        kvDatabases: z.number().describe('The maximum number of kv databases an account can create.').optional(),
        blobStores: z.number().describe('The maximum number of blob stores an account can create.').optional(),
        postgresDatabases: z.number().describe('The maximum number of postgres databases an account can create.').optional(),
        buildEntitlements: z
          .object({
            enhancedBuilds: z.boolean().optional(),
          })
          .optional(),
      })
      .optional(),
    previewDeploymentSuffix: z.string().describe('The hostname that is current set as preview deployment suffix.').nullable().nullish(),
    remoteCaching: z
      .object({
        enabled: z.boolean().optional(),
      })
      .describe('Is remote caching enabled for this team')
      .optional(),
    defaultDeploymentProtection: z
      .object({
        passwordProtection: z
          .object({
            deploymentType: z.string(),
          })
          .optional(),
        ssoProtection: z
          .object({
            deploymentType: z.string(),
          })
          .optional(),
      })
      .describe('Default deployment protection for this team')
      .optional(),
    enablePreviewFeedback: z
      .enum(['default', 'default-force', 'off', 'off-force', 'on', 'on-force'])
      .describe('Whether toolbar is enabled on preview deployments')
      .nullable()
      .nullish(),
    enableProductionFeedback: z
      .enum(['default', 'default-force', 'off', 'off-force', 'on', 'on-force'])
      .describe('Whether toolbar is enabled on production deployments')
      .nullable()
      .nullish(),
    sensitiveEnvironmentVariablePolicy: z.enum(['default', 'off', 'on']).describe('Sensitive environment variable policy for this team').nullable().nullish(),
    hideIpAddresses: z.boolean().describe('Indicates if IP addresses should be accessible in observability (o11y) tooling').nullable().nullish(),
    hideIpAddressesInLogDrains: z.boolean().describe('Indicates if IP addresses should be accessible in log drains').nullable().nullish(),
    ipBuckets: z
      .array(
        z.object({
          bucket: z.string(),
          supportUntil: z.number().optional(),
        }),
      )
      .optional(),
    id: z.string().describe("The Team's unique identifier."),
    slug: z.string().describe("The Team's slug, which is unique across the Vercel platform."),
    name: z.string().describe('Name associated with the Team account, or `null` if none has been provided.').nullable(),
    avatar: z.string().describe('The ID of the file used as avatar for this Team.').nullable(),
    membership: z
      .object({
        uid: z.string().optional(),
        entitlements: z
          .array(
            z.object({
              entitlement: z.string(),
            }),
          )
          .optional(),
        teamId: z.string().optional(),
        confirmed: z.boolean(),
        confirmedAt: z.number(),
        accessRequestedAt: z.number().optional(),
        role: z.enum(['BILLING', 'CONTRIBUTOR', 'DEVELOPER', 'MEMBER', 'OWNER', 'SECURITY', 'VIEWER']),
        teamRoles: z.array(z.enum(['BILLING', 'CONTRIBUTOR', 'DEVELOPER', 'MEMBER', 'OWNER', 'SECURITY', 'VIEWER'])).optional(),
        teamPermissions: z.array(z.enum(['CreateProject', 'EnvVariableManager', 'EnvironmentManager', 'FullProductionDeployment', 'UsageViewer'])).optional(),
        createdAt: z.number(),
        created: z.number(),
        joinedFrom: z
          .object({
            origin: z.enum(['bitbucket', 'dsync', 'feedback', 'github', 'gitlab', 'import', 'link', 'mail', 'organization-teams', 'saml', 'teams']),
            commitId: z.string().optional(),
            repoId: z.string().optional(),
            repoPath: z.string().optional(),
            gitUserId: z.union([z.string(), z.number()]).optional(),
            gitUserLogin: z.string().optional(),
            ssoUserId: z.string().optional(),
            ssoConnectedAt: z.number().optional(),
            idpUserId: z.string().optional(),
            dsyncUserId: z.string().optional(),
            dsyncConnectedAt: z.number().optional(),
          })
          .optional(),
      })
      .describe('The membership of the authenticated User in relation to the Team.'),
    createdAt: z.number().describe('UNIX timestamp (in milliseconds) when the Team was created.'),
  })
  .describe('Data representing a Team.') as unknown as ToZod<Team>

/**
 * @description A limited form of data representing a Team, due to the authentication token missing privileges to read the full Team data.
 */
export const teamLimitedSchema = z
  .object({
    limited: z
      .boolean()
      .describe(
        "Property indicating that this Team data contains only limited information, due to the authentication token missing privileges to read the full Team data or due to team having MFA enforced and the user not having MFA enabled. Re-login with the Team's configured SAML Single Sign-On provider in order to upgrade the authentication token with the necessary privileges.",
      ),
    limitedBy: z.array(z.enum(['mfa', 'scope'])),
    saml: z
      .object({
        connection: z
          .object({
            type: z.string().describe('The Identity Provider "type", for example Okta.'),
            status: z.string().describe('Current status of the connection.'),
            state: z.string().describe('Current state of the connection.'),
            connectedAt: z.number().describe('Timestamp (in milliseconds) of when the configuration was connected.'),
            lastReceivedWebhookEvent: z.number().describe('Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.').optional(),
          })
          .describe('Information for the SAML Single Sign-On configuration.')
          .optional(),
        directory: z
          .object({
            type: z.string().describe('The Identity Provider "type", for example Okta.'),
            state: z.string().describe('Current state of the connection.'),
            connectedAt: z.number().describe('Timestamp (in milliseconds) of when the configuration was connected.'),
            lastReceivedWebhookEvent: z.number().describe('Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.').optional(),
          })
          .describe('Information for the Directory Sync configuration.')
          .optional(),
        enforced: z
          .boolean()
          .describe(
            "When `true`, interactions with the Team **must** be done with an authentication token that has been authenticated with the Team's SAML Single Sign-On provider.",
          ),
      })
      .describe(
        'When "Single Sign-On (SAML)" is configured, this object contains information that allows the client-side to identify whether or not this Team has SAML enforced.',
      )
      .optional(),
    id: z.string().describe("The Team's unique identifier."),
    slug: z.string().describe("The Team's slug, which is unique across the Vercel platform."),
    name: z.string().describe('Name associated with the Team account, or `null` if none has been provided.').nullable(),
    avatar: z.string().describe('The ID of the file used as avatar for this Team.').nullable(),
    membership: z
      .object({
        uid: z.string().optional(),
        entitlements: z
          .array(
            z.object({
              entitlement: z.string(),
            }),
          )
          .optional(),
        teamId: z.string().optional(),
        confirmed: z.boolean(),
        confirmedAt: z.number(),
        accessRequestedAt: z.number().optional(),
        role: z.enum(['BILLING', 'CONTRIBUTOR', 'DEVELOPER', 'MEMBER', 'OWNER', 'SECURITY', 'VIEWER']),
        teamRoles: z.array(z.enum(['BILLING', 'CONTRIBUTOR', 'DEVELOPER', 'MEMBER', 'OWNER', 'SECURITY', 'VIEWER'])).optional(),
        teamPermissions: z.array(z.enum(['CreateProject', 'EnvVariableManager', 'EnvironmentManager', 'FullProductionDeployment', 'UsageViewer'])).optional(),
        createdAt: z.number(),
        created: z.number(),
        joinedFrom: z
          .object({
            origin: z.enum(['bitbucket', 'dsync', 'feedback', 'github', 'gitlab', 'import', 'link', 'mail', 'organization-teams', 'saml', 'teams']),
            commitId: z.string().optional(),
            repoId: z.string().optional(),
            repoPath: z.string().optional(),
            gitUserId: z.union([z.string(), z.number()]).optional(),
            gitUserLogin: z.string().optional(),
            ssoUserId: z.string().optional(),
            ssoConnectedAt: z.number().optional(),
            idpUserId: z.string().optional(),
            dsyncUserId: z.string().optional(),
            dsyncConnectedAt: z.number().optional(),
          })
          .optional(),
      })
      .describe('The membership of the authenticated User in relation to the Team.'),
    createdAt: z.number().describe('UNIX timestamp (in milliseconds) when the Team was created.'),
  })
  .describe(
    'A limited form of data representing a Team, due to the authentication token missing privileges to read the full Team data.',
  ) as unknown as ToZod<TeamLimited>

/**
 * @description Authentication token metadata.
 */
export const authTokenSchema = z
  .object({
    id: z.string().describe('The unique identifier of the token.'),
    name: z.string().describe('The human-readable name of the token.'),
    type: z.string().describe('The type of the token.'),
    origin: z.string().describe('The origin of how the token was created.').optional(),
    scopes: z
      .array(
        z.union([
          z.object({
            type: z.enum(['user']),
            sudo: z
              .object({
                origin: z.enum(['totp', 'webauthn', 'recovery-code']).describe('Possible multi-factor origins'),
                expiresAt: z.number(),
              })
              .optional(),
            origin: z.enum(['saml', 'github', 'gitlab', 'bitbucket', 'email', 'manual', 'passkey', 'otp', 'sms', 'invite', 'google']),
            createdAt: z.number(),
            expiresAt: z.number().optional(),
          }),
          z.object({
            type: z.enum(['team']),
            teamId: z.string(),
            origin: z.enum(['saml', 'github', 'gitlab', 'bitbucket', 'email', 'manual', 'passkey', 'otp', 'sms', 'invite', 'google']),
            createdAt: z.number(),
            expiresAt: z.number().optional(),
          }),
        ]),
      )
      .describe('The access scopes granted to the token.')
      .optional(),
    expiresAt: z.number().describe('Timestamp (in milliseconds) of when the token expires.').optional(),
    activeAt: z.number().describe('Timestamp (in milliseconds) of when the token was most recently used.'),
    createdAt: z.number().describe('Timestamp (in milliseconds) of when the token was created.'),
  })
  .describe('Authentication token metadata.') as unknown as ToZod<AuthToken>

/**
 * @description Data for the currently authenticated User.
 */
export const authUserSchema = z
  .object({
    createdAt: z.number().describe('UNIX timestamp (in milliseconds) when the User account was created.'),
    softBlock: z
      .object({
        blockedAt: z.number(),
        reason: z.enum([
          'BLOCKED_FOR_PLATFORM_ABUSE',
          'ENTERPRISE_TRIAL_ENDED',
          'FAIR_USE_LIMITS_EXCEEDED',
          'SUBSCRIPTION_CANCELED',
          'SUBSCRIPTION_EXPIRED',
          'UNPAID_INVOICE',
        ]),
        blockedDueToOverageType: z
          .enum([
            'analyticsUsage',
            'artifacts',
            'bandwidth',
            'blobDataTransfer',
            'blobTotalAdvancedRequests',
            'blobTotalAvgSizeInBytes',
            'blobTotalGetResponseObjectSizeInBytes',
            'blobTotalSimpleRequests',
            'connectDataTransfer',
            'dataCacheRead',
            'dataCacheWrite',
            'edgeConfigRead',
            'edgeConfigWrite',
            'edgeFunctionExecutionUnits',
            'edgeMiddlewareInvocations',
            'edgeRequest',
            'edgeRequestAdditionalCpuDuration',
            'elasticConcurrencyBuildSlots',
            'fastDataTransfer',
            'fastOriginTransfer',
            'fluidCpuDuration',
            'fluidDuration',
            'functionDuration',
            'functionInvocation',
            'imageOptimizationCacheRead',
            'imageOptimizationCacheWrite',
            'imageOptimizationTransformation',
            'logDrainsVolume',
            'monitoringMetric',
            'observabilityEvent',
            'onDemandConcurrencyMinutes',
            'runtimeCacheRead',
            'runtimeCacheWrite',
            'serverlessFunctionExecution',
            'sourceImages',
            'wafOwaspExcessBytes',
            'wafOwaspRequests',
            'wafRateLimitRequest',
            'webAnalyticsEvent',
          ])
          .optional(),
      })
      .describe(
        'When the User account has been "soft blocked", this property will contain the date when the restriction was enacted, and the identifier for why.',
      )
      .nullable(),
    billing: z.object({}).describe('An object containing billing infomation associated with the User account.').nullable(),
    resourceConfig: z
      .object({
        nodeType: z
          .string()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        concurrentBuilds: z
          .number()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        elasticConcurrencyEnabled: z
          .boolean()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        buildEntitlements: z
          .object({
            enhancedBuilds: z
              .boolean()
              .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
              .optional(),
          })
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        awsAccountType: z
          .string()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        awsAccountIds: z
          .array(z.string())
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        cfZoneName: z
          .string()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        imageOptimizationType: z
          .string()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        edgeConfigs: z
          .number()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        edgeConfigSize: z
          .number()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        edgeFunctionMaxSizeBytes: z
          .number()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        edgeFunctionExecutionTimeoutMs: z
          .number()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        serverlessFunctionMaxMemorySize: z
          .number()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        kvDatabases: z
          .number()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        postgresDatabases: z
          .number()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        blobStores: z
          .number()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        integrationStores: z
          .number()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        cronJobs: z
          .number()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        cronJobsPerProject: z
          .number()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        microfrontendGroupsPerTeam: z
          .number()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        microfrontendProjectsPerGroup: z
          .number()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        flagsExplorerOverridesThreshold: z
          .number()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        flagsExplorerUnlimitedOverrides: z
          .boolean()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        customEnvironmentsPerProject: z
          .number()
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
        buildMachine: z
          .object({
            purchaseType: z
              .enum(['enhanced', 'turbo'])
              .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
              .optional(),
            isDefaultBuildMachine: z
              .boolean()
              .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
              .optional(),
            cores: z
              .number()
              .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
              .optional(),
            memory: z
              .number()
              .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
              .optional(),
          })
          .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.')
          .optional(),
      })
      .describe('An object containing infomation related to the amount of platform resources may be allocated to the User account.'),
    stagingPrefix: z.string().describe('Prefix that will be used in the URL of "Preview" deployments created by the User account.'),
    activeDashboardViews: z
      .array(
        z
          .object({
            scopeId: z.string(),
            viewPreference: z.enum(['cards', 'list']).nullable().nullish(),
            favoritesViewPreference: z.enum(['closed', 'open']).nullable().nullish(),
            recentsViewPreference: z.enum(['closed', 'open']).nullable().nullish(),
          })
          .describe('set of dashboard view preferences (cards or list) per scopeId'),
      )
      .describe('set of dashboard view preferences (cards or list) per scopeId')
      .optional(),
    importFlowGitNamespace: z.union([z.string(), z.number()]).nullable().nullish(),
    importFlowGitNamespaceId: z.union([z.string(), z.number()]).nullable().nullish(),
    importFlowGitProvider: z.enum(['bitbucket', 'github', 'github-custom-host', 'gitlab']).nullable().nullish(),
    preferredScopesAndGitNamespaces: z
      .array(
        z.object({
          scopeId: z.string(),
          gitNamespaceId: z.union([z.string(), z.number()]).nullable(),
        }),
      )
      .optional(),
    dismissedToasts: z
      .array(
        z
          .object({
            name: z.string(),
            dismissals: z.array(
              z.object({
                scopeId: z.string(),
                createdAt: z.number(),
              }),
            ),
          })
          .describe('A record of when, under a certain scopeId, a toast was dismissed'),
      )
      .describe('A record of when, under a certain scopeId, a toast was dismissed')
      .optional(),
    favoriteProjectsAndSpaces: z
      .array(
        z
          .object({
            teamId: z.string(),
            projectId: z.string(),
          })
          .describe('A list of projects and spaces across teams that a user has marked as a favorite.'),
      )
      .describe('A list of projects and spaces across teams that a user has marked as a favorite.')
      .optional(),
    hasTrialAvailable: z.boolean().describe('Whether the user has a trial available for a paid plan subscription.'),
    remoteCaching: z
      .object({
        enabled: z.boolean().optional(),
      })
      .describe('remote caching settings')
      .optional(),
    dataCache: z
      .object({
        excessBillingEnabled: z.boolean().optional(),
      })
      .describe('data cache settings')
      .optional(),
    featureBlocks: z
      .object({
        webAnalytics: z
          .object({
            blockedFrom: z.number().optional(),
            blockedUntil: z.number().optional(),
            isCurrentlyBlocked: z.boolean(),
          })
          .optional(),
      })
      .describe('Feature blocks for the user')
      .optional(),
    id: z.string().describe("The User's unique identifier."),
    email: z.string().describe('Email address associated with the User account.'),
    name: z.string().describe('Name associated with the User account, or `null` if none has been provided.').nullable(),
    username: z.string().describe('Unique username associated with the User account.'),
    avatar: z
      .string()
      .describe('SHA1 hash of the avatar for the User account. Can be used in conjuction with the ... endpoint to retrieve the avatar image.')
      .nullable(),
    defaultTeamId: z.string().describe("The user's default team.").nullable(),
  })
  .describe('Data for the currently authenticated User.') as unknown as ToZod<AuthUser>

/**
 * @description A limited form of data for the currently authenticated User, due to the authentication token missing privileges to read the full User data.
 */
export const authUserLimitedSchema = z
  .object({
    limited: z
      .boolean()
      .describe(
        'Property indicating that this User data contains only limited information, due to the authentication token missing privileges to read the full User data. Re-login with email, GitHub, GitLab or Bitbucket in order to upgrade the authentication token with the necessary privileges.',
      ),
    id: z.string().describe("The User's unique identifier."),
    email: z.string().describe('Email address associated with the User account.'),
    name: z.string().describe('Name associated with the User account, or `null` if none has been provided.').nullable(),
    username: z.string().describe('Unique username associated with the User account.'),
    avatar: z
      .string()
      .describe('SHA1 hash of the avatar for the User account. Can be used in conjuction with the ... endpoint to retrieve the avatar image.')
      .nullable(),
    defaultTeamId: z.string().describe("The user's default team.").nullable(),
  })
  .describe(
    'A limited form of data for the currently authenticated User, due to the authentication token missing privileges to read the full User data.',
  ) as unknown as ToZod<AuthUserLimited>

/**
 * @description A deployment file tree entry
 */
export const fileTreeSchema = z
  .object({
    name: z.string().describe('The name of the file tree entry'),
    type: z.enum(['directory', 'file', 'invalid', 'lambda', 'middleware', 'symlink']).describe('String indicating the type of file tree entry.'),
    uid: z.string().describe('The unique identifier of the file (only valid for the `file` type)').optional(),
    children: z
      .array(z.lazy(() => fileTreeSchema).describe('A deployment file tree entry'))
      .describe('The list of children files of the directory (only valid for the `directory` type)')
      .optional(),
    contentType: z.string().describe('The content-type of the file (only valid for the `file` type)').optional(),
    mode: z.number().describe('The file "mode" indicating file type and permissions.'),
    symlink: z.string().describe('Not currently used. See `file-list-to-tree.ts`.').optional(),
  })
  .describe('A deployment file tree entry') as unknown as ToZod<FileTree>

export const readAccessGroupPathParamsSchema = z.object({
  idOrName: z.string(),
}) as unknown as ToZod<ReadAccessGroupPathParams>

export const readAccessGroupQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<ReadAccessGroupQueryParams>

export const readAccessGroup200Schema = z.object({
  entitlements: z.array(z.enum(['v0'])).optional(),
  isDsyncManaged: z.boolean(),
  name: z.string().describe('The name of this access group.'),
  createdAt: z.string().describe('Timestamp in milliseconds when the access group was created.'),
  teamId: z.string().describe('ID of the team that this access group belongs to.'),
  updatedAt: z.string().describe('Timestamp in milliseconds when the access group was last updated.'),
  accessGroupId: z.string().describe('ID of the access group.'),
  membersCount: z.number().describe('Number of members in the access group.'),
  projectsCount: z.number().describe('Number of projects in the access group.'),
  teamRoles: z.array(z.string()).describe('Roles that the team has in the access group.').optional(),
  teamPermissions: z.array(z.string()).describe('Permissions that the team has in the access group.').optional(),
}) as unknown as ToZod<ReadAccessGroup200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const readAccessGroup400Schema = z.unknown() as unknown as ToZod<ReadAccessGroup400>

export const readAccessGroup401Schema = z.unknown() as unknown as ToZod<ReadAccessGroup401>

/**
 * @description You do not have permission to access this resource.
 */
export const readAccessGroup403Schema = z.unknown() as unknown as ToZod<ReadAccessGroup403>

export const readAccessGroupQueryResponseSchema = z.lazy(() => readAccessGroup200Schema) as unknown as ToZod<ReadAccessGroupQueryResponse>

export const updateAccessGroupPathParamsSchema = z.object({
  idOrName: z.string(),
}) as unknown as ToZod<UpdateAccessGroupPathParams>

export const updateAccessGroupQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<UpdateAccessGroupQueryParams>

export const updateAccessGroup200Schema = z.object({
  entitlements: z.array(z.enum(['v0'])).optional(),
  name: z.string().describe('The name of this access group.'),
  createdAt: z.string().describe('Timestamp in milliseconds when the access group was created.'),
  teamId: z.string().describe('ID of the team that this access group belongs to.'),
  updatedAt: z.string().describe('Timestamp in milliseconds when the access group was last updated.'),
  accessGroupId: z.string().describe('ID of the access group.'),
  membersCount: z.number().describe('Number of members in the access group.'),
  projectsCount: z.number().describe('Number of projects in the access group.'),
  teamRoles: z.array(z.string()).describe('Roles that the team has in the access group.').optional(),
  teamPermissions: z.array(z.string()).describe('Permissions that the team has in the access group.').optional(),
}) as unknown as ToZod<UpdateAccessGroup200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const updateAccessGroup400Schema = z.unknown() as unknown as ToZod<UpdateAccessGroup400>

export const updateAccessGroup401Schema = z.unknown() as unknown as ToZod<UpdateAccessGroup401>

/**
 * @description You do not have permission to access this resource.
 */
export const updateAccessGroup403Schema = z.unknown() as unknown as ToZod<UpdateAccessGroup403>

export const updateAccessGroupMutationRequestSchema = z.object({
  name: z
    .string()
    .regex(/^[A-z0-9_ -]+$/)
    .max(50)
    .describe('The name of the access group')
    .optional(),
  projects: z
    .array(
      z.object({
        projectId: z.string().max(256).describe('The ID of the project.'),
        role: z
          .enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER'])
          .describe('The project role that will be added to this Access Group. \\"null\\" will remove this project level role.')
          .nullable(),
      }),
    )
    .optional(),
  membersToAdd: z.array(z.string()).describe('List of members to add to the access group.').optional(),
  membersToRemove: z.array(z.string()).describe('List of members to remove from the access group.').optional(),
}) as unknown as ToZod<UpdateAccessGroupMutationRequest>

export const updateAccessGroupMutationResponseSchema = z.lazy(() => updateAccessGroup200Schema) as unknown as ToZod<UpdateAccessGroupMutationResponse>

export const deleteAccessGroupPathParamsSchema = z.object({
  idOrName: z.string(),
}) as unknown as ToZod<DeleteAccessGroupPathParams>

export const deleteAccessGroupQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<DeleteAccessGroupQueryParams>

export const deleteAccessGroup200Schema = z.unknown() as unknown as ToZod<DeleteAccessGroup200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const deleteAccessGroup400Schema = z.unknown() as unknown as ToZod<DeleteAccessGroup400>

export const deleteAccessGroup401Schema = z.unknown() as unknown as ToZod<DeleteAccessGroup401>

/**
 * @description You do not have permission to access this resource.
 */
export const deleteAccessGroup403Schema = z.unknown() as unknown as ToZod<DeleteAccessGroup403>

export const deleteAccessGroupMutationResponseSchema = z.lazy(() => deleteAccessGroup200Schema) as unknown as ToZod<DeleteAccessGroupMutationResponse>

export const listAccessGroupMembersPathParamsSchema = z.object({
  idOrName: z.string().describe('The ID or name of the Access Group.'),
}) as unknown as ToZod<ListAccessGroupMembersPathParams>

export const listAccessGroupMembersQueryParamsSchema = z
  .object({
    limit: z.coerce.number().int().min(1).max(100).describe('Limit how many access group members should be returned.').optional(),
    next: z.string().describe('Continuation cursor to retrieve the next page of results.').optional(),
    search: z.string().describe('Search project members by their name, username, and email.').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<ListAccessGroupMembersQueryParams>

export const listAccessGroupMembers200Schema = z.object({
  members: z.array(
    z.object({
      avatar: z.string().optional(),
      email: z.string(),
      uid: z.string(),
      username: z.string(),
      name: z.string().optional(),
      createdAt: z.string().optional(),
      teamRole: z.enum(['BILLING', 'CONTRIBUTOR', 'DEVELOPER', 'MEMBER', 'OWNER', 'SECURITY', 'VIEWER']),
    }),
  ),
  pagination: z.object({
    count: z.number(),
    next: z.string().nullable(),
  }),
}) as unknown as ToZod<ListAccessGroupMembers200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const listAccessGroupMembers400Schema = z.unknown() as unknown as ToZod<ListAccessGroupMembers400>

export const listAccessGroupMembers401Schema = z.unknown() as unknown as ToZod<ListAccessGroupMembers401>

/**
 * @description You do not have permission to access this resource.
 */
export const listAccessGroupMembers403Schema = z.unknown() as unknown as ToZod<ListAccessGroupMembers403>

export const listAccessGroupMembersQueryResponseSchema = z.lazy(() => listAccessGroupMembers200Schema) as unknown as ToZod<ListAccessGroupMembersQueryResponse>

export const listAccessGroupsQueryParamsSchema = z
  .object({
    projectId: z.string().describe('Filter access groups by project.').optional(),
    search: z.string().describe('Search for access groups by name.').optional(),
    membersLimit: z.coerce.number().int().min(1).max(100).describe('Number of members to include in the response.').optional(),
    projectsLimit: z.coerce.number().int().min(1).max(100).describe('Number of projects to include in the response.').optional(),
    limit: z.coerce.number().int().min(1).max(100).describe('Limit how many access group should be returned.').optional(),
    next: z.string().describe('Continuation cursor to retrieve the next page of results.').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<ListAccessGroupsQueryParams>

export const listAccessGroups200Schema = z.union([
  z.object({}),
  z.object({
    accessGroups: z.array(
      z.object({
        members: z.array(z.string()).optional(),
        projects: z.array(z.string()).optional(),
        entitlements: z.array(z.string()).optional(),
        isDsyncManaged: z.boolean(),
        name: z.string().describe('The name of this access group.'),
        createdAt: z.string().describe('Timestamp in milliseconds when the access group was created.'),
        teamId: z.string().describe('ID of the team that this access group belongs to.'),
        updatedAt: z.string().describe('Timestamp in milliseconds when the access group was last updated.'),
        accessGroupId: z.string().describe('ID of the access group.'),
        membersCount: z.number().describe('Number of members in the access group.'),
        projectsCount: z.number().describe('Number of projects in the access group.'),
        teamRoles: z.array(z.string()).describe('Roles that the team has in the access group.').optional(),
        teamPermissions: z.array(z.string()).describe('Permissions that the team has in the access group.').optional(),
      }),
    ),
    pagination: z.object({
      count: z.number(),
      next: z.string().nullable(),
    }),
  }),
]) as unknown as ToZod<ListAccessGroups200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const listAccessGroups400Schema = z.unknown() as unknown as ToZod<ListAccessGroups400>

export const listAccessGroups401Schema = z.unknown() as unknown as ToZod<ListAccessGroups401>

/**
 * @description You do not have permission to access this resource.
 */
export const listAccessGroups403Schema = z.unknown() as unknown as ToZod<ListAccessGroups403>

export const listAccessGroupsQueryResponseSchema = z.lazy(() => listAccessGroups200Schema) as unknown as ToZod<ListAccessGroupsQueryResponse>

export const createAccessGroupQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<CreateAccessGroupQueryParams>

export const createAccessGroup200Schema = z.object({
  membersCount: z.number(),
  projectsCount: z.number(),
  name: z.string().describe('The name of this access group.'),
  createdAt: z.string().describe('Timestamp in milliseconds when the access group was created.'),
  teamId: z.string().describe('ID of the team that this access group belongs to.'),
  updatedAt: z.string().describe('Timestamp in milliseconds when the access group was last updated.'),
  accessGroupId: z.string().describe('ID of the access group.'),
  teamRoles: z.array(z.string()).describe('Roles that the team has in the access group.').optional(),
  teamPermissions: z.array(z.string()).describe('Permissions that the team has in the access group.').optional(),
}) as unknown as ToZod<CreateAccessGroup200>

/**
 * @description One of the provided values in the request body is invalid.
 */
export const createAccessGroup400Schema = z.unknown() as unknown as ToZod<CreateAccessGroup400>

export const createAccessGroup401Schema = z.unknown() as unknown as ToZod<CreateAccessGroup401>

/**
 * @description You do not have permission to access this resource.
 */
export const createAccessGroup403Schema = z.unknown() as unknown as ToZod<CreateAccessGroup403>

export const createAccessGroupMutationRequestSchema = z.object({
  name: z
    .string()
    .regex(/^[A-z0-9_ -]+$/)
    .max(50)
    .describe('The name of the access group'),
  projects: z
    .array(
      z.object({
        projectId: z.string().max(256).describe('The ID of the project.'),
        role: z
          .enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER'])
          .describe('The project role that will be added to this Access Group. \\"null\\" will remove this project level role.')
          .nullable(),
      }),
    )
    .optional(),
  membersToAdd: z.array(z.string()).describe('List of members to add to the access group.').optional(),
}) as unknown as ToZod<CreateAccessGroupMutationRequest>

export const createAccessGroupMutationResponseSchema = z.lazy(() => createAccessGroup200Schema) as unknown as ToZod<CreateAccessGroupMutationResponse>

export const listAccessGroupProjectsPathParamsSchema = z.object({
  idOrName: z.string().describe('The ID or name of the Access Group.'),
}) as unknown as ToZod<ListAccessGroupProjectsPathParams>

export const listAccessGroupProjectsQueryParamsSchema = z
  .object({
    limit: z.coerce.number().int().min(1).max(100).describe('Limit how many access group projects should be returned.').optional(),
    next: z.string().describe('Continuation cursor to retrieve the next page of results.').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<ListAccessGroupProjectsQueryParams>

export const listAccessGroupProjects200Schema = z.object({
  projects: z.array(
    z.object({
      projectId: z.string(),
      role: z.enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER']),
      createdAt: z.string(),
      updatedAt: z.string(),
      project: z.object({
        name: z.string().optional(),
        framework: z.string().nullable().nullish(),
        latestDeploymentId: z.string().optional(),
      }),
    }),
  ),
  pagination: z.object({
    count: z.number(),
    next: z.string().nullable(),
  }),
}) as unknown as ToZod<ListAccessGroupProjects200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const listAccessGroupProjects400Schema = z.unknown() as unknown as ToZod<ListAccessGroupProjects400>

export const listAccessGroupProjects401Schema = z.unknown() as unknown as ToZod<ListAccessGroupProjects401>

/**
 * @description You do not have permission to access this resource.
 */
export const listAccessGroupProjects403Schema = z.unknown() as unknown as ToZod<ListAccessGroupProjects403>

export const listAccessGroupProjectsQueryResponseSchema = z.lazy(
  () => listAccessGroupProjects200Schema,
) as unknown as ToZod<ListAccessGroupProjectsQueryResponse>

export const createAccessGroupProjectPathParamsSchema = z.object({
  accessGroupIdOrName: z.string(),
}) as unknown as ToZod<CreateAccessGroupProjectPathParams>

export const createAccessGroupProjectQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<CreateAccessGroupProjectQueryParams>

export const createAccessGroupProject200Schema = z.object({
  teamId: z.string(),
  accessGroupId: z.string(),
  projectId: z.string(),
  role: z.enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER']),
  createdAt: z.string(),
  updatedAt: z.string(),
}) as unknown as ToZod<CreateAccessGroupProject200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const createAccessGroupProject400Schema = z.unknown() as unknown as ToZod<CreateAccessGroupProject400>

export const createAccessGroupProject401Schema = z.unknown() as unknown as ToZod<CreateAccessGroupProject401>

/**
 * @description You do not have permission to access this resource.
 */
export const createAccessGroupProject403Schema = z.unknown() as unknown as ToZod<CreateAccessGroupProject403>

export const createAccessGroupProjectMutationRequestSchema = z.object({
  projectId: z.string().max(256).describe('The ID of the project.'),
  role: z.enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER']).describe('The project role that will be added to this Access Group.'),
}) as unknown as ToZod<CreateAccessGroupProjectMutationRequest>

export const createAccessGroupProjectMutationResponseSchema = z.lazy(
  () => createAccessGroupProject200Schema,
) as unknown as ToZod<CreateAccessGroupProjectMutationResponse>

export const readAccessGroupProjectPathParamsSchema = z.object({
  accessGroupIdOrName: z.string(),
  projectId: z.string(),
}) as unknown as ToZod<ReadAccessGroupProjectPathParams>

export const readAccessGroupProjectQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<ReadAccessGroupProjectQueryParams>

export const readAccessGroupProject200Schema = z.object({
  teamId: z.string(),
  accessGroupId: z.string(),
  projectId: z.string(),
  role: z.enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER']),
  createdAt: z.string(),
  updatedAt: z.string(),
}) as unknown as ToZod<ReadAccessGroupProject200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const readAccessGroupProject400Schema = z.unknown() as unknown as ToZod<ReadAccessGroupProject400>

export const readAccessGroupProject401Schema = z.unknown() as unknown as ToZod<ReadAccessGroupProject401>

/**
 * @description You do not have permission to access this resource.
 */
export const readAccessGroupProject403Schema = z.unknown() as unknown as ToZod<ReadAccessGroupProject403>

export const readAccessGroupProjectQueryResponseSchema = z.lazy(() => readAccessGroupProject200Schema) as unknown as ToZod<ReadAccessGroupProjectQueryResponse>

export const updateAccessGroupProjectPathParamsSchema = z.object({
  accessGroupIdOrName: z.string(),
  projectId: z.string(),
}) as unknown as ToZod<UpdateAccessGroupProjectPathParams>

export const updateAccessGroupProjectQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<UpdateAccessGroupProjectQueryParams>

export const updateAccessGroupProject200Schema = z.object({
  teamId: z.string(),
  accessGroupId: z.string(),
  projectId: z.string(),
  role: z.enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER']),
  createdAt: z.string(),
  updatedAt: z.string(),
}) as unknown as ToZod<UpdateAccessGroupProject200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const updateAccessGroupProject400Schema = z.unknown() as unknown as ToZod<UpdateAccessGroupProject400>

export const updateAccessGroupProject401Schema = z.unknown() as unknown as ToZod<UpdateAccessGroupProject401>

/**
 * @description You do not have permission to access this resource.
 */
export const updateAccessGroupProject403Schema = z.unknown() as unknown as ToZod<UpdateAccessGroupProject403>

export const updateAccessGroupProjectMutationRequestSchema = z.object({
  role: z.enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER']).describe('The project role that will be added to this Access Group.'),
}) as unknown as ToZod<UpdateAccessGroupProjectMutationRequest>

export const updateAccessGroupProjectMutationResponseSchema = z.lazy(
  () => updateAccessGroupProject200Schema,
) as unknown as ToZod<UpdateAccessGroupProjectMutationResponse>

export const deleteAccessGroupProjectPathParamsSchema = z.object({
  accessGroupIdOrName: z.string(),
  projectId: z.string(),
}) as unknown as ToZod<DeleteAccessGroupProjectPathParams>

export const deleteAccessGroupProjectQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<DeleteAccessGroupProjectQueryParams>

export const deleteAccessGroupProject200Schema = z.unknown() as unknown as ToZod<DeleteAccessGroupProject200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const deleteAccessGroupProject400Schema = z.unknown() as unknown as ToZod<DeleteAccessGroupProject400>

export const deleteAccessGroupProject401Schema = z.unknown() as unknown as ToZod<DeleteAccessGroupProject401>

/**
 * @description You do not have permission to access this resource.
 */
export const deleteAccessGroupProject403Schema = z.unknown() as unknown as ToZod<DeleteAccessGroupProject403>

export const deleteAccessGroupProjectMutationResponseSchema = z.lazy(
  () => deleteAccessGroupProject200Schema,
) as unknown as ToZod<DeleteAccessGroupProjectMutationResponse>

export const recordEventsQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<RecordEventsQueryParams>

export const recordEventsHeaderParamsSchema = z
  .object({
    'x-artifact-client-ci': z.string().max(50).describe('The continuous integration or delivery environment where this artifact is downloaded.').optional(),
    'x-artifact-client-interactive': z.coerce.number().int().min(0).max(1).describe('1 if the client is an interactive shell. Otherwise 0').optional(),
  })
  .optional() as unknown as ToZod<RecordEventsHeaderParams>

/**
 * @description Success. Event recorded.
 */
export const recordEvents200Schema = z.unknown() as unknown as ToZod<RecordEvents200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the headers is invalid
 */
export const recordEvents400Schema = z.unknown() as unknown as ToZod<RecordEvents400>

export const recordEvents401Schema = z.unknown() as unknown as ToZod<RecordEvents401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const recordEvents402Schema = z.unknown() as unknown as ToZod<RecordEvents402>

/**
 * @description The customer has reached their spend cap limit and has been paused. An owner can disable the cap or raise the limit in settings.\nThe Remote Caching usage limit has been reached for this account for this billing cycle.\nRemote Caching has been disabled for this team or user. An owner can enable it in the billing settings.\nYou do not have permission to access this resource.
 */
export const recordEvents403Schema = z.unknown() as unknown as ToZod<RecordEvents403>

export const recordEventsMutationRequestSchema = z.array(
  z.object({
    sessionId: z.string().describe('A UUID (universally unique identifer) for the session that generated this event.'),
    source: z
      .enum(['LOCAL', 'REMOTE'])
      .describe(
        "One of `LOCAL` or `REMOTE`. `LOCAL` specifies that the cache event was from the user's filesystem cache. `REMOTE` specifies that the cache event is from a remote cache.",
      ),
    event: z
      .enum(['HIT', 'MISS'])
      .describe(
        'One of `HIT` or `MISS`. `HIT` specifies that a cached artifact for `hash` was found in the cache. `MISS` specifies that a cached artifact with `hash` was not found.',
      ),
    hash: z.string().describe('The artifact hash'),
    duration: z.number().describe('The time taken to generate the artifact. This should be sent as a body parameter on `HIT` events.').optional(),
  }),
) as unknown as ToZod<RecordEventsMutationRequest>

export const recordEventsMutationResponseSchema = z.lazy(() => recordEvents200Schema) as unknown as ToZod<RecordEventsMutationResponse>

export const statusQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<StatusQueryParams>

export const status200Schema = z.object({
  status: z.enum(['disabled', 'enabled', 'over_limit', 'paused']),
}) as unknown as ToZod<Status200>

export const status400Schema = z.unknown() as unknown as ToZod<Status400>

export const status401Schema = z.unknown() as unknown as ToZod<Status401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const status402Schema = z.unknown() as unknown as ToZod<Status402>

/**
 * @description You do not have permission to access this resource.
 */
export const status403Schema = z.unknown() as unknown as ToZod<Status403>

export const statusQueryResponseSchema = z.lazy(() => status200Schema) as unknown as ToZod<StatusQueryResponse>

export const uploadArtifactPathParamsSchema = z.object({
  hash: z.string().describe('The artifact hash'),
}) as unknown as ToZod<UploadArtifactPathParams>

export const uploadArtifactQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<UploadArtifactQueryParams>

export const uploadArtifactHeaderParamsSchema = z.object({
  'Content-Length': z.coerce.number().describe('The artifact size in bytes'),
  'x-artifact-duration': z.coerce.number().describe('The time taken to generate the uploaded artifact in milliseconds.').optional(),
  'x-artifact-client-ci': z.string().max(50).describe('The continuous integration or delivery environment where this artifact was generated.').optional(),
  'x-artifact-client-interactive': z.coerce.number().int().min(0).max(1).describe('1 if the client is an interactive shell. Otherwise 0').optional(),
  'x-artifact-tag': z
    .string()
    .max(600)
    .describe('The base64 encoded tag for this artifact. The value is sent back to clients when the artifact is downloaded as the header `x-artifact-tag`')
    .optional(),
}) as unknown as ToZod<UploadArtifactHeaderParams>

/**
 * @description File successfully uploaded
 */
export const uploadArtifact202Schema = z.object({
  urls: z.array(z.string()).describe('Array of URLs where the artifact was updated'),
}) as unknown as ToZod<UploadArtifact202>

/**
 * @description One of the provided values in the request query is invalid.\nOne of the provided values in the headers is invalid\nFile size is not valid
 */
export const uploadArtifact400Schema = z.unknown() as unknown as ToZod<UploadArtifact400>

export const uploadArtifact401Schema = z.unknown() as unknown as ToZod<UploadArtifact401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const uploadArtifact402Schema = z.unknown() as unknown as ToZod<UploadArtifact402>

/**
 * @description The customer has reached their spend cap limit and has been paused. An owner can disable the cap or raise the limit in settings.\nThe Remote Caching usage limit has been reached for this account for this billing cycle.\nRemote Caching has been disabled for this team or user. An owner can enable it in the billing settings.\nYou do not have permission to access this resource.
 */
export const uploadArtifact403Schema = z.unknown() as unknown as ToZod<UploadArtifact403>

export const uploadArtifactMutationResponseSchema = z.lazy(() => uploadArtifact202Schema) as unknown as ToZod<UploadArtifactMutationResponse>

export const downloadArtifactPathParamsSchema = z.object({
  hash: z.string().describe('The artifact hash'),
}) as unknown as ToZod<DownloadArtifactPathParams>

export const downloadArtifactQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<DownloadArtifactQueryParams>

export const downloadArtifactHeaderParamsSchema = z
  .object({
    'x-artifact-client-ci': z.string().max(50).describe('The continuous integration or delivery environment where this artifact is downloaded.').optional(),
    'x-artifact-client-interactive': z.coerce.number().int().min(0).max(1).describe('1 if the client is an interactive shell. Otherwise 0').optional(),
  })
  .optional() as unknown as ToZod<DownloadArtifactHeaderParams>

/**
 * @description The artifact was found and is downloaded as a stream. Content-Length should be verified.
 */
export const downloadArtifact200Schema = z
  .instanceof(File)
  .describe('An octet stream response that will be piped to the response stream.') as unknown as ToZod<DownloadArtifact200>

/**
 * @description One of the provided values in the request query is invalid.\nOne of the provided values in the headers is invalid
 */
export const downloadArtifact400Schema = z.unknown() as unknown as ToZod<DownloadArtifact400>

export const downloadArtifact401Schema = z.unknown() as unknown as ToZod<DownloadArtifact401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const downloadArtifact402Schema = z.unknown() as unknown as ToZod<DownloadArtifact402>

/**
 * @description The customer has reached their spend cap limit and has been paused. An owner can disable the cap or raise the limit in settings.\nThe Remote Caching usage limit has been reached for this account for this billing cycle.\nRemote Caching has been disabled for this team or user. An owner can enable it in the billing settings.\nYou do not have permission to access this resource.
 */
export const downloadArtifact403Schema = z.unknown() as unknown as ToZod<DownloadArtifact403>

/**
 * @description The artifact was not found
 */
export const downloadArtifact404Schema = z.unknown() as unknown as ToZod<DownloadArtifact404>

export const downloadArtifactQueryResponseSchema = z.lazy(() => downloadArtifact200Schema) as unknown as ToZod<DownloadArtifactQueryResponse>

export const artifactExistsPathParamsSchema = z.object({
  hash: z.string().describe('The artifact hash'),
}) as unknown as ToZod<ArtifactExistsPathParams>

export const artifactExistsQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<ArtifactExistsQueryParams>

/**
 * @description The artifact was found and headers are returned
 */
export const artifactExists200Schema = z.unknown() as unknown as ToZod<ArtifactExists200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const artifactExists400Schema = z.unknown() as unknown as ToZod<ArtifactExists400>

export const artifactExists401Schema = z.unknown() as unknown as ToZod<ArtifactExists401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const artifactExists402Schema = z.unknown() as unknown as ToZod<ArtifactExists402>

/**
 * @description The customer has reached their spend cap limit and has been paused. An owner can disable the cap or raise the limit in settings.\nThe Remote Caching usage limit has been reached for this account for this billing cycle.\nRemote Caching has been disabled for this team or user. An owner can enable it in the billing settings.\nYou do not have permission to access this resource.
 */
export const artifactExists403Schema = z.unknown() as unknown as ToZod<ArtifactExists403>

/**
 * @description The artifact was not found
 */
export const artifactExists404Schema = z.unknown() as unknown as ToZod<ArtifactExists404>

export const artifactExistsMutationResponseSchema = z.lazy(() => artifactExists200Schema) as unknown as ToZod<ArtifactExistsMutationResponse>

export const artifactQueryQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<ArtifactQueryQueryParams>

export const artifactQuery200Schema = z.object({}).catchall(
  z
    .union([
      z.object({
        size: z.number(),
        taskDurationMs: z.number(),
        tag: z.string().optional(),
      }),
      z.object({
        error: z.object({
          message: z.string(),
        }),
      }),
    ])
    .nullable(),
) as unknown as ToZod<ArtifactQuery200>

/**
 * @description One of the provided values in the request body is invalid.
 */
export const artifactQuery400Schema = z.unknown() as unknown as ToZod<ArtifactQuery400>

export const artifactQuery401Schema = z.unknown() as unknown as ToZod<ArtifactQuery401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const artifactQuery402Schema = z.unknown() as unknown as ToZod<ArtifactQuery402>

/**
 * @description The customer has reached their spend cap limit and has been paused. An owner can disable the cap or raise the limit in settings.\nThe Remote Caching usage limit has been reached for this account for this billing cycle.\nRemote Caching has been disabled for this team or user. An owner can enable it in the billing settings.\nYou do not have permission to access this resource.
 */
export const artifactQuery403Schema = z.unknown() as unknown as ToZod<ArtifactQuery403>

export const artifactQueryMutationRequestSchema = z.object({
  hashes: z.array(z.string()).describe('artifact hashes'),
}) as unknown as ToZod<ArtifactQueryMutationRequest>

export const artifactQueryMutationResponseSchema = z.lazy(() => artifactQuery200Schema) as unknown as ToZod<ArtifactQueryMutationResponse>

export const createCheckPathParamsSchema = z.object({
  deploymentId: z.string().describe('The deployment to create the check for.'),
}) as unknown as ToZod<CreateCheckPathParams>

export const createCheckQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<CreateCheckQueryParams>

export const createCheck200Schema = z.object({
  id: z.string(),
  name: z.string(),
  path: z.string().optional(),
  status: z.enum(['completed', 'registered', 'running']),
  conclusion: z.enum(['canceled', 'failed', 'neutral', 'skipped', 'stale', 'succeeded']).optional(),
  blocking: z.boolean(),
  output: z
    .object({
      metrics: z
        .object({
          FCP: z.object({
            value: z.number().nullable(),
            previousValue: z.number().optional(),
            source: z.enum(['web-vitals']),
          }),
          LCP: z.object({
            value: z.number().nullable(),
            previousValue: z.number().optional(),
            source: z.enum(['web-vitals']),
          }),
          CLS: z.object({
            value: z.number().nullable(),
            previousValue: z.number().optional(),
            source: z.enum(['web-vitals']),
          }),
          TBT: z.object({
            value: z.number().nullable(),
            previousValue: z.number().optional(),
            source: z.enum(['web-vitals']),
          }),
          virtualExperienceScore: z
            .object({
              value: z.number().nullable(),
              previousValue: z.number().optional(),
              source: z.enum(['web-vitals']),
            })
            .optional(),
        })
        .optional(),
    })
    .optional(),
  detailsUrl: z.string().optional(),
  integrationId: z.string(),
  deploymentId: z.string(),
  externalId: z.string().optional(),
  createdAt: z.number(),
  updatedAt: z.number(),
  startedAt: z.number().optional(),
  completedAt: z.number().optional(),
  rerequestable: z.boolean().optional(),
}) as unknown as ToZod<CreateCheck200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.\nCannot create check for finished deployment\nThe provided token is not from an OAuth2 Client
 */
export const createCheck400Schema = z.unknown() as unknown as ToZod<CreateCheck400>

export const createCheck401Schema = z.unknown() as unknown as ToZod<CreateCheck401>

/**
 * @description You do not have permission to access this resource.
 */
export const createCheck403Schema = z.unknown() as unknown as ToZod<CreateCheck403>

/**
 * @description The deployment was not found
 */
export const createCheck404Schema = z.unknown() as unknown as ToZod<CreateCheck404>

export const createCheckMutationRequestSchema = z.object({
  name: z.string().max(100).describe('The name of the check being created'),
  path: z.string().max(255).describe('Path of the page that is being checked').optional(),
  blocking: z.boolean().describe('Whether the check should block a deployment from succeeding'),
  detailsUrl: z.string().describe('URL to display for further details').optional(),
  externalId: z.string().describe('An identifier that can be used as an external reference').optional(),
  rerequestable: z.boolean().describe('Whether a user should be able to request for the check to be rerun if it fails').optional(),
}) as unknown as ToZod<CreateCheckMutationRequest>

export const createCheckMutationResponseSchema = z.lazy(() => createCheck200Schema) as unknown as ToZod<CreateCheckMutationResponse>

export const getAllChecksPathParamsSchema = z.object({
  deploymentId: z.string().describe('The deployment to get all checks for'),
}) as unknown as ToZod<GetAllChecksPathParams>

export const getAllChecksQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetAllChecksQueryParams>

export const getAllChecks200Schema = z.object({
  checks: z.array(
    z.object({
      completedAt: z.number().optional(),
      conclusion: z.enum(['canceled', 'failed', 'neutral', 'skipped', 'stale', 'succeeded']).optional(),
      createdAt: z.number(),
      detailsUrl: z.string().optional(),
      id: z.string(),
      integrationId: z.string(),
      name: z.string(),
      output: z
        .object({
          metrics: z
            .object({
              FCP: z.object({
                value: z.number().nullable(),
                previousValue: z.number().optional(),
                source: z.enum(['web-vitals']),
              }),
              LCP: z.object({
                value: z.number().nullable(),
                previousValue: z.number().optional(),
                source: z.enum(['web-vitals']),
              }),
              CLS: z.object({
                value: z.number().nullable(),
                previousValue: z.number().optional(),
                source: z.enum(['web-vitals']),
              }),
              TBT: z.object({
                value: z.number().nullable(),
                previousValue: z.number().optional(),
                source: z.enum(['web-vitals']),
              }),
              virtualExperienceScore: z
                .object({
                  value: z.number().nullable(),
                  previousValue: z.number().optional(),
                  source: z.enum(['web-vitals']),
                })
                .optional(),
            })
            .optional(),
        })
        .optional(),
      path: z.string().optional(),
      rerequestable: z.boolean(),
      startedAt: z.number().optional(),
      status: z.enum(['completed', 'registered', 'running']),
      updatedAt: z.number(),
    }),
  ),
}) as unknown as ToZod<GetAllChecks200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getAllChecks400Schema = z.unknown() as unknown as ToZod<GetAllChecks400>

export const getAllChecks401Schema = z.unknown() as unknown as ToZod<GetAllChecks401>

/**
 * @description You do not have permission to access this resource.
 */
export const getAllChecks403Schema = z.unknown() as unknown as ToZod<GetAllChecks403>

/**
 * @description The deployment was not found
 */
export const getAllChecks404Schema = z.unknown() as unknown as ToZod<GetAllChecks404>

export const getAllChecksQueryResponseSchema = z.lazy(() => getAllChecks200Schema) as unknown as ToZod<GetAllChecksQueryResponse>

export const getCheckPathParamsSchema = z.object({
  deploymentId: z.string().describe('The deployment to get the check for.'),
  checkId: z.string().describe('The check to fetch'),
}) as unknown as ToZod<GetCheckPathParams>

export const getCheckQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetCheckQueryParams>

export const getCheck200Schema = z.object({
  id: z.string(),
  name: z.string(),
  path: z.string().optional(),
  status: z.enum(['completed', 'registered', 'running']),
  conclusion: z.enum(['canceled', 'failed', 'neutral', 'skipped', 'stale', 'succeeded']).optional(),
  blocking: z.boolean(),
  output: z
    .object({
      metrics: z
        .object({
          FCP: z.object({
            value: z.number().nullable(),
            previousValue: z.number().optional(),
            source: z.enum(['web-vitals']),
          }),
          LCP: z.object({
            value: z.number().nullable(),
            previousValue: z.number().optional(),
            source: z.enum(['web-vitals']),
          }),
          CLS: z.object({
            value: z.number().nullable(),
            previousValue: z.number().optional(),
            source: z.enum(['web-vitals']),
          }),
          TBT: z.object({
            value: z.number().nullable(),
            previousValue: z.number().optional(),
            source: z.enum(['web-vitals']),
          }),
          virtualExperienceScore: z
            .object({
              value: z.number().nullable(),
              previousValue: z.number().optional(),
              source: z.enum(['web-vitals']),
            })
            .optional(),
        })
        .optional(),
    })
    .optional(),
  detailsUrl: z.string().optional(),
  integrationId: z.string(),
  deploymentId: z.string(),
  externalId: z.string().optional(),
  createdAt: z.number(),
  updatedAt: z.number(),
  startedAt: z.number().optional(),
  completedAt: z.number().optional(),
  rerequestable: z.boolean().optional(),
}) as unknown as ToZod<GetCheck200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getCheck400Schema = z.unknown() as unknown as ToZod<GetCheck400>

export const getCheck401Schema = z.unknown() as unknown as ToZod<GetCheck401>

/**
 * @description You do not have permission to access this resource.\nThe provided token is not from an OAuth2 Client that created the Check
 */
export const getCheck403Schema = z.unknown() as unknown as ToZod<GetCheck403>

/**
 * @description Check was not found\nThe deployment was not found
 */
export const getCheck404Schema = z.unknown() as unknown as ToZod<GetCheck404>

export const getCheckQueryResponseSchema = z.lazy(() => getCheck200Schema) as unknown as ToZod<GetCheckQueryResponse>

export const updateCheckPathParamsSchema = z.object({
  deploymentId: z.string().describe('The deployment to update the check for.'),
  checkId: z.string().describe('The check being updated'),
}) as unknown as ToZod<UpdateCheckPathParams>

export const updateCheckQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<UpdateCheckQueryParams>

export const updateCheck200Schema = z.object({
  id: z.string(),
  name: z.string(),
  path: z.string().optional(),
  status: z.enum(['completed', 'registered', 'running']),
  conclusion: z.enum(['canceled', 'failed', 'neutral', 'skipped', 'stale', 'succeeded']).optional(),
  blocking: z.boolean(),
  output: z
    .object({
      metrics: z
        .object({
          FCP: z.object({
            value: z.number().nullable(),
            previousValue: z.number().optional(),
            source: z.enum(['web-vitals']),
          }),
          LCP: z.object({
            value: z.number().nullable(),
            previousValue: z.number().optional(),
            source: z.enum(['web-vitals']),
          }),
          CLS: z.object({
            value: z.number().nullable(),
            previousValue: z.number().optional(),
            source: z.enum(['web-vitals']),
          }),
          TBT: z.object({
            value: z.number().nullable(),
            previousValue: z.number().optional(),
            source: z.enum(['web-vitals']),
          }),
          virtualExperienceScore: z
            .object({
              value: z.number().nullable(),
              previousValue: z.number().optional(),
              source: z.enum(['web-vitals']),
            })
            .optional(),
        })
        .optional(),
    })
    .optional(),
  detailsUrl: z.string().optional(),
  integrationId: z.string(),
  deploymentId: z.string(),
  externalId: z.string().optional(),
  createdAt: z.number(),
  updatedAt: z.number(),
  startedAt: z.number().optional(),
  completedAt: z.number().optional(),
  rerequestable: z.boolean().optional(),
}) as unknown as ToZod<UpdateCheck200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.\nThe provided token is not from an OAuth2 Client
 */
export const updateCheck400Schema = z.unknown() as unknown as ToZod<UpdateCheck400>

export const updateCheck401Schema = z.unknown() as unknown as ToZod<UpdateCheck401>

/**
 * @description You do not have permission to access this resource.
 */
export const updateCheck403Schema = z.unknown() as unknown as ToZod<UpdateCheck403>

/**
 * @description Check was not found\nThe deployment was not found
 */
export const updateCheck404Schema = z.unknown() as unknown as ToZod<UpdateCheck404>

/**
 * @description The output provided is too large
 */
export const updateCheck413Schema = z.unknown() as unknown as ToZod<UpdateCheck413>

export const updateCheckMutationRequestSchema = z.object({
  name: z.string().max(100).describe('The name of the check being created').optional(),
  path: z.string().max(255).describe('Path of the page that is being checked').optional(),
  status: z.enum(['completed', 'running']).describe('The current status of the check').optional(),
  conclusion: z.enum(['canceled', 'failed', 'neutral', 'skipped', 'succeeded']).describe('The result of the check being run').optional(),
  detailsUrl: z.string().describe('A URL a user may visit to see more information about the check').optional(),
  output: z
    .object({
      metrics: z
        .object({
          FCP: z.object({
            value: z.number().describe('First Contentful Paint value').nullable(),
            previousValue: z.number().describe('Previous First Contentful Paint value to display a delta').optional(),
            source: z.enum(['web-vitals']),
          }),
          LCP: z.object({
            value: z.number().describe('Largest Contentful Paint value').nullable(),
            previousValue: z.number().describe('Previous Largest Contentful Paint value to display a delta').optional(),
            source: z.enum(['web-vitals']),
          }),
          CLS: z.object({
            value: z.number().describe('Cumulative Layout Shift value').nullable(),
            previousValue: z.number().describe('Previous Cumulative Layout Shift value to display a delta').optional(),
            source: z.enum(['web-vitals']),
          }),
          TBT: z.object({
            value: z.number().describe('Total Blocking Time value').nullable(),
            previousValue: z.number().describe('Previous Total Blocking Time value to display a delta').optional(),
            source: z.enum(['web-vitals']),
          }),
          virtualExperienceScore: z
            .object({
              value: z.number().int().min(0).max(100).describe('The calculated Virtual Experience Score value, between 0 and 100').nullable(),
              previousValue: z
                .number()
                .int()
                .min(0)
                .max(100)
                .describe('A previous Virtual Experience Score value to display a delta, between 0 and 100')
                .optional(),
              source: z.enum(['web-vitals']),
            })
            .optional(),
        })
        .describe('Metrics about the page')
        .optional(),
    })
    .describe('The results of the check Run')
    .optional(),
  externalId: z.string().describe('An identifier that can be used as an external reference').optional(),
}) as unknown as ToZod<UpdateCheckMutationRequest>

export const updateCheckMutationResponseSchema = z.lazy(() => updateCheck200Schema) as unknown as ToZod<UpdateCheckMutationResponse>

export const rerequestCheckPathParamsSchema = z.object({
  deploymentId: z.string().describe('The deployment to rerun the check for.'),
  checkId: z.string().describe('The check to rerun'),
}) as unknown as ToZod<RerequestCheckPathParams>

export const rerequestCheckQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<RerequestCheckQueryParams>

export const rerequestCheck200Schema = z.object({}) as unknown as ToZod<RerequestCheck200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const rerequestCheck400Schema = z.unknown() as unknown as ToZod<RerequestCheck400>

export const rerequestCheck401Schema = z.unknown() as unknown as ToZod<RerequestCheck401>

/**
 * @description You do not have permission to access this resource.
 */
export const rerequestCheck403Schema = z.unknown() as unknown as ToZod<RerequestCheck403>

/**
 * @description The deployment was not found\nCheck was not found
 */
export const rerequestCheck404Schema = z.unknown() as unknown as ToZod<RerequestCheck404>

export const rerequestCheckMutationResponseSchema = z.lazy(() => rerequestCheck200Schema) as unknown as ToZod<RerequestCheckMutationResponse>

export const deletedataCachepurgeAllQueryParamsSchema = z.object({
  projectIdOrName: z.string(),
}) as unknown as ToZod<DeletedataCachepurgeAllQueryParams>

export const deletedataCachepurgeAll200Schema = z.unknown() as unknown as ToZod<DeletedataCachepurgeAll200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const deletedataCachepurgeAll400Schema = z.unknown() as unknown as ToZod<DeletedataCachepurgeAll400>

export const deletedataCachepurgeAll401Schema = z.unknown() as unknown as ToZod<DeletedataCachepurgeAll401>

/**
 * @description You do not have permission to access this resource.
 */
export const deletedataCachepurgeAll403Schema = z.unknown() as unknown as ToZod<DeletedataCachepurgeAll403>

export const deletedataCachepurgeAll404Schema = z.unknown() as unknown as ToZod<DeletedataCachepurgeAll404>

export const deletedataCachepurgeAllMutationResponseSchema = z.lazy(
  () => deletedataCachepurgeAll200Schema,
) as unknown as ToZod<DeletedataCachepurgeAllMutationResponse>

export const patchdataCachebillingSettings200Schema = z.object({
  excessBillingEnabled: z.boolean().optional(),
}) as unknown as ToZod<PatchdataCachebillingSettings200>

/**
 * @description One of the provided values in the request body is invalid.
 */
export const patchdataCachebillingSettings400Schema = z.unknown() as unknown as ToZod<PatchdataCachebillingSettings400>

export const patchdataCachebillingSettings401Schema = z.unknown() as unknown as ToZod<PatchdataCachebillingSettings401>

/**
 * @description You do not have permission to access this resource.
 */
export const patchdataCachebillingSettings403Schema = z.unknown() as unknown as ToZod<PatchdataCachebillingSettings403>

export const patchdataCachebillingSettings404Schema = z.unknown() as unknown as ToZod<PatchdataCachebillingSettings404>

export const patchdataCachebillingSettingsMutationRequestSchema = z.object({
  excessBillingEnabled: z.boolean().optional(),
}) as unknown as ToZod<PatchdataCachebillingSettingsMutationRequest>

export const patchdataCachebillingSettingsMutationResponseSchema = z.lazy(
  () => patchdataCachebillingSettings200Schema,
) as unknown as ToZod<PatchdataCachebillingSettingsMutationResponse>

export const updateProjectDataCachePathParamsSchema = z.object({
  projectId: z.string().describe('The unique project identifier'),
}) as unknown as ToZod<UpdateProjectDataCachePathParams>

export const updateProjectDataCacheQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<UpdateProjectDataCacheQueryParams>

export const updateProjectDataCache200Schema = z.object({
  accountId: z.string(),
  analytics: z
    .object({
      id: z.string(),
      canceledAt: z.number().nullable().nullish(),
      disabledAt: z.number(),
      enabledAt: z.number(),
      paidAt: z.number().optional(),
      sampleRatePercent: z.number().nullable().nullish(),
      spendLimitInDollars: z.number().nullable().nullish(),
    })
    .optional(),
  speedInsights: z
    .object({
      id: z.string(),
      enabledAt: z.number().optional(),
      disabledAt: z.number().optional(),
      canceledAt: z.number().optional(),
      hasData: z.boolean().optional(),
      paidAt: z.number().optional(),
    })
    .optional(),
  autoExposeSystemEnvs: z.boolean().optional(),
  autoAssignCustomDomains: z.boolean().optional(),
  autoAssignCustomDomainsUpdatedBy: z.string().optional(),
  buildCommand: z.string().nullable().nullish(),
  commandForIgnoringBuildStep: z.string().nullable().nullish(),
  connectConfigurations: z
    .array(
      z.object({
        envId: z.union([z.string(), z.enum(['production', 'preview'])]),
        connectConfigurationId: z.string(),
        passive: z.boolean(),
        buildsEnabled: z.boolean(),
        aws: z
          .object({
            subnetIds: z.array(z.string()),
            securityGroupId: z.string(),
          })
          .optional(),
        createdAt: z.number(),
        updatedAt: z.number(),
      }),
    )
    .nullable()
    .nullish(),
  connectConfigurationId: z.string().nullable().nullish(),
  connectBuildsEnabled: z.boolean().optional(),
  passiveConnectConfigurationId: z.string().nullable().nullish(),
  createdAt: z.number().optional(),
  customerSupportCodeVisibility: z.boolean().optional(),
  crons: z
    .object({
      enabledAt: z
        .number()
        .describe('The time the feature was enabled for this project. Note: It enables automatically with the first Deployment that outputs cronjobs.'),
      disabledAt: z.number().describe('The time the feature was disabled for this project.').nullable(),
      updatedAt: z.number(),
      deploymentId: z.string().describe('The ID of the Deployment from which the definitions originated.').nullable(),
      definitions: z.array(
        z.object({
          host: z.string().describe('The hostname that should be used.'),
          path: z.string().describe('The path that should be called for the cronjob.'),
          schedule: z.string().describe('The cron expression.'),
        }),
      ),
    })
    .optional(),
  dataCache: z
    .object({
      userDisabled: z.boolean(),
      storageSizeBytes: z.number().nullable().nullish(),
      unlimited: z.boolean().optional(),
    })
    .optional(),
  deploymentExpiration: z
    .object({
      expirationDays: z.number().optional(),
      expirationDaysProduction: z.number().optional(),
      expirationDaysCanceled: z.number().optional(),
      expirationDaysErrored: z.number().optional(),
      deploymentsToKeep: z.number().optional(),
    })
    .nullable()
    .nullish(),
  devCommand: z.string().nullable().nullish(),
  directoryListing: z.boolean(),
  installCommand: z.string().nullable().nullish(),
  env: z
    .array(
      z.object({
        target: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])]).optional(),
        type: z.enum(['encrypted', 'plain', 'secret', 'sensitive', 'system']),
        sunsetSecretId: z.string().describe('This is used to identiy variables that have been migrated from type secret to sensitive.').optional(),
        decrypted: z.boolean().optional(),
        value: z.string(),
        vsmValue: z.string().optional(),
        id: z.string().optional(),
        key: z.string(),
        configurationId: z.string().nullable().nullish(),
        createdAt: z.number().optional(),
        updatedAt: z.number().optional(),
        createdBy: z.string().nullable().nullish(),
        updatedBy: z.string().nullable().nullish(),
        gitBranch: z.string().optional(),
        edgeConfigId: z.string().nullable().nullish(),
        edgeConfigTokenId: z.string().nullable().nullish(),
        contentHint: z
          .union([
            z.object({
              type: z.enum(['redis-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-read-only-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['blob-read-write-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url-non-pooling']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-prisma-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-user']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-host']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-password']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-database']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url-no-ssl']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['integration-store-secret']),
              storeId: z.string(),
              integrationId: z.string(),
              integrationProductId: z.string(),
              integrationConfigurationId: z.string(),
            }),
            z.object({
              type: z.enum(['flags-connection-string']),
              projectId: z.string(),
            }),
          ])
          .nullable()
          .nullish(),
        internalContentHint: z
          .object({
            type: z.enum(['flags-secret']),
            encryptedValue: z
              .string()
              .describe('Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.'),
          })
          .describe('Similar to `contentHints`, but should not be exposed to the user.')
          .nullable()
          .nullish(),
        comment: z.string().optional(),
        customEnvironmentIds: z.array(z.string()).optional(),
      }),
    )
    .optional(),
  customEnvironments: z
    .array(
      z
        .object({
          id: z.string().describe('Unique identifier for the custom environment (format: env_*)'),
          slug: z.string().describe('URL-friendly name of the environment'),
          type: z.enum(['development', 'preview', 'production']).describe('The type of environment (production, preview, or development)'),
          description: z.string().describe("Optional description of the environment's purpose").optional(),
          branchMatcher: z
            .object({
              type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
              pattern: z.string().describe('The pattern to match against branch names'),
            })
            .describe('Configuration for matching git branches to this environment')
            .optional(),
          domains: z
            .array(
              z
                .object({
                  name: z.string(),
                  apexName: z.string(),
                  projectId: z.string(),
                  redirect: z.string().nullable().nullish(),
                  redirectStatusCode: z
                    .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
                    .nullable()
                    .nullish(),
                  gitBranch: z.string().nullable().nullish(),
                  customEnvironmentId: z.string().nullable().nullish(),
                  updatedAt: z.number().optional(),
                  createdAt: z.number().optional(),
                  verified: z
                    .boolean()
                    .describe(
                      '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
                    ),
                  verification: z
                    .array(
                      z
                        .object({
                          type: z.string(),
                          domain: z.string(),
                          value: z.string(),
                          reason: z.string(),
                        })
                        .describe(
                          'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                        ),
                    )
                    .describe(
                      'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                    )
                    .optional(),
                })
                .describe('List of domains associated with this environment'),
            )
            .describe('List of domains associated with this environment')
            .optional(),
          currentDeploymentAliases: z.array(z.string()).describe('List of aliases for the current deployment').optional(),
          createdAt: z.number().describe('Timestamp when the environment was created'),
          updatedAt: z.number().describe('Timestamp when the environment was last updated'),
        })
        .describe('Internal representation of a custom environment with all required properties'),
    )
    .optional(),
  framework: z
    .enum([
      'angular',
      'astro',
      'blitzjs',
      'brunch',
      'create-react-app',
      'docusaurus',
      'docusaurus-2',
      'dojo',
      'eleventy',
      'ember',
      'fasthtml',
      'gatsby',
      'gridsome',
      'hexo',
      'hugo',
      'hydrogen',
      'ionic-angular',
      'ionic-react',
      'jekyll',
      'middleman',
      'nextjs',
      'nitro',
      'nuxtjs',
      'parcel',
      'polymer',
      'preact',
      'react-router',
      'redwoodjs',
      'remix',
      'saber',
      'sanity',
      'sanity-v3',
      'sapper',
      'scully',
      'solidstart',
      'solidstart-1',
      'stencil',
      'storybook',
      'svelte',
      'sveltekit',
      'sveltekit-1',
      'umijs',
      'vite',
      'vitepress',
      'vue',
      'vuepress',
      'zola',
    ])
    .nullable()
    .nullish(),
  gitForkProtection: z.boolean().optional(),
  gitLFS: z.boolean().optional(),
  id: z.string(),
  ipBuckets: z
    .array(
      z.object({
        bucket: z.string(),
        supportUntil: z.number().optional(),
      }),
    )
    .optional(),
  latestDeployments: z
    .array(
      z.object({
        id: z.string(),
        alias: z.array(z.string()).optional(),
        aliasAssigned: z.union([z.boolean(), z.number()]).nullable().nullish(),
        aliasError: z
          .object({
            code: z.string(),
            message: z.string(),
          })
          .nullable()
          .nullish(),
        aliasFinal: z.string().nullable().nullish(),
        automaticAliases: z.array(z.string()).optional(),
        branchMatcher: z
          .object({
            type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
            pattern: z.string().describe('The pattern to match against branch names'),
          })
          .optional(),
        buildingAt: z.number().optional(),
        builds: z
          .array(
            z.object({
              use: z.string(),
              src: z.string().optional(),
              dest: z.string().optional(),
            }),
          )
          .optional(),
        checksConclusion: z.enum(['canceled', 'failed', 'skipped', 'succeeded']).optional(),
        checksState: z.enum(['completed', 'registered', 'running']).optional(),
        connectBuildsEnabled: z.boolean().optional(),
        connectConfigurationId: z.string().optional(),
        createdAt: z.number(),
        createdIn: z.string(),
        creator: z
          .object({
            email: z.string(),
            githubLogin: z.string().optional(),
            gitlabLogin: z.string().optional(),
            uid: z.string(),
            username: z.string(),
          })
          .nullable(),
        deletedAt: z.number().optional(),
        deploymentHostname: z.string(),
        forced: z.boolean().optional(),
        name: z.string(),
        meta: z.object({}).catchall(z.string()).optional(),
        monorepoManager: z.string().nullable().nullish(),
        oidcTokenClaims: z
          .object({
            iss: z.string(),
            sub: z.string(),
            scope: z.string(),
            aud: z.string(),
            owner: z.string(),
            owner_id: z.string(),
            project: z.string(),
            project_id: z.string(),
            environment: z.string(),
          })
          .optional(),
        plan: z.enum(['enterprise', 'hobby', 'pro']),
        previewCommentsEnabled: z.boolean().describe('Whether or not preview comments are enabled for the deployment').optional(),
        private: z.boolean(),
        readyAt: z.number().optional(),
        readyState: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
        readySubstate: z.enum(['PROMOTED', 'ROLLING', 'STAGED']).optional(),
        requestedAt: z.number().optional(),
        target: z.string().nullable().nullish(),
        teamId: z.string().nullable().nullish(),
        type: z.enum(['LAMBDAS']),
        url: z.string(),
        userId: z.string(),
        withCache: z.boolean().optional(),
      }),
    )
    .optional(),
  link: z
    .union([
      z.object({
        org: z.string().optional(),
        repoOwnerId: z
          .number()
          .describe(
            'A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.',
          )
          .optional(),
        repo: z.string().optional(),
        repoId: z.number().optional(),
        type: z.enum(['github']).optional(),
        createdAt: z.number().optional(),
        deployHooks: z.array(
          z.object({
            createdAt: z.number().optional(),
            id: z.string(),
            name: z.string(),
            ref: z.string(),
            url: z.string(),
          }),
        ),
        gitCredentialId: z.string().optional(),
        updatedAt: z.number().optional(),
        sourceless: z.boolean().optional(),
        productionBranch: z.string().optional(),
      }),
      z.object({
        projectId: z.string().optional(),
        projectName: z.string().optional(),
        projectNameWithNamespace: z.string().optional(),
        projectNamespace: z.string().optional(),
        projectOwnerId: z
          .number()
          .describe(
            'A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes. This is the id of the top level group that a namespace belongs to. Gitlab supports group nesting (up to 20 levels).',
          )
          .optional(),
        projectUrl: z.string().optional(),
        type: z.enum(['gitlab']).optional(),
        createdAt: z.number().optional(),
        deployHooks: z.array(
          z.object({
            createdAt: z.number().optional(),
            id: z.string(),
            name: z.string(),
            ref: z.string(),
            url: z.string(),
          }),
        ),
        gitCredentialId: z.string().optional(),
        updatedAt: z.number().optional(),
        sourceless: z.boolean().optional(),
        productionBranch: z.string().optional(),
      }),
      z.object({
        name: z.string().optional(),
        slug: z.string().optional(),
        owner: z.string().optional(),
        type: z.enum(['bitbucket']).optional(),
        uuid: z.string().optional(),
        workspaceUuid: z.string().optional(),
        createdAt: z.number().optional(),
        deployHooks: z.array(
          z.object({
            createdAt: z.number().optional(),
            id: z.string(),
            name: z.string(),
            ref: z.string(),
            url: z.string(),
          }),
        ),
        gitCredentialId: z.string().optional(),
        updatedAt: z.number().optional(),
        sourceless: z.boolean().optional(),
        productionBranch: z.string().optional(),
      }),
      z.object({
        org: z.string().optional(),
        repoOwnerId: z
          .number()
          .describe(
            'A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.',
          )
          .optional(),
        repo: z.string().optional(),
        repoId: z.number().optional(),
        type: z.enum(['github-custom-host']).optional(),
        host: z.string().optional(),
        createdAt: z.number().optional(),
        deployHooks: z.array(
          z.object({
            createdAt: z.number().optional(),
            id: z.string(),
            name: z.string(),
            ref: z.string(),
            url: z.string(),
          }),
        ),
        gitCredentialId: z.string().optional(),
        updatedAt: z.number().optional(),
        sourceless: z.boolean().optional(),
        productionBranch: z.string().optional(),
      }),
    ])
    .optional(),
  microfrontends: z
    .union([
      z.object({
        updatedAt: z.number().describe('Timestamp when the microfrontends settings were last updated.'),
        groupIds: z
          .array(z.union([z.string(), z.string()]))
          .min(2)
          .max(2)
          .describe(
            'The group IDs of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.',
          ),
        enabled: z.boolean().describe('Whether microfrontends are enabled for this project.'),
        isDefaultApp: z
          .boolean()
          .describe(
            'Whether this project is the default application for the microfrontends group. The default application is the one that is used as the top level shell for the microfrontends group and hosts the other microfrontends.',
          )
          .optional(),
        defaultRoute: z
          .string()
          .describe(
            'A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI. Includes the leading slash, e.g. `/docs`',
          )
          .optional(),
        routeObservabilityToThisProject: z
          .boolean()
          .describe('Whether observability data should be routed to this microfrontend project or a root project.')
          .optional(),
      }),
      z.object({
        updatedAt: z.number(),
        groupIds: z
          .array(z.union([z.string(), z.string()]))
          .min(2)
          .max(2),
        enabled: z.boolean(),
      }),
    ])
    .optional(),
  name: z.string(),
  nodeVersion: z.enum(['10.x', '12.x', '14.x', '16.x', '18.x', '20.x', '22.x', '8.10.x']),
  optionsAllowlist: z
    .object({
      paths: z.array(
        z.object({
          value: z.string(),
        }),
      ),
    })
    .nullable()
    .nullish(),
  outputDirectory: z.string().nullable().nullish(),
  passwordProtection: z.object({}).nullable().nullish(),
  productionDeploymentsFastLane: z.boolean().optional(),
  publicSource: z.boolean().nullable().nullish(),
  resourceConfig: z.object({
    fluid: z.boolean().optional(),
    functionDefaultRegions: z.array(z.string()),
    functionDefaultTimeout: z.number().optional(),
    functionDefaultMemoryType: z.enum(['performance', 'standard', 'standard_legacy']).optional(),
    functionZeroConfigFailover: z.boolean().optional(),
    elasticConcurrencyEnabled: z.boolean().optional(),
    buildMachineType: z.enum(['enhanced', 'turbo']).optional(),
  }),
  rollbackDescription: z
    .object({
      userId: z.string().describe('The user who rolled back the project.'),
      username: z.string().describe('The username of the user who rolled back the project.'),
      description: z.string().describe('User-supplied explanation of why they rolled back the project. Limited to 250 characters.'),
      createdAt: z.number().describe('Timestamp of when the rollback was requested.'),
    })
    .describe('Description of why a project was rolled back, and by whom. Note that lastAliasRequest contains the from/to details of the rollback.')
    .optional(),
  rollingRelease: z
    .object({
      target: z
        .string()
        .describe(
          'The environment that the release targets, currently only supports production. Adding in case we want to configure with alias groups or custom environments.',
        ),
      stages: z
        .array(
          z
            .object({
              targetPercentage: z.number().describe('The percentage of traffic to serve to the canary deployment (0-100)'),
              requireApproval: z.boolean().describe('Whether or not this stage requires manual approval to proceed').optional(),
              duration: z.number().describe('Duration in minutes for automatic advancement to the next stage').optional(),
            })
            .describe(
              'An array of all the stages required during a deployment release. Each stage defines a target percentage and advancement rules. The final stage must always have targetPercentage: 100.',
            ),
        )
        .describe(
          'An array of all the stages required during a deployment release. Each stage defines a target percentage and advancement rules. The final stage must always have targetPercentage: 100.',
        )
        .nullable()
        .nullish(),
      canaryResponseHeader: z
        .boolean()
        .describe('Whether the request served by a canary deployment should return a header indicating a canary was served. Defaults to `false` when omitted.')
        .optional(),
    })
    .describe('Project-level rolling release configuration that defines how deployments should be gradually rolled out')
    .nullable()
    .nullish(),
  defaultResourceConfig: z.object({
    fluid: z.boolean().optional(),
    functionDefaultRegions: z.array(z.string()),
    functionDefaultTimeout: z.number().optional(),
    functionDefaultMemoryType: z.enum(['performance', 'standard', 'standard_legacy']).optional(),
    functionZeroConfigFailover: z.boolean().optional(),
    elasticConcurrencyEnabled: z.boolean().optional(),
    buildMachineType: z.enum(['enhanced', 'turbo']).optional(),
  }),
  rootDirectory: z.string().nullable().nullish(),
  serverlessFunctionZeroConfigFailover: z.boolean().optional(),
  skewProtectionBoundaryAt: z.number().optional(),
  skewProtectionMaxAge: z.number().optional(),
  skipGitConnectDuringLink: z.boolean().optional(),
  sourceFilesOutsideRootDirectory: z.boolean().optional(),
  enableAffectedProjectsDeployments: z.boolean().optional(),
  ssoProtection: z
    .object({
      deploymentType: z.enum(['all', 'all_except_custom_domains', 'preview', 'prod_deployment_urls_and_all_previews']),
    })
    .nullable()
    .nullish(),
  targets: z
    .object({})
    .catchall(
      z
        .object({
          id: z.string(),
          alias: z.array(z.string()).optional(),
          aliasAssigned: z.union([z.boolean(), z.number()]).nullable().nullish(),
          aliasError: z
            .object({
              code: z.string(),
              message: z.string(),
            })
            .nullable()
            .nullish(),
          aliasFinal: z.string().nullable().nullish(),
          automaticAliases: z.array(z.string()).optional(),
          branchMatcher: z
            .object({
              type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
              pattern: z.string().describe('The pattern to match against branch names'),
            })
            .optional(),
          buildingAt: z.number().optional(),
          builds: z
            .array(
              z.object({
                use: z.string(),
                src: z.string().optional(),
                dest: z.string().optional(),
              }),
            )
            .optional(),
          checksConclusion: z.enum(['canceled', 'failed', 'skipped', 'succeeded']).optional(),
          checksState: z.enum(['completed', 'registered', 'running']).optional(),
          connectBuildsEnabled: z.boolean().optional(),
          connectConfigurationId: z.string().optional(),
          createdAt: z.number(),
          createdIn: z.string(),
          creator: z
            .object({
              email: z.string(),
              githubLogin: z.string().optional(),
              gitlabLogin: z.string().optional(),
              uid: z.string(),
              username: z.string(),
            })
            .nullable(),
          deletedAt: z.number().optional(),
          deploymentHostname: z.string(),
          forced: z.boolean().optional(),
          name: z.string(),
          meta: z.object({}).catchall(z.string()).optional(),
          monorepoManager: z.string().nullable().nullish(),
          oidcTokenClaims: z
            .object({
              iss: z.string(),
              sub: z.string(),
              scope: z.string(),
              aud: z.string(),
              owner: z.string(),
              owner_id: z.string(),
              project: z.string(),
              project_id: z.string(),
              environment: z.string(),
            })
            .optional(),
          plan: z.enum(['enterprise', 'hobby', 'pro']),
          previewCommentsEnabled: z.boolean().describe('Whether or not preview comments are enabled for the deployment').optional(),
          private: z.boolean(),
          readyAt: z.number().optional(),
          readyState: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
          readySubstate: z.enum(['PROMOTED', 'ROLLING', 'STAGED']).optional(),
          requestedAt: z.number().optional(),
          target: z.string().nullable().nullish(),
          teamId: z.string().nullable().nullish(),
          type: z.enum(['LAMBDAS']),
          url: z.string(),
          userId: z.string(),
          withCache: z.boolean().optional(),
        })
        .nullable(),
    )
    .optional(),
  transferCompletedAt: z.number().optional(),
  transferStartedAt: z.number().optional(),
  transferToAccountId: z.string().optional(),
  transferredFromAccountId: z.string().optional(),
  updatedAt: z.number().optional(),
  live: z.boolean().optional(),
  enablePreviewFeedback: z.boolean().nullable().nullish(),
  enableProductionFeedback: z.boolean().nullable().nullish(),
  permissions: z
    .object({
      user: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      userConnection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      userSudo: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      webAuthn: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      oauth2Connection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      accessGroup: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      aliasGlobal: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      analyticsSampling: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      analyticsUsage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      auditLog: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingAddress: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingInformation: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingInvoice: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingInvoiceEmailRecipient: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingInvoiceLanguage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingPlan: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingPurchaseOrder: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingTaxId: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      blob: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      budget: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      cacheArtifact: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      cacheArtifactUsageEvent: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      codeChecks: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      concurrentBuilds: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      connect: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      connectConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      defaultDeploymentProtection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domain: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainAcceptDelegation: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainAuthCodes: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainCertificate: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainCheckConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainMove: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainPurchase: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainRecord: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainTransferIn: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      event: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      ownEvent: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sensitiveEnvironmentVariablePolicy: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      fileUpload: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      flagsExplorerSubscription: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      gitRepository: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      ipBlocking: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      imageOptimizationNewPrice: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationAccount: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationConfigurationTransfer: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationConfigurationProjects: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationVercelConfigurationOverride: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationConfigurationRole: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationSSOSession: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationResource: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationEvent: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationResourceSecrets: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationDeploymentAction: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceInstallationMember: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceBillingData: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceInvoice: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceExperimentationItem: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceExperimentationEdgeConfigData: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      jobGlobal: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      drain: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      logDrain: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      Monitoring: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      monitoringSettings: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      monitoringQuery: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      monitoringChart: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      monitoringAlert: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDeploymentFailed: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainExpire: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainMoved: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainPurchase: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainRenewal: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainTransfer: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainUnverified: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      NotificationMonitoringAlert: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationPaymentFailed: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationUsageAlert: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationPreferences: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationCustomerBudget: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationStatementOfReasons: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      observabilityConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      observabilityNotebook: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      observabilityFunnel: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      openTelemetryEndpoint: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      vercelAppInstallation: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      paymentMethod: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      permissions: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      postgres: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      previewDeploymentSuffix: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      proTrialOnboarding: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sharedEnvVars: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sharedEnvVarsProduction: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      space: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      spaceRun: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      passwordProtectionInvoiceItem: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      rateLimit: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      redis: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      repository: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      remoteCaching: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      samlConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      secret: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      redisStoreTokenSet: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      blobStoreTokenSet: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      postgresStoreTokenSet: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationStoreTokenSet: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationResourceReplCommand: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      storeTransfer: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      supportCase: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      supportCaseComment: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      dataCacheBillingSettings: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      team: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamAccessRequest: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamFellowMembership: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamGitExclusivity: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamInvite: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamInviteCode: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamJoin: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamMemberMfaStatus: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamMicrofrontends: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamOwnMembership: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamOwnMembershipDisconnectSAML: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      token: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      usage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      usageCycle: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      vpcPeeringConnection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      webAnalyticsPlan: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeConfigItem: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeConfigSchema: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeConfigToken: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      webhook: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      'webhook-event': z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      endpointVerification: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectTransferIn: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      oauth2Application: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      vercelRun: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      vercelRunExec: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      apiKey: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      apiKeyOwnedBySelf: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      aliasProject: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      aliasProtectionBypass: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      buildMachine: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      productionAliasProtectionBypass: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      connectConfigurationLink: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      dataCacheNamespace: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deployment: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentCheck: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentCheckPreview: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentCheckReRunFromProductionBranch: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentProductionGit: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentV0: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentPreview: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentPrivate: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentPromote: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentRollback: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeCacheNamespace: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      environments: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      logs: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      logsPreset: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      passwordProtection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      optionsAllowlist: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      job: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      observabilityData: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      onDemandBuild: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      onDemandConcurrency: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      project: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectFromV0: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectAccessGroup: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectAnalyticsSampling: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectCheck: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectCheckRun: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDeploymentHook: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDomain: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDomainMove: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDomainCheckConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectEnvVars: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectEnvVarsProduction: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectEnvVarsUnownedByIntegration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectFlags: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectId: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectIntegrationConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectLink: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectMember: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectMonitoring: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectPermissions: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectProductionBranch: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectTransfer: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectTransferOut: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectProtectionBypass: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectUsage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectAnalyticsUsage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectSupportCase: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectSupportCaseComment: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDeploymentExpiration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectRollingRelease: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectTier: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      seawallConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      skewProtection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      analytics: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      trustedIps: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      webAnalytics: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sharedEnvVarConnection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sonar: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
    })
    .optional(),
  lastRollbackTarget: z.object({}).nullable().nullish(),
  lastAliasRequest: z
    .object({
      fromDeploymentId: z.string(),
      toDeploymentId: z.string(),
      fromRollingReleaseId: z
        .string()
        .describe(
          'If rolling back from a rolling release, fromDeploymentId captures the "base" of that rolling release, and fromRollingReleaseId captures the "target" of that rolling release.',
        )
        .optional(),
      jobStatus: z.enum(['failed', 'in-progress', 'pending', 'skipped', 'succeeded']),
      requestedAt: z.number(),
      type: z.enum(['promote', 'rollback']),
    })
    .nullable()
    .nullish(),
  protectionBypass: z
    .object({})
    .catchall(
      z.union([
        z.object({
          createdAt: z.number(),
          createdBy: z.string(),
          scope: z.enum(['integration-automation-bypass']),
          integrationId: z.string(),
          configurationId: z.string(),
        }),
        z.object({
          createdAt: z.number(),
          createdBy: z.string(),
          scope: z.enum(['automation-bypass']),
        }),
      ]),
    )
    .optional(),
  hasActiveBranches: z.boolean().optional(),
  trustedIps: z
    .union([
      z.object({
        deploymentType: z.enum(['production', 'preview', 'all', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains']),
        addresses: z.array(
          z.object({
            value: z.string(),
            note: z.string().optional(),
          }),
        ),
        protectionMode: z.enum(['additional', 'exclusive']),
      }),
      z.object({
        deploymentType: z.enum(['production', 'preview', 'all', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains']),
      }),
    ])
    .nullable()
    .nullish(),
  gitComments: z
    .object({
      onPullRequest: z.boolean().describe('Whether the Vercel bot should comment on PRs'),
      onCommit: z.boolean().describe('Whether the Vercel bot should comment on commits'),
    })
    .optional(),
  gitProviderOptions: z
    .object({
      createDeployments: z
        .enum(['disabled', 'enabled'])
        .describe(
          'Whether the Vercel bot should automatically create GitHub deployments https://docs.github.com/en/rest/deployments/deployments#about-deployments NOTE: repository-dispatch events should be used instead',
        ),
    })
    .optional(),
  paused: z.boolean().optional(),
  concurrencyBucketName: z.string().optional(),
  webAnalytics: z
    .object({
      id: z.string(),
      disabledAt: z.number().optional(),
      canceledAt: z.number().optional(),
      enabledAt: z.number().optional(),
      hasData: z.boolean().optional(),
    })
    .optional(),
  security: z
    .object({
      attackModeEnabled: z.boolean().optional(),
      attackModeUpdatedAt: z.number().optional(),
      firewallEnabled: z.boolean().optional(),
      firewallUpdatedAt: z.number().optional(),
      attackModeActiveUntil: z.number().nullable().nullish(),
      firewallConfigVersion: z.number().optional(),
      firewallRoutes: z
        .array(
          z.object({
            src: z
              .union([
                z.string(),
                z.object({
                  re: z.string().optional(),
                  eq: z.string().optional(),
                  neq: z.string().optional(),
                  inc: z.array(z.string()).optional(),
                  ninc: z.array(z.string()).optional(),
                  pre: z.string().optional(),
                  suf: z.string().optional(),
                  gt: z.number().optional(),
                  gte: z.number().optional(),
                  lt: z.number().optional(),
                  lte: z.number().optional(),
                }),
              ])
              .optional(),
            has: z
              .array(
                z.object({
                  type: z.enum([
                    'cookie',
                    'environment',
                    'header',
                    'host',
                    'initial_request_path',
                    'ip_address',
                    'method',
                    'path',
                    'protocol',
                    'query',
                    'region',
                    'scheme',
                  ]),
                  key: z.string().optional(),
                  value: z
                    .union([
                      z.string(),
                      z.object({
                        re: z.string().optional(),
                        eq: z.string().optional(),
                        neq: z.string().optional(),
                        inc: z.array(z.string()).optional(),
                        ninc: z.array(z.string()).optional(),
                        pre: z.string().optional(),
                        suf: z.string().optional(),
                        gt: z.number().optional(),
                        gte: z.number().optional(),
                        lt: z.number().optional(),
                        lte: z.number().optional(),
                      }),
                    ])
                    .optional(),
                }),
              )
              .optional(),
            missing: z
              .array(
                z.object({
                  type: z.enum([
                    'cookie',
                    'environment',
                    'header',
                    'host',
                    'initial_request_path',
                    'ip_address',
                    'method',
                    'path',
                    'protocol',
                    'query',
                    'region',
                    'scheme',
                  ]),
                  key: z.string().optional(),
                  value: z
                    .union([
                      z.string(),
                      z.object({
                        re: z.string().optional(),
                        eq: z.string().optional(),
                        neq: z.string().optional(),
                        inc: z.array(z.string()).optional(),
                        ninc: z.array(z.string()).optional(),
                        pre: z.string().optional(),
                        suf: z.string().optional(),
                        gt: z.number().optional(),
                        gte: z.number().optional(),
                        lt: z.number().optional(),
                        lte: z.number().optional(),
                      }),
                    ])
                    .optional(),
                }),
              )
              .optional(),
            dest: z.string().optional(),
            status: z.number().optional(),
            handle: z.enum(['finalize', 'init']).optional(),
            mitigate: z
              .object({
                action: z.enum(['bypass', 'challenge', 'deny', 'log', 'rate_limit', 'redirect']),
                rule_id: z.string(),
                ttl: z.number().optional(),
                erl: z
                  .object({
                    algo: z.enum(['fixed_window', 'token_bucket']),
                    window: z.number(),
                    limit: z.number(),
                    keys: z.array(z.string()),
                  })
                  .optional(),
              })
              .optional(),
          }),
        )
        .optional(),
      firewallSeawallEnabled: z.boolean().optional(),
      ja3Enabled: z.boolean().optional(),
      ja4Enabled: z.boolean().optional(),
      firewallBypassIps: z.array(z.string()).optional(),
      managedRules: z
        .object({
          bot_filter: z.object({
            active: z.boolean(),
            action: z.enum(['challenge', 'deny', 'log']).optional(),
          }),
          ai_bots: z.object({
            active: z.boolean(),
            action: z.enum(['challenge', 'deny', 'log']).optional(),
          }),
          owasp: z.object({
            active: z.boolean(),
            action: z.enum(['challenge', 'deny', 'log']).optional(),
          }),
        })
        .nullable()
        .nullish(),
      botIdEnabled: z.boolean().optional(),
    })
    .optional(),
  oidcTokenConfig: z
    .object({
      enabled: z.boolean().describe('Whether or not to generate OpenID Connect JSON Web Tokens.').optional(),
      issuerMode: z.enum(['global', 'team']).describe('- team: `https://oidc.vercel.com/[team_slug]` - global: `https://oidc.vercel.com`').optional(),
    })
    .optional(),
  tier: z.enum(['advanced', 'critical', 'standard']).optional(),
  features: z
    .object({
      webAnalytics: z.boolean().optional(),
    })
    .optional(),
}) as unknown as ToZod<UpdateProjectDataCache200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const updateProjectDataCache400Schema = z.unknown() as unknown as ToZod<UpdateProjectDataCache400>

export const updateProjectDataCache401Schema = z.unknown() as unknown as ToZod<UpdateProjectDataCache401>

/**
 * @description You do not have permission to access this resource.
 */
export const updateProjectDataCache403Schema = z.unknown() as unknown as ToZod<UpdateProjectDataCache403>

export const updateProjectDataCache404Schema = z.unknown() as unknown as ToZod<UpdateProjectDataCache404>

export const updateProjectDataCacheMutationRequestSchema = z.object({
  disabled: z.boolean().describe('Enable or disable data cache for the project - default: false').optional(),
}) as unknown as ToZod<UpdateProjectDataCacheMutationRequest>

export const updateProjectDataCacheMutationResponseSchema = z.lazy(
  () => updateProjectDataCache200Schema,
) as unknown as ToZod<UpdateProjectDataCacheMutationResponse>

export const getDeploymentEventsPathParamsSchema = z.object({
  idOrUrl: z.string().describe('The unique identifier or hostname of the deployment.'),
}) as unknown as ToZod<GetDeploymentEventsPathParams>

export const getDeploymentEventsQueryParamsSchema = z.object({
  direction: z.enum(['backward', 'forward']).default('forward').describe('Order of the returned events based on the timestamp.'),
  follow: z
    .union([z.literal(0), z.literal(1)])
    .describe('When enabled, this endpoint will return live events as they happen.')
    .optional(),
  limit: z.coerce.number().describe('Maximum number of events to return. Provide `-1` to return all available logs.').optional(),
  name: z.string().describe('Deployment build ID.').optional(),
  since: z.coerce.number().describe('Timestamp for when build logs should be pulled from.').optional(),
  until: z.coerce.number().describe('Timestamp for when the build logs should be pulled up until.').optional(),
  statusCode: z.union([z.string(), z.coerce.number()]).describe('HTTP status code range to filter events by.').optional(),
  delimiter: z.union([z.literal(0), z.literal(1)]).optional(),
  builds: z.union([z.literal(0), z.literal(1)]).optional(),
  teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
  slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
}) as unknown as ToZod<GetDeploymentEventsQueryParams>

export const getDeploymentEvents200Schema = z
  .array(
    z
      .union([
        z.object({
          type: z.enum([
            'delimiter',
            'command',
            'stdout',
            'stderr',
            'exit',
            'deployment-state',
            'middleware',
            'middleware-invocation',
            'edge-function-invocation',
            'metric',
            'report',
            'fatal',
          ]),
          created: z.number(),
          payload: z.object({
            deploymentId: z.string(),
            info: z
              .object({
                type: z.string(),
                name: z.string(),
                entrypoint: z.string().optional(),
                path: z.string().optional(),
                step: z.string().optional(),
                readyState: z.string().optional(),
              })
              .optional(),
            text: z.string().optional(),
            id: z.string(),
            date: z.number(),
            serial: z.string(),
            created: z.number().optional(),
            statusCode: z.number().optional(),
            requestId: z.string().optional(),
            proxy: z
              .object({
                timestamp: z.number(),
                method: z.string(),
                host: z.string(),
                path: z.string(),
                statusCode: z.number().optional(),
                userAgent: z.array(z.string()),
                referer: z.string(),
                clientIp: z.string().optional(),
                region: z.string(),
                scheme: z.string().optional(),
                responseByteSize: z.number().optional(),
                cacheId: z.string().optional(),
                pathType: z.string().optional(),
                pathTypeVariant: z.string().optional(),
                vercelId: z.string().optional(),
                vercelCache: z.enum(['MISS', 'HIT', 'STALE', 'BYPASS', 'PRERENDER', 'REVALIDATED']).optional(),
                lambdaRegion: z.string().optional(),
                wafAction: z.enum(['log', 'challenge', 'deny', 'bypass', 'rate_limit']).optional(),
                wafRuleId: z.string().optional(),
              })
              .optional(),
          }),
        }),
        z.object({
          created: z.number(),
          date: z.number(),
          deploymentId: z.string(),
          id: z.string(),
          info: z.object({
            type: z.string(),
            name: z.string(),
            entrypoint: z.string().optional(),
            path: z.string().optional(),
            step: z.string().optional(),
            readyState: z.string().optional(),
          }),
          serial: z.string(),
          text: z.string().optional(),
          type: z.enum([
            'delimiter',
            'command',
            'stdout',
            'stderr',
            'exit',
            'deployment-state',
            'middleware',
            'middleware-invocation',
            'edge-function-invocation',
            'metric',
            'report',
            'fatal',
          ]),
          level: z.enum(['error', 'warning']).optional(),
        }),
      ])
      .nullable(),
  )
  .nullable() as unknown as ToZod<GetDeploymentEvents200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getDeploymentEvents400Schema = z.unknown() as unknown as ToZod<GetDeploymentEvents400>

export const getDeploymentEvents401Schema = z.unknown() as unknown as ToZod<GetDeploymentEvents401>

/**
 * @description You do not have permission to access this resource.
 */
export const getDeploymentEvents403Schema = z.unknown() as unknown as ToZod<GetDeploymentEvents403>

export const getDeploymentEvents500Schema = z.unknown() as unknown as ToZod<GetDeploymentEvents500>

export const getDeploymentEventsQueryResponseSchema = z.lazy(() => getDeploymentEvents200Schema) as unknown as ToZod<GetDeploymentEventsQueryResponse>

export const updateIntegrationDeploymentActionPathParamsSchema = z.object({
  deploymentId: z.string(),
  integrationConfigurationId: z.string(),
  resourceId: z.string(),
  action: z.string(),
}) as unknown as ToZod<UpdateIntegrationDeploymentActionPathParams>

export const updateIntegrationDeploymentAction202Schema = z.unknown() as unknown as ToZod<UpdateIntegrationDeploymentAction202>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const updateIntegrationDeploymentAction400Schema = z.unknown() as unknown as ToZod<UpdateIntegrationDeploymentAction400>

export const updateIntegrationDeploymentAction401Schema = z.unknown() as unknown as ToZod<UpdateIntegrationDeploymentAction401>

/**
 * @description You do not have permission to access this resource.
 */
export const updateIntegrationDeploymentAction403Schema = z.unknown() as unknown as ToZod<UpdateIntegrationDeploymentAction403>

export const updateIntegrationDeploymentActionMutationRequestSchema = z.object({
  status: z.enum(['failed', 'running', 'succeeded']).optional(),
  statusText: z.string().optional(),
  statusUrl: z.string().url().optional(),
  outcomes: z
    .array(
      z.object({
        kind: z.string(),
        secrets: z.array(
          z.object({
            name: z.string(),
            value: z.string(),
          }),
        ),
      }),
    )
    .optional(),
}) as unknown as ToZod<UpdateIntegrationDeploymentActionMutationRequest>

export const updateIntegrationDeploymentActionMutationResponseSchema = z.lazy(
  () => updateIntegrationDeploymentAction202Schema,
) as unknown as ToZod<UpdateIntegrationDeploymentActionMutationResponse>

export const getDeploymentPathParamsSchema = z.object({
  idOrUrl: z.string().describe('The unique identifier or hostname of the deployment.'),
}) as unknown as ToZod<GetDeploymentPathParams>

export const getDeploymentQueryParamsSchema = z
  .object({
    withGitRepoInfo: z.string().describe('Whether to add in gitRepo information.').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetDeploymentQueryParams>

/**
 * @description The deployment including only public information\nThe deployment including both public and private information
 */
export const getDeployment200Schema = z.union([
  z.object({
    aliasAssignedAt: z.union([z.boolean(), z.number()]).nullable().nullish(),
    alwaysRefuseToBuild: z.boolean().optional(),
    build: z.object({
      env: z.array(z.string()),
    }),
    buildArtifactUrls: z.array(z.string()).optional(),
    builds: z
      .array(
        z.object({
          use: z.string(),
          src: z.string().optional(),
          config: z.object({}).catchall(z.unknown()).optional(),
        }),
      )
      .optional(),
    env: z.array(z.string()),
    inspectorUrl: z.string().nullable(),
    isInConcurrentBuildsQueue: z.boolean(),
    isInSystemBuildsQueue: z.boolean(),
    projectSettings: z.object({
      buildCommand: z.string().nullable().nullish(),
      devCommand: z.string().nullable().nullish(),
      framework: z
        .enum([
          'blitzjs',
          'nextjs',
          'gatsby',
          'remix',
          'react-router',
          'astro',
          'hexo',
          'eleventy',
          'docusaurus-2',
          'docusaurus',
          'preact',
          'solidstart-1',
          'solidstart',
          'dojo',
          'ember',
          'vue',
          'scully',
          'ionic-angular',
          'angular',
          'polymer',
          'svelte',
          'sveltekit',
          'sveltekit-1',
          'ionic-react',
          'create-react-app',
          'gridsome',
          'umijs',
          'sapper',
          'saber',
          'stencil',
          'nuxtjs',
          'redwoodjs',
          'hugo',
          'jekyll',
          'brunch',
          'middleman',
          'zola',
          'hydrogen',
          'vite',
          'vitepress',
          'vuepress',
          'parcel',
          'fasthtml',
          'sanity-v3',
          'sanity',
          'storybook',
          'nitro',
        ])
        .nullable()
        .nullish(),
      commandForIgnoringBuildStep: z.string().nullable().nullish(),
      installCommand: z.string().nullable().nullish(),
      outputDirectory: z.string().nullable().nullish(),
      speedInsights: z
        .object({
          id: z.string(),
          enabledAt: z.number().optional(),
          disabledAt: z.number().optional(),
          canceledAt: z.number().optional(),
          hasData: z.boolean().optional(),
          paidAt: z.number().optional(),
        })
        .optional(),
      webAnalytics: z
        .object({
          id: z.string(),
          disabledAt: z.number().optional(),
          canceledAt: z.number().optional(),
          enabledAt: z.number().optional(),
          hasData: z.boolean().optional(),
        })
        .optional(),
    }),
    readyStateReason: z.string().optional(),
    integrations: z
      .object({
        status: z.enum(['skipped', 'pending', 'ready', 'error', 'timeout']),
        startedAt: z.number(),
        completedAt: z.number().optional(),
        skippedAt: z.number().optional(),
        skippedBy: z.string().optional(),
      })
      .optional(),
    images: z
      .object({
        sizes: z.array(z.number()).optional(),
        qualities: z.array(z.number()).optional(),
        domains: z.array(z.string()).optional(),
        remotePatterns: z
          .array(
            z.object({
              protocol: z.enum(['http', 'https']).describe('Must be `http` or `https`.').optional(),
              hostname: z.string().describe('Can be literal or wildcard. Single `*` matches a single subdomain. Double `**` matches any number of subdomains.'),
              port: z.string().describe('Can be literal port such as `8080` or empty string meaning no port.').optional(),
              pathname: z
                .string()
                .describe('Can be literal or wildcard. Single `*` matches a single path segment. Double `**` matches any number of path segments.')
                .optional(),
              search: z.string().describe('Can be literal query string such as `?v=1` or empty string meaning no query string.').optional(),
            }),
          )
          .optional(),
        localPatterns: z
          .array(
            z.object({
              pathname: z
                .string()
                .describe('Can be literal or wildcard. Single `*` matches a single path segment. Double `**` matches any number of path segments.')
                .optional(),
              search: z.string().describe('Can be literal query string such as `?v=1` or empty string meaning no query string.').optional(),
            }),
          )
          .optional(),
        minimumCacheTTL: z.number().optional(),
        formats: z.array(z.enum(['image/avif', 'image/webp'])).optional(),
        dangerouslyAllowSVG: z.boolean().optional(),
        contentSecurityPolicy: z.string().optional(),
        contentDispositionType: z.enum(['inline', 'attachment']).optional(),
      })
      .optional(),
    alias: z.array(z.string()).optional(),
    aliasAssigned: z.boolean(),
    bootedAt: z.number(),
    buildingAt: z.number(),
    buildContainerFinishedAt: z.number().describe('Since April 2025 it necessary for On-Demand Concurrency Minutes calculation').optional(),
    buildSkipped: z.boolean(),
    creator: z.object({
      uid: z.string(),
      username: z.string().optional(),
      avatar: z.string().optional(),
    }),
    initReadyAt: z.number().optional(),
    isFirstBranchDeployment: z.boolean().optional(),
    lambdas: z
      .array(
        z
          .object({
            id: z.string().optional(),
            createdAt: z.number().optional(),
            entrypoint: z.string().nullable().nullish(),
            readyState: z.enum(['BUILDING', 'ERROR', 'INITIALIZING', 'READY']).optional(),
            readyStateAt: z.number().optional(),
            output: z.array(
              z.object({
                path: z.string(),
                functionName: z.string(),
              }),
            ),
          })
          .describe('A partial representation of a Build used by the deployment endpoint.'),
      )
      .optional(),
    public: z.boolean(),
    ready: z.number().optional(),
    status: z.enum(['QUEUED', 'BUILDING', 'ERROR', 'INITIALIZING', 'READY', 'CANCELED']),
    team: z
      .object({
        id: z.string(),
        name: z.string(),
        slug: z.string(),
        avatar: z.string().optional(),
      })
      .optional(),
    userAliases: z.array(z.string()).optional(),
    previewCommentsEnabled: z.boolean().optional(),
    ttyBuildLogs: z.boolean().optional(),
    customEnvironment: z
      .union([
        z.object({
          id: z.string().describe('Unique identifier for the custom environment (format: env_*)'),
          slug: z.string().describe('URL-friendly name of the environment'),
          type: z.enum(['production', 'preview', 'development']).describe('The type of environment (production, preview, or development)'),
          description: z.string().describe("Optional description of the environment's purpose").optional(),
          branchMatcher: z
            .object({
              type: z.enum(['endsWith', 'startsWith', 'equals']).describe('The type of matching to perform'),
              pattern: z.string().describe('The pattern to match against branch names'),
            })
            .describe('Configuration for matching git branches to this environment')
            .optional(),
          domains: z
            .array(
              z
                .object({
                  name: z.string(),
                  apexName: z.string(),
                  projectId: z.string(),
                  redirect: z.string().nullable().nullish(),
                  redirectStatusCode: z
                    .union([z.literal(307), z.literal(301), z.literal(302), z.literal(308)])
                    .nullable()
                    .nullish(),
                  gitBranch: z.string().nullable().nullish(),
                  customEnvironmentId: z.string().nullable().nullish(),
                  updatedAt: z.number().optional(),
                  createdAt: z.number().optional(),
                  verified: z
                    .boolean()
                    .describe(
                      '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
                    ),
                  verification: z
                    .array(
                      z
                        .object({
                          type: z.string(),
                          domain: z.string(),
                          value: z.string(),
                          reason: z.string(),
                        })
                        .describe(
                          'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                        ),
                    )
                    .describe(
                      'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                    )
                    .optional(),
                })
                .describe('List of domains associated with this environment'),
            )
            .describe('List of domains associated with this environment')
            .optional(),
          currentDeploymentAliases: z.array(z.string()).describe('List of aliases for the current deployment').optional(),
          createdAt: z.number().describe('Timestamp when the environment was created'),
          updatedAt: z.number().describe('Timestamp when the environment was last updated'),
        }),
        z.object({
          id: z.string(),
        }),
      ])
      .optional(),
    oomReport: z.enum(['out-of-memory']).optional(),
    aliasWarning: z
      .object({
        code: z.string(),
        message: z.string(),
        link: z.string().optional(),
        action: z.string().optional(),
      })
      .nullable()
      .nullish(),
    id: z.string(),
    name: z.string(),
    type: z.enum(['LAMBDAS']),
    createdAt: z.number(),
    readyState: z.enum(['QUEUED', 'BUILDING', 'ERROR', 'INITIALIZING', 'READY', 'CANCELED']),
    aliasError: z
      .object({
        code: z.string(),
        message: z.string(),
      })
      .nullable()
      .nullish(),
    aliasFinal: z.string().nullable().nullish(),
    autoAssignCustomDomains: z.boolean().describe('applies to custom domains only, defaults to `true`').optional(),
    automaticAliases: z.array(z.string()).optional(),
    buildErrorAt: z.number().optional(),
    checksState: z.enum(['registered', 'running', 'completed']).optional(),
    checksConclusion: z.enum(['succeeded', 'failed', 'skipped', 'canceled']).optional(),
    deletedAt: z.number().nullable().nullish(),
    defaultRoute: z.string().describe('Computed field that is only available for deployments with a microfrontend configuration.').optional(),
    canceledAt: z.number().optional(),
    errorCode: z.string().optional(),
    errorLink: z.string().optional(),
    errorMessage: z.string().nullable().nullish(),
    errorStep: z.string().optional(),
    passiveRegions: z
      .array(z.string())
      .describe(
        'Since November 2023 this field defines a set of regions that we will deploy the lambda to passively Lambdas will be deployed to these regions but only invoked if all of the primary `regions` are marked as out of service',
      )
      .optional(),
    gitSource: z
      .union([
        z.object({
          type: z.enum(['github']),
          repoId: z.union([z.string(), z.number()]),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['github']),
          org: z.string(),
          repo: z.string(),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['github-custom-host']),
          host: z.string(),
          repoId: z.union([z.string(), z.number()]),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['github-custom-host']),
          host: z.string(),
          org: z.string(),
          repo: z.string(),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['gitlab']),
          projectId: z.union([z.string(), z.number()]),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['bitbucket']),
          workspaceUuid: z.string().optional(),
          repoUuid: z.string(),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['bitbucket']),
          owner: z.string(),
          slug: z.string(),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['custom']),
          ref: z.string(),
          sha: z.string(),
          gitUrl: z.string(),
        }),
        z.object({
          type: z.enum(['github']),
          ref: z.string(),
          sha: z.string(),
          repoId: z.number(),
          org: z.string().optional(),
          repo: z.string().optional(),
        }),
        z.object({
          type: z.enum(['github-custom-host']),
          host: z.string(),
          ref: z.string(),
          sha: z.string(),
          repoId: z.number(),
          org: z.string().optional(),
          repo: z.string().optional(),
        }),
        z.object({
          type: z.enum(['gitlab']),
          ref: z.string(),
          sha: z.string(),
          projectId: z.number(),
        }),
        z.object({
          type: z.enum(['bitbucket']),
          ref: z.string(),
          sha: z.string(),
          owner: z.string().optional(),
          slug: z.string().optional(),
          workspaceUuid: z.string(),
          repoUuid: z.string(),
        }),
      ])
      .optional(),
    meta: z.object({}).catchall(z.string()),
    originCacheRegion: z.string().optional(),
    project: z
      .object({
        id: z.string(),
        name: z.string(),
        framework: z.string().nullable().nullish(),
      })
      .optional(),
    readySubstate: z
      .enum(['STAGED', 'ROLLING', 'PROMOTED'])
      .describe(
        "Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - ROLLING: in the process of having production traffic gradually transitioned. - PROMOTED: has seen production traffic",
      )
      .optional(),
    regions: z.array(z.string()),
    softDeletedByRetention: z.boolean().optional(),
    source: z.enum(['api-trigger-git-deploy', 'cli', 'clone/repo', 'git', 'import', 'import/repo', 'redeploy', 'v0-web']).optional(),
    target: z.enum(['staging', 'production']).nullable().nullish(),
    undeletedAt: z.number().optional(),
    url: z.string(),
    version: z.literal(2),
    oidcTokenClaims: z
      .object({
        iss: z.string(),
        sub: z.string(),
        scope: z.string(),
        aud: z.string(),
        owner: z.string(),
        owner_id: z.string(),
        project: z.string(),
        project_id: z.string(),
        environment: z.string(),
      })
      .optional(),
    projectId: z.string(),
    plan: z.enum(['pro', 'enterprise', 'hobby']),
    connectBuildsEnabled: z.boolean().optional(),
    connectConfigurationId: z.string().optional(),
    createdIn: z.string(),
    crons: z
      .array(
        z.object({
          schedule: z.string(),
          path: z.string(),
        }),
      )
      .optional(),
    functions: z
      .object({})
      .catchall(
        z.object({
          architecture: z.enum(['x86_64', 'arm64']).optional(),
          memory: z.number().optional(),
          maxDuration: z.number().optional(),
          runtime: z.string().optional(),
          includeFiles: z.string().optional(),
          excludeFiles: z.string().optional(),
          experimentalTriggers: z
            .array(
              z
                .object({
                  type: z.enum(['queue/v1beta']).describe('Event type - must be "queue/v1beta" (REQUIRED)'),
                  topic: z.string().describe('Name of the queue topic to consume from (REQUIRED)'),
                  consumer: z.string().describe('Name of the consumer group for this trigger (REQUIRED)'),
                  maxDeliveries: z
                    .number()
                    .describe(
                      "Maximum number of delivery attempts for message processing (OPTIONAL) This represents the total number of times a message can be delivered, not the number of retries. Must be at least 1 if specified. Behavior when not specified depends on the server's default configuration.",
                    )
                    .optional(),
                  retryAfterSeconds: z
                    .number()
                    .describe(
                      "Delay in seconds before retrying failed executions (OPTIONAL) Behavior when not specified depends on the server's default configuration.",
                    )
                    .optional(),
                  initialDelaySeconds: z
                    .number()
                    .describe(
                      "Initial delay in seconds before first execution attempt (OPTIONAL) Must be 0 or greater. Use 0 for no initial delay. Behavior when not specified depends on the server's default configuration.",
                    )
                    .optional(),
                })
                .describe('Queue trigger event for Vercel\'s queue system. Handles "queue/v1beta" events with queue-specific configuration.'),
            )
            .optional(),
        }),
      )
      .nullable()
      .nullish(),
    monorepoManager: z.string().nullable().nullish(),
    ownerId: z.string(),
    passiveConnectConfigurationId: z
      .string()
      .describe('Since November 2023 this field defines a Secure Compute network that will only be used to deploy passive lambdas to (as in passiveRegions)')
      .optional(),
    routes: z
      .array(
        z.union([
          z.object({
            src: z.string(),
            dest: z.string().optional(),
            headers: z.object({}).catchall(z.string()).optional(),
            methods: z.array(z.string()).optional(),
            continue: z.boolean().optional(),
            override: z.boolean().optional(),
            caseSensitive: z.boolean().optional(),
            check: z.boolean().optional(),
            important: z.boolean().optional(),
            status: z.number().optional(),
            has: z
              .array(
                z.union([
                  z.object({
                    type: z.enum(['host']),
                    value: z.union([
                      z.string(),
                      z.object({
                        eq: z.union([z.string(), z.number()]).optional(),
                        neq: z.string().optional(),
                        inc: z.array(z.string()).optional(),
                        ninc: z.array(z.string()).optional(),
                        pre: z.string().optional(),
                        suf: z.string().optional(),
                        re: z.string().optional(),
                        gt: z.number().optional(),
                        gte: z.number().optional(),
                        lt: z.number().optional(),
                        lte: z.number().optional(),
                      }),
                    ]),
                  }),
                  z.object({
                    type: z.enum(['header', 'cookie', 'query']),
                    key: z.string(),
                    value: z
                      .union([
                        z.string(),
                        z.object({
                          eq: z.union([z.string(), z.number()]).optional(),
                          neq: z.string().optional(),
                          inc: z.array(z.string()).optional(),
                          ninc: z.array(z.string()).optional(),
                          pre: z.string().optional(),
                          suf: z.string().optional(),
                          re: z.string().optional(),
                          gt: z.number().optional(),
                          gte: z.number().optional(),
                          lt: z.number().optional(),
                          lte: z.number().optional(),
                        }),
                      ])
                      .optional(),
                  }),
                ]),
              )
              .optional(),
            missing: z
              .array(
                z.union([
                  z.object({
                    type: z.enum(['host']),
                    value: z.union([
                      z.string(),
                      z.object({
                        eq: z.union([z.string(), z.number()]).optional(),
                        neq: z.string().optional(),
                        inc: z.array(z.string()).optional(),
                        ninc: z.array(z.string()).optional(),
                        pre: z.string().optional(),
                        suf: z.string().optional(),
                        re: z.string().optional(),
                        gt: z.number().optional(),
                        gte: z.number().optional(),
                        lt: z.number().optional(),
                        lte: z.number().optional(),
                      }),
                    ]),
                  }),
                  z.object({
                    type: z.enum(['header', 'cookie', 'query']),
                    key: z.string(),
                    value: z
                      .union([
                        z.string(),
                        z.object({
                          eq: z.union([z.string(), z.number()]).optional(),
                          neq: z.string().optional(),
                          inc: z.array(z.string()).optional(),
                          ninc: z.array(z.string()).optional(),
                          pre: z.string().optional(),
                          suf: z.string().optional(),
                          re: z.string().optional(),
                          gt: z.number().optional(),
                          gte: z.number().optional(),
                          lt: z.number().optional(),
                          lte: z.number().optional(),
                        }),
                      ])
                      .optional(),
                  }),
                ]),
              )
              .optional(),
            mitigate: z
              .object({
                action: z.enum(['challenge', 'deny']),
              })
              .optional(),
            transforms: z
              .array(
                z.object({
                  type: z.enum(['request.headers', 'request.query', 'response.headers']),
                  op: z.enum(['append', 'set', 'delete']),
                  target: z.object({
                    key: z.union([
                      z.string(),
                      z.object({
                        eq: z.union([z.string(), z.number()]).optional(),
                        neq: z.string().optional(),
                        inc: z.array(z.string()).optional(),
                        ninc: z.array(z.string()).optional(),
                        pre: z.string().optional(),
                        suf: z.string().optional(),
                        gt: z.number().optional(),
                        gte: z.number().optional(),
                        lt: z.number().optional(),
                        lte: z.number().optional(),
                      }),
                    ]),
                  }),
                  args: z.union([z.array(z.string()), z.string()]).optional(),
                }),
              )
              .optional(),
            locale: z
              .object({
                redirect: z.object({}).catchall(z.string()).optional(),
                cookie: z.string().optional(),
              })
              .optional(),
            middlewarePath: z
              .string()
              .describe('A middleware key within the `output` key under the build result. Overrides a `middleware` definition.')
              .optional(),
            middlewareRawSrc: z.array(z.string()).describe('The original middleware matchers.').optional(),
            middleware: z.number().describe('A middleware index in the `middleware` key under the build result').optional(),
          }),
          z.object({
            handle: z.enum(['error', 'filesystem', 'hit', 'miss', 'rewrite', 'resource']),
            src: z.string().optional(),
            dest: z.string().optional(),
            status: z.number().optional(),
          }),
          z.object({
            src: z.string(),
            continue: z.boolean(),
            middleware: z.literal(0),
          }),
        ]),
      )
      .nullable(),
    gitRepo: z
      .union([
        z.object({
          namespace: z.string(),
          projectId: z.number(),
          type: z.enum(['gitlab']),
          url: z.string(),
          path: z.string(),
          defaultBranch: z.string(),
          name: z.string(),
          private: z.boolean(),
          ownerType: z.enum(['team', 'user']),
        }),
        z.object({
          org: z.string(),
          repo: z.string(),
          repoId: z.number(),
          type: z.enum(['github']),
          repoOwnerId: z.number(),
          path: z.string(),
          defaultBranch: z.string(),
          name: z.string(),
          private: z.boolean(),
          ownerType: z.enum(['team', 'user']),
        }),
        z.object({
          owner: z.string(),
          repoUuid: z.string(),
          slug: z.string(),
          type: z.enum(['bitbucket']),
          workspaceUuid: z.string(),
          path: z.string(),
          defaultBranch: z.string(),
          name: z.string(),
          private: z.boolean(),
          ownerType: z.enum(['team', 'user']),
        }),
      ])
      .nullable()
      .nullish(),
    flags: z
      .union([
        z.array(
          z.object({}).describe('Flags defined in the Build Output API, used by this deployment. Primarily used by the Toolbar to know about the used flags.'),
        ),
        z.object({
          definitions: z.object({}).catchall(
            z.object({
              options: z
                .array(
                  z.object({
                    value: z.lazy(() => flagJSONValueSchema).nullable(),
                    label: z.string().optional(),
                  }),
                )
                .optional(),
              url: z.string().optional(),
              description: z.string().optional(),
            }),
          ),
        }),
      ])
      .optional(),
    microfrontends: z
      .union([
        z.object({
          isDefaultApp: z
            .boolean()
            .describe(
              'Whether this project is the default application for the microfrontends group. The default application is the one that is used as the top level shell for the microfrontends group and hosts the other microfrontends.',
            )
            .optional(),
          defaultAppProjectName: z.string().describe("The project name of the default app of this deployment's microfrontends group."),
          defaultRoute: z
            .string()
            .describe(
              'A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI.',
            )
            .optional(),
          groupIds: z
            .array(z.union([z.string(), z.string()]))
            .min(2)
            .max(2)
            .describe(
              'The group of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.',
            ),
          microfrontendsAliasEnabled: z
            .boolean()
            .describe(
              "Whether the MicrofrontendsAlias team flag should be considered enabled for this deployment or not. This is used to ensure that we don't accidentally switch an existing branch alias to a microfrontends branch alias.",
            )
            .optional(),
          previewEnvAliasEnabled: z
            .boolean()
            .describe(
              'Whether this deployment, if a preview deployment on the production branch, should get the -env-preview alias instead of a normal branch alias. This is used to always generate a microfrontends fallback on the preview branch.',
            )
            .optional(),
        }),
        z.object({
          applications: z
            .object({})
            .catchall(
              z
                .object({
                  isDefaultApp: z.boolean().optional(),
                  productionHost: z.string().describe('This is the production alias, it will always show the most up to date of each application.'),
                  deploymentAlias: z
                    .string()
                    .describe(
                      'Use the fixed deploymentAlias and deploymentHost so that the microfrontend preview stays in sync with the deployment. These are only present for mono-repos when a single commit creates multiple deployments. If they are not present, productionHost will be used.',
                    )
                    .optional(),
                  deploymentHost: z.string().optional(),
                })
                .describe(
                  'A map of the other applications that are part of this group. Only defined on the default application. The field is set after deployments have been created, so can be undefined, but should be there for a successful deployment.',
                ),
            )
            .describe(
              'A map of the other applications that are part of this group. Only defined on the default application. The field is set after deployments have been created, so can be undefined, but should be there for a successful deployment.',
            )
            .optional(),
          isDefaultApp: z.boolean(),
          defaultAppProjectName: z.string().describe("The project name of the default app of this deployment's microfrontends group."),
          defaultRoute: z
            .string()
            .describe(
              'A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI.',
            )
            .optional(),
          groupIds: z
            .array(z.union([z.string(), z.string()]))
            .min(2)
            .max(2)
            .describe(
              'The group of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.',
            ),
          microfrontendsAliasEnabled: z
            .boolean()
            .describe(
              "Whether the MicrofrontendsAlias team flag should be considered enabled for this deployment or not. This is used to ensure that we don't accidentally switch an existing branch alias to a microfrontends branch alias.",
            )
            .optional(),
          previewEnvAliasEnabled: z
            .boolean()
            .describe(
              'Whether this deployment, if a preview deployment on the production branch, should get the -env-preview alias instead of a normal branch alias. This is used to always generate a microfrontends fallback on the preview branch.',
            )
            .optional(),
        }),
      ])
      .optional(),
    config: z
      .object({
        version: z.number().optional(),
        functionType: z.enum(['fluid', 'standard']),
        functionMemoryType: z.enum(['standard', 'standard_legacy', 'performance']),
        functionTimeout: z.number().nullable(),
        secureComputePrimaryRegion: z.string().nullable(),
        secureComputeFallbackRegion: z.string().nullable(),
        isUsingActiveCPU: z.boolean().optional(),
      })
      .describe(
        'Since February 2025 the configuration must include snapshot data at the time of deployment creation to capture properties for the /deployments/:id/config endpoint utilized for displaying Deployment Configuration on the frontend This is optional because older deployments may not have this data captured',
      )
      .optional(),
    checks: z
      .object({
        'deployment-alias': z
          .object({
            state: z.enum(['succeeded', 'failed', 'pending']),
            startedAt: z.number(),
            completedAt: z.number().optional(),
          })
          .describe('Condensed check data. Retrieve individual check and check run data using api-checks v2 routes.'),
      })
      .optional(),
  }),
  z.object({
    alias: z.array(z.string()).optional(),
    aliasAssigned: z.boolean(),
    bootedAt: z.number(),
    buildingAt: z.number(),
    buildContainerFinishedAt: z.number().describe('Since April 2025 it necessary for On-Demand Concurrency Minutes calculation').optional(),
    buildSkipped: z.boolean(),
    creator: z.object({
      uid: z.string(),
      username: z.string().optional(),
      avatar: z.string().optional(),
    }),
    initReadyAt: z.number().optional(),
    isFirstBranchDeployment: z.boolean().optional(),
    lambdas: z
      .array(
        z
          .object({
            id: z.string().optional(),
            createdAt: z.number().optional(),
            entrypoint: z.string().nullable().nullish(),
            readyState: z.enum(['BUILDING', 'ERROR', 'INITIALIZING', 'READY']).optional(),
            readyStateAt: z.number().optional(),
            output: z.array(
              z.object({
                path: z.string(),
                functionName: z.string(),
              }),
            ),
          })
          .describe('A partial representation of a Build used by the deployment endpoint.'),
      )
      .optional(),
    public: z.boolean(),
    ready: z.number().optional(),
    status: z.enum(['QUEUED', 'BUILDING', 'ERROR', 'INITIALIZING', 'READY', 'CANCELED']),
    team: z
      .object({
        id: z.string(),
        name: z.string(),
        slug: z.string(),
        avatar: z.string().optional(),
      })
      .optional(),
    userAliases: z.array(z.string()).optional(),
    previewCommentsEnabled: z.boolean().optional(),
    ttyBuildLogs: z.boolean().optional(),
    customEnvironment: z
      .union([
        z.object({
          id: z.string().describe('Unique identifier for the custom environment (format: env_*)'),
          slug: z.string().describe('URL-friendly name of the environment'),
          type: z.enum(['production', 'preview', 'development']).describe('The type of environment (production, preview, or development)'),
          description: z.string().describe("Optional description of the environment's purpose").optional(),
          branchMatcher: z
            .object({
              type: z.enum(['endsWith', 'startsWith', 'equals']).describe('The type of matching to perform'),
              pattern: z.string().describe('The pattern to match against branch names'),
            })
            .describe('Configuration for matching git branches to this environment')
            .optional(),
          domains: z
            .array(
              z
                .object({
                  name: z.string(),
                  apexName: z.string(),
                  projectId: z.string(),
                  redirect: z.string().nullable().nullish(),
                  redirectStatusCode: z
                    .union([z.literal(307), z.literal(301), z.literal(302), z.literal(308)])
                    .nullable()
                    .nullish(),
                  gitBranch: z.string().nullable().nullish(),
                  customEnvironmentId: z.string().nullable().nullish(),
                  updatedAt: z.number().optional(),
                  createdAt: z.number().optional(),
                  verified: z
                    .boolean()
                    .describe(
                      '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
                    ),
                  verification: z
                    .array(
                      z
                        .object({
                          type: z.string(),
                          domain: z.string(),
                          value: z.string(),
                          reason: z.string(),
                        })
                        .describe(
                          'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                        ),
                    )
                    .describe(
                      'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                    )
                    .optional(),
                })
                .describe('List of domains associated with this environment'),
            )
            .describe('List of domains associated with this environment')
            .optional(),
          currentDeploymentAliases: z.array(z.string()).describe('List of aliases for the current deployment').optional(),
          createdAt: z.number().describe('Timestamp when the environment was created'),
          updatedAt: z.number().describe('Timestamp when the environment was last updated'),
        }),
        z.object({
          id: z.string(),
        }),
      ])
      .optional(),
    oomReport: z.enum(['out-of-memory']).optional(),
    aliasWarning: z
      .object({
        code: z.string(),
        message: z.string(),
        link: z.string().optional(),
        action: z.string().optional(),
      })
      .nullable()
      .nullish(),
    id: z.string(),
    name: z.string(),
    type: z.enum(['LAMBDAS']),
    createdAt: z.number(),
    readyState: z.enum(['QUEUED', 'BUILDING', 'ERROR', 'INITIALIZING', 'READY', 'CANCELED']),
    aliasError: z
      .object({
        code: z.string(),
        message: z.string(),
      })
      .nullable()
      .nullish(),
    aliasFinal: z.string().nullable().nullish(),
    autoAssignCustomDomains: z.boolean().describe('applies to custom domains only, defaults to `true`').optional(),
    automaticAliases: z.array(z.string()).optional(),
    buildErrorAt: z.number().optional(),
    checksState: z.enum(['registered', 'running', 'completed']).optional(),
    checksConclusion: z.enum(['succeeded', 'failed', 'skipped', 'canceled']).optional(),
    deletedAt: z.number().nullable().nullish(),
    defaultRoute: z.string().describe('Computed field that is only available for deployments with a microfrontend configuration.').optional(),
    canceledAt: z.number().optional(),
    errorCode: z.string().optional(),
    errorLink: z.string().optional(),
    errorMessage: z.string().nullable().nullish(),
    errorStep: z.string().optional(),
    passiveRegions: z
      .array(z.string())
      .describe(
        'Since November 2023 this field defines a set of regions that we will deploy the lambda to passively Lambdas will be deployed to these regions but only invoked if all of the primary `regions` are marked as out of service',
      )
      .optional(),
    gitSource: z
      .union([
        z.object({
          type: z.enum(['github']),
          repoId: z.union([z.string(), z.number()]),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['github']),
          org: z.string(),
          repo: z.string(),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['github-custom-host']),
          host: z.string(),
          repoId: z.union([z.string(), z.number()]),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['github-custom-host']),
          host: z.string(),
          org: z.string(),
          repo: z.string(),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['gitlab']),
          projectId: z.union([z.string(), z.number()]),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['bitbucket']),
          workspaceUuid: z.string().optional(),
          repoUuid: z.string(),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['bitbucket']),
          owner: z.string(),
          slug: z.string(),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['custom']),
          ref: z.string(),
          sha: z.string(),
          gitUrl: z.string(),
        }),
        z.object({
          type: z.enum(['github']),
          ref: z.string(),
          sha: z.string(),
          repoId: z.number(),
          org: z.string().optional(),
          repo: z.string().optional(),
        }),
        z.object({
          type: z.enum(['github-custom-host']),
          host: z.string(),
          ref: z.string(),
          sha: z.string(),
          repoId: z.number(),
          org: z.string().optional(),
          repo: z.string().optional(),
        }),
        z.object({
          type: z.enum(['gitlab']),
          ref: z.string(),
          sha: z.string(),
          projectId: z.number(),
        }),
        z.object({
          type: z.enum(['bitbucket']),
          ref: z.string(),
          sha: z.string(),
          owner: z.string().optional(),
          slug: z.string().optional(),
          workspaceUuid: z.string(),
          repoUuid: z.string(),
        }),
      ])
      .optional(),
    meta: z.object({}).catchall(z.string()),
    originCacheRegion: z.string().optional(),
    project: z
      .object({
        id: z.string(),
        name: z.string(),
        framework: z.string().nullable().nullish(),
      })
      .optional(),
    readySubstate: z
      .enum(['STAGED', 'ROLLING', 'PROMOTED'])
      .describe(
        "Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - ROLLING: in the process of having production traffic gradually transitioned. - PROMOTED: has seen production traffic",
      )
      .optional(),
    regions: z.array(z.string()),
    softDeletedByRetention: z.boolean().optional(),
    source: z.enum(['api-trigger-git-deploy', 'cli', 'clone/repo', 'git', 'import', 'import/repo', 'redeploy', 'v0-web']).optional(),
    target: z.enum(['staging', 'production']).nullable().nullish(),
    undeletedAt: z.number().optional(),
    url: z.string(),
    version: z.literal(2),
    oidcTokenClaims: z
      .object({
        iss: z.string(),
        sub: z.string(),
        scope: z.string(),
        aud: z.string(),
        owner: z.string(),
        owner_id: z.string(),
        project: z.string(),
        project_id: z.string(),
        environment: z.string(),
      })
      .optional(),
  }),
]) as unknown as ToZod<GetDeployment200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getDeployment400Schema = z.unknown() as unknown as ToZod<GetDeployment400>

/**
 * @description You do not have permission to access this resource.
 */
export const getDeployment403Schema = z.unknown() as unknown as ToZod<GetDeployment403>

/**
 * @description The deployment was not found
 */
export const getDeployment404Schema = z.unknown() as unknown as ToZod<GetDeployment404>

export const getDeploymentQueryResponseSchema = z.lazy(() => getDeployment200Schema) as unknown as ToZod<GetDeploymentQueryResponse>

export const createDeploymentQueryParamsSchema = z
  .object({
    forceNew: z.enum(['0', '1']).describe('Forces a new deployment even if there is a previous similar deployment').optional(),
    skipAutoDetectionConfirmation: z
      .enum(['0', '1'])
      .describe('Allows to skip framework detection so the API would not fail to ask for confirmation')
      .optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<CreateDeploymentQueryParams>

/**
 * @description The successfully created deployment
 */
export const createDeployment200Schema = z
  .object({
    aliasAssignedAt: z.union([z.boolean(), z.number()]).nullable().nullish(),
    alwaysRefuseToBuild: z.boolean().optional(),
    build: z.object({
      env: z.array(z.string()),
    }),
    buildArtifactUrls: z.array(z.string()).optional(),
    builds: z
      .array(
        z.object({
          use: z.string(),
          src: z.string().optional(),
          config: z.object({}).catchall(z.unknown()).optional(),
        }),
      )
      .optional(),
    env: z.array(z.string()),
    inspectorUrl: z.string().nullable(),
    isInConcurrentBuildsQueue: z.boolean(),
    isInSystemBuildsQueue: z.boolean(),
    projectSettings: z.object({
      buildCommand: z.string().nullable().nullish(),
      commandForIgnoringBuildStep: z.string().nullable().nullish(),
      devCommand: z.string().nullable().nullish(),
      framework: z
        .enum([
          'angular',
          'astro',
          'blitzjs',
          'brunch',
          'create-react-app',
          'docusaurus',
          'docusaurus-2',
          'dojo',
          'eleventy',
          'ember',
          'fasthtml',
          'gatsby',
          'gridsome',
          'hexo',
          'hugo',
          'hydrogen',
          'ionic-angular',
          'ionic-react',
          'jekyll',
          'middleman',
          'nextjs',
          'nitro',
          'nuxtjs',
          'parcel',
          'polymer',
          'preact',
          'react-router',
          'redwoodjs',
          'remix',
          'saber',
          'sanity',
          'sanity-v3',
          'sapper',
          'scully',
          'solidstart',
          'solidstart-1',
          'stencil',
          'storybook',
          'svelte',
          'sveltekit',
          'sveltekit-1',
          'umijs',
          'vite',
          'vitepress',
          'vue',
          'vuepress',
          'zola',
        ])
        .nullable()
        .nullish(),
      installCommand: z.string().nullable().nullish(),
      outputDirectory: z.string().nullable().nullish(),
      speedInsights: z
        .object({
          id: z.string(),
          enabledAt: z.number().optional(),
          disabledAt: z.number().optional(),
          canceledAt: z.number().optional(),
          hasData: z.boolean().optional(),
          paidAt: z.number().optional(),
        })
        .optional(),
      webAnalytics: z
        .object({
          id: z.string(),
          disabledAt: z.number().optional(),
          canceledAt: z.number().optional(),
          enabledAt: z.number().optional(),
          hasData: z.boolean().optional(),
        })
        .optional(),
    }),
    readyStateReason: z.string().optional(),
    integrations: z
      .object({
        status: z.enum(['error', 'pending', 'ready', 'skipped', 'timeout']),
        startedAt: z.number(),
        completedAt: z.number().optional(),
        skippedAt: z.number().optional(),
        skippedBy: z.string().optional(),
      })
      .optional(),
    images: z
      .object({
        sizes: z.array(z.number()).optional(),
        qualities: z.array(z.number()).optional(),
        domains: z.array(z.string()).optional(),
        remotePatterns: z
          .array(
            z.object({
              protocol: z.enum(['http', 'https']).describe('Must be `http` or `https`.').optional(),
              hostname: z.string().describe('Can be literal or wildcard. Single `*` matches a single subdomain. Double `**` matches any number of subdomains.'),
              port: z.string().describe('Can be literal port such as `8080` or empty string meaning no port.').optional(),
              pathname: z
                .string()
                .describe('Can be literal or wildcard. Single `*` matches a single path segment. Double `**` matches any number of path segments.')
                .optional(),
              search: z.string().describe('Can be literal query string such as `?v=1` or empty string meaning no query string.').optional(),
            }),
          )
          .optional(),
        localPatterns: z
          .array(
            z.object({
              pathname: z
                .string()
                .describe('Can be literal or wildcard. Single `*` matches a single path segment. Double `**` matches any number of path segments.')
                .optional(),
              search: z.string().describe('Can be literal query string such as `?v=1` or empty string meaning no query string.').optional(),
            }),
          )
          .optional(),
        minimumCacheTTL: z.number().optional(),
        formats: z.array(z.enum(['image/avif', 'image/webp'])).optional(),
        dangerouslyAllowSVG: z.boolean().optional(),
        contentSecurityPolicy: z.string().optional(),
        contentDispositionType: z.enum(['attachment', 'inline']).optional(),
      })
      .optional(),
    alias: z.array(z.string()).optional(),
    aliasAssigned: z.boolean(),
    bootedAt: z.number(),
    buildingAt: z.number(),
    buildContainerFinishedAt: z.number().describe('Since April 2025 it necessary for On-Demand Concurrency Minutes calculation').optional(),
    buildSkipped: z.boolean(),
    creator: z.object({
      uid: z.string(),
      username: z.string().optional(),
      avatar: z.string().optional(),
    }),
    initReadyAt: z.number().optional(),
    isFirstBranchDeployment: z.boolean().optional(),
    lambdas: z
      .array(
        z
          .object({
            id: z.string().optional(),
            createdAt: z.number().optional(),
            entrypoint: z.string().nullable().nullish(),
            readyState: z.enum(['BUILDING', 'ERROR', 'INITIALIZING', 'READY']).optional(),
            readyStateAt: z.number().optional(),
            output: z.array(
              z.object({
                path: z.string(),
                functionName: z.string(),
              }),
            ),
          })
          .describe('A partial representation of a Build used by the deployment endpoint.'),
      )
      .optional(),
    public: z.boolean(),
    ready: z.number().optional(),
    status: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
    team: z
      .object({
        id: z.string(),
        name: z.string(),
        slug: z.string(),
        avatar: z.string().optional(),
      })
      .optional(),
    userAliases: z.array(z.string()).optional(),
    previewCommentsEnabled: z.boolean().optional(),
    ttyBuildLogs: z.boolean().optional(),
    customEnvironment: z
      .union([
        z.object({
          id: z.string().describe('Unique identifier for the custom environment (format: env_*)'),
          slug: z.string().describe('URL-friendly name of the environment'),
          type: z.enum(['production', 'preview', 'development']).describe('The type of environment (production, preview, or development)'),
          description: z.string().describe("Optional description of the environment's purpose").optional(),
          branchMatcher: z
            .object({
              type: z.enum(['endsWith', 'startsWith', 'equals']).describe('The type of matching to perform'),
              pattern: z.string().describe('The pattern to match against branch names'),
            })
            .describe('Configuration for matching git branches to this environment')
            .optional(),
          domains: z
            .array(
              z
                .object({
                  name: z.string(),
                  apexName: z.string(),
                  projectId: z.string(),
                  redirect: z.string().nullable().nullish(),
                  redirectStatusCode: z
                    .union([z.literal(307), z.literal(301), z.literal(302), z.literal(308)])
                    .nullable()
                    .nullish(),
                  gitBranch: z.string().nullable().nullish(),
                  customEnvironmentId: z.string().nullable().nullish(),
                  updatedAt: z.number().optional(),
                  createdAt: z.number().optional(),
                  verified: z
                    .boolean()
                    .describe(
                      '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
                    ),
                  verification: z
                    .array(
                      z
                        .object({
                          type: z.string(),
                          domain: z.string(),
                          value: z.string(),
                          reason: z.string(),
                        })
                        .describe(
                          'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                        ),
                    )
                    .describe(
                      'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                    )
                    .optional(),
                })
                .describe('List of domains associated with this environment'),
            )
            .describe('List of domains associated with this environment')
            .optional(),
          currentDeploymentAliases: z.array(z.string()).describe('List of aliases for the current deployment').optional(),
          createdAt: z.number().describe('Timestamp when the environment was created'),
          updatedAt: z.number().describe('Timestamp when the environment was last updated'),
        }),
        z.object({
          id: z.string(),
        }),
      ])
      .optional(),
    oomReport: z.enum(['out-of-memory']).optional(),
    id: z.string(),
    name: z.string(),
    createdAt: z.number(),
    type: z.enum(['LAMBDAS']),
    deletedAt: z.number().nullable().nullish(),
    version: z.literal(2),
    autoAssignCustomDomains: z.boolean().describe('applies to custom domains only, defaults to `true`').optional(),
    gitSource: z
      .union([
        z.object({
          type: z.enum(['github']),
          repoId: z.union([z.string(), z.number()]),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['github']),
          org: z.string(),
          repo: z.string(),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['github-custom-host']),
          host: z.string(),
          repoId: z.union([z.string(), z.number()]),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['github-custom-host']),
          host: z.string(),
          org: z.string(),
          repo: z.string(),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['gitlab']),
          projectId: z.union([z.string(), z.number()]),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['bitbucket']),
          workspaceUuid: z.string().optional(),
          repoUuid: z.string(),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['bitbucket']),
          owner: z.string(),
          slug: z.string(),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['custom']),
          ref: z.string(),
          sha: z.string(),
          gitUrl: z.string(),
        }),
        z.object({
          type: z.enum(['github']),
          ref: z.string(),
          sha: z.string(),
          repoId: z.number(),
          org: z.string().optional(),
          repo: z.string().optional(),
        }),
        z.object({
          type: z.enum(['github-custom-host']),
          host: z.string(),
          ref: z.string(),
          sha: z.string(),
          repoId: z.number(),
          org: z.string().optional(),
          repo: z.string().optional(),
        }),
        z.object({
          type: z.enum(['gitlab']),
          ref: z.string(),
          sha: z.string(),
          projectId: z.number(),
        }),
        z.object({
          type: z.enum(['bitbucket']),
          ref: z.string(),
          sha: z.string(),
          owner: z.string().optional(),
          slug: z.string().optional(),
          workspaceUuid: z.string(),
          repoUuid: z.string(),
        }),
      ])
      .optional(),
    meta: z.object({}).catchall(z.string()),
    project: z
      .object({
        id: z.string(),
        name: z.string(),
        framework: z.string().nullable().nullish(),
      })
      .optional(),
    readyState: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
    source: z.enum(['api-trigger-git-deploy', 'cli', 'clone/repo', 'git', 'import', 'import/repo', 'redeploy', 'v0-web']).optional(),
    target: z.enum(['production', 'staging']).nullable().nullish(),
    errorMessage: z.string().nullable().nullish(),
    passiveRegions: z
      .array(z.string())
      .describe(
        'Since November 2023 this field defines a set of regions that we will deploy the lambda to passively Lambdas will be deployed to these regions but only invoked if all of the primary `regions` are marked as out of service',
      )
      .optional(),
    regions: z.array(z.string()),
    aliasWarning: z
      .object({
        code: z.string(),
        message: z.string(),
        link: z.string().optional(),
        action: z.string().optional(),
      })
      .nullable()
      .nullish(),
    aliasError: z
      .object({
        code: z.string(),
        message: z.string(),
      })
      .nullable()
      .nullish(),
    aliasFinal: z.string().nullable().nullish(),
    automaticAliases: z.array(z.string()).optional(),
    buildErrorAt: z.number().optional(),
    checksState: z.enum(['completed', 'registered', 'running']).optional(),
    checksConclusion: z.enum(['canceled', 'failed', 'skipped', 'succeeded']).optional(),
    defaultRoute: z.string().describe('Computed field that is only available for deployments with a microfrontend configuration.').optional(),
    canceledAt: z.number().optional(),
    errorCode: z.string().optional(),
    errorLink: z.string().optional(),
    errorStep: z.string().optional(),
    originCacheRegion: z.string().optional(),
    readySubstate: z
      .enum(['PROMOTED', 'ROLLING', 'STAGED'])
      .describe(
        "Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - ROLLING: in the process of having production traffic gradually transitioned. - PROMOTED: has seen production traffic",
      )
      .optional(),
    softDeletedByRetention: z.boolean().optional(),
    undeletedAt: z.number().optional(),
    url: z.string(),
    oidcTokenClaims: z
      .object({
        iss: z.string(),
        sub: z.string(),
        scope: z.string(),
        aud: z.string(),
        owner: z.string(),
        owner_id: z.string(),
        project: z.string(),
        project_id: z.string(),
        environment: z.string(),
      })
      .optional(),
    projectId: z.string(),
    ownerId: z.string(),
    monorepoManager: z.string().nullable().nullish(),
    plan: z.enum(['enterprise', 'hobby', 'pro']),
    config: z
      .object({
        version: z.number().optional(),
        functionType: z.enum(['fluid', 'standard']),
        functionMemoryType: z.enum(['performance', 'standard', 'standard_legacy']),
        functionTimeout: z.number().nullable(),
        secureComputePrimaryRegion: z.string().nullable(),
        secureComputeFallbackRegion: z.string().nullable(),
        isUsingActiveCPU: z.boolean().optional(),
      })
      .describe(
        'Since February 2025 the configuration must include snapshot data at the time of deployment creation to capture properties for the /deployments/:id/config endpoint utilized for displaying Deployment Configuration on the frontend This is optional because older deployments may not have this data captured',
      )
      .optional(),
    functions: z
      .object({})
      .catchall(
        z.object({
          architecture: z.enum(['arm64', 'x86_64']).optional(),
          memory: z.number().optional(),
          maxDuration: z.number().optional(),
          runtime: z.string().optional(),
          includeFiles: z.string().optional(),
          excludeFiles: z.string().optional(),
          experimentalTriggers: z
            .array(
              z
                .object({
                  type: z.enum(['queue/v1beta']).describe('Event type - must be "queue/v1beta" (REQUIRED)'),
                  topic: z.string().describe('Name of the queue topic to consume from (REQUIRED)'),
                  consumer: z.string().describe('Name of the consumer group for this trigger (REQUIRED)'),
                  maxDeliveries: z
                    .number()
                    .describe(
                      "Maximum number of delivery attempts for message processing (OPTIONAL) This represents the total number of times a message can be delivered, not the number of retries. Must be at least 1 if specified. Behavior when not specified depends on the server's default configuration.",
                    )
                    .optional(),
                  retryAfterSeconds: z
                    .number()
                    .describe(
                      "Delay in seconds before retrying failed executions (OPTIONAL) Behavior when not specified depends on the server's default configuration.",
                    )
                    .optional(),
                  initialDelaySeconds: z
                    .number()
                    .describe(
                      "Initial delay in seconds before first execution attempt (OPTIONAL) Must be 0 or greater. Use 0 for no initial delay. Behavior when not specified depends on the server's default configuration.",
                    )
                    .optional(),
                })
                .describe('Queue trigger event for Vercel\'s queue system. Handles "queue/v1beta" events with queue-specific configuration.'),
            )
            .optional(),
        }),
      )
      .nullable()
      .nullish(),
    routes: z
      .array(
        z.union([
          z.object({
            src: z.string(),
            dest: z.string().optional(),
            headers: z.object({}).catchall(z.string()).optional(),
            methods: z.array(z.string()).optional(),
            continue: z.boolean().optional(),
            override: z.boolean().optional(),
            caseSensitive: z.boolean().optional(),
            check: z.boolean().optional(),
            important: z.boolean().optional(),
            status: z.number().optional(),
            has: z
              .array(
                z.union([
                  z.object({
                    type: z.enum(['host']),
                    value: z.union([
                      z.string(),
                      z.object({
                        eq: z.union([z.string(), z.number()]).optional(),
                        neq: z.string().optional(),
                        inc: z.array(z.string()).optional(),
                        ninc: z.array(z.string()).optional(),
                        pre: z.string().optional(),
                        suf: z.string().optional(),
                        re: z.string().optional(),
                        gt: z.number().optional(),
                        gte: z.number().optional(),
                        lt: z.number().optional(),
                        lte: z.number().optional(),
                      }),
                    ]),
                  }),
                  z.object({
                    type: z.enum(['header', 'cookie', 'query']),
                    key: z.string(),
                    value: z
                      .union([
                        z.string(),
                        z.object({
                          eq: z.union([z.string(), z.number()]).optional(),
                          neq: z.string().optional(),
                          inc: z.array(z.string()).optional(),
                          ninc: z.array(z.string()).optional(),
                          pre: z.string().optional(),
                          suf: z.string().optional(),
                          re: z.string().optional(),
                          gt: z.number().optional(),
                          gte: z.number().optional(),
                          lt: z.number().optional(),
                          lte: z.number().optional(),
                        }),
                      ])
                      .optional(),
                  }),
                ]),
              )
              .optional(),
            missing: z
              .array(
                z.union([
                  z.object({
                    type: z.enum(['host']),
                    value: z.union([
                      z.string(),
                      z.object({
                        eq: z.union([z.string(), z.number()]).optional(),
                        neq: z.string().optional(),
                        inc: z.array(z.string()).optional(),
                        ninc: z.array(z.string()).optional(),
                        pre: z.string().optional(),
                        suf: z.string().optional(),
                        re: z.string().optional(),
                        gt: z.number().optional(),
                        gte: z.number().optional(),
                        lt: z.number().optional(),
                        lte: z.number().optional(),
                      }),
                    ]),
                  }),
                  z.object({
                    type: z.enum(['header', 'cookie', 'query']),
                    key: z.string(),
                    value: z
                      .union([
                        z.string(),
                        z.object({
                          eq: z.union([z.string(), z.number()]).optional(),
                          neq: z.string().optional(),
                          inc: z.array(z.string()).optional(),
                          ninc: z.array(z.string()).optional(),
                          pre: z.string().optional(),
                          suf: z.string().optional(),
                          re: z.string().optional(),
                          gt: z.number().optional(),
                          gte: z.number().optional(),
                          lt: z.number().optional(),
                          lte: z.number().optional(),
                        }),
                      ])
                      .optional(),
                  }),
                ]),
              )
              .optional(),
            mitigate: z
              .object({
                action: z.enum(['challenge', 'deny']),
              })
              .optional(),
            transforms: z
              .array(
                z.object({
                  type: z.enum(['request.headers', 'request.query', 'response.headers']),
                  op: z.enum(['append', 'set', 'delete']),
                  target: z.object({
                    key: z.union([
                      z.string(),
                      z.object({
                        eq: z.union([z.string(), z.number()]).optional(),
                        neq: z.string().optional(),
                        inc: z.array(z.string()).optional(),
                        ninc: z.array(z.string()).optional(),
                        pre: z.string().optional(),
                        suf: z.string().optional(),
                        gt: z.number().optional(),
                        gte: z.number().optional(),
                        lt: z.number().optional(),
                        lte: z.number().optional(),
                      }),
                    ]),
                  }),
                  args: z.union([z.array(z.string()), z.string()]).optional(),
                }),
              )
              .optional(),
            locale: z
              .object({
                redirect: z.object({}).catchall(z.string()).optional(),
                cookie: z.string().optional(),
              })
              .optional(),
            middlewarePath: z
              .string()
              .describe('A middleware key within the `output` key under the build result. Overrides a `middleware` definition.')
              .optional(),
            middlewareRawSrc: z.array(z.string()).describe('The original middleware matchers.').optional(),
            middleware: z.number().describe('A middleware index in the `middleware` key under the build result').optional(),
          }),
          z.object({
            handle: z.enum(['error', 'filesystem', 'hit', 'miss', 'rewrite', 'resource']),
            src: z.string().optional(),
            dest: z.string().optional(),
            status: z.number().optional(),
          }),
          z.object({
            src: z.string(),
            continue: z.boolean(),
            middleware: z.literal(0),
          }),
        ]),
      )
      .nullable(),
    crons: z
      .array(
        z.object({
          schedule: z.string(),
          path: z.string(),
        }),
      )
      .optional(),
    checks: z
      .object({
        'deployment-alias': z
          .object({
            state: z.enum(['failed', 'pending', 'succeeded']),
            startedAt: z.number(),
            completedAt: z.number().optional(),
          })
          .describe('Condensed check data. Retrieve individual check and check run data using api-checks v2 routes.'),
      })
      .optional(),
    microfrontends: z
      .union([
        z.object({
          isDefaultApp: z
            .boolean()
            .describe(
              'Whether this project is the default application for the microfrontends group. The default application is the one that is used as the top level shell for the microfrontends group and hosts the other microfrontends.',
            )
            .optional(),
          defaultAppProjectName: z.string().describe("The project name of the default app of this deployment's microfrontends group."),
          defaultRoute: z
            .string()
            .describe(
              'A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI.',
            )
            .optional(),
          groupIds: z
            .array(z.union([z.string(), z.string()]))
            .min(2)
            .max(2)
            .describe(
              'The group of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.',
            ),
          microfrontendsAliasEnabled: z
            .boolean()
            .describe(
              "Whether the MicrofrontendsAlias team flag should be considered enabled for this deployment or not. This is used to ensure that we don't accidentally switch an existing branch alias to a microfrontends branch alias.",
            )
            .optional(),
          previewEnvAliasEnabled: z
            .boolean()
            .describe(
              'Whether this deployment, if a preview deployment on the production branch, should get the -env-preview alias instead of a normal branch alias. This is used to always generate a microfrontends fallback on the preview branch.',
            )
            .optional(),
        }),
        z.object({
          applications: z
            .object({})
            .catchall(
              z
                .object({
                  isDefaultApp: z.boolean().optional(),
                  productionHost: z.string().describe('This is the production alias, it will always show the most up to date of each application.'),
                  deploymentAlias: z
                    .string()
                    .describe(
                      'Use the fixed deploymentAlias and deploymentHost so that the microfrontend preview stays in sync with the deployment. These are only present for mono-repos when a single commit creates multiple deployments. If they are not present, productionHost will be used.',
                    )
                    .optional(),
                  deploymentHost: z.string().optional(),
                })
                .describe(
                  'A map of the other applications that are part of this group. Only defined on the default application. The field is set after deployments have been created, so can be undefined, but should be there for a successful deployment.',
                ),
            )
            .describe(
              'A map of the other applications that are part of this group. Only defined on the default application. The field is set after deployments have been created, so can be undefined, but should be there for a successful deployment.',
            )
            .optional(),
          isDefaultApp: z.boolean(),
          defaultAppProjectName: z.string().describe("The project name of the default app of this deployment's microfrontends group."),
          defaultRoute: z
            .string()
            .describe(
              'A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI.',
            )
            .optional(),
          groupIds: z
            .array(z.union([z.string(), z.string()]))
            .min(2)
            .max(2)
            .describe(
              'The group of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.',
            ),
          microfrontendsAliasEnabled: z
            .boolean()
            .describe(
              "Whether the MicrofrontendsAlias team flag should be considered enabled for this deployment or not. This is used to ensure that we don't accidentally switch an existing branch alias to a microfrontends branch alias.",
            )
            .optional(),
          previewEnvAliasEnabled: z
            .boolean()
            .describe(
              'Whether this deployment, if a preview deployment on the production branch, should get the -env-preview alias instead of a normal branch alias. This is used to always generate a microfrontends fallback on the preview branch.',
            )
            .optional(),
        }),
      ])
      .optional(),
    connectBuildsEnabled: z.boolean().optional(),
    connectConfigurationId: z.string().optional(),
    createdIn: z.string(),
    passiveConnectConfigurationId: z
      .string()
      .describe('Since November 2023 this field defines a Secure Compute network that will only be used to deploy passive lambdas to (as in passiveRegions)')
      .optional(),
    gitRepo: z
      .union([
        z.object({
          namespace: z.string(),
          projectId: z.number(),
          type: z.enum(['gitlab']),
          url: z.string(),
          path: z.string(),
          defaultBranch: z.string(),
          name: z.string(),
          private: z.boolean(),
          ownerType: z.enum(['team', 'user']),
        }),
        z.object({
          org: z.string(),
          repo: z.string(),
          repoId: z.number(),
          type: z.enum(['github']),
          repoOwnerId: z.number(),
          path: z.string(),
          defaultBranch: z.string(),
          name: z.string(),
          private: z.boolean(),
          ownerType: z.enum(['team', 'user']),
        }),
        z.object({
          owner: z.string(),
          repoUuid: z.string(),
          slug: z.string(),
          type: z.enum(['bitbucket']),
          workspaceUuid: z.string(),
          path: z.string(),
          defaultBranch: z.string(),
          name: z.string(),
          private: z.boolean(),
          ownerType: z.enum(['team', 'user']),
        }),
      ])
      .nullable()
      .nullish(),
    flags: z
      .union([
        z.array(
          z.object({}).describe('Flags defined in the Build Output API, used by this deployment. Primarily used by the Toolbar to know about the used flags.'),
        ),
        z.object({
          definitions: z.object({}).catchall(
            z.object({
              options: z
                .array(
                  z.object({
                    value: z.lazy(() => flagJSONValueSchema).nullable(),
                    label: z.string().optional(),
                  }),
                )
                .optional(),
              url: z.string().optional(),
              description: z.string().optional(),
            }),
          ),
        }),
      ])
      .optional(),
  })
  .describe('The successfully created deployment') as unknown as ToZod<CreateDeployment200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const createDeployment400Schema = z.unknown() as unknown as ToZod<CreateDeployment400>

export const createDeployment401Schema = z.unknown() as unknown as ToZod<CreateDeployment401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated\nPro customers are allowed to deploy Serverless Functions to up to `proMaxRegions` regions, or if the project was created before the limit was introduced.\nDeploying to Serverless Functions to multiple regions requires a plan update
 */
export const createDeployment402Schema = z.unknown() as unknown as ToZod<CreateDeployment402>

/**
 * @description You do not have permission to access this resource.
 */
export const createDeployment403Schema = z.unknown() as unknown as ToZod<CreateDeployment403>

export const createDeployment404Schema = z.unknown() as unknown as ToZod<CreateDeployment404>

/**
 * @description The deployment project is being transferred
 */
export const createDeployment409Schema = z.unknown() as unknown as ToZod<CreateDeployment409>

export const createDeployment500Schema = z.unknown() as unknown as ToZod<CreateDeployment500>

export const createDeploymentMutationRequestSchema = z.object({
  customEnvironmentSlugOrId: z.string().describe('Deploy to a custom environment, which will override the default environment').optional(),
  deploymentId: z.string().describe('An deployment id for an existing deployment to redeploy').optional(),
  files: z
    .array(
      z.union([
        z.object({
          data: z
            .string()
            .describe('The file content, it could be either a `base64` (useful for images, etc.) of the files or the plain content for source code'),
          encoding: z
            .enum(['base64', 'utf-8'])
            .describe('The file content encoding, it could be either a base64 (useful for images, etc.) of the files or the plain text for source code.')
            .optional(),
          file: z.string().describe('The file name including the whole path'),
        }),
        z.object({
          file: z.string().describe('The file path relative to the project root'),
          sha: z.string().describe('The file contents hashed with SHA1, used to check the integrity').optional(),
          size: z.number().int().describe('The file size in bytes').optional(),
        }),
      ]),
    )
    .describe('A list of objects with the files to be deployed')
    .optional(),
  gitMetadata: z
    .object({
      remoteUrl: z.string().describe("The git repository's remote origin url").optional(),
      commitAuthorName: z.string().describe('The name of the author of the commit').optional(),
      commitAuthorEmail: z.string().describe('The email of the author of the commit').optional(),
      commitMessage: z.string().describe('The commit message').optional(),
      commitRef: z.string().describe('The branch on which the commit was made').optional(),
      commitSha: z.string().describe('The hash of the commit').optional(),
      dirty: z.boolean().describe('Whether or not there have been modifications to the working tree since the latest commit').optional(),
    })
    .describe('Populates initial git metadata for different git providers.')
    .optional(),
  gitSource: z
    .union([
      z.object({
        ref: z.string(),
        repoId: z.union([z.string(), z.number()]),
        sha: z.string().optional(),
        type: z.enum(['github']),
      }),
      z.object({
        org: z.string(),
        ref: z.string(),
        repo: z.string(),
        sha: z.string().optional(),
        type: z.enum(['github']),
      }),
      z.object({
        projectId: z.union([z.string(), z.number()]),
        ref: z.string(),
        sha: z.string().optional(),
        type: z.enum(['gitlab']),
      }),
      z.object({
        ref: z.string(),
        repoUuid: z.string(),
        sha: z.string().optional(),
        type: z.enum(['bitbucket']),
        workspaceUuid: z.string().optional(),
      }),
      z.object({
        owner: z.string(),
        ref: z.string(),
        sha: z.string().optional(),
        slug: z.string(),
        type: z.enum(['bitbucket']),
      }),
    ])
    .describe('Defines the Git Repository source to be deployed. This property can not be used in combination with `files`.')
    .optional(),
  meta: z
    .object({})
    .catchall(z.string().max(65536))
    .describe("An object containing the deployment's metadata. Multiple key-value pairs can be attached to a deployment")
    .optional(),
  monorepoManager: z
    .string()
    .describe('The monorepo manager that is being used for this deployment. When `null` is used no monorepo manager is selected')
    .nullable()
    .nullish(),
  name: z.string().describe('A string with the project name used in the deployment URL'),
  project: z.string().describe('The target project identifier in which the deployment will be created. When defined, this parameter overrides name').optional(),
  projectSettings: z
    .object({
      buildCommand: z
        .string()
        .max(256)
        .describe('The build command for this project. When `null` is used this value will be automatically detected')
        .nullable()
        .nullish(),
      commandForIgnoringBuildStep: z.string().max(256).nullable().nullish(),
      devCommand: z
        .string()
        .max(256)
        .describe('The dev command for this project. When `null` is used this value will be automatically detected')
        .nullable()
        .nullish(),
      framework: z
        .enum([
          'angular',
          'astro',
          'blitzjs',
          'brunch',
          'create-react-app',
          'docusaurus',
          'docusaurus-2',
          'dojo',
          'eleventy',
          'ember',
          'fasthtml',
          'gatsby',
          'gridsome',
          'hexo',
          'hugo',
          'hydrogen',
          'ionic-angular',
          'ionic-react',
          'jekyll',
          'middleman',
          'nextjs',
          'nitro',
          'nuxtjs',
          'parcel',
          'polymer',
          'preact',
          'react-router',
          'redwoodjs',
          'remix',
          'saber',
          'sanity',
          'sanity-v3',
          'sapper',
          'scully',
          'solidstart',
          'solidstart-1',
          'stencil',
          'storybook',
          'svelte',
          'sveltekit',
          'sveltekit-1',
          'umijs',
          'vite',
          'vitepress',
          'vue',
          'vuepress',
          'zola',
        ])
        .describe('The framework that is being used for this project. When `null` is used no framework is selected')
        .nullable()
        .nullish(),
      installCommand: z
        .string()
        .max(256)
        .describe('The install command for this project. When `null` is used this value will be automatically detected')
        .nullable()
        .nullish(),
      nodeVersion: z
        .enum(['10.x', '12.x', '14.x', '16.x', '18.x', '20.x', '22.x', '8.10.x'])
        .describe('Override the Node.js version that should be used for this deployment')
        .optional(),
      outputDirectory: z
        .string()
        .max(256)
        .describe('The output directory of the project. When `null` is used this value will be automatically detected')
        .nullable()
        .nullish(),
      rootDirectory: z
        .string()
        .max(256)
        .describe('The name of a directory or relative path to the source code of your project. When `null` is used it will default to the project root')
        .nullable()
        .nullish(),
      serverlessFunctionRegion: z.string().max(4).describe('The region to deploy Serverless Functions in this project').nullable().nullish(),
      skipGitConnectDuringLink: z.boolean().describe('Opts-out of the message prompting a CLI user to connect a Git repository in `vercel link`.').optional(),
      sourceFilesOutsideRootDirectory: z
        .boolean()
        .describe('Indicates if there are source files outside of the root directory, typically used for monorepos')
        .optional(),
    })
    .describe(
      'Project settings that will be applied to the deployment. It is required for the first deployment of a project and will be saved for any following deployments',
    )
    .optional(),
  target: z
    .string()
    .describe(
      'Either not defined, `staging`, `production`, or a custom environment identifier. If `staging`, a staging alias in the format `<project>-<team>.vercel.app` will be assigned. If `production`, any aliases defined in `alias` will be assigned. If omitted, the target will be `preview`.',
    )
    .optional(),
  withLatestCommit: z
    .boolean()
    .describe(
      "When `true` and `deploymentId` is passed in, the sha from the previous deployment's `gitSource` is removed forcing the latest commit to be used.",
    )
    .optional(),
}) as unknown as ToZod<CreateDeploymentMutationRequest>

export const createDeploymentMutationResponseSchema = z.lazy(() => createDeployment200Schema) as unknown as ToZod<CreateDeploymentMutationResponse>

export const cancelDeploymentPathParamsSchema = z.object({
  id: z.string().describe('The unique identifier of the deployment.'),
}) as unknown as ToZod<CancelDeploymentPathParams>

export const cancelDeploymentQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<CancelDeploymentQueryParams>

export const cancelDeployment200Schema = z
  .object({
    aliasAssignedAt: z.union([z.boolean(), z.number()]).nullable().nullish(),
    alwaysRefuseToBuild: z.boolean().optional(),
    build: z.object({
      env: z.array(z.string()),
    }),
    buildArtifactUrls: z.array(z.string()).optional(),
    builds: z
      .array(
        z.object({
          use: z.string(),
          src: z.string().optional(),
          config: z.object({}).catchall(z.unknown()).optional(),
        }),
      )
      .optional(),
    env: z.array(z.string()),
    inspectorUrl: z.string().nullable(),
    isInConcurrentBuildsQueue: z.boolean(),
    isInSystemBuildsQueue: z.boolean(),
    projectSettings: z.object({
      buildCommand: z.string().nullable().nullish(),
      devCommand: z.string().nullable().nullish(),
      framework: z
        .enum([
          'angular',
          'astro',
          'blitzjs',
          'brunch',
          'create-react-app',
          'docusaurus',
          'docusaurus-2',
          'dojo',
          'eleventy',
          'ember',
          'fasthtml',
          'gatsby',
          'gridsome',
          'hexo',
          'hugo',
          'hydrogen',
          'ionic-angular',
          'ionic-react',
          'jekyll',
          'middleman',
          'nextjs',
          'nitro',
          'nuxtjs',
          'parcel',
          'polymer',
          'preact',
          'react-router',
          'redwoodjs',
          'remix',
          'saber',
          'sanity',
          'sanity-v3',
          'sapper',
          'scully',
          'solidstart',
          'solidstart-1',
          'stencil',
          'storybook',
          'svelte',
          'sveltekit',
          'sveltekit-1',
          'umijs',
          'vite',
          'vitepress',
          'vue',
          'vuepress',
          'zola',
        ])
        .nullable()
        .nullish(),
      commandForIgnoringBuildStep: z.string().nullable().nullish(),
      installCommand: z.string().nullable().nullish(),
      outputDirectory: z.string().nullable().nullish(),
      speedInsights: z
        .object({
          id: z.string(),
          enabledAt: z.number().optional(),
          disabledAt: z.number().optional(),
          canceledAt: z.number().optional(),
          hasData: z.boolean().optional(),
          paidAt: z.number().optional(),
        })
        .optional(),
      webAnalytics: z
        .object({
          id: z.string(),
          disabledAt: z.number().optional(),
          canceledAt: z.number().optional(),
          enabledAt: z.number().optional(),
          hasData: z.boolean().optional(),
        })
        .optional(),
    }),
    readyStateReason: z.string().optional(),
    integrations: z
      .object({
        status: z.enum(['error', 'pending', 'ready', 'skipped', 'timeout']),
        startedAt: z.number(),
        completedAt: z.number().optional(),
        skippedAt: z.number().optional(),
        skippedBy: z.string().optional(),
      })
      .optional(),
    images: z
      .object({
        sizes: z.array(z.number()).optional(),
        qualities: z.array(z.number()).optional(),
        domains: z.array(z.string()).optional(),
        remotePatterns: z
          .array(
            z.object({
              protocol: z.enum(['http', 'https']).describe('Must be `http` or `https`.').optional(),
              hostname: z.string().describe('Can be literal or wildcard. Single `*` matches a single subdomain. Double `**` matches any number of subdomains.'),
              port: z.string().describe('Can be literal port such as `8080` or empty string meaning no port.').optional(),
              pathname: z
                .string()
                .describe('Can be literal or wildcard. Single `*` matches a single path segment. Double `**` matches any number of path segments.')
                .optional(),
              search: z.string().describe('Can be literal query string such as `?v=1` or empty string meaning no query string.').optional(),
            }),
          )
          .optional(),
        localPatterns: z
          .array(
            z.object({
              pathname: z
                .string()
                .describe('Can be literal or wildcard. Single `*` matches a single path segment. Double `**` matches any number of path segments.')
                .optional(),
              search: z.string().describe('Can be literal query string such as `?v=1` or empty string meaning no query string.').optional(),
            }),
          )
          .optional(),
        minimumCacheTTL: z.number().optional(),
        formats: z.array(z.enum(['image/avif', 'image/webp'])).optional(),
        dangerouslyAllowSVG: z.boolean().optional(),
        contentSecurityPolicy: z.string().optional(),
        contentDispositionType: z.enum(['attachment', 'inline']).optional(),
      })
      .optional(),
    alias: z.array(z.string()).optional(),
    aliasAssigned: z.boolean(),
    bootedAt: z.number(),
    buildingAt: z.number(),
    buildContainerFinishedAt: z.number().describe('Since April 2025 it necessary for On-Demand Concurrency Minutes calculation').optional(),
    buildSkipped: z.boolean(),
    creator: z.object({
      uid: z.string(),
      username: z.string().optional(),
      avatar: z.string().optional(),
    }),
    initReadyAt: z.number().optional(),
    isFirstBranchDeployment: z.boolean().optional(),
    lambdas: z
      .array(
        z
          .object({
            id: z.string().optional(),
            createdAt: z.number().optional(),
            entrypoint: z.string().nullable().nullish(),
            readyState: z.enum(['BUILDING', 'ERROR', 'INITIALIZING', 'READY']).optional(),
            readyStateAt: z.number().optional(),
            output: z.array(
              z.object({
                path: z.string(),
                functionName: z.string(),
              }),
            ),
          })
          .describe('A partial representation of a Build used by the deployment endpoint.'),
      )
      .optional(),
    public: z.boolean(),
    ready: z.number().optional(),
    status: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
    team: z
      .object({
        id: z.string(),
        name: z.string(),
        avatar: z.string().optional(),
        slug: z.string(),
      })
      .optional(),
    userAliases: z.array(z.string()).optional(),
    previewCommentsEnabled: z.boolean().optional(),
    ttyBuildLogs: z.boolean().optional(),
    customEnvironment: z
      .union([
        z.object({
          id: z.string().describe('Unique identifier for the custom environment (format: env_*)'),
          slug: z.string().describe('URL-friendly name of the environment'),
          type: z.enum(['production', 'preview', 'development']).describe('The type of environment (production, preview, or development)'),
          description: z.string().describe("Optional description of the environment's purpose").optional(),
          branchMatcher: z
            .object({
              type: z.enum(['endsWith', 'startsWith', 'equals']).describe('The type of matching to perform'),
              pattern: z.string().describe('The pattern to match against branch names'),
            })
            .describe('Configuration for matching git branches to this environment')
            .optional(),
          domains: z
            .array(
              z
                .object({
                  name: z.string(),
                  apexName: z.string(),
                  projectId: z.string(),
                  redirect: z.string().nullable().nullish(),
                  redirectStatusCode: z
                    .union([z.literal(307), z.literal(301), z.literal(302), z.literal(308)])
                    .nullable()
                    .nullish(),
                  gitBranch: z.string().nullable().nullish(),
                  customEnvironmentId: z.string().nullable().nullish(),
                  updatedAt: z.number().optional(),
                  createdAt: z.number().optional(),
                  verified: z
                    .boolean()
                    .describe(
                      '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
                    ),
                  verification: z
                    .array(
                      z
                        .object({
                          type: z.string(),
                          domain: z.string(),
                          value: z.string(),
                          reason: z.string(),
                        })
                        .describe(
                          'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                        ),
                    )
                    .describe(
                      'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                    )
                    .optional(),
                })
                .describe('List of domains associated with this environment'),
            )
            .describe('List of domains associated with this environment')
            .optional(),
          currentDeploymentAliases: z.array(z.string()).describe('List of aliases for the current deployment').optional(),
          createdAt: z.number().describe('Timestamp when the environment was created'),
          updatedAt: z.number().describe('Timestamp when the environment was last updated'),
        }),
        z.object({
          id: z.string(),
        }),
      ])
      .optional(),
    oomReport: z.enum(['out-of-memory']).optional(),
    id: z.string(),
    aliasError: z
      .object({
        code: z.string(),
        message: z.string(),
      })
      .nullable()
      .nullish(),
    aliasFinal: z.string().nullable().nullish(),
    aliasWarning: z
      .object({
        code: z.string(),
        message: z.string(),
        link: z.string().optional(),
        action: z.string().optional(),
      })
      .nullable()
      .nullish(),
    autoAssignCustomDomains: z.boolean().describe('applies to custom domains only, defaults to `true`').optional(),
    automaticAliases: z.array(z.string()).optional(),
    buildErrorAt: z.number().optional(),
    checksState: z.enum(['completed', 'registered', 'running']).optional(),
    checksConclusion: z.enum(['canceled', 'failed', 'skipped', 'succeeded']).optional(),
    createdAt: z.number(),
    deletedAt: z.number().nullable().nullish(),
    defaultRoute: z.string().describe('Computed field that is only available for deployments with a microfrontend configuration.').optional(),
    canceledAt: z.number().optional(),
    errorCode: z.string().optional(),
    errorLink: z.string().optional(),
    errorMessage: z.string().nullable().nullish(),
    errorStep: z.string().optional(),
    passiveRegions: z
      .array(z.string())
      .describe(
        'Since November 2023 this field defines a set of regions that we will deploy the lambda to passively Lambdas will be deployed to these regions but only invoked if all of the primary `regions` are marked as out of service',
      )
      .optional(),
    gitSource: z
      .union([
        z.object({
          type: z.enum(['github']),
          repoId: z.union([z.string(), z.number()]),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['github']),
          org: z.string(),
          repo: z.string(),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['github-custom-host']),
          host: z.string(),
          repoId: z.union([z.string(), z.number()]),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['github-custom-host']),
          host: z.string(),
          org: z.string(),
          repo: z.string(),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['gitlab']),
          projectId: z.union([z.string(), z.number()]),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['bitbucket']),
          workspaceUuid: z.string().optional(),
          repoUuid: z.string(),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['bitbucket']),
          owner: z.string(),
          slug: z.string(),
          ref: z.string().nullable().nullish(),
          sha: z.string().optional(),
          prId: z.number().nullable().nullish(),
        }),
        z.object({
          type: z.enum(['custom']),
          ref: z.string(),
          sha: z.string(),
          gitUrl: z.string(),
        }),
        z.object({
          type: z.enum(['github']),
          ref: z.string(),
          sha: z.string(),
          repoId: z.number(),
          org: z.string().optional(),
          repo: z.string().optional(),
        }),
        z.object({
          type: z.enum(['github-custom-host']),
          host: z.string(),
          ref: z.string(),
          sha: z.string(),
          repoId: z.number(),
          org: z.string().optional(),
          repo: z.string().optional(),
        }),
        z.object({
          type: z.enum(['gitlab']),
          ref: z.string(),
          sha: z.string(),
          projectId: z.number(),
        }),
        z.object({
          type: z.enum(['bitbucket']),
          ref: z.string(),
          sha: z.string(),
          owner: z.string().optional(),
          slug: z.string().optional(),
          workspaceUuid: z.string(),
          repoUuid: z.string(),
        }),
      ])
      .optional(),
    name: z.string(),
    meta: z.object({}).catchall(z.string()),
    originCacheRegion: z.string().optional(),
    project: z
      .object({
        id: z.string(),
        name: z.string(),
        framework: z.string().nullable().nullish(),
      })
      .optional(),
    readyState: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
    readySubstate: z
      .enum(['PROMOTED', 'ROLLING', 'STAGED'])
      .describe(
        "Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - ROLLING: in the process of having production traffic gradually transitioned. - PROMOTED: has seen production traffic",
      )
      .optional(),
    regions: z.array(z.string()),
    softDeletedByRetention: z.boolean().optional(),
    source: z.enum(['api-trigger-git-deploy', 'cli', 'clone/repo', 'git', 'import', 'import/repo', 'redeploy', 'v0-web']).optional(),
    target: z.enum(['production', 'staging']).nullable().nullish(),
    type: z.enum(['LAMBDAS']),
    undeletedAt: z.number().optional(),
    url: z.string(),
    version: z.literal(2),
    oidcTokenClaims: z
      .object({
        iss: z.string(),
        sub: z.string(),
        scope: z.string(),
        aud: z.string(),
        owner: z.string(),
        owner_id: z.string(),
        project: z.string(),
        project_id: z.string(),
        environment: z.string(),
      })
      .optional(),
    connectBuildsEnabled: z.boolean().optional(),
    connectConfigurationId: z.string().optional(),
    createdIn: z.string(),
    crons: z
      .array(
        z.object({
          schedule: z.string(),
          path: z.string(),
        }),
      )
      .optional(),
    functions: z
      .object({})
      .catchall(
        z.object({
          architecture: z.enum(['arm64', 'x86_64']).optional(),
          memory: z.number().optional(),
          maxDuration: z.number().optional(),
          runtime: z.string().optional(),
          includeFiles: z.string().optional(),
          excludeFiles: z.string().optional(),
          experimentalTriggers: z
            .array(
              z
                .object({
                  type: z.enum(['queue/v1beta']).describe('Event type - must be "queue/v1beta" (REQUIRED)'),
                  topic: z.string().describe('Name of the queue topic to consume from (REQUIRED)'),
                  consumer: z.string().describe('Name of the consumer group for this trigger (REQUIRED)'),
                  maxDeliveries: z
                    .number()
                    .describe(
                      "Maximum number of delivery attempts for message processing (OPTIONAL) This represents the total number of times a message can be delivered, not the number of retries. Must be at least 1 if specified. Behavior when not specified depends on the server's default configuration.",
                    )
                    .optional(),
                  retryAfterSeconds: z
                    .number()
                    .describe(
                      "Delay in seconds before retrying failed executions (OPTIONAL) Behavior when not specified depends on the server's default configuration.",
                    )
                    .optional(),
                  initialDelaySeconds: z
                    .number()
                    .describe(
                      "Initial delay in seconds before first execution attempt (OPTIONAL) Must be 0 or greater. Use 0 for no initial delay. Behavior when not specified depends on the server's default configuration.",
                    )
                    .optional(),
                })
                .describe('Queue trigger event for Vercel\'s queue system. Handles "queue/v1beta" events with queue-specific configuration.'),
            )
            .optional(),
        }),
      )
      .nullable()
      .nullish(),
    monorepoManager: z.string().nullable().nullish(),
    ownerId: z.string(),
    passiveConnectConfigurationId: z
      .string()
      .describe('Since November 2023 this field defines a Secure Compute network that will only be used to deploy passive lambdas to (as in passiveRegions)')
      .optional(),
    plan: z.enum(['enterprise', 'hobby', 'pro']),
    projectId: z.string(),
    routes: z
      .array(
        z.union([
          z.object({
            src: z.string(),
            dest: z.string().optional(),
            headers: z.object({}).catchall(z.string()).optional(),
            methods: z.array(z.string()).optional(),
            continue: z.boolean().optional(),
            override: z.boolean().optional(),
            caseSensitive: z.boolean().optional(),
            check: z.boolean().optional(),
            important: z.boolean().optional(),
            status: z.number().optional(),
            has: z
              .array(
                z.union([
                  z.object({
                    type: z.enum(['host']),
                    value: z.union([
                      z.string(),
                      z.object({
                        eq: z.union([z.string(), z.number()]).optional(),
                        neq: z.string().optional(),
                        inc: z.array(z.string()).optional(),
                        ninc: z.array(z.string()).optional(),
                        pre: z.string().optional(),
                        suf: z.string().optional(),
                        re: z.string().optional(),
                        gt: z.number().optional(),
                        gte: z.number().optional(),
                        lt: z.number().optional(),
                        lte: z.number().optional(),
                      }),
                    ]),
                  }),
                  z.object({
                    type: z.enum(['header', 'cookie', 'query']),
                    key: z.string(),
                    value: z
                      .union([
                        z.string(),
                        z.object({
                          eq: z.union([z.string(), z.number()]).optional(),
                          neq: z.string().optional(),
                          inc: z.array(z.string()).optional(),
                          ninc: z.array(z.string()).optional(),
                          pre: z.string().optional(),
                          suf: z.string().optional(),
                          re: z.string().optional(),
                          gt: z.number().optional(),
                          gte: z.number().optional(),
                          lt: z.number().optional(),
                          lte: z.number().optional(),
                        }),
                      ])
                      .optional(),
                  }),
                ]),
              )
              .optional(),
            missing: z
              .array(
                z.union([
                  z.object({
                    type: z.enum(['host']),
                    value: z.union([
                      z.string(),
                      z.object({
                        eq: z.union([z.string(), z.number()]).optional(),
                        neq: z.string().optional(),
                        inc: z.array(z.string()).optional(),
                        ninc: z.array(z.string()).optional(),
                        pre: z.string().optional(),
                        suf: z.string().optional(),
                        re: z.string().optional(),
                        gt: z.number().optional(),
                        gte: z.number().optional(),
                        lt: z.number().optional(),
                        lte: z.number().optional(),
                      }),
                    ]),
                  }),
                  z.object({
                    type: z.enum(['header', 'cookie', 'query']),
                    key: z.string(),
                    value: z
                      .union([
                        z.string(),
                        z.object({
                          eq: z.union([z.string(), z.number()]).optional(),
                          neq: z.string().optional(),
                          inc: z.array(z.string()).optional(),
                          ninc: z.array(z.string()).optional(),
                          pre: z.string().optional(),
                          suf: z.string().optional(),
                          re: z.string().optional(),
                          gt: z.number().optional(),
                          gte: z.number().optional(),
                          lt: z.number().optional(),
                          lte: z.number().optional(),
                        }),
                      ])
                      .optional(),
                  }),
                ]),
              )
              .optional(),
            mitigate: z
              .object({
                action: z.enum(['challenge', 'deny']),
              })
              .optional(),
            transforms: z
              .array(
                z.object({
                  type: z.enum(['request.headers', 'request.query', 'response.headers']),
                  op: z.enum(['append', 'set', 'delete']),
                  target: z.object({
                    key: z.union([
                      z.string(),
                      z.object({
                        eq: z.union([z.string(), z.number()]).optional(),
                        neq: z.string().optional(),
                        inc: z.array(z.string()).optional(),
                        ninc: z.array(z.string()).optional(),
                        pre: z.string().optional(),
                        suf: z.string().optional(),
                        gt: z.number().optional(),
                        gte: z.number().optional(),
                        lt: z.number().optional(),
                        lte: z.number().optional(),
                      }),
                    ]),
                  }),
                  args: z.union([z.array(z.string()), z.string()]).optional(),
                }),
              )
              .optional(),
            locale: z
              .object({
                redirect: z.object({}).catchall(z.string()).optional(),
                cookie: z.string().optional(),
              })
              .optional(),
            middlewarePath: z
              .string()
              .describe('A middleware key within the `output` key under the build result. Overrides a `middleware` definition.')
              .optional(),
            middlewareRawSrc: z.array(z.string()).describe('The original middleware matchers.').optional(),
            middleware: z.number().describe('A middleware index in the `middleware` key under the build result').optional(),
          }),
          z.object({
            handle: z.enum(['error', 'filesystem', 'hit', 'miss', 'rewrite', 'resource']),
            src: z.string().optional(),
            dest: z.string().optional(),
            status: z.number().optional(),
          }),
          z.object({
            src: z.string(),
            continue: z.boolean(),
            middleware: z.literal(0),
          }),
        ]),
      )
      .nullable(),
    gitRepo: z
      .union([
        z.object({
          namespace: z.string(),
          projectId: z.number(),
          type: z.enum(['gitlab']),
          url: z.string(),
          path: z.string(),
          defaultBranch: z.string(),
          name: z.string(),
          private: z.boolean(),
          ownerType: z.enum(['team', 'user']),
        }),
        z.object({
          org: z.string(),
          repo: z.string(),
          repoId: z.number(),
          type: z.enum(['github']),
          repoOwnerId: z.number(),
          path: z.string(),
          defaultBranch: z.string(),
          name: z.string(),
          private: z.boolean(),
          ownerType: z.enum(['team', 'user']),
        }),
        z.object({
          owner: z.string(),
          repoUuid: z.string(),
          slug: z.string(),
          type: z.enum(['bitbucket']),
          workspaceUuid: z.string(),
          path: z.string(),
          defaultBranch: z.string(),
          name: z.string(),
          private: z.boolean(),
          ownerType: z.enum(['team', 'user']),
        }),
      ])
      .nullable()
      .nullish(),
    flags: z
      .union([
        z.array(
          z.object({}).describe('Flags defined in the Build Output API, used by this deployment. Primarily used by the Toolbar to know about the used flags.'),
        ),
        z.object({
          definitions: z.object({}).catchall(
            z.object({
              options: z
                .array(
                  z.object({
                    value: z.lazy(() => flagJSONValueSchema).nullable(),
                    label: z.string().optional(),
                  }),
                )
                .optional(),
              url: z.string().optional(),
              description: z.string().optional(),
            }),
          ),
        }),
      ])
      .optional(),
    microfrontends: z
      .union([
        z.object({
          isDefaultApp: z
            .boolean()
            .describe(
              'Whether this project is the default application for the microfrontends group. The default application is the one that is used as the top level shell for the microfrontends group and hosts the other microfrontends.',
            )
            .optional(),
          defaultAppProjectName: z.string().describe("The project name of the default app of this deployment's microfrontends group."),
          defaultRoute: z
            .string()
            .describe(
              'A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI.',
            )
            .optional(),
          groupIds: z
            .array(z.union([z.string(), z.string()]))
            .min(2)
            .max(2)
            .describe(
              'The group of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.',
            ),
          microfrontendsAliasEnabled: z
            .boolean()
            .describe(
              "Whether the MicrofrontendsAlias team flag should be considered enabled for this deployment or not. This is used to ensure that we don't accidentally switch an existing branch alias to a microfrontends branch alias.",
            )
            .optional(),
          previewEnvAliasEnabled: z
            .boolean()
            .describe(
              'Whether this deployment, if a preview deployment on the production branch, should get the -env-preview alias instead of a normal branch alias. This is used to always generate a microfrontends fallback on the preview branch.',
            )
            .optional(),
        }),
        z.object({
          applications: z
            .object({})
            .catchall(
              z
                .object({
                  isDefaultApp: z.boolean().optional(),
                  productionHost: z.string().describe('This is the production alias, it will always show the most up to date of each application.'),
                  deploymentAlias: z
                    .string()
                    .describe(
                      'Use the fixed deploymentAlias and deploymentHost so that the microfrontend preview stays in sync with the deployment. These are only present for mono-repos when a single commit creates multiple deployments. If they are not present, productionHost will be used.',
                    )
                    .optional(),
                  deploymentHost: z.string().optional(),
                })
                .describe(
                  'A map of the other applications that are part of this group. Only defined on the default application. The field is set after deployments have been created, so can be undefined, but should be there for a successful deployment.',
                ),
            )
            .describe(
              'A map of the other applications that are part of this group. Only defined on the default application. The field is set after deployments have been created, so can be undefined, but should be there for a successful deployment.',
            )
            .optional(),
          isDefaultApp: z.boolean(),
          defaultAppProjectName: z.string().describe("The project name of the default app of this deployment's microfrontends group."),
          defaultRoute: z
            .string()
            .describe(
              'A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI.',
            )
            .optional(),
          groupIds: z
            .array(z.union([z.string(), z.string()]))
            .min(2)
            .max(2)
            .describe(
              'The group of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.',
            ),
          microfrontendsAliasEnabled: z
            .boolean()
            .describe(
              "Whether the MicrofrontendsAlias team flag should be considered enabled for this deployment or not. This is used to ensure that we don't accidentally switch an existing branch alias to a microfrontends branch alias.",
            )
            .optional(),
          previewEnvAliasEnabled: z
            .boolean()
            .describe(
              'Whether this deployment, if a preview deployment on the production branch, should get the -env-preview alias instead of a normal branch alias. This is used to always generate a microfrontends fallback on the preview branch.',
            )
            .optional(),
        }),
      ])
      .optional(),
    config: z
      .object({
        version: z.number().optional(),
        functionType: z.enum(['fluid', 'standard']),
        functionMemoryType: z.enum(['performance', 'standard', 'standard_legacy']),
        functionTimeout: z.number().nullable(),
        secureComputePrimaryRegion: z.string().nullable(),
        secureComputeFallbackRegion: z.string().nullable(),
        isUsingActiveCPU: z.boolean().optional(),
      })
      .describe(
        'Since February 2025 the configuration must include snapshot data at the time of deployment creation to capture properties for the /deployments/:id/config endpoint utilized for displaying Deployment Configuration on the frontend This is optional because older deployments may not have this data captured',
      )
      .optional(),
    checks: z
      .object({
        'deployment-alias': z
          .object({
            state: z.enum(['failed', 'pending', 'succeeded']),
            startedAt: z.number(),
            completedAt: z.number().optional(),
          })
          .describe('Condensed check data. Retrieve individual check and check run data using api-checks v2 routes.'),
      })
      .optional(),
  })
  .describe('The private deployment representation of a Deployment.') as unknown as ToZod<CancelDeployment200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const cancelDeployment400Schema = z.unknown() as unknown as ToZod<CancelDeployment400>

export const cancelDeployment401Schema = z.unknown() as unknown as ToZod<CancelDeployment401>

/**
 * @description You do not have permission to access this resource.
 */
export const cancelDeployment403Schema = z.unknown() as unknown as ToZod<CancelDeployment403>

export const cancelDeployment404Schema = z.unknown() as unknown as ToZod<CancelDeployment404>

export const cancelDeploymentMutationResponseSchema = z.lazy(() => cancelDeployment200Schema) as unknown as ToZod<CancelDeploymentMutationResponse>

export const buyDomainQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<BuyDomainQueryParams>

export const buyDomain201Schema = z.object({
  domain: z.object({
    uid: z.string(),
    ns: z.array(z.string()),
    verified: z.boolean(),
    created: z.number(),
    pending: z.boolean(),
  }),
}) as unknown as ToZod<BuyDomain201>

export const buyDomain202Schema = z.object({
  domain: z.object({
    uid: z.string(),
    ns: z.array(z.string()),
    verified: z.boolean(),
    created: z.number(),
    pending: z.boolean(),
  }),
}) as unknown as ToZod<BuyDomain202>

/**
 * @description One of the provided values in the request body is invalid.
 */
export const buyDomain400Schema = z.unknown() as unknown as ToZod<BuyDomain400>

export const buyDomain401Schema = z.unknown() as unknown as ToZod<BuyDomain401>

/**
 * @description You do not have permission to access this resource.
 */
export const buyDomain403Schema = z.unknown() as unknown as ToZod<BuyDomain403>

export const buyDomain409Schema = z.unknown() as unknown as ToZod<BuyDomain409>

export const buyDomain429Schema = z.unknown() as unknown as ToZod<BuyDomain429>

export const buyDomainMutationRequestSchema = z.object({
  name: z.string().describe('The domain name to purchase.'),
  expectedPrice: z.number().describe('The price you expect to be charged for the purchase.').optional(),
  renew: z.boolean().describe('Indicates whether the domain should be automatically renewed.').optional(),
  country: z.string().describe('The country of the domain registrant'),
  orgName: z.string().describe('The company name of the domain registrant').optional(),
  firstName: z.string().describe('The first name of the domain registrant'),
  lastName: z.string().describe('The last name of the domain registrant'),
  address1: z.string().describe('The street address of the domain registrant'),
  city: z.string().describe('The city of the domain registrant'),
  state: z.string().describe('The state of the domain registrant'),
  postalCode: z.string().describe('The postal code of the domain registrant'),
  phone: z.string().describe('The phone number of the domain registrant'),
  email: z.string().describe('The email of the domain registrant'),
}) as unknown as ToZod<BuyDomainMutationRequest>

export const buyDomainMutationResponseSchema = z.union([
  z.lazy(() => buyDomain201Schema),
  z.lazy(() => buyDomain202Schema),
]) as unknown as ToZod<BuyDomainMutationResponse>

export const checkDomainPriceQueryParamsSchema = z.object({
  name: z.string().describe('The name of the domain for which the price needs to be checked.'),
  type: z.enum(['new', 'renewal', 'transfer', 'redemption']).describe('In which status of the domain the price needs to be checked.').optional(),
  teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
  slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
}) as unknown as ToZod<CheckDomainPriceQueryParams>

/**
 * @description Successful response which returns the price of the domain and the period.
 */
export const checkDomainPrice200Schema = z
  .object({
    price: z.number().describe('The domain price in USD.'),
    period: z.union([z.literal(1), z.literal(10), z.literal(2)]).describe('The number of years the domain could be held before paying again.'),
  })
  .describe('Successful response which returns the price of the domain and the period.') as unknown as ToZod<CheckDomainPrice200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const checkDomainPrice400Schema = z.unknown() as unknown as ToZod<CheckDomainPrice400>

export const checkDomainPrice401Schema = z.unknown() as unknown as ToZod<CheckDomainPrice401>

/**
 * @description You do not have permission to access this resource.
 */
export const checkDomainPrice403Schema = z.unknown() as unknown as ToZod<CheckDomainPrice403>

export const checkDomainPriceQueryResponseSchema = z.lazy(() => checkDomainPrice200Schema) as unknown as ToZod<CheckDomainPriceQueryResponse>

export const checkDomainStatusQueryParamsSchema = z.object({
  name: z.string().describe('The name of the domain for which we would like to check the status.'),
  teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
  slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
}) as unknown as ToZod<CheckDomainStatusQueryParams>

/**
 * @description Successful response checking if a Domain\'s name is available.
 */
export const checkDomainStatus200Schema = z.object({
  available: z.boolean(),
}) as unknown as ToZod<CheckDomainStatus200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const checkDomainStatus400Schema = z.unknown() as unknown as ToZod<CheckDomainStatus400>

export const checkDomainStatus401Schema = z.unknown() as unknown as ToZod<CheckDomainStatus401>

/**
 * @description You do not have permission to access this resource.
 */
export const checkDomainStatus403Schema = z.unknown() as unknown as ToZod<CheckDomainStatus403>

export const checkDomainStatus408Schema = z.unknown() as unknown as ToZod<CheckDomainStatus408>

export const checkDomainStatus500Schema = z.unknown() as unknown as ToZod<CheckDomainStatus500>

export const checkDomainStatusQueryResponseSchema = z.lazy(() => checkDomainStatus200Schema) as unknown as ToZod<CheckDomainStatusQueryResponse>

export const getRecordsPathParamsSchema = z.object({
  domain: z.string(),
}) as unknown as ToZod<GetRecordsPathParams>

export const getRecordsQueryParamsSchema = z
  .object({
    limit: z.string().describe('Maximum number of records to list from a request.').optional(),
    since: z.string().describe('Get records created after this JavaScript timestamp.').optional(),
    until: z.string().describe('Get records created before this JavaScript timestamp.').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetRecordsQueryParams>

/**
 * @description Successful response retrieving a list of paginated DNS records.
 */
export const getRecords200Schema = z.union([
  z.string(),
  z.object({
    records: z.array(
      z.object({
        id: z.string(),
        slug: z.string(),
        name: z.string(),
        type: z.enum(['A', 'AAAA', 'ALIAS', 'CAA', 'CNAME', 'HTTPS', 'MX', 'SRV', 'TXT', 'NS']),
        value: z.string(),
        mxPriority: z.number().optional(),
        priority: z.number().optional(),
        creator: z.string(),
        created: z.number().nullable(),
        updated: z.number().nullable(),
        createdAt: z.number().nullable(),
        updatedAt: z.number().nullable(),
      }),
    ),
  }),
  z.object({
    records: z.array(
      z.object({
        id: z.string(),
        slug: z.string(),
        name: z.string(),
        type: z.enum(['A', 'AAAA', 'ALIAS', 'CAA', 'CNAME', 'HTTPS', 'MX', 'SRV', 'TXT', 'NS']),
        value: z.string(),
        mxPriority: z.number().optional(),
        priority: z.number().optional(),
        creator: z.string(),
        created: z.number().nullable(),
        updated: z.number().nullable(),
        createdAt: z.number().nullable(),
        updatedAt: z.number().nullable(),
      }),
    ),
    pagination: z
      .lazy(() => paginationSchema)
      .describe(
        'This object contains information related to the pagination of the current request, including the necessary parameters to get the next or previous page of data.',
      ),
  }),
]) as unknown as ToZod<GetRecords200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getRecords400Schema = z.unknown() as unknown as ToZod<GetRecords400>

export const getRecords401Schema = z.unknown() as unknown as ToZod<GetRecords401>

/**
 * @description You do not have permission to access this resource.
 */
export const getRecords403Schema = z.unknown() as unknown as ToZod<GetRecords403>

export const getRecords404Schema = z.unknown() as unknown as ToZod<GetRecords404>

export const getRecordsQueryResponseSchema = z.lazy(() => getRecords200Schema) as unknown as ToZod<GetRecordsQueryResponse>

export const createRecordPathParamsSchema = z.object({
  domain: z.string().describe('The domain used to create the DNS record.'),
}) as unknown as ToZod<CreateRecordPathParams>

export const createRecordQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<CreateRecordQueryParams>

/**
 * @description Successful response showing the uid of the newly created DNS record.
 */
export const createRecord200Schema = z.union([
  z.object({
    uid: z.string(),
    updated: z.number(),
  }),
  z.object({
    uid: z.string().describe('The id of the newly created DNS record'),
  }),
]) as unknown as ToZod<CreateRecord200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const createRecord400Schema = z.unknown() as unknown as ToZod<CreateRecord400>

export const createRecord401Schema = z.unknown() as unknown as ToZod<CreateRecord401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const createRecord402Schema = z.unknown() as unknown as ToZod<CreateRecord402>

/**
 * @description You do not have permission to access this resource.
 */
export const createRecord403Schema = z.unknown() as unknown as ToZod<CreateRecord403>

export const createRecord404Schema = z.unknown() as unknown as ToZod<CreateRecord404>

export const createRecord409Schema = z.unknown() as unknown as ToZod<CreateRecord409>

export const createRecordMutationRequestSchema = z.union([
  z
    .object({
      name: z.string().describe('A subdomain name or an empty string for the root domain.'),
      type: z.enum(['A']).describe('Must be of type `A`.'),
      ttl: z.number().min(60).max(2147483647).describe('The TTL value. Must be a number between 60 and 2147483647. Default value is 60.').optional(),
      value: z.string().url().describe('The record value must be a valid IPv4 address.'),
      comment: z.string().max(500).describe('A comment to add context on what this DNS record is for').optional(),
    })
    .and(
      z.object({
        type: z
          .enum(['A', 'AAAA', 'ALIAS', 'CAA', 'CNAME', 'HTTPS', 'MX', 'NS', 'SRV', 'TXT'])
          .describe('The type of record, it could be one of the valid DNS records.'),
      }),
    ),
  z
    .object({
      name: z.string().describe('A subdomain name or an empty string for the root domain.'),
      type: z.enum(['AAAA']).describe('Must be of type `AAAA`.'),
      ttl: z.number().min(60).max(2147483647).describe('The TTL value. Must be a number between 60 and 2147483647. Default value is 60.').optional(),
      value: z.string().url().describe('An AAAA record pointing to an IPv6 address.'),
      comment: z.string().max(500).describe('A comment to add context on what this DNS record is for').optional(),
    })
    .and(
      z.object({
        type: z
          .enum(['A', 'AAAA', 'ALIAS', 'CAA', 'CNAME', 'HTTPS', 'MX', 'NS', 'SRV', 'TXT'])
          .describe('The type of record, it could be one of the valid DNS records.'),
      }),
    ),
  z
    .object({
      name: z.string().describe('A subdomain name or an empty string for the root domain.'),
      type: z.enum(['ALIAS']).describe('Must be of type `ALIAS`.'),
      ttl: z.number().min(60).max(2147483647).describe('The TTL value. Must be a number between 60 and 2147483647. Default value is 60.').optional(),
      value: z.string().describe('An ALIAS virtual record pointing to a hostname resolved to an A record on server side.'),
      comment: z.string().max(500).describe('A comment to add context on what this DNS record is for').optional(),
    })
    .and(
      z.object({
        type: z
          .enum(['A', 'AAAA', 'ALIAS', 'CAA', 'CNAME', 'HTTPS', 'MX', 'NS', 'SRV', 'TXT'])
          .describe('The type of record, it could be one of the valid DNS records.'),
      }),
    ),
  z
    .object({
      name: z.string().describe('A subdomain name or an empty string for the root domain.'),
      type: z.enum(['CAA']).describe('Must be of type `CAA`.'),
      ttl: z.number().min(60).max(2147483647).describe('The TTL value. Must be a number between 60 and 2147483647. Default value is 60.').optional(),
      value: z.string().describe('A CAA record to specify which Certificate Authorities (CAs) are allowed to issue certificates for the domain.'),
      comment: z.string().max(500).describe('A comment to add context on what this DNS record is for').optional(),
    })
    .and(
      z.object({
        type: z
          .enum(['A', 'AAAA', 'ALIAS', 'CAA', 'CNAME', 'HTTPS', 'MX', 'NS', 'SRV', 'TXT'])
          .describe('The type of record, it could be one of the valid DNS records.'),
      }),
    ),
  z
    .object({
      name: z.string().describe('A subdomain name or an empty string for the root domain.'),
      type: z.enum(['CNAME']).describe('Must be of type `CNAME`.'),
      ttl: z.number().min(60).max(2147483647).describe('The TTL value. Must be a number between 60 and 2147483647. Default value is 60.').optional(),
      value: z.string().describe('A CNAME record mapping to another domain name.').optional(),
      comment: z.string().max(500).describe('A comment to add context on what this DNS record is for').optional(),
    })
    .and(
      z.object({
        type: z
          .enum(['A', 'AAAA', 'ALIAS', 'CAA', 'CNAME', 'HTTPS', 'MX', 'NS', 'SRV', 'TXT'])
          .describe('The type of record, it could be one of the valid DNS records.'),
      }),
    ),
  z
    .object({
      name: z.string().describe('A subdomain name or an empty string for the root domain.'),
      type: z.enum(['MX']).describe('Must be of type `MX`.'),
      ttl: z.number().min(60).max(2147483647).describe('The TTL value. Must be a number between 60 and 2147483647. Default value is 60.').optional(),
      value: z.string().describe('An MX record specifying the mail server responsible for accepting messages on behalf of the domain name.'),
      mxPriority: z.number().min(0).max(65535),
      comment: z.string().max(500).describe('A comment to add context on what this DNS record is for').optional(),
    })
    .and(
      z.object({
        type: z
          .enum(['A', 'AAAA', 'ALIAS', 'CAA', 'CNAME', 'HTTPS', 'MX', 'NS', 'SRV', 'TXT'])
          .describe('The type of record, it could be one of the valid DNS records.'),
      }),
    ),
  z
    .object({
      name: z.string().describe('A subdomain name or an empty string for the root domain.'),
      type: z.enum(['SRV']).describe('Must be of type `SRV`.'),
      ttl: z.number().min(60).max(2147483647).describe('The TTL value. Must be a number between 60 and 2147483647. Default value is 60.').optional(),
      srv: z.object({
        priority: z.union([z.number(), z.null()]),
        weight: z.union([z.number(), z.null()]),
        port: z.union([z.number(), z.null()]),
        target: z.string(),
      }),
      comment: z.string().max(500).describe('A comment to add context on what this DNS record is for').optional(),
    })
    .and(
      z.object({
        type: z
          .enum(['A', 'AAAA', 'ALIAS', 'CAA', 'CNAME', 'HTTPS', 'MX', 'NS', 'SRV', 'TXT'])
          .describe('The type of record, it could be one of the valid DNS records.'),
      }),
    ),
  z
    .object({
      name: z.string().describe('A subdomain name or an empty string for the root domain.'),
      type: z.enum(['TXT']).describe('Must be of type `TXT`.'),
      ttl: z.number().min(60).max(2147483647).describe('The TTL value. Must be a number between 60 and 2147483647. Default value is 60.').optional(),
      value: z.string().describe('A TXT record containing arbitrary text.'),
      comment: z.string().max(500).describe('A comment to add context on what this DNS record is for').optional(),
    })
    .and(
      z.object({
        type: z
          .enum(['A', 'AAAA', 'ALIAS', 'CAA', 'CNAME', 'HTTPS', 'MX', 'NS', 'SRV', 'TXT'])
          .describe('The type of record, it could be one of the valid DNS records.'),
      }),
    ),
  z
    .object({
      name: z.string().describe('A subdomain name.'),
      type: z.enum(['NS']).describe('Must be of type `NS`.'),
      ttl: z.number().min(60).max(2147483647).describe('The TTL value. Must be a number between 60 and 2147483647. Default value is 60.').optional(),
      value: z.string().describe('An NS domain value.').optional(),
      comment: z.string().max(500).describe('A comment to add context on what this DNS record is for').optional(),
    })
    .and(
      z.object({
        type: z
          .enum(['A', 'AAAA', 'ALIAS', 'CAA', 'CNAME', 'HTTPS', 'MX', 'NS', 'SRV', 'TXT'])
          .describe('The type of record, it could be one of the valid DNS records.'),
      }),
    ),
  z
    .object({
      name: z.string().describe('A subdomain name or an empty string for the root domain.'),
      type: z.enum(['HTTPS']).describe('Must be of type `HTTPS`.'),
      ttl: z.number().min(60).max(2147483647).describe('The TTL value. Must be a number between 60 and 2147483647. Default value is 60.').optional(),
      https: z.object({
        priority: z.union([z.number(), z.null()]),
        target: z.string(),
        params: z.string().optional(),
      }),
      comment: z.string().max(500).describe('A comment to add context on what this DNS record is for').optional(),
    })
    .and(
      z.object({
        type: z
          .enum(['A', 'AAAA', 'ALIAS', 'CAA', 'CNAME', 'HTTPS', 'MX', 'NS', 'SRV', 'TXT'])
          .describe('The type of record, it could be one of the valid DNS records.'),
      }),
    ),
]) as unknown as ToZod<CreateRecordMutationRequest>

export const createRecordMutationResponseSchema = z.lazy(() => createRecord200Schema) as unknown as ToZod<CreateRecordMutationResponse>

export const updateRecordPathParamsSchema = z.object({
  recordId: z.string().describe('The id of the DNS record'),
}) as unknown as ToZod<UpdateRecordPathParams>

export const updateRecordQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<UpdateRecordQueryParams>

export const updateRecord200Schema = z.object({
  createdAt: z.number().nullable().nullish(),
  creator: z.string(),
  domain: z.string(),
  id: z.string(),
  name: z.string(),
  recordType: z.enum(['A', 'AAAA', 'ALIAS', 'CAA', 'CNAME', 'HTTPS', 'MX', 'NS', 'SRV', 'TXT']),
  ttl: z.number().optional(),
  type: z.enum(['record', 'record-sys']),
  value: z.string(),
  comment: z.string().optional(),
}) as unknown as ToZod<UpdateRecord200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const updateRecord400Schema = z.unknown() as unknown as ToZod<UpdateRecord400>

export const updateRecord401Schema = z.unknown() as unknown as ToZod<UpdateRecord401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const updateRecord402Schema = z.unknown() as unknown as ToZod<UpdateRecord402>

/**
 * @description You do not have permission to access this resource.
 */
export const updateRecord403Schema = z.unknown() as unknown as ToZod<UpdateRecord403>

export const updateRecord404Schema = z.unknown() as unknown as ToZod<UpdateRecord404>

export const updateRecord409Schema = z.unknown() as unknown as ToZod<UpdateRecord409>

export const updateRecordMutationRequestSchema = z.object({
  additionalProperties: z.unknown().optional(),
  name: z.string().describe('The name of the DNS record').nullable().nullish(),
  value: z.string().describe('The value of the DNS record').nullable().nullish(),
  type: z.enum(['A', 'AAAA', 'ALIAS', 'CAA', 'CNAME', 'HTTPS', 'MX', 'NS', 'SRV', 'TXT']).describe('The type of the DNS record').nullable().nullish(),
  ttl: z.number().int().min(60).max(2147483647).describe('The Time to live (TTL) value of the DNS record').nullable().nullish(),
  mxPriority: z.number().int().describe('The MX priority value of the DNS record').nullable().nullish(),
  srv: z
    .object({
      target: z.string().max(255).nullable(),
      weight: z.number().int().nullable(),
      port: z.number().int().nullable(),
      priority: z.number().int().nullable(),
    })
    .nullable()
    .nullish(),
  https: z
    .object({
      priority: z.number().int().nullable(),
      target: z.string().max(255).nullable(),
      params: z.string().nullable().nullish(),
    })
    .nullable()
    .nullish(),
  comment: z.string().max(500).describe('A comment to add context on what this DNS record is for').optional(),
}) as unknown as ToZod<UpdateRecordMutationRequest>

export const updateRecordMutationResponseSchema = z.lazy(() => updateRecord200Schema) as unknown as ToZod<UpdateRecordMutationResponse>

export const removeRecordPathParamsSchema = z.object({
  domain: z.string(),
  recordId: z.string(),
}) as unknown as ToZod<RemoveRecordPathParams>

export const removeRecordQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<RemoveRecordQueryParams>

/**
 * @description Successful response by removing the specified DNS record.
 */
export const removeRecord200Schema = z.object({}) as unknown as ToZod<RemoveRecord200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const removeRecord400Schema = z.unknown() as unknown as ToZod<RemoveRecord400>

export const removeRecord401Schema = z.unknown() as unknown as ToZod<RemoveRecord401>

/**
 * @description You do not have permission to access this resource.
 */
export const removeRecord403Schema = z.unknown() as unknown as ToZod<RemoveRecord403>

export const removeRecord404Schema = z.unknown() as unknown as ToZod<RemoveRecord404>

export const removeRecordMutationResponseSchema = z.lazy(() => removeRecord200Schema) as unknown as ToZod<RemoveRecordMutationResponse>

export const getDomainTransferQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetDomainTransferQueryParams>

export const getDomainTransfer200Schema = z.object({
  transferable: z.boolean().describe('Whether or not the domain is transferable'),
  transferPolicy: z
    .enum(['charge-and-renew', 'new-term', 'no-change', 'no-charge-no-change', 'not-supported'])
    .describe(
      "The domain's transfer policy (depends on TLD requirements). `charge-and-renew`: transfer will charge for renewal and will renew the existing domain's registration. `no-charge-no-change`: transfer will have no change to registration period and does not require charge. `no-change`: transfer charge is required, but no change in registration period. `new-term`: transfer charge is required and a new registry term is set based on the transfer date. `not-supported`: transfers are not supported for this domain or TLD. `null`: This TLD is not supported by Vercel's Registrar.",
    )
    .nullable(),
  reason: z.string().describe('Description associated with transferable state.'),
  status: z
    .enum(['cancelled', 'completed', 'pending_admin', 'pending_owner', 'pending_registry', 'undef', 'unknown'])
    .describe(
      "The current state of an ongoing transfer. `pending_owner`: Awaiting approval by domain's admin contact (every transfer begins with this status). If approval is not given within five days, the transfer is cancelled. `pending_admin`: Waiting for approval by Vercel Registrar admin. `pending_registry`: Awaiting registry approval (the transfer completes after 7 days unless it is declined by the current registrar). `completed`: The transfer completed successfully. `cancelled`: The transfer was cancelled. `undef`: No transfer exists for this domain. `unknown`: This TLD is not supported by Vercel's Registrar.",
    ),
}) as unknown as ToZod<GetDomainTransfer200>

export const getDomainTransfer400Schema = z.unknown() as unknown as ToZod<GetDomainTransfer400>

export const getDomainTransfer401Schema = z.unknown() as unknown as ToZod<GetDomainTransfer401>

/**
 * @description You do not have permission to access this resource.
 */
export const getDomainTransfer403Schema = z.unknown() as unknown as ToZod<GetDomainTransfer403>

export const getDomainTransferQueryResponseSchema = z.lazy(() => getDomainTransfer200Schema) as unknown as ToZod<GetDomainTransferQueryResponse>

export const getDomainConfigPathParamsSchema = z.object({
  domain: z.string().describe('The name of the domain.'),
}) as unknown as ToZod<GetDomainConfigPathParams>

export const getDomainConfigQueryParamsSchema = z
  .object({
    strict: z
      .enum(['true', 'false'])
      .describe(
        "When true, the response will only include the nameservers assigned directly to the specified domain. When false and there are no nameservers assigned directly to the specified domain, the response will include the nameservers of the domain's parent zone.",
      )
      .optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetDomainConfigQueryParams>

export const getDomainConfig200Schema = z.object({
  configuredBy: z
    .enum(['A', 'CNAME', 'dns-01', 'http'])
    .describe(
      "How we see the domain's configuration. - `CNAME`: Domain has a CNAME pointing to Vercel. - `A`: Domain's A record is resolving to Vercel. - `http`: Domain is resolving to Vercel but may be behind a Proxy. - `dns-01`: Domain is not resolving to Vercel but dns-01 challenge is enabled. - `null`: Domain is not resolving to Vercel.",
    )
    .nullable()
    .nullish(),
  acceptedChallenges: z
    .array(z.enum(['dns-01', 'http-01']).describe('Which challenge types the domain can use for issuing certs.'))
    .describe('Which challenge types the domain can use for issuing certs.')
    .optional(),
  misconfigured: z.boolean().describe('Whether or not the domain is configured AND we can automatically generate a TLS certificate.'),
}) as unknown as ToZod<GetDomainConfig200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getDomainConfig400Schema = z.unknown() as unknown as ToZod<GetDomainConfig400>

export const getDomainConfig401Schema = z.unknown() as unknown as ToZod<GetDomainConfig401>

/**
 * @description You do not have permission to access this resource.
 */
export const getDomainConfig403Schema = z.unknown() as unknown as ToZod<GetDomainConfig403>

export const getDomainConfig500Schema = z.unknown() as unknown as ToZod<GetDomainConfig500>

export const getDomainConfigQueryResponseSchema = z.lazy(() => getDomainConfig200Schema) as unknown as ToZod<GetDomainConfigQueryResponse>

export const getDomainPathParamsSchema = z.object({
  domain: z.string().describe('The name of the domain.'),
}) as unknown as ToZod<GetDomainPathParams>

export const getDomainQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetDomainQueryParams>

/**
 * @description Successful response retrieving an information for a specific domains.
 */
export const getDomain200Schema = z.object({
  domain: z.object({
    suffix: z.boolean(),
    verified: z.boolean().describe('If the domain has the ownership verified.'),
    nameservers: z.array(z.string()).describe('A list of the current nameservers of the domain.'),
    intendedNameservers: z.array(z.string()).describe('A list of the intended nameservers for the domain to point to Vercel DNS.'),
    customNameservers: z
      .array(z.string())
      .describe('A list of custom nameservers for the domain to point to. Only applies to domains purchased with Vercel.')
      .optional(),
    creator: z
      .object({
        username: z.string(),
        email: z.string(),
        customerId: z.string().nullable().nullish(),
        isDomainReseller: z.boolean().optional(),
        id: z.string(),
      })
      .describe("An object containing information of the domain creator, including the user's id, username, and email."),
    teamId: z.string().nullable(),
    boughtAt: z.number().describe('If it was purchased through Vercel, the timestamp in milliseconds when it was purchased.').nullable(),
    name: z.string().describe('The domain name.'),
    createdAt: z.number().describe('Timestamp in milliseconds when the domain was created in the registry.'),
    expiresAt: z.number().describe('Timestamp in milliseconds at which the domain is set to expire. `null` if not bought with Vercel.').nullable(),
    id: z.string().describe('The unique identifier of the domain.'),
    orderedAt: z.number().describe('Timestamp in milliseconds at which the domain was ordered.').optional(),
    renew: z.boolean().describe('Indicates whether the domain is set to automatically renew.').optional(),
    serviceType: z
      .enum(['external', 'na', 'zeit.world'])
      .describe(
        'The type of service the domain is handled by. `external` if the DNS is externally handled, `zeit.world` if handled with Vercel, or `na` if the service is not available.',
      ),
    transferredAt: z
      .number()
      .describe(
        'Timestamp in milliseconds at which the domain was successfully transferred into Vercel. `null` if the transfer is still processing or was never transferred in.',
      )
      .nullable()
      .nullish(),
    transferStartedAt: z.number().describe('If transferred into Vercel, timestamp in milliseconds when the domain transfer was initiated.').optional(),
    userId: z.string(),
  }),
}) as unknown as ToZod<GetDomain200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getDomain400Schema = z.unknown() as unknown as ToZod<GetDomain400>

export const getDomain401Schema = z.unknown() as unknown as ToZod<GetDomain401>

/**
 * @description You do not have permission to access this resource.
 */
export const getDomain403Schema = z.unknown() as unknown as ToZod<GetDomain403>

export const getDomain404Schema = z.unknown() as unknown as ToZod<GetDomain404>

export const getDomainQueryResponseSchema = z.lazy(() => getDomain200Schema) as unknown as ToZod<GetDomainQueryResponse>

export const getDomainsQueryParamsSchema = z
  .object({
    limit: z.coerce.number().describe('Maximum number of domains to list from a request.').optional(),
    since: z.coerce.number().describe('Get domains created after this JavaScript timestamp.').optional(),
    until: z.coerce.number().describe('Get domains created before this JavaScript timestamp.').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetDomainsQueryParams>

/**
 * @description Successful response retrieving a list of domains.
 */
export const getDomains200Schema = z.object({
  domains: z.array(
    z.object({
      verified: z.boolean().describe('If the domain has the ownership verified.'),
      nameservers: z.array(z.string()).describe('A list of the current nameservers of the domain.'),
      intendedNameservers: z.array(z.string()).describe('A list of the intended nameservers for the domain to point to Vercel DNS.'),
      customNameservers: z
        .array(z.string())
        .describe('A list of custom nameservers for the domain to point to. Only applies to domains purchased with Vercel.')
        .optional(),
      creator: z
        .object({
          username: z.string(),
          email: z.string(),
          customerId: z.string().nullable().nullish(),
          isDomainReseller: z.boolean().optional(),
          id: z.string(),
        })
        .describe("An object containing information of the domain creator, including the user's id, username, and email."),
      teamId: z.string().nullable(),
      createdAt: z.number().describe('Timestamp in milliseconds when the domain was created in the registry.'),
      boughtAt: z.number().describe('If it was purchased through Vercel, the timestamp in milliseconds when it was purchased.').nullable(),
      expiresAt: z.number().describe('Timestamp in milliseconds at which the domain is set to expire. `null` if not bought with Vercel.').nullable(),
      id: z.string().describe('The unique identifier of the domain.'),
      name: z.string().describe('The domain name.'),
      orderedAt: z.number().describe('Timestamp in milliseconds at which the domain was ordered.').optional(),
      renew: z.boolean().describe('Indicates whether the domain is set to automatically renew.').optional(),
      serviceType: z
        .enum(['external', 'na', 'zeit.world'])
        .describe(
          'The type of service the domain is handled by. `external` if the DNS is externally handled, `zeit.world` if handled with Vercel, or `na` if the service is not available.',
        ),
      transferredAt: z
        .number()
        .describe(
          'Timestamp in milliseconds at which the domain was successfully transferred into Vercel. `null` if the transfer is still processing or was never transferred in.',
        )
        .nullable()
        .nullish(),
      transferStartedAt: z.number().describe('If transferred into Vercel, timestamp in milliseconds when the domain transfer was initiated.').optional(),
      userId: z.string(),
    }),
  ),
  pagination: z
    .lazy(() => paginationSchema)
    .describe(
      'This object contains information related to the pagination of the current request, including the necessary parameters to get the next or previous page of data.',
    ),
}) as unknown as ToZod<GetDomains200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getDomains400Schema = z.unknown() as unknown as ToZod<GetDomains400>

export const getDomains401Schema = z.unknown() as unknown as ToZod<GetDomains401>

/**
 * @description You do not have permission to access this resource.
 */
export const getDomains403Schema = z.unknown() as unknown as ToZod<GetDomains403>

export const getDomains409Schema = z.unknown() as unknown as ToZod<GetDomains409>

export const getDomainsQueryResponseSchema = z.lazy(() => getDomains200Schema) as unknown as ToZod<GetDomainsQueryResponse>

export const createOrTransferDomainQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<CreateOrTransferDomainQueryParams>

export const createOrTransferDomain200Schema = z.object({
  domain: z.object({
    verified: z.boolean().describe('If the domain has the ownership verified.'),
    nameservers: z.array(z.string()).describe('A list of the current nameservers of the domain.'),
    intendedNameservers: z.array(z.string()).describe('A list of the intended nameservers for the domain to point to Vercel DNS.'),
    customNameservers: z
      .array(z.string())
      .describe('A list of custom nameservers for the domain to point to. Only applies to domains purchased with Vercel.')
      .optional(),
    creator: z
      .object({
        username: z.string(),
        email: z.string(),
        customerId: z.string().nullable().nullish(),
        isDomainReseller: z.boolean().optional(),
        id: z.string(),
      })
      .describe("An object containing information of the domain creator, including the user's id, username, and email."),
    name: z.string().describe('The domain name.'),
    boughtAt: z.number().describe('If it was purchased through Vercel, the timestamp in milliseconds when it was purchased.').nullable(),
    createdAt: z.number().describe('Timestamp in milliseconds when the domain was created in the registry.'),
    expiresAt: z.number().describe('Timestamp in milliseconds at which the domain is set to expire. `null` if not bought with Vercel.').nullable(),
    id: z.string().describe('The unique identifier of the domain.'),
    orderedAt: z.number().describe('Timestamp in milliseconds at which the domain was ordered.').optional(),
    renew: z.boolean().describe('Indicates whether the domain is set to automatically renew.').optional(),
    serviceType: z
      .enum(['external', 'na', 'zeit.world'])
      .describe(
        'The type of service the domain is handled by. `external` if the DNS is externally handled, `zeit.world` if handled with Vercel, or `na` if the service is not available.',
      ),
    transferredAt: z
      .number()
      .describe(
        'Timestamp in milliseconds at which the domain was successfully transferred into Vercel. `null` if the transfer is still processing or was never transferred in.',
      )
      .nullable()
      .nullish(),
    transferStartedAt: z.number().describe('If transferred into Vercel, timestamp in milliseconds when the domain transfer was initiated.').optional(),
    userId: z.string(),
    teamId: z.string().nullable(),
  }),
}) as unknown as ToZod<CreateOrTransferDomain200>

/**
 * @description One of the provided values in the request body is invalid.
 */
export const createOrTransferDomain400Schema = z.unknown() as unknown as ToZod<CreateOrTransferDomain400>

export const createOrTransferDomain401Schema = z.unknown() as unknown as ToZod<CreateOrTransferDomain401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const createOrTransferDomain402Schema = z.unknown() as unknown as ToZod<CreateOrTransferDomain402>

/**
 * @description You do not have permission to access this resource.
 */
export const createOrTransferDomain403Schema = z.unknown() as unknown as ToZod<CreateOrTransferDomain403>

export const createOrTransferDomain404Schema = z.unknown() as unknown as ToZod<CreateOrTransferDomain404>

/**
 * @description The domain is not allowed to be used
 */
export const createOrTransferDomain409Schema = z.unknown() as unknown as ToZod<CreateOrTransferDomain409>

export const createOrTransferDomain500Schema = z.unknown() as unknown as ToZod<CreateOrTransferDomain500>

export const createOrTransferDomainMutationRequestSchema = z.union([
  z
    .object({
      name: z.string().describe('The domain name you want to add.'),
      cdnEnabled: z.boolean().describe('Whether the domain has the Vercel Edge Network enabled or not.').optional(),
      zone: z.boolean().optional(),
      method: z.string().describe('The domain operation to perform.').optional(),
    })
    .and(
      z.object({
        method: z.string().describe('The domain operation to perform. It can be either `add` or `transfer-in`.').optional(),
      }),
    ),
  z
    .object({
      name: z.string().describe('The domain name you want to add.'),
      method: z.string().describe('The domain operation to perform.'),
      token: z.string().describe('The move-in token from Move Requested email.').optional(),
    })
    .and(
      z.object({
        method: z.string().describe('The domain operation to perform. It can be either `add` or `transfer-in`.').optional(),
      }),
    ),
  z
    .object({
      name: z.string().describe('The domain name you want to add.'),
      method: z.string().describe('The domain operation to perform.'),
      authCode: z.string().describe('The authorization code assigned to the domain.').optional(),
      expectedPrice: z.number().describe('The price you expect to be charged for the required 1 year renewal.').optional(),
    })
    .and(
      z.object({
        method: z.string().describe('The domain operation to perform. It can be either `add` or `transfer-in`.').optional(),
      }),
    ),
]) as unknown as ToZod<CreateOrTransferDomainMutationRequest>

export const createOrTransferDomainMutationResponseSchema = z.lazy(
  () => createOrTransferDomain200Schema,
) as unknown as ToZod<CreateOrTransferDomainMutationResponse>

export const patchDomainPathParamsSchema = z
  .object({
    domain: z.string().optional(),
  })
  .optional() as unknown as ToZod<PatchDomainPathParams>

export const patchDomainQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<PatchDomainQueryParams>

export const patchDomain200Schema = z.union([
  z.object({
    moved: z.boolean(),
  }),
  z.object({
    moved: z.boolean(),
    token: z.string(),
  }),
  z.object({
    renew: z.boolean().optional(),
    customNameservers: z.array(z.string()).optional(),
    zone: z.boolean().optional(),
  }),
]) as unknown as ToZod<PatchDomain200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const patchDomain400Schema = z.unknown() as unknown as ToZod<PatchDomain400>

export const patchDomain401Schema = z.unknown() as unknown as ToZod<PatchDomain401>

/**
 * @description You do not have permission to access this resource.
 */
export const patchDomain403Schema = z.unknown() as unknown as ToZod<PatchDomain403>

export const patchDomain404Schema = z.unknown() as unknown as ToZod<PatchDomain404>

export const patchDomain409Schema = z.unknown() as unknown as ToZod<PatchDomain409>

export const patchDomainMutationRequestSchema = z.union([
  z.object({
    op: z.string().optional(),
    renew: z.boolean().describe('Specifies whether domain should be renewed.').optional(),
    customNameservers: z
      .array(z.string())
      .min(0)
      .max(4)
      .refine((items) => new Set(items).size === items.length, { message: 'Array entries must be unique' })
      .describe('The custom nameservers for this project.')
      .optional(),
    zone: z.boolean().describe("Specifies whether this is a DNS zone that intends to use Vercel's nameservers.").optional(),
  }),
  z.object({
    op: z.string().optional(),
    destination: z.string().describe('User or team to move domain to').optional(),
  }),
]) as unknown as ToZod<PatchDomainMutationRequest>

export const patchDomainMutationResponseSchema = z.lazy(() => patchDomain200Schema) as unknown as ToZod<PatchDomainMutationResponse>

export const deleteDomainPathParamsSchema = z.object({
  domain: z.string().describe('The name of the domain.'),
}) as unknown as ToZod<DeleteDomainPathParams>

export const deleteDomainQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<DeleteDomainQueryParams>

/**
 * @description Successful response removing a domain.
 */
export const deleteDomain200Schema = z.object({
  uid: z.string(),
}) as unknown as ToZod<DeleteDomain200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const deleteDomain400Schema = z.unknown() as unknown as ToZod<DeleteDomain400>

export const deleteDomain401Schema = z.unknown() as unknown as ToZod<DeleteDomain401>

/**
 * @description You do not have permission to access this resource.
 */
export const deleteDomain403Schema = z.unknown() as unknown as ToZod<DeleteDomain403>

export const deleteDomain404Schema = z.unknown() as unknown as ToZod<DeleteDomain404>

export const deleteDomain409Schema = z.unknown() as unknown as ToZod<DeleteDomain409>

export const deleteDomainMutationResponseSchema = z.lazy(() => deleteDomain200Schema) as unknown as ToZod<DeleteDomainMutationResponse>

export const getEdgeConfigsQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetEdgeConfigsQueryParams>

/**
 * @description List of all edge configs.
 */
export const getEdgeConfigs200Schema = z
  .object({
    id: z.string().optional(),
    createdAt: z.number().optional(),
    ownerId: z.string().optional(),
    slug: z
      .string()
      .describe(
        'Name for the Edge Config Names are not unique. Must start with an alphabetic character and can contain only alphanumeric characters and underscores).',
      )
      .optional(),
    updatedAt: z.number().optional(),
    digest: z.string().optional(),
    transfer: z
      .object({
        fromAccountId: z.string(),
        startedAt: z.number(),
        doneAt: z.number().nullable(),
      })
      .describe('Keeps track of the current state of the Edge Config while it gets transferred.')
      .optional(),
    schema: z.object({}).optional(),
    purpose: z
      .union([
        z.object({
          type: z.enum(['flags']),
          projectId: z.string(),
        }),
        z.object({
          type: z.enum(['experimentation']),
          resourceId: z.string(),
        }),
      ])
      .optional(),
    sizeInBytes: z.number(),
    itemCount: z.number(),
  })
  .describe('List of all edge configs.') as unknown as ToZod<GetEdgeConfigs200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getEdgeConfigs400Schema = z.unknown() as unknown as ToZod<GetEdgeConfigs400>

export const getEdgeConfigs401Schema = z.unknown() as unknown as ToZod<GetEdgeConfigs401>

/**
 * @description You do not have permission to access this resource.
 */
export const getEdgeConfigs403Schema = z.unknown() as unknown as ToZod<GetEdgeConfigs403>

export const getEdgeConfigsQueryResponseSchema = z.lazy(() => getEdgeConfigs200Schema) as unknown as ToZod<GetEdgeConfigsQueryResponse>

export const createEdgeConfigQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<CreateEdgeConfigQueryParams>

export const createEdgeConfig201Schema = z
  .object({
    createdAt: z.number().optional(),
    updatedAt: z.number().optional(),
    id: z.string().optional(),
    slug: z
      .string()
      .describe(
        'Name for the Edge Config Names are not unique. Must start with an alphabetic character and can contain only alphanumeric characters and underscores).',
      )
      .optional(),
    ownerId: z.string().optional(),
    digest: z.string().optional(),
    transfer: z
      .object({
        fromAccountId: z.string(),
        startedAt: z.number(),
        doneAt: z.number().nullable(),
      })
      .describe('Keeps track of the current state of the Edge Config while it gets transferred.')
      .optional(),
    schema: z.object({}).optional(),
    purpose: z
      .union([
        z.object({
          type: z.enum(['flags']),
          projectId: z.string(),
        }),
        z.object({
          type: z.enum(['experimentation']),
          resourceId: z.string(),
        }),
      ])
      .optional(),
    sizeInBytes: z.number(),
    itemCount: z.number(),
  })
  .describe('An Edge Config') as unknown as ToZod<CreateEdgeConfig201>

/**
 * @description One of the provided values in the request body is invalid.
 */
export const createEdgeConfig400Schema = z.unknown() as unknown as ToZod<CreateEdgeConfig400>

export const createEdgeConfig401Schema = z.unknown() as unknown as ToZod<CreateEdgeConfig401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const createEdgeConfig402Schema = z.unknown() as unknown as ToZod<CreateEdgeConfig402>

/**
 * @description You do not have permission to access this resource.
 */
export const createEdgeConfig403Schema = z.unknown() as unknown as ToZod<CreateEdgeConfig403>

export const createEdgeConfigMutationRequestSchema = z.object({
  slug: z
    .string()
    .regex(/^[\\w-]+$/)
    .max(64),
  items: z.object({}).catchall(z.unknown()).optional(),
}) as unknown as ToZod<CreateEdgeConfigMutationRequest>

export const createEdgeConfigMutationResponseSchema = z.lazy(() => createEdgeConfig201Schema) as unknown as ToZod<CreateEdgeConfigMutationResponse>

export const getEdgeConfigPathParamsSchema = z.object({
  edgeConfigId: z.string(),
}) as unknown as ToZod<GetEdgeConfigPathParams>

export const getEdgeConfigQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetEdgeConfigQueryParams>

/**
 * @description The EdgeConfig.
 */
export const getEdgeConfig200Schema = z
  .object({
    createdAt: z.number().optional(),
    updatedAt: z.number().optional(),
    id: z.string().optional(),
    slug: z
      .string()
      .describe(
        'Name for the Edge Config Names are not unique. Must start with an alphabetic character and can contain only alphanumeric characters and underscores).',
      )
      .optional(),
    ownerId: z.string().optional(),
    digest: z.string().optional(),
    transfer: z
      .object({
        fromAccountId: z.string(),
        startedAt: z.number(),
        doneAt: z.number().nullable(),
      })
      .describe('Keeps track of the current state of the Edge Config while it gets transferred.')
      .optional(),
    schema: z.object({}).optional(),
    purpose: z
      .union([
        z.object({
          type: z.enum(['flags']),
          projectId: z.string(),
        }),
        z.object({
          type: z.enum(['experimentation']),
          resourceId: z.string(),
        }),
      ])
      .optional(),
    sizeInBytes: z.number(),
    itemCount: z.number(),
  })
  .describe('The EdgeConfig.') as unknown as ToZod<GetEdgeConfig200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getEdgeConfig400Schema = z.unknown() as unknown as ToZod<GetEdgeConfig400>

export const getEdgeConfig401Schema = z.unknown() as unknown as ToZod<GetEdgeConfig401>

/**
 * @description You do not have permission to access this resource.
 */
export const getEdgeConfig403Schema = z.unknown() as unknown as ToZod<GetEdgeConfig403>

export const getEdgeConfig404Schema = z.unknown() as unknown as ToZod<GetEdgeConfig404>

export const getEdgeConfigQueryResponseSchema = z.lazy(() => getEdgeConfig200Schema) as unknown as ToZod<GetEdgeConfigQueryResponse>

export const updateEdgeConfigPathParamsSchema = z.object({
  edgeConfigId: z.string(),
}) as unknown as ToZod<UpdateEdgeConfigPathParams>

export const updateEdgeConfigQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<UpdateEdgeConfigQueryParams>

export const updateEdgeConfig200Schema = z
  .object({
    createdAt: z.number().optional(),
    updatedAt: z.number().optional(),
    id: z.string().optional(),
    slug: z
      .string()
      .describe(
        'Name for the Edge Config Names are not unique. Must start with an alphabetic character and can contain only alphanumeric characters and underscores).',
      )
      .optional(),
    ownerId: z.string().optional(),
    digest: z.string().optional(),
    transfer: z
      .object({
        fromAccountId: z.string(),
        startedAt: z.number(),
        doneAt: z.number().nullable(),
      })
      .describe('Keeps track of the current state of the Edge Config while it gets transferred.')
      .optional(),
    schema: z.object({}).optional(),
    purpose: z
      .union([
        z.object({
          type: z.enum(['flags']),
          projectId: z.string(),
        }),
        z.object({
          type: z.enum(['experimentation']),
          resourceId: z.string(),
        }),
      ])
      .optional(),
    sizeInBytes: z.number(),
    itemCount: z.number(),
  })
  .describe('An Edge Config') as unknown as ToZod<UpdateEdgeConfig200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const updateEdgeConfig400Schema = z.unknown() as unknown as ToZod<UpdateEdgeConfig400>

export const updateEdgeConfig401Schema = z.unknown() as unknown as ToZod<UpdateEdgeConfig401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const updateEdgeConfig402Schema = z.unknown() as unknown as ToZod<UpdateEdgeConfig402>

/**
 * @description You do not have permission to access this resource.
 */
export const updateEdgeConfig403Schema = z.unknown() as unknown as ToZod<UpdateEdgeConfig403>

export const updateEdgeConfig404Schema = z.unknown() as unknown as ToZod<UpdateEdgeConfig404>

export const updateEdgeConfigMutationRequestSchema = z.object({
  slug: z
    .string()
    .regex(/^[\\w-]+$/)
    .max(64),
}) as unknown as ToZod<UpdateEdgeConfigMutationRequest>

export const updateEdgeConfigMutationResponseSchema = z.lazy(() => updateEdgeConfig200Schema) as unknown as ToZod<UpdateEdgeConfigMutationResponse>

export const deleteEdgeConfigPathParamsSchema = z.object({
  edgeConfigId: z.string(),
}) as unknown as ToZod<DeleteEdgeConfigPathParams>

export const deleteEdgeConfigQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<DeleteEdgeConfigQueryParams>

export const deleteEdgeConfig204Schema = z.unknown() as unknown as ToZod<DeleteEdgeConfig204>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const deleteEdgeConfig400Schema = z.unknown() as unknown as ToZod<DeleteEdgeConfig400>

export const deleteEdgeConfig401Schema = z.unknown() as unknown as ToZod<DeleteEdgeConfig401>

/**
 * @description You do not have permission to access this resource.
 */
export const deleteEdgeConfig403Schema = z.unknown() as unknown as ToZod<DeleteEdgeConfig403>

export const deleteEdgeConfig404Schema = z.unknown() as unknown as ToZod<DeleteEdgeConfig404>

export const deleteEdgeConfigMutationResponseSchema = z.lazy(() => deleteEdgeConfig204Schema) as unknown as ToZod<DeleteEdgeConfigMutationResponse>

export const getEdgeConfigItemsPathParamsSchema = z.object({
  edgeConfigId: z.string().regex(/^ecfg_/),
}) as unknown as ToZod<GetEdgeConfigItemsPathParams>

export const getEdgeConfigItemsQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetEdgeConfigItemsQueryParams>

/**
 * @description List of all Edge Config items.
 */
export const getEdgeConfigItems200Schema = z.array(z.lazy(() => edgeConfigItemSchema).describe('The EdgeConfig.')) as unknown as ToZod<GetEdgeConfigItems200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getEdgeConfigItems400Schema = z.unknown() as unknown as ToZod<GetEdgeConfigItems400>

export const getEdgeConfigItems401Schema = z.unknown() as unknown as ToZod<GetEdgeConfigItems401>

/**
 * @description You do not have permission to access this resource.
 */
export const getEdgeConfigItems403Schema = z.unknown() as unknown as ToZod<GetEdgeConfigItems403>

export const getEdgeConfigItems404Schema = z.unknown() as unknown as ToZod<GetEdgeConfigItems404>

export const getEdgeConfigItemsQueryResponseSchema = z.lazy(() => getEdgeConfigItems200Schema) as unknown as ToZod<GetEdgeConfigItemsQueryResponse>

export const patchEdgeConfigItemsPathParamsSchema = z.object({
  edgeConfigId: z.string().regex(/^ecfg_/),
}) as unknown as ToZod<PatchEdgeConfigItemsPathParams>

export const patchEdgeConfigItemsQueryParamsSchema = z
  .object({
    dryRun: z.string().optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<PatchEdgeConfigItemsQueryParams>

export const patchEdgeConfigItems200Schema = z.object({
  status: z.string(),
}) as unknown as ToZod<PatchEdgeConfigItems200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const patchEdgeConfigItems400Schema = z.unknown() as unknown as ToZod<PatchEdgeConfigItems400>

export const patchEdgeConfigItems401Schema = z.unknown() as unknown as ToZod<PatchEdgeConfigItems401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const patchEdgeConfigItems402Schema = z.unknown() as unknown as ToZod<PatchEdgeConfigItems402>

/**
 * @description You do not have permission to access this resource.
 */
export const patchEdgeConfigItems403Schema = z.unknown() as unknown as ToZod<PatchEdgeConfigItems403>

export const patchEdgeConfigItems404Schema = z.unknown() as unknown as ToZod<PatchEdgeConfigItems404>

export const patchEdgeConfigItems409Schema = z.unknown() as unknown as ToZod<PatchEdgeConfigItems409>

export const patchEdgeConfigItemsMutationRequestSchema = z.object({
  items: z.array(
    z.union([
      z
        .object({
          operation: z.unknown(),
        })
        .and(
          z.object({
            operation: z.enum(['create', 'update', 'upsert', 'delete']).optional(),
            key: z
              .string()
              .regex(/^[\\w-]+$/)
              .max(256)
              .optional(),
            value: z.unknown().optional(),
            description: z.union([z.string(), z.null()]).optional(),
          }),
        ),
      z
        .object({
          operation: z.enum(['update', 'upsert']),
        })
        .and(
          z.object({
            operation: z.enum(['create', 'update', 'upsert', 'delete']).optional(),
            key: z
              .string()
              .regex(/^[\\w-]+$/)
              .max(256)
              .optional(),
            value: z.unknown().optional(),
            description: z.union([z.string(), z.null()]).optional(),
          }),
        ),
      z
        .object({
          operation: z.enum(['update', 'upsert']),
        })
        .and(
          z.object({
            operation: z.enum(['create', 'update', 'upsert', 'delete']).optional(),
            key: z
              .string()
              .regex(/^[\\w-]+$/)
              .max(256)
              .optional(),
            value: z.unknown().optional(),
            description: z.union([z.string(), z.null()]).optional(),
          }),
        ),
      z
        .object({
          operation: z.unknown(),
        })
        .and(
          z.object({
            operation: z.enum(['create', 'update', 'upsert', 'delete']).optional(),
            key: z
              .string()
              .regex(/^[\\w-]+$/)
              .max(256)
              .optional(),
            value: z.unknown().optional(),
            description: z.union([z.string(), z.null()]).optional(),
          }),
        ),
    ]),
  ),
  definition: z.unknown(),
}) as unknown as ToZod<PatchEdgeConfigItemsMutationRequest>

export const patchEdgeConfigItemsMutationResponseSchema = z.lazy(() => patchEdgeConfigItems200Schema) as unknown as ToZod<PatchEdgeConfigItemsMutationResponse>

export const getEdgeConfigSchemaPathParamsSchema = z.object({
  edgeConfigId: z.string(),
}) as unknown as ToZod<GetEdgeConfigSchemaPathParams>

export const getEdgeConfigSchemaQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetEdgeConfigSchemaQueryParams>

/**
 * @description The EdgeConfig.
 */
export const getEdgeConfigSchema200Schema = z.object({}).describe('The EdgeConfig.').nullable() as unknown as ToZod<GetEdgeConfigSchema200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getEdgeConfigSchema400Schema = z.unknown() as unknown as ToZod<GetEdgeConfigSchema400>

export const getEdgeConfigSchema401Schema = z.unknown() as unknown as ToZod<GetEdgeConfigSchema401>

/**
 * @description You do not have permission to access this resource.
 */
export const getEdgeConfigSchema403Schema = z.unknown() as unknown as ToZod<GetEdgeConfigSchema403>

export const getEdgeConfigSchema404Schema = z.unknown() as unknown as ToZod<GetEdgeConfigSchema404>

export const getEdgeConfigSchemaQueryResponseSchema = z.lazy(() => getEdgeConfigSchema200Schema) as unknown as ToZod<GetEdgeConfigSchemaQueryResponse>

export const patchEdgeConfigSchemaPathParamsSchema = z.object({
  edgeConfigId: z.string(),
}) as unknown as ToZod<PatchEdgeConfigSchemaPathParams>

export const patchEdgeConfigSchemaQueryParamsSchema = z
  .object({
    dryRun: z.string().optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<PatchEdgeConfigSchemaQueryParams>

export const patchEdgeConfigSchema200Schema = z
  .object({})
  .describe('The JSON schema uploaded by the user')
  .nullable() as unknown as ToZod<PatchEdgeConfigSchema200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const patchEdgeConfigSchema400Schema = z.unknown() as unknown as ToZod<PatchEdgeConfigSchema400>

export const patchEdgeConfigSchema401Schema = z.unknown() as unknown as ToZod<PatchEdgeConfigSchema401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const patchEdgeConfigSchema402Schema = z.unknown() as unknown as ToZod<PatchEdgeConfigSchema402>

/**
 * @description You do not have permission to access this resource.
 */
export const patchEdgeConfigSchema403Schema = z.unknown() as unknown as ToZod<PatchEdgeConfigSchema403>

export const patchEdgeConfigSchema404Schema = z.unknown() as unknown as ToZod<PatchEdgeConfigSchema404>

export const patchEdgeConfigSchemaMutationRequestSchema = z.object({
  definition: z.unknown(),
}) as unknown as ToZod<PatchEdgeConfigSchemaMutationRequest>

export const patchEdgeConfigSchemaMutationResponseSchema = z.lazy(
  () => patchEdgeConfigSchema200Schema,
) as unknown as ToZod<PatchEdgeConfigSchemaMutationResponse>

export const deleteEdgeConfigSchemaPathParamsSchema = z.object({
  edgeConfigId: z.string(),
}) as unknown as ToZod<DeleteEdgeConfigSchemaPathParams>

export const deleteEdgeConfigSchemaQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<DeleteEdgeConfigSchemaQueryParams>

export const deleteEdgeConfigSchema204Schema = z.unknown() as unknown as ToZod<DeleteEdgeConfigSchema204>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const deleteEdgeConfigSchema400Schema = z.unknown() as unknown as ToZod<DeleteEdgeConfigSchema400>

export const deleteEdgeConfigSchema401Schema = z.unknown() as unknown as ToZod<DeleteEdgeConfigSchema401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const deleteEdgeConfigSchema402Schema = z.unknown() as unknown as ToZod<DeleteEdgeConfigSchema402>

/**
 * @description You do not have permission to access this resource.
 */
export const deleteEdgeConfigSchema403Schema = z.unknown() as unknown as ToZod<DeleteEdgeConfigSchema403>

export const deleteEdgeConfigSchema404Schema = z.unknown() as unknown as ToZod<DeleteEdgeConfigSchema404>

export const deleteEdgeConfigSchemaMutationResponseSchema = z.lazy(
  () => deleteEdgeConfigSchema204Schema,
) as unknown as ToZod<DeleteEdgeConfigSchemaMutationResponse>

export const getEdgeConfigItemPathParamsSchema = z.object({
  edgeConfigId: z.string().regex(/^ecfg_/),
  edgeConfigItemKey: z.string(),
}) as unknown as ToZod<GetEdgeConfigItemPathParams>

export const getEdgeConfigItemQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetEdgeConfigItemQueryParams>

/**
 * @description The EdgeConfig.
 */
export const getEdgeConfigItem200Schema = z.lazy(() => edgeConfigItemSchema).describe('The EdgeConfig.') as unknown as ToZod<GetEdgeConfigItem200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getEdgeConfigItem400Schema = z.unknown() as unknown as ToZod<GetEdgeConfigItem400>

export const getEdgeConfigItem401Schema = z.unknown() as unknown as ToZod<GetEdgeConfigItem401>

/**
 * @description You do not have permission to access this resource.
 */
export const getEdgeConfigItem403Schema = z.unknown() as unknown as ToZod<GetEdgeConfigItem403>

export const getEdgeConfigItem404Schema = z.unknown() as unknown as ToZod<GetEdgeConfigItem404>

export const getEdgeConfigItemQueryResponseSchema = z.lazy(() => getEdgeConfigItem200Schema) as unknown as ToZod<GetEdgeConfigItemQueryResponse>

export const getEdgeConfigTokensPathParamsSchema = z.object({
  edgeConfigId: z.string(),
}) as unknown as ToZod<GetEdgeConfigTokensPathParams>

export const getEdgeConfigTokensQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetEdgeConfigTokensQueryParams>

/**
 * @description The EdgeConfig.
 */
export const getEdgeConfigTokens200Schema = z.lazy(() => edgeConfigTokenSchema).describe('The EdgeConfig.') as unknown as ToZod<GetEdgeConfigTokens200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getEdgeConfigTokens400Schema = z.unknown() as unknown as ToZod<GetEdgeConfigTokens400>

export const getEdgeConfigTokens401Schema = z.unknown() as unknown as ToZod<GetEdgeConfigTokens401>

/**
 * @description You do not have permission to access this resource.
 */
export const getEdgeConfigTokens403Schema = z.unknown() as unknown as ToZod<GetEdgeConfigTokens403>

export const getEdgeConfigTokens404Schema = z.unknown() as unknown as ToZod<GetEdgeConfigTokens404>

export const getEdgeConfigTokensQueryResponseSchema = z.lazy(() => getEdgeConfigTokens200Schema) as unknown as ToZod<GetEdgeConfigTokensQueryResponse>

export const deleteEdgeConfigTokensPathParamsSchema = z.object({
  edgeConfigId: z.string(),
}) as unknown as ToZod<DeleteEdgeConfigTokensPathParams>

export const deleteEdgeConfigTokensQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<DeleteEdgeConfigTokensQueryParams>

export const deleteEdgeConfigTokens204Schema = z.unknown() as unknown as ToZod<DeleteEdgeConfigTokens204>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const deleteEdgeConfigTokens400Schema = z.unknown() as unknown as ToZod<DeleteEdgeConfigTokens400>

export const deleteEdgeConfigTokens401Schema = z.unknown() as unknown as ToZod<DeleteEdgeConfigTokens401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const deleteEdgeConfigTokens402Schema = z.unknown() as unknown as ToZod<DeleteEdgeConfigTokens402>

/**
 * @description You do not have permission to access this resource.
 */
export const deleteEdgeConfigTokens403Schema = z.unknown() as unknown as ToZod<DeleteEdgeConfigTokens403>

export const deleteEdgeConfigTokens404Schema = z.unknown() as unknown as ToZod<DeleteEdgeConfigTokens404>

export const deleteEdgeConfigTokensMutationRequestSchema = z.object({
  tokens: z.array(z.string()),
}) as unknown as ToZod<DeleteEdgeConfigTokensMutationRequest>

export const deleteEdgeConfigTokensMutationResponseSchema = z.lazy(
  () => deleteEdgeConfigTokens204Schema,
) as unknown as ToZod<DeleteEdgeConfigTokensMutationResponse>

export const getEdgeConfigTokenPathParamsSchema = z.object({
  edgeConfigId: z.string(),
  token: z.string(),
}) as unknown as ToZod<GetEdgeConfigTokenPathParams>

export const getEdgeConfigTokenQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetEdgeConfigTokenQueryParams>

/**
 * @description The EdgeConfig.
 */
export const getEdgeConfigToken200Schema = z.lazy(() => edgeConfigTokenSchema).describe('The EdgeConfig.') as unknown as ToZod<GetEdgeConfigToken200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getEdgeConfigToken400Schema = z.unknown() as unknown as ToZod<GetEdgeConfigToken400>

export const getEdgeConfigToken401Schema = z.unknown() as unknown as ToZod<GetEdgeConfigToken401>

/**
 * @description You do not have permission to access this resource.
 */
export const getEdgeConfigToken403Schema = z.unknown() as unknown as ToZod<GetEdgeConfigToken403>

export const getEdgeConfigToken404Schema = z.unknown() as unknown as ToZod<GetEdgeConfigToken404>

export const getEdgeConfigTokenQueryResponseSchema = z.lazy(() => getEdgeConfigToken200Schema) as unknown as ToZod<GetEdgeConfigTokenQueryResponse>

export const createEdgeConfigTokenPathParamsSchema = z.object({
  edgeConfigId: z.string(),
}) as unknown as ToZod<CreateEdgeConfigTokenPathParams>

export const createEdgeConfigTokenQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<CreateEdgeConfigTokenQueryParams>

export const createEdgeConfigToken201Schema = z.object({
  token: z.string(),
  id: z.string(),
}) as unknown as ToZod<CreateEdgeConfigToken201>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const createEdgeConfigToken400Schema = z.unknown() as unknown as ToZod<CreateEdgeConfigToken400>

export const createEdgeConfigToken401Schema = z.unknown() as unknown as ToZod<CreateEdgeConfigToken401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const createEdgeConfigToken402Schema = z.unknown() as unknown as ToZod<CreateEdgeConfigToken402>

/**
 * @description You do not have permission to access this resource.
 */
export const createEdgeConfigToken403Schema = z.unknown() as unknown as ToZod<CreateEdgeConfigToken403>

export const createEdgeConfigToken404Schema = z.unknown() as unknown as ToZod<CreateEdgeConfigToken404>

export const createEdgeConfigTokenMutationRequestSchema = z.object({
  label: z.string().max(52),
}) as unknown as ToZod<CreateEdgeConfigTokenMutationRequest>

export const createEdgeConfigTokenMutationResponseSchema = z.lazy(
  () => createEdgeConfigToken201Schema,
) as unknown as ToZod<CreateEdgeConfigTokenMutationResponse>

export const getEdgeConfigBackupPathParamsSchema = z.object({
  edgeConfigId: z.string(),
  edgeConfigBackupVersionId: z.string(),
}) as unknown as ToZod<GetEdgeConfigBackupPathParams>

export const getEdgeConfigBackupQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetEdgeConfigBackupQueryParams>

export const getEdgeConfigBackup200Schema = z.union([
  z.object({
    id: z.string(),
    lastModified: z.number(),
    backup: z.object({
      digest: z.string(),
      items: z.object({}).catchall(
        z.object({
          updatedAt: z.number(),
          value: z.lazy(() => edgeConfigItemValueSchema).nullable(),
          description: z.string().optional(),
          createdAt: z.number(),
        }),
      ),
      slug: z
        .string()
        .describe(
          'Name for the Edge Config Names are not unique. Must start with an alphabetic character and can contain only alphanumeric characters and underscores).',
        ),
      updatedAt: z.number(),
    }),
    metadata: z.object({
      updatedAt: z.string().optional(),
      updatedBy: z.string().optional(),
      itemsCount: z.number().optional(),
      itemsBytes: z.number().optional(),
    }),
    user: z
      .object({
        id: z.string(),
        username: z.string(),
        email: z.string(),
        name: z.string().optional(),
        avatar: z.string().optional(),
      })
      .optional(),
  }),
  z.object({
    user: z.object({
      id: z.string(),
      username: z.string(),
      email: z.string(),
      name: z.string().optional(),
      avatar: z.string().optional(),
    }),
    id: z.string(),
    lastModified: z.number(),
    backup: z.object({
      digest: z.string(),
      items: z.object({}).catchall(
        z.object({
          updatedAt: z.number(),
          value: z.lazy(() => edgeConfigItemValueSchema).nullable(),
          description: z.string().optional(),
          createdAt: z.number(),
        }),
      ),
      slug: z
        .string()
        .describe(
          'Name for the Edge Config Names are not unique. Must start with an alphabetic character and can contain only alphanumeric characters and underscores).',
        ),
      updatedAt: z.number(),
    }),
    metadata: z.object({
      updatedAt: z.string().optional(),
      updatedBy: z.string().optional(),
      itemsCount: z.number().optional(),
      itemsBytes: z.number().optional(),
    }),
  }),
]) as unknown as ToZod<GetEdgeConfigBackup200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getEdgeConfigBackup400Schema = z.unknown() as unknown as ToZod<GetEdgeConfigBackup400>

export const getEdgeConfigBackup401Schema = z.unknown() as unknown as ToZod<GetEdgeConfigBackup401>

/**
 * @description You do not have permission to access this resource.
 */
export const getEdgeConfigBackup403Schema = z.unknown() as unknown as ToZod<GetEdgeConfigBackup403>

export const getEdgeConfigBackup404Schema = z.unknown() as unknown as ToZod<GetEdgeConfigBackup404>

export const getEdgeConfigBackupQueryResponseSchema = z.lazy(() => getEdgeConfigBackup200Schema) as unknown as ToZod<GetEdgeConfigBackupQueryResponse>

export const getEdgeConfigBackupsPathParamsSchema = z.object({
  edgeConfigId: z.string(),
}) as unknown as ToZod<GetEdgeConfigBackupsPathParams>

export const getEdgeConfigBackupsQueryParamsSchema = z
  .object({
    next: z.string().optional(),
    limit: z.coerce.number().min(0).max(50).optional(),
    metadata: z.string().optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetEdgeConfigBackupsQueryParams>

export const getEdgeConfigBackups200Schema = z.object({
  backups: z.array(
    z.object({
      metadata: z
        .object({
          updatedAt: z.string().optional(),
          updatedBy: z.string().optional(),
          itemsCount: z.number().optional(),
          itemsBytes: z.number().optional(),
        })
        .optional(),
      id: z.string(),
      lastModified: z.number(),
    }),
  ),
  pagination: z.object({
    hasNext: z.boolean(),
    next: z.string().optional(),
  }),
}) as unknown as ToZod<GetEdgeConfigBackups200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getEdgeConfigBackups400Schema = z.unknown() as unknown as ToZod<GetEdgeConfigBackups400>

export const getEdgeConfigBackups401Schema = z.unknown() as unknown as ToZod<GetEdgeConfigBackups401>

/**
 * @description You do not have permission to access this resource.
 */
export const getEdgeConfigBackups403Schema = z.unknown() as unknown as ToZod<GetEdgeConfigBackups403>

export const getEdgeConfigBackups404Schema = z.unknown() as unknown as ToZod<GetEdgeConfigBackups404>

export const getEdgeConfigBackupsQueryResponseSchema = z.lazy(() => getEdgeConfigBackups200Schema) as unknown as ToZod<GetEdgeConfigBackupsQueryResponse>

export const listUserEventsQueryParamsSchema = z
  .object({
    limit: z.coerce.number().describe('Maximum number of items which may be returned.').optional(),
    since: z.string().describe('Timestamp to only include items created since then.').optional(),
    until: z.string().describe('Timestamp to only include items created until then.').optional(),
    types: z.string().describe('Comma-delimited list of event \\"types\\" to filter the results by.').optional(),
    userId: z.string().describe('Deprecated. Use `principalId` instead. If `principalId` and `userId` both exist, `principalId` will be used.').optional(),
    principalId: z
      .string()
      .describe('When retrieving events for a Team, the `principalId` parameter may be specified to filter events generated by a specific principal.')
      .optional(),
    projectIds: z.string().describe('Comma-delimited list of project IDs to filter the results by.').optional(),
    withPayload: z.string().describe('When set to `true`, the response will include the `payload` field for each event.').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<ListUserEventsQueryParams>

/**
 * @description Successful response.
 */
export const listUserEvents200Schema = z
  .object({
    events: z.array(z.lazy(() => userEventSchema).describe('Array of events generated by the User.')).describe('Array of events generated by the User.'),
  })
  .describe('Successful response.') as unknown as ToZod<ListUserEvents200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const listUserEvents400Schema = z.unknown() as unknown as ToZod<ListUserEvents400>

export const listUserEvents401Schema = z.unknown() as unknown as ToZod<ListUserEvents401>

/**
 * @description You do not have permission to access this resource.
 */
export const listUserEvents403Schema = z.unknown() as unknown as ToZod<ListUserEvents403>

export const listUserEventsQueryResponseSchema = z.lazy(() => listUserEvents200Schema) as unknown as ToZod<ListUserEventsQueryResponse>

export const getAccountInfoPathParamsSchema = z.object({
  integrationConfigurationId: z.string(),
}) as unknown as ToZod<GetAccountInfoPathParams>

export const getAccountInfo200Schema = z.object({
  name: z.string().describe('The name of the team the installation is tied to.').optional(),
  url: z.string().describe('A URL linking to the installation in the Vercel Dashboard.'),
  contact: z
    .object({
      email: z.string(),
      name: z.string().optional(),
    })
    .describe('The best contact for the integration, which can change as team members and their roles change.')
    .nullable(),
}) as unknown as ToZod<GetAccountInfo200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getAccountInfo400Schema = z.unknown() as unknown as ToZod<GetAccountInfo400>

export const getAccountInfo401Schema = z.unknown() as unknown as ToZod<GetAccountInfo401>

/**
 * @description You do not have permission to access this resource.
 */
export const getAccountInfo403Schema = z.unknown() as unknown as ToZod<GetAccountInfo403>

export const getAccountInfo404Schema = z.unknown() as unknown as ToZod<GetAccountInfo404>

export const getAccountInfoQueryResponseSchema = z.lazy(() => getAccountInfo200Schema) as unknown as ToZod<GetAccountInfoQueryResponse>

export const getMemberPathParamsSchema = z.object({
  integrationConfigurationId: z.string(),
  memberId: z.string(),
}) as unknown as ToZod<GetMemberPathParams>

export const getMember200Schema = z.object({
  id: z.string(),
  role: z
    .enum(['ADMIN', 'USER'])
    .describe(
      'The `ADMIN` role, by default, is provided to users capable of installing integrations, while the `USER` role can be granted to Vercel users with the Vercel `Billing` or Vercel `Viewer` role, which are considered to be Read-Only roles.',
    ),
}) as unknown as ToZod<GetMember200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getMember400Schema = z.unknown() as unknown as ToZod<GetMember400>

export const getMember401Schema = z.unknown() as unknown as ToZod<GetMember401>

/**
 * @description You do not have permission to access this resource.
 */
export const getMember403Schema = z.unknown() as unknown as ToZod<GetMember403>

export const getMember404Schema = z.unknown() as unknown as ToZod<GetMember404>

export const getMemberQueryResponseSchema = z.lazy(() => getMember200Schema) as unknown as ToZod<GetMemberQueryResponse>

export const createEventPathParamsSchema = z.object({
  integrationConfigurationId: z.string(),
}) as unknown as ToZod<CreateEventPathParams>

export const createEvent201Schema = z.unknown() as unknown as ToZod<CreateEvent201>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const createEvent400Schema = z.unknown() as unknown as ToZod<CreateEvent400>

export const createEvent401Schema = z.unknown() as unknown as ToZod<CreateEvent401>

/**
 * @description You do not have permission to access this resource.
 */
export const createEvent403Schema = z.unknown() as unknown as ToZod<CreateEvent403>

export const createEvent404Schema = z.unknown() as unknown as ToZod<CreateEvent404>

export const createEventMutationRequestSchema = z.object({
  event: z.union([
    z.object({
      type: z.enum(['installation.updated']),
      billingPlanId: z.string().describe('The installation-level billing plan ID').optional(),
    }),
    z.object({
      type: z.enum(['resource.updated']),
      productId: z.string().describe('Partner-provided product slug or id'),
      resourceId: z.string().describe('Partner provided resource ID'),
    }),
  ]),
}) as unknown as ToZod<CreateEventMutationRequest>

export const createEventMutationResponseSchema = z.lazy(() => createEvent201Schema) as unknown as ToZod<CreateEventMutationResponse>

export const getIntegrationResourcesPathParamsSchema = z.object({
  integrationConfigurationId: z.string(),
}) as unknown as ToZod<GetIntegrationResourcesPathParams>

export const getIntegrationResources200Schema = z.object({
  resources: z.array(
    z.object({
      partnerId: z.string().describe('The ID provided by the partner for the given resource'),
      internalId: z.string().describe('The ID assigned by Vercel for the given resource'),
      name: z.string().describe('The name of the resource as it is recorded in Vercel'),
      status: z.enum(['error', 'pending', 'ready', 'resumed', 'suspended', 'uninstalled']).describe('The current status of the resource').optional(),
      productId: z.string().describe('The ID of the product the resource is derived from'),
      protocolSettings: z
        .object({
          experimentation: z
            .object({
              edgeConfigSyncingEnabled: z.boolean().optional(),
              edgeConfigId: z.string().optional(),
              edgeConfigTokenId: z.string().optional(),
            })
            .optional(),
        })
        .describe("Any settings provided for the resource to support its product's protocols")
        .optional(),
      notification: z
        .object({
          level: z.enum(['error', 'info', 'warn']),
          title: z.string(),
          message: z.string().optional(),
          href: z.string().optional(),
        })
        .describe('The notification, if set, displayed to the user when viewing the resource in Vercel')
        .optional(),
      billingPlanId: z.string().describe('The ID of the billing plan the resource is subscribed to, if applicable').optional(),
      metadata: z
        .object({})
        .catchall(z.union([z.boolean(), z.array(z.string()), z.array(z.number()), z.string(), z.number()]))
        .describe("The configured metadata for the resource as defined by its product's Metadata Schema")
        .optional(),
    }),
  ),
}) as unknown as ToZod<GetIntegrationResources200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getIntegrationResources400Schema = z.unknown() as unknown as ToZod<GetIntegrationResources400>

export const getIntegrationResources401Schema = z.unknown() as unknown as ToZod<GetIntegrationResources401>

/**
 * @description You do not have permission to access this resource.
 */
export const getIntegrationResources403Schema = z.unknown() as unknown as ToZod<GetIntegrationResources403>

export const getIntegrationResources404Schema = z.unknown() as unknown as ToZod<GetIntegrationResources404>

export const getIntegrationResourcesQueryResponseSchema = z.lazy(
  () => getIntegrationResources200Schema,
) as unknown as ToZod<GetIntegrationResourcesQueryResponse>

export const getIntegrationResourcePathParamsSchema = z.object({
  integrationConfigurationId: z.string().describe('The ID of the integration configuration (installation) the resource belongs to'),
  resourceId: z.string().describe('The ID provided by the 3rd party provider for the given resource'),
}) as unknown as ToZod<GetIntegrationResourcePathParams>

export const getIntegrationResource200Schema = z.object({
  id: z.string().describe('The ID provided by the 3rd party provider for the given resource'),
  internalId: z.string().describe('The ID assigned by Vercel for the given resource'),
  name: z.string().describe('The name of the resource as it is recorded in Vercel'),
  status: z.enum(['error', 'pending', 'ready', 'resumed', 'suspended', 'uninstalled']).describe('The current status of the resource').optional(),
  productId: z.string().describe('The ID of the product the resource is derived from'),
  protocolSettings: z
    .object({
      experimentation: z
        .object({
          edgeConfigSyncingEnabled: z.boolean().optional(),
          edgeConfigId: z.string().optional(),
          edgeConfigTokenId: z.string().optional(),
        })
        .optional(),
    })
    .describe("Any settings provided for the resource to support its product's protocols")
    .optional(),
  notification: z
    .object({
      level: z.enum(['error', 'info', 'warn']),
      title: z.string(),
      message: z.string().optional(),
      href: z.string().optional(),
    })
    .describe('The notification, if set, displayed to the user when viewing the resource in Vercel')
    .optional(),
  billingPlanId: z.string().describe('The ID of the billing plan the resource is subscribed to, if applicable').optional(),
  metadata: z
    .object({})
    .catchall(z.union([z.boolean(), z.array(z.string()), z.array(z.number()), z.string(), z.number()]))
    .describe("The configured metadata for the resource as defined by its product's Metadata Schema")
    .optional(),
}) as unknown as ToZod<GetIntegrationResource200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getIntegrationResource400Schema = z.unknown() as unknown as ToZod<GetIntegrationResource400>

export const getIntegrationResource401Schema = z.unknown() as unknown as ToZod<GetIntegrationResource401>

/**
 * @description You do not have permission to access this resource.
 */
export const getIntegrationResource403Schema = z.unknown() as unknown as ToZod<GetIntegrationResource403>

export const getIntegrationResource404Schema = z.unknown() as unknown as ToZod<GetIntegrationResource404>

export const getIntegrationResourceQueryResponseSchema = z.lazy(() => getIntegrationResource200Schema) as unknown as ToZod<GetIntegrationResourceQueryResponse>

export const deleteIntegrationResourcePathParamsSchema = z.object({
  integrationConfigurationId: z.string(),
  resourceId: z.string(),
}) as unknown as ToZod<DeleteIntegrationResourcePathParams>

export const deleteIntegrationResource204Schema = z.unknown() as unknown as ToZod<DeleteIntegrationResource204>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const deleteIntegrationResource400Schema = z.unknown() as unknown as ToZod<DeleteIntegrationResource400>

export const deleteIntegrationResource401Schema = z.unknown() as unknown as ToZod<DeleteIntegrationResource401>

/**
 * @description You do not have permission to access this resource.
 */
export const deleteIntegrationResource403Schema = z.unknown() as unknown as ToZod<DeleteIntegrationResource403>

export const deleteIntegrationResource404Schema = z.unknown() as unknown as ToZod<DeleteIntegrationResource404>

export const deleteIntegrationResourceMutationResponseSchema = z.lazy(
  () => deleteIntegrationResource204Schema,
) as unknown as ToZod<DeleteIntegrationResourceMutationResponse>

export const importResourcePathParamsSchema = z.object({
  integrationConfigurationId: z.string(),
  resourceId: z.string(),
}) as unknown as ToZod<ImportResourcePathParams>

export const importResource200Schema = z.object({
  name: z.string(),
}) as unknown as ToZod<ImportResource200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const importResource400Schema = z.unknown() as unknown as ToZod<ImportResource400>

export const importResource401Schema = z.unknown() as unknown as ToZod<ImportResource401>

/**
 * @description You do not have permission to access this resource.
 */
export const importResource403Schema = z.unknown() as unknown as ToZod<ImportResource403>

export const importResource404Schema = z.unknown() as unknown as ToZod<ImportResource404>

export const importResourceMutationRequestSchema = z.object({
  productId: z.string(),
  name: z.string(),
  status: z.enum(['error', 'pending', 'ready', 'resumed', 'suspended', 'uninstalled']),
  metadata: z.object({}).catchall(z.unknown()).optional(),
  billingPlan: z
    .object({
      id: z.string(),
      type: z.enum(['prepayment', 'subscription']),
      name: z.string(),
      description: z.string().optional(),
      paymentMethodRequired: z.boolean().optional(),
      cost: z.string().optional(),
      details: z
        .array(
          z.object({
            label: z.string(),
            value: z.string().optional(),
          }),
        )
        .optional(),
      heightlightedDetails: z
        .array(
          z.object({
            label: z.string(),
            value: z.string().optional(),
          }),
        )
        .optional(),
      effectiveDate: z.string().optional(),
    })
    .catchall(z.unknown())
    .optional(),
  notification: z
    .object({
      level: z.enum(['error', 'info', 'warn']),
      title: z.string(),
      message: z.string().optional(),
      href: z.string().url().optional(),
    })
    .optional(),
  secrets: z
    .array(
      z.object({
        name: z.string(),
        value: z.string(),
        prefix: z.string().optional(),
        environmentOverrides: z
          .object({
            development: z.string().describe('Value used for development environment.').optional(),
            preview: z.string().describe('Value used for preview environment.').optional(),
            production: z.string().describe('Value used for production environment.').optional(),
          })
          .describe(
            'A map of environments to override values for the secret, used for setting different values across deployments in production, preview, and development environments. Note: the same value will be used for all deployments in the given environment.',
          )
          .optional(),
      }),
    )
    .optional(),
}) as unknown as ToZod<ImportResourceMutationRequest>

export const importResourceMutationResponseSchema = z.lazy(() => importResource200Schema) as unknown as ToZod<ImportResourceMutationResponse>

export const submitBillingDataPathParamsSchema = z.object({
  integrationConfigurationId: z.string(),
}) as unknown as ToZod<SubmitBillingDataPathParams>

export const submitBillingData201Schema = z.unknown() as unknown as ToZod<SubmitBillingData201>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const submitBillingData400Schema = z.unknown() as unknown as ToZod<SubmitBillingData400>

export const submitBillingData401Schema = z.unknown() as unknown as ToZod<SubmitBillingData401>

/**
 * @description You do not have permission to access this resource.
 */
export const submitBillingData403Schema = z.unknown() as unknown as ToZod<SubmitBillingData403>

export const submitBillingData404Schema = z.unknown() as unknown as ToZod<SubmitBillingData404>

export const submitBillingDataMutationRequestSchema = z.object({
  timestamp: z
    .date()
    .describe(
      'Server time of your integration, used to determine the most recent data for race conditions & updates. Only the latest usage data for a given day, week, and month will be kept.',
    ),
  eod: z
    .date()
    .describe(
      'End of Day, the UTC datetime for when the end of the billing/usage day is in UTC time. This tells us which day the usage data is for, and also allows for your \\"end of day\\" to be different from UTC 00:00:00. eod must be within the period dates, and cannot be older than 24h earlier from our server\'s current time.',
    ),
  period: z
    .object({
      start: z.date(),
      end: z.date(),
    })
    .describe("Period for the billing cycle. The period end date cannot be older than 24 hours earlier than our current server's time."),
  billing: z
    .union([
      z.array(
        z.object({
          billingPlanId: z.string().describe("Partner's billing plan ID."),
          resourceId: z.string().describe("Partner's resource ID.").optional(),
          start: z.date().describe("Start and end are only needed if different from the period's start/end.").optional(),
          end: z.date().describe("Start and end are only needed if different from the period's start/end.").optional(),
          name: z.string().describe('Line item name.'),
          details: z.string().describe('Line item details.').optional(),
          price: z
            .string()
            .regex(/^[0-9]+(\\.[0-9]+)?$/)
            .describe('Price per unit.'),
          quantity: z.number().describe('Quantity of units.'),
          units: z.string().describe('Units of the quantity.'),
          total: z
            .string()
            .regex(/^[0-9]+(\\.[0-9]+)?$/)
            .describe('Total amount.'),
        }),
      ),
      z.object({
        items: z.array(
          z.object({
            billingPlanId: z.string().describe("Partner's billing plan ID."),
            resourceId: z.string().describe("Partner's resource ID.").optional(),
            start: z.date().describe("Start and end are only needed if different from the period's start/end.").optional(),
            end: z.date().describe("Start and end are only needed if different from the period's start/end.").optional(),
            name: z.string().describe('Line item name.'),
            details: z.string().describe('Line item details.').optional(),
            price: z
              .string()
              .regex(/^[0-9]+(\\.[0-9]+)?$/)
              .describe('Price per unit.'),
            quantity: z.number().describe('Quantity of units.'),
            units: z.string().describe('Units of the quantity.'),
            total: z
              .string()
              .regex(/^[0-9]+(\\.[0-9]+)?$/)
              .describe('Total amount.'),
          }),
        ),
        discounts: z
          .array(
            z.object({
              billingPlanId: z.string().describe("Partner's billing plan ID."),
              resourceId: z.string().describe("Partner's resource ID.").optional(),
              start: z.date().describe("Start and end are only needed if different from the period's start/end.").optional(),
              end: z.date().describe("Start and end are only needed if different from the period's start/end.").optional(),
              name: z.string().describe('Discount name.'),
              details: z.string().describe('Discount details.').optional(),
              amount: z
                .string()
                .regex(/^[0-9]+(\\.[0-9]+)?$/)
                .describe('Discount amount.'),
            }),
          )
          .optional(),
      }),
    ])
    .describe('Billing data (interim invoicing data).'),
  usage: z.array(
    z.object({
      resourceId: z.string().describe("Partner's resource ID.").optional(),
      name: z.string().describe('Metric name.'),
      type: z
        .enum(['interval', 'rate', 'total'])
        .describe(
          '\\n              Type of the metric.\\n              - total: measured total value, such as Database size\\n              - interval: usage during the period, such as i/o or number of queries.\\n              - rate: rate of usage, such as queries per second.\\n            ',
        ),
      units: z.string().describe('Metric units. Example: \\"GB\\"'),
      dayValue: z.number().describe('Metric value for the day. Could be a final or an interim value for the day.'),
      periodValue: z.number().describe('Metric value for the billing period. Could be a final or an interim value for the period.'),
      planValue: z.number().describe('The limit value of the metric for a billing period, if a limit is defined by the plan.').optional(),
    }),
  ),
}) as unknown as ToZod<SubmitBillingDataMutationRequest>

export const submitBillingDataMutationResponseSchema = z.lazy(() => submitBillingData201Schema) as unknown as ToZod<SubmitBillingDataMutationResponse>

export const submitInvoicePathParamsSchema = z.object({
  integrationConfigurationId: z.string(),
}) as unknown as ToZod<SubmitInvoicePathParams>

export const submitInvoice200Schema = z.object({
  invoiceId: z.string().optional(),
  test: z.boolean().optional(),
  validationErrors: z.array(z.string()).optional(),
}) as unknown as ToZod<SubmitInvoice200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const submitInvoice400Schema = z.unknown() as unknown as ToZod<SubmitInvoice400>

export const submitInvoice401Schema = z.unknown() as unknown as ToZod<SubmitInvoice401>

/**
 * @description You do not have permission to access this resource.
 */
export const submitInvoice403Schema = z.unknown() as unknown as ToZod<SubmitInvoice403>

export const submitInvoice404Schema = z.unknown() as unknown as ToZod<SubmitInvoice404>

export const submitInvoiceMutationRequestSchema = z.object({
  externalId: z.string().optional(),
  invoiceDate: z.date().describe("Invoice date. Must be within the period's start and end."),
  memo: z.string().describe('Additional memo for the invoice.').optional(),
  period: z
    .object({
      start: z.date(),
      end: z.date(),
    })
    .describe('Subscription period for this billing cycle.'),
  items: z.array(
    z.object({
      resourceId: z.string().describe("Partner's resource ID.").optional(),
      billingPlanId: z.string().describe("Partner's billing plan ID."),
      start: z.date().describe("Start and end are only needed if different from the period's start/end.").optional(),
      end: z.date().describe("Start and end are only needed if different from the period's start/end.").optional(),
      name: z.string(),
      details: z.string().optional(),
      price: z
        .string()
        .regex(/^[0-9]+(\\.[0-9]+)?$/)
        .describe('Currency amount as a decimal string.'),
      quantity: z.number(),
      units: z.string(),
      total: z
        .string()
        .regex(/^[0-9]+(\\.[0-9]+)?$/)
        .describe('Currency amount as a decimal string.'),
    }),
  ),
  discounts: z
    .array(
      z.object({
        resourceId: z.string().describe("Partner's resource ID.").optional(),
        billingPlanId: z.string().describe("Partner's billing plan ID."),
        start: z.date().describe("Start and end are only needed if different from the period's start/end.").optional(),
        end: z.date().describe("Start and end are only needed if different from the period's start/end.").optional(),
        name: z.string(),
        details: z.string().optional(),
        amount: z
          .string()
          .regex(/^[0-9]+(\\.[0-9]+)?$/)
          .describe('Currency amount as a decimal string.'),
      }),
    )
    .optional(),
  test: z
    .object({
      validate: z.boolean().optional(),
      result: z.enum(['notpaid', 'paid']).optional(),
    })
    .describe('Test mode')
    .optional(),
}) as unknown as ToZod<SubmitInvoiceMutationRequest>

export const submitInvoiceMutationResponseSchema = z.lazy(() => submitInvoice200Schema) as unknown as ToZod<SubmitInvoiceMutationResponse>

export const getInvoicePathParamsSchema = z.object({
  integrationConfigurationId: z.string(),
  invoiceId: z.string(),
}) as unknown as ToZod<GetInvoicePathParams>

export const getInvoice200Schema = z.object({
  test: z.boolean().describe('Whether the invoice is in the testmode (no real transaction created).').optional(),
  invoiceId: z.string().describe('Vercel Marketplace Invoice ID.'),
  externalId: z.string().describe('Partner-supplied Invoice ID, if applicable.').optional(),
  state: z.enum(['invoiced', 'notpaid', 'paid', 'pending', 'refund_requested', 'refunded', 'scheduled']).describe('Invoice state.'),
  invoiceNumber: z.string().describe('User-readable invoice number.').optional(),
  invoiceDate: z.string().describe('Invoice date. ISO 8601 timestamp.'),
  period: z
    .object({
      start: z.string(),
      end: z.string(),
    })
    .describe('Subscription period for this billing cycle. ISO 8601 timestamps.'),
  memo: z.string().describe('Additional memo for the invoice.').optional(),
  items: z
    .array(
      z
        .object({
          billingPlanId: z.string().describe("Partner's billing plan ID."),
          resourceId: z.string().describe("Partner's resource ID. If not specified, indicates installation-wide item.").optional(),
          start: z.string().describe("Start and end are only needed if different from the period's start/end. ISO 8601 timestamp.").optional(),
          end: z.string().describe("Start and end are only needed if different from the period's start/end. ISO 8601 timestamp.").optional(),
          name: z.string().describe('Invoice item name.'),
          details: z.string().describe('Additional item details.').optional(),
          price: z.string().describe('Item price. A dollar-based decimal string.'),
          quantity: z.number().describe('Item quantity.'),
          units: z.string().describe("Units for item's quantity."),
          total: z.string().describe('Item total. A dollar-based decimal string.'),
        })
        .describe('Invoice items.'),
    )
    .describe('Invoice items.'),
  discounts: z
    .array(
      z
        .object({
          billingPlanId: z.string().describe("Partner's billing plan ID."),
          resourceId: z.string().describe("Partner's resource ID. If not specified, indicates installation-wide discount.").optional(),
          start: z.string().describe("Start and end are only needed if different from the period's start/end. ISO 8601 timestamp.").optional(),
          end: z.string().describe("Start and end are only needed if different from the period's start/end. ISO 8601 timestamp.").optional(),
          name: z.string().describe('Discount name.'),
          details: z.string().describe('Additional discount details.').optional(),
          amount: z.string().describe('Discount amount. A dollar-based decimal string.'),
        })
        .describe('Invoice discounts.'),
    )
    .describe('Invoice discounts.')
    .optional(),
  total: z.string().describe('Invoice total amount. A dollar-based decimal string.'),
  refundReason: z.string().describe('The reason for refund. Only applicable for states "refunded" or "refund_request".').optional(),
  refundTotal: z.string().describe('Refund amount. Only applicable for states "refunded" or "refund_request". A dollar-based decimal string.').optional(),
  created: z.string().describe('System creation date. ISO 8601 timestamp.'),
  updated: z.string().describe('System update date. ISO 8601 timestamp.'),
}) as unknown as ToZod<GetInvoice200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getInvoice400Schema = z.unknown() as unknown as ToZod<GetInvoice400>

export const getInvoice401Schema = z.unknown() as unknown as ToZod<GetInvoice401>

/**
 * @description You do not have permission to access this resource.
 */
export const getInvoice403Schema = z.unknown() as unknown as ToZod<GetInvoice403>

export const getInvoice404Schema = z.unknown() as unknown as ToZod<GetInvoice404>

export const getInvoiceQueryResponseSchema = z.lazy(() => getInvoice200Schema) as unknown as ToZod<GetInvoiceQueryResponse>

export const updateInvoicePathParamsSchema = z.object({
  integrationConfigurationId: z.string(),
  invoiceId: z.string(),
}) as unknown as ToZod<UpdateInvoicePathParams>

export const updateInvoice204Schema = z.unknown() as unknown as ToZod<UpdateInvoice204>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const updateInvoice400Schema = z.unknown() as unknown as ToZod<UpdateInvoice400>

export const updateInvoice401Schema = z.unknown() as unknown as ToZod<UpdateInvoice401>

/**
 * @description You do not have permission to access this resource.
 */
export const updateInvoice403Schema = z.unknown() as unknown as ToZod<UpdateInvoice403>

export const updateInvoice404Schema = z.unknown() as unknown as ToZod<UpdateInvoice404>

export const updateInvoiceMutationRequestSchema = z.object({
  action: z.enum(['refund']),
  reason: z.string().describe('Refund reason.'),
  total: z
    .string()
    .regex(/^[0-9]+(\\.[0-9]+)?$/)
    .describe('The total amount to be refunded. Must be less than or equal to the total amount of the invoice.'),
}) as unknown as ToZod<UpdateInvoiceMutationRequest>

export const updateInvoiceMutationResponseSchema = z.lazy(() => updateInvoice204Schema) as unknown as ToZod<UpdateInvoiceMutationResponse>

export const submitPrepaymentBalancesPathParamsSchema = z.object({
  integrationConfigurationId: z.string(),
}) as unknown as ToZod<SubmitPrepaymentBalancesPathParams>

export const submitPrepaymentBalances201Schema = z.unknown() as unknown as ToZod<SubmitPrepaymentBalances201>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const submitPrepaymentBalances400Schema = z.unknown() as unknown as ToZod<SubmitPrepaymentBalances400>

export const submitPrepaymentBalances401Schema = z.unknown() as unknown as ToZod<SubmitPrepaymentBalances401>

/**
 * @description You do not have permission to access this resource.
 */
export const submitPrepaymentBalances403Schema = z.unknown() as unknown as ToZod<SubmitPrepaymentBalances403>

export const submitPrepaymentBalances404Schema = z.unknown() as unknown as ToZod<SubmitPrepaymentBalances404>

export const submitPrepaymentBalancesMutationRequestSchema = z.object({
  timestamp: z
    .date()
    .describe(
      'Server time of your integration, used to determine the most recent data for race conditions & updates. Only the latest usage data for a given day, week, and month will be kept.',
    ),
  balances: z.array(
    z
      .object({
        resourceId: z.string().describe("Partner's resource ID, exclude if credits are tied to the installation and not an individual resource.").optional(),
        credit: z.string().describe('A human-readable description of the credits the user currently has, e.g. \\"2,000 Tokens\\"').optional(),
        nameLabel: z.string().describe('The name of the credits, for display purposes, e.g. \\"Tokens\\"').optional(),
        currencyValueInCents: z
          .number()
          .describe('The dollar value of the credit balance, in USD and provided in cents, which is used to trigger automatic purchase thresholds.'),
      })
      .describe('A credit balance for a particular token type'),
  ),
}) as unknown as ToZod<SubmitPrepaymentBalancesMutationRequest>

export const submitPrepaymentBalancesMutationResponseSchema = z.lazy(
  () => submitPrepaymentBalances201Schema,
) as unknown as ToZod<SubmitPrepaymentBalancesMutationResponse>

export const updateResourceSecretsPathParamsSchema = z.object({
  integrationConfigurationId: z.string(),
  integrationProductIdOrSlug: z.string(),
  resourceId: z.string(),
}) as unknown as ToZod<UpdateResourceSecretsPathParams>

export const updateResourceSecrets201Schema = z.unknown() as unknown as ToZod<UpdateResourceSecrets201>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const updateResourceSecrets400Schema = z.unknown() as unknown as ToZod<UpdateResourceSecrets400>

export const updateResourceSecrets401Schema = z.unknown() as unknown as ToZod<UpdateResourceSecrets401>

/**
 * @description You do not have permission to access this resource.
 */
export const updateResourceSecrets403Schema = z.unknown() as unknown as ToZod<UpdateResourceSecrets403>

export const updateResourceSecrets404Schema = z.unknown() as unknown as ToZod<UpdateResourceSecrets404>

export const updateResourceSecretsMutationRequestSchema = z.object({
  secrets: z.array(
    z.object({
      name: z.string(),
      value: z.string(),
      prefix: z.string().optional(),
      environmentOverrides: z
        .object({
          development: z.string().describe('Value used for development environment.').optional(),
          preview: z.string().describe('Value used for preview environment.').optional(),
          production: z.string().describe('Value used for production environment.').optional(),
        })
        .describe(
          'A map of environments to override values for the secret, used for setting different values across deployments in production, preview, and development environments. Note: the same value will be used for all deployments in the given environment.',
        )
        .optional(),
    }),
  ),
  partial: z.boolean().describe('If true, will only update the provided secrets').optional(),
}) as unknown as ToZod<UpdateResourceSecretsMutationRequest>

export const updateResourceSecretsMutationResponseSchema = z.lazy(
  () => updateResourceSecrets201Schema,
) as unknown as ToZod<UpdateResourceSecretsMutationResponse>

export const updateResourceSecretsByIdPathParamsSchema = z.object({
  integrationConfigurationId: z.string(),
  resourceId: z.string(),
}) as unknown as ToZod<UpdateResourceSecretsByIdPathParams>

export const updateResourceSecretsById201Schema = z.unknown() as unknown as ToZod<UpdateResourceSecretsById201>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const updateResourceSecretsById400Schema = z.unknown() as unknown as ToZod<UpdateResourceSecretsById400>

export const updateResourceSecretsById401Schema = z.unknown() as unknown as ToZod<UpdateResourceSecretsById401>

/**
 * @description You do not have permission to access this resource.
 */
export const updateResourceSecretsById403Schema = z.unknown() as unknown as ToZod<UpdateResourceSecretsById403>

export const updateResourceSecretsById404Schema = z.unknown() as unknown as ToZod<UpdateResourceSecretsById404>

export const updateResourceSecretsById422Schema = z.unknown() as unknown as ToZod<UpdateResourceSecretsById422>

export const updateResourceSecretsByIdMutationRequestSchema = z.object({
  secrets: z.array(
    z.object({
      name: z.string(),
      value: z.string(),
      prefix: z.string().optional(),
      environmentOverrides: z
        .object({
          development: z.string().describe('Value used for development environment.').optional(),
          preview: z.string().describe('Value used for preview environment.').optional(),
          production: z.string().describe('Value used for production environment.').optional(),
        })
        .describe(
          'A map of environments to override values for the secret, used for setting different values across deployments in production, preview, and development environments. Note: the same value will be used for all deployments in the given environment.',
        )
        .optional(),
    }),
  ),
  partial: z.boolean().describe('If true, will only overwrite the provided secrets instead of replacing all secrets.').optional(),
}) as unknown as ToZod<UpdateResourceSecretsByIdMutationRequest>

export const updateResourceSecretsByIdMutationResponseSchema = z.lazy(
  () => updateResourceSecretsById201Schema,
) as unknown as ToZod<UpdateResourceSecretsByIdMutationResponse>

export const getConfigurationsQueryParamsSchema = z.object({
  view: z.enum(['account', 'project']),
  installationType: z.enum(['marketplace', 'external']).optional(),
  integrationIdOrSlug: z.string().describe('ID of the integration').optional(),
  teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
  slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
}) as unknown as ToZod<GetConfigurationsQueryParams>

/**
 * @description The list of configurations for the authenticated user
 */
export const getConfigurations200Schema = z.union([
  z.array(
    z
      .object({
        completedAt: z.number().describe('A timestamp that tells you when the configuration was installed successfully').optional(),
        createdAt: z.number().describe('A timestamp that tells you when the configuration was created').optional(),
        id: z.string().describe('The unique identifier of the configuration').optional(),
        integrationId: z.string().describe('The unique identifier of the app the configuration was created for').optional(),
        ownerId: z.string().describe('The user or team ID that owns the configuration').optional(),
        projects: z
          .array(z.string())
          .describe(
            'When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.',
          )
          .optional(),
        source: z
          .enum(['marketplace', 'deploy-button', 'external', 'v0'])
          .describe(
            'Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.',
          )
          .optional(),
        slug: z.string().describe('The slug of the integration the configuration is created for.').optional(),
        teamId: z.string().describe('When the configuration was created for a team, this will show the ID of the team.').nullable().nullish(),
        type: z.enum(['integration-configuration']).optional(),
        updatedAt: z.number().describe('A timestamp that tells you when the configuration was updated.').optional(),
        userId: z.string().describe('The ID of the user that created the configuration.').optional(),
        scopes: z.array(z.string()).describe('The resources that are allowed to be accessed by the configuration.').optional(),
        disabledAt: z
          .number()
          .describe(
            "A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.",
          )
          .optional(),
        deletedAt: z.number().describe('A timestamp that tells you when the configuration was deleted.').nullable().nullish(),
        deleteRequestedAt: z
          .number()
          .describe(
            'A timestamp that tells you when the configuration deletion has been started for cases when the deletion needs to be settled/approved by partners, such as when marketplace invoices have been paid.',
          )
          .nullable()
          .nullish(),
        disabledReason: z
          .enum([
            'disabled-by-owner',
            'feature-not-available',
            'disabled-by-admin',
            'original-owner-left-the-team',
            'account-plan-downgrade',
            'original-owner-role-downgraded',
          ])
          .optional(),
        installationType: z
          .enum(['marketplace', 'external'])
          .describe(
            "Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'",
          )
          .optional(),
      })
      .describe('The list of configurations for the authenticated user'),
  ),
  z.array(
    z.object({
      integration: z.object({
        name: z.string(),
        icon: z.string(),
        isLegacy: z.boolean(),
        flags: z.array(z.string()).optional(),
        assignedBetaLabelAt: z.number().optional(),
        tagIds: z
          .array(
            z.enum([
              'tag_ai',
              'tag_analytics',
              'tag_authentication',
              'tag_cms',
              'tag_code_repository',
              'tag_commerce',
              'tag_databases',
              'tag_dev_tools',
              'tag_experimentation',
              'tag_flags',
              'tag_logging',
              'tag_messaging',
              'tag_monitoring',
              'tag_observability',
              'tag_performance',
              'tag_productivity',
              'tag_searching',
              'tag_security',
              'tag_testing',
              'tag_video',
              'tag_workflow',
            ]),
          )
          .optional(),
      }),
      completedAt: z.number().describe('A timestamp that tells you when the configuration was installed successfully').optional(),
      createdAt: z.number().describe('A timestamp that tells you when the configuration was created'),
      id: z.string().describe('The unique identifier of the configuration'),
      integrationId: z.string().describe('The unique identifier of the app the configuration was created for'),
      ownerId: z.string().describe('The user or team ID that owns the configuration'),
      projects: z
        .array(z.string())
        .describe(
          'When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.',
        )
        .optional(),
      source: z
        .enum(['marketplace', 'deploy-button', 'external', 'v0'])
        .describe(
          'Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.',
        )
        .optional(),
      slug: z.string().describe('The slug of the integration the configuration is created for.'),
      teamId: z.string().describe('When the configuration was created for a team, this will show the ID of the team.').nullable().nullish(),
      type: z.enum(['integration-configuration']),
      updatedAt: z.number().describe('A timestamp that tells you when the configuration was updated.'),
      userId: z.string().describe('The ID of the user that created the configuration.'),
      scopes: z.array(z.string()).describe('The resources that are allowed to be accessed by the configuration.'),
      disabledAt: z
        .number()
        .describe(
          "A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.",
        )
        .optional(),
      deletedAt: z.number().describe('A timestamp that tells you when the configuration was deleted.').nullable().nullish(),
      deleteRequestedAt: z
        .number()
        .describe(
          'A timestamp that tells you when the configuration deletion has been started for cases when the deletion needs to be settled/approved by partners, such as when marketplace invoices have been paid.',
        )
        .nullable()
        .nullish(),
      disabledReason: z
        .enum([
          'disabled-by-owner',
          'feature-not-available',
          'disabled-by-admin',
          'original-owner-left-the-team',
          'account-plan-downgrade',
          'original-owner-role-downgraded',
        ])
        .optional(),
      installationType: z
        .enum(['marketplace', 'external'])
        .describe(
          "Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'",
        )
        .optional(),
    }),
  ),
]) as unknown as ToZod<GetConfigurations200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getConfigurations400Schema = z.unknown() as unknown as ToZod<GetConfigurations400>

export const getConfigurations401Schema = z.unknown() as unknown as ToZod<GetConfigurations401>

/**
 * @description You do not have permission to access this resource.
 */
export const getConfigurations403Schema = z.unknown() as unknown as ToZod<GetConfigurations403>

export const getConfigurationsQueryResponseSchema = z.lazy(() => getConfigurations200Schema) as unknown as ToZod<GetConfigurationsQueryResponse>

export const getConfigurationPathParamsSchema = z.object({
  id: z.string().describe('ID of the configuration to check'),
}) as unknown as ToZod<GetConfigurationPathParams>

export const getConfigurationQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetConfigurationQueryParams>

/**
 * @description The configuration with the provided id
 */
export const getConfiguration200Schema = z.union([
  z.object({
    completedAt: z.number().describe('A timestamp that tells you when the configuration was installed successfully').optional(),
    createdAt: z.number().describe('A timestamp that tells you when the configuration was created'),
    id: z.string().describe('The unique identifier of the configuration'),
    integrationId: z.string().describe('The unique identifier of the app the configuration was created for'),
    ownerId: z.string().describe('The user or team ID that owns the configuration'),
    projects: z
      .array(z.string())
      .describe(
        'When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.',
      )
      .optional(),
    source: z
      .enum(['marketplace', 'deploy-button', 'external', 'v0'])
      .describe(
        'Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.',
      )
      .optional(),
    slug: z.string().describe('The slug of the integration the configuration is created for.'),
    teamId: z.string().describe('When the configuration was created for a team, this will show the ID of the team.').nullable().nullish(),
    type: z.enum(['integration-configuration']),
    updatedAt: z.number().describe('A timestamp that tells you when the configuration was updated.'),
    userId: z.string().describe('The ID of the user that created the configuration.'),
    scopes: z.array(z.string()).describe('The resources that are allowed to be accessed by the configuration.'),
    disabledAt: z
      .number()
      .describe(
        "A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.",
      )
      .optional(),
    deletedAt: z.number().describe('A timestamp that tells you when the configuration was deleted.').nullable().nullish(),
    deleteRequestedAt: z
      .number()
      .describe(
        'A timestamp that tells you when the configuration deletion has been started for cases when the deletion needs to be settled/approved by partners, such as when marketplace invoices have been paid.',
      )
      .nullable()
      .nullish(),
    disabledReason: z
      .enum([
        'disabled-by-owner',
        'feature-not-available',
        'disabled-by-admin',
        'original-owner-left-the-team',
        'account-plan-downgrade',
        'original-owner-role-downgraded',
      ])
      .optional(),
    installationType: z
      .enum(['marketplace', 'external'])
      .describe(
        "Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'",
      )
      .optional(),
  }),
  z.object({
    projectSelection: z.enum(['selected', 'all']).describe('A string representing the permission for projects. Possible values are `all` or `selected`.'),
    notification: z.object({
      level: z.enum(['info', 'warn', 'error']),
      title: z.string(),
      message: z.string().optional(),
      href: z.string().optional(),
    }),
    transferRequest: z.union([
      z.object({
        kind: z.enum(['transfer-to-marketplace']),
        metadata: z.object({}).catchall(z.unknown()).optional(),
        billingPlan: z
          .object({
            id: z.string(),
            type: z.enum(['subscription', 'prepayment']),
            scope: z.enum(['installation', 'resource']).optional(),
            name: z.string(),
            description: z.string(),
            paymentMethodRequired: z.boolean().optional(),
            preauthorizationAmount: z.number().optional(),
          })
          .optional(),
        requestId: z.string(),
        transferId: z.string(),
        requester: z.object({
          name: z.string(),
          email: z.string().optional(),
        }),
        createdAt: z.number(),
        expiresAt: z.number(),
        discardedAt: z.number().optional(),
        discardedBy: z.string().optional(),
        approvedAt: z.number().optional(),
        approvedBy: z.string().optional(),
        authorizationId: z.string().optional(),
      }),
      z.object({
        kind: z.enum(['transfer-from-marketplace']),
        requestId: z.string(),
        transferId: z.string(),
        requester: z.object({
          name: z.string(),
          email: z.string().optional(),
        }),
        createdAt: z.number(),
        expiresAt: z.number(),
        discardedAt: z.number().optional(),
        discardedBy: z.string().optional(),
        approvedAt: z.number().optional(),
        approvedBy: z.string().optional(),
        authorizationId: z.string().optional(),
      }),
    ]),
    projects: z
      .array(z.string())
      .describe(
        'When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.',
      )
      .optional(),
    completedAt: z.number().describe('A timestamp that tells you when the configuration was installed successfully').optional(),
    createdAt: z.number().describe('A timestamp that tells you when the configuration was created'),
    id: z.string().describe('The unique identifier of the configuration'),
    integrationId: z.string().describe('The unique identifier of the app the configuration was created for'),
    ownerId: z.string().describe('The user or team ID that owns the configuration'),
    source: z
      .enum(['marketplace', 'deploy-button', 'external', 'v0'])
      .describe(
        'Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.',
      )
      .optional(),
    slug: z.string().describe('The slug of the integration the configuration is created for.'),
    teamId: z.string().describe('When the configuration was created for a team, this will show the ID of the team.').nullable().nullish(),
    type: z.enum(['integration-configuration']),
    updatedAt: z.number().describe('A timestamp that tells you when the configuration was updated.'),
    userId: z.string().describe('The ID of the user that created the configuration.'),
    scopes: z.array(z.string()).describe('The resources that are allowed to be accessed by the configuration.'),
    disabledAt: z
      .number()
      .describe(
        "A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.",
      )
      .optional(),
    deletedAt: z.number().describe('A timestamp that tells you when the configuration was deleted.').nullable().nullish(),
    deleteRequestedAt: z
      .number()
      .describe(
        'A timestamp that tells you when the configuration deletion has been started for cases when the deletion needs to be settled/approved by partners, such as when marketplace invoices have been paid.',
      )
      .nullable()
      .nullish(),
    disabledReason: z
      .enum([
        'disabled-by-owner',
        'feature-not-available',
        'disabled-by-admin',
        'original-owner-left-the-team',
        'account-plan-downgrade',
        'original-owner-role-downgraded',
      ])
      .optional(),
    installationType: z
      .enum(['marketplace', 'external'])
      .describe(
        "Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'",
      )
      .optional(),
    canConfigureOpenTelemetry: z.boolean().optional(),
  }),
]) as unknown as ToZod<GetConfiguration200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getConfiguration400Schema = z.unknown() as unknown as ToZod<GetConfiguration400>

export const getConfiguration401Schema = z.unknown() as unknown as ToZod<GetConfiguration401>

/**
 * @description You do not have permission to access this resource.
 */
export const getConfiguration403Schema = z.unknown() as unknown as ToZod<GetConfiguration403>

/**
 * @description The configuration was not found
 */
export const getConfiguration404Schema = z.unknown() as unknown as ToZod<GetConfiguration404>

export const getConfigurationQueryResponseSchema = z.lazy(() => getConfiguration200Schema) as unknown as ToZod<GetConfigurationQueryResponse>

export const deleteConfigurationPathParamsSchema = z.object({
  id: z.string(),
}) as unknown as ToZod<DeleteConfigurationPathParams>

export const deleteConfigurationQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<DeleteConfigurationQueryParams>

/**
 * @description The configuration was successfully removed
 */
export const deleteConfiguration204Schema = z.unknown() as unknown as ToZod<DeleteConfiguration204>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const deleteConfiguration400Schema = z.unknown() as unknown as ToZod<DeleteConfiguration400>

export const deleteConfiguration401Schema = z.unknown() as unknown as ToZod<DeleteConfiguration401>

/**
 * @description You do not have permission to access this resource.
 */
export const deleteConfiguration403Schema = z.unknown() as unknown as ToZod<DeleteConfiguration403>

/**
 * @description The configuration was not found
 */
export const deleteConfiguration404Schema = z.unknown() as unknown as ToZod<DeleteConfiguration404>

export const deleteConfigurationMutationResponseSchema = z.lazy(() => deleteConfiguration204Schema) as unknown as ToZod<DeleteConfigurationMutationResponse>

export const exchangeSsoToken200Schema = z.object({
  id_token: z.string(),
  access_token: z.unknown(),
  token_type: z.unknown(),
}) as unknown as ToZod<ExchangeSsoToken200>

/**
 * @description One of the provided values in the request body is invalid.
 */
export const exchangeSsoToken400Schema = z.unknown() as unknown as ToZod<ExchangeSsoToken400>

export const exchangeSsoToken404Schema = z.unknown() as unknown as ToZod<ExchangeSsoToken404>

export const exchangeSsoToken500Schema = z.unknown() as unknown as ToZod<ExchangeSsoToken500>

export const exchangeSsoTokenMutationRequestSchema = z.object({
  code: z.string().describe('The sensitive code received from Vercel'),
  state: z.string().describe('The state received from the initialization request').optional(),
  client_id: z.string().describe('The integration client id'),
  client_secret: z.string().describe('The integration client secret'),
  redirect_uri: z.string().describe('The integration redirect URI').optional(),
  grant_type: z.enum(['authorization_code']).describe('The grant type, when using x-www-form-urlencoded content type').optional(),
}) as unknown as ToZod<ExchangeSsoTokenMutationRequest>

export const exchangeSsoTokenMutationResponseSchema = z.lazy(() => exchangeSsoToken200Schema) as unknown as ToZod<ExchangeSsoTokenMutationResponse>

export const getIntegrationLogDrainsQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetIntegrationLogDrainsQueryParams>

/**
 * @description A list of log drains
 */
export const getIntegrationLogDrains200Schema = z.array(
  z.object({
    clientId: z.string().describe('The oauth2 client application id that created this log drain').optional(),
    configurationId: z.string().describe('The client configuration this log drain was created with').optional(),
    createdAt: z.number().describe('A timestamp that tells you when the log drain was created'),
    id: z.string().describe('The unique identifier of the log drain. Always prefixed with `ld_`'),
    deliveryFormat: z.enum(['json', 'ndjson', 'protobuf', 'syslog']).describe('The delivery log format').optional(),
    name: z.string().describe('The name of the log drain'),
    ownerId: z.string().describe('The identifier of the team or user whose events will trigger the log drain'),
    projectId: z.string().nullable().nullish(),
    projectIds: z.array(z.string()).describe('The identifier of the projects this log drain is associated with').optional(),
    url: z.string().describe('The URL to call when logs are generated'),
    sources: z
      .array(
        z
          .enum(['build', 'edge', 'external', 'firewall', 'lambda', 'static'])
          .describe('The sources from which logs are currently being delivered to this log drain.'),
      )
      .describe('The sources from which logs are currently being delivered to this log drain.')
      .optional(),
    createdFrom: z.enum(['integration', 'self-served']).describe('Whether the log drain was created by an integration or by a user').optional(),
    headers: z.object({}).catchall(z.string()).describe('The headers to send with the request').optional(),
    environments: z.array(z.enum(['preview', 'production']).describe('The environment of log drain')).describe('The environment of log drain'),
    branch: z.string().describe('The branch regexp of log drain').optional(),
    samplingRate: z.number().describe('The sampling rate of log drain').optional(),
  }),
) as unknown as ToZod<GetIntegrationLogDrains200>

export const getIntegrationLogDrains400Schema = z.unknown() as unknown as ToZod<GetIntegrationLogDrains400>

export const getIntegrationLogDrains401Schema = z.unknown() as unknown as ToZod<GetIntegrationLogDrains401>

/**
 * @description You do not have permission to access this resource.
 */
export const getIntegrationLogDrains403Schema = z.unknown() as unknown as ToZod<GetIntegrationLogDrains403>

export const getIntegrationLogDrainsQueryResponseSchema = z.lazy(
  () => getIntegrationLogDrains200Schema,
) as unknown as ToZod<GetIntegrationLogDrainsQueryResponse>

export const createLogDrainQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<CreateLogDrainQueryParams>

/**
 * @description The log drain was successfully created
 */
export const createLogDrain200Schema = z.object({
  clientId: z.string().describe('The oauth2 client application id that created this log drain').optional(),
  configurationId: z.string().describe('The client configuration this log drain was created with').optional(),
  createdAt: z.number().describe('A timestamp that tells you when the log drain was created'),
  id: z.string().describe('The unique identifier of the log drain. Always prefixed with `ld_`'),
  deliveryFormat: z.enum(['json', 'ndjson', 'protobuf', 'syslog']).describe('The delivery log format').optional(),
  name: z.string().describe('The name of the log drain'),
  ownerId: z.string().describe('The identifier of the team or user whose events will trigger the log drain'),
  projectId: z.string().nullable().nullish(),
  projectIds: z.array(z.string()).describe('The identifier of the projects this log drain is associated with').optional(),
  url: z.string().describe('The URL to call when logs are generated'),
  sources: z
    .array(
      z
        .enum(['build', 'edge', 'external', 'firewall', 'lambda', 'static'])
        .describe('The sources from which logs are currently being delivered to this log drain.'),
    )
    .describe('The sources from which logs are currently being delivered to this log drain.')
    .optional(),
  createdFrom: z.enum(['integration', 'self-served']).describe('Whether the log drain was created by an integration or by a user').optional(),
  headers: z.object({}).catchall(z.string()).describe('The headers to send with the request').optional(),
  environments: z.array(z.enum(['preview', 'production']).describe('The environment of log drain')).describe('The environment of log drain'),
  branch: z.string().describe('The branch regexp of log drain').optional(),
  samplingRate: z.number().describe('The sampling rate of log drain').optional(),
}) as unknown as ToZod<CreateLogDrain200>

/**
 * @description One of the provided values in the request body is invalid.\nThe provided token is not from an OAuth2 Client
 */
export const createLogDrain400Schema = z.unknown() as unknown as ToZod<CreateLogDrain400>

export const createLogDrain401Schema = z.unknown() as unknown as ToZod<CreateLogDrain401>

/**
 * @description You do not have permission to access this resource.
 */
export const createLogDrain403Schema = z.unknown() as unknown as ToZod<CreateLogDrain403>

export const createLogDrainMutationRequestSchema = z.object({
  name: z
    .string()
    .regex(/^[A-z0-9_ -]+$/)
    .max(100)
    .describe('The name of the log drain'),
  projectIds: z
    .array(z.string().regex(/^[a-zA-z0-9_]+$/))
    .min(1)
    .max(50)
    .optional(),
  secret: z
    .string()
    .regex(/^[A-z0-9_ -]+$/)
    .max(100)
    .describe('A secret to sign log drain notification headers so a consumer can verify their authenticity')
    .optional(),
  deliveryFormat: z.enum(['json', 'ndjson', 'syslog']).describe('The delivery log format').optional(),
  url: z
    .string()
    .url()
    .describe(
      'The url where you will receive logs. The protocol must be `https://` or `http://` when type is `json` and `ndjson`, and `syslog+tls:` or `syslog:` when the type is `syslog`.',
    ),
  sources: z
    .array(z.enum(['build', 'edge', 'external', 'firewall', 'lambda', 'static']))
    .min(1)
    .refine((items) => new Set(items).size === items.length, { message: 'Array entries must be unique' })
    .optional(),
  headers: z.object({}).catchall(z.string()).describe('Headers to be sent together with the request').optional(),
  environments: z
    .array(z.enum(['preview', 'production']))
    .min(1)
    .refine((items) => new Set(items).size === items.length, { message: 'Array entries must be unique' })
    .optional(),
}) as unknown as ToZod<CreateLogDrainMutationRequest>

export const createLogDrainMutationResponseSchema = z.lazy(() => createLogDrain200Schema) as unknown as ToZod<CreateLogDrainMutationResponse>

export const deleteIntegrationLogDrainPathParamsSchema = z.object({
  id: z.string().describe('ID of the log drain to be deleted'),
}) as unknown as ToZod<DeleteIntegrationLogDrainPathParams>

export const deleteIntegrationLogDrainQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<DeleteIntegrationLogDrainQueryParams>

/**
 * @description The log drain was successfully deleted
 */
export const deleteIntegrationLogDrain204Schema = z.unknown() as unknown as ToZod<DeleteIntegrationLogDrain204>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const deleteIntegrationLogDrain400Schema = z.unknown() as unknown as ToZod<DeleteIntegrationLogDrain400>

export const deleteIntegrationLogDrain401Schema = z.unknown() as unknown as ToZod<DeleteIntegrationLogDrain401>

/**
 * @description You do not have permission to access this resource.
 */
export const deleteIntegrationLogDrain403Schema = z.unknown() as unknown as ToZod<DeleteIntegrationLogDrain403>

/**
 * @description The log drain was not found
 */
export const deleteIntegrationLogDrain404Schema = z.unknown() as unknown as ToZod<DeleteIntegrationLogDrain404>

export const deleteIntegrationLogDrainMutationResponseSchema = z.lazy(
  () => deleteIntegrationLogDrain204Schema,
) as unknown as ToZod<DeleteIntegrationLogDrainMutationResponse>

export const getRuntimeLogsPathParamsSchema = z.object({
  projectId: z.string(),
  deploymentId: z.string(),
}) as unknown as ToZod<GetRuntimeLogsPathParams>

export const getRuntimeLogsQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetRuntimeLogsQueryParams>

export const getRuntimeLogs200Schema = z.unknown() as unknown as ToZod<GetRuntimeLogs200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getRuntimeLogs400Schema = z.unknown() as unknown as ToZod<GetRuntimeLogs400>

export const getRuntimeLogs401Schema = z.unknown() as unknown as ToZod<GetRuntimeLogs401>

/**
 * @description You do not have permission to access this resource.
 */
export const getRuntimeLogs403Schema = z.unknown() as unknown as ToZod<GetRuntimeLogs403>

export const getRuntimeLogsQueryResponseSchema = z.lazy(() => getRuntimeLogs200Schema) as unknown as ToZod<GetRuntimeLogsQueryResponse>

export const postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsPathParamsSchema = z.object({
  integrationConfigurationId: z.string(),
  resourceId: z.string(),
}) as unknown as ToZod<Postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsPathParams>

/**
 * @description The items were created
 */
export const postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitems204Schema =
  z.unknown() as unknown as ToZod<Postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitems204>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitems400Schema =
  z.unknown() as unknown as ToZod<Postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitems400>

export const postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitems401Schema =
  z.unknown() as unknown as ToZod<Postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitems401>

/**
 * @description You do not have permission to access this resource.
 */
export const postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitems403Schema =
  z.unknown() as unknown as ToZod<Postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitems403>

export const postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitems404Schema =
  z.unknown() as unknown as ToZod<Postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitems404>

export const postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsMutationRequestSchema = z.object({
  items: z
    .array(
      z.object({
        id: z.string().max(1024),
        slug: z.string().max(1024),
        origin: z.string().max(2048),
        category: z.enum(['experiment', 'flag']).optional(),
        name: z.string().max(1024).optional(),
        description: z.string().max(1024).optional(),
        isArchived: z.boolean().optional(),
        createdAt: z.number().optional(),
        updatedAt: z.number().optional(),
      }),
    )
    .max(50),
}) as unknown as ToZod<Postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsMutationRequest>

export const postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsMutationResponseSchema = z.lazy(
  () => postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitems204Schema,
) as unknown as ToZod<Postv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsMutationResponse>

export const patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemIdPathParamsSchema = z.object({
  integrationConfigurationId: z.string(),
  resourceId: z.string(),
  itemId: z.string(),
}) as unknown as ToZod<Patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemIdPathParams>

/**
 * @description The item was updated
 */
export const patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId204Schema =
  z.unknown() as unknown as ToZod<Patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId204>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId400Schema =
  z.unknown() as unknown as ToZod<Patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId400>

export const patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId401Schema =
  z.unknown() as unknown as ToZod<Patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId401>

/**
 * @description You do not have permission to access this resource.
 */
export const patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId403Schema =
  z.unknown() as unknown as ToZod<Patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId403>

export const patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId404Schema =
  z.unknown() as unknown as ToZod<Patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId404>

export const patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemIdMutationRequestSchema = z.object({
  slug: z.string().max(1024),
  origin: z.string().max(2048),
  name: z.string().max(1024).optional(),
  category: z.enum(['experiment', 'flag']).optional(),
  description: z.string().max(1024).optional(),
  isArchived: z.boolean().optional(),
  createdAt: z.number().optional(),
  updatedAt: z.number().optional(),
}) as unknown as ToZod<Patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemIdMutationRequest>

export const patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemIdMutationResponseSchema = z.lazy(
  () => patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId204Schema,
) as unknown as ToZod<Patchv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemIdMutationResponse>

export const deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemIdPathParamsSchema = z.object({
  integrationConfigurationId: z.string(),
  resourceId: z.string(),
  itemId: z.string(),
}) as unknown as ToZod<Deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemIdPathParams>

/**
 * @description The item was deleted
 */
export const deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId204Schema =
  z.unknown() as unknown as ToZod<Deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId204>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId400Schema =
  z.unknown() as unknown as ToZod<Deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId400>

export const deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId401Schema =
  z.unknown() as unknown as ToZod<Deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId401>

/**
 * @description You do not have permission to access this resource.
 */
export const deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId403Schema =
  z.unknown() as unknown as ToZod<Deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId403>

export const deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId404Schema =
  z.unknown() as unknown as ToZod<Deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId404>

export const deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemIdMutationResponseSchema = z.lazy(
  () => deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemId204Schema,
) as unknown as ToZod<Deletev1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationitemsitemIdMutationResponse>

export const headV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfigPathParamsSchema = z.object({
  integrationConfigurationId: z.string(),
  resourceId: z.string(),
}) as unknown as ToZod<HeadV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfigPathParams>

/**
 * @description The Edge Config data
 */
export const headV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig200Schema = z.object({
  items: z.object({}).catchall(z.lazy(() => edgeConfigItemValueSchema).nullable()),
  updatedAt: z.number(),
  digest: z.string(),
}) as unknown as ToZod<HeadV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig200>

export const headV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig304Schema =
  z.unknown() as unknown as ToZod<HeadV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig304>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const headV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig400Schema =
  z.unknown() as unknown as ToZod<HeadV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig400>

export const headV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig401Schema =
  z.unknown() as unknown as ToZod<HeadV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig401>

/**
 * @description You do not have permission to access this resource.
 */
export const headV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig403Schema =
  z.unknown() as unknown as ToZod<HeadV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig403>

export const headV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig404Schema =
  z.unknown() as unknown as ToZod<HeadV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig404>

export const headV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfigMutationResponseSchema = z.lazy(
  () => headV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfig200Schema,
) as unknown as ToZod<HeadV1InstallationsIntegrationconfigurationidResourcesResourceidExperimentationEdgeConfigMutationResponse>

export const putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfigPathParamsSchema = z.object({
  integrationConfigurationId: z.string(),
  resourceId: z.string(),
}) as unknown as ToZod<Putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfigPathParams>

/**
 * @description The Edge Config was updated
 */
export const putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig200Schema = z.object({
  items: z.object({}).catchall(z.lazy(() => edgeConfigItemValueSchema).nullable()),
  updatedAt: z.number(),
  digest: z.string(),
}) as unknown as ToZod<Putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig400Schema =
  z.unknown() as unknown as ToZod<Putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig400>

export const putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig401Schema =
  z.unknown() as unknown as ToZod<Putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig401>

/**
 * @description You do not have permission to access this resource.
 */
export const putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig403Schema =
  z.unknown() as unknown as ToZod<Putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig403>

export const putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig404Schema =
  z.unknown() as unknown as ToZod<Putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig404>

export const putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig412Schema =
  z.unknown() as unknown as ToZod<Putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig412>

export const putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfigMutationRequestSchema = z.object({
  data: z.object({}).catchall(z.unknown()),
}) as unknown as ToZod<Putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfigMutationRequest>

export const putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfigMutationResponseSchema = z.lazy(
  () => putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfig200Schema,
) as unknown as ToZod<Putv1InstallationsintegrationConfigurationIdresourcesresourceIdexperimentationedgeConfigMutationResponse>

export const getProjectMembersPathParamsSchema = z.object({
  idOrName: z.string().describe('The ID or name of the Project.'),
}) as unknown as ToZod<GetProjectMembersPathParams>

export const getProjectMembersQueryParamsSchema = z
  .object({
    limit: z.coerce.number().int().min(1).max(100).describe('Limit how many project members should be returned').optional(),
    since: z.coerce.number().int().describe('Timestamp in milliseconds to only include members added since then.').optional(),
    until: z.coerce.number().int().describe('Timestamp in milliseconds to only include members added until then.').optional(),
    search: z.string().describe('Search project members by their name, username, and email.').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetProjectMembersQueryParams>

/**
 * @description Paginated list of members for the project.
 */
export const getProjectMembers200Schema = z.union([
  z.object({}),
  z.object({
    members: z.array(
      z.object({
        avatar: z.string().describe('ID of the file for the Avatar of this member.').optional(),
        email: z.string().describe('The email of this member.'),
        role: z.enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER']).describe('Role of this user in the project.'),
        computedProjectRole: z.enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER']).describe('Role of this user in the project.'),
        uid: z.string().describe('The ID of this user.'),
        username: z.string().describe('The unique username of this user.'),
        name: z.string().describe('The name of this user.').optional(),
        createdAt: z.number().describe('Timestamp in milliseconds when this member was added.'),
        teamRole: z.enum(['OWNER', 'MEMBER', 'DEVELOPER', 'SECURITY', 'BILLING', 'VIEWER', 'CONTRIBUTOR']).describe('The role of this user in the team.'),
      }),
    ),
    pagination: z.object({
      hasNext: z.boolean(),
      count: z.number().describe('Amount of items in the current page.'),
      next: z.number().describe('Timestamp that must be used to request the next page.').nullable(),
      prev: z.number().describe('Timestamp that must be used to request the previous page.').nullable(),
    }),
  }),
]) as unknown as ToZod<GetProjectMembers200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getProjectMembers400Schema = z.unknown() as unknown as ToZod<GetProjectMembers400>

export const getProjectMembers401Schema = z.unknown() as unknown as ToZod<GetProjectMembers401>

/**
 * @description You do not have permission to access this resource.
 */
export const getProjectMembers403Schema = z.unknown() as unknown as ToZod<GetProjectMembers403>

export const getProjectMembersQueryResponseSchema = z.lazy(() => getProjectMembers200Schema) as unknown as ToZod<GetProjectMembersQueryResponse>

export const addProjectMemberPathParamsSchema = z.object({
  idOrName: z.string().describe('The ID or name of the Project.'),
}) as unknown as ToZod<AddProjectMemberPathParams>

export const addProjectMemberQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<AddProjectMemberQueryParams>

/**
 * @description Responds with the project ID on success.
 */
export const addProjectMember200Schema = z
  .object({
    id: z.string(),
  })
  .describe('Responds with the project ID on success.') as unknown as ToZod<AddProjectMember200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const addProjectMember400Schema = z.unknown() as unknown as ToZod<AddProjectMember400>

export const addProjectMember401Schema = z.unknown() as unknown as ToZod<AddProjectMember401>

/**
 * @description You do not have permission to access this resource.
 */
export const addProjectMember403Schema = z.unknown() as unknown as ToZod<AddProjectMember403>

export const addProjectMember500Schema = z.unknown() as unknown as ToZod<AddProjectMember500>

export const addProjectMemberMutationRequestSchema = z.unknown() as unknown as ToZod<AddProjectMemberMutationRequest>

export const addProjectMemberMutationResponseSchema = z.lazy(() => addProjectMember200Schema) as unknown as ToZod<AddProjectMemberMutationResponse>

export const removeProjectMemberPathParamsSchema = z.object({
  idOrName: z.string().describe('The ID or name of the Project.'),
  uid: z.string().describe('The user ID of the member.'),
}) as unknown as ToZod<RemoveProjectMemberPathParams>

export const removeProjectMemberQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<RemoveProjectMemberQueryParams>

export const removeProjectMember200Schema = z.object({
  id: z.string(),
}) as unknown as ToZod<RemoveProjectMember200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const removeProjectMember400Schema = z.unknown() as unknown as ToZod<RemoveProjectMember400>

export const removeProjectMember401Schema = z.unknown() as unknown as ToZod<RemoveProjectMember401>

/**
 * @description You do not have permission to access this resource.
 */
export const removeProjectMember403Schema = z.unknown() as unknown as ToZod<RemoveProjectMember403>

export const removeProjectMemberMutationResponseSchema = z.lazy(() => removeProjectMember200Schema) as unknown as ToZod<RemoveProjectMemberMutationResponse>

export const getProjectsQueryParamsSchema = z
  .object({
    from: z.string().describe('Query only projects updated after the given timestamp').optional(),
    gitForkProtection: z
      .enum(['1', '0'])
      .describe("Specifies whether PRs from Git forks should require a team member's authorization before it can be deployed")
      .optional(),
    limit: z.string().describe('Limit the number of projects returned').optional(),
    search: z.string().max(100).describe('Search projects by the name field').optional(),
    repo: z.string().describe('Filter results by repo. Also used for project count').optional(),
    repoId: z.string().describe('Filter results by Repository ID.').optional(),
    repoUrl: z.string().describe('Filter results by Repository URL.').optional(),
    excludeRepos: z.string().describe('Filter results by excluding those projects that belong to a repo').optional(),
    edgeConfigId: z.string().describe('Filter results by connected Edge Config ID').optional(),
    edgeConfigTokenId: z.string().describe('Filter results by connected Edge Config Token ID').optional(),
    deprecated: z.boolean().optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetProjectsQueryParams>

/**
 * @description The paginated list of projects
 */
export const getProjects200Schema = z
  .object({
    projects: z.array(
      z.object({
        accountId: z.string(),
        analytics: z
          .object({
            id: z.string(),
            canceledAt: z.number().nullable().nullish(),
            disabledAt: z.number(),
            enabledAt: z.number(),
            paidAt: z.number().optional(),
            sampleRatePercent: z.number().nullable().nullish(),
            spendLimitInDollars: z.number().nullable().nullish(),
          })
          .optional(),
        speedInsights: z
          .object({
            id: z.string(),
            enabledAt: z.number().optional(),
            disabledAt: z.number().optional(),
            canceledAt: z.number().optional(),
            hasData: z.boolean().optional(),
            paidAt: z.number().optional(),
          })
          .optional(),
        autoExposeSystemEnvs: z.boolean().optional(),
        autoAssignCustomDomains: z.boolean().optional(),
        autoAssignCustomDomainsUpdatedBy: z.string().optional(),
        buildCommand: z.string().nullable().nullish(),
        commandForIgnoringBuildStep: z.string().nullable().nullish(),
        connectConfigurations: z
          .array(
            z.object({
              envId: z.union([z.string(), z.enum(['production', 'preview'])]),
              connectConfigurationId: z.string(),
              passive: z.boolean(),
              buildsEnabled: z.boolean(),
              aws: z
                .object({
                  subnetIds: z.array(z.string()),
                  securityGroupId: z.string(),
                })
                .optional(),
              createdAt: z.number(),
              updatedAt: z.number(),
            }),
          )
          .nullable()
          .nullish(),
        connectConfigurationId: z.string().nullable().nullish(),
        connectBuildsEnabled: z.boolean().optional(),
        passiveConnectConfigurationId: z.string().nullable().nullish(),
        createdAt: z.number().optional(),
        customerSupportCodeVisibility: z.boolean().optional(),
        crons: z
          .object({
            enabledAt: z
              .number()
              .describe('The time the feature was enabled for this project. Note: It enables automatically with the first Deployment that outputs cronjobs.'),
            disabledAt: z.number().describe('The time the feature was disabled for this project.').nullable(),
            updatedAt: z.number(),
            deploymentId: z.string().describe('The ID of the Deployment from which the definitions originated.').nullable(),
            definitions: z.array(
              z.object({
                host: z.string().describe('The hostname that should be used.'),
                path: z.string().describe('The path that should be called for the cronjob.'),
                schedule: z.string().describe('The cron expression.'),
              }),
            ),
          })
          .optional(),
        dataCache: z
          .object({
            userDisabled: z.boolean(),
            storageSizeBytes: z.number().nullable().nullish(),
            unlimited: z.boolean().optional(),
          })
          .optional(),
        deploymentExpiration: z
          .object({
            expirationDays: z.number().optional(),
            expirationDaysProduction: z.number().optional(),
            expirationDaysCanceled: z.number().optional(),
            expirationDaysErrored: z.number().optional(),
            deploymentsToKeep: z.number().optional(),
          })
          .nullable()
          .nullish(),
        devCommand: z.string().nullable().nullish(),
        directoryListing: z.boolean(),
        installCommand: z.string().nullable().nullish(),
        env: z
          .array(
            z.object({
              target: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])]).optional(),
              type: z.enum(['encrypted', 'plain', 'secret', 'sensitive', 'system']),
              sunsetSecretId: z.string().describe('This is used to identiy variables that have been migrated from type secret to sensitive.').optional(),
              decrypted: z.boolean().optional(),
              value: z.string(),
              vsmValue: z.string().optional(),
              id: z.string().optional(),
              key: z.string(),
              configurationId: z.string().nullable().nullish(),
              createdAt: z.number().optional(),
              updatedAt: z.number().optional(),
              createdBy: z.string().nullable().nullish(),
              updatedBy: z.string().nullable().nullish(),
              gitBranch: z.string().optional(),
              edgeConfigId: z.string().nullable().nullish(),
              edgeConfigTokenId: z.string().nullable().nullish(),
              contentHint: z
                .union([
                  z.object({
                    type: z.enum(['redis-url']),
                    storeId: z.string(),
                  }),
                  z.object({
                    type: z.enum(['redis-rest-api-url']),
                    storeId: z.string(),
                  }),
                  z.object({
                    type: z.enum(['redis-rest-api-token']),
                    storeId: z.string(),
                  }),
                  z.object({
                    type: z.enum(['redis-rest-api-read-only-token']),
                    storeId: z.string(),
                  }),
                  z.object({
                    type: z.enum(['blob-read-write-token']),
                    storeId: z.string(),
                  }),
                  z.object({
                    type: z.enum(['postgres-url']),
                    storeId: z.string(),
                  }),
                  z.object({
                    type: z.enum(['postgres-url-non-pooling']),
                    storeId: z.string(),
                  }),
                  z.object({
                    type: z.enum(['postgres-prisma-url']),
                    storeId: z.string(),
                  }),
                  z.object({
                    type: z.enum(['postgres-user']),
                    storeId: z.string(),
                  }),
                  z.object({
                    type: z.enum(['postgres-host']),
                    storeId: z.string(),
                  }),
                  z.object({
                    type: z.enum(['postgres-password']),
                    storeId: z.string(),
                  }),
                  z.object({
                    type: z.enum(['postgres-database']),
                    storeId: z.string(),
                  }),
                  z.object({
                    type: z.enum(['postgres-url-no-ssl']),
                    storeId: z.string(),
                  }),
                  z.object({
                    type: z.enum(['integration-store-secret']),
                    storeId: z.string(),
                    integrationId: z.string(),
                    integrationProductId: z.string(),
                    integrationConfigurationId: z.string(),
                  }),
                  z.object({
                    type: z.enum(['flags-connection-string']),
                    projectId: z.string(),
                  }),
                ])
                .nullable()
                .nullish(),
              internalContentHint: z
                .object({
                  type: z.enum(['flags-secret']),
                  encryptedValue: z
                    .string()
                    .describe('Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.'),
                })
                .describe('Similar to `contentHints`, but should not be exposed to the user.')
                .nullable()
                .nullish(),
              comment: z.string().optional(),
              customEnvironmentIds: z.array(z.string()).optional(),
            }),
          )
          .optional(),
        customEnvironments: z
          .array(
            z
              .object({
                id: z.string().describe('Unique identifier for the custom environment (format: env_*)'),
                slug: z.string().describe('URL-friendly name of the environment'),
                type: z.enum(['development', 'preview', 'production']).describe('The type of environment (production, preview, or development)'),
                description: z.string().describe("Optional description of the environment's purpose").optional(),
                branchMatcher: z
                  .object({
                    type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
                    pattern: z.string().describe('The pattern to match against branch names'),
                  })
                  .describe('Configuration for matching git branches to this environment')
                  .optional(),
                domains: z
                  .array(
                    z
                      .object({
                        name: z.string(),
                        apexName: z.string(),
                        projectId: z.string(),
                        redirect: z.string().nullable().nullish(),
                        redirectStatusCode: z
                          .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
                          .nullable()
                          .nullish(),
                        gitBranch: z.string().nullable().nullish(),
                        customEnvironmentId: z.string().nullable().nullish(),
                        updatedAt: z.number().optional(),
                        createdAt: z.number().optional(),
                        verified: z
                          .boolean()
                          .describe(
                            '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
                          ),
                        verification: z
                          .array(
                            z
                              .object({
                                type: z.string(),
                                domain: z.string(),
                                value: z.string(),
                                reason: z.string(),
                              })
                              .describe(
                                'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                              ),
                          )
                          .describe(
                            'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                          )
                          .optional(),
                      })
                      .describe('List of domains associated with this environment'),
                  )
                  .describe('List of domains associated with this environment')
                  .optional(),
                currentDeploymentAliases: z.array(z.string()).describe('List of aliases for the current deployment').optional(),
                createdAt: z.number().describe('Timestamp when the environment was created'),
                updatedAt: z.number().describe('Timestamp when the environment was last updated'),
              })
              .describe('Internal representation of a custom environment with all required properties'),
          )
          .optional(),
        framework: z
          .enum([
            'angular',
            'astro',
            'blitzjs',
            'brunch',
            'create-react-app',
            'docusaurus',
            'docusaurus-2',
            'dojo',
            'eleventy',
            'ember',
            'fasthtml',
            'gatsby',
            'gridsome',
            'hexo',
            'hugo',
            'hydrogen',
            'ionic-angular',
            'ionic-react',
            'jekyll',
            'middleman',
            'nextjs',
            'nitro',
            'nuxtjs',
            'parcel',
            'polymer',
            'preact',
            'react-router',
            'redwoodjs',
            'remix',
            'saber',
            'sanity',
            'sanity-v3',
            'sapper',
            'scully',
            'solidstart',
            'solidstart-1',
            'stencil',
            'storybook',
            'svelte',
            'sveltekit',
            'sveltekit-1',
            'umijs',
            'vite',
            'vitepress',
            'vue',
            'vuepress',
            'zola',
          ])
          .nullable()
          .nullish(),
        gitForkProtection: z.boolean().optional(),
        gitLFS: z.boolean().optional(),
        id: z.string(),
        ipBuckets: z
          .array(
            z.object({
              bucket: z.string(),
              supportUntil: z.number().optional(),
            }),
          )
          .optional(),
        latestDeployments: z
          .array(
            z.object({
              id: z.string(),
              alias: z.array(z.string()).optional(),
              aliasAssigned: z.union([z.boolean(), z.number()]).nullable().nullish(),
              aliasError: z
                .object({
                  code: z.string(),
                  message: z.string(),
                })
                .nullable()
                .nullish(),
              aliasFinal: z.string().nullable().nullish(),
              automaticAliases: z.array(z.string()).optional(),
              branchMatcher: z
                .object({
                  type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
                  pattern: z.string().describe('The pattern to match against branch names'),
                })
                .optional(),
              buildingAt: z.number().optional(),
              builds: z
                .array(
                  z.object({
                    use: z.string(),
                    src: z.string().optional(),
                    dest: z.string().optional(),
                  }),
                )
                .optional(),
              checksConclusion: z.enum(['canceled', 'failed', 'skipped', 'succeeded']).optional(),
              checksState: z.enum(['completed', 'registered', 'running']).optional(),
              connectBuildsEnabled: z.boolean().optional(),
              connectConfigurationId: z.string().optional(),
              createdAt: z.number(),
              createdIn: z.string(),
              creator: z
                .object({
                  email: z.string(),
                  githubLogin: z.string().optional(),
                  gitlabLogin: z.string().optional(),
                  uid: z.string(),
                  username: z.string(),
                })
                .nullable(),
              deletedAt: z.number().optional(),
              deploymentHostname: z.string(),
              forced: z.boolean().optional(),
              name: z.string(),
              meta: z.object({}).catchall(z.string()).optional(),
              monorepoManager: z.string().nullable().nullish(),
              oidcTokenClaims: z
                .object({
                  iss: z.string(),
                  sub: z.string(),
                  scope: z.string(),
                  aud: z.string(),
                  owner: z.string(),
                  owner_id: z.string(),
                  project: z.string(),
                  project_id: z.string(),
                  environment: z.string(),
                })
                .optional(),
              plan: z.enum(['enterprise', 'hobby', 'pro']),
              previewCommentsEnabled: z.boolean().describe('Whether or not preview comments are enabled for the deployment').optional(),
              private: z.boolean(),
              readyAt: z.number().optional(),
              readyState: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
              readySubstate: z.enum(['PROMOTED', 'ROLLING', 'STAGED']).optional(),
              requestedAt: z.number().optional(),
              target: z.string().nullable().nullish(),
              teamId: z.string().nullable().nullish(),
              type: z.enum(['LAMBDAS']),
              url: z.string(),
              userId: z.string(),
              withCache: z.boolean().optional(),
            }),
          )
          .optional(),
        link: z
          .union([
            z.object({
              org: z.string().optional(),
              repoOwnerId: z
                .number()
                .describe(
                  'A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.',
                )
                .optional(),
              repo: z.string().optional(),
              repoId: z.number().optional(),
              type: z.enum(['github']).optional(),
              createdAt: z.number().optional(),
              deployHooks: z.array(
                z.object({
                  createdAt: z.number().optional(),
                  id: z.string(),
                  name: z.string(),
                  ref: z.string(),
                  url: z.string(),
                }),
              ),
              gitCredentialId: z.string().optional(),
              updatedAt: z.number().optional(),
              sourceless: z.boolean().optional(),
              productionBranch: z.string().optional(),
            }),
            z.object({
              projectId: z.string().optional(),
              projectName: z.string().optional(),
              projectNameWithNamespace: z.string().optional(),
              projectNamespace: z.string().optional(),
              projectOwnerId: z
                .number()
                .describe(
                  'A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes. This is the id of the top level group that a namespace belongs to. Gitlab supports group nesting (up to 20 levels).',
                )
                .optional(),
              projectUrl: z.string().optional(),
              type: z.enum(['gitlab']).optional(),
              createdAt: z.number().optional(),
              deployHooks: z.array(
                z.object({
                  createdAt: z.number().optional(),
                  id: z.string(),
                  name: z.string(),
                  ref: z.string(),
                  url: z.string(),
                }),
              ),
              gitCredentialId: z.string().optional(),
              updatedAt: z.number().optional(),
              sourceless: z.boolean().optional(),
              productionBranch: z.string().optional(),
            }),
            z.object({
              name: z.string().optional(),
              slug: z.string().optional(),
              owner: z.string().optional(),
              type: z.enum(['bitbucket']).optional(),
              uuid: z.string().optional(),
              workspaceUuid: z.string().optional(),
              createdAt: z.number().optional(),
              deployHooks: z.array(
                z.object({
                  createdAt: z.number().optional(),
                  id: z.string(),
                  name: z.string(),
                  ref: z.string(),
                  url: z.string(),
                }),
              ),
              gitCredentialId: z.string().optional(),
              updatedAt: z.number().optional(),
              sourceless: z.boolean().optional(),
              productionBranch: z.string().optional(),
            }),
            z.object({
              org: z.string().optional(),
              repoOwnerId: z
                .number()
                .describe(
                  'A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.',
                )
                .optional(),
              repo: z.string().optional(),
              repoId: z.number().optional(),
              type: z.enum(['github-custom-host']).optional(),
              host: z.string().optional(),
              createdAt: z.number().optional(),
              deployHooks: z.array(
                z.object({
                  createdAt: z.number().optional(),
                  id: z.string(),
                  name: z.string(),
                  ref: z.string(),
                  url: z.string(),
                }),
              ),
              gitCredentialId: z.string().optional(),
              updatedAt: z.number().optional(),
              sourceless: z.boolean().optional(),
              productionBranch: z.string().optional(),
            }),
          ])
          .optional(),
        microfrontends: z
          .union([
            z.object({
              updatedAt: z.number().describe('Timestamp when the microfrontends settings were last updated.'),
              groupIds: z
                .array(z.union([z.string(), z.string()]))
                .min(2)
                .max(2)
                .describe(
                  'The group IDs of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.',
                ),
              enabled: z.boolean().describe('Whether microfrontends are enabled for this project.'),
              isDefaultApp: z
                .boolean()
                .describe(
                  'Whether this project is the default application for the microfrontends group. The default application is the one that is used as the top level shell for the microfrontends group and hosts the other microfrontends.',
                )
                .optional(),
              defaultRoute: z
                .string()
                .describe(
                  'A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI. Includes the leading slash, e.g. `/docs`',
                )
                .optional(),
              routeObservabilityToThisProject: z
                .boolean()
                .describe('Whether observability data should be routed to this microfrontend project or a root project.')
                .optional(),
            }),
            z.object({
              updatedAt: z.number(),
              groupIds: z
                .array(z.union([z.string(), z.string()]))
                .min(2)
                .max(2),
              enabled: z.boolean(),
            }),
          ])
          .optional(),
        name: z.string(),
        nodeVersion: z.enum(['10.x', '12.x', '14.x', '16.x', '18.x', '20.x', '22.x', '8.10.x']),
        optionsAllowlist: z
          .object({
            paths: z.array(
              z.object({
                value: z.string(),
              }),
            ),
          })
          .nullable()
          .nullish(),
        outputDirectory: z.string().nullable().nullish(),
        passwordProtection: z.object({}).nullable().nullish(),
        productionDeploymentsFastLane: z.boolean().optional(),
        publicSource: z.boolean().nullable().nullish(),
        resourceConfig: z.object({
          fluid: z.boolean().optional(),
          functionDefaultRegions: z.array(z.string()),
          functionDefaultTimeout: z.number().optional(),
          functionDefaultMemoryType: z.enum(['performance', 'standard', 'standard_legacy']).optional(),
          functionZeroConfigFailover: z.boolean().optional(),
          elasticConcurrencyEnabled: z.boolean().optional(),
          buildMachineType: z.enum(['enhanced', 'turbo']).optional(),
        }),
        rollbackDescription: z
          .object({
            userId: z.string().describe('The user who rolled back the project.'),
            username: z.string().describe('The username of the user who rolled back the project.'),
            description: z.string().describe('User-supplied explanation of why they rolled back the project. Limited to 250 characters.'),
            createdAt: z.number().describe('Timestamp of when the rollback was requested.'),
          })
          .describe('Description of why a project was rolled back, and by whom. Note that lastAliasRequest contains the from/to details of the rollback.')
          .optional(),
        rollingRelease: z
          .object({
            target: z
              .string()
              .describe(
                'The environment that the release targets, currently only supports production. Adding in case we want to configure with alias groups or custom environments.',
              ),
            stages: z
              .array(
                z
                  .object({
                    targetPercentage: z.number().describe('The percentage of traffic to serve to the canary deployment (0-100)'),
                    requireApproval: z.boolean().describe('Whether or not this stage requires manual approval to proceed').optional(),
                    duration: z.number().describe('Duration in minutes for automatic advancement to the next stage').optional(),
                  })
                  .describe(
                    'An array of all the stages required during a deployment release. Each stage defines a target percentage and advancement rules. The final stage must always have targetPercentage: 100.',
                  ),
              )
              .describe(
                'An array of all the stages required during a deployment release. Each stage defines a target percentage and advancement rules. The final stage must always have targetPercentage: 100.',
              )
              .nullable()
              .nullish(),
            canaryResponseHeader: z
              .boolean()
              .describe(
                'Whether the request served by a canary deployment should return a header indicating a canary was served. Defaults to `false` when omitted.',
              )
              .optional(),
          })
          .describe('Project-level rolling release configuration that defines how deployments should be gradually rolled out')
          .nullable()
          .nullish(),
        defaultResourceConfig: z.object({
          fluid: z.boolean().optional(),
          functionDefaultRegions: z.array(z.string()),
          functionDefaultTimeout: z.number().optional(),
          functionDefaultMemoryType: z.enum(['performance', 'standard', 'standard_legacy']).optional(),
          functionZeroConfigFailover: z.boolean().optional(),
          elasticConcurrencyEnabled: z.boolean().optional(),
          buildMachineType: z.enum(['enhanced', 'turbo']).optional(),
        }),
        rootDirectory: z.string().nullable().nullish(),
        serverlessFunctionZeroConfigFailover: z.boolean().optional(),
        skewProtectionBoundaryAt: z.number().optional(),
        skewProtectionMaxAge: z.number().optional(),
        skipGitConnectDuringLink: z.boolean().optional(),
        sourceFilesOutsideRootDirectory: z.boolean().optional(),
        enableAffectedProjectsDeployments: z.boolean().optional(),
        ssoProtection: z
          .object({
            deploymentType: z.enum(['all', 'all_except_custom_domains', 'preview', 'prod_deployment_urls_and_all_previews']),
          })
          .nullable()
          .nullish(),
        targets: z
          .object({})
          .catchall(
            z
              .object({
                id: z.string(),
                alias: z.array(z.string()).optional(),
                aliasAssigned: z.union([z.boolean(), z.number()]).nullable().nullish(),
                aliasError: z
                  .object({
                    code: z.string(),
                    message: z.string(),
                  })
                  .nullable()
                  .nullish(),
                aliasFinal: z.string().nullable().nullish(),
                automaticAliases: z.array(z.string()).optional(),
                branchMatcher: z
                  .object({
                    type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
                    pattern: z.string().describe('The pattern to match against branch names'),
                  })
                  .optional(),
                buildingAt: z.number().optional(),
                builds: z
                  .array(
                    z.object({
                      use: z.string(),
                      src: z.string().optional(),
                      dest: z.string().optional(),
                    }),
                  )
                  .optional(),
                checksConclusion: z.enum(['canceled', 'failed', 'skipped', 'succeeded']).optional(),
                checksState: z.enum(['completed', 'registered', 'running']).optional(),
                connectBuildsEnabled: z.boolean().optional(),
                connectConfigurationId: z.string().optional(),
                createdAt: z.number(),
                createdIn: z.string(),
                creator: z
                  .object({
                    email: z.string(),
                    githubLogin: z.string().optional(),
                    gitlabLogin: z.string().optional(),
                    uid: z.string(),
                    username: z.string(),
                  })
                  .nullable(),
                deletedAt: z.number().optional(),
                deploymentHostname: z.string(),
                forced: z.boolean().optional(),
                name: z.string(),
                meta: z.object({}).catchall(z.string()).optional(),
                monorepoManager: z.string().nullable().nullish(),
                oidcTokenClaims: z
                  .object({
                    iss: z.string(),
                    sub: z.string(),
                    scope: z.string(),
                    aud: z.string(),
                    owner: z.string(),
                    owner_id: z.string(),
                    project: z.string(),
                    project_id: z.string(),
                    environment: z.string(),
                  })
                  .optional(),
                plan: z.enum(['enterprise', 'hobby', 'pro']),
                previewCommentsEnabled: z.boolean().describe('Whether or not preview comments are enabled for the deployment').optional(),
                private: z.boolean(),
                readyAt: z.number().optional(),
                readyState: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
                readySubstate: z.enum(['PROMOTED', 'ROLLING', 'STAGED']).optional(),
                requestedAt: z.number().optional(),
                target: z.string().nullable().nullish(),
                teamId: z.string().nullable().nullish(),
                type: z.enum(['LAMBDAS']),
                url: z.string(),
                userId: z.string(),
                withCache: z.boolean().optional(),
              })
              .nullable(),
          )
          .optional(),
        transferCompletedAt: z.number().optional(),
        transferStartedAt: z.number().optional(),
        transferToAccountId: z.string().optional(),
        transferredFromAccountId: z.string().optional(),
        updatedAt: z.number().optional(),
        live: z.boolean().optional(),
        enablePreviewFeedback: z.boolean().nullable().nullish(),
        enableProductionFeedback: z.boolean().nullable().nullish(),
        permissions: z
          .object({
            aliasProject: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            aliasProtectionBypass: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            buildMachine: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            productionAliasProtectionBypass: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            connectConfigurationLink: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            dataCacheNamespace: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            deployment: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            deploymentCheck: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            deploymentCheckPreview: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            deploymentCheckReRunFromProductionBranch: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            deploymentProductionGit: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            deploymentV0: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            deploymentPreview: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            deploymentPrivate: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            deploymentPromote: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            deploymentRollback: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            edgeCacheNamespace: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            environments: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            logs: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            logsPreset: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            passwordProtection: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            optionsAllowlist: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            job: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            observabilityData: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            onDemandBuild: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            onDemandConcurrency: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            project: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectFromV0: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectAccessGroup: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectAnalyticsSampling: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectCheck: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectCheckRun: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectDeploymentHook: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectDomain: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectDomainMove: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectDomainCheckConfig: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectEnvVars: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectEnvVarsProduction: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectEnvVarsUnownedByIntegration: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectFlags: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectId: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectIntegrationConfiguration: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectLink: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectMember: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectMonitoring: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectPermissions: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectProductionBranch: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectTransfer: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectTransferOut: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectProtectionBypass: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectUsage: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectAnalyticsUsage: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectSupportCase: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectSupportCaseComment: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectDeploymentExpiration: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectRollingRelease: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectTier: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            seawallConfig: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            skewProtection: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            analytics: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            trustedIps: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            webAnalytics: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            sharedEnvVarConnection: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            sonar: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            user: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            userConnection: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            userSudo: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            webAuthn: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            oauth2Connection: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            accessGroup: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            aliasGlobal: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            analyticsSampling: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            analyticsUsage: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            auditLog: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            billingAddress: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            billingInformation: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            billingInvoice: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            billingInvoiceEmailRecipient: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            billingInvoiceLanguage: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            billingPlan: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            billingPurchaseOrder: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            billingTaxId: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            blob: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            budget: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            cacheArtifact: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            cacheArtifactUsageEvent: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            codeChecks: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            concurrentBuilds: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            connect: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            connectConfiguration: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            defaultDeploymentProtection: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            domain: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            domainAcceptDelegation: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            domainAuthCodes: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            domainCertificate: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            domainCheckConfig: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            domainMove: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            domainPurchase: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            domainRecord: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            domainTransferIn: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            event: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            ownEvent: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            sensitiveEnvironmentVariablePolicy: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            fileUpload: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            flagsExplorerSubscription: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            gitRepository: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            ipBlocking: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            imageOptimizationNewPrice: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            integration: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            integrationAccount: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            integrationConfiguration: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            integrationConfigurationTransfer: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            integrationConfigurationProjects: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            integrationVercelConfigurationOverride: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            integrationConfigurationRole: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            integrationSSOSession: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            integrationResource: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            integrationEvent: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            integrationResourceSecrets: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            integrationDeploymentAction: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            marketplaceInstallationMember: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            marketplaceBillingData: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            marketplaceInvoice: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            marketplaceExperimentationItem: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            marketplaceExperimentationEdgeConfigData: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            jobGlobal: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            drain: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            logDrain: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            Monitoring: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            monitoringSettings: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            monitoringQuery: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            monitoringChart: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            monitoringAlert: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            notificationDeploymentFailed: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            notificationDomainConfiguration: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            notificationDomainExpire: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            notificationDomainMoved: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            notificationDomainPurchase: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            notificationDomainRenewal: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            notificationDomainTransfer: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            notificationDomainUnverified: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            NotificationMonitoringAlert: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            notificationPaymentFailed: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            notificationUsageAlert: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            notificationPreferences: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            notificationCustomerBudget: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            notificationStatementOfReasons: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            observabilityConfiguration: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            observabilityNotebook: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            observabilityFunnel: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            openTelemetryEndpoint: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            vercelAppInstallation: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            paymentMethod: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            permissions: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            postgres: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            previewDeploymentSuffix: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            proTrialOnboarding: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            sharedEnvVars: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            sharedEnvVarsProduction: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            space: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            spaceRun: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            passwordProtectionInvoiceItem: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            rateLimit: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            redis: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            repository: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            remoteCaching: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            samlConfig: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            secret: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            redisStoreTokenSet: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            blobStoreTokenSet: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            postgresStoreTokenSet: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            integrationStoreTokenSet: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            integrationResourceReplCommand: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            storeTransfer: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            supportCase: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            supportCaseComment: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            dataCacheBillingSettings: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            team: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            teamAccessRequest: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            teamFellowMembership: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            teamGitExclusivity: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            teamInvite: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            teamInviteCode: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            teamJoin: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            teamMemberMfaStatus: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            teamMicrofrontends: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            teamOwnMembership: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            teamOwnMembershipDisconnectSAML: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            token: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            usage: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            usageCycle: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            vpcPeeringConnection: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            webAnalyticsPlan: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            edgeConfig: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            edgeConfigItem: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            edgeConfigSchema: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            edgeConfigToken: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            webhook: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            'webhook-event': z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            endpointVerification: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            projectTransferIn: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            oauth2Application: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            vercelRun: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            vercelRunExec: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            apiKey: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
            apiKeyOwnedBySelf: z
              .array(
                z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'),
              )
              .optional(),
          })
          .optional(),
        lastRollbackTarget: z.object({}).nullable().nullish(),
        lastAliasRequest: z
          .object({
            fromDeploymentId: z.string(),
            toDeploymentId: z.string(),
            fromRollingReleaseId: z
              .string()
              .describe(
                'If rolling back from a rolling release, fromDeploymentId captures the "base" of that rolling release, and fromRollingReleaseId captures the "target" of that rolling release.',
              )
              .optional(),
            jobStatus: z.enum(['failed', 'in-progress', 'pending', 'skipped', 'succeeded']),
            requestedAt: z.number(),
            type: z.enum(['promote', 'rollback']),
          })
          .nullable()
          .nullish(),
        protectionBypass: z
          .object({})
          .catchall(
            z.union([
              z.object({
                createdAt: z.number(),
                createdBy: z.string(),
                scope: z.enum(['integration-automation-bypass']),
                integrationId: z.string(),
                configurationId: z.string(),
              }),
              z.object({
                createdAt: z.number(),
                createdBy: z.string(),
                scope: z.enum(['automation-bypass']),
              }),
            ]),
          )
          .optional(),
        hasActiveBranches: z.boolean().optional(),
        trustedIps: z
          .union([
            z.object({
              deploymentType: z.enum(['production', 'preview', 'all', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains']),
              addresses: z.array(
                z.object({
                  value: z.string(),
                  note: z.string().optional(),
                }),
              ),
              protectionMode: z.enum(['additional', 'exclusive']),
            }),
            z.object({
              deploymentType: z.enum(['production', 'preview', 'all', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains']),
            }),
          ])
          .nullable()
          .nullish(),
        gitComments: z
          .object({
            onPullRequest: z.boolean().describe('Whether the Vercel bot should comment on PRs'),
            onCommit: z.boolean().describe('Whether the Vercel bot should comment on commits'),
          })
          .optional(),
        gitProviderOptions: z
          .object({
            createDeployments: z
              .enum(['disabled', 'enabled'])
              .describe(
                'Whether the Vercel bot should automatically create GitHub deployments https://docs.github.com/en/rest/deployments/deployments#about-deployments NOTE: repository-dispatch events should be used instead',
              ),
          })
          .optional(),
        paused: z.boolean().optional(),
        concurrencyBucketName: z.string().optional(),
        webAnalytics: z
          .object({
            id: z.string(),
            disabledAt: z.number().optional(),
            canceledAt: z.number().optional(),
            enabledAt: z.number().optional(),
            hasData: z.boolean().optional(),
          })
          .optional(),
        security: z
          .object({
            attackModeEnabled: z.boolean().optional(),
            attackModeUpdatedAt: z.number().optional(),
            firewallEnabled: z.boolean().optional(),
            firewallUpdatedAt: z.number().optional(),
            attackModeActiveUntil: z.number().nullable().nullish(),
            firewallConfigVersion: z.number().optional(),
            firewallRoutes: z
              .array(
                z.object({
                  src: z
                    .union([
                      z.string(),
                      z.object({
                        re: z.string().optional(),
                        eq: z.string().optional(),
                        neq: z.string().optional(),
                        inc: z.array(z.string()).optional(),
                        ninc: z.array(z.string()).optional(),
                        pre: z.string().optional(),
                        suf: z.string().optional(),
                        gt: z.number().optional(),
                        gte: z.number().optional(),
                        lt: z.number().optional(),
                        lte: z.number().optional(),
                      }),
                    ])
                    .optional(),
                  has: z
                    .array(
                      z.object({
                        type: z.enum([
                          'cookie',
                          'environment',
                          'header',
                          'host',
                          'initial_request_path',
                          'ip_address',
                          'method',
                          'path',
                          'protocol',
                          'query',
                          'region',
                          'scheme',
                        ]),
                        key: z.string().optional(),
                        value: z
                          .union([
                            z.string(),
                            z.object({
                              re: z.string().optional(),
                              eq: z.string().optional(),
                              neq: z.string().optional(),
                              inc: z.array(z.string()).optional(),
                              ninc: z.array(z.string()).optional(),
                              pre: z.string().optional(),
                              suf: z.string().optional(),
                              gt: z.number().optional(),
                              gte: z.number().optional(),
                              lt: z.number().optional(),
                              lte: z.number().optional(),
                            }),
                          ])
                          .optional(),
                      }),
                    )
                    .optional(),
                  missing: z
                    .array(
                      z.object({
                        type: z.enum([
                          'cookie',
                          'environment',
                          'header',
                          'host',
                          'initial_request_path',
                          'ip_address',
                          'method',
                          'path',
                          'protocol',
                          'query',
                          'region',
                          'scheme',
                        ]),
                        key: z.string().optional(),
                        value: z
                          .union([
                            z.string(),
                            z.object({
                              re: z.string().optional(),
                              eq: z.string().optional(),
                              neq: z.string().optional(),
                              inc: z.array(z.string()).optional(),
                              ninc: z.array(z.string()).optional(),
                              pre: z.string().optional(),
                              suf: z.string().optional(),
                              gt: z.number().optional(),
                              gte: z.number().optional(),
                              lt: z.number().optional(),
                              lte: z.number().optional(),
                            }),
                          ])
                          .optional(),
                      }),
                    )
                    .optional(),
                  dest: z.string().optional(),
                  status: z.number().optional(),
                  handle: z.enum(['finalize', 'init']).optional(),
                  mitigate: z
                    .object({
                      action: z.enum(['bypass', 'challenge', 'deny', 'log', 'rate_limit', 'redirect']),
                      rule_id: z.string(),
                      ttl: z.number().optional(),
                      erl: z
                        .object({
                          algo: z.enum(['fixed_window', 'token_bucket']),
                          window: z.number(),
                          limit: z.number(),
                          keys: z.array(z.string()),
                        })
                        .optional(),
                    })
                    .optional(),
                }),
              )
              .optional(),
            firewallSeawallEnabled: z.boolean().optional(),
            ja3Enabled: z.boolean().optional(),
            ja4Enabled: z.boolean().optional(),
            firewallBypassIps: z.array(z.string()).optional(),
            managedRules: z
              .object({
                bot_filter: z.object({
                  active: z.boolean(),
                  action: z.enum(['challenge', 'deny', 'log']).optional(),
                }),
                ai_bots: z.object({
                  active: z.boolean(),
                  action: z.enum(['challenge', 'deny', 'log']).optional(),
                }),
                owasp: z.object({
                  active: z.boolean(),
                  action: z.enum(['challenge', 'deny', 'log']).optional(),
                }),
              })
              .nullable()
              .nullish(),
            botIdEnabled: z.boolean().optional(),
          })
          .optional(),
        oidcTokenConfig: z
          .object({
            enabled: z.boolean().describe('Whether or not to generate OpenID Connect JSON Web Tokens.').optional(),
            issuerMode: z.enum(['global', 'team']).describe('- team: `https://oidc.vercel.com/[team_slug]` - global: `https://oidc.vercel.com`').optional(),
          })
          .optional(),
        tier: z.enum(['advanced', 'critical', 'standard']).optional(),
        features: z
          .object({
            webAnalytics: z.boolean().optional(),
          })
          .optional(),
      }),
    ),
    pagination: z
      .lazy(() => paginationSchema)
      .describe(
        'This object contains information related to the pagination of the current request, including the necessary parameters to get the next or previous page of data.',
      ),
  })
  .describe('The paginated list of projects') as unknown as ToZod<GetProjects200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getProjects400Schema = z.unknown() as unknown as ToZod<GetProjects400>

export const getProjects401Schema = z.unknown() as unknown as ToZod<GetProjects401>

/**
 * @description You do not have permission to access this resource.
 */
export const getProjects403Schema = z.unknown() as unknown as ToZod<GetProjects403>

export const getProjectsQueryResponseSchema = z.lazy(() => getProjects200Schema) as unknown as ToZod<GetProjectsQueryResponse>

export const createProjectQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<CreateProjectQueryParams>

/**
 * @description The project was successfuly created
 */
export const createProject200Schema = z.object({
  accountId: z.string(),
  analytics: z
    .object({
      id: z.string(),
      canceledAt: z.number().nullable().nullish(),
      disabledAt: z.number(),
      enabledAt: z.number(),
      paidAt: z.number().optional(),
      sampleRatePercent: z.number().nullable().nullish(),
      spendLimitInDollars: z.number().nullable().nullish(),
    })
    .optional(),
  speedInsights: z
    .object({
      id: z.string(),
      enabledAt: z.number().optional(),
      disabledAt: z.number().optional(),
      canceledAt: z.number().optional(),
      hasData: z.boolean().optional(),
      paidAt: z.number().optional(),
    })
    .optional(),
  autoExposeSystemEnvs: z.boolean().optional(),
  autoAssignCustomDomains: z.boolean().optional(),
  autoAssignCustomDomainsUpdatedBy: z.string().optional(),
  buildCommand: z.string().nullable().nullish(),
  commandForIgnoringBuildStep: z.string().nullable().nullish(),
  connectConfigurations: z
    .array(
      z.object({
        envId: z.union([z.string(), z.enum(['preview', 'production'])]),
        connectConfigurationId: z.string(),
        passive: z.boolean(),
        buildsEnabled: z.boolean(),
        aws: z
          .object({
            subnetIds: z.array(z.string()),
            securityGroupId: z.string(),
          })
          .optional(),
        createdAt: z.number(),
        updatedAt: z.number(),
      }),
    )
    .nullable()
    .nullish(),
  connectConfigurationId: z.string().nullable().nullish(),
  connectBuildsEnabled: z.boolean().optional(),
  passiveConnectConfigurationId: z.string().nullable().nullish(),
  createdAt: z.number().optional(),
  customerSupportCodeVisibility: z.boolean().optional(),
  crons: z
    .object({
      enabledAt: z
        .number()
        .describe('The time the feature was enabled for this project. Note: It enables automatically with the first Deployment that outputs cronjobs.'),
      disabledAt: z.number().describe('The time the feature was disabled for this project.').nullable(),
      updatedAt: z.number(),
      deploymentId: z.string().describe('The ID of the Deployment from which the definitions originated.').nullable(),
      definitions: z.array(
        z.object({
          host: z.string().describe('The hostname that should be used.'),
          path: z.string().describe('The path that should be called for the cronjob.'),
          schedule: z.string().describe('The cron expression.'),
        }),
      ),
    })
    .optional(),
  dataCache: z
    .object({
      userDisabled: z.boolean(),
      storageSizeBytes: z.number().nullable().nullish(),
      unlimited: z.boolean().optional(),
    })
    .optional(),
  deploymentExpiration: z
    .object({
      expirationDays: z.number().optional(),
      expirationDaysProduction: z.number().optional(),
      expirationDaysCanceled: z.number().optional(),
      expirationDaysErrored: z.number().optional(),
      deploymentsToKeep: z.number().optional(),
    })
    .nullable()
    .nullish(),
  devCommand: z.string().nullable().nullish(),
  directoryListing: z.boolean(),
  installCommand: z.string().nullable().nullish(),
  env: z
    .array(
      z.object({
        target: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])]).optional(),
        type: z.enum(['encrypted', 'plain', 'secret', 'sensitive', 'system']),
        sunsetSecretId: z.string().describe('This is used to identiy variables that have been migrated from type secret to sensitive.').optional(),
        decrypted: z.boolean().optional(),
        value: z.string(),
        vsmValue: z.string().optional(),
        id: z.string().optional(),
        key: z.string(),
        configurationId: z.string().nullable().nullish(),
        createdAt: z.number().optional(),
        updatedAt: z.number().optional(),
        createdBy: z.string().nullable().nullish(),
        updatedBy: z.string().nullable().nullish(),
        gitBranch: z.string().optional(),
        edgeConfigId: z.string().nullable().nullish(),
        edgeConfigTokenId: z.string().nullable().nullish(),
        contentHint: z
          .union([
            z.object({
              type: z.enum(['redis-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-read-only-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['blob-read-write-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url-non-pooling']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-prisma-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-user']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-host']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-password']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-database']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url-no-ssl']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['integration-store-secret']),
              storeId: z.string(),
              integrationId: z.string(),
              integrationProductId: z.string(),
              integrationConfigurationId: z.string(),
            }),
            z.object({
              type: z.enum(['flags-connection-string']),
              projectId: z.string(),
            }),
          ])
          .nullable()
          .nullish(),
        internalContentHint: z
          .object({
            type: z.enum(['flags-secret']),
            encryptedValue: z
              .string()
              .describe('Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.'),
          })
          .describe('Similar to `contentHints`, but should not be exposed to the user.')
          .nullable()
          .nullish(),
        comment: z.string().optional(),
        customEnvironmentIds: z.array(z.string()).optional(),
      }),
    )
    .optional(),
  customEnvironments: z
    .array(
      z
        .object({
          id: z.string().describe('Unique identifier for the custom environment (format: env_*)'),
          slug: z.string().describe('URL-friendly name of the environment'),
          type: z.enum(['development', 'preview', 'production']).describe('The type of environment (production, preview, or development)'),
          description: z.string().describe("Optional description of the environment's purpose").optional(),
          branchMatcher: z
            .object({
              type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
              pattern: z.string().describe('The pattern to match against branch names'),
            })
            .describe('Configuration for matching git branches to this environment')
            .optional(),
          domains: z
            .array(
              z
                .object({
                  name: z.string(),
                  apexName: z.string(),
                  projectId: z.string(),
                  redirect: z.string().nullable().nullish(),
                  redirectStatusCode: z
                    .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
                    .nullable()
                    .nullish(),
                  gitBranch: z.string().nullable().nullish(),
                  customEnvironmentId: z.string().nullable().nullish(),
                  updatedAt: z.number().optional(),
                  createdAt: z.number().optional(),
                  verified: z
                    .boolean()
                    .describe(
                      '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
                    ),
                  verification: z
                    .array(
                      z
                        .object({
                          type: z.string(),
                          domain: z.string(),
                          value: z.string(),
                          reason: z.string(),
                        })
                        .describe(
                          'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                        ),
                    )
                    .describe(
                      'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                    )
                    .optional(),
                })
                .describe('List of domains associated with this environment'),
            )
            .describe('List of domains associated with this environment')
            .optional(),
          currentDeploymentAliases: z.array(z.string()).describe('List of aliases for the current deployment').optional(),
          createdAt: z.number().describe('Timestamp when the environment was created'),
          updatedAt: z.number().describe('Timestamp when the environment was last updated'),
        })
        .describe('Internal representation of a custom environment with all required properties'),
    )
    .optional(),
  framework: z
    .enum([
      'angular',
      'astro',
      'blitzjs',
      'brunch',
      'create-react-app',
      'docusaurus',
      'docusaurus-2',
      'dojo',
      'eleventy',
      'ember',
      'fasthtml',
      'gatsby',
      'gridsome',
      'hexo',
      'hugo',
      'hydrogen',
      'ionic-angular',
      'ionic-react',
      'jekyll',
      'middleman',
      'nextjs',
      'nitro',
      'nuxtjs',
      'parcel',
      'polymer',
      'preact',
      'react-router',
      'redwoodjs',
      'remix',
      'saber',
      'sanity',
      'sanity-v3',
      'sapper',
      'scully',
      'solidstart',
      'solidstart-1',
      'stencil',
      'storybook',
      'svelte',
      'sveltekit',
      'sveltekit-1',
      'umijs',
      'vite',
      'vitepress',
      'vue',
      'vuepress',
      'zola',
    ])
    .nullable()
    .nullish(),
  gitForkProtection: z.boolean().optional(),
  gitLFS: z.boolean().optional(),
  id: z.string(),
  ipBuckets: z
    .array(
      z.object({
        bucket: z.string(),
        supportUntil: z.number().optional(),
      }),
    )
    .optional(),
  latestDeployments: z
    .array(
      z.object({
        id: z.string(),
        alias: z.array(z.string()).optional(),
        aliasAssigned: z.union([z.boolean(), z.number()]).nullable().nullish(),
        aliasError: z
          .object({
            code: z.string(),
            message: z.string(),
          })
          .nullable()
          .nullish(),
        aliasFinal: z.string().nullable().nullish(),
        automaticAliases: z.array(z.string()).optional(),
        branchMatcher: z
          .object({
            type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
            pattern: z.string().describe('The pattern to match against branch names'),
          })
          .optional(),
        buildingAt: z.number().optional(),
        builds: z
          .array(
            z.object({
              use: z.string(),
              src: z.string().optional(),
              dest: z.string().optional(),
            }),
          )
          .optional(),
        checksConclusion: z.enum(['canceled', 'failed', 'skipped', 'succeeded']).optional(),
        checksState: z.enum(['completed', 'registered', 'running']).optional(),
        connectBuildsEnabled: z.boolean().optional(),
        connectConfigurationId: z.string().optional(),
        createdAt: z.number(),
        createdIn: z.string(),
        creator: z
          .object({
            email: z.string(),
            githubLogin: z.string().optional(),
            gitlabLogin: z.string().optional(),
            uid: z.string(),
            username: z.string(),
          })
          .nullable(),
        deletedAt: z.number().optional(),
        deploymentHostname: z.string(),
        forced: z.boolean().optional(),
        name: z.string(),
        meta: z.object({}).catchall(z.string()).optional(),
        monorepoManager: z.string().nullable().nullish(),
        oidcTokenClaims: z
          .object({
            iss: z.string(),
            sub: z.string(),
            scope: z.string(),
            aud: z.string(),
            owner: z.string(),
            owner_id: z.string(),
            project: z.string(),
            project_id: z.string(),
            environment: z.string(),
          })
          .optional(),
        plan: z.enum(['enterprise', 'hobby', 'pro']),
        previewCommentsEnabled: z.boolean().describe('Whether or not preview comments are enabled for the deployment').optional(),
        private: z.boolean(),
        readyAt: z.number().optional(),
        readyState: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
        readySubstate: z.enum(['PROMOTED', 'ROLLING', 'STAGED']).optional(),
        requestedAt: z.number().optional(),
        target: z.string().nullable().nullish(),
        teamId: z.string().nullable().nullish(),
        type: z.enum(['LAMBDAS']),
        url: z.string(),
        userId: z.string(),
        withCache: z.boolean().optional(),
      }),
    )
    .optional(),
  link: z
    .union([
      z.object({
        org: z.string().optional(),
        repoOwnerId: z
          .number()
          .describe(
            'A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.',
          )
          .optional(),
        repo: z.string().optional(),
        repoId: z.number().optional(),
        type: z.enum(['github']).optional(),
        createdAt: z.number().optional(),
        deployHooks: z.array(
          z.object({
            createdAt: z.number().optional(),
            id: z.string(),
            name: z.string(),
            ref: z.string(),
            url: z.string(),
          }),
        ),
        gitCredentialId: z.string().optional(),
        updatedAt: z.number().optional(),
        sourceless: z.boolean().optional(),
        productionBranch: z.string().optional(),
      }),
      z.object({
        projectId: z.string().optional(),
        projectName: z.string().optional(),
        projectNameWithNamespace: z.string().optional(),
        projectNamespace: z.string().optional(),
        projectOwnerId: z
          .number()
          .describe(
            'A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes. This is the id of the top level group that a namespace belongs to. Gitlab supports group nesting (up to 20 levels).',
          )
          .optional(),
        projectUrl: z.string().optional(),
        type: z.enum(['gitlab']).optional(),
        createdAt: z.number().optional(),
        deployHooks: z.array(
          z.object({
            createdAt: z.number().optional(),
            id: z.string(),
            name: z.string(),
            ref: z.string(),
            url: z.string(),
          }),
        ),
        gitCredentialId: z.string().optional(),
        updatedAt: z.number().optional(),
        sourceless: z.boolean().optional(),
        productionBranch: z.string().optional(),
      }),
      z.object({
        name: z.string().optional(),
        slug: z.string().optional(),
        owner: z.string().optional(),
        type: z.enum(['bitbucket']).optional(),
        uuid: z.string().optional(),
        workspaceUuid: z.string().optional(),
        createdAt: z.number().optional(),
        deployHooks: z.array(
          z.object({
            createdAt: z.number().optional(),
            id: z.string(),
            name: z.string(),
            ref: z.string(),
            url: z.string(),
          }),
        ),
        gitCredentialId: z.string().optional(),
        updatedAt: z.number().optional(),
        sourceless: z.boolean().optional(),
        productionBranch: z.string().optional(),
      }),
      z.object({
        org: z.string().optional(),
        repoOwnerId: z
          .number()
          .describe(
            'A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.',
          )
          .optional(),
        repo: z.string().optional(),
        repoId: z.number().optional(),
        type: z.enum(['github-custom-host']).optional(),
        host: z.string().optional(),
        createdAt: z.number().optional(),
        deployHooks: z.array(
          z.object({
            createdAt: z.number().optional(),
            id: z.string(),
            name: z.string(),
            ref: z.string(),
            url: z.string(),
          }),
        ),
        gitCredentialId: z.string().optional(),
        updatedAt: z.number().optional(),
        sourceless: z.boolean().optional(),
        productionBranch: z.string().optional(),
      }),
    ])
    .optional(),
  microfrontends: z
    .union([
      z.object({
        updatedAt: z.number().describe('Timestamp when the microfrontends settings were last updated.'),
        groupIds: z
          .array(z.union([z.string(), z.string()]))
          .min(2)
          .max(2)
          .describe(
            'The group IDs of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.',
          ),
        enabled: z.boolean().describe('Whether microfrontends are enabled for this project.'),
        isDefaultApp: z
          .boolean()
          .describe(
            'Whether this project is the default application for the microfrontends group. The default application is the one that is used as the top level shell for the microfrontends group and hosts the other microfrontends.',
          )
          .optional(),
        defaultRoute: z
          .string()
          .describe(
            'A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI. Includes the leading slash, e.g. `/docs`',
          )
          .optional(),
        routeObservabilityToThisProject: z
          .boolean()
          .describe('Whether observability data should be routed to this microfrontend project or a root project.')
          .optional(),
      }),
      z.object({
        updatedAt: z.number(),
        groupIds: z
          .array(z.union([z.string(), z.string()]))
          .min(2)
          .max(2),
        enabled: z.boolean(),
      }),
    ])
    .optional(),
  name: z.string(),
  nodeVersion: z.enum(['10.x', '12.x', '14.x', '16.x', '18.x', '20.x', '22.x', '8.10.x']),
  optionsAllowlist: z
    .object({
      paths: z.array(
        z.object({
          value: z.string(),
        }),
      ),
    })
    .nullable()
    .nullish(),
  outputDirectory: z.string().nullable().nullish(),
  passwordProtection: z.object({}).nullable().nullish(),
  productionDeploymentsFastLane: z.boolean().optional(),
  publicSource: z.boolean().nullable().nullish(),
  resourceConfig: z.object({
    fluid: z.boolean().optional(),
    functionDefaultRegions: z.array(z.string()),
    functionDefaultTimeout: z.number().optional(),
    functionDefaultMemoryType: z.enum(['performance', 'standard', 'standard_legacy']).optional(),
    functionZeroConfigFailover: z.boolean().optional(),
    elasticConcurrencyEnabled: z.boolean().optional(),
    buildMachineType: z.enum(['enhanced', 'turbo']).optional(),
  }),
  rollbackDescription: z
    .object({
      userId: z.string().describe('The user who rolled back the project.'),
      username: z.string().describe('The username of the user who rolled back the project.'),
      description: z.string().describe('User-supplied explanation of why they rolled back the project. Limited to 250 characters.'),
      createdAt: z.number().describe('Timestamp of when the rollback was requested.'),
    })
    .describe('Description of why a project was rolled back, and by whom. Note that lastAliasRequest contains the from/to details of the rollback.')
    .optional(),
  rollingRelease: z
    .object({
      target: z
        .string()
        .describe(
          'The environment that the release targets, currently only supports production. Adding in case we want to configure with alias groups or custom environments.',
        ),
      stages: z
        .array(
          z
            .object({
              targetPercentage: z.number().describe('The percentage of traffic to serve to the canary deployment (0-100)'),
              requireApproval: z.boolean().describe('Whether or not this stage requires manual approval to proceed').optional(),
              duration: z.number().describe('Duration in minutes for automatic advancement to the next stage').optional(),
            })
            .describe(
              'An array of all the stages required during a deployment release. Each stage defines a target percentage and advancement rules. The final stage must always have targetPercentage: 100.',
            ),
        )
        .describe(
          'An array of all the stages required during a deployment release. Each stage defines a target percentage and advancement rules. The final stage must always have targetPercentage: 100.',
        )
        .nullable()
        .nullish(),
      canaryResponseHeader: z
        .boolean()
        .describe('Whether the request served by a canary deployment should return a header indicating a canary was served. Defaults to `false` when omitted.')
        .optional(),
    })
    .describe('Project-level rolling release configuration that defines how deployments should be gradually rolled out')
    .nullable()
    .nullish(),
  defaultResourceConfig: z.object({
    fluid: z.boolean().optional(),
    functionDefaultRegions: z.array(z.string()),
    functionDefaultTimeout: z.number().optional(),
    functionDefaultMemoryType: z.enum(['performance', 'standard', 'standard_legacy']).optional(),
    functionZeroConfigFailover: z.boolean().optional(),
    elasticConcurrencyEnabled: z.boolean().optional(),
    buildMachineType: z.enum(['enhanced', 'turbo']).optional(),
  }),
  rootDirectory: z.string().nullable().nullish(),
  serverlessFunctionZeroConfigFailover: z.boolean().optional(),
  skewProtectionBoundaryAt: z.number().optional(),
  skewProtectionMaxAge: z.number().optional(),
  skipGitConnectDuringLink: z.boolean().optional(),
  sourceFilesOutsideRootDirectory: z.boolean().optional(),
  enableAffectedProjectsDeployments: z.boolean().optional(),
  ssoProtection: z
    .object({
      deploymentType: z.enum(['all', 'all_except_custom_domains', 'preview', 'prod_deployment_urls_and_all_previews']),
    })
    .nullable()
    .nullish(),
  targets: z
    .object({})
    .catchall(
      z
        .object({
          id: z.string(),
          alias: z.array(z.string()).optional(),
          aliasAssigned: z.union([z.boolean(), z.number()]).nullable().nullish(),
          aliasError: z
            .object({
              code: z.string(),
              message: z.string(),
            })
            .nullable()
            .nullish(),
          aliasFinal: z.string().nullable().nullish(),
          automaticAliases: z.array(z.string()).optional(),
          branchMatcher: z
            .object({
              type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
              pattern: z.string().describe('The pattern to match against branch names'),
            })
            .optional(),
          buildingAt: z.number().optional(),
          builds: z
            .array(
              z.object({
                use: z.string(),
                src: z.string().optional(),
                dest: z.string().optional(),
              }),
            )
            .optional(),
          checksConclusion: z.enum(['canceled', 'failed', 'skipped', 'succeeded']).optional(),
          checksState: z.enum(['completed', 'registered', 'running']).optional(),
          connectBuildsEnabled: z.boolean().optional(),
          connectConfigurationId: z.string().optional(),
          createdAt: z.number(),
          createdIn: z.string(),
          creator: z
            .object({
              email: z.string(),
              githubLogin: z.string().optional(),
              gitlabLogin: z.string().optional(),
              uid: z.string(),
              username: z.string(),
            })
            .nullable(),
          deletedAt: z.number().optional(),
          deploymentHostname: z.string(),
          forced: z.boolean().optional(),
          name: z.string(),
          meta: z.object({}).catchall(z.string()).optional(),
          monorepoManager: z.string().nullable().nullish(),
          oidcTokenClaims: z
            .object({
              iss: z.string(),
              sub: z.string(),
              scope: z.string(),
              aud: z.string(),
              owner: z.string(),
              owner_id: z.string(),
              project: z.string(),
              project_id: z.string(),
              environment: z.string(),
            })
            .optional(),
          plan: z.enum(['enterprise', 'hobby', 'pro']),
          previewCommentsEnabled: z.boolean().describe('Whether or not preview comments are enabled for the deployment').optional(),
          private: z.boolean(),
          readyAt: z.number().optional(),
          readyState: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
          readySubstate: z.enum(['PROMOTED', 'ROLLING', 'STAGED']).optional(),
          requestedAt: z.number().optional(),
          target: z.string().nullable().nullish(),
          teamId: z.string().nullable().nullish(),
          type: z.enum(['LAMBDAS']),
          url: z.string(),
          userId: z.string(),
          withCache: z.boolean().optional(),
        })
        .nullable(),
    )
    .optional(),
  transferCompletedAt: z.number().optional(),
  transferStartedAt: z.number().optional(),
  transferToAccountId: z.string().optional(),
  transferredFromAccountId: z.string().optional(),
  updatedAt: z.number().optional(),
  live: z.boolean().optional(),
  enablePreviewFeedback: z.boolean().nullable().nullish(),
  enableProductionFeedback: z.boolean().nullable().nullish(),
  permissions: z
    .object({
      user: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      userConnection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      userSudo: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      webAuthn: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      oauth2Connection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      accessGroup: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      aliasGlobal: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      analyticsSampling: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      analyticsUsage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      auditLog: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingAddress: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingInformation: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingInvoice: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingInvoiceEmailRecipient: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingInvoiceLanguage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingPlan: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingPurchaseOrder: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingTaxId: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      blob: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      budget: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      cacheArtifact: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      cacheArtifactUsageEvent: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      codeChecks: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      concurrentBuilds: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      connect: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      connectConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      defaultDeploymentProtection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domain: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainAcceptDelegation: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainAuthCodes: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainCertificate: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainCheckConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainMove: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainPurchase: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainRecord: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainTransferIn: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      event: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      ownEvent: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sensitiveEnvironmentVariablePolicy: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      fileUpload: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      flagsExplorerSubscription: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      gitRepository: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      ipBlocking: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      imageOptimizationNewPrice: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationAccount: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationConfigurationTransfer: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationConfigurationProjects: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationVercelConfigurationOverride: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationConfigurationRole: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationSSOSession: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationResource: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationEvent: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationResourceSecrets: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationDeploymentAction: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceInstallationMember: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceBillingData: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceInvoice: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceExperimentationItem: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceExperimentationEdgeConfigData: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      jobGlobal: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      drain: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      logDrain: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      Monitoring: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      monitoringSettings: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      monitoringQuery: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      monitoringChart: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      monitoringAlert: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDeploymentFailed: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainExpire: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainMoved: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainPurchase: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainRenewal: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainTransfer: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainUnverified: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      NotificationMonitoringAlert: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationPaymentFailed: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationUsageAlert: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationPreferences: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationCustomerBudget: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationStatementOfReasons: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      observabilityConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      observabilityNotebook: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      observabilityFunnel: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      openTelemetryEndpoint: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      vercelAppInstallation: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      paymentMethod: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      permissions: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      postgres: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      previewDeploymentSuffix: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      proTrialOnboarding: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sharedEnvVars: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sharedEnvVarsProduction: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      space: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      spaceRun: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      passwordProtectionInvoiceItem: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      rateLimit: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      redis: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      repository: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      remoteCaching: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      samlConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      secret: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      redisStoreTokenSet: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      blobStoreTokenSet: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      postgresStoreTokenSet: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationStoreTokenSet: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationResourceReplCommand: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      storeTransfer: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      supportCase: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      supportCaseComment: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      dataCacheBillingSettings: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      team: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamAccessRequest: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamFellowMembership: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamGitExclusivity: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamInvite: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamInviteCode: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamJoin: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamMemberMfaStatus: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamMicrofrontends: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamOwnMembership: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamOwnMembershipDisconnectSAML: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      token: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      usage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      usageCycle: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      vpcPeeringConnection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      webAnalyticsPlan: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeConfigItem: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeConfigSchema: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeConfigToken: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      webhook: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      'webhook-event': z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      endpointVerification: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectTransferIn: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      oauth2Application: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      vercelRun: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      vercelRunExec: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      apiKey: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      apiKeyOwnedBySelf: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      aliasProject: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      aliasProtectionBypass: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      buildMachine: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      productionAliasProtectionBypass: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      connectConfigurationLink: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      dataCacheNamespace: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deployment: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentCheck: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentCheckPreview: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentCheckReRunFromProductionBranch: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentProductionGit: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentV0: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentPreview: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentPrivate: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentPromote: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentRollback: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeCacheNamespace: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      environments: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      logs: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      logsPreset: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      passwordProtection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      optionsAllowlist: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      job: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      observabilityData: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      onDemandBuild: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      onDemandConcurrency: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      project: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectFromV0: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectAccessGroup: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectAnalyticsSampling: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectCheck: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectCheckRun: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDeploymentHook: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDomain: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDomainMove: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDomainCheckConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectEnvVars: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectEnvVarsProduction: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectEnvVarsUnownedByIntegration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectFlags: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectId: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectIntegrationConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectLink: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectMember: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectMonitoring: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectPermissions: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectProductionBranch: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectTransfer: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectTransferOut: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectProtectionBypass: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectUsage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectAnalyticsUsage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectSupportCase: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectSupportCaseComment: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDeploymentExpiration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectRollingRelease: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectTier: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      seawallConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      skewProtection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      analytics: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      trustedIps: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      webAnalytics: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sharedEnvVarConnection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sonar: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
    })
    .optional(),
  lastRollbackTarget: z.object({}).nullable().nullish(),
  lastAliasRequest: z
    .object({
      fromDeploymentId: z.string(),
      toDeploymentId: z.string(),
      fromRollingReleaseId: z
        .string()
        .describe(
          'If rolling back from a rolling release, fromDeploymentId captures the "base" of that rolling release, and fromRollingReleaseId captures the "target" of that rolling release.',
        )
        .optional(),
      jobStatus: z.enum(['failed', 'in-progress', 'pending', 'skipped', 'succeeded']),
      requestedAt: z.number(),
      type: z.enum(['promote', 'rollback']),
    })
    .nullable()
    .nullish(),
  protectionBypass: z
    .object({})
    .catchall(
      z.union([
        z.object({
          createdAt: z.number(),
          createdBy: z.string(),
          scope: z.enum(['integration-automation-bypass']),
          integrationId: z.string(),
          configurationId: z.string(),
        }),
        z.object({
          createdAt: z.number(),
          createdBy: z.string(),
          scope: z.enum(['automation-bypass']),
        }),
      ]),
    )
    .optional(),
  hasActiveBranches: z.boolean().optional(),
  trustedIps: z
    .union([
      z.object({
        deploymentType: z.enum(['all', 'preview', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains', 'production']),
        addresses: z.array(
          z.object({
            value: z.string(),
            note: z.string().optional(),
          }),
        ),
        protectionMode: z.enum(['additional', 'exclusive']),
      }),
      z.object({
        deploymentType: z.enum(['all', 'preview', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains', 'production']),
      }),
    ])
    .nullable()
    .nullish(),
  gitComments: z
    .object({
      onPullRequest: z.boolean().describe('Whether the Vercel bot should comment on PRs'),
      onCommit: z.boolean().describe('Whether the Vercel bot should comment on commits'),
    })
    .optional(),
  gitProviderOptions: z
    .object({
      createDeployments: z
        .enum(['disabled', 'enabled'])
        .describe(
          'Whether the Vercel bot should automatically create GitHub deployments https://docs.github.com/en/rest/deployments/deployments#about-deployments NOTE: repository-dispatch events should be used instead',
        ),
    })
    .optional(),
  paused: z.boolean().optional(),
  concurrencyBucketName: z.string().optional(),
  webAnalytics: z
    .object({
      id: z.string(),
      disabledAt: z.number().optional(),
      canceledAt: z.number().optional(),
      enabledAt: z.number().optional(),
      hasData: z.boolean().optional(),
    })
    .optional(),
  security: z
    .object({
      attackModeEnabled: z.boolean().optional(),
      attackModeUpdatedAt: z.number().optional(),
      firewallEnabled: z.boolean().optional(),
      firewallUpdatedAt: z.number().optional(),
      attackModeActiveUntil: z.number().nullable().nullish(),
      firewallConfigVersion: z.number().optional(),
      firewallRoutes: z
        .array(
          z.object({
            src: z
              .union([
                z.string(),
                z.object({
                  re: z.string().optional(),
                  eq: z.string().optional(),
                  neq: z.string().optional(),
                  inc: z.array(z.string()).optional(),
                  ninc: z.array(z.string()).optional(),
                  pre: z.string().optional(),
                  suf: z.string().optional(),
                  gt: z.number().optional(),
                  gte: z.number().optional(),
                  lt: z.number().optional(),
                  lte: z.number().optional(),
                }),
              ])
              .optional(),
            has: z
              .array(
                z.object({
                  type: z.enum([
                    'cookie',
                    'environment',
                    'header',
                    'host',
                    'initial_request_path',
                    'ip_address',
                    'method',
                    'path',
                    'protocol',
                    'query',
                    'region',
                    'scheme',
                  ]),
                  key: z.string().optional(),
                  value: z
                    .union([
                      z.string(),
                      z.object({
                        re: z.string().optional(),
                        eq: z.string().optional(),
                        neq: z.string().optional(),
                        inc: z.array(z.string()).optional(),
                        ninc: z.array(z.string()).optional(),
                        pre: z.string().optional(),
                        suf: z.string().optional(),
                        gt: z.number().optional(),
                        gte: z.number().optional(),
                        lt: z.number().optional(),
                        lte: z.number().optional(),
                      }),
                    ])
                    .optional(),
                }),
              )
              .optional(),
            missing: z
              .array(
                z.object({
                  type: z.enum([
                    'cookie',
                    'environment',
                    'header',
                    'host',
                    'initial_request_path',
                    'ip_address',
                    'method',
                    'path',
                    'protocol',
                    'query',
                    'region',
                    'scheme',
                  ]),
                  key: z.string().optional(),
                  value: z
                    .union([
                      z.string(),
                      z.object({
                        re: z.string().optional(),
                        eq: z.string().optional(),
                        neq: z.string().optional(),
                        inc: z.array(z.string()).optional(),
                        ninc: z.array(z.string()).optional(),
                        pre: z.string().optional(),
                        suf: z.string().optional(),
                        gt: z.number().optional(),
                        gte: z.number().optional(),
                        lt: z.number().optional(),
                        lte: z.number().optional(),
                      }),
                    ])
                    .optional(),
                }),
              )
              .optional(),
            dest: z.string().optional(),
            status: z.number().optional(),
            handle: z.enum(['finalize', 'init']).optional(),
            mitigate: z
              .object({
                action: z.enum(['bypass', 'challenge', 'deny', 'log', 'rate_limit', 'redirect']),
                rule_id: z.string(),
                ttl: z.number().optional(),
                erl: z
                  .object({
                    algo: z.enum(['fixed_window', 'token_bucket']),
                    window: z.number(),
                    limit: z.number(),
                    keys: z.array(z.string()),
                  })
                  .optional(),
              })
              .optional(),
          }),
        )
        .optional(),
      firewallSeawallEnabled: z.boolean().optional(),
      ja3Enabled: z.boolean().optional(),
      ja4Enabled: z.boolean().optional(),
      firewallBypassIps: z.array(z.string()).optional(),
      managedRules: z
        .object({
          bot_filter: z.object({
            active: z.boolean(),
            action: z.enum(['challenge', 'deny', 'log']).optional(),
          }),
          ai_bots: z.object({
            active: z.boolean(),
            action: z.enum(['challenge', 'deny', 'log']).optional(),
          }),
          owasp: z.object({
            active: z.boolean(),
            action: z.enum(['challenge', 'deny', 'log']).optional(),
          }),
        })
        .nullable()
        .nullish(),
      botIdEnabled: z.boolean().optional(),
    })
    .optional(),
  oidcTokenConfig: z
    .object({
      enabled: z.boolean().describe('Whether or not to generate OpenID Connect JSON Web Tokens.').optional(),
      issuerMode: z.enum(['global', 'team']).describe('- team: `https://oidc.vercel.com/[team_slug]` - global: `https://oidc.vercel.com`').optional(),
    })
    .optional(),
  tier: z.enum(['advanced', 'critical', 'standard']).optional(),
  features: z
    .object({
      webAnalytics: z.boolean().optional(),
    })
    .optional(),
}) as unknown as ToZod<CreateProject200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.\nAt least one environment variable failed validation\nThe Bitbucket Webhook for the project link could not be created\nThe Gitlab Webhook for the project link could not be created
 */
export const createProject400Schema = z.unknown() as unknown as ToZod<CreateProject400>

export const createProject401Schema = z.unknown() as unknown as ToZod<CreateProject401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated\nPro customers are allowed to deploy Serverless Functions to up to `proMaxRegions` regions, or if the project was created before the limit was introduced.\nDeploying to Serverless Functions to multiple regions requires a plan update
 */
export const createProject402Schema = z.unknown() as unknown as ToZod<CreateProject402>

/**
 * @description You do not have permission to access this resource.
 */
export const createProject403Schema = z.unknown() as unknown as ToZod<CreateProject403>

/**
 * @description A project with the provided name already exists.
 */
export const createProject409Schema = z.unknown() as unknown as ToZod<CreateProject409>

export const createProjectMutationRequestSchema = z.object({
  enablePreviewFeedback: z.boolean().describe('Opt-in to preview toolbar on the project level').nullable().nullish(),
  enableProductionFeedback: z.boolean().describe('Opt-in to production toolbar on the project level').nullable().nullish(),
  buildCommand: z
    .string()
    .max(256)
    .describe('The build command for this project. When `null` is used this value will be automatically detected')
    .nullable()
    .nullish(),
  commandForIgnoringBuildStep: z.string().max(256).nullable().nullish(),
  devCommand: z
    .string()
    .max(256)
    .describe('The dev command for this project. When `null` is used this value will be automatically detected')
    .nullable()
    .nullish(),
  environmentVariables: z
    .array(
      z.object({
        key: z.string().describe('Name of the ENV variable'),
        target: z
          .union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])])
          .describe('Deployment Target or Targets in which the ENV variable will be used'),
        gitBranch: z.string().max(250).describe('If defined, the git branch of the environment variable (must have target=preview)').optional(),
        type: z.enum(['encrypted', 'plain', 'secret', 'sensitive', 'system']).describe('Type of the ENV variable').optional(),
        value: z.string().describe('Value for the ENV variable'),
      }),
    )
    .describe('Collection of ENV Variables the Project will use')
    .optional(),
  framework: z
    .enum([
      'angular',
      'astro',
      'blitzjs',
      'brunch',
      'create-react-app',
      'docusaurus',
      'docusaurus-2',
      'dojo',
      'eleventy',
      'ember',
      'fasthtml',
      'gatsby',
      'gridsome',
      'hexo',
      'hugo',
      'hydrogen',
      'ionic-angular',
      'ionic-react',
      'jekyll',
      'middleman',
      'nextjs',
      'nitro',
      'nuxtjs',
      'parcel',
      'polymer',
      'preact',
      'react-router',
      'redwoodjs',
      'remix',
      'saber',
      'sanity',
      'sanity-v3',
      'sapper',
      'scully',
      'solidstart',
      'solidstart-1',
      'stencil',
      'storybook',
      'svelte',
      'sveltekit',
      'sveltekit-1',
      'umijs',
      'vite',
      'vitepress',
      'vue',
      'vuepress',
      'zola',
    ])
    .describe('The framework that is being used for this project. When `null` is used no framework is selected')
    .optional()
    .nullable(),
  gitRepository: z
    .object({
      repo: z.string().describe('The name of the git repository. For example: \\"vercel/next.js\\"'),
      type: z.enum(['bitbucket', 'github', 'gitlab']).describe('The Git Provider of the repository'),
    })
    .describe(
      'The Git Repository that will be connected to the project. When this is defined, any pushes to the specified connected Git Repository will be automatically deployed',
    )
    .optional(),
  installCommand: z
    .string()
    .max(256)
    .describe('The install command for this project. When `null` is used this value will be automatically detected')
    .nullable()
    .nullish(),
  name: z.string().max(100).describe('The desired name for the project'),
  skipGitConnectDuringLink: z.boolean().describe('Opts-out of the message prompting a CLI user to connect a Git repository in `vercel link`.').optional(),
  ssoProtection: z
    .object({
      deploymentType: z.enum(['all', 'all_except_custom_domains', 'preview', 'prod_deployment_urls_and_all_previews']),
    })
    .describe('The Vercel Auth setting for the project (historically named \\"SSO Protection\\")')
    .nullable()
    .nullish(),
  outputDirectory: z
    .string()
    .max(256)
    .describe('The output directory of the project. When `null` is used this value will be automatically detected')
    .nullable()
    .nullish(),
  publicSource: z
    .boolean()
    .describe('Specifies whether the source code and logs of the deployments for this project should be public or not')
    .nullable()
    .nullish(),
  rootDirectory: z
    .string()
    .max(256)
    .describe('The name of a directory or relative path to the source code of your project. When `null` is used it will default to the project root')
    .nullable()
    .nullish(),
  serverlessFunctionRegion: z.string().max(4).describe('The region to deploy Serverless Functions in this project').nullable().nullish(),
  serverlessFunctionZeroConfigFailover: z.boolean().describe('Specifies whether Zero Config Failover is enabled for this project.').optional(),
  oidcTokenConfig: z
    .object({
      enabled: z.boolean().default(true).describe('Whether or not to generate OpenID Connect JSON Web Tokens.'),
      issuerMode: z.enum(['global', 'team']).default('team').describe('team: `https://oidc.vercel.com/[team_slug]` global: `https://oidc.vercel.com`'),
    })
    .describe('OpenID Connect JSON Web Token generation configuration.')
    .optional(),
  enableAffectedProjectsDeployments: z
    .boolean()
    .describe('Opt-in to skip deployments when there are no changes to the root directory and its dependencies')
    .optional(),
  resourceConfig: z
    .object({
      fluid: z.boolean().optional(),
      functionDefaultRegions: z
        .array(z.string().max(4))
        .min(1)
        .refine((items) => new Set(items).size === items.length, { message: 'Array entries must be unique' })
        .describe('The regions to deploy Vercel Functions to for this project')
        .optional(),
      functionDefaultTimeout: z.number().min(1).max(900).optional(),
      functionDefaultMemoryType: z.enum(['performance', 'standard', 'standard_legacy']).optional(),
      functionZeroConfigFailover: z.boolean().describe('Specifies whether Zero Config Failover is enabled for this project.').optional(),
      elasticConcurrencyEnabled: z.boolean().optional(),
      buildMachineType: z.enum(['enhanced', 'turbo']).optional(),
    })
    .describe('Specifies resource override configuration for the project')
    .optional(),
}) as unknown as ToZod<CreateProjectMutationRequest>

export const createProjectMutationResponseSchema = z.lazy(() => createProject200Schema) as unknown as ToZod<CreateProjectMutationResponse>

export const getProjectPathParamsSchema = z.object({
  idOrName: z.union([z.boolean(), z.string()]).describe('The unique project identifier or the project name'),
}) as unknown as ToZod<GetProjectPathParams>

export const getProjectQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetProjectQueryParams>

/**
 * @description The project information
 */
export const getProject200Schema = z.object({
  integrations: z
    .array(
      z
        .object({
          installationId: z.string().describe('The integration installation ID.'),
          resources: z
            .array(
              z
                .object({
                  externalResourceId: z.string(),
                })
                .describe('The list of the installation resources connected to the project.'),
            )
            .describe('The list of the installation resources connected to the project.')
            .optional(),
        })
        .describe('Integration installation enabled on the project.'),
    )
    .optional(),
  accountId: z.string(),
  analytics: z
    .object({
      id: z.string(),
      canceledAt: z.number().nullable().nullish(),
      disabledAt: z.number(),
      enabledAt: z.number(),
      paidAt: z.number().optional(),
      sampleRatePercent: z.number().nullable().nullish(),
      spendLimitInDollars: z.number().nullable().nullish(),
    })
    .optional(),
  speedInsights: z
    .object({
      id: z.string(),
      enabledAt: z.number().optional(),
      disabledAt: z.number().optional(),
      canceledAt: z.number().optional(),
      hasData: z.boolean().optional(),
      paidAt: z.number().optional(),
    })
    .optional(),
  autoExposeSystemEnvs: z.boolean().optional(),
  autoAssignCustomDomains: z.boolean().optional(),
  autoAssignCustomDomainsUpdatedBy: z.string().optional(),
  buildCommand: z.string().nullable().nullish(),
  commandForIgnoringBuildStep: z.string().nullable().nullish(),
  connectConfigurations: z
    .array(
      z.object({
        envId: z.union([z.string(), z.enum(['preview', 'production'])]),
        connectConfigurationId: z.string(),
        passive: z.boolean(),
        buildsEnabled: z.boolean(),
        aws: z
          .object({
            subnetIds: z.array(z.string()),
            securityGroupId: z.string(),
          })
          .optional(),
        createdAt: z.number(),
        updatedAt: z.number(),
      }),
    )
    .nullable()
    .nullish(),
  connectConfigurationId: z.string().nullable().nullish(),
  connectBuildsEnabled: z.boolean().optional(),
  passiveConnectConfigurationId: z.string().nullable().nullish(),
  createdAt: z.number().optional(),
  customerSupportCodeVisibility: z.boolean().optional(),
  crons: z
    .object({
      enabledAt: z
        .number()
        .describe('The time the feature was enabled for this project. Note: It enables automatically with the first Deployment that outputs cronjobs.'),
      disabledAt: z.number().describe('The time the feature was disabled for this project.').nullable(),
      updatedAt: z.number(),
      deploymentId: z.string().describe('The ID of the Deployment from which the definitions originated.').nullable(),
      definitions: z.array(
        z.object({
          host: z.string().describe('The hostname that should be used.'),
          path: z.string().describe('The path that should be called for the cronjob.'),
          schedule: z.string().describe('The cron expression.'),
        }),
      ),
    })
    .optional(),
  dataCache: z
    .object({
      userDisabled: z.boolean(),
      storageSizeBytes: z.number().nullable().nullish(),
      unlimited: z.boolean().optional(),
    })
    .optional(),
  deploymentExpiration: z
    .object({
      expirationDays: z.number().optional(),
      expirationDaysProduction: z.number().optional(),
      expirationDaysCanceled: z.number().optional(),
      expirationDaysErrored: z.number().optional(),
      deploymentsToKeep: z.number().optional(),
    })
    .nullable()
    .nullish(),
  devCommand: z.string().nullable().nullish(),
  directoryListing: z.boolean(),
  installCommand: z.string().nullable().nullish(),
  env: z
    .array(
      z.object({
        target: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])]).optional(),
        type: z.enum(['encrypted', 'plain', 'secret', 'sensitive', 'system']),
        sunsetSecretId: z.string().describe('This is used to identiy variables that have been migrated from type secret to sensitive.').optional(),
        decrypted: z.boolean().optional(),
        value: z.string(),
        vsmValue: z.string().optional(),
        id: z.string().optional(),
        key: z.string(),
        configurationId: z.string().nullable().nullish(),
        createdAt: z.number().optional(),
        updatedAt: z.number().optional(),
        createdBy: z.string().nullable().nullish(),
        updatedBy: z.string().nullable().nullish(),
        gitBranch: z.string().optional(),
        edgeConfigId: z.string().nullable().nullish(),
        edgeConfigTokenId: z.string().nullable().nullish(),
        contentHint: z
          .union([
            z.object({
              type: z.enum(['redis-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-read-only-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['blob-read-write-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url-non-pooling']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-prisma-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-user']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-host']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-password']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-database']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url-no-ssl']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['integration-store-secret']),
              storeId: z.string(),
              integrationId: z.string(),
              integrationProductId: z.string(),
              integrationConfigurationId: z.string(),
            }),
            z.object({
              type: z.enum(['flags-connection-string']),
              projectId: z.string(),
            }),
          ])
          .nullable()
          .nullish(),
        internalContentHint: z
          .object({
            type: z.enum(['flags-secret']),
            encryptedValue: z
              .string()
              .describe('Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.'),
          })
          .describe('Similar to `contentHints`, but should not be exposed to the user.')
          .nullable()
          .nullish(),
        comment: z.string().optional(),
        customEnvironmentIds: z.array(z.string()).optional(),
      }),
    )
    .optional(),
  customEnvironments: z
    .array(
      z
        .object({
          id: z.string().describe('Unique identifier for the custom environment (format: env_*)'),
          slug: z.string().describe('URL-friendly name of the environment'),
          type: z.enum(['development', 'preview', 'production']).describe('The type of environment (production, preview, or development)'),
          description: z.string().describe("Optional description of the environment's purpose").optional(),
          branchMatcher: z
            .object({
              type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
              pattern: z.string().describe('The pattern to match against branch names'),
            })
            .describe('Configuration for matching git branches to this environment')
            .optional(),
          domains: z
            .array(
              z
                .object({
                  name: z.string(),
                  apexName: z.string(),
                  projectId: z.string(),
                  redirect: z.string().nullable().nullish(),
                  redirectStatusCode: z
                    .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
                    .nullable()
                    .nullish(),
                  gitBranch: z.string().nullable().nullish(),
                  customEnvironmentId: z.string().nullable().nullish(),
                  updatedAt: z.number().optional(),
                  createdAt: z.number().optional(),
                  verified: z
                    .boolean()
                    .describe(
                      '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
                    ),
                  verification: z
                    .array(
                      z
                        .object({
                          type: z.string(),
                          domain: z.string(),
                          value: z.string(),
                          reason: z.string(),
                        })
                        .describe(
                          'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                        ),
                    )
                    .describe(
                      'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                    )
                    .optional(),
                })
                .describe('List of domains associated with this environment'),
            )
            .describe('List of domains associated with this environment')
            .optional(),
          currentDeploymentAliases: z.array(z.string()).describe('List of aliases for the current deployment').optional(),
          createdAt: z.number().describe('Timestamp when the environment was created'),
          updatedAt: z.number().describe('Timestamp when the environment was last updated'),
        })
        .describe('Internal representation of a custom environment with all required properties'),
    )
    .optional(),
  framework: z
    .enum([
      'angular',
      'astro',
      'blitzjs',
      'brunch',
      'create-react-app',
      'docusaurus',
      'docusaurus-2',
      'dojo',
      'eleventy',
      'ember',
      'fasthtml',
      'gatsby',
      'gridsome',
      'hexo',
      'hugo',
      'hydrogen',
      'ionic-angular',
      'ionic-react',
      'jekyll',
      'middleman',
      'nextjs',
      'nitro',
      'nuxtjs',
      'parcel',
      'polymer',
      'preact',
      'react-router',
      'redwoodjs',
      'remix',
      'saber',
      'sanity',
      'sanity-v3',
      'sapper',
      'scully',
      'solidstart',
      'solidstart-1',
      'stencil',
      'storybook',
      'svelte',
      'sveltekit',
      'sveltekit-1',
      'umijs',
      'vite',
      'vitepress',
      'vue',
      'vuepress',
      'zola',
    ])
    .nullable()
    .nullish(),
  gitForkProtection: z.boolean().optional(),
  gitLFS: z.boolean().optional(),
  id: z.string(),
  ipBuckets: z
    .array(
      z.object({
        bucket: z.string(),
        supportUntil: z.number().optional(),
      }),
    )
    .optional(),
  latestDeployments: z
    .array(
      z.object({
        id: z.string(),
        alias: z.array(z.string()).optional(),
        aliasAssigned: z.union([z.boolean(), z.number()]).nullable().nullish(),
        aliasError: z
          .object({
            code: z.string(),
            message: z.string(),
          })
          .nullable()
          .nullish(),
        aliasFinal: z.string().nullable().nullish(),
        automaticAliases: z.array(z.string()).optional(),
        branchMatcher: z
          .object({
            type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
            pattern: z.string().describe('The pattern to match against branch names'),
          })
          .optional(),
        buildingAt: z.number().optional(),
        builds: z
          .array(
            z.object({
              use: z.string(),
              src: z.string().optional(),
              dest: z.string().optional(),
            }),
          )
          .optional(),
        checksConclusion: z.enum(['canceled', 'failed', 'skipped', 'succeeded']).optional(),
        checksState: z.enum(['completed', 'registered', 'running']).optional(),
        connectBuildsEnabled: z.boolean().optional(),
        connectConfigurationId: z.string().optional(),
        createdAt: z.number(),
        createdIn: z.string(),
        creator: z
          .object({
            email: z.string(),
            githubLogin: z.string().optional(),
            gitlabLogin: z.string().optional(),
            uid: z.string(),
            username: z.string(),
          })
          .nullable(),
        deletedAt: z.number().optional(),
        deploymentHostname: z.string(),
        forced: z.boolean().optional(),
        name: z.string(),
        meta: z.object({}).catchall(z.string()).optional(),
        monorepoManager: z.string().nullable().nullish(),
        oidcTokenClaims: z
          .object({
            iss: z.string(),
            sub: z.string(),
            scope: z.string(),
            aud: z.string(),
            owner: z.string(),
            owner_id: z.string(),
            project: z.string(),
            project_id: z.string(),
            environment: z.string(),
          })
          .optional(),
        plan: z.enum(['enterprise', 'hobby', 'pro']),
        previewCommentsEnabled: z.boolean().describe('Whether or not preview comments are enabled for the deployment').optional(),
        private: z.boolean(),
        readyAt: z.number().optional(),
        readyState: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
        readySubstate: z.enum(['PROMOTED', 'ROLLING', 'STAGED']).optional(),
        requestedAt: z.number().optional(),
        target: z.string().nullable().nullish(),
        teamId: z.string().nullable().nullish(),
        type: z.enum(['LAMBDAS']),
        url: z.string(),
        userId: z.string(),
        withCache: z.boolean().optional(),
      }),
    )
    .optional(),
  link: z
    .union([
      z.object({
        org: z.string().optional(),
        repoOwnerId: z
          .number()
          .describe(
            'A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.',
          )
          .optional(),
        repo: z.string().optional(),
        repoId: z.number().optional(),
        type: z.enum(['github']).optional(),
        createdAt: z.number().optional(),
        deployHooks: z.array(
          z.object({
            createdAt: z.number().optional(),
            id: z.string(),
            name: z.string(),
            ref: z.string(),
            url: z.string(),
          }),
        ),
        gitCredentialId: z.string().optional(),
        updatedAt: z.number().optional(),
        sourceless: z.boolean().optional(),
        productionBranch: z.string().optional(),
      }),
      z.object({
        projectId: z.string().optional(),
        projectName: z.string().optional(),
        projectNameWithNamespace: z.string().optional(),
        projectNamespace: z.string().optional(),
        projectOwnerId: z
          .number()
          .describe(
            'A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes. This is the id of the top level group that a namespace belongs to. Gitlab supports group nesting (up to 20 levels).',
          )
          .optional(),
        projectUrl: z.string().optional(),
        type: z.enum(['gitlab']).optional(),
        createdAt: z.number().optional(),
        deployHooks: z.array(
          z.object({
            createdAt: z.number().optional(),
            id: z.string(),
            name: z.string(),
            ref: z.string(),
            url: z.string(),
          }),
        ),
        gitCredentialId: z.string().optional(),
        updatedAt: z.number().optional(),
        sourceless: z.boolean().optional(),
        productionBranch: z.string().optional(),
      }),
      z.object({
        name: z.string().optional(),
        slug: z.string().optional(),
        owner: z.string().optional(),
        type: z.enum(['bitbucket']).optional(),
        uuid: z.string().optional(),
        workspaceUuid: z.string().optional(),
        createdAt: z.number().optional(),
        deployHooks: z.array(
          z.object({
            createdAt: z.number().optional(),
            id: z.string(),
            name: z.string(),
            ref: z.string(),
            url: z.string(),
          }),
        ),
        gitCredentialId: z.string().optional(),
        updatedAt: z.number().optional(),
        sourceless: z.boolean().optional(),
        productionBranch: z.string().optional(),
      }),
      z.object({
        org: z.string().optional(),
        repoOwnerId: z
          .number()
          .describe(
            'A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.',
          )
          .optional(),
        repo: z.string().optional(),
        repoId: z.number().optional(),
        type: z.enum(['github-custom-host']).optional(),
        host: z.string().optional(),
        createdAt: z.number().optional(),
        deployHooks: z.array(
          z.object({
            createdAt: z.number().optional(),
            id: z.string(),
            name: z.string(),
            ref: z.string(),
            url: z.string(),
          }),
        ),
        gitCredentialId: z.string().optional(),
        updatedAt: z.number().optional(),
        sourceless: z.boolean().optional(),
        productionBranch: z.string().optional(),
      }),
    ])
    .optional(),
  microfrontends: z
    .union([
      z.object({
        updatedAt: z.number().describe('Timestamp when the microfrontends settings were last updated.'),
        groupIds: z
          .array(z.union([z.string(), z.string()]))
          .min(2)
          .max(2)
          .describe(
            'The group IDs of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.',
          ),
        enabled: z.boolean().describe('Whether microfrontends are enabled for this project.'),
        isDefaultApp: z
          .boolean()
          .describe(
            'Whether this project is the default application for the microfrontends group. The default application is the one that is used as the top level shell for the microfrontends group and hosts the other microfrontends.',
          )
          .optional(),
        defaultRoute: z
          .string()
          .describe(
            'A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI. Includes the leading slash, e.g. `/docs`',
          )
          .optional(),
        routeObservabilityToThisProject: z
          .boolean()
          .describe('Whether observability data should be routed to this microfrontend project or a root project.')
          .optional(),
      }),
      z.object({
        updatedAt: z.number(),
        groupIds: z
          .array(z.union([z.string(), z.string()]))
          .min(2)
          .max(2),
        enabled: z.boolean(),
      }),
    ])
    .optional(),
  name: z.string(),
  nodeVersion: z.enum(['10.x', '12.x', '14.x', '16.x', '18.x', '20.x', '22.x', '8.10.x']),
  optionsAllowlist: z
    .object({
      paths: z.array(
        z.object({
          value: z.string(),
        }),
      ),
    })
    .nullable()
    .nullish(),
  outputDirectory: z.string().nullable().nullish(),
  passwordProtection: z.object({}).nullable().nullish(),
  productionDeploymentsFastLane: z.boolean().optional(),
  publicSource: z.boolean().nullable().nullish(),
  resourceConfig: z.object({
    fluid: z.boolean().optional(),
    functionDefaultRegions: z.array(z.string()),
    functionDefaultTimeout: z.number().optional(),
    functionDefaultMemoryType: z.enum(['performance', 'standard', 'standard_legacy']).optional(),
    functionZeroConfigFailover: z.boolean().optional(),
    elasticConcurrencyEnabled: z.boolean().optional(),
    buildMachineType: z.enum(['enhanced', 'turbo']).optional(),
  }),
  rollbackDescription: z
    .object({
      userId: z.string().describe('The user who rolled back the project.'),
      username: z.string().describe('The username of the user who rolled back the project.'),
      description: z.string().describe('User-supplied explanation of why they rolled back the project. Limited to 250 characters.'),
      createdAt: z.number().describe('Timestamp of when the rollback was requested.'),
    })
    .describe('Description of why a project was rolled back, and by whom. Note that lastAliasRequest contains the from/to details of the rollback.')
    .optional(),
  rollingRelease: z
    .object({
      target: z
        .string()
        .describe(
          'The environment that the release targets, currently only supports production. Adding in case we want to configure with alias groups or custom environments.',
        ),
      stages: z
        .array(
          z
            .object({
              targetPercentage: z.number().describe('The percentage of traffic to serve to the canary deployment (0-100)'),
              requireApproval: z.boolean().describe('Whether or not this stage requires manual approval to proceed').optional(),
              duration: z.number().describe('Duration in minutes for automatic advancement to the next stage').optional(),
            })
            .describe(
              'An array of all the stages required during a deployment release. Each stage defines a target percentage and advancement rules. The final stage must always have targetPercentage: 100.',
            ),
        )
        .describe(
          'An array of all the stages required during a deployment release. Each stage defines a target percentage and advancement rules. The final stage must always have targetPercentage: 100.',
        )
        .nullable()
        .nullish(),
      canaryResponseHeader: z
        .boolean()
        .describe('Whether the request served by a canary deployment should return a header indicating a canary was served. Defaults to `false` when omitted.')
        .optional(),
    })
    .describe('Project-level rolling release configuration that defines how deployments should be gradually rolled out')
    .nullable()
    .nullish(),
  defaultResourceConfig: z.object({
    fluid: z.boolean().optional(),
    functionDefaultRegions: z.array(z.string()),
    functionDefaultTimeout: z.number().optional(),
    functionDefaultMemoryType: z.enum(['performance', 'standard', 'standard_legacy']).optional(),
    functionZeroConfigFailover: z.boolean().optional(),
    elasticConcurrencyEnabled: z.boolean().optional(),
    buildMachineType: z.enum(['enhanced', 'turbo']).optional(),
  }),
  rootDirectory: z.string().nullable().nullish(),
  serverlessFunctionZeroConfigFailover: z.boolean().optional(),
  skewProtectionBoundaryAt: z.number().optional(),
  skewProtectionMaxAge: z.number().optional(),
  skipGitConnectDuringLink: z.boolean().optional(),
  sourceFilesOutsideRootDirectory: z.boolean().optional(),
  enableAffectedProjectsDeployments: z.boolean().optional(),
  ssoProtection: z
    .object({
      deploymentType: z.enum(['all', 'all_except_custom_domains', 'preview', 'prod_deployment_urls_and_all_previews']),
    })
    .nullable()
    .nullish(),
  targets: z
    .object({})
    .catchall(
      z
        .object({
          id: z.string(),
          alias: z.array(z.string()).optional(),
          aliasAssigned: z.union([z.boolean(), z.number()]).nullable().nullish(),
          aliasError: z
            .object({
              code: z.string(),
              message: z.string(),
            })
            .nullable()
            .nullish(),
          aliasFinal: z.string().nullable().nullish(),
          automaticAliases: z.array(z.string()).optional(),
          branchMatcher: z
            .object({
              type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
              pattern: z.string().describe('The pattern to match against branch names'),
            })
            .optional(),
          buildingAt: z.number().optional(),
          builds: z
            .array(
              z.object({
                use: z.string(),
                src: z.string().optional(),
                dest: z.string().optional(),
              }),
            )
            .optional(),
          checksConclusion: z.enum(['canceled', 'failed', 'skipped', 'succeeded']).optional(),
          checksState: z.enum(['completed', 'registered', 'running']).optional(),
          connectBuildsEnabled: z.boolean().optional(),
          connectConfigurationId: z.string().optional(),
          createdAt: z.number(),
          createdIn: z.string(),
          creator: z
            .object({
              email: z.string(),
              githubLogin: z.string().optional(),
              gitlabLogin: z.string().optional(),
              uid: z.string(),
              username: z.string(),
            })
            .nullable(),
          deletedAt: z.number().optional(),
          deploymentHostname: z.string(),
          forced: z.boolean().optional(),
          name: z.string(),
          meta: z.object({}).catchall(z.string()).optional(),
          monorepoManager: z.string().nullable().nullish(),
          oidcTokenClaims: z
            .object({
              iss: z.string(),
              sub: z.string(),
              scope: z.string(),
              aud: z.string(),
              owner: z.string(),
              owner_id: z.string(),
              project: z.string(),
              project_id: z.string(),
              environment: z.string(),
            })
            .optional(),
          plan: z.enum(['enterprise', 'hobby', 'pro']),
          previewCommentsEnabled: z.boolean().describe('Whether or not preview comments are enabled for the deployment').optional(),
          private: z.boolean(),
          readyAt: z.number().optional(),
          readyState: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
          readySubstate: z.enum(['PROMOTED', 'ROLLING', 'STAGED']).optional(),
          requestedAt: z.number().optional(),
          target: z.string().nullable().nullish(),
          teamId: z.string().nullable().nullish(),
          type: z.enum(['LAMBDAS']),
          url: z.string(),
          userId: z.string(),
          withCache: z.boolean().optional(),
        })
        .nullable(),
    )
    .optional(),
  transferCompletedAt: z.number().optional(),
  transferStartedAt: z.number().optional(),
  transferToAccountId: z.string().optional(),
  transferredFromAccountId: z.string().optional(),
  updatedAt: z.number().optional(),
  live: z.boolean().optional(),
  enablePreviewFeedback: z.boolean().nullable().nullish(),
  enableProductionFeedback: z.boolean().nullable().nullish(),
  permissions: z
    .object({
      user: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      userConnection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      userSudo: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      webAuthn: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      oauth2Connection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      accessGroup: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      aliasGlobal: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      analyticsSampling: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      analyticsUsage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      auditLog: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingAddress: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingInformation: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingInvoice: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingInvoiceEmailRecipient: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingInvoiceLanguage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingPlan: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingPurchaseOrder: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingTaxId: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      blob: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      budget: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      cacheArtifact: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      cacheArtifactUsageEvent: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      codeChecks: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      concurrentBuilds: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      connect: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      connectConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      defaultDeploymentProtection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domain: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainAcceptDelegation: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainAuthCodes: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainCertificate: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainCheckConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainMove: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainPurchase: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainRecord: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainTransferIn: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      event: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      ownEvent: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sensitiveEnvironmentVariablePolicy: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      fileUpload: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      flagsExplorerSubscription: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      gitRepository: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      ipBlocking: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      imageOptimizationNewPrice: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationAccount: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationConfigurationTransfer: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationConfigurationProjects: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationVercelConfigurationOverride: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationConfigurationRole: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationSSOSession: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationResource: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationEvent: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationResourceSecrets: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationDeploymentAction: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceInstallationMember: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceBillingData: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceInvoice: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceExperimentationItem: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceExperimentationEdgeConfigData: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      jobGlobal: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      drain: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      logDrain: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      Monitoring: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      monitoringSettings: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      monitoringQuery: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      monitoringChart: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      monitoringAlert: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDeploymentFailed: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainExpire: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainMoved: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainPurchase: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainRenewal: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainTransfer: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainUnverified: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      NotificationMonitoringAlert: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationPaymentFailed: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationUsageAlert: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationPreferences: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationCustomerBudget: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationStatementOfReasons: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      observabilityConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      observabilityNotebook: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      observabilityFunnel: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      openTelemetryEndpoint: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      vercelAppInstallation: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      paymentMethod: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      permissions: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      postgres: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      previewDeploymentSuffix: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      proTrialOnboarding: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sharedEnvVars: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sharedEnvVarsProduction: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      space: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      spaceRun: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      passwordProtectionInvoiceItem: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      rateLimit: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      redis: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      repository: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      remoteCaching: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      samlConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      secret: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      redisStoreTokenSet: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      blobStoreTokenSet: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      postgresStoreTokenSet: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationStoreTokenSet: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationResourceReplCommand: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      storeTransfer: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      supportCase: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      supportCaseComment: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      dataCacheBillingSettings: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      team: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamAccessRequest: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamFellowMembership: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamGitExclusivity: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamInvite: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamInviteCode: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamJoin: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamMemberMfaStatus: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamMicrofrontends: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamOwnMembership: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamOwnMembershipDisconnectSAML: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      token: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      usage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      usageCycle: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      vpcPeeringConnection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      webAnalyticsPlan: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeConfigItem: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeConfigSchema: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeConfigToken: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      webhook: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      'webhook-event': z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      endpointVerification: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectTransferIn: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      oauth2Application: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      vercelRun: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      vercelRunExec: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      apiKey: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      apiKeyOwnedBySelf: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      aliasProject: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      aliasProtectionBypass: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      buildMachine: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      productionAliasProtectionBypass: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      connectConfigurationLink: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      dataCacheNamespace: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deployment: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentCheck: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentCheckPreview: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentCheckReRunFromProductionBranch: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentProductionGit: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentV0: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentPreview: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentPrivate: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentPromote: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentRollback: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeCacheNamespace: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      environments: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      logs: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      logsPreset: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      passwordProtection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      optionsAllowlist: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      job: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      observabilityData: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      onDemandBuild: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      onDemandConcurrency: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      project: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectFromV0: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectAccessGroup: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectAnalyticsSampling: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectCheck: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectCheckRun: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDeploymentHook: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDomain: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDomainMove: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDomainCheckConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectEnvVars: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectEnvVarsProduction: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectEnvVarsUnownedByIntegration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectFlags: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectId: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectIntegrationConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectLink: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectMember: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectMonitoring: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectPermissions: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectProductionBranch: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectTransfer: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectTransferOut: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectProtectionBypass: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectUsage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectAnalyticsUsage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectSupportCase: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectSupportCaseComment: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDeploymentExpiration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectRollingRelease: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectTier: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      seawallConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      skewProtection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      analytics: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      trustedIps: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      webAnalytics: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sharedEnvVarConnection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sonar: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
    })
    .optional(),
  lastRollbackTarget: z.object({}).nullable().nullish(),
  lastAliasRequest: z
    .object({
      fromDeploymentId: z.string(),
      toDeploymentId: z.string(),
      fromRollingReleaseId: z
        .string()
        .describe(
          'If rolling back from a rolling release, fromDeploymentId captures the "base" of that rolling release, and fromRollingReleaseId captures the "target" of that rolling release.',
        )
        .optional(),
      jobStatus: z.enum(['failed', 'in-progress', 'pending', 'skipped', 'succeeded']),
      requestedAt: z.number(),
      type: z.enum(['promote', 'rollback']),
    })
    .nullable()
    .nullish(),
  protectionBypass: z
    .object({})
    .catchall(
      z.union([
        z.object({
          createdAt: z.number(),
          createdBy: z.string(),
          scope: z.enum(['integration-automation-bypass']),
          integrationId: z.string(),
          configurationId: z.string(),
        }),
        z.object({
          createdAt: z.number(),
          createdBy: z.string(),
          scope: z.enum(['automation-bypass']),
        }),
      ]),
    )
    .optional(),
  hasActiveBranches: z.boolean().optional(),
  trustedIps: z
    .union([
      z.object({
        deploymentType: z.enum(['all', 'preview', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains', 'production']),
        addresses: z.array(
          z.object({
            value: z.string(),
            note: z.string().optional(),
          }),
        ),
        protectionMode: z.enum(['additional', 'exclusive']),
      }),
      z.object({
        deploymentType: z.enum(['all', 'preview', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains', 'production']),
      }),
    ])
    .nullable()
    .nullish(),
  gitComments: z
    .object({
      onPullRequest: z.boolean().describe('Whether the Vercel bot should comment on PRs'),
      onCommit: z.boolean().describe('Whether the Vercel bot should comment on commits'),
    })
    .optional(),
  gitProviderOptions: z
    .object({
      createDeployments: z
        .enum(['disabled', 'enabled'])
        .describe(
          'Whether the Vercel bot should automatically create GitHub deployments https://docs.github.com/en/rest/deployments/deployments#about-deployments NOTE: repository-dispatch events should be used instead',
        ),
    })
    .optional(),
  paused: z.boolean().optional(),
  concurrencyBucketName: z.string().optional(),
  webAnalytics: z
    .object({
      id: z.string(),
      disabledAt: z.number().optional(),
      canceledAt: z.number().optional(),
      enabledAt: z.number().optional(),
      hasData: z.boolean().optional(),
    })
    .optional(),
  security: z
    .object({
      attackModeEnabled: z.boolean().optional(),
      attackModeUpdatedAt: z.number().optional(),
      firewallEnabled: z.boolean().optional(),
      firewallUpdatedAt: z.number().optional(),
      attackModeActiveUntil: z.number().nullable().nullish(),
      firewallConfigVersion: z.number().optional(),
      firewallRoutes: z
        .array(
          z.object({
            src: z
              .union([
                z.string(),
                z.object({
                  re: z.string().optional(),
                  eq: z.string().optional(),
                  neq: z.string().optional(),
                  inc: z.array(z.string()).optional(),
                  ninc: z.array(z.string()).optional(),
                  pre: z.string().optional(),
                  suf: z.string().optional(),
                  gt: z.number().optional(),
                  gte: z.number().optional(),
                  lt: z.number().optional(),
                  lte: z.number().optional(),
                }),
              ])
              .optional(),
            has: z
              .array(
                z.object({
                  type: z.enum([
                    'cookie',
                    'environment',
                    'header',
                    'host',
                    'initial_request_path',
                    'ip_address',
                    'method',
                    'path',
                    'protocol',
                    'query',
                    'region',
                    'scheme',
                  ]),
                  key: z.string().optional(),
                  value: z
                    .union([
                      z.string(),
                      z.object({
                        re: z.string().optional(),
                        eq: z.string().optional(),
                        neq: z.string().optional(),
                        inc: z.array(z.string()).optional(),
                        ninc: z.array(z.string()).optional(),
                        pre: z.string().optional(),
                        suf: z.string().optional(),
                        gt: z.number().optional(),
                        gte: z.number().optional(),
                        lt: z.number().optional(),
                        lte: z.number().optional(),
                      }),
                    ])
                    .optional(),
                }),
              )
              .optional(),
            missing: z
              .array(
                z.object({
                  type: z.enum([
                    'cookie',
                    'environment',
                    'header',
                    'host',
                    'initial_request_path',
                    'ip_address',
                    'method',
                    'path',
                    'protocol',
                    'query',
                    'region',
                    'scheme',
                  ]),
                  key: z.string().optional(),
                  value: z
                    .union([
                      z.string(),
                      z.object({
                        re: z.string().optional(),
                        eq: z.string().optional(),
                        neq: z.string().optional(),
                        inc: z.array(z.string()).optional(),
                        ninc: z.array(z.string()).optional(),
                        pre: z.string().optional(),
                        suf: z.string().optional(),
                        gt: z.number().optional(),
                        gte: z.number().optional(),
                        lt: z.number().optional(),
                        lte: z.number().optional(),
                      }),
                    ])
                    .optional(),
                }),
              )
              .optional(),
            dest: z.string().optional(),
            status: z.number().optional(),
            handle: z.enum(['finalize', 'init']).optional(),
            mitigate: z
              .object({
                action: z.enum(['bypass', 'challenge', 'deny', 'log', 'rate_limit', 'redirect']),
                rule_id: z.string(),
                ttl: z.number().optional(),
                erl: z
                  .object({
                    algo: z.enum(['fixed_window', 'token_bucket']),
                    window: z.number(),
                    limit: z.number(),
                    keys: z.array(z.string()),
                  })
                  .optional(),
              })
              .optional(),
          }),
        )
        .optional(),
      firewallSeawallEnabled: z.boolean().optional(),
      ja3Enabled: z.boolean().optional(),
      ja4Enabled: z.boolean().optional(),
      firewallBypassIps: z.array(z.string()).optional(),
      managedRules: z
        .object({
          bot_filter: z.object({
            active: z.boolean(),
            action: z.enum(['challenge', 'deny', 'log']).optional(),
          }),
          ai_bots: z.object({
            active: z.boolean(),
            action: z.enum(['challenge', 'deny', 'log']).optional(),
          }),
          owasp: z.object({
            active: z.boolean(),
            action: z.enum(['challenge', 'deny', 'log']).optional(),
          }),
        })
        .nullable()
        .nullish(),
      botIdEnabled: z.boolean().optional(),
    })
    .optional(),
  oidcTokenConfig: z
    .object({
      enabled: z.boolean().describe('Whether or not to generate OpenID Connect JSON Web Tokens.').optional(),
      issuerMode: z.enum(['global', 'team']).describe('- team: `https://oidc.vercel.com/[team_slug]` - global: `https://oidc.vercel.com`').optional(),
    })
    .optional(),
  tier: z.enum(['advanced', 'critical', 'standard']).optional(),
  features: z
    .object({
      webAnalytics: z.boolean().optional(),
    })
    .optional(),
}) as unknown as ToZod<GetProject200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getProject400Schema = z.unknown() as unknown as ToZod<GetProject400>

export const getProject401Schema = z.unknown() as unknown as ToZod<GetProject401>

/**
 * @description You do not have permission to access this resource.
 */
export const getProject403Schema = z.unknown() as unknown as ToZod<GetProject403>

export const getProjectQueryResponseSchema = z.lazy(() => getProject200Schema) as unknown as ToZod<GetProjectQueryResponse>

export const updateProjectPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
}) as unknown as ToZod<UpdateProjectPathParams>

export const updateProjectQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<UpdateProjectQueryParams>

/**
 * @description The project was successfully updated
 */
export const updateProject200Schema = z.object({
  accountId: z.string(),
  analytics: z
    .object({
      id: z.string(),
      canceledAt: z.number().nullable().nullish(),
      disabledAt: z.number(),
      enabledAt: z.number(),
      paidAt: z.number().optional(),
      sampleRatePercent: z.number().nullable().nullish(),
      spendLimitInDollars: z.number().nullable().nullish(),
    })
    .optional(),
  speedInsights: z
    .object({
      id: z.string(),
      enabledAt: z.number().optional(),
      disabledAt: z.number().optional(),
      canceledAt: z.number().optional(),
      hasData: z.boolean().optional(),
      paidAt: z.number().optional(),
    })
    .optional(),
  autoExposeSystemEnvs: z.boolean().optional(),
  autoAssignCustomDomains: z.boolean().optional(),
  autoAssignCustomDomainsUpdatedBy: z.string().optional(),
  buildCommand: z.string().nullable().nullish(),
  commandForIgnoringBuildStep: z.string().nullable().nullish(),
  connectConfigurations: z
    .array(
      z.object({
        envId: z.union([z.string(), z.enum(['preview', 'production'])]),
        connectConfigurationId: z.string(),
        passive: z.boolean(),
        buildsEnabled: z.boolean(),
        aws: z
          .object({
            subnetIds: z.array(z.string()),
            securityGroupId: z.string(),
          })
          .optional(),
        createdAt: z.number(),
        updatedAt: z.number(),
      }),
    )
    .nullable()
    .nullish(),
  connectConfigurationId: z.string().nullable().nullish(),
  connectBuildsEnabled: z.boolean().optional(),
  passiveConnectConfigurationId: z.string().nullable().nullish(),
  createdAt: z.number().optional(),
  customerSupportCodeVisibility: z.boolean().optional(),
  crons: z
    .object({
      enabledAt: z
        .number()
        .describe('The time the feature was enabled for this project. Note: It enables automatically with the first Deployment that outputs cronjobs.'),
      disabledAt: z.number().describe('The time the feature was disabled for this project.').nullable(),
      updatedAt: z.number(),
      deploymentId: z.string().describe('The ID of the Deployment from which the definitions originated.').nullable(),
      definitions: z.array(
        z.object({
          host: z.string().describe('The hostname that should be used.'),
          path: z.string().describe('The path that should be called for the cronjob.'),
          schedule: z.string().describe('The cron expression.'),
        }),
      ),
    })
    .optional(),
  dataCache: z
    .object({
      userDisabled: z.boolean(),
      storageSizeBytes: z.number().nullable().nullish(),
      unlimited: z.boolean().optional(),
    })
    .optional(),
  deploymentExpiration: z
    .object({
      expirationDays: z.number().optional(),
      expirationDaysProduction: z.number().optional(),
      expirationDaysCanceled: z.number().optional(),
      expirationDaysErrored: z.number().optional(),
      deploymentsToKeep: z.number().optional(),
    })
    .nullable()
    .nullish(),
  devCommand: z.string().nullable().nullish(),
  directoryListing: z.boolean(),
  installCommand: z.string().nullable().nullish(),
  env: z
    .array(
      z.object({
        target: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])]).optional(),
        type: z.enum(['encrypted', 'plain', 'secret', 'sensitive', 'system']),
        sunsetSecretId: z.string().describe('This is used to identiy variables that have been migrated from type secret to sensitive.').optional(),
        decrypted: z.boolean().optional(),
        value: z.string(),
        vsmValue: z.string().optional(),
        id: z.string().optional(),
        key: z.string(),
        configurationId: z.string().nullable().nullish(),
        createdAt: z.number().optional(),
        updatedAt: z.number().optional(),
        createdBy: z.string().nullable().nullish(),
        updatedBy: z.string().nullable().nullish(),
        gitBranch: z.string().optional(),
        edgeConfigId: z.string().nullable().nullish(),
        edgeConfigTokenId: z.string().nullable().nullish(),
        contentHint: z
          .union([
            z.object({
              type: z.enum(['redis-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-read-only-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['blob-read-write-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url-non-pooling']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-prisma-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-user']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-host']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-password']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-database']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url-no-ssl']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['integration-store-secret']),
              storeId: z.string(),
              integrationId: z.string(),
              integrationProductId: z.string(),
              integrationConfigurationId: z.string(),
            }),
            z.object({
              type: z.enum(['flags-connection-string']),
              projectId: z.string(),
            }),
          ])
          .nullable()
          .nullish(),
        internalContentHint: z
          .object({
            type: z.enum(['flags-secret']),
            encryptedValue: z
              .string()
              .describe('Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.'),
          })
          .describe('Similar to `contentHints`, but should not be exposed to the user.')
          .nullable()
          .nullish(),
        comment: z.string().optional(),
        customEnvironmentIds: z.array(z.string()).optional(),
      }),
    )
    .optional(),
  customEnvironments: z
    .array(
      z
        .object({
          id: z.string().describe('Unique identifier for the custom environment (format: env_*)'),
          slug: z.string().describe('URL-friendly name of the environment'),
          type: z.enum(['development', 'preview', 'production']).describe('The type of environment (production, preview, or development)'),
          description: z.string().describe("Optional description of the environment's purpose").optional(),
          branchMatcher: z
            .object({
              type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
              pattern: z.string().describe('The pattern to match against branch names'),
            })
            .describe('Configuration for matching git branches to this environment')
            .optional(),
          domains: z
            .array(
              z
                .object({
                  name: z.string(),
                  apexName: z.string(),
                  projectId: z.string(),
                  redirect: z.string().nullable().nullish(),
                  redirectStatusCode: z
                    .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
                    .nullable()
                    .nullish(),
                  gitBranch: z.string().nullable().nullish(),
                  customEnvironmentId: z.string().nullable().nullish(),
                  updatedAt: z.number().optional(),
                  createdAt: z.number().optional(),
                  verified: z
                    .boolean()
                    .describe(
                      '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
                    ),
                  verification: z
                    .array(
                      z
                        .object({
                          type: z.string(),
                          domain: z.string(),
                          value: z.string(),
                          reason: z.string(),
                        })
                        .describe(
                          'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                        ),
                    )
                    .describe(
                      'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                    )
                    .optional(),
                })
                .describe('List of domains associated with this environment'),
            )
            .describe('List of domains associated with this environment')
            .optional(),
          currentDeploymentAliases: z.array(z.string()).describe('List of aliases for the current deployment').optional(),
          createdAt: z.number().describe('Timestamp when the environment was created'),
          updatedAt: z.number().describe('Timestamp when the environment was last updated'),
        })
        .describe('Internal representation of a custom environment with all required properties'),
    )
    .optional(),
  framework: z
    .enum([
      'angular',
      'astro',
      'blitzjs',
      'brunch',
      'create-react-app',
      'docusaurus',
      'docusaurus-2',
      'dojo',
      'eleventy',
      'ember',
      'fasthtml',
      'gatsby',
      'gridsome',
      'hexo',
      'hugo',
      'hydrogen',
      'ionic-angular',
      'ionic-react',
      'jekyll',
      'middleman',
      'nextjs',
      'nitro',
      'nuxtjs',
      'parcel',
      'polymer',
      'preact',
      'react-router',
      'redwoodjs',
      'remix',
      'saber',
      'sanity',
      'sanity-v3',
      'sapper',
      'scully',
      'solidstart',
      'solidstart-1',
      'stencil',
      'storybook',
      'svelte',
      'sveltekit',
      'sveltekit-1',
      'umijs',
      'vite',
      'vitepress',
      'vue',
      'vuepress',
      'zola',
    ])
    .nullable()
    .nullish(),
  gitForkProtection: z.boolean().optional(),
  gitLFS: z.boolean().optional(),
  id: z.string(),
  ipBuckets: z
    .array(
      z.object({
        bucket: z.string(),
        supportUntil: z.number().optional(),
      }),
    )
    .optional(),
  latestDeployments: z
    .array(
      z.object({
        id: z.string(),
        alias: z.array(z.string()).optional(),
        aliasAssigned: z.union([z.boolean(), z.number()]).nullable().nullish(),
        aliasError: z
          .object({
            code: z.string(),
            message: z.string(),
          })
          .nullable()
          .nullish(),
        aliasFinal: z.string().nullable().nullish(),
        automaticAliases: z.array(z.string()).optional(),
        branchMatcher: z
          .object({
            type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
            pattern: z.string().describe('The pattern to match against branch names'),
          })
          .optional(),
        buildingAt: z.number().optional(),
        builds: z
          .array(
            z.object({
              use: z.string(),
              src: z.string().optional(),
              dest: z.string().optional(),
            }),
          )
          .optional(),
        checksConclusion: z.enum(['canceled', 'failed', 'skipped', 'succeeded']).optional(),
        checksState: z.enum(['completed', 'registered', 'running']).optional(),
        connectBuildsEnabled: z.boolean().optional(),
        connectConfigurationId: z.string().optional(),
        createdAt: z.number(),
        createdIn: z.string(),
        creator: z
          .object({
            email: z.string(),
            githubLogin: z.string().optional(),
            gitlabLogin: z.string().optional(),
            uid: z.string(),
            username: z.string(),
          })
          .nullable(),
        deletedAt: z.number().optional(),
        deploymentHostname: z.string(),
        forced: z.boolean().optional(),
        name: z.string(),
        meta: z.object({}).catchall(z.string()).optional(),
        monorepoManager: z.string().nullable().nullish(),
        oidcTokenClaims: z
          .object({
            iss: z.string(),
            sub: z.string(),
            scope: z.string(),
            aud: z.string(),
            owner: z.string(),
            owner_id: z.string(),
            project: z.string(),
            project_id: z.string(),
            environment: z.string(),
          })
          .optional(),
        plan: z.enum(['enterprise', 'hobby', 'pro']),
        previewCommentsEnabled: z.boolean().describe('Whether or not preview comments are enabled for the deployment').optional(),
        private: z.boolean(),
        readyAt: z.number().optional(),
        readyState: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
        readySubstate: z.enum(['PROMOTED', 'ROLLING', 'STAGED']).optional(),
        requestedAt: z.number().optional(),
        target: z.string().nullable().nullish(),
        teamId: z.string().nullable().nullish(),
        type: z.enum(['LAMBDAS']),
        url: z.string(),
        userId: z.string(),
        withCache: z.boolean().optional(),
      }),
    )
    .optional(),
  link: z
    .union([
      z.object({
        org: z.string().optional(),
        repoOwnerId: z
          .number()
          .describe(
            'A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.',
          )
          .optional(),
        repo: z.string().optional(),
        repoId: z.number().optional(),
        type: z.enum(['github']).optional(),
        createdAt: z.number().optional(),
        deployHooks: z.array(
          z.object({
            createdAt: z.number().optional(),
            id: z.string(),
            name: z.string(),
            ref: z.string(),
            url: z.string(),
          }),
        ),
        gitCredentialId: z.string().optional(),
        updatedAt: z.number().optional(),
        sourceless: z.boolean().optional(),
        productionBranch: z.string().optional(),
      }),
      z.object({
        projectId: z.string().optional(),
        projectName: z.string().optional(),
        projectNameWithNamespace: z.string().optional(),
        projectNamespace: z.string().optional(),
        projectOwnerId: z
          .number()
          .describe(
            'A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes. This is the id of the top level group that a namespace belongs to. Gitlab supports group nesting (up to 20 levels).',
          )
          .optional(),
        projectUrl: z.string().optional(),
        type: z.enum(['gitlab']).optional(),
        createdAt: z.number().optional(),
        deployHooks: z.array(
          z.object({
            createdAt: z.number().optional(),
            id: z.string(),
            name: z.string(),
            ref: z.string(),
            url: z.string(),
          }),
        ),
        gitCredentialId: z.string().optional(),
        updatedAt: z.number().optional(),
        sourceless: z.boolean().optional(),
        productionBranch: z.string().optional(),
      }),
      z.object({
        name: z.string().optional(),
        slug: z.string().optional(),
        owner: z.string().optional(),
        type: z.enum(['bitbucket']).optional(),
        uuid: z.string().optional(),
        workspaceUuid: z.string().optional(),
        createdAt: z.number().optional(),
        deployHooks: z.array(
          z.object({
            createdAt: z.number().optional(),
            id: z.string(),
            name: z.string(),
            ref: z.string(),
            url: z.string(),
          }),
        ),
        gitCredentialId: z.string().optional(),
        updatedAt: z.number().optional(),
        sourceless: z.boolean().optional(),
        productionBranch: z.string().optional(),
      }),
      z.object({
        org: z.string().optional(),
        repoOwnerId: z
          .number()
          .describe(
            'A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.',
          )
          .optional(),
        repo: z.string().optional(),
        repoId: z.number().optional(),
        type: z.enum(['github-custom-host']).optional(),
        host: z.string().optional(),
        createdAt: z.number().optional(),
        deployHooks: z.array(
          z.object({
            createdAt: z.number().optional(),
            id: z.string(),
            name: z.string(),
            ref: z.string(),
            url: z.string(),
          }),
        ),
        gitCredentialId: z.string().optional(),
        updatedAt: z.number().optional(),
        sourceless: z.boolean().optional(),
        productionBranch: z.string().optional(),
      }),
    ])
    .optional(),
  microfrontends: z
    .union([
      z.object({
        updatedAt: z.number().describe('Timestamp when the microfrontends settings were last updated.'),
        groupIds: z
          .array(z.union([z.string(), z.string()]))
          .min(2)
          .max(2)
          .describe(
            'The group IDs of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.',
          ),
        enabled: z.boolean().describe('Whether microfrontends are enabled for this project.'),
        isDefaultApp: z
          .boolean()
          .describe(
            'Whether this project is the default application for the microfrontends group. The default application is the one that is used as the top level shell for the microfrontends group and hosts the other microfrontends.',
          )
          .optional(),
        defaultRoute: z
          .string()
          .describe(
            'A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI. Includes the leading slash, e.g. `/docs`',
          )
          .optional(),
        routeObservabilityToThisProject: z
          .boolean()
          .describe('Whether observability data should be routed to this microfrontend project or a root project.')
          .optional(),
      }),
      z.object({
        updatedAt: z.number(),
        groupIds: z
          .array(z.union([z.string(), z.string()]))
          .min(2)
          .max(2),
        enabled: z.boolean(),
      }),
    ])
    .optional(),
  name: z.string(),
  nodeVersion: z.enum(['10.x', '12.x', '14.x', '16.x', '18.x', '20.x', '22.x', '8.10.x']),
  optionsAllowlist: z
    .object({
      paths: z.array(
        z.object({
          value: z.string(),
        }),
      ),
    })
    .nullable()
    .nullish(),
  outputDirectory: z.string().nullable().nullish(),
  passwordProtection: z.object({}).nullable().nullish(),
  productionDeploymentsFastLane: z.boolean().optional(),
  publicSource: z.boolean().nullable().nullish(),
  resourceConfig: z.object({
    fluid: z.boolean().optional(),
    functionDefaultRegions: z.array(z.string()),
    functionDefaultTimeout: z.number().optional(),
    functionDefaultMemoryType: z.enum(['performance', 'standard', 'standard_legacy']).optional(),
    functionZeroConfigFailover: z.boolean().optional(),
    elasticConcurrencyEnabled: z.boolean().optional(),
    buildMachineType: z.enum(['enhanced', 'turbo']).optional(),
  }),
  rollbackDescription: z
    .object({
      userId: z.string().describe('The user who rolled back the project.'),
      username: z.string().describe('The username of the user who rolled back the project.'),
      description: z.string().describe('User-supplied explanation of why they rolled back the project. Limited to 250 characters.'),
      createdAt: z.number().describe('Timestamp of when the rollback was requested.'),
    })
    .describe('Description of why a project was rolled back, and by whom. Note that lastAliasRequest contains the from/to details of the rollback.')
    .optional(),
  rollingRelease: z
    .object({
      target: z
        .string()
        .describe(
          'The environment that the release targets, currently only supports production. Adding in case we want to configure with alias groups or custom environments.',
        ),
      stages: z
        .array(
          z
            .object({
              targetPercentage: z.number().describe('The percentage of traffic to serve to the canary deployment (0-100)'),
              requireApproval: z.boolean().describe('Whether or not this stage requires manual approval to proceed').optional(),
              duration: z.number().describe('Duration in minutes for automatic advancement to the next stage').optional(),
            })
            .describe(
              'An array of all the stages required during a deployment release. Each stage defines a target percentage and advancement rules. The final stage must always have targetPercentage: 100.',
            ),
        )
        .describe(
          'An array of all the stages required during a deployment release. Each stage defines a target percentage and advancement rules. The final stage must always have targetPercentage: 100.',
        )
        .nullable()
        .nullish(),
      canaryResponseHeader: z
        .boolean()
        .describe('Whether the request served by a canary deployment should return a header indicating a canary was served. Defaults to `false` when omitted.')
        .optional(),
    })
    .describe('Project-level rolling release configuration that defines how deployments should be gradually rolled out')
    .nullable()
    .nullish(),
  defaultResourceConfig: z.object({
    fluid: z.boolean().optional(),
    functionDefaultRegions: z.array(z.string()),
    functionDefaultTimeout: z.number().optional(),
    functionDefaultMemoryType: z.enum(['performance', 'standard', 'standard_legacy']).optional(),
    functionZeroConfigFailover: z.boolean().optional(),
    elasticConcurrencyEnabled: z.boolean().optional(),
    buildMachineType: z.enum(['enhanced', 'turbo']).optional(),
  }),
  rootDirectory: z.string().nullable().nullish(),
  serverlessFunctionZeroConfigFailover: z.boolean().optional(),
  skewProtectionBoundaryAt: z.number().optional(),
  skewProtectionMaxAge: z.number().optional(),
  skipGitConnectDuringLink: z.boolean().optional(),
  sourceFilesOutsideRootDirectory: z.boolean().optional(),
  enableAffectedProjectsDeployments: z.boolean().optional(),
  ssoProtection: z
    .object({
      deploymentType: z.enum(['all', 'all_except_custom_domains', 'preview', 'prod_deployment_urls_and_all_previews']),
    })
    .nullable()
    .nullish(),
  targets: z
    .object({})
    .catchall(
      z
        .object({
          id: z.string(),
          alias: z.array(z.string()).optional(),
          aliasAssigned: z.union([z.boolean(), z.number()]).nullable().nullish(),
          aliasError: z
            .object({
              code: z.string(),
              message: z.string(),
            })
            .nullable()
            .nullish(),
          aliasFinal: z.string().nullable().nullish(),
          automaticAliases: z.array(z.string()).optional(),
          branchMatcher: z
            .object({
              type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
              pattern: z.string().describe('The pattern to match against branch names'),
            })
            .optional(),
          buildingAt: z.number().optional(),
          builds: z
            .array(
              z.object({
                use: z.string(),
                src: z.string().optional(),
                dest: z.string().optional(),
              }),
            )
            .optional(),
          checksConclusion: z.enum(['canceled', 'failed', 'skipped', 'succeeded']).optional(),
          checksState: z.enum(['completed', 'registered', 'running']).optional(),
          connectBuildsEnabled: z.boolean().optional(),
          connectConfigurationId: z.string().optional(),
          createdAt: z.number(),
          createdIn: z.string(),
          creator: z
            .object({
              email: z.string(),
              githubLogin: z.string().optional(),
              gitlabLogin: z.string().optional(),
              uid: z.string(),
              username: z.string(),
            })
            .nullable(),
          deletedAt: z.number().optional(),
          deploymentHostname: z.string(),
          forced: z.boolean().optional(),
          name: z.string(),
          meta: z.object({}).catchall(z.string()).optional(),
          monorepoManager: z.string().nullable().nullish(),
          oidcTokenClaims: z
            .object({
              iss: z.string(),
              sub: z.string(),
              scope: z.string(),
              aud: z.string(),
              owner: z.string(),
              owner_id: z.string(),
              project: z.string(),
              project_id: z.string(),
              environment: z.string(),
            })
            .optional(),
          plan: z.enum(['enterprise', 'hobby', 'pro']),
          previewCommentsEnabled: z.boolean().describe('Whether or not preview comments are enabled for the deployment').optional(),
          private: z.boolean(),
          readyAt: z.number().optional(),
          readyState: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
          readySubstate: z.enum(['PROMOTED', 'ROLLING', 'STAGED']).optional(),
          requestedAt: z.number().optional(),
          target: z.string().nullable().nullish(),
          teamId: z.string().nullable().nullish(),
          type: z.enum(['LAMBDAS']),
          url: z.string(),
          userId: z.string(),
          withCache: z.boolean().optional(),
        })
        .nullable(),
    )
    .optional(),
  transferCompletedAt: z.number().optional(),
  transferStartedAt: z.number().optional(),
  transferToAccountId: z.string().optional(),
  transferredFromAccountId: z.string().optional(),
  updatedAt: z.number().optional(),
  live: z.boolean().optional(),
  enablePreviewFeedback: z.boolean().nullable().nullish(),
  enableProductionFeedback: z.boolean().nullable().nullish(),
  permissions: z
    .object({
      user: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      userConnection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      userSudo: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      webAuthn: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      oauth2Connection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      accessGroup: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      aliasGlobal: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      analyticsSampling: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      analyticsUsage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      auditLog: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingAddress: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingInformation: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingInvoice: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingInvoiceEmailRecipient: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingInvoiceLanguage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingPlan: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingPurchaseOrder: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      billingTaxId: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      blob: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      budget: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      cacheArtifact: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      cacheArtifactUsageEvent: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      codeChecks: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      concurrentBuilds: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      connect: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      connectConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      defaultDeploymentProtection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domain: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainAcceptDelegation: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainAuthCodes: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainCertificate: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainCheckConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainMove: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainPurchase: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainRecord: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      domainTransferIn: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      event: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      ownEvent: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sensitiveEnvironmentVariablePolicy: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      fileUpload: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      flagsExplorerSubscription: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      gitRepository: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      ipBlocking: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      imageOptimizationNewPrice: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationAccount: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationConfigurationTransfer: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationConfigurationProjects: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationVercelConfigurationOverride: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationConfigurationRole: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationSSOSession: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationResource: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationEvent: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationResourceSecrets: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationDeploymentAction: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceInstallationMember: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceBillingData: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceInvoice: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceExperimentationItem: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      marketplaceExperimentationEdgeConfigData: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      jobGlobal: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      drain: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      logDrain: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      Monitoring: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      monitoringSettings: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      monitoringQuery: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      monitoringChart: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      monitoringAlert: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDeploymentFailed: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainExpire: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainMoved: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainPurchase: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainRenewal: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainTransfer: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationDomainUnverified: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      NotificationMonitoringAlert: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationPaymentFailed: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationUsageAlert: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationPreferences: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationCustomerBudget: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      notificationStatementOfReasons: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      observabilityConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      observabilityNotebook: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      observabilityFunnel: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      openTelemetryEndpoint: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      vercelAppInstallation: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      paymentMethod: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      permissions: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      postgres: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      previewDeploymentSuffix: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      proTrialOnboarding: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sharedEnvVars: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sharedEnvVarsProduction: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      space: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      spaceRun: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      passwordProtectionInvoiceItem: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      rateLimit: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      redis: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      repository: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      remoteCaching: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      samlConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      secret: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      redisStoreTokenSet: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      blobStoreTokenSet: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      postgresStoreTokenSet: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationStoreTokenSet: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      integrationResourceReplCommand: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      storeTransfer: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      supportCase: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      supportCaseComment: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      dataCacheBillingSettings: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      team: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamAccessRequest: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamFellowMembership: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamGitExclusivity: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamInvite: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamInviteCode: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamJoin: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamMemberMfaStatus: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamMicrofrontends: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamOwnMembership: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      teamOwnMembershipDisconnectSAML: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      token: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      usage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      usageCycle: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      vpcPeeringConnection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      webAnalyticsPlan: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeConfigItem: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeConfigSchema: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeConfigToken: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      webhook: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      'webhook-event': z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      endpointVerification: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectTransferIn: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      oauth2Application: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      vercelRun: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      vercelRunExec: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      apiKey: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      apiKeyOwnedBySelf: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      aliasProject: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      aliasProtectionBypass: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      buildMachine: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      productionAliasProtectionBypass: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      connectConfigurationLink: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      dataCacheNamespace: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deployment: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentCheck: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentCheckPreview: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentCheckReRunFromProductionBranch: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentProductionGit: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentV0: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentPreview: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentPrivate: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentPromote: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      deploymentRollback: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      edgeCacheNamespace: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      environments: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      logs: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      logsPreset: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      passwordProtection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      optionsAllowlist: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      job: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      observabilityData: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      onDemandBuild: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      onDemandConcurrency: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      project: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectFromV0: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectAccessGroup: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectAnalyticsSampling: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectCheck: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectCheckRun: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDeploymentHook: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDomain: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDomainMove: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDomainCheckConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectEnvVars: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectEnvVarsProduction: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectEnvVarsUnownedByIntegration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectFlags: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectId: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectIntegrationConfiguration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectLink: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectMember: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectMonitoring: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectPermissions: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectProductionBranch: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectTransfer: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectTransferOut: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectProtectionBypass: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectUsage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectAnalyticsUsage: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectSupportCase: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectSupportCaseComment: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectDeploymentExpiration: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectRollingRelease: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      projectTier: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      seawallConfig: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      skewProtection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      analytics: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      trustedIps: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      webAnalytics: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sharedEnvVarConnection: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
      sonar: z
        .array(z.lazy(() => ACLActionSchema).describe('Enum containing the actions that can be performed against a resource. Group operations are included.'))
        .optional(),
    })
    .optional(),
  lastRollbackTarget: z.object({}).nullable().nullish(),
  lastAliasRequest: z
    .object({
      fromDeploymentId: z.string(),
      toDeploymentId: z.string(),
      fromRollingReleaseId: z
        .string()
        .describe(
          'If rolling back from a rolling release, fromDeploymentId captures the "base" of that rolling release, and fromRollingReleaseId captures the "target" of that rolling release.',
        )
        .optional(),
      jobStatus: z.enum(['failed', 'in-progress', 'pending', 'skipped', 'succeeded']),
      requestedAt: z.number(),
      type: z.enum(['promote', 'rollback']),
    })
    .nullable()
    .nullish(),
  protectionBypass: z
    .object({})
    .catchall(
      z.union([
        z.object({
          createdAt: z.number(),
          createdBy: z.string(),
          scope: z.enum(['integration-automation-bypass']),
          integrationId: z.string(),
          configurationId: z.string(),
        }),
        z.object({
          createdAt: z.number(),
          createdBy: z.string(),
          scope: z.enum(['automation-bypass']),
        }),
      ]),
    )
    .optional(),
  hasActiveBranches: z.boolean().optional(),
  trustedIps: z
    .union([
      z.object({
        deploymentType: z.enum(['all', 'preview', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains', 'production']),
        addresses: z.array(
          z.object({
            value: z.string(),
            note: z.string().optional(),
          }),
        ),
        protectionMode: z.enum(['additional', 'exclusive']),
      }),
      z.object({
        deploymentType: z.enum(['all', 'preview', 'prod_deployment_urls_and_all_previews', 'all_except_custom_domains', 'production']),
      }),
    ])
    .nullable()
    .nullish(),
  gitComments: z
    .object({
      onPullRequest: z.boolean().describe('Whether the Vercel bot should comment on PRs'),
      onCommit: z.boolean().describe('Whether the Vercel bot should comment on commits'),
    })
    .optional(),
  gitProviderOptions: z
    .object({
      createDeployments: z
        .enum(['disabled', 'enabled'])
        .describe(
          'Whether the Vercel bot should automatically create GitHub deployments https://docs.github.com/en/rest/deployments/deployments#about-deployments NOTE: repository-dispatch events should be used instead',
        ),
    })
    .optional(),
  paused: z.boolean().optional(),
  concurrencyBucketName: z.string().optional(),
  webAnalytics: z
    .object({
      id: z.string(),
      disabledAt: z.number().optional(),
      canceledAt: z.number().optional(),
      enabledAt: z.number().optional(),
      hasData: z.boolean().optional(),
    })
    .optional(),
  security: z
    .object({
      attackModeEnabled: z.boolean().optional(),
      attackModeUpdatedAt: z.number().optional(),
      firewallEnabled: z.boolean().optional(),
      firewallUpdatedAt: z.number().optional(),
      attackModeActiveUntil: z.number().nullable().nullish(),
      firewallConfigVersion: z.number().optional(),
      firewallRoutes: z
        .array(
          z.object({
            src: z
              .union([
                z.string(),
                z.object({
                  re: z.string().optional(),
                  eq: z.string().optional(),
                  neq: z.string().optional(),
                  inc: z.array(z.string()).optional(),
                  ninc: z.array(z.string()).optional(),
                  pre: z.string().optional(),
                  suf: z.string().optional(),
                  gt: z.number().optional(),
                  gte: z.number().optional(),
                  lt: z.number().optional(),
                  lte: z.number().optional(),
                }),
              ])
              .optional(),
            has: z
              .array(
                z.object({
                  type: z.enum([
                    'cookie',
                    'environment',
                    'header',
                    'host',
                    'initial_request_path',
                    'ip_address',
                    'method',
                    'path',
                    'protocol',
                    'query',
                    'region',
                    'scheme',
                  ]),
                  key: z.string().optional(),
                  value: z
                    .union([
                      z.string(),
                      z.object({
                        re: z.string().optional(),
                        eq: z.string().optional(),
                        neq: z.string().optional(),
                        inc: z.array(z.string()).optional(),
                        ninc: z.array(z.string()).optional(),
                        pre: z.string().optional(),
                        suf: z.string().optional(),
                        gt: z.number().optional(),
                        gte: z.number().optional(),
                        lt: z.number().optional(),
                        lte: z.number().optional(),
                      }),
                    ])
                    .optional(),
                }),
              )
              .optional(),
            missing: z
              .array(
                z.object({
                  type: z.enum([
                    'cookie',
                    'environment',
                    'header',
                    'host',
                    'initial_request_path',
                    'ip_address',
                    'method',
                    'path',
                    'protocol',
                    'query',
                    'region',
                    'scheme',
                  ]),
                  key: z.string().optional(),
                  value: z
                    .union([
                      z.string(),
                      z.object({
                        re: z.string().optional(),
                        eq: z.string().optional(),
                        neq: z.string().optional(),
                        inc: z.array(z.string()).optional(),
                        ninc: z.array(z.string()).optional(),
                        pre: z.string().optional(),
                        suf: z.string().optional(),
                        gt: z.number().optional(),
                        gte: z.number().optional(),
                        lt: z.number().optional(),
                        lte: z.number().optional(),
                      }),
                    ])
                    .optional(),
                }),
              )
              .optional(),
            dest: z.string().optional(),
            status: z.number().optional(),
            handle: z.enum(['finalize', 'init']).optional(),
            mitigate: z
              .object({
                action: z.enum(['bypass', 'challenge', 'deny', 'log', 'rate_limit', 'redirect']),
                rule_id: z.string(),
                ttl: z.number().optional(),
                erl: z
                  .object({
                    algo: z.enum(['fixed_window', 'token_bucket']),
                    window: z.number(),
                    limit: z.number(),
                    keys: z.array(z.string()),
                  })
                  .optional(),
              })
              .optional(),
          }),
        )
        .optional(),
      firewallSeawallEnabled: z.boolean().optional(),
      ja3Enabled: z.boolean().optional(),
      ja4Enabled: z.boolean().optional(),
      firewallBypassIps: z.array(z.string()).optional(),
      managedRules: z
        .object({
          bot_filter: z.object({
            active: z.boolean(),
            action: z.enum(['challenge', 'deny', 'log']).optional(),
          }),
          ai_bots: z.object({
            active: z.boolean(),
            action: z.enum(['challenge', 'deny', 'log']).optional(),
          }),
          owasp: z.object({
            active: z.boolean(),
            action: z.enum(['challenge', 'deny', 'log']).optional(),
          }),
        })
        .nullable()
        .nullish(),
      botIdEnabled: z.boolean().optional(),
    })
    .optional(),
  oidcTokenConfig: z
    .object({
      enabled: z.boolean().describe('Whether or not to generate OpenID Connect JSON Web Tokens.').optional(),
      issuerMode: z.enum(['global', 'team']).describe('- team: `https://oidc.vercel.com/[team_slug]` - global: `https://oidc.vercel.com`').optional(),
    })
    .optional(),
  tier: z.enum(['advanced', 'critical', 'standard']).optional(),
  features: z
    .object({
      webAnalytics: z.boolean().optional(),
    })
    .optional(),
}) as unknown as ToZod<UpdateProject200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.\nTrusted IPs is only accessible for enterprise customers
 */
export const updateProject400Schema = z.unknown() as unknown as ToZod<UpdateProject400>

export const updateProject401Schema = z.unknown() as unknown as ToZod<UpdateProject401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated\nPro customers are allowed to deploy Serverless Functions to up to `proMaxRegions` regions, or if the project was created before the limit was introduced.\nDeploying to Serverless Functions to multiple regions requires a plan update
 */
export const updateProject402Schema = z.unknown() as unknown as ToZod<UpdateProject402>

/**
 * @description You do not have permission to access this resource.
 */
export const updateProject403Schema = z.unknown() as unknown as ToZod<UpdateProject403>

export const updateProject404Schema = z.unknown() as unknown as ToZod<UpdateProject404>

/**
 * @description The provided name for the project is already being used\nThe project is currently being transferred.
 */
export const updateProject409Schema = z.unknown() as unknown as ToZod<UpdateProject409>

/**
 * @description Owner does not have protection add-on\nAdvanced Deployment Protection is not available for the user plan
 */
export const updateProject428Schema = z.unknown() as unknown as ToZod<UpdateProject428>

export const updateProjectMutationRequestSchema = z.object({
  autoExposeSystemEnvs: z.boolean().optional(),
  autoAssignCustomDomains: z.boolean().optional(),
  autoAssignCustomDomainsUpdatedBy: z.string().optional(),
  buildCommand: z
    .string()
    .max(256)
    .describe('The build command for this project. When `null` is used this value will be automatically detected')
    .nullable()
    .nullish(),
  commandForIgnoringBuildStep: z.string().max(256).nullable().nullish(),
  customerSupportCodeVisibility: z.boolean().describe('Specifies whether customer support can see git source for a deployment').optional(),
  devCommand: z
    .string()
    .max(256)
    .describe('The dev command for this project. When `null` is used this value will be automatically detected')
    .nullable()
    .nullish(),
  directoryListing: z.boolean().optional(),
  framework: z
    .enum([
      'angular',
      'astro',
      'blitzjs',
      'brunch',
      'create-react-app',
      'docusaurus',
      'docusaurus-2',
      'dojo',
      'eleventy',
      'ember',
      'fasthtml',
      'gatsby',
      'gridsome',
      'hexo',
      'hugo',
      'hydrogen',
      'ionic-angular',
      'ionic-react',
      'jekyll',
      'middleman',
      'nextjs',
      'nitro',
      'nuxtjs',
      'parcel',
      'polymer',
      'preact',
      'react-router',
      'redwoodjs',
      'remix',
      'saber',
      'sanity',
      'sanity-v3',
      'sapper',
      'scully',
      'solidstart',
      'solidstart-1',
      'stencil',
      'storybook',
      'svelte',
      'sveltekit',
      'sveltekit-1',
      'umijs',
      'vite',
      'vitepress',
      'vue',
      'vuepress',
      'zola',
    ])
    .describe('The framework that is being used for this project. When `null` is used no framework is selected')
    .nullable()
    .nullish(),
  gitForkProtection: z
    .boolean()
    .describe("Specifies whether PRs from Git forks should require a team member's authorization before it can be deployed")
    .optional(),
  gitLFS: z.boolean().describe('Specifies whether Git LFS is enabled for this project.').optional(),
  installCommand: z
    .string()
    .max(256)
    .describe('The install command for this project. When `null` is used this value will be automatically detected')
    .nullable()
    .nullish(),
  name: z.string().max(100).describe('The desired name for the project').optional(),
  nodeVersion: z.enum(['10.x', '12.x', '14.x', '16.x', '18.x', '20.x', '22.x']).optional(),
  outputDirectory: z
    .string()
    .max(256)
    .describe('The output directory of the project. When `null` is used this value will be automatically detected')
    .nullable()
    .nullish(),
  previewDeploymentsDisabled: z.boolean().describe('Specifies whether preview deployments are disabled for this project.').nullable().nullish(),
  publicSource: z
    .boolean()
    .describe('Specifies whether the source code and logs of the deployments for this project should be public or not')
    .nullable()
    .nullish(),
  resourceConfig: z
    .object({
      buildMachineType: z.enum(['enhanced', 'turbo']).optional().nullable(),
      fluid: z.boolean().optional(),
      functionDefaultRegions: z
        .array(z.string().max(4))
        .min(1)
        .refine((items) => new Set(items).size === items.length, { message: 'Array entries must be unique' })
        .describe('The regions to deploy Vercel Functions to for this project')
        .optional(),
      functionDefaultTimeout: z.number().min(1).max(900).optional(),
      functionDefaultMemoryType: z.enum(['performance', 'standard', 'standard_legacy']).optional(),
      functionZeroConfigFailover: z.boolean().describe('Specifies whether Zero Config Failover is enabled for this project.').optional(),
      elasticConcurrencyEnabled: z.boolean().optional(),
    })
    .describe('Specifies resource override configuration for the project')
    .optional(),
  rootDirectory: z
    .string()
    .max(256)
    .describe('The name of a directory or relative path to the source code of your project. When `null` is used it will default to the project root')
    .nullable()
    .nullish(),
  serverlessFunctionRegion: z.string().max(4).describe('The region to deploy Serverless Functions in this project').nullable().nullish(),
  serverlessFunctionZeroConfigFailover: z.boolean().describe('Specifies whether Zero Config Failover is enabled for this project.').optional(),
  skewProtectionBoundaryAt: z
    .number()
    .int()
    .min(0)
    .describe(
      'Deployments created before this absolute datetime have Skew Protection disabled. Value is in milliseconds since epoch to match \\"createdAt\\" fields.',
    )
    .optional(),
  skewProtectionMaxAge: z
    .number()
    .int()
    .min(0)
    .describe('Deployments created before this rolling window have Skew Protection disabled. Value is in seconds to match \\"revalidate\\" fields.')
    .optional(),
  skipGitConnectDuringLink: z.boolean().describe('Opts-out of the message prompting a CLI user to connect a Git repository in `vercel link`.').optional(),
  sourceFilesOutsideRootDirectory: z.boolean().describe('Indicates if there are source files outside of the root directory').optional(),
  enablePreviewFeedback: z.boolean().describe('Opt-in to preview toolbar on the project level').nullable().nullish(),
  enableProductionFeedback: z.boolean().describe('Opt-in to production toolbar on the project level').nullable().nullish(),
  enableAffectedProjectsDeployments: z
    .boolean()
    .describe('Opt-in to skip deployments when there are no changes to the root directory and its dependencies')
    .optional(),
  oidcTokenConfig: z
    .object({
      enabled: z.boolean().default(true).describe('Whether or not to generate OpenID Connect JSON Web Tokens.'),
      issuerMode: z.enum(['global', 'team']).default('team').describe('team: `https://oidc.vercel.com/[team_slug]` global: `https://oidc.vercel.com`'),
    })
    .describe('OpenID Connect JSON Web Token generation configuration.')
    .optional(),
  passwordProtection: z
    .object({
      deploymentType: z
        .enum(['all', 'all_except_custom_domains', 'preview', 'prod_deployment_urls_and_all_previews'])
        .describe('Specify if the password will apply to every Deployment Target or just Preview'),
      password: z.string().max(72).describe('The password that will be used to protect Project Deployments').nullable().nullish(),
    })
    .describe('Allows to protect project deployments with a password')
    .nullable()
    .nullish(),
  ssoProtection: z
    .object({
      deploymentType: z
        .enum(['all', 'all_except_custom_domains', 'preview', 'prod_deployment_urls_and_all_previews'])
        .default('preview')
        .describe('Specify if the Vercel Authentication (SSO Protection) will apply to every Deployment Target or just Preview'),
    })
    .describe('Ensures visitors to your Preview Deployments are logged into Vercel and have a minimum of Viewer access on your team')
    .nullable()
    .nullish(),
  trustedIps: z
    .object({
      deploymentType: z
        .enum(['all', 'all_except_custom_domains', 'preview', 'prod_deployment_urls_and_all_previews', 'production'])
        .describe('Specify if the Trusted IPs will apply to every Deployment Target or just Preview'),
      addresses: z
        .array(
          z.object({
            value: z.string().describe('The IP addresses that are allowlisted. Supports IPv4 addresses and CIDR notations. IPv6 is not supported'),
            note: z.string().max(20).describe('An optional note explaining what the IP address or subnet is used for').optional(),
          }),
        )
        .min(1),
      protectionMode: z
        .enum(['additional', 'exclusive'])
        .describe(
          'exclusive: ip match is enough to bypass deployment protection (regardless of other settings). additional: ip must match + any other protection should be also provided (password, vercel auth, shareable link, automation bypass header, automation bypass query param)',
        ),
    })
    .describe('Restricts access to deployments based on the incoming request IP address')
    .nullable()
    .nullish(),
  optionsAllowlist: z
    .object({
      paths: z
        .array(
          z.object({
            value: z.string().regex(/^\/.*/).describe('The regex path that should not be protected by Deployment Protection'),
          }),
        )
        .min(1)
        .max(5),
    })
    .describe('Specify a list of paths that should not be protected by Deployment Protection to enable Cors preflight requests')
    .nullable()
    .nullish(),
  connectConfigurations: z
    .array(
      z.object({}).and(
        z.object({
          envId: z.string().describe('The ID of the environment'),
          connectConfigurationId: z.string().describe('The ID of the Secure Compute network'),
          passive: z
            .boolean()
            .describe('Whether the configuration should be passive, meaning builds will not run there and only passive Serverless Functions will be deployed'),
          buildsEnabled: z.boolean().describe('Flag saying if project builds should use Secure Compute'),
        }),
      ),
    )
    .min(1)
    .describe('The list of connections from project environment to Secure Compute network')
    .nullable()
    .nullish(),
}) as unknown as ToZod<UpdateProjectMutationRequest>

export const updateProjectMutationResponseSchema = z.lazy(() => updateProject200Schema) as unknown as ToZod<UpdateProjectMutationResponse>

export const deleteProjectPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
}) as unknown as ToZod<DeleteProjectPathParams>

export const deleteProjectQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<DeleteProjectQueryParams>

/**
 * @description The project was successfuly removed
 */
export const deleteProject204Schema = z.unknown() as unknown as ToZod<DeleteProject204>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const deleteProject400Schema = z.unknown() as unknown as ToZod<DeleteProject400>

export const deleteProject401Schema = z.unknown() as unknown as ToZod<DeleteProject401>

/**
 * @description You do not have permission to access this resource.
 */
export const deleteProject403Schema = z.unknown() as unknown as ToZod<DeleteProject403>

export const deleteProject409Schema = z.unknown() as unknown as ToZod<DeleteProject409>

export const deleteProjectMutationResponseSchema = z.lazy(() => deleteProject204Schema) as unknown as ToZod<DeleteProjectMutationResponse>

export const createCustomEnvironmentPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
}) as unknown as ToZod<CreateCustomEnvironmentPathParams>

export const createCustomEnvironmentQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<CreateCustomEnvironmentQueryParams>

export const createCustomEnvironment201Schema = z
  .object({
    id: z.string().describe('Unique identifier for the custom environment (format: env_*)'),
    slug: z.string().describe('URL-friendly name of the environment'),
    type: z.enum(['development', 'preview', 'production']).describe('The type of environment (production, preview, or development)'),
    description: z.string().describe("Optional description of the environment's purpose").optional(),
    branchMatcher: z
      .object({
        type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
        pattern: z.string().describe('The pattern to match against branch names'),
      })
      .describe('Configuration for matching git branches to this environment')
      .optional(),
    domains: z
      .array(
        z
          .object({
            name: z.string(),
            apexName: z.string(),
            projectId: z.string(),
            redirect: z.string().nullable().nullish(),
            redirectStatusCode: z
              .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
              .nullable()
              .nullish(),
            gitBranch: z.string().nullable().nullish(),
            customEnvironmentId: z.string().nullable().nullish(),
            updatedAt: z.number().optional(),
            createdAt: z.number().optional(),
            verified: z
              .boolean()
              .describe(
                '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
              ),
            verification: z
              .array(
                z
                  .object({
                    type: z.string(),
                    domain: z.string(),
                    value: z.string(),
                    reason: z.string(),
                  })
                  .describe(
                    'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                  ),
              )
              .describe(
                'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
              )
              .optional(),
          })
          .describe('List of domains associated with this environment'),
      )
      .describe('List of domains associated with this environment')
      .optional(),
    currentDeploymentAliases: z.array(z.string()).describe('List of aliases for the current deployment').optional(),
    createdAt: z.number().describe('Timestamp when the environment was created'),
    updatedAt: z.number().describe('Timestamp when the environment was last updated'),
  })
  .describe('Internal representation of a custom environment with all required properties') as unknown as ToZod<CreateCustomEnvironment201>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const createCustomEnvironment400Schema = z.unknown() as unknown as ToZod<CreateCustomEnvironment400>

export const createCustomEnvironment401Schema = z.unknown() as unknown as ToZod<CreateCustomEnvironment401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const createCustomEnvironment402Schema = z.unknown() as unknown as ToZod<CreateCustomEnvironment402>

/**
 * @description You do not have permission to access this resource.
 */
export const createCustomEnvironment403Schema = z.unknown() as unknown as ToZod<CreateCustomEnvironment403>

export const createCustomEnvironment500Schema = z.unknown() as unknown as ToZod<CreateCustomEnvironment500>

export const createCustomEnvironmentMutationRequestSchema = z.object({
  slug: z.string().max(32).describe('The slug of the custom environment to create.').optional(),
  description: z.string().max(256).describe('Description of the custom environment. This is optional.').optional(),
  branchMatcher: z
    .object({
      type: z.enum(['endsWith', 'equals', 'startsWith']).describe('Type of matcher. One of \\"equals\\", \\"startsWith\\", or \\"endsWith\\".'),
      pattern: z.string().max(100).describe('Git branch name or portion thereof.'),
    })
    .describe('How we want to determine a matching branch. This is optional.')
    .optional(),
  copyEnvVarsFrom: z.string().describe('Where to copy environment variables from. This is optional.').optional(),
}) as unknown as ToZod<CreateCustomEnvironmentMutationRequest>

export const createCustomEnvironmentMutationResponseSchema = z.lazy(
  () => createCustomEnvironment201Schema,
) as unknown as ToZod<CreateCustomEnvironmentMutationResponse>

export const getv9ProjectsidOrNamecustomEnvironmentsPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
}) as unknown as ToZod<Getv9ProjectsidOrNamecustomEnvironmentsPathParams>

export const getv9ProjectsidOrNamecustomEnvironmentsQueryParamsSchema = z
  .object({
    gitBranch: z.string().describe('Fetch custom environments for a specific git branch').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<Getv9ProjectsidOrNamecustomEnvironmentsQueryParams>

export const getv9ProjectsidOrNamecustomEnvironments200Schema = z.object({
  accountLimit: z
    .object({
      total: z.number(),
    })
    .describe("The maximum number of custom environments allowed either by the team's plan type or a custom override."),
  environments: z.array(
    z.object({
      id: z.string().describe('Unique identifier for the custom environment (format: env_*)'),
      slug: z.string().describe('URL-friendly name of the environment'),
      type: z.enum(['development', 'preview', 'production']).describe('The type of environment (production, preview, or development)'),
      description: z.string().describe("Optional description of the environment's purpose").optional(),
      branchMatcher: z
        .object({
          type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
          pattern: z.string().describe('The pattern to match against branch names'),
        })
        .describe('Configuration for matching git branches to this environment')
        .optional(),
      domains: z
        .array(
          z
            .object({
              name: z.string(),
              apexName: z.string(),
              projectId: z.string(),
              redirect: z.string().nullable().nullish(),
              redirectStatusCode: z
                .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
                .nullable()
                .nullish(),
              gitBranch: z.string().nullable().nullish(),
              customEnvironmentId: z.string().nullable().nullish(),
              updatedAt: z.number().optional(),
              createdAt: z.number().optional(),
              verified: z
                .boolean()
                .describe(
                  '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
                ),
              verification: z
                .array(
                  z
                    .object({
                      type: z.string(),
                      domain: z.string(),
                      value: z.string(),
                      reason: z.string(),
                    })
                    .describe(
                      'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                    ),
                )
                .describe(
                  'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                )
                .optional(),
            })
            .describe('List of domains associated with this environment'),
        )
        .describe('List of domains associated with this environment')
        .optional(),
      currentDeploymentAliases: z.array(z.string()).describe('List of aliases for the current deployment').optional(),
      createdAt: z.number().describe('Timestamp when the environment was created'),
      updatedAt: z.number().describe('Timestamp when the environment was last updated'),
    }),
  ),
}) as unknown as ToZod<Getv9ProjectsidOrNamecustomEnvironments200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getv9ProjectsidOrNamecustomEnvironments400Schema = z.unknown() as unknown as ToZod<Getv9ProjectsidOrNamecustomEnvironments400>

export const getv9ProjectsidOrNamecustomEnvironments401Schema = z.unknown() as unknown as ToZod<Getv9ProjectsidOrNamecustomEnvironments401>

/**
 * @description You do not have permission to access this resource.
 */
export const getv9ProjectsidOrNamecustomEnvironments403Schema = z.unknown() as unknown as ToZod<Getv9ProjectsidOrNamecustomEnvironments403>

export const getv9ProjectsidOrNamecustomEnvironmentsQueryResponseSchema = z.lazy(
  () => getv9ProjectsidOrNamecustomEnvironments200Schema,
) as unknown as ToZod<Getv9ProjectsidOrNamecustomEnvironmentsQueryResponse>

export const getCustomEnvironmentPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
  environmentSlugOrId: z.string().describe('The unique custom environment identifier within the project'),
}) as unknown as ToZod<GetCustomEnvironmentPathParams>

export const getCustomEnvironmentQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetCustomEnvironmentQueryParams>

export const getCustomEnvironment200Schema = z
  .object({
    id: z.string().describe('Unique identifier for the custom environment (format: env_*)'),
    slug: z.string().describe('URL-friendly name of the environment'),
    type: z.enum(['development', 'preview', 'production']).describe('The type of environment (production, preview, or development)'),
    description: z.string().describe("Optional description of the environment's purpose").optional(),
    branchMatcher: z
      .object({
        type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
        pattern: z.string().describe('The pattern to match against branch names'),
      })
      .describe('Configuration for matching git branches to this environment')
      .optional(),
    domains: z
      .array(
        z
          .object({
            name: z.string(),
            apexName: z.string(),
            projectId: z.string(),
            redirect: z.string().nullable().nullish(),
            redirectStatusCode: z
              .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
              .nullable()
              .nullish(),
            gitBranch: z.string().nullable().nullish(),
            customEnvironmentId: z.string().nullable().nullish(),
            updatedAt: z.number().optional(),
            createdAt: z.number().optional(),
            verified: z
              .boolean()
              .describe(
                '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
              ),
            verification: z
              .array(
                z
                  .object({
                    type: z.string(),
                    domain: z.string(),
                    value: z.string(),
                    reason: z.string(),
                  })
                  .describe(
                    'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                  ),
              )
              .describe(
                'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
              )
              .optional(),
          })
          .describe('List of domains associated with this environment'),
      )
      .describe('List of domains associated with this environment')
      .optional(),
    currentDeploymentAliases: z.array(z.string()).describe('List of aliases for the current deployment').optional(),
    createdAt: z.number().describe('Timestamp when the environment was created'),
    updatedAt: z.number().describe('Timestamp when the environment was last updated'),
  })
  .describe('Internal representation of a custom environment with all required properties') as unknown as ToZod<GetCustomEnvironment200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getCustomEnvironment400Schema = z.unknown() as unknown as ToZod<GetCustomEnvironment400>

export const getCustomEnvironment401Schema = z.unknown() as unknown as ToZod<GetCustomEnvironment401>

/**
 * @description You do not have permission to access this resource.
 */
export const getCustomEnvironment403Schema = z.unknown() as unknown as ToZod<GetCustomEnvironment403>

export const getCustomEnvironment404Schema = z.unknown() as unknown as ToZod<GetCustomEnvironment404>

export const getCustomEnvironmentQueryResponseSchema = z.lazy(() => getCustomEnvironment200Schema) as unknown as ToZod<GetCustomEnvironmentQueryResponse>

export const updateCustomEnvironmentPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
  environmentSlugOrId: z.string().describe('The unique custom environment identifier within the project'),
}) as unknown as ToZod<UpdateCustomEnvironmentPathParams>

export const updateCustomEnvironmentQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<UpdateCustomEnvironmentQueryParams>

export const updateCustomEnvironment200Schema = z
  .object({
    id: z.string().describe('Unique identifier for the custom environment (format: env_*)'),
    slug: z.string().describe('URL-friendly name of the environment'),
    type: z.enum(['development', 'preview', 'production']).describe('The type of environment (production, preview, or development)'),
    description: z.string().describe("Optional description of the environment's purpose").optional(),
    branchMatcher: z
      .object({
        type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
        pattern: z.string().describe('The pattern to match against branch names'),
      })
      .describe('Configuration for matching git branches to this environment')
      .optional(),
    domains: z
      .array(
        z
          .object({
            name: z.string(),
            apexName: z.string(),
            projectId: z.string(),
            redirect: z.string().nullable().nullish(),
            redirectStatusCode: z
              .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
              .nullable()
              .nullish(),
            gitBranch: z.string().nullable().nullish(),
            customEnvironmentId: z.string().nullable().nullish(),
            updatedAt: z.number().optional(),
            createdAt: z.number().optional(),
            verified: z
              .boolean()
              .describe(
                '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
              ),
            verification: z
              .array(
                z
                  .object({
                    type: z.string(),
                    domain: z.string(),
                    value: z.string(),
                    reason: z.string(),
                  })
                  .describe(
                    'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                  ),
              )
              .describe(
                'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
              )
              .optional(),
          })
          .describe('List of domains associated with this environment'),
      )
      .describe('List of domains associated with this environment')
      .optional(),
    currentDeploymentAliases: z.array(z.string()).describe('List of aliases for the current deployment').optional(),
    createdAt: z.number().describe('Timestamp when the environment was created'),
    updatedAt: z.number().describe('Timestamp when the environment was last updated'),
  })
  .describe('Internal representation of a custom environment with all required properties') as unknown as ToZod<UpdateCustomEnvironment200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const updateCustomEnvironment400Schema = z.unknown() as unknown as ToZod<UpdateCustomEnvironment400>

export const updateCustomEnvironment401Schema = z.unknown() as unknown as ToZod<UpdateCustomEnvironment401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const updateCustomEnvironment402Schema = z.unknown() as unknown as ToZod<UpdateCustomEnvironment402>

/**
 * @description You do not have permission to access this resource.
 */
export const updateCustomEnvironment403Schema = z.unknown() as unknown as ToZod<UpdateCustomEnvironment403>

export const updateCustomEnvironment500Schema = z.unknown() as unknown as ToZod<UpdateCustomEnvironment500>

export const updateCustomEnvironmentMutationRequestSchema = z.object({
  slug: z.string().max(32).describe('The slug of the custom environment.').optional(),
  description: z.string().max(256).describe('Description of the custom environment. This is optional.').optional(),
  branchMatcher: z
    .object({
      type: z.enum(['endsWith', 'equals', 'startsWith']).describe('Type of matcher. One of \\"equals\\", \\"startsWith\\", or \\"endsWith\\".'),
      pattern: z.string().max(100).describe('Git branch name or portion thereof.'),
    })
    .describe('How we want to determine a matching branch. This is optional.')
    .nullable()
    .nullish(),
}) as unknown as ToZod<UpdateCustomEnvironmentMutationRequest>

export const updateCustomEnvironmentMutationResponseSchema = z.lazy(
  () => updateCustomEnvironment200Schema,
) as unknown as ToZod<UpdateCustomEnvironmentMutationResponse>

export const removeCustomEnvironmentPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
  environmentSlugOrId: z.string().describe('The unique custom environment identifier within the project'),
}) as unknown as ToZod<RemoveCustomEnvironmentPathParams>

export const removeCustomEnvironmentQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<RemoveCustomEnvironmentQueryParams>

export const removeCustomEnvironment200Schema = z
  .object({
    id: z.string().describe('Unique identifier for the custom environment (format: env_*)'),
    slug: z.string().describe('URL-friendly name of the environment'),
    type: z.enum(['development', 'preview', 'production']).describe('The type of environment (production, preview, or development)'),
    description: z.string().describe("Optional description of the environment's purpose").optional(),
    branchMatcher: z
      .object({
        type: z.enum(['endsWith', 'equals', 'startsWith']).describe('The type of matching to perform'),
        pattern: z.string().describe('The pattern to match against branch names'),
      })
      .describe('Configuration for matching git branches to this environment')
      .optional(),
    domains: z
      .array(
        z
          .object({
            name: z.string(),
            apexName: z.string(),
            projectId: z.string(),
            redirect: z.string().nullable().nullish(),
            redirectStatusCode: z
              .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
              .nullable()
              .nullish(),
            gitBranch: z.string().nullable().nullish(),
            customEnvironmentId: z.string().nullable().nullish(),
            updatedAt: z.number().optional(),
            createdAt: z.number().optional(),
            verified: z
              .boolean()
              .describe(
                '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
              ),
            verification: z
              .array(
                z
                  .object({
                    type: z.string(),
                    domain: z.string(),
                    value: z.string(),
                    reason: z.string(),
                  })
                  .describe(
                    'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
                  ),
              )
              .describe(
                'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
              )
              .optional(),
          })
          .describe('List of domains associated with this environment'),
      )
      .describe('List of domains associated with this environment')
      .optional(),
    currentDeploymentAliases: z.array(z.string()).describe('List of aliases for the current deployment').optional(),
    createdAt: z.number().describe('Timestamp when the environment was created'),
    updatedAt: z.number().describe('Timestamp when the environment was last updated'),
  })
  .describe('Internal representation of a custom environment with all required properties') as unknown as ToZod<RemoveCustomEnvironment200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const removeCustomEnvironment400Schema = z.unknown() as unknown as ToZod<RemoveCustomEnvironment400>

export const removeCustomEnvironment401Schema = z.unknown() as unknown as ToZod<RemoveCustomEnvironment401>

/**
 * @description You do not have permission to access this resource.
 */
export const removeCustomEnvironment403Schema = z.unknown() as unknown as ToZod<RemoveCustomEnvironment403>

export const removeCustomEnvironmentMutationRequestSchema = z.object({
  deleteUnassignedEnvironmentVariables: z.boolean().describe('Delete Environment Variables that are not assigned to any environments.').optional(),
}) as unknown as ToZod<RemoveCustomEnvironmentMutationRequest>

export const removeCustomEnvironmentMutationResponseSchema = z.lazy(
  () => removeCustomEnvironment200Schema,
) as unknown as ToZod<RemoveCustomEnvironmentMutationResponse>

export const getProjectDomainsPathParamsSchema = z.object({
  idOrName: z.union([z.coerce.number().int(), z.string()]).describe('The unique project identifier or the project name'),
}) as unknown as ToZod<GetProjectDomainsPathParams>

export const getProjectDomainsQueryParamsSchema = z.object({
  production: z.enum(['true', 'false']).default('false').describe('Filters only production domains when set to `true`.'),
  target: z.enum(['production', 'preview']).describe('Filters on the target of the domain. Can be either \\"production\\", \\"preview\\"').optional(),
  customEnvironmentId: z.string().describe('The unique custom environment identifier within the project').optional(),
  gitBranch: z.string().describe('Filters domains based on specific branch.').optional(),
  redirects: z
    .enum(['true', 'false'])
    .default('true')
    .describe('Excludes redirect project domains when \\"false\\". Includes redirect project domains when \\"true\\" (default).'),
  redirect: z.string().describe('Filters domains based on their redirect target.').optional(),
  verified: z.enum(['true', 'false']).describe('Filters domains based on their verification status.').optional(),
  limit: z.coerce.number().describe('Maximum number of domains to list from a request (max 100).').optional(),
  since: z.coerce.number().describe('Get domains created after this JavaScript timestamp.').optional(),
  until: z.coerce.number().describe('Get domains created before this JavaScript timestamp.').optional(),
  order: z.enum(['ASC', 'DESC']).default('DESC').describe('Domains sort order by createdAt'),
  teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
  slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
}) as unknown as ToZod<GetProjectDomainsQueryParams>

/**
 * @description Successful response retrieving a list of domains
 */
export const getProjectDomains200Schema = z.union([
  z.object({
    domains: z.array(
      z.object({
        name: z.string(),
        apexName: z.string(),
        projectId: z.string(),
        redirect: z.string().nullable().nullish(),
        redirectStatusCode: z
          .union([z.literal(307), z.literal(301), z.literal(302), z.literal(308)])
          .nullable()
          .nullish(),
        gitBranch: z.string().nullable().nullish(),
        customEnvironmentId: z.string().nullable().nullish(),
        updatedAt: z.number().optional(),
        createdAt: z.number().optional(),
        verified: z
          .boolean()
          .describe(
            '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
          ),
        verification: z
          .array(
            z
              .object({
                type: z.string(),
                domain: z.string(),
                value: z.string(),
                reason: z.string(),
              })
              .describe(
                'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
              ),
          )
          .describe(
            'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
          )
          .optional(),
      }),
    ),
    pagination: z.object({
      count: z.number(),
      next: z.number().nullable(),
      prev: z.number().nullable(),
    }),
  }),
  z.object({
    domains: z.array(
      z.object({
        name: z.string(),
        apexName: z.string(),
        projectId: z.string(),
        redirect: z.string().nullable().nullish(),
        redirectStatusCode: z
          .union([z.literal(307), z.literal(301), z.literal(302), z.literal(308)])
          .nullable()
          .nullish(),
        gitBranch: z.string().nullable().nullish(),
        customEnvironmentId: z.string().nullable().nullish(),
        updatedAt: z.number().optional(),
        createdAt: z.number().optional(),
        verified: z
          .boolean()
          .describe(
            '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
          ),
        verification: z
          .array(
            z
              .object({
                type: z.string(),
                domain: z.string(),
                value: z.string(),
                reason: z.string(),
              })
              .describe(
                'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
              ),
          )
          .describe(
            'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
          )
          .optional(),
      }),
    ),
    pagination: z
      .lazy(() => paginationSchema)
      .describe(
        'This object contains information related to the pagination of the current request, including the necessary parameters to get the next or previous page of data.',
      ),
  }),
]) as unknown as ToZod<GetProjectDomains200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getProjectDomains400Schema = z.unknown() as unknown as ToZod<GetProjectDomains400>

export const getProjectDomains401Schema = z.unknown() as unknown as ToZod<GetProjectDomains401>

/**
 * @description You do not have permission to access this resource.
 */
export const getProjectDomains403Schema = z.unknown() as unknown as ToZod<GetProjectDomains403>

export const getProjectDomainsQueryResponseSchema = z.lazy(() => getProjectDomains200Schema) as unknown as ToZod<GetProjectDomainsQueryResponse>

export const getProjectDomainPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
  domain: z.string().describe('The project domain name'),
}) as unknown as ToZod<GetProjectDomainPathParams>

export const getProjectDomainQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetProjectDomainQueryParams>

export const getProjectDomain200Schema = z.object({
  name: z.string(),
  apexName: z.string(),
  projectId: z.string(),
  redirect: z.string().nullable().nullish(),
  redirectStatusCode: z
    .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
    .nullable()
    .nullish(),
  gitBranch: z.string().nullable().nullish(),
  customEnvironmentId: z.string().nullable().nullish(),
  updatedAt: z.number().optional(),
  createdAt: z.number().optional(),
  verified: z
    .boolean()
    .describe(
      '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
    ),
  verification: z
    .array(
      z
        .object({
          type: z.string(),
          domain: z.string(),
          value: z.string(),
          reason: z.string(),
        })
        .describe(
          'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
        ),
    )
    .describe(
      'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
    )
    .optional(),
}) as unknown as ToZod<GetProjectDomain200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getProjectDomain400Schema = z.unknown() as unknown as ToZod<GetProjectDomain400>

export const getProjectDomain401Schema = z.unknown() as unknown as ToZod<GetProjectDomain401>

/**
 * @description You do not have permission to access this resource.
 */
export const getProjectDomain403Schema = z.unknown() as unknown as ToZod<GetProjectDomain403>

export const getProjectDomainQueryResponseSchema = z.lazy(() => getProjectDomain200Schema) as unknown as ToZod<GetProjectDomainQueryResponse>

export const updateProjectDomainPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
  domain: z.string().describe('The project domain name'),
}) as unknown as ToZod<UpdateProjectDomainPathParams>

export const updateProjectDomainQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<UpdateProjectDomainQueryParams>

/**
 * @description The domain was updated successfuly
 */
export const updateProjectDomain200Schema = z.object({
  name: z.string(),
  apexName: z.string(),
  projectId: z.string(),
  redirect: z.string().nullable().nullish(),
  redirectStatusCode: z
    .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
    .nullable()
    .nullish(),
  gitBranch: z.string().nullable().nullish(),
  customEnvironmentId: z.string().nullable().nullish(),
  updatedAt: z.number().optional(),
  createdAt: z.number().optional(),
  verified: z
    .boolean()
    .describe(
      '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
    ),
  verification: z
    .array(
      z
        .object({
          type: z.string(),
          domain: z.string(),
          value: z.string(),
          reason: z.string(),
        })
        .describe(
          'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
        ),
    )
    .describe(
      'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
    )
    .optional(),
}) as unknown as ToZod<UpdateProjectDomain200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.\nThe domain redirect is not valid
 */
export const updateProjectDomain400Schema = z.unknown() as unknown as ToZod<UpdateProjectDomain400>

export const updateProjectDomain401Schema = z.unknown() as unknown as ToZod<UpdateProjectDomain401>

/**
 * @description You do not have permission to access this resource.
 */
export const updateProjectDomain403Schema = z.unknown() as unknown as ToZod<UpdateProjectDomain403>

/**
 * @description The project is currently being transferred
 */
export const updateProjectDomain409Schema = z.unknown() as unknown as ToZod<UpdateProjectDomain409>

export const updateProjectDomainMutationRequestSchema = z.object({
  gitBranch: z.string().max(250).describe('Git branch to link the project domain').nullable().nullish(),
  redirect: z.string().describe('Target destination domain for redirect').nullable().nullish(),
  redirectStatusCode: z
    .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
    .describe('Status code for domain redirect')
    .nullable()
    .nullish(),
}) as unknown as ToZod<UpdateProjectDomainMutationRequest>

export const updateProjectDomainMutationResponseSchema = z.lazy(() => updateProjectDomain200Schema) as unknown as ToZod<UpdateProjectDomainMutationResponse>

export const removeProjectDomainPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
  domain: z.string().describe('The project domain name'),
}) as unknown as ToZod<RemoveProjectDomainPathParams>

export const removeProjectDomainQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<RemoveProjectDomainQueryParams>

/**
 * @description The domain was succesfully removed from the project
 */
export const removeProjectDomain200Schema = z.object({}) as unknown as ToZod<RemoveProjectDomain200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const removeProjectDomain400Schema = z.unknown() as unknown as ToZod<RemoveProjectDomain400>

export const removeProjectDomain401Schema = z.unknown() as unknown as ToZod<RemoveProjectDomain401>

/**
 * @description You do not have permission to access this resource.
 */
export const removeProjectDomain403Schema = z.unknown() as unknown as ToZod<RemoveProjectDomain403>

export const removeProjectDomain404Schema = z.unknown() as unknown as ToZod<RemoveProjectDomain404>

/**
 * @description The project is currently being transferred
 */
export const removeProjectDomain409Schema = z.unknown() as unknown as ToZod<RemoveProjectDomain409>

export const removeProjectDomainMutationRequestSchema = z.object({
  removeRedirects: z.boolean().describe('Whether to remove all domains from this project that redirect to the domain being removed.').optional(),
}) as unknown as ToZod<RemoveProjectDomainMutationRequest>

export const removeProjectDomainMutationResponseSchema = z.lazy(() => removeProjectDomain200Schema) as unknown as ToZod<RemoveProjectDomainMutationResponse>

export const addProjectDomainPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
}) as unknown as ToZod<AddProjectDomainPathParams>

export const addProjectDomainQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<AddProjectDomainQueryParams>

/**
 * @description The domain was successfully added to the project
 */
export const addProjectDomain200Schema = z.object({
  name: z.string(),
  apexName: z.string(),
  projectId: z.string(),
  redirect: z.string().nullable().nullish(),
  redirectStatusCode: z
    .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
    .nullable()
    .nullish(),
  gitBranch: z.string().nullable().nullish(),
  customEnvironmentId: z.string().nullable().nullish(),
  updatedAt: z.number().optional(),
  createdAt: z.number().optional(),
  verified: z
    .boolean()
    .describe(
      '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
    ),
  verification: z
    .array(
      z
        .object({
          type: z.string(),
          domain: z.string(),
          value: z.string(),
          reason: z.string(),
        })
        .describe(
          'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
        ),
    )
    .describe(
      'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
    )
    .optional(),
}) as unknown as ToZod<AddProjectDomain200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.\nThe domain is not valid\nYou can\'t set both a git branch and a redirect for the domain\nThe domain can not be added because the latest production deployment for the project was not successful\nThe domain redirect is not valid\nA domain cannot redirect to itself\nYou can not set the production branch as a branch for your domain
 */
export const addProjectDomain400Schema = z.unknown() as unknown as ToZod<AddProjectDomain400>

export const addProjectDomain401Schema = z.unknown() as unknown as ToZod<AddProjectDomain401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const addProjectDomain402Schema = z.unknown() as unknown as ToZod<AddProjectDomain402>

/**
 * @description You do not have permission to access this resource.\nYou don\'t have access to the domain you are adding
 */
export const addProjectDomain403Schema = z.unknown() as unknown as ToZod<AddProjectDomain403>

/**
 * @description The domain is already assigned to another Vercel project\nCannot create project domain since owner already has `domain` on their account, but it\'s not verified yet.\nCannot create project domain since owner already has `domain` on their account, and it\'s verified.\nThe domain is not allowed to be used\nThe project is currently being transferred
 */
export const addProjectDomain409Schema = z.unknown() as unknown as ToZod<AddProjectDomain409>

export const addProjectDomainMutationRequestSchema = z.object({
  name: z.string().describe('The project domain name'),
  gitBranch: z.string().max(250).describe('Git branch to link the project domain').nullable().nullish(),
  customEnvironmentId: z.string().describe('The unique custom environment identifier within the project').optional(),
  redirect: z.string().describe('Target destination domain for redirect').nullable().nullish(),
  redirectStatusCode: z
    .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
    .describe('Status code for domain redirect')
    .nullable()
    .nullish(),
}) as unknown as ToZod<AddProjectDomainMutationRequest>

export const addProjectDomainMutationResponseSchema = z.lazy(() => addProjectDomain200Schema) as unknown as ToZod<AddProjectDomainMutationResponse>

export const moveProjectDomainPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
  domain: z.string().describe('The project domain name'),
}) as unknown as ToZod<MoveProjectDomainPathParams>

export const moveProjectDomainQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<MoveProjectDomainQueryParams>

/**
 * @description The domain was updated successfuly
 */
export const moveProjectDomain200Schema = z.object({
  name: z.string(),
  apexName: z.string(),
  projectId: z.string(),
  redirect: z.string().nullable().nullish(),
  redirectStatusCode: z
    .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
    .nullable()
    .nullish(),
  gitBranch: z.string().nullable().nullish(),
  customEnvironmentId: z.string().nullable().nullish(),
  updatedAt: z.number().optional(),
  createdAt: z.number().optional(),
  verified: z
    .boolean()
    .describe(
      '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
    ),
  verification: z
    .array(
      z
        .object({
          type: z.string(),
          domain: z.string(),
          value: z.string(),
          reason: z.string(),
        })
        .describe(
          'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
        ),
    )
    .describe(
      'A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.',
    )
    .optional(),
}) as unknown as ToZod<MoveProjectDomain200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const moveProjectDomain400Schema = z.unknown() as unknown as ToZod<MoveProjectDomain400>

export const moveProjectDomain401Schema = z.unknown() as unknown as ToZod<MoveProjectDomain401>

/**
 * @description You do not have permission to access this resource.
 */
export const moveProjectDomain403Schema = z.unknown() as unknown as ToZod<MoveProjectDomain403>

/**
 * @description The project is currently being transferred
 */
export const moveProjectDomain409Schema = z.unknown() as unknown as ToZod<MoveProjectDomain409>

export const moveProjectDomainMutationRequestSchema = z.object({
  projectId: z.string().describe('The unique target project identifier'),
}) as unknown as ToZod<MoveProjectDomainMutationRequest>

export const moveProjectDomainMutationResponseSchema = z.lazy(() => moveProjectDomain200Schema) as unknown as ToZod<MoveProjectDomainMutationResponse>

export const verifyProjectDomainPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
  domain: z.string().describe('The domain name you want to verify'),
}) as unknown as ToZod<VerifyProjectDomainPathParams>

export const verifyProjectDomainQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<VerifyProjectDomainQueryParams>

/**
 * @description The project domain was verified successfully\nDomain is already verified
 */
export const verifyProjectDomain200Schema = z.object({
  name: z.string(),
  apexName: z.string(),
  projectId: z.string(),
  redirect: z.string().nullable().nullish(),
  redirectStatusCode: z
    .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
    .nullable()
    .nullish(),
  gitBranch: z.string().nullable().nullish(),
  customEnvironmentId: z.string().nullable().nullish(),
  updatedAt: z.number().optional(),
  createdAt: z.number().optional(),
  verified: z
    .boolean()
    .describe(
      '`true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.',
    ),
}) as unknown as ToZod<VerifyProjectDomain200>

/**
 * @description One of the provided values in the request query is invalid.\nThere is an existing TXT record on the domain verifying it for another project\nThe domain does not have a TXT record that attempts to verify the project domain\nThe TXT record on the domain does not match the expected challenge for the project domain\nProject domain is not assigned to project
 */
export const verifyProjectDomain400Schema = z.unknown() as unknown as ToZod<VerifyProjectDomain400>

export const verifyProjectDomain401Schema = z.unknown() as unknown as ToZod<VerifyProjectDomain401>

/**
 * @description You do not have permission to access this resource.
 */
export const verifyProjectDomain403Schema = z.unknown() as unknown as ToZod<VerifyProjectDomain403>

export const verifyProjectDomainMutationResponseSchema = z.lazy(() => verifyProjectDomain200Schema) as unknown as ToZod<VerifyProjectDomainMutationResponse>

export const filterProjectEnvsPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
}) as unknown as ToZod<FilterProjectEnvsPathParams>

export const filterProjectEnvsQueryParamsSchema = z
  .object({
    gitBranch: z
      .string()
      .max(250)
      .describe('If defined, the git branch of the environment variable to filter the results (must have target=preview)')
      .optional(),
    decrypt: z.enum(['true', 'false']).describe('If true, the environment variable value will be decrypted').optional(),
    source: z.string().describe('The source that is calling the endpoint.').optional(),
    customEnvironmentId: z.string().describe('The unique custom environment identifier within the project').optional(),
    customEnvironmentSlug: z.string().describe('The custom environment slug (name) within the project').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<FilterProjectEnvsQueryParams>

/**
 * @description The list of environment variables for the given project
 */
export const filterProjectEnvs200Schema = z.union([
  z.object({
    target: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])]).optional(),
    type: z.enum(['system', 'encrypted', 'plain', 'sensitive', 'secret']).optional(),
    sunsetSecretId: z.string().describe('This is used to identiy variables that have been migrated from type secret to sensitive.').optional(),
    decrypted: z.boolean().optional(),
    value: z.string().optional(),
    vsmValue: z.string().optional(),
    id: z.string().optional(),
    key: z.string().optional(),
    configurationId: z.string().nullable().nullish(),
    createdAt: z.number().optional(),
    updatedAt: z.number().optional(),
    createdBy: z.string().nullable().nullish(),
    updatedBy: z.string().nullable().nullish(),
    gitBranch: z.string().optional(),
    edgeConfigId: z.string().nullable().nullish(),
    edgeConfigTokenId: z.string().nullable().nullish(),
    contentHint: z
      .union([
        z.object({
          type: z.enum(['redis-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-read-only-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['blob-read-write-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url-non-pooling']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-prisma-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-user']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-host']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-password']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-database']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url-no-ssl']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['integration-store-secret']),
          storeId: z.string(),
          integrationId: z.string(),
          integrationProductId: z.string(),
          integrationConfigurationId: z.string(),
        }),
        z.object({
          type: z.enum(['flags-connection-string']),
          projectId: z.string(),
        }),
      ])
      .nullable()
      .nullish(),
    internalContentHint: z
      .object({
        type: z.enum(['flags-secret']),
        encryptedValue: z
          .string()
          .describe('Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.'),
      })
      .describe('Similar to `contentHints`, but should not be exposed to the user.')
      .nullable()
      .nullish(),
    comment: z.string().optional(),
    customEnvironmentIds: z.array(z.string()).optional(),
    system: z.boolean().optional(),
  }),
  z.object({
    envs: z.array(
      z.object({
        target: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])]).optional(),
        type: z.enum(['system', 'encrypted', 'plain', 'sensitive', 'secret']).optional(),
        sunsetSecretId: z.string().describe('This is used to identiy variables that have been migrated from type secret to sensitive.').optional(),
        decrypted: z.boolean().optional(),
        value: z.string().optional(),
        vsmValue: z.string().optional(),
        id: z.string().optional(),
        key: z.string().optional(),
        configurationId: z.string().nullable().nullish(),
        createdAt: z.number().optional(),
        updatedAt: z.number().optional(),
        createdBy: z.string().nullable().nullish(),
        updatedBy: z.string().nullable().nullish(),
        gitBranch: z.string().optional(),
        edgeConfigId: z.string().nullable().nullish(),
        edgeConfigTokenId: z.string().nullable().nullish(),
        contentHint: z
          .union([
            z.object({
              type: z.enum(['redis-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-read-only-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['blob-read-write-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url-non-pooling']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-prisma-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-user']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-host']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-password']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-database']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url-no-ssl']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['integration-store-secret']),
              storeId: z.string(),
              integrationId: z.string(),
              integrationProductId: z.string(),
              integrationConfigurationId: z.string(),
            }),
            z.object({
              type: z.enum(['flags-connection-string']),
              projectId: z.string(),
            }),
          ])
          .nullable()
          .nullish(),
        internalContentHint: z
          .object({
            type: z.enum(['flags-secret']),
            encryptedValue: z
              .string()
              .describe('Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.'),
          })
          .describe('Similar to `contentHints`, but should not be exposed to the user.')
          .nullable()
          .nullish(),
        comment: z.string().optional(),
        customEnvironmentIds: z.array(z.string()).optional(),
        system: z.boolean().optional(),
      }),
    ),
    pagination: z
      .lazy(() => paginationSchema)
      .describe(
        'This object contains information related to the pagination of the current request, including the necessary parameters to get the next or previous page of data.',
      ),
  }),
  z.object({
    envs: z.array(
      z.object({
        target: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])]).optional(),
        type: z.enum(['system', 'encrypted', 'plain', 'sensitive', 'secret']).optional(),
        sunsetSecretId: z.string().describe('This is used to identiy variables that have been migrated from type secret to sensitive.').optional(),
        decrypted: z.boolean().optional(),
        value: z.string().optional(),
        vsmValue: z.string().optional(),
        id: z.string().optional(),
        key: z.string().optional(),
        configurationId: z.string().nullable().nullish(),
        createdAt: z.number().optional(),
        updatedAt: z.number().optional(),
        createdBy: z.string().nullable().nullish(),
        updatedBy: z.string().nullable().nullish(),
        gitBranch: z.string().optional(),
        edgeConfigId: z.string().nullable().nullish(),
        edgeConfigTokenId: z.string().nullable().nullish(),
        contentHint: z
          .union([
            z.object({
              type: z.enum(['redis-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-read-only-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['blob-read-write-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url-non-pooling']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-prisma-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-user']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-host']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-password']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-database']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url-no-ssl']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['integration-store-secret']),
              storeId: z.string(),
              integrationId: z.string(),
              integrationProductId: z.string(),
              integrationConfigurationId: z.string(),
            }),
            z.object({
              type: z.enum(['flags-connection-string']),
              projectId: z.string(),
            }),
          ])
          .nullable()
          .nullish(),
        internalContentHint: z
          .object({
            type: z.enum(['flags-secret']),
            encryptedValue: z
              .string()
              .describe('Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.'),
          })
          .describe('Similar to `contentHints`, but should not be exposed to the user.')
          .nullable()
          .nullish(),
        comment: z.string().optional(),
        customEnvironmentIds: z.array(z.string()).optional(),
        system: z.boolean().optional(),
      }),
    ),
  }),
]) as unknown as ToZod<FilterProjectEnvs200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const filterProjectEnvs400Schema = z.unknown() as unknown as ToZod<FilterProjectEnvs400>

export const filterProjectEnvs401Schema = z.unknown() as unknown as ToZod<FilterProjectEnvs401>

/**
 * @description You do not have permission to access this resource.
 */
export const filterProjectEnvs403Schema = z.unknown() as unknown as ToZod<FilterProjectEnvs403>

export const filterProjectEnvsQueryResponseSchema = z.lazy(() => filterProjectEnvs200Schema) as unknown as ToZod<FilterProjectEnvsQueryResponse>

export const createProjectEnvPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
}) as unknown as ToZod<CreateProjectEnvPathParams>

export const createProjectEnvQueryParamsSchema = z
  .object({
    upsert: z.string().describe('Allow override of environment variable if it already exists').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<CreateProjectEnvQueryParams>

/**
 * @description The environment variable was created successfully
 */
export const createProjectEnv201Schema = z.object({
  created: z.union([
    z.array(
      z.object({
        target: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])]).optional(),
        type: z.enum(['system', 'secret', 'encrypted', 'plain', 'sensitive']).optional(),
        sunsetSecretId: z.string().describe('This is used to identiy variables that have been migrated from type secret to sensitive.').optional(),
        decrypted: z.boolean().optional(),
        value: z.string().optional(),
        vsmValue: z.string().optional(),
        id: z.string().optional(),
        key: z.string().optional(),
        configurationId: z.string().nullable().nullish(),
        createdAt: z.number().optional(),
        updatedAt: z.number().optional(),
        createdBy: z.string().nullable().nullish(),
        updatedBy: z.string().nullable().nullish(),
        gitBranch: z.string().optional(),
        edgeConfigId: z.string().nullable().nullish(),
        edgeConfigTokenId: z.string().nullable().nullish(),
        contentHint: z
          .union([
            z.object({
              type: z.enum(['redis-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['redis-rest-api-read-only-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['blob-read-write-token']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url-non-pooling']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-prisma-url']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-user']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-host']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-password']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-database']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['postgres-url-no-ssl']),
              storeId: z.string(),
            }),
            z.object({
              type: z.enum(['integration-store-secret']),
              storeId: z.string(),
              integrationId: z.string(),
              integrationProductId: z.string(),
              integrationConfigurationId: z.string(),
            }),
            z.object({
              type: z.enum(['flags-connection-string']),
              projectId: z.string(),
            }),
          ])
          .nullable()
          .nullish(),
        internalContentHint: z
          .object({
            type: z.enum(['flags-secret']),
            encryptedValue: z
              .string()
              .describe('Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.'),
          })
          .describe('Similar to `contentHints`, but should not be exposed to the user.')
          .nullable()
          .nullish(),
        comment: z.string().optional(),
        customEnvironmentIds: z.array(z.string()).optional(),
        system: z.boolean().optional(),
      }),
    ),
    z.object({
      target: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])]).optional(),
      type: z.enum(['system', 'secret', 'encrypted', 'plain', 'sensitive']).optional(),
      sunsetSecretId: z.string().describe('This is used to identiy variables that have been migrated from type secret to sensitive.').optional(),
      decrypted: z.boolean().optional(),
      value: z.string().optional(),
      vsmValue: z.string().optional(),
      id: z.string().optional(),
      key: z.string().optional(),
      configurationId: z.string().nullable().nullish(),
      createdAt: z.number().optional(),
      updatedAt: z.number().optional(),
      createdBy: z.string().nullable().nullish(),
      updatedBy: z.string().nullable().nullish(),
      gitBranch: z.string().optional(),
      edgeConfigId: z.string().nullable().nullish(),
      edgeConfigTokenId: z.string().nullable().nullish(),
      contentHint: z
        .union([
          z.object({
            type: z.enum(['redis-url']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['redis-rest-api-url']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['redis-rest-api-token']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['redis-rest-api-read-only-token']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['blob-read-write-token']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['postgres-url']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['postgres-url-non-pooling']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['postgres-prisma-url']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['postgres-user']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['postgres-host']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['postgres-password']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['postgres-database']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['postgres-url-no-ssl']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['integration-store-secret']),
            storeId: z.string(),
            integrationId: z.string(),
            integrationProductId: z.string(),
            integrationConfigurationId: z.string(),
          }),
          z.object({
            type: z.enum(['flags-connection-string']),
            projectId: z.string(),
          }),
        ])
        .nullable()
        .nullish(),
      internalContentHint: z
        .object({
          type: z.enum(['flags-secret']),
          encryptedValue: z
            .string()
            .describe('Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.'),
        })
        .describe('Similar to `contentHints`, but should not be exposed to the user.')
        .nullable()
        .nullish(),
      comment: z.string().optional(),
      customEnvironmentIds: z.array(z.string()).optional(),
      system: z.boolean().optional(),
    }),
  ]),
  failed: z.array(
    z.object({
      error: z.object({
        code: z.string(),
        message: z.string(),
        key: z.string().optional(),
        envVarId: z.string().optional(),
        envVarKey: z.string().optional(),
        action: z.string().optional(),
        link: z.string().optional(),
        value: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.string()]).optional(),
        gitBranch: z.string().optional(),
        target: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])]).optional(),
        project: z.string().optional(),
      }),
    }),
  ),
}) as unknown as ToZod<CreateProjectEnv201>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.\nThe environment variable coudn\'t be created because an ongoing update env update is already happening\nThe environment variable coudn\'t be created because project document is too large
 */
export const createProjectEnv400Schema = z.unknown() as unknown as ToZod<CreateProjectEnv400>

export const createProjectEnv401Schema = z.unknown() as unknown as ToZod<CreateProjectEnv401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const createProjectEnv402Schema = z.unknown() as unknown as ToZod<CreateProjectEnv402>

/**
 * @description You do not have permission to access this resource.\nThe environment variable cannot be created because it already exists\nAdditional permissions are required to create production environment variables
 */
export const createProjectEnv403Schema = z.unknown() as unknown as ToZod<CreateProjectEnv403>

/**
 * @description The project is being transfered and creating an environment variable is not possible
 */
export const createProjectEnv409Schema = z.unknown() as unknown as ToZod<CreateProjectEnv409>

export const createProjectEnvMutationRequestSchema = z.union([z.array()]) as unknown as ToZod<CreateProjectEnvMutationRequest>

export const createProjectEnvMutationResponseSchema = z.lazy(() => createProjectEnv201Schema) as unknown as ToZod<CreateProjectEnvMutationResponse>

export const getProjectEnvPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
  id: z.string().describe('The unique ID for the environment variable to get the decrypted value.'),
}) as unknown as ToZod<GetProjectEnvPathParams>

export const getProjectEnvQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetProjectEnvQueryParams>

export const getProjectEnv200Schema = z.union([
  z.object({
    decrypted: z.boolean(),
    target: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])]).optional(),
    type: z.enum(['system', 'encrypted', 'plain', 'sensitive', 'secret']),
    sunsetSecretId: z.string().describe('This is used to identiy variables that have been migrated from type secret to sensitive.').optional(),
    id: z.string().optional(),
    key: z.string(),
    configurationId: z.string().nullable().nullish(),
    createdAt: z.number().optional(),
    updatedAt: z.number().optional(),
    createdBy: z.string().nullable().nullish(),
    updatedBy: z.string().nullable().nullish(),
    gitBranch: z.string().optional(),
    edgeConfigId: z.string().nullable().nullish(),
    edgeConfigTokenId: z.string().nullable().nullish(),
    contentHint: z
      .union([
        z.object({
          type: z.enum(['redis-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-read-only-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['blob-read-write-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url-non-pooling']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-prisma-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-user']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-host']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-password']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-database']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url-no-ssl']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['integration-store-secret']),
          storeId: z.string(),
          integrationId: z.string(),
          integrationProductId: z.string(),
          integrationConfigurationId: z.string(),
        }),
        z.object({
          type: z.enum(['flags-connection-string']),
          projectId: z.string(),
        }),
      ])
      .nullable()
      .nullish(),
    internalContentHint: z
      .object({
        type: z.enum(['flags-secret']),
        encryptedValue: z
          .string()
          .describe('Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.'),
      })
      .describe('Similar to `contentHints`, but should not be exposed to the user.')
      .nullable()
      .nullish(),
    comment: z.string().optional(),
    customEnvironmentIds: z.array(z.string()).optional(),
  }),
  z.object({
    target: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])]).optional(),
    type: z.enum(['system', 'encrypted', 'plain', 'sensitive', 'secret']),
    sunsetSecretId: z.string().describe('This is used to identiy variables that have been migrated from type secret to sensitive.').optional(),
    decrypted: z.boolean().optional(),
    value: z.string(),
    vsmValue: z.string().optional(),
    id: z.string().optional(),
    key: z.string(),
    configurationId: z.string().nullable().nullish(),
    createdAt: z.number().optional(),
    updatedAt: z.number().optional(),
    createdBy: z.string().nullable().nullish(),
    updatedBy: z.string().nullable().nullish(),
    gitBranch: z.string().optional(),
    edgeConfigId: z.string().nullable().nullish(),
    edgeConfigTokenId: z.string().nullable().nullish(),
    contentHint: z
      .union([
        z.object({
          type: z.enum(['redis-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-read-only-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['blob-read-write-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url-non-pooling']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-prisma-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-user']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-host']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-password']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-database']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url-no-ssl']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['integration-store-secret']),
          storeId: z.string(),
          integrationId: z.string(),
          integrationProductId: z.string(),
          integrationConfigurationId: z.string(),
        }),
        z.object({
          type: z.enum(['flags-connection-string']),
          projectId: z.string(),
        }),
      ])
      .nullable()
      .nullish(),
    internalContentHint: z
      .object({
        type: z.enum(['flags-secret']),
        encryptedValue: z
          .string()
          .describe('Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.'),
      })
      .describe('Similar to `contentHints`, but should not be exposed to the user.')
      .nullable()
      .nullish(),
    comment: z.string().optional(),
    customEnvironmentIds: z.array(z.string()).optional(),
  }),
  z.object({
    target: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])]).optional(),
    type: z.enum(['system', 'encrypted', 'plain', 'sensitive', 'secret']),
    sunsetSecretId: z.string().describe('This is used to identiy variables that have been migrated from type secret to sensitive.').optional(),
    decrypted: z.boolean().optional(),
    value: z.string(),
    id: z.string().optional(),
    key: z.string(),
    configurationId: z.string().nullable().nullish(),
    createdAt: z.number().optional(),
    updatedAt: z.number().optional(),
    createdBy: z.string().nullable().nullish(),
    updatedBy: z.string().nullable().nullish(),
    gitBranch: z.string().optional(),
    edgeConfigId: z.string().nullable().nullish(),
    edgeConfigTokenId: z.string().nullable().nullish(),
    contentHint: z
      .union([
        z.object({
          type: z.enum(['redis-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-read-only-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['blob-read-write-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url-non-pooling']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-prisma-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-user']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-host']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-password']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-database']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url-no-ssl']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['integration-store-secret']),
          storeId: z.string(),
          integrationId: z.string(),
          integrationProductId: z.string(),
          integrationConfigurationId: z.string(),
        }),
        z.object({
          type: z.enum(['flags-connection-string']),
          projectId: z.string(),
        }),
      ])
      .nullable()
      .nullish(),
    internalContentHint: z
      .object({
        type: z.enum(['flags-secret']),
        encryptedValue: z
          .string()
          .describe('Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.'),
      })
      .describe('Similar to `contentHints`, but should not be exposed to the user.')
      .nullable()
      .nullish(),
    comment: z.string().optional(),
    customEnvironmentIds: z.array(z.string()).optional(),
  }),
]) as unknown as ToZod<GetProjectEnv200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getProjectEnv400Schema = z.unknown() as unknown as ToZod<GetProjectEnv400>

export const getProjectEnv401Schema = z.unknown() as unknown as ToZod<GetProjectEnv401>

/**
 * @description You do not have permission to access this resource.
 */
export const getProjectEnv403Schema = z.unknown() as unknown as ToZod<GetProjectEnv403>

export const getProjectEnvQueryResponseSchema = z.lazy(() => getProjectEnv200Schema) as unknown as ToZod<GetProjectEnvQueryResponse>

export const removeProjectEnvPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
  id: z.string().describe('The unique environment variable identifier'),
}) as unknown as ToZod<RemoveProjectEnvPathParams>

export const removeProjectEnvQueryParamsSchema = z
  .object({
    customEnvironmentId: z.string().describe('The unique custom environment identifier within the project').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<RemoveProjectEnvQueryParams>

/**
 * @description The environment variable was successfully removed
 */
export const removeProjectEnv200Schema = z.union([
  z.array(
    z.object({
      target: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])]).optional(),
      type: z.enum(['system', 'secret', 'encrypted', 'plain', 'sensitive']),
      sunsetSecretId: z.string().describe('This is used to identiy variables that have been migrated from type secret to sensitive.').optional(),
      decrypted: z.boolean().optional(),
      value: z.string(),
      vsmValue: z.string().optional(),
      id: z.string().optional(),
      key: z.string(),
      configurationId: z.string().nullable().nullish(),
      createdAt: z.number().optional(),
      updatedAt: z.number().optional(),
      createdBy: z.string().nullable().nullish(),
      updatedBy: z.string().nullable().nullish(),
      gitBranch: z.string().optional(),
      edgeConfigId: z.string().nullable().nullish(),
      edgeConfigTokenId: z.string().nullable().nullish(),
      contentHint: z
        .union([
          z.object({
            type: z.enum(['redis-url']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['redis-rest-api-url']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['redis-rest-api-token']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['redis-rest-api-read-only-token']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['blob-read-write-token']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['postgres-url']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['postgres-url-non-pooling']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['postgres-prisma-url']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['postgres-user']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['postgres-host']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['postgres-password']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['postgres-database']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['postgres-url-no-ssl']),
            storeId: z.string(),
          }),
          z.object({
            type: z.enum(['integration-store-secret']),
            storeId: z.string(),
            integrationId: z.string(),
            integrationProductId: z.string(),
            integrationConfigurationId: z.string(),
          }),
          z.object({
            type: z.enum(['flags-connection-string']),
            projectId: z.string(),
          }),
        ])
        .nullable()
        .nullish(),
      internalContentHint: z
        .object({
          type: z.enum(['flags-secret']),
          encryptedValue: z
            .string()
            .describe('Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.'),
        })
        .describe('Similar to `contentHints`, but should not be exposed to the user.')
        .nullable()
        .nullish(),
      comment: z.string().optional(),
      customEnvironmentIds: z.array(z.string()).optional(),
    }),
  ),
  z.object({
    system: z.boolean().optional(),
    target: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])]).optional(),
    type: z.enum(['system', 'secret', 'encrypted', 'plain', 'sensitive']),
    sunsetSecretId: z.string().describe('This is used to identiy variables that have been migrated from type secret to sensitive.').optional(),
    decrypted: z.boolean().optional(),
    value: z.string(),
    vsmValue: z.string().optional(),
    id: z.string().optional(),
    key: z.string(),
    configurationId: z.string().nullable().nullish(),
    createdAt: z.number().optional(),
    updatedAt: z.number().optional(),
    createdBy: z.string().nullable().nullish(),
    updatedBy: z.string().nullable().nullish(),
    gitBranch: z.string().optional(),
    edgeConfigId: z.string().nullable().nullish(),
    edgeConfigTokenId: z.string().nullable().nullish(),
    contentHint: z
      .union([
        z.object({
          type: z.enum(['redis-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-read-only-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['blob-read-write-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url-non-pooling']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-prisma-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-user']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-host']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-password']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-database']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url-no-ssl']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['integration-store-secret']),
          storeId: z.string(),
          integrationId: z.string(),
          integrationProductId: z.string(),
          integrationConfigurationId: z.string(),
        }),
        z.object({
          type: z.enum(['flags-connection-string']),
          projectId: z.string(),
        }),
      ])
      .nullable()
      .nullish(),
    internalContentHint: z
      .object({
        type: z.enum(['flags-secret']),
        encryptedValue: z
          .string()
          .describe('Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.'),
      })
      .describe('Similar to `contentHints`, but should not be exposed to the user.')
      .nullable()
      .nullish(),
    comment: z.string().optional(),
    customEnvironmentIds: z.array(z.string()).optional(),
  }),
  z.object({
    target: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])]).optional(),
    type: z.enum(['system', 'secret', 'encrypted', 'plain', 'sensitive']),
    sunsetSecretId: z.string().describe('This is used to identiy variables that have been migrated from type secret to sensitive.').optional(),
    decrypted: z.boolean().optional(),
    value: z.string(),
    vsmValue: z.string().optional(),
    id: z.string().optional(),
    key: z.string(),
    configurationId: z.string().nullable().nullish(),
    createdAt: z.number().optional(),
    updatedAt: z.number().optional(),
    createdBy: z.string().nullable().nullish(),
    updatedBy: z.string().nullable().nullish(),
    gitBranch: z.string().optional(),
    edgeConfigId: z.string().nullable().nullish(),
    edgeConfigTokenId: z.string().nullable().nullish(),
    contentHint: z
      .union([
        z.object({
          type: z.enum(['redis-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-read-only-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['blob-read-write-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url-non-pooling']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-prisma-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-user']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-host']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-password']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-database']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url-no-ssl']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['integration-store-secret']),
          storeId: z.string(),
          integrationId: z.string(),
          integrationProductId: z.string(),
          integrationConfigurationId: z.string(),
        }),
        z.object({
          type: z.enum(['flags-connection-string']),
          projectId: z.string(),
        }),
      ])
      .nullable()
      .nullish(),
    internalContentHint: z
      .object({
        type: z.enum(['flags-secret']),
        encryptedValue: z
          .string()
          .describe('Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.'),
      })
      .describe('Similar to `contentHints`, but should not be exposed to the user.')
      .nullable()
      .nullish(),
    comment: z.string().optional(),
    customEnvironmentIds: z.array(z.string()).optional(),
  }),
]) as unknown as ToZod<RemoveProjectEnv200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const removeProjectEnv400Schema = z.unknown() as unknown as ToZod<RemoveProjectEnv400>

export const removeProjectEnv401Schema = z.unknown() as unknown as ToZod<RemoveProjectEnv401>

/**
 * @description You do not have permission to access this resource.
 */
export const removeProjectEnv403Schema = z.unknown() as unknown as ToZod<RemoveProjectEnv403>

export const removeProjectEnv404Schema = z.unknown() as unknown as ToZod<RemoveProjectEnv404>

/**
 * @description The project is being transfered and removing an environment variable is not possible
 */
export const removeProjectEnv409Schema = z.unknown() as unknown as ToZod<RemoveProjectEnv409>

export const removeProjectEnvMutationResponseSchema = z.lazy(() => removeProjectEnv200Schema) as unknown as ToZod<RemoveProjectEnvMutationResponse>

export const editProjectEnvPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
  id: z.string().describe('The unique environment variable identifier'),
}) as unknown as ToZod<EditProjectEnvPathParams>

export const editProjectEnvQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<EditProjectEnvQueryParams>

/**
 * @description The environment variable was successfully edited
 */
export const editProjectEnv200Schema = z.union([
  z.object({
    target: z.union([z.array(z.enum(['production', 'preview', 'development'])), z.enum(['production', 'preview', 'development'])]).optional(),
    type: z.enum(['system', 'secret', 'encrypted', 'plain', 'sensitive']),
    sunsetSecretId: z.string().describe('This is used to identiy variables that have been migrated from type secret to sensitive.').optional(),
    decrypted: z.boolean().optional(),
    value: z.string(),
    id: z.string().optional(),
    key: z.string(),
    configurationId: z.string().nullable().nullish(),
    createdAt: z.number().optional(),
    updatedAt: z.number().optional(),
    createdBy: z.string().nullable().nullish(),
    updatedBy: z.string().nullable().nullish(),
    gitBranch: z.string().optional(),
    edgeConfigId: z.string().nullable().nullish(),
    edgeConfigTokenId: z.string().nullable().nullish(),
    contentHint: z
      .union([
        z.object({
          type: z.enum(['redis-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['redis-rest-api-read-only-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['blob-read-write-token']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url-non-pooling']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-prisma-url']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-user']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-host']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-password']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-database']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['postgres-url-no-ssl']),
          storeId: z.string(),
        }),
        z.object({
          type: z.enum(['integration-store-secret']),
          storeId: z.string(),
          integrationId: z.string(),
          integrationProductId: z.string(),
          integrationConfigurationId: z.string(),
        }),
        z.object({
          type: z.enum(['flags-connection-string']),
          projectId: z.string(),
        }),
      ])
      .nullable()
      .nullish(),
    internalContentHint: z
      .object({
        type: z.enum(['flags-secret']),
        encryptedValue: z
          .string()
          .describe('Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.'),
      })
      .describe('Similar to `contentHints`, but should not be exposed to the user.')
      .nullable()
      .nullish(),
    comment: z.string().optional(),
    customEnvironmentIds: z.array(z.string()).optional(),
  }),
  z.object({}),
]) as unknown as ToZod<EditProjectEnv200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.\nAt least one environment variable failed validation
 */
export const editProjectEnv400Schema = z.unknown() as unknown as ToZod<EditProjectEnv400>

export const editProjectEnv401Schema = z.unknown() as unknown as ToZod<EditProjectEnv401>

/**
 * @description You do not have permission to access this resource.
 */
export const editProjectEnv403Schema = z.unknown() as unknown as ToZod<EditProjectEnv403>

/**
 * @description The project is being transfered and removing an environment variable is not possible
 */
export const editProjectEnv409Schema = z.unknown() as unknown as ToZod<EditProjectEnv409>

export const editProjectEnvMutationRequestSchema = z.object({
  key: z.string().describe('The name of the environment variable').optional(),
  target: z
    .array(z.enum(['development', 'preview', 'production']))
    .describe('The target environment of the environment variable')
    .optional(),
  gitBranch: z.string().max(250).describe('If defined, the git branch of the environment variable (must have target=preview)').nullable().nullish(),
  type: z.enum(['encrypted', 'plain', 'secret', 'sensitive', 'system']).describe('The type of environment variable').optional(),
  value: z.string().describe('The value of the environment variable').optional(),
  customEnvironmentIds: z.array(z.string()).describe('The custom environments that the environment variable should be synced to').optional(),
  comment: z.string().max(500).describe('A comment to add context on what this env var is for').optional(),
}) as unknown as ToZod<EditProjectEnvMutationRequest>

export const editProjectEnvMutationResponseSchema = z.lazy(() => editProjectEnv200Schema) as unknown as ToZod<EditProjectEnvMutationResponse>

export const getRollingReleaseBillingStatusPathParamsSchema = z.object({
  idOrName: z.string().describe('Project ID or project name (URL-encoded)'),
}) as unknown as ToZod<GetRollingReleaseBillingStatusPathParams>

export const getRollingReleaseBillingStatusQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetRollingReleaseBillingStatusQueryParams>

export const getRollingReleaseBillingStatus200Schema = z.union([
  z.object({
    availableSlots: z.literal(0),
    reason: z.enum(['plan_not_supported']),
    message: z.string(),
  }),
  z.object({
    availableSlots: z.enum(['unlimited']),
    reason: z.enum(['unlimited_slots']),
    message: z.string(),
  }),
  z.object({
    availableSlots: z.literal(0),
    reason: z.enum(['no_available_slots']),
    message: z.string(),
    enabledProjects: z.array(z.string()),
  }),
  z.object({
    availableSlots: z.number(),
    reason: z.enum(['available_slots']),
    message: z.string(),
  }),
]) as unknown as ToZod<GetRollingReleaseBillingStatus200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getRollingReleaseBillingStatus400Schema = z.unknown() as unknown as ToZod<GetRollingReleaseBillingStatus400>

export const getRollingReleaseBillingStatus401Schema = z.unknown() as unknown as ToZod<GetRollingReleaseBillingStatus401>

/**
 * @description You do not have permission to access this resource.
 */
export const getRollingReleaseBillingStatus403Schema = z.unknown() as unknown as ToZod<GetRollingReleaseBillingStatus403>

export const getRollingReleaseBillingStatus404Schema = z.unknown() as unknown as ToZod<GetRollingReleaseBillingStatus404>

export const getRollingReleaseBillingStatusQueryResponseSchema = z.lazy(
  () => getRollingReleaseBillingStatus200Schema,
) as unknown as ToZod<GetRollingReleaseBillingStatusQueryResponse>

export const getRollingReleaseConfigPathParamsSchema = z.object({
  idOrName: z.string().describe('Project ID or project name (URL-encoded)'),
}) as unknown as ToZod<GetRollingReleaseConfigPathParams>

export const getRollingReleaseConfigQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetRollingReleaseConfigQueryParams>

export const getRollingReleaseConfig200Schema = z.object({
  rollingRelease: z
    .object({
      target: z
        .string()
        .describe(
          'The environment that the release targets, currently only supports production. Adding in case we want to configure with alias groups or custom environments.',
        ),
      stages: z
        .array(
          z
            .object({
              targetPercentage: z.number().describe('The percentage of traffic to serve to the canary deployment (0-100)'),
              requireApproval: z.boolean().describe('Whether or not this stage requires manual approval to proceed').optional(),
              duration: z.number().describe('Duration in minutes for automatic advancement to the next stage').optional(),
            })
            .describe(
              'An array of all the stages required during a deployment release. Each stage defines a target percentage and advancement rules. The final stage must always have targetPercentage: 100.',
            ),
        )
        .describe(
          'An array of all the stages required during a deployment release. Each stage defines a target percentage and advancement rules. The final stage must always have targetPercentage: 100.',
        )
        .nullable()
        .nullish(),
      canaryResponseHeader: z
        .boolean()
        .describe('Whether the request served by a canary deployment should return a header indicating a canary was served. Defaults to `false` when omitted.')
        .optional(),
    })
    .describe('Project-level rolling release configuration that defines how deployments should be gradually rolled out')
    .nullable(),
}) as unknown as ToZod<GetRollingReleaseConfig200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getRollingReleaseConfig400Schema = z.unknown() as unknown as ToZod<GetRollingReleaseConfig400>

export const getRollingReleaseConfig401Schema = z.unknown() as unknown as ToZod<GetRollingReleaseConfig401>

/**
 * @description You do not have permission to access this resource.
 */
export const getRollingReleaseConfig403Schema = z.unknown() as unknown as ToZod<GetRollingReleaseConfig403>

export const getRollingReleaseConfig404Schema = z.unknown() as unknown as ToZod<GetRollingReleaseConfig404>

export const getRollingReleaseConfigQueryResponseSchema = z.lazy(
  () => getRollingReleaseConfig200Schema,
) as unknown as ToZod<GetRollingReleaseConfigQueryResponse>

export const deleteRollingReleaseConfigPathParamsSchema = z.object({
  idOrName: z.string().describe('Project ID or project name (URL-encoded)'),
}) as unknown as ToZod<DeleteRollingReleaseConfigPathParams>

export const deleteRollingReleaseConfigQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<DeleteRollingReleaseConfigQueryParams>

export const deleteRollingReleaseConfig200Schema = z.object({
  rollingRelease: z.unknown(),
}) as unknown as ToZod<DeleteRollingReleaseConfig200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const deleteRollingReleaseConfig400Schema = z.unknown() as unknown as ToZod<DeleteRollingReleaseConfig400>

export const deleteRollingReleaseConfig401Schema = z.unknown() as unknown as ToZod<DeleteRollingReleaseConfig401>

/**
 * @description You do not have permission to access this resource.
 */
export const deleteRollingReleaseConfig403Schema = z.unknown() as unknown as ToZod<DeleteRollingReleaseConfig403>

export const deleteRollingReleaseConfig404Schema = z.unknown() as unknown as ToZod<DeleteRollingReleaseConfig404>

export const deleteRollingReleaseConfigMutationResponseSchema = z.lazy(
  () => deleteRollingReleaseConfig200Schema,
) as unknown as ToZod<DeleteRollingReleaseConfigMutationResponse>

export const updateRollingReleaseConfigPathParamsSchema = z.object({
  idOrName: z.string().describe('Project ID or project name (URL-encoded)'),
}) as unknown as ToZod<UpdateRollingReleaseConfigPathParams>

export const updateRollingReleaseConfigQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<UpdateRollingReleaseConfigQueryParams>

export const updateRollingReleaseConfig200Schema = z.union([
  z.object({
    rollingRelease: z.unknown(),
  }),
  z.object({
    rollingRelease: z
      .object({
        stages: z
          .array(
            z
              .object({
                targetPercentage: z.number().describe('The percentage of traffic to serve to the canary deployment (0-100)'),
                requireApproval: z.boolean().describe('Whether or not this stage requires manual approval to proceed').optional(),
                duration: z.number().describe('Duration in minutes for automatic advancement to the next stage').optional(),
              })
              .describe(
                'A stage object configured for a rolling release once a new deployment is triggered the first stage will be read in the proxy for first time visitors, and if a RNG < targetPercentage then it will serve the new deployment. Upon approval the next stage will be read, etc.',
              ),
          )
          .nullable()
          .nullish(),
      })
      .nullable(),
  }),
]) as unknown as ToZod<UpdateRollingReleaseConfig200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const updateRollingReleaseConfig400Schema = z.unknown() as unknown as ToZod<UpdateRollingReleaseConfig400>

export const updateRollingReleaseConfig401Schema = z.unknown() as unknown as ToZod<UpdateRollingReleaseConfig401>

/**
 * @description You do not have permission to access this resource.
 */
export const updateRollingReleaseConfig403Schema = z.unknown() as unknown as ToZod<UpdateRollingReleaseConfig403>

export const updateRollingReleaseConfig404Schema = z.unknown() as unknown as ToZod<UpdateRollingReleaseConfig404>

export const updateRollingReleaseConfigMutationResponseSchema = z.lazy(
  () => updateRollingReleaseConfig200Schema,
) as unknown as ToZod<UpdateRollingReleaseConfigMutationResponse>

export const getRollingReleasePathParamsSchema = z.object({
  idOrName: z.string().describe('Project ID or project name (URL-encoded)'),
}) as unknown as ToZod<GetRollingReleasePathParams>

export const getRollingReleaseQueryParamsSchema = z
  .object({
    state: z.enum(['ACTIVE', 'COMPLETE', 'ABORTED']).describe('Filter by rolling release state').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetRollingReleaseQueryParams>

export const getRollingRelease200Schema = z
  .object({
    rollingRelease: z
      .object({
        state: z.enum(['ABORTED', 'ACTIVE', 'COMPLETE']).describe('The current state of the rolling release'),
        currentDeployment: z
          .object({
            id: z.string(),
            name: z.string(),
            url: z.string(),
            target: z.enum(['production', 'staging']).nullable().nullish(),
            source: z.enum(['api-trigger-git-deploy', 'cli', 'clone/repo', 'git', 'import', 'import/repo', 'redeploy', 'v0-web']).optional(),
            createdAt: z.number(),
            readyState: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
            readyStateAt: z.number().optional(),
          })
          .describe('The current deployment receiving production traffic')
          .nullable(),
        canaryDeployment: z
          .object({
            id: z.string(),
            name: z.string(),
            url: z.string(),
            target: z.enum(['production', 'staging']).nullable().nullish(),
            source: z.enum(['api-trigger-git-deploy', 'cli', 'clone/repo', 'git', 'import', 'import/repo', 'redeploy', 'v0-web']).optional(),
            createdAt: z.number(),
            readyState: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
            readyStateAt: z.number().optional(),
          })
          .describe('The canary deployment being rolled out')
          .nullable(),
        queuedDeploymentId: z.string().describe('The ID of a deployment queued for the next rolling release').nullable(),
        advancementType: z.enum(['automatic', 'manual-approval']).describe('The advancement type of the rolling release'),
        stages: z
          .array(
            z
              .object({
                index: z.number().describe('The zero-based index of the stage'),
                isFinalStage: z.boolean().describe('Whether or not this stage is the final stage (targetPercentage === 100)'),
                targetPercentage: z.number().describe('The percentage of traffic to serve to the canary deployment (0-100)'),
                requireApproval: z.boolean().describe('Whether or not this stage requires manual approval to proceed'),
                duration: z.number().describe('Duration in seconds for automatic advancement, null for manual stages or the final stage').nullable(),
              })
              .describe('All stages configured for this rolling release'),
          )
          .describe('All stages configured for this rolling release'),
        activeStage: z
          .object({
            index: z.number().describe('The zero-based index of the stage'),
            isFinalStage: z.boolean().describe('Whether or not this stage is the final stage (targetPercentage === 100)'),
            targetPercentage: z.number().describe('The percentage of traffic to serve to the canary deployment (0-100)'),
            requireApproval: z.boolean().describe('Whether or not this stage requires manual approval to proceed'),
            duration: z.number().describe('Duration in seconds for automatic advancement, null for manual stages or the final stage').nullable(),
          })
          .describe('The currently active stage, null if the rollout is aborted')
          .nullable(),
        nextStage: z
          .object({
            index: z.number().describe('The zero-based index of the stage'),
            isFinalStage: z.boolean().describe('Whether or not this stage is the final stage (targetPercentage === 100)'),
            targetPercentage: z.number().describe('The percentage of traffic to serve to the canary deployment (0-100)'),
            requireApproval: z.boolean().describe('Whether or not this stage requires manual approval to proceed'),
            duration: z.number().describe('Duration in seconds for automatic advancement, null for manual stages or the final stage').nullable(),
          })
          .describe('The next stage to be activated, null if not in ACTIVE state')
          .nullable(),
        startedAt: z.number().describe('Unix timestamp in milliseconds when the rolling release started'),
        updatedAt: z.number().describe('Unix timestamp in milliseconds when the rolling release was last updated'),
      })
      .describe('Rolling release information including configuration and document details, or null if no rolling release exists')
      .nullable(),
  })
  .describe('The response format for rolling release endpoints that return rolling release information') as unknown as ToZod<GetRollingRelease200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getRollingRelease400Schema = z.unknown() as unknown as ToZod<GetRollingRelease400>

export const getRollingRelease401Schema = z.unknown() as unknown as ToZod<GetRollingRelease401>

/**
 * @description You do not have permission to access this resource.
 */
export const getRollingRelease403Schema = z.unknown() as unknown as ToZod<GetRollingRelease403>

export const getRollingRelease404Schema = z.unknown() as unknown as ToZod<GetRollingRelease404>

export const getRollingReleaseQueryResponseSchema = z.lazy(() => getRollingRelease200Schema) as unknown as ToZod<GetRollingReleaseQueryResponse>

export const approveRollingReleaseStagePathParamsSchema = z.object({
  idOrName: z.string().describe('Project ID or project name (URL-encoded)'),
}) as unknown as ToZod<ApproveRollingReleaseStagePathParams>

export const approveRollingReleaseStageQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<ApproveRollingReleaseStageQueryParams>

export const approveRollingReleaseStage200Schema = z
  .object({
    rollingRelease: z
      .object({
        state: z.enum(['ABORTED', 'ACTIVE', 'COMPLETE']).describe('The current state of the rolling release'),
        currentDeployment: z
          .object({
            id: z.string(),
            name: z.string(),
            url: z.string(),
            target: z.enum(['production', 'staging']).nullable().nullish(),
            source: z.enum(['api-trigger-git-deploy', 'cli', 'clone/repo', 'git', 'import', 'import/repo', 'redeploy', 'v0-web']).optional(),
            createdAt: z.number(),
            readyState: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
            readyStateAt: z.number().optional(),
          })
          .describe('The current deployment receiving production traffic')
          .nullable(),
        canaryDeployment: z
          .object({
            id: z.string(),
            name: z.string(),
            url: z.string(),
            target: z.enum(['production', 'staging']).nullable().nullish(),
            source: z.enum(['api-trigger-git-deploy', 'cli', 'clone/repo', 'git', 'import', 'import/repo', 'redeploy', 'v0-web']).optional(),
            createdAt: z.number(),
            readyState: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
            readyStateAt: z.number().optional(),
          })
          .describe('The canary deployment being rolled out')
          .nullable(),
        queuedDeploymentId: z.string().describe('The ID of a deployment queued for the next rolling release').nullable(),
        advancementType: z.enum(['automatic', 'manual-approval']).describe('The advancement type of the rolling release'),
        stages: z
          .array(
            z
              .object({
                index: z.number().describe('The zero-based index of the stage'),
                isFinalStage: z.boolean().describe('Whether or not this stage is the final stage (targetPercentage === 100)'),
                targetPercentage: z.number().describe('The percentage of traffic to serve to the canary deployment (0-100)'),
                requireApproval: z.boolean().describe('Whether or not this stage requires manual approval to proceed'),
                duration: z.number().describe('Duration in seconds for automatic advancement, null for manual stages or the final stage').nullable(),
              })
              .describe('All stages configured for this rolling release'),
          )
          .describe('All stages configured for this rolling release'),
        activeStage: z
          .object({
            index: z.number().describe('The zero-based index of the stage'),
            isFinalStage: z.boolean().describe('Whether or not this stage is the final stage (targetPercentage === 100)'),
            targetPercentage: z.number().describe('The percentage of traffic to serve to the canary deployment (0-100)'),
            requireApproval: z.boolean().describe('Whether or not this stage requires manual approval to proceed'),
            duration: z.number().describe('Duration in seconds for automatic advancement, null for manual stages or the final stage').nullable(),
          })
          .describe('The currently active stage, null if the rollout is aborted')
          .nullable(),
        nextStage: z
          .object({
            index: z.number().describe('The zero-based index of the stage'),
            isFinalStage: z.boolean().describe('Whether or not this stage is the final stage (targetPercentage === 100)'),
            targetPercentage: z.number().describe('The percentage of traffic to serve to the canary deployment (0-100)'),
            requireApproval: z.boolean().describe('Whether or not this stage requires manual approval to proceed'),
            duration: z.number().describe('Duration in seconds for automatic advancement, null for manual stages or the final stage').nullable(),
          })
          .describe('The next stage to be activated, null if not in ACTIVE state')
          .nullable(),
        startedAt: z.number().describe('Unix timestamp in milliseconds when the rolling release started'),
        updatedAt: z.number().describe('Unix timestamp in milliseconds when the rolling release was last updated'),
      })
      .describe('Rolling release information including configuration and document details, or null if no rolling release exists')
      .nullable(),
  })
  .describe('The response format for rolling release endpoints that return rolling release information') as unknown as ToZod<ApproveRollingReleaseStage200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const approveRollingReleaseStage400Schema = z.unknown() as unknown as ToZod<ApproveRollingReleaseStage400>

export const approveRollingReleaseStage401Schema = z.unknown() as unknown as ToZod<ApproveRollingReleaseStage401>

/**
 * @description You do not have permission to access this resource.
 */
export const approveRollingReleaseStage403Schema = z.unknown() as unknown as ToZod<ApproveRollingReleaseStage403>

export const approveRollingReleaseStage404Schema = z.unknown() as unknown as ToZod<ApproveRollingReleaseStage404>

export const approveRollingReleaseStage500Schema = z.unknown() as unknown as ToZod<ApproveRollingReleaseStage500>

export const approveRollingReleaseStageMutationRequestSchema = z.object({
  nextStageIndex: z.number().describe('The index of the stage to transition to'),
  canaryDeploymentId: z.string().describe('The id of the canary deployment to approve for the next stage'),
}) as unknown as ToZod<ApproveRollingReleaseStageMutationRequest>

export const approveRollingReleaseStageMutationResponseSchema = z.lazy(
  () => approveRollingReleaseStage200Schema,
) as unknown as ToZod<ApproveRollingReleaseStageMutationResponse>

export const completeRollingReleasePathParamsSchema = z.object({
  idOrName: z.string().describe('Project ID or project name (URL-encoded)'),
}) as unknown as ToZod<CompleteRollingReleasePathParams>

export const completeRollingReleaseQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<CompleteRollingReleaseQueryParams>

export const completeRollingRelease200Schema = z
  .object({
    rollingRelease: z
      .object({
        state: z.enum(['ABORTED', 'ACTIVE', 'COMPLETE']).describe('The current state of the rolling release'),
        currentDeployment: z
          .object({
            id: z.string(),
            name: z.string(),
            url: z.string(),
            target: z.enum(['production', 'staging']).nullable().nullish(),
            source: z.enum(['api-trigger-git-deploy', 'cli', 'clone/repo', 'git', 'import', 'import/repo', 'redeploy', 'v0-web']).optional(),
            createdAt: z.number(),
            readyState: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
            readyStateAt: z.number().optional(),
          })
          .describe('The current deployment receiving production traffic')
          .nullable(),
        canaryDeployment: z
          .object({
            id: z.string(),
            name: z.string(),
            url: z.string(),
            target: z.enum(['production', 'staging']).nullable().nullish(),
            source: z.enum(['api-trigger-git-deploy', 'cli', 'clone/repo', 'git', 'import', 'import/repo', 'redeploy', 'v0-web']).optional(),
            createdAt: z.number(),
            readyState: z.enum(['BUILDING', 'CANCELED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']),
            readyStateAt: z.number().optional(),
          })
          .describe('The canary deployment being rolled out')
          .nullable(),
        queuedDeploymentId: z.string().describe('The ID of a deployment queued for the next rolling release').nullable(),
        advancementType: z.enum(['automatic', 'manual-approval']).describe('The advancement type of the rolling release'),
        stages: z
          .array(
            z
              .object({
                index: z.number().describe('The zero-based index of the stage'),
                isFinalStage: z.boolean().describe('Whether or not this stage is the final stage (targetPercentage === 100)'),
                targetPercentage: z.number().describe('The percentage of traffic to serve to the canary deployment (0-100)'),
                requireApproval: z.boolean().describe('Whether or not this stage requires manual approval to proceed'),
                duration: z.number().describe('Duration in seconds for automatic advancement, null for manual stages or the final stage').nullable(),
              })
              .describe('All stages configured for this rolling release'),
          )
          .describe('All stages configured for this rolling release'),
        activeStage: z
          .object({
            index: z.number().describe('The zero-based index of the stage'),
            isFinalStage: z.boolean().describe('Whether or not this stage is the final stage (targetPercentage === 100)'),
            targetPercentage: z.number().describe('The percentage of traffic to serve to the canary deployment (0-100)'),
            requireApproval: z.boolean().describe('Whether or not this stage requires manual approval to proceed'),
            duration: z.number().describe('Duration in seconds for automatic advancement, null for manual stages or the final stage').nullable(),
          })
          .describe('The currently active stage, null if the rollout is aborted')
          .nullable(),
        nextStage: z
          .object({
            index: z.number().describe('The zero-based index of the stage'),
            isFinalStage: z.boolean().describe('Whether or not this stage is the final stage (targetPercentage === 100)'),
            targetPercentage: z.number().describe('The percentage of traffic to serve to the canary deployment (0-100)'),
            requireApproval: z.boolean().describe('Whether or not this stage requires manual approval to proceed'),
            duration: z.number().describe('Duration in seconds for automatic advancement, null for manual stages or the final stage').nullable(),
          })
          .describe('The next stage to be activated, null if not in ACTIVE state')
          .nullable(),
        startedAt: z.number().describe('Unix timestamp in milliseconds when the rolling release started'),
        updatedAt: z.number().describe('Unix timestamp in milliseconds when the rolling release was last updated'),
      })
      .describe('Rolling release information including configuration and document details, or null if no rolling release exists')
      .nullable(),
  })
  .describe('The response format for rolling release endpoints that return rolling release information') as unknown as ToZod<CompleteRollingRelease200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const completeRollingRelease400Schema = z.unknown() as unknown as ToZod<CompleteRollingRelease400>

export const completeRollingRelease401Schema = z.unknown() as unknown as ToZod<CompleteRollingRelease401>

/**
 * @description You do not have permission to access this resource.
 */
export const completeRollingRelease403Schema = z.unknown() as unknown as ToZod<CompleteRollingRelease403>

export const completeRollingRelease404Schema = z.unknown() as unknown as ToZod<CompleteRollingRelease404>

export const completeRollingReleaseMutationRequestSchema = z.object({
  canaryDeploymentId: z.string().describe('The ID of the canary deployment to complete'),
}) as unknown as ToZod<CompleteRollingReleaseMutationRequest>

export const completeRollingReleaseMutationResponseSchema = z.lazy(
  () => completeRollingRelease200Schema,
) as unknown as ToZod<CompleteRollingReleaseMutationResponse>

export const createProjectTransferRequestPathParamsSchema = z.object({
  idOrName: z.string().describe('The ID or name of the project to transfer.'),
}) as unknown as ToZod<CreateProjectTransferRequestPathParams>

export const createProjectTransferRequestQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<CreateProjectTransferRequestQueryParams>

/**
 * @description The project transfer request has been initiated successfully.
 */
export const createProjectTransferRequest200Schema = z.object({
  code: z.string().describe('Code that can be used to accept the project transfer request.'),
}) as unknown as ToZod<CreateProjectTransferRequest200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const createProjectTransferRequest400Schema = z.unknown() as unknown as ToZod<CreateProjectTransferRequest400>

export const createProjectTransferRequest401Schema = z.unknown() as unknown as ToZod<CreateProjectTransferRequest401>

/**
 * @description You do not have permission to access this resource.
 */
export const createProjectTransferRequest403Schema = z.unknown() as unknown as ToZod<CreateProjectTransferRequest403>

export const createProjectTransferRequestMutationRequestSchema = z.object({
  callbackUrl: z.string().describe('The URL to send a webhook to when the transfer is accepted.').optional(),
  callbackSecret: z.string().describe('The secret to use to sign the webhook payload with HMAC-SHA256.').optional(),
}) as unknown as ToZod<CreateProjectTransferRequestMutationRequest>

export const createProjectTransferRequestMutationResponseSchema = z.lazy(
  () => createProjectTransferRequest200Schema,
) as unknown as ToZod<CreateProjectTransferRequestMutationResponse>

export const acceptProjectTransferRequestPathParamsSchema = z.object({
  code: z.string().describe('The code of the project transfer request.'),
}) as unknown as ToZod<AcceptProjectTransferRequestPathParams>

export const acceptProjectTransferRequestQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<AcceptProjectTransferRequestQueryParams>

/**
 * @description The project has been transferred successfully.
 */
export const acceptProjectTransferRequest202Schema = z.union([
  z.object({
    partnerCalls: z.array(
      z.object({
        installationId: z.string(),
        resourceIds: z.array(z.string()),
        result: z.object({
          status: z.enum(['fulfilled', 'errored']),
          error: z.object({}).optional(),
          code: z.string().optional(),
        }),
      }),
    ),
    resourceTransferErrors: z.array(z.object({})),
  }),
  z.object({}),
]) as unknown as ToZod<AcceptProjectTransferRequest202>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const acceptProjectTransferRequest400Schema = z.unknown() as unknown as ToZod<AcceptProjectTransferRequest400>

export const acceptProjectTransferRequest401Schema = z.unknown() as unknown as ToZod<AcceptProjectTransferRequest401>

/**
 * @description You do not have permission to access this resource.
 */
export const acceptProjectTransferRequest403Schema = z.unknown() as unknown as ToZod<AcceptProjectTransferRequest403>

export const acceptProjectTransferRequest404Schema = z.unknown() as unknown as ToZod<AcceptProjectTransferRequest404>

export const acceptProjectTransferRequest422Schema = z.unknown() as unknown as ToZod<AcceptProjectTransferRequest422>

export const acceptProjectTransferRequestMutationRequestSchema = z.object({
  newProjectName: z.string().max(100).describe('The desired name for the project').optional(),
  paidFeatures: z
    .object({
      concurrentBuilds: z.number().int().nullable().nullish(),
      passwordProtection: z.boolean().nullable().nullish(),
      previewDeploymentSuffix: z.boolean().nullable().nullish(),
    })
    .optional(),
}) as unknown as ToZod<AcceptProjectTransferRequestMutationRequest>

export const acceptProjectTransferRequestMutationResponseSchema = z.lazy(
  () => acceptProjectTransferRequest202Schema,
) as unknown as ToZod<AcceptProjectTransferRequestMutationResponse>

export const updateProjectProtectionBypassPathParamsSchema = z.object({
  idOrName: z.string().describe('The unique project identifier or the project name'),
}) as unknown as ToZod<UpdateProjectProtectionBypassPathParams>

export const updateProjectProtectionBypassQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<UpdateProjectProtectionBypassQueryParams>

export const updateProjectProtectionBypass200Schema = z.object({
  protectionBypass: z
    .object({})
    .catchall(
      z.union([
        z.object({
          createdAt: z.number(),
          createdBy: z.string(),
          scope: z.enum(['integration-automation-bypass']),
          integrationId: z.string(),
          configurationId: z.string(),
        }),
        z.object({
          createdAt: z.number(),
          createdBy: z.string(),
          scope: z.enum(['automation-bypass']),
        }),
      ]),
    )
    .optional(),
}) as unknown as ToZod<UpdateProjectProtectionBypass200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const updateProjectProtectionBypass400Schema = z.unknown() as unknown as ToZod<UpdateProjectProtectionBypass400>

export const updateProjectProtectionBypass401Schema = z.unknown() as unknown as ToZod<UpdateProjectProtectionBypass401>

/**
 * @description You do not have permission to access this resource.
 */
export const updateProjectProtectionBypass403Schema = z.unknown() as unknown as ToZod<UpdateProjectProtectionBypass403>

export const updateProjectProtectionBypass404Schema = z.unknown() as unknown as ToZod<UpdateProjectProtectionBypass404>

export const updateProjectProtectionBypass409Schema = z.unknown() as unknown as ToZod<UpdateProjectProtectionBypass409>

export const updateProjectProtectionBypassMutationRequestSchema = z.object({
  revoke: z
    .object({
      secret: z.string().describe('Automation bypass to revoked'),
      regenerate: z.boolean().describe('Whether or not a new automation bypass should be created after the provided secret is revoked'),
    })
    .describe('Optional instructions for revoking and regenerating a automation bypass')
    .optional(),
  generate: z
    .object({
      secret: z
        .string()
        .regex(/^[a-zA-Z0-9]{32}$/)
        .describe("Optional value of the secret to generate, don't send it for oauth2 tokens")
        .optional(),
    })
    .describe('Generate a new secret. If neither generate or revoke are provided, a new random secret will be generated.')
    .optional(),
}) as unknown as ToZod<UpdateProjectProtectionBypassMutationRequest>

export const updateProjectProtectionBypassMutationResponseSchema = z.lazy(
  () => updateProjectProtectionBypass200Schema,
) as unknown as ToZod<UpdateProjectProtectionBypassMutationResponse>

export const requestPromotePathParamsSchema = z.object({
  projectId: z.string(),
  deploymentId: z.string(),
}) as unknown as ToZod<RequestPromotePathParams>

export const requestPromoteQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<RequestPromoteQueryParams>

export const requestPromote201Schema = z.unknown() as unknown as ToZod<RequestPromote201>

export const requestPromote202Schema = z.unknown() as unknown as ToZod<RequestPromote202>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const requestPromote400Schema = z.unknown() as unknown as ToZod<RequestPromote400>

export const requestPromote401Schema = z.unknown() as unknown as ToZod<RequestPromote401>

/**
 * @description You do not have permission to access this resource.
 */
export const requestPromote403Schema = z.unknown() as unknown as ToZod<RequestPromote403>

export const requestPromote409Schema = z.unknown() as unknown as ToZod<RequestPromote409>

export const requestPromoteMutationResponseSchema = z.union([
  z.lazy(() => requestPromote201Schema),
  z.lazy(() => requestPromote202Schema),
]) as unknown as ToZod<RequestPromoteMutationResponse>

export const listPromoteAliasesPathParamsSchema = z.object({
  projectId: z.string(),
}) as unknown as ToZod<ListPromoteAliasesPathParams>

export const listPromoteAliasesQueryParamsSchema = z
  .object({
    limit: z.coerce.number().max(100).describe('Maximum number of aliases to list from a request (max 100).').optional(),
    since: z.coerce.number().describe('Get aliases created after this epoch timestamp.').optional(),
    until: z.coerce.number().describe('Get aliases created before this epoch timestamp.').optional(),
    failedOnly: z.boolean().describe('Filter results down to aliases that failed to map to the requested deployment').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<ListPromoteAliasesQueryParams>

export const listPromoteAliases200Schema = z.union([
  z.object({}),
  z.object({
    aliases: z.array(
      z.object({
        status: z.string(),
        alias: z.string(),
        id: z.string(),
      }),
    ),
    pagination: z
      .lazy(() => paginationSchema)
      .describe(
        'This object contains information related to the pagination of the current request, including the necessary parameters to get the next or previous page of data.',
      ),
  }),
]) as unknown as ToZod<ListPromoteAliases200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const listPromoteAliases400Schema = z.unknown() as unknown as ToZod<ListPromoteAliases400>

export const listPromoteAliases401Schema = z.unknown() as unknown as ToZod<ListPromoteAliases401>

/**
 * @description You do not have permission to access this resource.
 */
export const listPromoteAliases403Schema = z.unknown() as unknown as ToZod<ListPromoteAliases403>

export const listPromoteAliases404Schema = z.unknown() as unknown as ToZod<ListPromoteAliases404>

export const listPromoteAliasesQueryResponseSchema = z.lazy(() => listPromoteAliases200Schema) as unknown as ToZod<ListPromoteAliasesQueryResponse>

export const pauseProjectPathParamsSchema = z.object({
  projectId: z.string().describe('The unique project identifier'),
}) as unknown as ToZod<PauseProjectPathParams>

export const pauseProjectQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<PauseProjectQueryParams>

export const pauseProject200Schema = z.unknown() as unknown as ToZod<PauseProject200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const pauseProject400Schema = z.unknown() as unknown as ToZod<PauseProject400>

export const pauseProject401Schema = z.unknown() as unknown as ToZod<PauseProject401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const pauseProject402Schema = z.unknown() as unknown as ToZod<PauseProject402>

/**
 * @description You do not have permission to access this resource.
 */
export const pauseProject403Schema = z.unknown() as unknown as ToZod<PauseProject403>

export const pauseProject500Schema = z.unknown() as unknown as ToZod<PauseProject500>

export const pauseProjectMutationResponseSchema = z.lazy(() => pauseProject200Schema) as unknown as ToZod<PauseProjectMutationResponse>

export const unpauseProjectPathParamsSchema = z.object({
  projectId: z.string().describe('The unique project identifier'),
}) as unknown as ToZod<UnpauseProjectPathParams>

export const unpauseProjectQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<UnpauseProjectQueryParams>

export const unpauseProject200Schema = z.unknown() as unknown as ToZod<UnpauseProject200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const unpauseProject400Schema = z.unknown() as unknown as ToZod<UnpauseProject400>

export const unpauseProject401Schema = z.unknown() as unknown as ToZod<UnpauseProject401>

/**
 * @description You do not have permission to access this resource.
 */
export const unpauseProject403Schema = z.unknown() as unknown as ToZod<UnpauseProject403>

export const unpauseProject500Schema = z.unknown() as unknown as ToZod<UnpauseProject500>

export const unpauseProjectMutationResponseSchema = z.lazy(() => unpauseProject200Schema) as unknown as ToZod<UnpauseProjectMutationResponse>

export const updateAttackChallengeModeQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<UpdateAttackChallengeModeQueryParams>

export const updateAttackChallengeMode200Schema = z.object({
  attackModeEnabled: z.boolean(),
  attackModeUpdatedAt: z.number(),
}) as unknown as ToZod<UpdateAttackChallengeMode200>

/**
 * @description One of the provided values in the request body is invalid.
 */
export const updateAttackChallengeMode400Schema = z.unknown() as unknown as ToZod<UpdateAttackChallengeMode400>

export const updateAttackChallengeMode401Schema = z.unknown() as unknown as ToZod<UpdateAttackChallengeMode401>

/**
 * @description You do not have permission to access this resource.
 */
export const updateAttackChallengeMode403Schema = z.unknown() as unknown as ToZod<UpdateAttackChallengeMode403>

export const updateAttackChallengeMode404Schema = z.unknown() as unknown as ToZod<UpdateAttackChallengeMode404>

export const updateAttackChallengeModeMutationRequestSchema = z.object({
  projectId: z.string(),
  attackModeEnabled: z.boolean(),
  attackModeActiveUntil: z.number().nullable().nullish(),
}) as unknown as ToZod<UpdateAttackChallengeModeMutationRequest>

export const updateAttackChallengeModeMutationResponseSchema = z.lazy(
  () => updateAttackChallengeMode200Schema,
) as unknown as ToZod<UpdateAttackChallengeModeMutationResponse>

export const putFirewallConfigQueryParamsSchema = z.object({
  projectId: z.string(),
  teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
  slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
}) as unknown as ToZod<PutFirewallConfigQueryParams>

export const putFirewallConfig200Schema = z.object({
  active: z.object({
    ownerId: z.string(),
    projectKey: z.string(),
    id: z.string(),
    version: z.number(),
    updatedAt: z.string(),
    firewallEnabled: z.boolean(),
    crs: z.object({
      sd: z.object({
        active: z.boolean(),
        action: z.enum(['deny', 'log']),
      }),
      ma: z.object({
        active: z.boolean(),
        action: z.enum(['deny', 'log']),
      }),
      lfi: z.object({
        active: z.boolean(),
        action: z.enum(['deny', 'log']),
      }),
      rfi: z.object({
        active: z.boolean(),
        action: z.enum(['deny', 'log']),
      }),
      rce: z.object({
        active: z.boolean(),
        action: z.enum(['deny', 'log']),
      }),
      php: z.object({
        active: z.boolean(),
        action: z.enum(['deny', 'log']),
      }),
      gen: z.object({
        active: z.boolean(),
        action: z.enum(['deny', 'log']),
      }),
      xss: z.object({
        active: z.boolean(),
        action: z.enum(['deny', 'log']),
      }),
      sqli: z.object({
        active: z.boolean(),
        action: z.enum(['deny', 'log']),
      }),
      sf: z.object({
        active: z.boolean(),
        action: z.enum(['deny', 'log']),
      }),
      java: z.object({
        active: z.boolean(),
        action: z.enum(['deny', 'log']),
      }),
    }),
    rules: z.array(
      z.object({
        id: z.string(),
        name: z.string(),
        description: z.string().optional(),
        active: z.boolean(),
        conditionGroup: z.array(
          z.object({
            conditions: z.array(
              z.object({
                type: z.enum([
                  'cookie',
                  'environment',
                  'geo_as_number',
                  'geo_city',
                  'geo_continent',
                  'geo_country',
                  'geo_country_region',
                  'header',
                  'host',
                  'ip_address',
                  'ja3_digest',
                  'ja4_digest',
                  'method',
                  'path',
                  'protocol',
                  'query',
                  'rate_limit_api_id',
                  'raw_path',
                  'region',
                  'scheme',
                  'target_path',
                  'user_agent',
                ]),
                op: z.enum(['eq', 'ex', 'gt', 'gte', 'inc', 'lt', 'lte', 'neq', 'nex', 'ninc', 'pre', 're', 'sub', 'suf']),
                neg: z.boolean().optional(),
                key: z.string().optional(),
                value: z.union([z.array(z.string()), z.string(), z.number()]).optional(),
              }),
            ),
          }),
        ),
        action: z.object({
          mitigate: z
            .object({
              action: z.enum(['bypass', 'challenge', 'deny', 'log', 'rate_limit', 'redirect']),
              rateLimit: z
                .object({
                  algo: z.enum(['fixed_window', 'token_bucket']),
                  window: z.number(),
                  limit: z.number(),
                  keys: z.array(z.string()),
                  action: z.enum(['challenge', 'deny', 'log', 'rate_limit']).nullable().nullish(),
                })
                .nullable()
                .nullish(),
              redirect: z
                .object({
                  location: z.string(),
                  permanent: z.boolean(),
                })
                .nullable()
                .nullish(),
              actionDuration: z.string().nullable().nullish(),
              bypassSystem: z.boolean().nullable().nullish(),
            })
            .optional(),
        }),
      }),
    ),
    ips: z.array(
      z.object({
        id: z.string(),
        hostname: z.string(),
        ip: z.string(),
        notes: z.string().optional(),
        action: z.enum(['bypass', 'challenge', 'deny', 'log']),
      }),
    ),
    changes: z.array(z.object({})),
    managedRules: z
      .object({
        bot_protection: z
          .object({
            active: z.boolean(),
            action: z.enum(['challenge', 'deny', 'log']).optional(),
            updatedAt: z.string().optional(),
            userId: z.string().optional(),
            username: z.string().optional(),
          })
          .optional(),
        ai_bots: z
          .object({
            active: z.boolean(),
            action: z.enum(['challenge', 'deny', 'log']).optional(),
            updatedAt: z.string().optional(),
            userId: z.string().optional(),
            username: z.string().optional(),
          })
          .optional(),
        owasp: z
          .object({
            active: z.boolean(),
            action: z.enum(['challenge', 'deny', 'log']).optional(),
            updatedAt: z.string().optional(),
            userId: z.string().optional(),
            username: z.string().optional(),
          })
          .optional(),
      })
      .optional(),
    botIdEnabled: z.boolean().optional(),
  }),
}) as unknown as ToZod<PutFirewallConfig200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const putFirewallConfig400Schema = z.unknown() as unknown as ToZod<PutFirewallConfig400>

export const putFirewallConfig401Schema = z.unknown() as unknown as ToZod<PutFirewallConfig401>

export const putFirewallConfig402Schema = z.unknown() as unknown as ToZod<PutFirewallConfig402>

/**
 * @description You do not have permission to access this resource.
 */
export const putFirewallConfig403Schema = z.unknown() as unknown as ToZod<PutFirewallConfig403>

export const putFirewallConfig404Schema = z.unknown() as unknown as ToZod<PutFirewallConfig404>

export const putFirewallConfig500Schema = z.unknown() as unknown as ToZod<PutFirewallConfig500>

export const putFirewallConfigMutationRequestSchema = z.object({
  firewallEnabled: z.boolean(),
  managedRules: z
    .object({})
    .catchall(
      z.object({
        active: z.boolean(),
        action: z.enum(['log', 'challenge', 'deny']).optional(),
        ruleGroups: z
          .object({})
          .catchall(
            z.object({
              active: z.boolean().optional(),
              action: z.enum(['log', 'challenge', 'deny']).optional(),
            }),
          )
          .optional(),
      }),
    )
    .optional(),
  crs: z
    .object({
      sd: z
        .object({
          active: z.boolean(),
          action: z.enum(['deny', 'log']),
        })
        .optional(),
      ma: z
        .object({
          active: z.boolean(),
          action: z.enum(['deny', 'log']),
        })
        .optional(),
      lfi: z
        .object({
          active: z.boolean(),
          action: z.enum(['deny', 'log']),
        })
        .optional(),
      rfi: z
        .object({
          active: z.boolean(),
          action: z.enum(['deny', 'log']),
        })
        .optional(),
      rce: z
        .object({
          active: z.boolean(),
          action: z.enum(['deny', 'log']),
        })
        .optional(),
      php: z
        .object({
          active: z.boolean(),
          action: z.enum(['deny', 'log']),
        })
        .optional(),
      gen: z
        .object({
          active: z.boolean(),
          action: z.enum(['deny', 'log']),
        })
        .optional(),
      xss: z
        .object({
          active: z.boolean(),
          action: z.enum(['deny', 'log']),
        })
        .optional(),
      sqli: z
        .object({
          active: z.boolean(),
          action: z.enum(['deny', 'log']),
        })
        .optional(),
      sf: z
        .object({
          active: z.boolean(),
          action: z.enum(['deny', 'log']),
        })
        .optional(),
      java: z
        .object({
          active: z.boolean(),
          action: z.enum(['deny', 'log']),
        })
        .optional(),
    })
    .optional(),
  rules: z
    .array(
      z.object({
        id: z.string().optional(),
        name: z.string().max(160),
        description: z.string().max(256).optional(),
        active: z.boolean(),
        conditionGroup: z
          .array(
            z.object({
              conditions: z
                .array(
                  z.object({
                    type: z.enum([
                      'cookie',
                      'environment',
                      'geo_as_number',
                      'geo_city',
                      'geo_continent',
                      'geo_country',
                      'geo_country_region',
                      'header',
                      'host',
                      'ip_address',
                      'ja3_digest',
                      'ja4_digest',
                      'method',
                      'path',
                      'protocol',
                      'query',
                      'rate_limit_api_id',
                      'raw_path',
                      'region',
                      'scheme',
                      'target_path',
                      'user_agent',
                    ]),
                    op: z.enum(['eq', 'ex', 'gt', 'gte', 'inc', 'lt', 'lte', 'neq', 'nex', 'ninc', 'pre', 're', 'sub', 'suf']),
                    neg: z.boolean().optional(),
                    key: z.string().optional(),
                    value: z.union([z.array(z.string()).max(75), z.string(), z.number()]).optional(),
                  }),
                )
                .max(65),
            }),
          )
          .max(25),
        action: z.object({
          mitigate: z
            .object({
              action: z.enum(['bypass', 'challenge', 'deny', 'log', 'rate_limit', 'redirect']),
              rateLimit: z
                .union([
                  z.object({
                    algo: z.enum(['fixed_window', 'token_bucket']),
                    window: z.number(),
                    limit: z.number(),
                    keys: z.array(z.string()),
                    action: z.union([z.enum(['log', 'challenge', 'deny', 'rate_limit']), z.null()]).optional(),
                  }),
                  z.null(),
                ])
                .optional(),
              redirect: z
                .union([
                  z.object({
                    location: z.string(),
                    permanent: z.boolean(),
                  }),
                  z.null(),
                ])
                .optional(),
              actionDuration: z.string().nullable().nullish(),
              bypassSystem: z.boolean().nullable().nullish(),
            })
            .optional(),
        }),
      }),
    )
    .optional(),
  ips: z
    .array(
      z.object({
        id: z.string().optional(),
        hostname: z.string(),
        ip: z.string(),
        notes: z.string().optional(),
        action: z.enum(['bypass', 'challenge', 'deny', 'log']),
      }),
    )
    .optional(),
  botIdEnabled: z.boolean().optional(),
}) as unknown as ToZod<PutFirewallConfigMutationRequest>

export const putFirewallConfigMutationResponseSchema = z.lazy(() => putFirewallConfig200Schema) as unknown as ToZod<PutFirewallConfigMutationResponse>

export const updateFirewallConfigQueryParamsSchema = z.object({
  projectId: z.string(),
  teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
  slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
}) as unknown as ToZod<UpdateFirewallConfigQueryParams>

export const updateFirewallConfig200Schema = z.object({}) as unknown as ToZod<UpdateFirewallConfig200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const updateFirewallConfig400Schema = z.unknown() as unknown as ToZod<UpdateFirewallConfig400>

export const updateFirewallConfig401Schema = z.unknown() as unknown as ToZod<UpdateFirewallConfig401>

export const updateFirewallConfig402Schema = z.unknown() as unknown as ToZod<UpdateFirewallConfig402>

/**
 * @description You do not have permission to access this resource.
 */
export const updateFirewallConfig403Schema = z.unknown() as unknown as ToZod<UpdateFirewallConfig403>

export const updateFirewallConfig404Schema = z.unknown() as unknown as ToZod<UpdateFirewallConfig404>

export const updateFirewallConfig500Schema = z.unknown() as unknown as ToZod<UpdateFirewallConfig500>

export const updateFirewallConfigMutationRequestSchema = z.union([
  z.object({
    action: z.string(),
    id: z.null().optional(),
    value: z.boolean(),
  }),
  z.object({
    action: z.string(),
    id: z.null().optional(),
    value: z.object({
      name: z.string().max(160),
      description: z.string().max(256).optional(),
      active: z.boolean(),
      conditionGroup: z
        .array(
          z.object({
            conditions: z
              .array(
                z.object({
                  type: z.enum([
                    'host',
                    'path',
                    'method',
                    'header',
                    'query',
                    'cookie',
                    'target_path',
                    'raw_path',
                    'ip_address',
                    'region',
                    'protocol',
                    'scheme',
                    'environment',
                    'user_agent',
                    'geo_continent',
                    'geo_country',
                    'geo_country_region',
                    'geo_city',
                    'geo_as_number',
                    'ja4_digest',
                    'ja3_digest',
                    'rate_limit_api_id',
                  ]),
                  op: z.enum(['re', 'eq', 'neq', 'ex', 'nex', 'inc', 'ninc', 'pre', 'suf', 'sub', 'gt', 'gte', 'lt', 'lte']),
                  neg: z.boolean().optional(),
                  key: z.string().optional(),
                  value: z.union([z.array(z.string()).max(75), z.string(), z.number()]).optional(),
                }),
              )
              .max(65),
          }),
        )
        .max(25),
      action: z.object({
        mitigate: z
          .object({
            action: z.enum(['log', 'challenge', 'deny', 'bypass', 'rate_limit', 'redirect']),
            rateLimit: z
              .union([
                z.object({
                  algo: z.enum(['fixed_window', 'token_bucket']),
                  window: z.number(),
                  limit: z.number(),
                  keys: z.array(z.string()),
                  action: z.union([z.enum(['log', 'challenge', 'deny', 'rate_limit']), z.null()]).optional(),
                }),
                z.null(),
              ])
              .optional(),
            redirect: z
              .union([
                z.object({
                  location: z.string(),
                  permanent: z.boolean(),
                }),
                z.null(),
              ])
              .optional(),
            actionDuration: z.string().nullable().nullish(),
            bypassSystem: z.boolean().nullable().nullish(),
          })
          .optional(),
      }),
    }),
  }),
  z.object({
    action: z.string(),
    id: z.string(),
    value: z.object({
      name: z.string().max(160),
      description: z.string().max(256).optional(),
      active: z.boolean(),
      conditionGroup: z
        .array(
          z.object({
            conditions: z
              .array(
                z.object({
                  type: z.enum([
                    'host',
                    'path',
                    'method',
                    'header',
                    'query',
                    'cookie',
                    'target_path',
                    'raw_path',
                    'ip_address',
                    'region',
                    'protocol',
                    'scheme',
                    'environment',
                    'user_agent',
                    'geo_continent',
                    'geo_country',
                    'geo_country_region',
                    'geo_city',
                    'geo_as_number',
                    'ja4_digest',
                    'ja3_digest',
                    'rate_limit_api_id',
                  ]),
                  op: z.enum(['re', 'eq', 'neq', 'ex', 'nex', 'inc', 'ninc', 'pre', 'suf', 'sub', 'gt', 'gte', 'lt', 'lte']),
                  neg: z.boolean().optional(),
                  key: z.string().optional(),
                  value: z.union([z.array(z.string()).max(75), z.string(), z.number()]).optional(),
                }),
              )
              .max(65),
          }),
        )
        .max(25),
      action: z.object({
        mitigate: z
          .object({
            action: z.enum(['log', 'challenge', 'deny', 'bypass', 'rate_limit', 'redirect']),
            rateLimit: z
              .union([
                z.object({
                  algo: z.enum(['fixed_window', 'token_bucket']),
                  window: z.number(),
                  limit: z.number(),
                  keys: z.array(z.string()),
                  action: z.union([z.enum(['log', 'challenge', 'deny', 'rate_limit']), z.null()]).optional(),
                }),
                z.null(),
              ])
              .optional(),
            redirect: z
              .union([
                z.object({
                  location: z.string(),
                  permanent: z.boolean(),
                }),
                z.null(),
              ])
              .optional(),
            actionDuration: z.string().nullable().nullish(),
            bypassSystem: z.boolean().nullable().nullish(),
          })
          .optional(),
      }),
    }),
  }),
  z.object({
    action: z.string(),
    id: z.string(),
    value: z.null().optional(),
  }),
  z.object({
    action: z.string(),
    id: z.string(),
    value: z.number(),
  }),
  z.object({
    action: z.string(),
    id: z.enum(['sd', 'ma', 'lfi', 'rfi', 'rce', 'php', 'gen', 'xss', 'sqli', 'sf', 'java']),
    value: z.object({
      active: z.boolean(),
      action: z.enum(['deny', 'log']),
    }),
  }),
  z.object({
    action: z.string(),
    id: z.null().optional(),
    value: z.null().optional(),
  }),
  z.object({
    action: z.string(),
    id: z.null().optional(),
    value: z.object({
      hostname: z.string(),
      ip: z.string(),
      notes: z.string().optional(),
      action: z.enum(['deny', 'challenge', 'log', 'bypass']),
    }),
  }),
  z.object({
    action: z.string(),
    id: z.string(),
    value: z.object({
      hostname: z.string(),
      ip: z.string(),
      notes: z.string().optional(),
      action: z.enum(['deny', 'challenge', 'log', 'bypass']),
    }),
  }),
  z.object({
    action: z.string(),
    id: z.string(),
    value: z.null().optional(),
  }),
  z.object({
    action: z.string(),
    id: z.string(),
    value: z.object({
      action: z.enum(['log', 'challenge', 'deny']).optional(),
      active: z.boolean(),
    }),
  }),
  z.object({
    action: z.string(),
    id: z.string(),
    value: z.object({}).catchall(
      z.object({
        active: z.boolean(),
        action: z.enum(['log', 'challenge', 'deny']).optional(),
      }),
    ),
  }),
  z.object({
    action: z.string(),
    id: z.null().optional(),
    value: z.boolean(),
  }),
]) as unknown as ToZod<UpdateFirewallConfigMutationRequest>

export const updateFirewallConfigMutationResponseSchema = z.lazy(() => updateFirewallConfig200Schema) as unknown as ToZod<UpdateFirewallConfigMutationResponse>

export const getFirewallConfigQueryParamsSchema = z.object({
  projectId: z.string(),
  teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
  slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
}) as unknown as ToZod<GetFirewallConfigQueryParams>

/**
 * @description If the firewall configuration includes a [custom managed ruleset](https://vercel.com/docs/security/vercel-waf/managed-rulesets), it will include a `crs` item that has the following values: sd: Scanner Detection ma: Multipart Attack lfi: Local File Inclusion Attack rfi: Remote File Inclusion Attack rce: Remote Execution Attack php: PHP Attack gen: Generic Attack xss: XSS Attack sqli: SQL Injection Attack sf: Session Fixation Attack java: Java Attack
 */
export const getFirewallConfig200Schema = z.object({
  ownerId: z.string(),
  projectKey: z.string(),
  id: z.string(),
  version: z.number(),
  updatedAt: z.string(),
  firewallEnabled: z.boolean(),
  crs: z.object({
    sd: z.object({
      active: z.boolean(),
      action: z.enum(['deny', 'log']),
    }),
    ma: z.object({
      active: z.boolean(),
      action: z.enum(['deny', 'log']),
    }),
    lfi: z.object({
      active: z.boolean(),
      action: z.enum(['deny', 'log']),
    }),
    rfi: z.object({
      active: z.boolean(),
      action: z.enum(['deny', 'log']),
    }),
    rce: z.object({
      active: z.boolean(),
      action: z.enum(['deny', 'log']),
    }),
    php: z.object({
      active: z.boolean(),
      action: z.enum(['deny', 'log']),
    }),
    gen: z.object({
      active: z.boolean(),
      action: z.enum(['deny', 'log']),
    }),
    xss: z.object({
      active: z.boolean(),
      action: z.enum(['deny', 'log']),
    }),
    sqli: z.object({
      active: z.boolean(),
      action: z.enum(['deny', 'log']),
    }),
    sf: z.object({
      active: z.boolean(),
      action: z.enum(['deny', 'log']),
    }),
    java: z.object({
      active: z.boolean(),
      action: z.enum(['deny', 'log']),
    }),
  }),
  rules: z.array(
    z.object({
      id: z.string(),
      name: z.string(),
      description: z.string().optional(),
      active: z.boolean(),
      conditionGroup: z.array(
        z.object({
          conditions: z.array(
            z.object({
              type: z.enum([
                'cookie',
                'environment',
                'geo_as_number',
                'geo_city',
                'geo_continent',
                'geo_country',
                'geo_country_region',
                'header',
                'host',
                'ip_address',
                'ja3_digest',
                'ja4_digest',
                'method',
                'path',
                'protocol',
                'query',
                'rate_limit_api_id',
                'raw_path',
                'region',
                'scheme',
                'target_path',
                'user_agent',
              ]),
              op: z.enum(['eq', 'ex', 'gt', 'gte', 'inc', 'lt', 'lte', 'neq', 'nex', 'ninc', 'pre', 're', 'sub', 'suf']),
              neg: z.boolean().optional(),
              key: z.string().optional(),
              value: z.union([z.array(z.string()), z.string(), z.number()]).optional(),
            }),
          ),
        }),
      ),
      action: z.object({
        mitigate: z
          .object({
            action: z.enum(['bypass', 'challenge', 'deny', 'log', 'rate_limit', 'redirect']),
            rateLimit: z
              .object({
                algo: z.enum(['fixed_window', 'token_bucket']),
                window: z.number(),
                limit: z.number(),
                keys: z.array(z.string()),
                action: z.enum(['challenge', 'deny', 'log', 'rate_limit']).nullable().nullish(),
              })
              .nullable()
              .nullish(),
            redirect: z
              .object({
                location: z.string(),
                permanent: z.boolean(),
              })
              .nullable()
              .nullish(),
            actionDuration: z.string().nullable().nullish(),
            bypassSystem: z.boolean().nullable().nullish(),
          })
          .optional(),
      }),
    }),
  ),
  ips: z.array(
    z.object({
      id: z.string(),
      hostname: z.string(),
      ip: z.string(),
      notes: z.string().optional(),
      action: z.enum(['bypass', 'challenge', 'deny', 'log']),
    }),
  ),
  changes: z.array(z.object({})),
  managedRules: z
    .object({
      bot_protection: z
        .object({
          active: z.boolean(),
          action: z.enum(['challenge', 'deny', 'log']).optional(),
          updatedAt: z.string().optional(),
          userId: z.string().optional(),
          username: z.string().optional(),
        })
        .optional(),
      ai_bots: z
        .object({
          active: z.boolean(),
          action: z.enum(['challenge', 'deny', 'log']).optional(),
          updatedAt: z.string().optional(),
          userId: z.string().optional(),
          username: z.string().optional(),
        })
        .optional(),
      owasp: z
        .object({
          active: z.boolean(),
          action: z.enum(['challenge', 'deny', 'log']).optional(),
          updatedAt: z.string().optional(),
          userId: z.string().optional(),
          username: z.string().optional(),
        })
        .optional(),
    })
    .optional(),
  botIdEnabled: z.boolean().optional(),
}) as unknown as ToZod<GetFirewallConfig200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getFirewallConfig400Schema = z.unknown() as unknown as ToZod<GetFirewallConfig400>

export const getFirewallConfig401Schema = z.unknown() as unknown as ToZod<GetFirewallConfig401>

/**
 * @description You do not have permission to access this resource.
 */
export const getFirewallConfig403Schema = z.unknown() as unknown as ToZod<GetFirewallConfig403>

export const getFirewallConfig404Schema = z.unknown() as unknown as ToZod<GetFirewallConfig404>

export const getFirewallConfigQueryResponseSchema = z.lazy(() => getFirewallConfig200Schema) as unknown as ToZod<GetFirewallConfigQueryResponse>

export const getActiveAttackStatusQueryParamsSchema = z.object({
  projectId: z.string(),
  teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
  slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
}) as unknown as ToZod<GetActiveAttackStatusQueryParams>

export const getActiveAttackStatus200Schema = z.union([
  z.object({}),
  z.object({
    anomalies: z.array(
      z.object({
        ownerId: z.string(),
        projectId: z.string(),
        startTime: z.number(),
        endTime: z.number().nullable(),
        atMinute: z.number(),
        state: z.string().optional(),
        affectedHostMap: z.object({}).catchall(
          z.object({
            anomalyAlerts: z
              .object({})
              .catchall(
                z.object({
                  at_minute: z.string(),
                  zscore: z.number(),
                  total_requests_minute: z.number(),
                  avg_requests: z.number(),
                  stddev_requests: z.number(),
                }),
              )
              .optional(),
            ddosAlerts: z
              .object({})
              .catchall(
                z.object({
                  atMinute: z.string(),
                  totalReqs: z.number(),
                }),
              )
              .optional(),
          }),
        ),
      }),
    ),
  }),
]) as unknown as ToZod<GetActiveAttackStatus200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getActiveAttackStatus400Schema = z.unknown() as unknown as ToZod<GetActiveAttackStatus400>

export const getActiveAttackStatus401Schema = z.unknown() as unknown as ToZod<GetActiveAttackStatus401>

/**
 * @description You do not have permission to access this resource.
 */
export const getActiveAttackStatus403Schema = z.unknown() as unknown as ToZod<GetActiveAttackStatus403>

export const getActiveAttackStatus404Schema = z.unknown() as unknown as ToZod<GetActiveAttackStatus404>

export const getActiveAttackStatusQueryResponseSchema = z.lazy(() => getActiveAttackStatus200Schema) as unknown as ToZod<GetActiveAttackStatusQueryResponse>

export const getBypassIpQueryParamsSchema = z.object({
  projectId: z.string(),
  limit: z.coerce.number().max(128).optional(),
  sourceIp: z.string().max(49).describe('Filter by source IP').optional(),
  domain: z
    .string()
    .regex(/([a-z]+[a-z.]+)$/)
    .max(2544)
    .describe('Filter by domain')
    .optional(),
  projectScope: z.boolean().describe('Filter by project scoped rules').optional(),
  offset: z.string().max(2560).describe('Used for pagination. Retrieves results after the provided id').optional(),
  teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
  slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
}) as unknown as ToZod<GetBypassIpQueryParams>

export const getBypassIp200Schema = z.union([
  z.object({
    result: z.array(
      z.object({
        OwnerId: z.string().optional(),
        Id: z.string().optional(),
        Domain: z.string().optional(),
        Ip: z.string().optional(),
        Action: z.enum(['block', 'bypass']).optional(),
        ProjectId: z.string().optional(),
        IsProjectRule: z.boolean().optional(),
        Note: z.string().optional(),
        CreatedAt: z.string().optional(),
        ActorId: z.string().optional(),
        UpdatedAt: z.string().optional(),
        UpdatedAtHour: z.string().optional(),
        DeletedAt: z.string().optional(),
        ExpiresAt: z.number().nullable().nullish(),
      }),
    ),
    pagination: z.unknown(),
  }),
  z.object({
    result: z
      .array(
        z.object({
          OwnerId: z.string().optional(),
          Id: z.string().optional(),
          Domain: z.string().optional(),
          Ip: z.string().optional(),
          Action: z.enum(['block', 'bypass']).optional(),
          ProjectId: z.string().optional(),
          IsProjectRule: z.boolean().optional(),
          Note: z.string().optional(),
          CreatedAt: z.string().optional(),
          ActorId: z.string().optional(),
          UpdatedAt: z.string().optional(),
          UpdatedAtHour: z.string().optional(),
          DeletedAt: z.string().optional(),
          ExpiresAt: z.number().nullable().nullish(),
        }),
      )
      .optional(),
    pagination: z
      .object({
        OwnerId: z.string(),
        Id: z.string(),
      })
      .optional(),
  }),
]) as unknown as ToZod<GetBypassIp200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getBypassIp400Schema = z.unknown() as unknown as ToZod<GetBypassIp400>

export const getBypassIp401Schema = z.unknown() as unknown as ToZod<GetBypassIp401>

/**
 * @description You do not have permission to access this resource.
 */
export const getBypassIp403Schema = z.unknown() as unknown as ToZod<GetBypassIp403>

export const getBypassIp404Schema = z.unknown() as unknown as ToZod<GetBypassIp404>

export const getBypassIp500Schema = z.unknown() as unknown as ToZod<GetBypassIp500>

export const getBypassIpQueryResponseSchema = z.lazy(() => getBypassIp200Schema) as unknown as ToZod<GetBypassIpQueryResponse>

export const addBypassIpQueryParamsSchema = z.object({
  projectId: z.string(),
  teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
  slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
}) as unknown as ToZod<AddBypassIpQueryParams>

export const addBypassIp200Schema = z.union([
  z.object({
    ok: z.boolean(),
    result: z.array(
      z.object({
        OwnerId: z.string(),
        Id: z.string(),
        Domain: z.string(),
        Ip: z.string().optional(),
        ProjectId: z.string(),
        Note: z.string(),
        IsProjectRule: z.boolean(),
      }),
    ),
    pagination: z.unknown(),
  }),
  z.object({
    ok: z.boolean(),
    result: z
      .array(
        z.object({
          OwnerId: z.string(),
          Id: z.string(),
          Domain: z.string(),
          Ip: z.string(),
          Action: z.enum(['block', 'bypass']).optional(),
          ProjectId: z.string().optional(),
          IsProjectRule: z.boolean().optional(),
          Note: z.string().optional(),
          CreatedAt: z.string(),
          ActorId: z.string().optional(),
          UpdatedAt: z.string(),
          UpdatedAtHour: z.string(),
          DeletedAt: z.string().optional(),
          ExpiresAt: z.number().nullable().nullish(),
        }),
      )
      .optional(),
  }),
]) as unknown as ToZod<AddBypassIp200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const addBypassIp400Schema = z.unknown() as unknown as ToZod<AddBypassIp400>

export const addBypassIp401Schema = z.unknown() as unknown as ToZod<AddBypassIp401>

/**
 * @description You do not have permission to access this resource.
 */
export const addBypassIp403Schema = z.unknown() as unknown as ToZod<AddBypassIp403>

export const addBypassIp404Schema = z.unknown() as unknown as ToZod<AddBypassIp404>

export const addBypassIp500Schema = z.unknown() as unknown as ToZod<AddBypassIp500>

export const addBypassIpMutationRequestSchema = z.unknown() as unknown as ToZod<AddBypassIpMutationRequest>

export const addBypassIpMutationResponseSchema = z.lazy(() => addBypassIp200Schema) as unknown as ToZod<AddBypassIpMutationResponse>

export const removeBypassIpQueryParamsSchema = z.object({
  projectId: z.string(),
  teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
  slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
}) as unknown as ToZod<RemoveBypassIpQueryParams>

export const removeBypassIp200Schema = z.object({
  ok: z.boolean(),
}) as unknown as ToZod<RemoveBypassIp200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const removeBypassIp400Schema = z.unknown() as unknown as ToZod<RemoveBypassIp400>

export const removeBypassIp401Schema = z.unknown() as unknown as ToZod<RemoveBypassIp401>

/**
 * @description You do not have permission to access this resource.
 */
export const removeBypassIp403Schema = z.unknown() as unknown as ToZod<RemoveBypassIp403>

export const removeBypassIp404Schema = z.unknown() as unknown as ToZod<RemoveBypassIp404>

export const removeBypassIp500Schema = z.unknown() as unknown as ToZod<RemoveBypassIp500>

export const removeBypassIpMutationRequestSchema = z.unknown() as unknown as ToZod<RemoveBypassIpMutationRequest>

export const removeBypassIpMutationResponseSchema = z.lazy(() => removeBypassIp200Schema) as unknown as ToZod<RemoveBypassIpMutationResponse>

export const getTeamMembersQueryParamsSchema = z
  .object({
    limit: z.coerce.number().min(1).describe('Limit how many teams should be returned').optional(),
    since: z.coerce.number().describe('Timestamp in milliseconds to only include members added since then.').optional(),
    until: z.coerce.number().describe('Timestamp in milliseconds to only include members added until then.').optional(),
    search: z.string().describe('Search team members by their name, username, and email.').optional(),
    role: z.enum(['OWNER', 'MEMBER', 'DEVELOPER', 'VIEWER', 'BILLING', 'CONTRIBUTOR']).describe('Only return members with the specified team role.').optional(),
    excludeProject: z.string().describe('Exclude members who belong to the specified project.').optional(),
    eligibleMembersForProjectId: z.string().describe('Include team members who are eligible to be members of the specified project.').optional(),
  })
  .optional() as unknown as ToZod<GetTeamMembersQueryParams>

export const getTeamMembers200Schema = z.object({
  members: z.array(
    z.object({
      avatar: z.string().describe('ID of the file for the Avatar of this member.').optional(),
      confirmed: z.boolean().describe('Boolean that indicates if this member was confirmed by an owner.'),
      email: z.string().describe('The email of this member.'),
      github: z
        .object({
          login: z.string().optional(),
        })
        .describe('Information about the GitHub account for this user.')
        .optional(),
      gitlab: z
        .object({
          login: z.string().optional(),
        })
        .describe('Information about the GitLab account of this user.')
        .optional(),
      bitbucket: z
        .object({
          login: z.string().optional(),
        })
        .describe('Information about the Bitbucket account of this user.')
        .optional(),
      role: z.enum(['BILLING', 'CONTRIBUTOR', 'DEVELOPER', 'MEMBER', 'OWNER', 'SECURITY', 'VIEWER']).describe('Role of this user in the team.'),
      uid: z.string().describe('The ID of this user.'),
      username: z.string().describe('The unique username of this user.'),
      name: z.string().describe('The name of this user.').optional(),
      createdAt: z.number().describe('Timestamp in milliseconds when this member was added.'),
      accessRequestedAt: z.number().describe('Timestamp in milliseconds for when this team member was accepted by an owner.').optional(),
      joinedFrom: z
        .object({
          origin: z.enum(['bitbucket', 'dsync', 'feedback', 'github', 'gitlab', 'import', 'link', 'mail', 'organization-teams', 'saml', 'teams']),
          commitId: z.string().optional(),
          repoId: z.string().optional(),
          repoPath: z.string().optional(),
          gitUserId: z.union([z.string(), z.number()]).optional(),
          gitUserLogin: z.string().optional(),
          ssoUserId: z.string().optional(),
          ssoConnectedAt: z.number().optional(),
          idpUserId: z.string().optional(),
          dsyncUserId: z.string().optional(),
          dsyncConnectedAt: z.number().optional(),
        })
        .describe('Map with information about the members origin if they joined by requesting access.')
        .optional(),
      projects: z
        .array(
          z
            .object({
              name: z.string().optional(),
              id: z.string().optional(),
              role: z.enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER']).optional(),
            })
            .describe('Array of project memberships'),
        )
        .describe('Array of project memberships')
        .optional(),
    }),
  ),
  emailInviteCodes: z
    .array(
      z.object({
        accessGroups: z.array(z.string()).optional(),
        id: z.string(),
        email: z.string().optional(),
        role: z.enum(['BILLING', 'CONTRIBUTOR', 'DEVELOPER', 'MEMBER', 'OWNER', 'SECURITY', 'VIEWER']).optional(),
        isDSyncUser: z.boolean(),
        createdAt: z.number().optional(),
        expired: z.boolean().optional(),
        projects: z
          .object({})
          .catchall(z.enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER']))
          .optional(),
        entitlements: z.array(z.string()).optional(),
      }),
    )
    .optional(),
  pagination: z.object({
    hasNext: z.boolean(),
    count: z.number().describe('Amount of items in the current page.'),
    next: z.number().describe('Timestamp that must be used to request the next page.').nullable(),
    prev: z.number().describe('Timestamp that must be used to request the previous page.').nullable(),
  }),
}) as unknown as ToZod<GetTeamMembers200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getTeamMembers400Schema = z.unknown() as unknown as ToZod<GetTeamMembers400>

export const getTeamMembers401Schema = z.unknown() as unknown as ToZod<GetTeamMembers401>

/**
 * @description You do not have permission to access this resource.
 */
export const getTeamMembers403Schema = z.unknown() as unknown as ToZod<GetTeamMembers403>

export const getTeamMembers404Schema = z.unknown() as unknown as ToZod<GetTeamMembers404>

export const getTeamMembersQueryResponseSchema = z.lazy(() => getTeamMembers200Schema) as unknown as ToZod<GetTeamMembersQueryResponse>

/**
 * @description The member was successfully added to the team
 */
export const inviteUserToTeam200Schema = z.union([
  z.object({
    uid: z.string().describe('The ID of the invited user'),
    username: z.string().describe('The username of the invited user'),
    email: z.string().describe('The email of the invited user. Not included if the user was invited via their UID.').optional(),
    role: z.enum(['OWNER', 'MEMBER', 'DEVELOPER', 'SECURITY', 'BILLING', 'VIEWER', 'CONTRIBUTOR']).describe('The role used for the invitation'),
    teamRoles: z
      .array(z.enum(['OWNER', 'MEMBER', 'DEVELOPER', 'SECURITY', 'BILLING', 'VIEWER', 'CONTRIBUTOR']).describe('The team roles of the user'))
      .describe('The team roles of the user')
      .optional(),
    teamPermissions: z
      .array(
        z
          .enum(['CreateProject', 'FullProductionDeployment', 'UsageViewer', 'EnvVariableManager', 'EnvironmentManager'])
          .describe('The team permissions of the user'),
      )
      .describe('The team permissions of the user')
      .optional(),
  }),
  z.object({
    uid: z.string(),
    username: z.string(),
    role: z.enum(['OWNER', 'MEMBER', 'DEVELOPER', 'SECURITY', 'BILLING', 'VIEWER', 'CONTRIBUTOR']),
    teamRoles: z.array(z.enum(['OWNER', 'MEMBER', 'DEVELOPER', 'SECURITY', 'BILLING', 'VIEWER', 'CONTRIBUTOR'])).optional(),
    teamPermissions: z.array(z.enum(['CreateProject', 'FullProductionDeployment', 'UsageViewer', 'EnvVariableManager', 'EnvironmentManager'])).optional(),
  }),
]) as unknown as ToZod<InviteUserToTeam200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.\nThe user already requested access to the team\nThe team reached the maximum allowed amount of members
 */
export const inviteUserToTeam400Schema = z.unknown() as unknown as ToZod<InviteUserToTeam400>

export const inviteUserToTeam401Schema = z.unknown() as unknown as ToZod<InviteUserToTeam401>

/**
 * @description The authenticated user must be a team owner to perform the action\nYou do not have permission to access this resource.
 */
export const inviteUserToTeam403Schema = z.unknown() as unknown as ToZod<InviteUserToTeam403>

export const inviteUserToTeam503Schema = z.unknown() as unknown as ToZod<InviteUserToTeam503>

export const inviteUserToTeamMutationRequestSchema = z.object({
  uid: z.string().describe('The id of the user to invite').optional(),
  email: z.string().email().describe('The email address of the user to invite').optional(),
  role: z.enum(['BILLING', 'CONTRIBUTOR', 'DEVELOPER', 'MEMBER', 'OWNER', 'SECURITY', 'VIEWER']).describe('The role of the user to invite').optional(),
  projects: z
    .array(
      z.object({
        projectId: z.string().max(64).describe('The ID of the project.'),
        role: z.enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER']).describe('Sets the project roles for the invited user'),
      }),
    )
    .optional(),
}) as unknown as ToZod<InviteUserToTeamMutationRequest>

export const inviteUserToTeamMutationResponseSchema = z.lazy(() => inviteUserToTeam200Schema) as unknown as ToZod<InviteUserToTeamMutationResponse>

/**
 * @description Successfuly requested access to the team.
 */
export const requestAccessToTeam200Schema = z.object({
  teamSlug: z.string(),
  teamName: z.string(),
  confirmed: z.boolean().optional(),
  joinedFrom: z
    .object({
      origin: z.enum(['bitbucket', 'dsync', 'feedback', 'github', 'gitlab', 'import', 'link', 'mail', 'organization-teams', 'saml', 'teams']),
      commitId: z.string().optional(),
      repoId: z.string().optional(),
      repoPath: z.string().optional(),
      gitUserId: z.union([z.string(), z.number()]).optional(),
      gitUserLogin: z.string().optional(),
      ssoUserId: z.string().optional(),
      ssoConnectedAt: z.number().optional(),
      idpUserId: z.string().optional(),
      dsyncUserId: z.string().optional(),
      dsyncConnectedAt: z.number().optional(),
    })
    .optional(),
  accessRequestedAt: z.number().optional(),
  github: z
    .object({
      login: z.string().optional(),
    })
    .nullable(),
  gitlab: z
    .object({
      login: z.string().optional(),
    })
    .nullable(),
  bitbucket: z
    .object({
      login: z.string().optional(),
    })
    .nullable(),
}) as unknown as ToZod<RequestAccessToTeam200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const requestAccessToTeam400Schema = z.unknown() as unknown as ToZod<RequestAccessToTeam400>

export const requestAccessToTeam401Schema = z.unknown() as unknown as ToZod<RequestAccessToTeam401>

/**
 * @description You do not have permission to access this resource.
 */
export const requestAccessToTeam403Schema = z.unknown() as unknown as ToZod<RequestAccessToTeam403>

/**
 * @description The team was not found.
 */
export const requestAccessToTeam404Schema = z.unknown() as unknown as ToZod<RequestAccessToTeam404>

export const requestAccessToTeam503Schema = z.unknown() as unknown as ToZod<RequestAccessToTeam503>

export const requestAccessToTeamMutationRequestSchema = z.object({
  joinedFrom: z.object({
    origin: z.enum(['bitbucket', 'feedback', 'github', 'gitlab', 'import', 'organization-teams', 'teams']).describe('The origin of the request.'),
    commitId: z.string().describe('The commit sha if the origin is a git provider.').optional(),
    repoId: z.string().describe('The ID of the repository for the given Git provider.').optional(),
    repoPath: z.string().describe('The path to the repository for the given Git provider.').optional(),
    gitUserId: z.union([z.string(), z.number()]).describe('The ID of the Git account of the user who requests access.').optional(),
    gitUserLogin: z.string().describe('The login name for the Git account of the user who requests access.').optional(),
  }),
}) as unknown as ToZod<RequestAccessToTeamMutationRequest>

export const requestAccessToTeamMutationResponseSchema = z.lazy(() => requestAccessToTeam200Schema) as unknown as ToZod<RequestAccessToTeamMutationResponse>

export const getTeamAccessRequestPathParamsSchema = z
  .object({
    userId: z.string().optional(),
  })
  .optional() as unknown as ToZod<GetTeamAccessRequestPathParams>

/**
 * @description Successfully
 */
export const getTeamAccessRequest200Schema = z.object({
  teamSlug: z.string().describe('The slug of the team.'),
  teamName: z.string().describe('The name of the team.'),
  confirmed: z.boolean().describe("Current status of the membership. Will be `true` if confirmed, if pending it'll be `false`."),
  joinedFrom: z
    .object({
      origin: z.enum(['bitbucket', 'dsync', 'feedback', 'github', 'gitlab', 'import', 'link', 'mail', 'organization-teams', 'saml', 'teams']),
      commitId: z.string().optional(),
      repoId: z.string().optional(),
      repoPath: z.string().optional(),
      gitUserId: z.union([z.string(), z.number()]).optional(),
      gitUserLogin: z.string().optional(),
      ssoUserId: z.string().optional(),
      ssoConnectedAt: z.number().optional(),
      idpUserId: z.string().optional(),
      dsyncUserId: z.string().optional(),
      dsyncConnectedAt: z.number().optional(),
    })
    .describe('A map that describes the origin from where the user joined.'),
  accessRequestedAt: z.number().describe('Timestamp in milliseconds when the user requested access to the team.'),
  github: z
    .object({
      login: z.string().optional(),
    })
    .describe('Map of the connected GitHub account.')
    .nullable(),
  gitlab: z
    .object({
      login: z.string().optional(),
    })
    .describe('Map of the connected GitLab account.')
    .nullable(),
  bitbucket: z
    .object({
      login: z.string().optional(),
    })
    .describe('Map of the connected Bitbucket account.')
    .nullable(),
}) as unknown as ToZod<GetTeamAccessRequest200>

/**
 * @description One of the provided values in the request query is invalid.\nUser is already a confirmed member of the team and did not request access. Only visible when the authenticated user does have access to the team.
 */
export const getTeamAccessRequest400Schema = z.unknown() as unknown as ToZod<GetTeamAccessRequest400>

export const getTeamAccessRequest401Schema = z.unknown() as unknown as ToZod<GetTeamAccessRequest401>

/**
 * @description You do not have permission to access this resource.
 */
export const getTeamAccessRequest403Schema = z.unknown() as unknown as ToZod<GetTeamAccessRequest403>

/**
 * @description The provided user doesn\'t have a membership.\nTeam was not found.
 */
export const getTeamAccessRequest404Schema = z.unknown() as unknown as ToZod<GetTeamAccessRequest404>

export const getTeamAccessRequestQueryResponseSchema = z.lazy(() => getTeamAccessRequest200Schema) as unknown as ToZod<GetTeamAccessRequestQueryResponse>

/**
 * @description Successfully joined a team.
 */
export const joinTeam200Schema = z
  .object({
    teamId: z.string().describe('The ID of the team the user joined.'),
    slug: z.string().describe('The slug of the team the user joined.'),
    name: z.string().describe('The name of the team the user joined.'),
    from: z.string().describe('The origin of how the user joined.'),
  })
  .describe('Successfully joined a team.') as unknown as ToZod<JoinTeam200>

/**
 * @description One of the provided values in the request body is invalid.
 */
export const joinTeam400Schema = z.unknown() as unknown as ToZod<JoinTeam400>

export const joinTeam401Schema = z.unknown() as unknown as ToZod<JoinTeam401>

export const joinTeam402Schema = z.unknown() as unknown as ToZod<JoinTeam402>

/**
 * @description You do not have permission to access this resource.
 */
export const joinTeam403Schema = z.unknown() as unknown as ToZod<JoinTeam403>

export const joinTeam404Schema = z.unknown() as unknown as ToZod<JoinTeam404>

export const joinTeamMutationRequestSchema = z.object({
  inviteCode: z.string().describe('The invite code to join the team.').optional(),
}) as unknown as ToZod<JoinTeamMutationRequest>

export const joinTeamMutationResponseSchema = z.lazy(() => joinTeam200Schema) as unknown as ToZod<JoinTeamMutationResponse>

export const updateTeamMemberPathParamsSchema = z.object({
  uid: z.string().describe('The ID of the member.'),
}) as unknown as ToZod<UpdateTeamMemberPathParams>

/**
 * @description Successfully updated the membership.
 */
export const updateTeamMember200Schema = z.object({
  id: z.string().describe('ID of the team.'),
}) as unknown as ToZod<UpdateTeamMember200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.\nCannot disconnect SSO from a Team member that does not have a SSO connection.\nCannot confirm a member that is already confirmed.\nCannot confirm a member that did not request access.
 */
export const updateTeamMember400Schema = z.unknown() as unknown as ToZod<UpdateTeamMember400>

/**
 * @description Team members can only be updated by an owner, or by the authenticated user if they are only disconnecting their SAML connection to the Team.
 */
export const updateTeamMember401Schema = z.unknown() as unknown as ToZod<UpdateTeamMember401>

export const updateTeamMember402Schema = z.unknown() as unknown as ToZod<UpdateTeamMember402>

/**
 * @description You do not have permission to access this resource.
 */
export const updateTeamMember403Schema = z.unknown() as unknown as ToZod<UpdateTeamMember403>

/**
 * @description The provided user is not part of this team.\nA user with the specified ID does not exist.
 */
export const updateTeamMember404Schema = z.unknown() as unknown as ToZod<UpdateTeamMember404>

export const updateTeamMember500Schema = z.unknown() as unknown as ToZod<UpdateTeamMember500>

export const updateTeamMemberMutationRequestSchema = z.object({
  confirmed: z.literal(true).describe('Accept a user who requested access to the team.').optional(),
  role: z.string().describe('The role in the team of the member.').optional(),
  projects: z
    .array(
      z.object({
        projectId: z.string().max(256).describe('The ID of the project.'),
        role: z
          .enum(['ADMIN', 'PROJECT_DEVELOPER', 'PROJECT_VIEWER'])
          .describe('The project role of the member that will be added. \\"null\\" will remove this project level role.')
          .nullable(),
      }),
    )
    .optional(),
  joinedFrom: z
    .object({
      ssoUserId: z.null().optional(),
    })
    .optional(),
}) as unknown as ToZod<UpdateTeamMemberMutationRequest>

export const updateTeamMemberMutationResponseSchema = z.lazy(() => updateTeamMember200Schema) as unknown as ToZod<UpdateTeamMemberMutationResponse>

export const removeTeamMemberPathParamsSchema = z.object({
  uid: z.string().describe('The user ID of the member.'),
}) as unknown as ToZod<RemoveTeamMemberPathParams>

export const removeTeamMemberQueryParamsSchema = z
  .object({
    newDefaultTeamId: z.string().describe('The ID of the team to set as the new default team for the Northstar user.').optional(),
  })
  .optional() as unknown as ToZod<RemoveTeamMemberQueryParams>

/**
 * @description Successfully removed a member of the team.
 */
export const removeTeamMember200Schema = z.object({
  id: z.string().describe('ID of the team.'),
}) as unknown as ToZod<RemoveTeamMember200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const removeTeamMember400Schema = z.unknown() as unknown as ToZod<RemoveTeamMember400>

export const removeTeamMember401Schema = z.unknown() as unknown as ToZod<RemoveTeamMember401>

/**
 * @description You do not have permission to access this resource.\nNot authorized to update the team.
 */
export const removeTeamMember403Schema = z.unknown() as unknown as ToZod<RemoveTeamMember403>

export const removeTeamMember404Schema = z.unknown() as unknown as ToZod<RemoveTeamMember404>

export const removeTeamMember503Schema = z.unknown() as unknown as ToZod<RemoveTeamMember503>

export const removeTeamMemberMutationResponseSchema = z.lazy(() => removeTeamMember200Schema) as unknown as ToZod<RemoveTeamMemberMutationResponse>

export const getTeamPathParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetTeamPathParams>

export const getTeamQueryParamsSchema = z
  .object({
    slug: z.string().optional(),
  })
  .optional() as unknown as ToZod<GetTeamQueryParams>

/**
 * @description The requested team
 */
export const getTeam200Schema = z.lazy(() => teamSchema).describe('Data representing a Team.') as unknown as ToZod<GetTeam200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getTeam400Schema = z.unknown() as unknown as ToZod<GetTeam400>

export const getTeam401Schema = z.unknown() as unknown as ToZod<GetTeam401>

/**
 * @description You do not have permission to access this resource.\nNot authorized to access the team.
 */
export const getTeam403Schema = z.unknown() as unknown as ToZod<GetTeam403>

/**
 * @description Team was not found.
 */
export const getTeam404Schema = z.unknown() as unknown as ToZod<GetTeam404>

export const getTeamQueryResponseSchema = z.lazy(() => getTeam200Schema) as unknown as ToZod<GetTeamQueryResponse>

export const patchTeamPathParamsSchema = z.object({
  teamId: z.string().describe('The Team identifier to perform the request on behalf of.'),
}) as unknown as ToZod<PatchTeamPathParams>

export const patchTeamQueryParamsSchema = z
  .object({
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<PatchTeamQueryParams>

export const patchTeam200Schema = z.lazy(() => teamSchema).describe('Data representing a Team.') as unknown as ToZod<PatchTeam200>

/**
 * @description One of the provided values in the request body is invalid.
 */
export const patchTeam400Schema = z.unknown() as unknown as ToZod<PatchTeam400>

export const patchTeam401Schema = z.unknown() as unknown as ToZod<PatchTeam401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const patchTeam402Schema = z.unknown() as unknown as ToZod<PatchTeam402>

/**
 * @description You do not have permission to access this resource.\nNot authorized to update the team. Must be an OWNER.
 */
export const patchTeam403Schema = z.unknown() as unknown as ToZod<PatchTeam403>

/**
 * @description Owner does not have protection add-on\nAdvanced Deployment Protection is not available for the user plan
 */
export const patchTeam428Schema = z.unknown() as unknown as ToZod<PatchTeam428>

export const patchTeamMutationRequestSchema = z.object({
  avatar: z.string().describe('The hash value of an uploaded image.').optional(),
  description: z.string().max(140).describe('A short text that describes the team.').optional(),
  emailDomain: z.string().nullable().nullish(),
  name: z.string().max(256).describe('The name of the team.').optional(),
  previewDeploymentSuffix: z.string().url().describe('Suffix that will be used for all preview deployments.').nullable().nullish(),
  regenerateInviteCode: z.boolean().describe('Create a new invite code and replace the current one.').optional(),
  saml: z
    .object({
      enforced: z.boolean().describe('Require that members of the team use SAML Single Sign-On.').optional(),
      roles: z
        .object({})
        .catchall(
          z.union([
            z.object({
              accessGroupId: z.string().regex(/^ag_[A-z0-9_ -]+$/),
            }),
            z.enum(['OWNER', 'MEMBER', 'DEVELOPER', 'SECURITY', 'BILLING', 'VIEWER', 'CONTRIBUTOR']),
          ]),
        )
        .describe('Directory groups to role or access group mappings.')
        .optional(),
    })
    .optional(),
  slug: z.string().describe('A new slug for the team.').optional(),
  enablePreviewFeedback: z.string().describe('Enable preview toolbar: one of on, off or default.').optional(),
  enableProductionFeedback: z.string().describe('Enable production toolbar: one of on, off or default.').optional(),
  sensitiveEnvironmentVariablePolicy: z.string().describe('Sensitive environment variable policy: one of on, off or default.').optional(),
  remoteCaching: z
    .object({
      enabled: z.boolean().describe('Enable or disable remote caching for the team.').optional(),
    })
    .describe('Whether or not remote caching is enabled for the team')
    .optional(),
  hideIpAddresses: z.boolean().describe('Display or hide IP addresses in Monitoring queries.').optional(),
  hideIpAddressesInLogDrains: z.boolean().describe('Display or hide IP addresses in Log Drains.').optional(),
  defaultDeploymentProtection: z
    .object({
      passwordProtection: z
        .object({
          deploymentType: z
            .enum(['all', 'all_except_custom_domains', 'preview', 'prod_deployment_urls_and_all_previews'])
            .describe('Specify if the password will apply to every Deployment Target or just Preview'),
          password: z.string().max(72).describe('The password that will be used to protect Project Deployments').nullable().nullish(),
        })
        .describe('Allows to protect project deployments with a password')
        .nullable()
        .nullish(),
      ssoProtection: z
        .object({
          deploymentType: z
            .enum(['all', 'all_except_custom_domains', 'preview', 'prod_deployment_urls_and_all_previews'])
            .default('preview')
            .describe('Specify if the Vercel Authentication (SSO Protection) will apply to every Deployment Target or just Preview'),
        })
        .describe('Ensures visitors to your Preview Deployments are logged into Vercel and have a minimum of Viewer access on your team')
        .nullable()
        .nullish(),
    })
    .describe('Default deployment protection settings for new projects.')
    .optional(),
}) as unknown as ToZod<PatchTeamMutationRequest>

export const patchTeamMutationResponseSchema = z.lazy(() => patchTeam200Schema) as unknown as ToZod<PatchTeamMutationResponse>

export const getTeamsQueryParamsSchema = z
  .object({
    limit: z.coerce.number().describe('Maximum number of Teams which may be returned.').optional(),
    since: z.coerce.number().describe('Timestamp (in milliseconds) to only include Teams created since then.').optional(),
    until: z.coerce.number().describe('Timestamp (in milliseconds) to only include Teams created until then.').optional(),
  })
  .optional() as unknown as ToZod<GetTeamsQueryParams>

/**
 * @description A paginated list of teams.
 */
export const getTeams200Schema = z
  .object({
    teams: z.array(z.union([z.lazy(() => teamSchema), z.lazy(() => teamLimitedSchema)])),
    pagination: z
      .lazy(() => paginationSchema)
      .describe(
        'This object contains information related to the pagination of the current request, including the necessary parameters to get the next or previous page of data.',
      ),
  })
  .describe('A paginated list of teams.') as unknown as ToZod<GetTeams200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getTeams400Schema = z.unknown() as unknown as ToZod<GetTeams400>

export const getTeams401Schema = z.unknown() as unknown as ToZod<GetTeams401>

/**
 * @description You do not have permission to access this resource.
 */
export const getTeams403Schema = z.unknown() as unknown as ToZod<GetTeams403>

export const getTeamsQueryResponseSchema = z.lazy(() => getTeams200Schema) as unknown as ToZod<GetTeamsQueryResponse>

/**
 * @description The team was created successfully
 */
export const createTeam200Schema = z
  .object({
    id: z.string().describe('Id of the created team'),
    slug: z.string(),
  })
  .describe('The team was created successfully') as unknown as ToZod<CreateTeam200>

/**
 * @description One of the provided values in the request body is invalid.\nThe slug is already in use
 */
export const createTeam400Schema = z.unknown() as unknown as ToZod<CreateTeam400>

export const createTeam401Schema = z.unknown() as unknown as ToZod<CreateTeam401>

/**
 * @description You do not have permission to access this resource.
 */
export const createTeam403Schema = z.unknown() as unknown as ToZod<CreateTeam403>

export const createTeamMutationRequestSchema = z.object({
  slug: z.string().max(48).describe('The desired slug for the Team'),
  name: z.string().max(256).describe('The desired name for the Team. It will be generated from the provided slug if nothing is provided').optional(),
  attribution: z
    .object({
      sessionReferrer: z.string().describe('Session referrer').optional(),
      landingPage: z.string().describe('Session landing page').optional(),
      pageBeforeConversionPage: z.string().describe('Referrer to the signup page').optional(),
      utm: z
        .object({
          utmSource: z.string().describe('UTM source').optional(),
          utmMedium: z.string().describe('UTM medium').optional(),
          utmCampaign: z.string().describe('UTM campaign').optional(),
          utmTerm: z.string().describe('UTM term').optional(),
        })
        .optional(),
    })
    .describe('Attribution information for the session or current page')
    .optional(),
}) as unknown as ToZod<CreateTeamMutationRequest>

export const createTeamMutationResponseSchema = z.lazy(() => createTeam200Schema) as unknown as ToZod<CreateTeamMutationResponse>

export const deleteTeamPathParamsSchema = z.object({
  teamId: z.string().describe('The Team identifier to perform the request on behalf of.'),
}) as unknown as ToZod<DeleteTeamPathParams>

export const deleteTeamQueryParamsSchema = z
  .object({
    newDefaultTeamId: z.string().describe('Id of the team to be set as the new default team').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<DeleteTeamQueryParams>

/**
 * @description The Team was successfully deleted
 */
export const deleteTeam200Schema = z
  .object({
    id: z.string().describe('The ID of the deleted Team'),
    newDefaultTeamIdError: z
      .boolean()
      .describe('Signifies whether the default team update has failed, when newDefaultTeamId is provided in request query.')
      .optional(),
  })
  .describe('The Team was successfully deleted') as unknown as ToZod<DeleteTeam200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const deleteTeam400Schema = z.unknown() as unknown as ToZod<DeleteTeam400>

export const deleteTeam401Schema = z.unknown() as unknown as ToZod<DeleteTeam401>

export const deleteTeam402Schema = z.unknown() as unknown as ToZod<DeleteTeam402>

/**
 * @description You do not have permission to access this resource.\nThe authenticated user can\'t access the team
 */
export const deleteTeam403Schema = z.unknown() as unknown as ToZod<DeleteTeam403>

export const deleteTeam409Schema = z.unknown() as unknown as ToZod<DeleteTeam409>

export const deleteTeamMutationRequestSchema = z.object({
  reasons: z
    .array(
      z
        .object({
          slug: z.string().describe('Idenitifier slug of the reason why the team is being deleted.'),
          description: z.string().describe('Description of the reason why the team is being deleted.'),
        })
        .describe('An object describing the reason why the team is being deleted.'),
    )
    .describe('Optional array of objects that describe the reason why the team is being deleted.')
    .optional(),
}) as unknown as ToZod<DeleteTeamMutationRequest>

export const deleteTeamMutationResponseSchema = z.lazy(() => deleteTeam200Schema) as unknown as ToZod<DeleteTeamMutationResponse>

export const deleteTeamInviteCodePathParamsSchema = z.object({
  inviteId: z.string().describe('The Team invite code ID.'),
}) as unknown as ToZod<DeleteTeamInviteCodePathParams>

/**
 * @description Successfully deleted Team invite code.
 */
export const deleteTeamInviteCode200Schema = z.object({
  id: z.string().describe('ID of the team.'),
}) as unknown as ToZod<DeleteTeamInviteCode200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const deleteTeamInviteCode400Schema = z.unknown() as unknown as ToZod<DeleteTeamInviteCode400>

export const deleteTeamInviteCode401Schema = z.unknown() as unknown as ToZod<DeleteTeamInviteCode401>

/**
 * @description You do not have permission to access this resource.\nInvite managed by directory sync\nNot authorized to access this team.
 */
export const deleteTeamInviteCode403Schema = z.unknown() as unknown as ToZod<DeleteTeamInviteCode403>

/**
 * @description Team invite code not found.
 */
export const deleteTeamInviteCode404Schema = z.unknown() as unknown as ToZod<DeleteTeamInviteCode404>

export const deleteTeamInviteCodeMutationResponseSchema = z.lazy(() => deleteTeamInviteCode200Schema) as unknown as ToZod<DeleteTeamInviteCodeMutationResponse>

export const uploadFileQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<UploadFileQueryParams>

export const uploadFileHeaderParamsSchema = z
  .object({
    'Content-Length': z.coerce.number().describe('The file size in bytes').optional(),
    'x-vercel-digest': z.string().max(40).describe('The file SHA1 used to check the integrity').optional(),
    'x-now-digest': z.string().max(40).describe('The file SHA1 used to check the integrity').optional(),
    'x-now-size': z.coerce.number().describe('The file size as an alternative to `Content-Length`').optional(),
    'x-internal-v0-token': z
      .string()
      .describe('Shared secret token set by v0 deployments. When present and valid, the API applies an extended rate limit.')
      .optional(),
  })
  .optional() as unknown as ToZod<UploadFileHeaderParams>

/**
 * @description File already uploaded\nFile successfully uploaded
 */
export const uploadFile200Schema = z.union([
  z.object({
    urls: z.array(z.string()).describe('Array of URLs where the file was updated'),
  }),
  z.object({}),
]) as unknown as ToZod<UploadFile200>

/**
 * @description One of the provided values in the headers is invalid\nDigest is not valid\nFile size is not valid
 */
export const uploadFile400Schema = z.unknown() as unknown as ToZod<UploadFile400>

export const uploadFile401Schema = z.unknown() as unknown as ToZod<UploadFile401>

/**
 * @description You do not have permission to access this resource.
 */
export const uploadFile403Schema = z.unknown() as unknown as ToZod<UploadFile403>

export const uploadFileMutationResponseSchema = z.lazy(() => uploadFile200Schema) as unknown as ToZod<UploadFileMutationResponse>

export const listAuthTokens200Schema = z.object({
  tokens: z.array(z.lazy(() => authTokenSchema).describe('Authentication token metadata.')),
  pagination: z
    .lazy(() => paginationSchema)
    .describe(
      'This object contains information related to the pagination of the current request, including the necessary parameters to get the next or previous page of data.',
    ),
}) as unknown as ToZod<ListAuthTokens200>

export const listAuthTokens400Schema = z.unknown() as unknown as ToZod<ListAuthTokens400>

export const listAuthTokens401Schema = z.unknown() as unknown as ToZod<ListAuthTokens401>

/**
 * @description You do not have permission to access this resource.
 */
export const listAuthTokens403Schema = z.unknown() as unknown as ToZod<ListAuthTokens403>

export const listAuthTokensQueryResponseSchema = z.lazy(() => listAuthTokens200Schema) as unknown as ToZod<ListAuthTokensQueryResponse>

export const createAuthTokenQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<CreateAuthTokenQueryParams>

/**
 * @description Successful response.
 */
export const createAuthToken200Schema = z
  .object({
    token: z.lazy(() => authTokenSchema).describe('Authentication token metadata.'),
    bearerToken: z
      .string()
      .describe(
        "The authentication token's actual value. This token is only provided in this response, and can never be retrieved again in the future. Be sure to save it somewhere safe!",
      ),
  })
  .describe('Successful response.') as unknown as ToZod<CreateAuthToken200>

/**
 * @description One of the provided values in the request body is invalid.
 */
export const createAuthToken400Schema = z.unknown() as unknown as ToZod<CreateAuthToken400>

export const createAuthToken401Schema = z.unknown() as unknown as ToZod<CreateAuthToken401>

/**
 * @description You do not have permission to access this resource.
 */
export const createAuthToken403Schema = z.unknown() as unknown as ToZod<CreateAuthToken403>

export const createAuthTokenMutationRequestSchema = z.object({
  name: z.string(),
  expiresAt: z.number().optional(),
}) as unknown as ToZod<CreateAuthTokenMutationRequest>

export const createAuthTokenMutationResponseSchema = z.lazy(() => createAuthToken200Schema) as unknown as ToZod<CreateAuthTokenMutationResponse>

export const getAuthTokenPathParamsSchema = z.object({
  tokenId: z
    .string()
    .describe(
      'The identifier of the token to retrieve. The special value \\"current\\" may be supplied, which returns the metadata for the token that the current HTTP request is authenticated with.',
    ),
}) as unknown as ToZod<GetAuthTokenPathParams>

/**
 * @description Successful response.
 */
export const getAuthToken200Schema = z
  .object({
    token: z.lazy(() => authTokenSchema).describe('Authentication token metadata.'),
  })
  .describe('Successful response.') as unknown as ToZod<GetAuthToken200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getAuthToken400Schema = z.unknown() as unknown as ToZod<GetAuthToken400>

export const getAuthToken401Schema = z.unknown() as unknown as ToZod<GetAuthToken401>

/**
 * @description You do not have permission to access this resource.
 */
export const getAuthToken403Schema = z.unknown() as unknown as ToZod<GetAuthToken403>

/**
 * @description Token not found with the requested `tokenId`.
 */
export const getAuthToken404Schema = z.unknown() as unknown as ToZod<GetAuthToken404>

export const getAuthTokenQueryResponseSchema = z.lazy(() => getAuthToken200Schema) as unknown as ToZod<GetAuthTokenQueryResponse>

export const deleteAuthTokenPathParamsSchema = z.object({
  tokenId: z
    .string()
    .describe(
      'The identifier of the token to invalidate. The special value \\"current\\" may be supplied, which invalidates the token that the HTTP request was authenticated with.',
    ),
}) as unknown as ToZod<DeleteAuthTokenPathParams>

/**
 * @description Authentication token successfully deleted.
 */
export const deleteAuthToken200Schema = z
  .object({
    tokenId: z.string().describe('The unique identifier of the token that was deleted.'),
  })
  .describe('Authentication token successfully deleted.') as unknown as ToZod<DeleteAuthToken200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const deleteAuthToken400Schema = z.unknown() as unknown as ToZod<DeleteAuthToken400>

export const deleteAuthToken401Schema = z.unknown() as unknown as ToZod<DeleteAuthToken401>

/**
 * @description You do not have permission to access this resource.
 */
export const deleteAuthToken403Schema = z.unknown() as unknown as ToZod<DeleteAuthToken403>

/**
 * @description Token not found with the requested `tokenId`.
 */
export const deleteAuthToken404Schema = z.unknown() as unknown as ToZod<DeleteAuthToken404>

export const deleteAuthTokenMutationResponseSchema = z.lazy(() => deleteAuthToken200Schema) as unknown as ToZod<DeleteAuthTokenMutationResponse>

/**
 * @description Successful response.
 */
export const getAuthUser200Schema = z
  .object({
    user: z.union([z.lazy(() => authUserSchema), z.lazy(() => authUserLimitedSchema)]),
  })
  .describe('Successful response.') as unknown as ToZod<GetAuthUser200>

export const getAuthUser400Schema = z.unknown() as unknown as ToZod<GetAuthUser400>

export const getAuthUser401Schema = z.unknown() as unknown as ToZod<GetAuthUser401>

/**
 * @description You do not have permission to access this resource.
 */
export const getAuthUser403Schema = z.unknown() as unknown as ToZod<GetAuthUser403>

export const getAuthUser409Schema = z.unknown() as unknown as ToZod<GetAuthUser409>

export const getAuthUserQueryResponseSchema = z.lazy(() => getAuthUser200Schema) as unknown as ToZod<GetAuthUserQueryResponse>

/**
 * @description Response indicating that the User deletion process has been initiated, and a confirmation email has been sent.
 */
export const requestDelete202Schema = z.object({
  id: z.string().describe('Unique identifier of the User who has initiated deletion.'),
  email: z.string().describe('Email address of the User who has initiated deletion.'),
  message: z.string().describe('User deletion progress status.'),
}) as unknown as ToZod<RequestDelete202>

/**
 * @description One of the provided values in the request body is invalid.
 */
export const requestDelete400Schema = z.unknown() as unknown as ToZod<RequestDelete400>

export const requestDelete401Schema = z.unknown() as unknown as ToZod<RequestDelete401>

export const requestDelete402Schema = z.unknown() as unknown as ToZod<RequestDelete402>

/**
 * @description You do not have permission to access this resource.
 */
export const requestDelete403Schema = z.unknown() as unknown as ToZod<RequestDelete403>

export const requestDeleteMutationRequestSchema = z.object({
  reasons: z
    .array(
      z
        .object({
          slug: z.string().describe('Idenitifier slug of the reason why the User account is being deleted.'),
          description: z.string().describe('Description of the reason why the User account is being deleted.'),
        })
        .describe('An object describing the reason why the User account is being deleted.'),
    )
    .describe('Optional array of objects that describe the reason why the User account is being deleted.')
    .optional(),
}) as unknown as ToZod<RequestDeleteMutationRequest>

export const requestDeleteMutationResponseSchema = z.lazy(() => requestDelete202Schema) as unknown as ToZod<RequestDeleteMutationResponse>

export const createWebhookQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<CreateWebhookQueryParams>

export const createWebhook200Schema = z.object({
  secret: z.string().describe('The webhook secret used to sign the payload'),
  events: z
    .array(
      z
        .enum([
          'budget.reached',
          'budget.reset',
          'deployment',
          'deployment-canceled',
          'deployment-check-rerequested',
          'deployment-checks-completed',
          'deployment-error',
          'deployment-prepared',
          'deployment-ready',
          'deployment.canceled',
          'deployment.check-rerequested',
          'deployment.checkrun.cancel',
          'deployment.checkrun.start',
          'deployment.checks.failed',
          'deployment.checks.succeeded',
          'deployment.created',
          'deployment.error',
          'deployment.integration.action.cancel',
          'deployment.integration.action.cleanup',
          'deployment.integration.action.start',
          'deployment.promoted',
          'deployment.ready',
          'deployment.succeeded',
          'domain-created',
          'domain.auto-renew.changed',
          'domain.certificate.add',
          'domain.certificate.add.failed',
          'domain.certificate.deleted',
          'domain.certificate.renew',
          'domain.certificate.renew.failed',
          'domain.created',
          'domain.dns.records.changed',
          'domain.renewal',
          'domain.renewal.failed',
          'domain.transfer-in.completed',
          'domain.transfer-in.failed',
          'domain.transfer-in.started',
          'edge-config.created',
          'edge-config.deleted',
          'edge-config.items.updated',
          'firewall.attack',
          'integration-configuration-permission-updated',
          'integration-configuration-removed',
          'integration-configuration-scope-change-confirmed',
          'integration-configuration.permission-upgraded',
          'integration-configuration.removed',
          'integration-configuration.scope-change-confirmed',
          'integration-resource.project-connected',
          'integration-resource.project-disconnected',
          'marketplace.invoice.created',
          'marketplace.invoice.notpaid',
          'marketplace.invoice.paid',
          'marketplace.invoice.refunded',
          'observability.anomaly',
          'project-created',
          'project-removed',
          'project.created',
          'project.domain.created',
          'project.domain.deleted',
          'project.domain.moved',
          'project.domain.unverified',
          'project.domain.updated',
          'project.domain.verified',
          'project.removed',
          'project.rolling-release.aborted',
          'project.rolling-release.approved',
          'project.rolling-release.completed',
          'project.rolling-release.started',
          'test-webhook',
        ])
        .describe('The webhooks events'),
    )
    .describe('The webhooks events'),
  id: z.string().describe('The webhook id'),
  url: z.string().describe('A string with the URL of the webhook'),
  ownerId: z.string().describe('The unique ID of the team the webhook belongs to'),
  createdAt: z.number().describe('A number containing the date when the webhook was created in in milliseconds'),
  updatedAt: z.number().describe('A number containing the date when the webhook was updated in in milliseconds'),
  projectIds: z.array(z.string()).describe('The ID of the projects the webhook is associated with').optional(),
}) as unknown as ToZod<CreateWebhook200>

/**
 * @description One of the provided values in the request body is invalid.
 */
export const createWebhook400Schema = z.unknown() as unknown as ToZod<CreateWebhook400>

export const createWebhook401Schema = z.unknown() as unknown as ToZod<CreateWebhook401>

/**
 * @description You do not have permission to access this resource.
 */
export const createWebhook403Schema = z.unknown() as unknown as ToZod<CreateWebhook403>

export const createWebhookMutationRequestSchema = z.object({
  url: z.string().url(),
  events: z
    .array(
      z.enum([
        'budget.reached',
        'budget.reset',
        'deployment',
        'deployment-canceled',
        'deployment-check-rerequested',
        'deployment-checks-completed',
        'deployment-error',
        'deployment-prepared',
        'deployment-ready',
        'deployment.canceled',
        'deployment.check-rerequested',
        'deployment.checkrun.cancel',
        'deployment.checkrun.start',
        'deployment.checks.failed',
        'deployment.checks.succeeded',
        'deployment.created',
        'deployment.error',
        'deployment.integration.action.cancel',
        'deployment.integration.action.cleanup',
        'deployment.integration.action.start',
        'deployment.promoted',
        'deployment.ready',
        'deployment.succeeded',
        'domain-created',
        'domain.auto-renew.changed',
        'domain.certificate.add',
        'domain.certificate.add.failed',
        'domain.certificate.deleted',
        'domain.certificate.renew',
        'domain.certificate.renew.failed',
        'domain.created',
        'domain.dns.records.changed',
        'domain.renewal',
        'domain.renewal.failed',
        'domain.transfer-in.completed',
        'domain.transfer-in.failed',
        'domain.transfer-in.started',
        'edge-config.created',
        'edge-config.deleted',
        'edge-config.items.updated',
        'firewall.attack',
        'integration-configuration-permission-updated',
        'integration-configuration-removed',
        'integration-configuration-scope-change-confirmed',
        'integration-configuration.permission-upgraded',
        'integration-configuration.removed',
        'integration-configuration.scope-change-confirmed',
        'integration-resource.project-connected',
        'integration-resource.project-disconnected',
        'marketplace.invoice.created',
        'marketplace.invoice.notpaid',
        'marketplace.invoice.paid',
        'marketplace.invoice.refunded',
        'observability.anomaly',
        'project-created',
        'project-removed',
        'project.created',
        'project.domain.created',
        'project.domain.deleted',
        'project.domain.moved',
        'project.domain.unverified',
        'project.domain.updated',
        'project.domain.verified',
        'project.removed',
        'project.rolling-release.aborted',
        'project.rolling-release.approved',
        'project.rolling-release.completed',
        'project.rolling-release.started',
        'test-webhook',
      ]),
    )
    .min(1),
  projectIds: z
    .array(z.string().regex(/^[a-zA-z0-9_]+$/))
    .min(1)
    .max(50)
    .optional(),
}) as unknown as ToZod<CreateWebhookMutationRequest>

export const createWebhookMutationResponseSchema = z.lazy(() => createWebhook200Schema) as unknown as ToZod<CreateWebhookMutationResponse>

export const getWebhooksQueryParamsSchema = z
  .object({
    projectId: z
      .string()
      .regex(/^[a-zA-z0-9_]+$/)
      .optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetWebhooksQueryParams>

export const getWebhooks200Schema = z.union([
  z.array(
    z.object({
      projectsMetadata: z
        .array(
          z.object({
            id: z.string(),
            name: z.string(),
            framework: z
              .enum([
                'blitzjs',
                'nextjs',
                'gatsby',
                'remix',
                'react-router',
                'astro',
                'hexo',
                'eleventy',
                'docusaurus-2',
                'docusaurus',
                'preact',
                'solidstart-1',
                'solidstart',
                'dojo',
                'ember',
                'vue',
                'scully',
                'ionic-angular',
                'angular',
                'polymer',
                'svelte',
                'sveltekit',
                'sveltekit-1',
                'ionic-react',
                'create-react-app',
                'gridsome',
                'umijs',
                'sapper',
                'saber',
                'stencil',
                'nuxtjs',
                'redwoodjs',
                'hugo',
                'jekyll',
                'brunch',
                'middleman',
                'zola',
                'hydrogen',
                'vite',
                'vitepress',
                'vuepress',
                'parcel',
                'fasthtml',
                'sanity-v3',
                'sanity',
                'storybook',
                'nitro',
              ])
              .nullable()
              .nullish(),
            latestDeployment: z.string().optional(),
          }),
        )
        .nullable(),
      events: z
        .array(
          z
            .enum([
              'budget.reached',
              'budget.reset',
              'domain.created',
              'domain.dns.records.changed',
              'domain.transfer-in.started',
              'domain.transfer-in.completed',
              'domain.transfer-in.failed',
              'domain.certificate.add',
              'domain.certificate.add.failed',
              'domain.certificate.renew',
              'domain.certificate.renew.failed',
              'domain.certificate.deleted',
              'domain.renewal',
              'domain.renewal.failed',
              'domain.auto-renew.changed',
              'deployment.created',
              'deployment.error',
              'deployment.canceled',
              'deployment.succeeded',
              'deployment.ready',
              'deployment.check-rerequested',
              'deployment.promoted',
              'deployment.integration.action.start',
              'deployment.integration.action.cancel',
              'deployment.integration.action.cleanup',
              'deployment.checkrun.start',
              'deployment.checkrun.cancel',
              'edge-config.created',
              'edge-config.deleted',
              'edge-config.items.updated',
              'firewall.attack',
              'integration-configuration.permission-upgraded',
              'integration-configuration.removed',
              'integration-configuration.scope-change-confirmed',
              'integration-resource.project-connected',
              'integration-resource.project-disconnected',
              'project.created',
              'project.removed',
              'project.domain.created',
              'project.domain.updated',
              'project.domain.deleted',
              'project.domain.verified',
              'project.domain.unverified',
              'project.domain.moved',
              'project.rolling-release.started',
              'project.rolling-release.aborted',
              'project.rolling-release.completed',
              'project.rolling-release.approved',
              'deployment.checks.failed',
              'deployment.checks.succeeded',
              'deployment-checks-completed',
              'deployment-ready',
              'deployment-prepared',
              'deployment-error',
              'deployment-check-rerequested',
              'deployment-canceled',
              'project-created',
              'project-removed',
              'domain-created',
              'deployment',
              'integration-configuration-permission-updated',
              'integration-configuration-removed',
              'integration-configuration-scope-change-confirmed',
              'marketplace.invoice.created',
              'marketplace.invoice.paid',
              'marketplace.invoice.notpaid',
              'marketplace.invoice.refunded',
              'observability.anomaly',
              'test-webhook',
            ])
            .describe('The webhooks events'),
        )
        .describe('The webhooks events'),
      id: z.string().describe('The webhook id'),
      url: z.string().describe('A string with the URL of the webhook'),
      ownerId: z.string().describe('The unique ID of the team the webhook belongs to'),
      createdAt: z.number().describe('A number containing the date when the webhook was created in in milliseconds'),
      updatedAt: z.number().describe('A number containing the date when the webhook was updated in in milliseconds'),
      projectIds: z.array(z.string()).describe('The ID of the projects the webhook is associated with').optional(),
    }),
  ),
  z.array(
    z.object({
      events: z
        .array(
          z
            .enum([
              'budget.reached',
              'budget.reset',
              'domain.created',
              'domain.dns.records.changed',
              'domain.transfer-in.started',
              'domain.transfer-in.completed',
              'domain.transfer-in.failed',
              'domain.certificate.add',
              'domain.certificate.add.failed',
              'domain.certificate.renew',
              'domain.certificate.renew.failed',
              'domain.certificate.deleted',
              'domain.renewal',
              'domain.renewal.failed',
              'domain.auto-renew.changed',
              'deployment.created',
              'deployment.error',
              'deployment.canceled',
              'deployment.succeeded',
              'deployment.ready',
              'deployment.check-rerequested',
              'deployment.promoted',
              'deployment.integration.action.start',
              'deployment.integration.action.cancel',
              'deployment.integration.action.cleanup',
              'deployment.checkrun.start',
              'deployment.checkrun.cancel',
              'edge-config.created',
              'edge-config.deleted',
              'edge-config.items.updated',
              'firewall.attack',
              'integration-configuration.permission-upgraded',
              'integration-configuration.removed',
              'integration-configuration.scope-change-confirmed',
              'integration-resource.project-connected',
              'integration-resource.project-disconnected',
              'project.created',
              'project.removed',
              'project.domain.created',
              'project.domain.updated',
              'project.domain.deleted',
              'project.domain.verified',
              'project.domain.unverified',
              'project.domain.moved',
              'project.rolling-release.started',
              'project.rolling-release.aborted',
              'project.rolling-release.completed',
              'project.rolling-release.approved',
              'deployment.checks.failed',
              'deployment.checks.succeeded',
              'deployment-checks-completed',
              'deployment-ready',
              'deployment-prepared',
              'deployment-error',
              'deployment-check-rerequested',
              'deployment-canceled',
              'project-created',
              'project-removed',
              'domain-created',
              'deployment',
              'integration-configuration-permission-updated',
              'integration-configuration-removed',
              'integration-configuration-scope-change-confirmed',
              'marketplace.invoice.created',
              'marketplace.invoice.paid',
              'marketplace.invoice.notpaid',
              'marketplace.invoice.refunded',
              'observability.anomaly',
              'test-webhook',
            ])
            .describe('The webhooks events'),
        )
        .describe('The webhooks events'),
      id: z.string().describe('The webhook id'),
      url: z.string().describe('A string with the URL of the webhook'),
      ownerId: z.string().describe('The unique ID of the team the webhook belongs to'),
      createdAt: z.number().describe('A number containing the date when the webhook was created in in milliseconds'),
      updatedAt: z.number().describe('A number containing the date when the webhook was updated in in milliseconds'),
      projectIds: z.array(z.string()).describe('The ID of the projects the webhook is associated with').optional(),
    }),
  ),
]) as unknown as ToZod<GetWebhooks200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getWebhooks400Schema = z.unknown() as unknown as ToZod<GetWebhooks400>

export const getWebhooks401Schema = z.unknown() as unknown as ToZod<GetWebhooks401>

/**
 * @description You do not have permission to access this resource.
 */
export const getWebhooks403Schema = z.unknown() as unknown as ToZod<GetWebhooks403>

export const getWebhooksQueryResponseSchema = z.lazy(() => getWebhooks200Schema) as unknown as ToZod<GetWebhooksQueryResponse>

export const getWebhookPathParamsSchema = z.object({
  id: z.string(),
}) as unknown as ToZod<GetWebhookPathParams>

export const getWebhookQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetWebhookQueryParams>

export const getWebhook200Schema = z.object({
  events: z
    .array(
      z
        .enum([
          'budget.reached',
          'budget.reset',
          'deployment',
          'deployment-canceled',
          'deployment-check-rerequested',
          'deployment-checks-completed',
          'deployment-error',
          'deployment-prepared',
          'deployment-ready',
          'deployment.canceled',
          'deployment.check-rerequested',
          'deployment.checkrun.cancel',
          'deployment.checkrun.start',
          'deployment.checks.failed',
          'deployment.checks.succeeded',
          'deployment.created',
          'deployment.error',
          'deployment.integration.action.cancel',
          'deployment.integration.action.cleanup',
          'deployment.integration.action.start',
          'deployment.promoted',
          'deployment.ready',
          'deployment.succeeded',
          'domain-created',
          'domain.auto-renew.changed',
          'domain.certificate.add',
          'domain.certificate.add.failed',
          'domain.certificate.deleted',
          'domain.certificate.renew',
          'domain.certificate.renew.failed',
          'domain.created',
          'domain.dns.records.changed',
          'domain.renewal',
          'domain.renewal.failed',
          'domain.transfer-in.completed',
          'domain.transfer-in.failed',
          'domain.transfer-in.started',
          'edge-config.created',
          'edge-config.deleted',
          'edge-config.items.updated',
          'firewall.attack',
          'integration-configuration-permission-updated',
          'integration-configuration-removed',
          'integration-configuration-scope-change-confirmed',
          'integration-configuration.permission-upgraded',
          'integration-configuration.removed',
          'integration-configuration.scope-change-confirmed',
          'integration-resource.project-connected',
          'integration-resource.project-disconnected',
          'marketplace.invoice.created',
          'marketplace.invoice.notpaid',
          'marketplace.invoice.paid',
          'marketplace.invoice.refunded',
          'observability.anomaly',
          'project-created',
          'project-removed',
          'project.created',
          'project.domain.created',
          'project.domain.deleted',
          'project.domain.moved',
          'project.domain.unverified',
          'project.domain.updated',
          'project.domain.verified',
          'project.removed',
          'project.rolling-release.aborted',
          'project.rolling-release.approved',
          'project.rolling-release.completed',
          'project.rolling-release.started',
          'test-webhook',
        ])
        .describe('The webhooks events'),
    )
    .describe('The webhooks events'),
  id: z.string().describe('The webhook id'),
  url: z.string().describe('A string with the URL of the webhook'),
  ownerId: z.string().describe('The unique ID of the team the webhook belongs to'),
  createdAt: z.number().describe('A number containing the date when the webhook was created in in milliseconds'),
  updatedAt: z.number().describe('A number containing the date when the webhook was updated in in milliseconds'),
  projectIds: z.array(z.string()).describe('The ID of the projects the webhook is associated with').optional(),
}) as unknown as ToZod<GetWebhook200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getWebhook400Schema = z.unknown() as unknown as ToZod<GetWebhook400>

export const getWebhook401Schema = z.unknown() as unknown as ToZod<GetWebhook401>

/**
 * @description You do not have permission to access this resource.
 */
export const getWebhook403Schema = z.unknown() as unknown as ToZod<GetWebhook403>

export const getWebhookQueryResponseSchema = z.lazy(() => getWebhook200Schema) as unknown as ToZod<GetWebhookQueryResponse>

export const deleteWebhookPathParamsSchema = z.object({
  id: z.string(),
}) as unknown as ToZod<DeleteWebhookPathParams>

export const deleteWebhookQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<DeleteWebhookQueryParams>

export const deleteWebhook204Schema = z.unknown() as unknown as ToZod<DeleteWebhook204>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const deleteWebhook400Schema = z.unknown() as unknown as ToZod<DeleteWebhook400>

export const deleteWebhook401Schema = z.unknown() as unknown as ToZod<DeleteWebhook401>

/**
 * @description You do not have permission to access this resource.
 */
export const deleteWebhook403Schema = z.unknown() as unknown as ToZod<DeleteWebhook403>

export const deleteWebhookMutationResponseSchema = z.lazy(() => deleteWebhook204Schema) as unknown as ToZod<DeleteWebhookMutationResponse>

export const listDeploymentAliasesPathParamsSchema = z.object({
  id: z.string().describe('The ID of the deployment the aliases should be listed for'),
}) as unknown as ToZod<ListDeploymentAliasesPathParams>

export const listDeploymentAliasesQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<ListDeploymentAliasesQueryParams>

/**
 * @description The list of aliases assigned to the deployment
 */
export const listDeploymentAliases200Schema = z.object({
  aliases: z
    .array(
      z
        .object({
          uid: z.string().describe('The unique identifier of the alias'),
          alias: z.string().describe('The alias name, it could be a `.vercel.app` subdomain or a custom domain'),
          created: z.date().describe('The date when the alias was created'),
          redirect: z.string().describe('Target destination domain for redirect when the alias is a redirect').nullable().nullish(),
          protectionBypass: z
            .object({})
            .catchall(
              z.union([
                z.object({
                  createdAt: z.number(),
                  createdBy: z.string(),
                  scope: z.enum(['shareable-link']),
                }),
                z.object({
                  createdAt: z.number(),
                  lastUpdatedAt: z.number(),
                  lastUpdatedBy: z.string(),
                  access: z.enum(['requested', 'granted']),
                  scope: z.enum(['user']),
                }),
                z.object({
                  createdAt: z.number(),
                  createdBy: z.string(),
                  scope: z.enum(['alias-protection-override']),
                }),
                z.object({
                  createdAt: z.number(),
                  lastUpdatedAt: z.number(),
                  lastUpdatedBy: z.string(),
                  scope: z.enum(['email_invite']),
                }),
              ]),
            )
            .describe('The protection bypass for the alias')
            .optional(),
        })
        .describe('A list of the aliases assigned to the deployment'),
    )
    .describe('A list of the aliases assigned to the deployment'),
}) as unknown as ToZod<ListDeploymentAliases200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const listDeploymentAliases400Schema = z.unknown() as unknown as ToZod<ListDeploymentAliases400>

export const listDeploymentAliases401Schema = z.unknown() as unknown as ToZod<ListDeploymentAliases401>

/**
 * @description You do not have permission to access this resource.
 */
export const listDeploymentAliases403Schema = z.unknown() as unknown as ToZod<ListDeploymentAliases403>

/**
 * @description The deployment was not found
 */
export const listDeploymentAliases404Schema = z.unknown() as unknown as ToZod<ListDeploymentAliases404>

export const listDeploymentAliasesQueryResponseSchema = z.lazy(() => listDeploymentAliases200Schema) as unknown as ToZod<ListDeploymentAliasesQueryResponse>

export const assignAliasPathParamsSchema = z.object({
  id: z.string().describe('The ID of the deployment the aliases should be listed for'),
}) as unknown as ToZod<AssignAliasPathParams>

export const assignAliasQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<AssignAliasQueryParams>

/**
 * @description The alias was successfully assigned to the deployment
 */
export const assignAlias200Schema = z.object({
  uid: z.string().describe('The unique identifier of the alias'),
  alias: z.string().describe('The assigned alias name'),
  created: z.date().describe('The date when the alias was created'),
  oldDeploymentId: z
    .string()
    .describe('The unique identifier of the previously aliased deployment, only received when the alias was used before')
    .nullable()
    .nullish(),
}) as unknown as ToZod<AssignAlias200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.\nThe cert for the provided alias is not ready\nThe deployment is not READY and can not be aliased\nThe supplied alias is invalid
 */
export const assignAlias400Schema = z.unknown() as unknown as ToZod<AssignAlias400>

export const assignAlias401Schema = z.unknown() as unknown as ToZod<AssignAlias401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const assignAlias402Schema = z.unknown() as unknown as ToZod<AssignAlias402>

/**
 * @description You do not have permission to access this resource.\nIf no .vercel.app alias exists then we fail (nothing to mirror)
 */
export const assignAlias403Schema = z.unknown() as unknown as ToZod<AssignAlias403>

/**
 * @description The domain used for the alias was not found\nThe deployment was not found
 */
export const assignAlias404Schema = z.unknown() as unknown as ToZod<AssignAlias404>

/**
 * @description The provided alias is already assigned to the given deployment\nThe domain is not allowed to be used
 */
export const assignAlias409Schema = z.unknown() as unknown as ToZod<AssignAlias409>

export const assignAliasMutationRequestSchema = z.object({
  alias: z.string().describe('The alias we want to assign to the deployment defined in the URL').optional(),
  redirect: z
    .string()
    .describe(
      'The redirect property will take precedence over the deployment id from the URL and consists of a hostname (like test.com) to which the alias should redirect using status code 307',
    )
    .nullable()
    .nullish(),
}) as unknown as ToZod<AssignAliasMutationRequest>

export const assignAliasMutationResponseSchema = z.lazy(() => assignAlias200Schema) as unknown as ToZod<AssignAliasMutationResponse>

export const listAliasesQueryParamsSchema = z
  .object({
    domain: z
      .union([z.array(z.unknown()), z.string()])
      .max(20)
      .describe('Get only aliases of the given domain name')
      .optional(),
    from: z.coerce.number().describe('Get only aliases created after the provided timestamp').optional(),
    limit: z.coerce.number().describe('Maximum number of aliases to list from a request').optional(),
    projectId: z.string().describe('Filter aliases from the given `projectId`').optional(),
    since: z.coerce.number().describe('Get aliases created after this JavaScript timestamp').optional(),
    until: z.coerce.number().describe('Get aliases created before this JavaScript timestamp').optional(),
    rollbackDeploymentId: z.string().describe('Get aliases that would be rolled back for the given deployment').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<ListAliasesQueryParams>

/**
 * @description The paginated list of aliases
 */
export const listAliases200Schema = z.object({
  aliases: z.array(
    z.object({
      alias: z.string().describe('The alias name, it could be a `.vercel.app` subdomain or a custom domain'),
      created: z.date().describe('The date when the alias was created'),
      createdAt: z.number().describe('The date when the alias was created in milliseconds since the UNIX epoch').optional(),
      creator: z
        .object({
          uid: z.string().describe('ID of the user who created the alias'),
          email: z.string().describe('Email of the user who created the alias'),
          username: z.string().describe('Username of the user who created the alias'),
        })
        .describe('Information of the user who created the alias')
        .optional(),
      deletedAt: z.number().describe('The date when the alias was deleted in milliseconds since the UNIX epoch').optional(),
      deployment: z
        .object({
          id: z.string().describe('The deployment unique identifier'),
          url: z.string().describe('The deployment unique URL'),
          meta: z.string().describe('The deployment metadata').optional(),
        })
        .describe('A map with the deployment ID, URL and metadata')
        .optional(),
      deploymentId: z.string().describe('The deployment ID').nullable(),
      projectId: z.string().describe('The unique identifier of the project').nullable(),
      redirect: z.string().describe('Target destination domain for redirect when the alias is a redirect').nullable().nullish(),
      redirectStatusCode: z
        .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
        .describe('Status code to be used on redirect')
        .nullable()
        .nullish(),
      uid: z.string().describe('The unique identifier of the alias'),
      updatedAt: z.number().describe('The date when the alias was updated in milliseconds since the UNIX epoch').optional(),
      protectionBypass: z
        .object({})
        .catchall(
          z.union([
            z.object({
              createdAt: z.number(),
              createdBy: z.string(),
              scope: z.enum(['shareable-link']),
            }),
            z.object({
              createdAt: z.number(),
              lastUpdatedAt: z.number(),
              lastUpdatedBy: z.string(),
              access: z.enum(['requested', 'granted']),
              scope: z.enum(['user']),
            }),
            z.object({
              createdAt: z.number(),
              createdBy: z.string(),
              scope: z.enum(['alias-protection-override']),
            }),
            z.object({
              createdAt: z.number(),
              lastUpdatedAt: z.number(),
              lastUpdatedBy: z.string(),
              scope: z.enum(['email_invite']),
            }),
          ]),
        )
        .describe('The protection bypass for the alias')
        .optional(),
      microfrontends: z
        .object({
          defaultApp: z.object({
            projectId: z.string(),
          }),
          applications: z
            .array(
              z
                .object({
                  projectId: z.string().describe('The project ID that should use the below configuration.'),
                  fallbackHost: z.string().describe('This is always set and is the fallback host to send the request to if there is no deployment ID.'),
                  deploymentId: z
                    .string()
                    .describe(
                      'This is only set if there are changes to the application. This is the deployment ID to use for requests to that application. If this is unset, requests will be sent to the `fallbackHost`.',
                    )
                    .optional(),
                  deploymentUrl: z.string().describe('This is used and set in the exact same way as `deploymentId`.').optional(),
                })
                .describe('A list of the deployment routing information for each project.'),
            )
            .describe('A list of the deployment routing information for each project.'),
        })
        .describe('The microfrontends for the alias including the routing configuration')
        .optional(),
    }),
  ),
  pagination: z
    .lazy(() => paginationSchema)
    .describe(
      'This object contains information related to the pagination of the current request, including the necessary parameters to get the next or previous page of data.',
    ),
}) as unknown as ToZod<ListAliases200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const listAliases400Schema = z.unknown() as unknown as ToZod<ListAliases400>

export const listAliases401Schema = z.unknown() as unknown as ToZod<ListAliases401>

/**
 * @description You do not have permission to access this resource.
 */
export const listAliases403Schema = z.unknown() as unknown as ToZod<ListAliases403>

export const listAliases404Schema = z.unknown() as unknown as ToZod<ListAliases404>

export const listAliasesQueryResponseSchema = z.lazy(() => listAliases200Schema) as unknown as ToZod<ListAliasesQueryResponse>

export const getAliasPathParamsSchema = z.object({
  idOrAlias: z.string().describe('The alias or alias ID to be retrieved'),
}) as unknown as ToZod<GetAliasPathParams>

export const getAliasQueryParamsSchema = z
  .object({
    from: z.coerce.number().describe('Get the alias only if it was created after the provided timestamp').optional(),
    projectId: z.string().describe('Get the alias only if it is assigned to the provided project ID').optional(),
    since: z.coerce.number().describe('Get the alias only if it was created after this JavaScript timestamp').optional(),
    until: z.coerce.number().describe('Get the alias only if it was created before this JavaScript timestamp').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetAliasQueryParams>

/**
 * @description The alias information
 */
export const getAlias200Schema = z.object({
  alias: z.string().describe('The alias name, it could be a `.vercel.app` subdomain or a custom domain'),
  created: z.date().describe('The date when the alias was created'),
  createdAt: z.number().describe('The date when the alias was created in milliseconds since the UNIX epoch').optional(),
  creator: z
    .object({
      uid: z.string().describe('ID of the user who created the alias'),
      email: z.string().describe('Email of the user who created the alias'),
      username: z.string().describe('Username of the user who created the alias'),
    })
    .describe('Information of the user who created the alias')
    .optional(),
  deletedAt: z.number().describe('The date when the alias was deleted in milliseconds since the UNIX epoch').optional(),
  deployment: z
    .object({
      id: z.string().describe('The deployment unique identifier'),
      url: z.string().describe('The deployment unique URL'),
      meta: z.string().describe('The deployment metadata').optional(),
    })
    .describe('A map with the deployment ID, URL and metadata')
    .optional(),
  deploymentId: z.string().describe('The deployment ID').nullable(),
  projectId: z.string().describe('The unique identifier of the project').nullable(),
  redirect: z.string().describe('Target destination domain for redirect when the alias is a redirect').nullable().nullish(),
  redirectStatusCode: z
    .union([z.literal(301), z.literal(302), z.literal(307), z.literal(308)])
    .describe('Status code to be used on redirect')
    .nullable()
    .nullish(),
  uid: z.string().describe('The unique identifier of the alias'),
  updatedAt: z.number().describe('The date when the alias was updated in milliseconds since the UNIX epoch').optional(),
  protectionBypass: z
    .object({})
    .catchall(
      z.union([
        z.object({
          createdAt: z.number(),
          createdBy: z.string(),
          scope: z.enum(['shareable-link']),
        }),
        z.object({
          createdAt: z.number(),
          lastUpdatedAt: z.number(),
          lastUpdatedBy: z.string(),
          access: z.enum(['requested', 'granted']),
          scope: z.enum(['user']),
        }),
        z.object({
          createdAt: z.number(),
          createdBy: z.string(),
          scope: z.enum(['alias-protection-override']),
        }),
        z.object({
          createdAt: z.number(),
          lastUpdatedAt: z.number(),
          lastUpdatedBy: z.string(),
          scope: z.enum(['email_invite']),
        }),
      ]),
    )
    .describe('The protection bypass for the alias')
    .optional(),
  microfrontends: z
    .object({
      defaultApp: z.object({
        projectId: z.string(),
      }),
      applications: z
        .array(
          z
            .object({
              projectId: z.string().describe('The project ID that should use the below configuration.'),
              fallbackHost: z.string().describe('This is always set and is the fallback host to send the request to if there is no deployment ID.'),
              deploymentId: z
                .string()
                .describe(
                  'This is only set if there are changes to the application. This is the deployment ID to use for requests to that application. If this is unset, requests will be sent to the `fallbackHost`.',
                )
                .optional(),
              deploymentUrl: z.string().describe('This is used and set in the exact same way as `deploymentId`.').optional(),
            })
            .describe('A list of the deployment routing information for each project.'),
        )
        .describe('A list of the deployment routing information for each project.'),
    })
    .describe('The microfrontends for the alias including the routing configuration')
    .optional(),
}) as unknown as ToZod<GetAlias200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getAlias400Schema = z.unknown() as unknown as ToZod<GetAlias400>

export const getAlias401Schema = z.unknown() as unknown as ToZod<GetAlias401>

/**
 * @description You do not have permission to access this resource.
 */
export const getAlias403Schema = z.unknown() as unknown as ToZod<GetAlias403>

/**
 * @description The alias was not found
 */
export const getAlias404Schema = z.unknown() as unknown as ToZod<GetAlias404>

export const getAliasQueryResponseSchema = z.lazy(() => getAlias200Schema) as unknown as ToZod<GetAliasQueryResponse>

export const deleteAliasPathParamsSchema = z.object({
  aliasId: z.string().describe('The ID or alias that will be removed'),
}) as unknown as ToZod<DeleteAliasPathParams>

export const deleteAliasQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<DeleteAliasQueryParams>

/**
 * @description The alias was successfully removed
 */
export const deleteAlias200Schema = z.object({
  status: z.enum(['SUCCESS']),
}) as unknown as ToZod<DeleteAlias200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const deleteAlias400Schema = z.unknown() as unknown as ToZod<DeleteAlias400>

export const deleteAlias401Schema = z.unknown() as unknown as ToZod<DeleteAlias401>

/**
 * @description You do not have permission to access this resource.
 */
export const deleteAlias403Schema = z.unknown() as unknown as ToZod<DeleteAlias403>

/**
 * @description The alias was not found
 */
export const deleteAlias404Schema = z.unknown() as unknown as ToZod<DeleteAlias404>

export const deleteAliasMutationResponseSchema = z.lazy(() => deleteAlias200Schema) as unknown as ToZod<DeleteAliasMutationResponse>

export const patchUrlProtectionBypassPathParamsSchema = z.object({
  id: z.string().describe('The alias or deployment ID'),
}) as unknown as ToZod<PatchUrlProtectionBypassPathParams>

export const patchUrlProtectionBypassQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<PatchUrlProtectionBypassQueryParams>

export const patchUrlProtectionBypass200Schema = z.object({}).catchall(z.unknown()) as unknown as ToZod<PatchUrlProtectionBypass200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const patchUrlProtectionBypass400Schema = z.unknown() as unknown as ToZod<PatchUrlProtectionBypass400>

export const patchUrlProtectionBypass401Schema = z.unknown() as unknown as ToZod<PatchUrlProtectionBypass401>

/**
 * @description You do not have permission to access this resource.
 */
export const patchUrlProtectionBypass403Schema = z.unknown() as unknown as ToZod<PatchUrlProtectionBypass403>

export const patchUrlProtectionBypass404Schema = z.unknown() as unknown as ToZod<PatchUrlProtectionBypass404>

export const patchUrlProtectionBypass409Schema = z.unknown() as unknown as ToZod<PatchUrlProtectionBypass409>

export const patchUrlProtectionBypass428Schema = z.unknown() as unknown as ToZod<PatchUrlProtectionBypass428>

export const patchUrlProtectionBypass500Schema = z.unknown() as unknown as ToZod<PatchUrlProtectionBypass500>

export const patchUrlProtectionBypassMutationRequestSchema = z.union([
  z.object({
    revoke: z
      .object({
        secret: z.string().describe('Sharebale link to revoked'),
        regenerate: z.boolean().describe('Whether or not a new shareable link should be created after the provided secret is revoked'),
      })
      .describe('Optional instructions for revoking and regenerating a shareable link')
      .optional(),
  }),
  z.object({
    scope: z
      .object({
        userId: z.string().describe('Specified user id for the scoped bypass.').optional(),
        email: z.string().email().describe('Specified email for the scoped bypass.').optional(),
        access: z.enum(['denied', 'granted']).describe('Invitation status for the user scoped bypass.').optional(),
      })
      .describe('Instructions for creating a user scoped protection bypass'),
  }),
  z.object({
    override: z.object({
      scope: z.enum(['alias-protection-override']),
      action: z.enum(['create', 'revoke']),
    }),
  }),
]) as unknown as ToZod<PatchUrlProtectionBypassMutationRequest>

export const patchUrlProtectionBypassMutationResponseSchema = z.lazy(
  () => patchUrlProtectionBypass200Schema,
) as unknown as ToZod<PatchUrlProtectionBypassMutationResponse>

export const getcerts200Schema = z.object({
  certs: z.array(
    z.object({
      cn: z.string(),
      uid: z.string(),
      created: z.date(),
      expiration: z.date(),
      autoRenew: z.boolean(),
    }),
  ),
}) as unknown as ToZod<Getcerts200>

export const getcerts400Schema = z.unknown() as unknown as ToZod<Getcerts400>

export const getcerts401Schema = z.unknown() as unknown as ToZod<Getcerts401>

/**
 * @description You do not have permission to access this resource.
 */
export const getcerts403Schema = z.unknown() as unknown as ToZod<Getcerts403>

export const getcertsQueryResponseSchema = z.lazy(() => getcerts200Schema) as unknown as ToZod<GetcertsQueryResponse>

export const getCertByIdPathParamsSchema = z.object({
  id: z.string().describe('The cert id'),
}) as unknown as ToZod<GetCertByIdPathParams>

export const getCertByIdQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetCertByIdQueryParams>

export const getCertById200Schema = z.object({
  id: z.string(),
  createdAt: z.number(),
  expiresAt: z.number(),
  autoRenew: z.boolean(),
  cns: z.array(z.string()),
}) as unknown as ToZod<GetCertById200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getCertById400Schema = z.unknown() as unknown as ToZod<GetCertById400>

export const getCertById401Schema = z.unknown() as unknown as ToZod<GetCertById401>

/**
 * @description You do not have permission to access this resource.
 */
export const getCertById403Schema = z.unknown() as unknown as ToZod<GetCertById403>

export const getCertById404Schema = z.unknown() as unknown as ToZod<GetCertById404>

export const getCertByIdQueryResponseSchema = z.lazy(() => getCertById200Schema) as unknown as ToZod<GetCertByIdQueryResponse>

export const removeCertPathParamsSchema = z.object({
  id: z.string().describe('The cert id to remove'),
}) as unknown as ToZod<RemoveCertPathParams>

export const removeCertQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<RemoveCertQueryParams>

export const removeCert200Schema = z.object({}) as unknown as ToZod<RemoveCert200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const removeCert400Schema = z.unknown() as unknown as ToZod<RemoveCert400>

export const removeCert401Schema = z.unknown() as unknown as ToZod<RemoveCert401>

/**
 * @description You do not have permission to access this resource.
 */
export const removeCert403Schema = z.unknown() as unknown as ToZod<RemoveCert403>

export const removeCert404Schema = z.unknown() as unknown as ToZod<RemoveCert404>

export const removeCertMutationResponseSchema = z.lazy(() => removeCert200Schema) as unknown as ToZod<RemoveCertMutationResponse>

export const issueCertQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<IssueCertQueryParams>

export const issueCert200Schema = z.object({
  id: z.string(),
  createdAt: z.number(),
  expiresAt: z.number(),
  autoRenew: z.boolean(),
  cns: z.array(z.string()),
}) as unknown as ToZod<IssueCert200>

/**
 * @description One of the provided values in the request body is invalid.
 */
export const issueCert400Schema = z.unknown() as unknown as ToZod<IssueCert400>

export const issueCert401Schema = z.unknown() as unknown as ToZod<IssueCert401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const issueCert402Schema = z.unknown() as unknown as ToZod<IssueCert402>

/**
 * @description You do not have permission to access this resource.
 */
export const issueCert403Schema = z.unknown() as unknown as ToZod<IssueCert403>

export const issueCert404Schema = z.unknown() as unknown as ToZod<IssueCert404>

export const issueCert449Schema = z.unknown() as unknown as ToZod<IssueCert449>

export const issueCert500Schema = z.unknown() as unknown as ToZod<IssueCert500>

export const issueCertMutationRequestSchema = z.object({
  cns: z.array(z.string()).describe('The common names the cert should be issued for').optional(),
}) as unknown as ToZod<IssueCertMutationRequest>

export const issueCertMutationResponseSchema = z.lazy(() => issueCert200Schema) as unknown as ToZod<IssueCertMutationResponse>

export const uploadCertQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<UploadCertQueryParams>

export const uploadCert200Schema = z.object({
  id: z.string(),
  createdAt: z.number(),
  expiresAt: z.number(),
  autoRenew: z.boolean(),
  cns: z.array(z.string()),
}) as unknown as ToZod<UploadCert200>

/**
 * @description One of the provided values in the request body is invalid.
 */
export const uploadCert400Schema = z.unknown() as unknown as ToZod<UploadCert400>

export const uploadCert401Schema = z.unknown() as unknown as ToZod<UploadCert401>

/**
 * @description This feature is only available for Enterprise customers.
 */
export const uploadCert402Schema = z.unknown() as unknown as ToZod<UploadCert402>

/**
 * @description You do not have permission to access this resource.
 */
export const uploadCert403Schema = z.unknown() as unknown as ToZod<UploadCert403>

export const uploadCertMutationRequestSchema = z.object({
  ca: z.string().describe('The certificate authority'),
  key: z.string().describe('The certificate key'),
  cert: z.string().describe('The certificate'),
  skipValidation: z.boolean().describe('Skip validation of the certificate').optional(),
}) as unknown as ToZod<UploadCertMutationRequest>

export const uploadCertMutationResponseSchema = z.lazy(() => uploadCert200Schema) as unknown as ToZod<UploadCertMutationResponse>

export const listDeploymentFilesPathParamsSchema = z.object({
  id: z.string().describe('The unique deployment identifier'),
}) as unknown as ToZod<ListDeploymentFilesPathParams>

export const listDeploymentFilesQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<ListDeploymentFilesQueryParams>

/**
 * @description Retrieved the file tree successfully
 */
export const listDeploymentFiles200Schema = z.array(
  z.lazy(() => fileTreeSchema).describe('A deployment file tree entry'),
) as unknown as ToZod<ListDeploymentFiles200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const listDeploymentFiles400Schema = z.unknown() as unknown as ToZod<ListDeploymentFiles400>

export const listDeploymentFiles401Schema = z.unknown() as unknown as ToZod<ListDeploymentFiles401>

/**
 * @description You do not have permission to access this resource.
 */
export const listDeploymentFiles403Schema = z.unknown() as unknown as ToZod<ListDeploymentFiles403>

/**
 * @description File tree not found\nDeployment not found
 */
export const listDeploymentFiles404Schema = z.unknown() as unknown as ToZod<ListDeploymentFiles404>

export const listDeploymentFilesQueryResponseSchema = z.lazy(() => listDeploymentFiles200Schema) as unknown as ToZod<ListDeploymentFilesQueryResponse>

export const getDeploymentFileContentsPathParamsSchema = z.object({
  id: z.string().describe('The unique deployment identifier'),
  fileId: z.string().describe('The unique file identifier'),
}) as unknown as ToZod<GetDeploymentFileContentsPathParams>

export const getDeploymentFileContentsQueryParamsSchema = z
  .object({
    path: z.string().describe('Path to the file to fetch (only for Git deployments)').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetDeploymentFileContentsQueryParams>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getDeploymentFileContents400Schema = z.unknown() as unknown as ToZod<GetDeploymentFileContents400>

export const getDeploymentFileContents401Schema = z.unknown() as unknown as ToZod<GetDeploymentFileContents401>

/**
 * @description You do not have permission to access this resource.
 */
export const getDeploymentFileContents403Schema = z.unknown() as unknown as ToZod<GetDeploymentFileContents403>

/**
 * @description File not found\nDeployment not found
 */
export const getDeploymentFileContents404Schema = z.unknown() as unknown as ToZod<GetDeploymentFileContents404>

/**
 * @description Invalid API version.
 */
export const getDeploymentFileContents410Schema = z.unknown() as unknown as ToZod<GetDeploymentFileContents410>

export const getDeploymentFileContentsQueryResponseSchema = z.unknown() as unknown as ToZod<GetDeploymentFileContentsQueryResponse>

export const getDeploymentsQueryParamsSchema = z
  .object({
    app: z.string().describe('Name of the deployment.').optional(),
    from: z.coerce.number().describe('Gets the deployment created after this Date timestamp. (default: current time)').optional(),
    limit: z.coerce.number().describe('Maximum number of deployments to list from a request.').optional(),
    projectId: z.string().describe('Filter deployments from the given ID or name.').optional(),
    target: z.string().describe('Filter deployments based on the environment.').optional(),
    to: z.coerce.number().describe('Gets the deployment created before this Date timestamp. (default: current time)').optional(),
    users: z.string().describe('Filter out deployments based on users who have created the deployment.').optional(),
    since: z.coerce.number().describe('Get Deployments created after this JavaScript timestamp.').optional(),
    until: z.coerce.number().describe('Get Deployments created before this JavaScript timestamp.').optional(),
    state: z.string().describe('Filter deployments based on their state (`BUILDING`, `ERROR`, `INITIALIZING`, `QUEUED`, `READY`, `CANCELED`)').optional(),
    rollbackCandidate: z.boolean().describe('Filter deployments based on their rollback candidacy').optional(),
    branch: z.string().describe('Filter deployments based on the branch name').optional(),
    sha: z.string().describe('Filter deployments based on the SHA').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetDeploymentsQueryParams>

export const getDeployments200Schema = z.object({
  pagination: z
    .lazy(() => paginationSchema)
    .describe(
      'This object contains information related to the pagination of the current request, including the necessary parameters to get the next or previous page of data.',
    ),
  deployments: z.array(
    z.object({
      uid: z.string().describe('The unique identifier of the deployment.'),
      name: z.string().describe('The name of the deployment.'),
      projectId: z.string().describe('The project ID of the deployment'),
      url: z.string().describe('The URL of the deployment.'),
      created: z.number().describe('Timestamp of when the deployment got created.'),
      defaultRoute: z.string().describe('The default route that should be used for screenshots and links if configured with microfrontends.').optional(),
      deleted: z.number().describe('Timestamp of when the deployment got deleted.').optional(),
      undeleted: z.number().describe('Timestamp of when the deployment was undeleted.').optional(),
      softDeletedByRetention: z.boolean().describe('Optional flag to indicate if the deployment was soft deleted by retention policy.').optional(),
      source: z
        .enum(['api-trigger-git-deploy', 'cli', 'clone/repo', 'git', 'import', 'import/repo', 'redeploy', 'v0-web'])
        .describe('The source of the deployment.')
        .optional(),
      state: z.enum(['BUILDING', 'CANCELED', 'DELETED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY']).describe('In which state is the deployment.').optional(),
      readyState: z
        .enum(['BUILDING', 'CANCELED', 'DELETED', 'ERROR', 'INITIALIZING', 'QUEUED', 'READY'])
        .describe('In which state is the deployment.')
        .optional(),
      type: z.enum(['LAMBDAS']).describe('The type of the deployment.'),
      creator: z
        .object({
          uid: z.string().describe('The unique identifier of the user.'),
          email: z.string().describe('The email address of the user.').optional(),
          username: z.string().describe('The username of the user.').optional(),
          githubLogin: z.string().describe('The GitHub login of the user.').optional(),
          gitlabLogin: z.string().describe('The GitLab login of the user.').optional(),
        })
        .describe('Metadata information of the user who created the deployment.'),
      meta: z
        .object({})
        .catchall(z.string().describe('Metadata information from the Git provider.'))
        .describe('Metadata information from the Git provider.')
        .optional(),
      target: z.enum(['production', 'staging']).describe('On which environment has the deployment been deployed to.').nullable().nullish(),
      aliasError: z
        .object({
          code: z.string(),
          message: z.string(),
        })
        .describe('An error object in case aliasing of the deployment failed.')
        .nullable()
        .nullish(),
      aliasAssigned: z.union([z.boolean(), z.number()]).nullable().nullish(),
      createdAt: z.number().describe('Timestamp of when the deployment got created.').optional(),
      buildingAt: z.number().describe('Timestamp of when the deployment started building at.').optional(),
      ready: z.number().describe('Timestamp of when the deployment got ready.').optional(),
      readySubstate: z
        .enum(['PROMOTED', 'ROLLING', 'STAGED'])
        .describe(
          "Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - ROLLING: in the process of gradually transitioning production traffic - PROMOTED: has seen production traffic",
        )
        .optional(),
      checksState: z.enum(['completed', 'registered', 'running']).describe('State of all registered checks').optional(),
      checksConclusion: z.enum(['canceled', 'failed', 'skipped', 'succeeded']).describe('Conclusion for checks').optional(),
      checks: z
        .object({
          'deployment-alias': z
            .object({
              state: z.enum(['failed', 'pending', 'succeeded']),
              startedAt: z.number(),
              completedAt: z.number().optional(),
            })
            .describe('Detailed information about v2 deployment checks. Includes information about blocked workflows in the deployment lifecycle.'),
        })
        .describe('Detailed information about v2 deployment checks. Includes information about blocked workflows in the deployment lifecycle.')
        .optional(),
      inspectorUrl: z.string().describe('Vercel URL to inspect the deployment.').nullable(),
      isRollbackCandidate: z.boolean().describe('Deployment can be used for instant rollback').nullable().nullish(),
      projectSettings: z
        .object({
          framework: z
            .enum([
              'angular',
              'astro',
              'blitzjs',
              'brunch',
              'create-react-app',
              'docusaurus',
              'docusaurus-2',
              'dojo',
              'eleventy',
              'ember',
              'fasthtml',
              'gatsby',
              'gridsome',
              'hexo',
              'hugo',
              'hydrogen',
              'ionic-angular',
              'ionic-react',
              'jekyll',
              'middleman',
              'nextjs',
              'nitro',
              'nuxtjs',
              'parcel',
              'polymer',
              'preact',
              'react-router',
              'redwoodjs',
              'remix',
              'saber',
              'sanity',
              'sanity-v3',
              'sapper',
              'scully',
              'solidstart',
              'solidstart-1',
              'stencil',
              'storybook',
              'svelte',
              'sveltekit',
              'sveltekit-1',
              'umijs',
              'vite',
              'vitepress',
              'vue',
              'vuepress',
              'zola',
            ])
            .nullable()
            .nullish(),
          gitForkProtection: z.boolean().optional(),
          customerSupportCodeVisibility: z.boolean().optional(),
          gitLFS: z.boolean().optional(),
          devCommand: z.string().nullable().nullish(),
          installCommand: z.string().nullable().nullish(),
          buildCommand: z.string().nullable().nullish(),
          nodeVersion: z.enum(['10.x', '12.x', '14.x', '16.x', '18.x', '20.x', '22.x', '8.10.x']).optional(),
          outputDirectory: z.string().nullable().nullish(),
          publicSource: z.boolean().nullable().nullish(),
          rootDirectory: z.string().nullable().nullish(),
          sourceFilesOutsideRootDirectory: z.boolean().optional(),
          commandForIgnoringBuildStep: z.string().nullable().nullish(),
          createdAt: z.number().optional(),
          speedInsights: z
            .object({
              id: z.string(),
              enabledAt: z.number().optional(),
              disabledAt: z.number().optional(),
              canceledAt: z.number().optional(),
              hasData: z.boolean().optional(),
              paidAt: z.number().optional(),
            })
            .optional(),
          webAnalytics: z
            .object({
              id: z.string(),
              disabledAt: z.number().optional(),
              canceledAt: z.number().optional(),
              enabledAt: z.number().optional(),
              hasData: z.boolean().optional(),
            })
            .optional(),
          skipGitConnectDuringLink: z.boolean().optional(),
          gitComments: z
            .object({
              onPullRequest: z.boolean().describe('Whether the Vercel bot should comment on PRs'),
              onCommit: z.boolean().describe('Whether the Vercel bot should comment on commits'),
            })
            .describe("Since June '23")
            .optional(),
        })
        .describe('The project settings which was used for this deployment')
        .optional(),
      connectBuildsEnabled: z.boolean().describe('The flag saying if Secure Compute network is used for builds').optional(),
      connectConfigurationId: z.string().describe('The ID of Secure Compute network used for this deployment').optional(),
      passiveConnectConfigurationId: z.string().describe("The ID of Secure Compute network used for this deployment's passive functions").optional(),
      expiration: z.number().describe('The expiration configured by the project retention policy').optional(),
      proposedExpiration: z.number().describe('The expiration proposed to replace the existing expiration').optional(),
      customEnvironment: z
        .object({
          id: z.string(),
          slug: z.string().optional(),
        })
        .describe('The custom environment used for this deployment, if any')
        .optional(),
    }),
  ),
}) as unknown as ToZod<GetDeployments200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getDeployments400Schema = z.unknown() as unknown as ToZod<GetDeployments400>

export const getDeployments401Schema = z.unknown() as unknown as ToZod<GetDeployments401>

/**
 * @description You do not have permission to access this resource.
 */
export const getDeployments403Schema = z.unknown() as unknown as ToZod<GetDeployments403>

export const getDeployments404Schema = z.unknown() as unknown as ToZod<GetDeployments404>

export const getDeployments422Schema = z.unknown() as unknown as ToZod<GetDeployments422>

export const getDeploymentsQueryResponseSchema = z.lazy(() => getDeployments200Schema) as unknown as ToZod<GetDeploymentsQueryResponse>

export const deleteDeploymentPathParamsSchema = z.object({
  id: z.string().describe('The ID of the deployment to be deleted'),
}) as unknown as ToZod<DeleteDeploymentPathParams>

export const deleteDeploymentQueryParamsSchema = z
  .object({
    url: z.string().describe('A Deployment or Alias URL. In case it is passed, the ID will be ignored').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<DeleteDeploymentQueryParams>

/**
 * @description The deployment was successfully deleted
 */
export const deleteDeployment200Schema = z.object({
  uid: z.string().describe('The removed deployment ID.'),
  state: z.enum(['DELETED']).describe('A constant with the final state of the deployment.'),
}) as unknown as ToZod<DeleteDeployment200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const deleteDeployment400Schema = z.unknown() as unknown as ToZod<DeleteDeployment400>

export const deleteDeployment401Schema = z.unknown() as unknown as ToZod<DeleteDeployment401>

/**
 * @description You do not have permission to access this resource.
 */
export const deleteDeployment403Schema = z.unknown() as unknown as ToZod<DeleteDeployment403>

/**
 * @description The deployment was not found
 */
export const deleteDeployment404Schema = z.unknown() as unknown as ToZod<DeleteDeployment404>

export const deleteDeploymentMutationResponseSchema = z.lazy(() => deleteDeployment200Schema) as unknown as ToZod<DeleteDeploymentMutationResponse>

export const getSecretsQueryParamsSchema = z
  .object({
    id: z.string().describe('Filter out secrets based on comma separated secret ids.').optional(),
    projectId: z.string().describe('Filter out secrets that belong to a project.').optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetSecretsQueryParams>

/**
 * @description Successful response retrieving a list of secrets.
 */
export const getSecrets200Schema = z.object({
  secrets: z.array(
    z
      .object({
        created: z.date().describe('The date when the secret was created.'),
        name: z.string().describe('The name of the secret.'),
        teamId: z.string().describe('The unique identifier of the team the secret was created for.').nullable().nullish(),
        uid: z.string().describe('The unique identifier of the secret.'),
        userId: z.string().describe('The unique identifier of the user who created the secret.').optional(),
        value: z.string().describe('The value of the secret.').optional(),
        createdAt: z.number().describe('Timestamp for when the secret was created.').optional(),
        projectId: z.string().describe('The unique identifier of the project which the secret belongs to.').optional(),
        decryptable: z.boolean().describe('Indicates whether the secret value can be decrypted after it has been created.').optional(),
      })
      .describe('Data representing a secret.'),
  ),
  pagination: z
    .lazy(() => paginationSchema)
    .describe(
      'This object contains information related to the pagination of the current request, including the necessary parameters to get the next or previous page of data.',
    ),
}) as unknown as ToZod<GetSecrets200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getSecrets400Schema = z.unknown() as unknown as ToZod<GetSecrets400>

export const getSecrets401Schema = z.unknown() as unknown as ToZod<GetSecrets401>

/**
 * @description You do not have permission to access this resource.
 */
export const getSecrets403Schema = z.unknown() as unknown as ToZod<GetSecrets403>

export const getSecrets410Schema = z.unknown() as unknown as ToZod<GetSecrets410>

export const getSecretsQueryResponseSchema = z.lazy(() => getSecrets200Schema) as unknown as ToZod<GetSecretsQueryResponse>

export const createSecretQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<CreateSecretQueryParams>

/**
 * @description Successful response showing the created secret.
 */
export const createSecret200Schema = z.object({
  value: z.object({
    type: z.enum(['Buffer']).optional(),
    data: z.array(z.number()).optional(),
  }),
  created: z.date().describe('The date when the secret was created.'),
  name: z.string().describe('The name of the secret.'),
  teamId: z.string().describe('The unique identifier of the team the secret was created for.').nullable().nullish(),
  uid: z.string().describe('The unique identifier of the secret.'),
  userId: z.string().describe('The unique identifier of the user who created the secret.').optional(),
  createdAt: z.number().describe('Timestamp for when the secret was created.').optional(),
  projectId: z.string().describe('The unique identifier of the project which the secret belongs to.').optional(),
  decryptable: z.boolean().describe('Indicates whether the secret value can be decrypted after it has been created.').optional(),
}) as unknown as ToZod<CreateSecret200>

/**
 * @description One of the provided values in the request body is invalid.
 */
export const createSecret400Schema = z.unknown() as unknown as ToZod<CreateSecret400>

export const createSecret401Schema = z.unknown() as unknown as ToZod<CreateSecret401>

/**
 * @description The account was soft-blocked for an unhandled reason.\nThe account is missing a payment so payment method must be updated
 */
export const createSecret402Schema = z.unknown() as unknown as ToZod<CreateSecret402>

/**
 * @description You do not have permission to access this resource.
 */
export const createSecret403Schema = z.unknown() as unknown as ToZod<CreateSecret403>

export const createSecret410Schema = z.unknown() as unknown as ToZod<CreateSecret410>

export const createSecretMutationRequestSchema = z.object({
  name: z.string().max(100).describe('The name of the secret (max 100 characters).'),
  value: z.string().describe('The value of the new secret.'),
  decryptable: z.boolean().describe('Whether the secret value can be decrypted after it has been created.').optional(),
  projectId: z.string().describe('Associate a secret to a project.').optional(),
}) as unknown as ToZod<CreateSecretMutationRequest>

export const createSecretMutationResponseSchema = z.lazy(() => createSecret200Schema) as unknown as ToZod<CreateSecretMutationResponse>

export const renameSecretPathParamsSchema = z.object({
  name: z.string().describe('The name of the secret.'),
}) as unknown as ToZod<RenameSecretPathParams>

export const renameSecretQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<RenameSecretQueryParams>

export const renameSecret200Schema = z.object({
  uid: z.string(),
  name: z.string(),
  created: z.date(),
  oldName: z.string(),
}) as unknown as ToZod<RenameSecret200>

/**
 * @description One of the provided values in the request body is invalid.\nOne of the provided values in the request query is invalid.
 */
export const renameSecret400Schema = z.unknown() as unknown as ToZod<RenameSecret400>

export const renameSecret401Schema = z.unknown() as unknown as ToZod<RenameSecret401>

/**
 * @description You do not have permission to access this resource.
 */
export const renameSecret403Schema = z.unknown() as unknown as ToZod<RenameSecret403>

export const renameSecret410Schema = z.unknown() as unknown as ToZod<RenameSecret410>

export const renameSecretMutationRequestSchema = z.object({
  name: z.string().max(100).describe('The name of the new secret.'),
}) as unknown as ToZod<RenameSecretMutationRequest>

export const renameSecretMutationResponseSchema = z.lazy(() => renameSecret200Schema) as unknown as ToZod<RenameSecretMutationResponse>

export const getSecretPathParamsSchema = z.object({
  idOrName: z.string().describe('The name or the unique identifier to which the secret belongs to.'),
}) as unknown as ToZod<GetSecretPathParams>

export const getSecretQueryParamsSchema = z
  .object({
    decrypt: z
      .enum(['true', 'false'])
      .describe('Whether to try to decrypt the value of the secret. Only works if `decryptable` has been set to `true` when the secret was created.')
      .optional(),
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<GetSecretQueryParams>

/**
 * @description Successful response retrieving a secret.
 */
export const getSecret200Schema = z
  .object({
    created: z.date().describe('The date when the secret was created.'),
    name: z.string().describe('The name of the secret.'),
    teamId: z.string().describe('The unique identifier of the team the secret was created for.').nullable().nullish(),
    uid: z.string().describe('The unique identifier of the secret.'),
    userId: z.string().describe('The unique identifier of the user who created the secret.').optional(),
    value: z.string().describe('The value of the secret.').optional(),
    createdAt: z.number().describe('Timestamp for when the secret was created.').optional(),
    projectId: z.string().describe('The unique identifier of the project which the secret belongs to.').optional(),
    decryptable: z.boolean().describe('Indicates whether the secret value can be decrypted after it has been created.').optional(),
  })
  .describe('Data representing a secret.') as unknown as ToZod<GetSecret200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const getSecret400Schema = z.unknown() as unknown as ToZod<GetSecret400>

export const getSecret401Schema = z.unknown() as unknown as ToZod<GetSecret401>

/**
 * @description You do not have permission to access this resource.
 */
export const getSecret403Schema = z.unknown() as unknown as ToZod<GetSecret403>

export const getSecret404Schema = z.unknown() as unknown as ToZod<GetSecret404>

export const getSecret410Schema = z.unknown() as unknown as ToZod<GetSecret410>

export const getSecretQueryResponseSchema = z.lazy(() => getSecret200Schema) as unknown as ToZod<GetSecretQueryResponse>

export const deleteSecretPathParamsSchema = z.object({
  idOrName: z.string().describe('The name or the unique identifier to which the secret belongs to.'),
}) as unknown as ToZod<DeleteSecretPathParams>

export const deleteSecretQueryParamsSchema = z
  .object({
    teamId: z.string().describe('The Team identifier to perform the request on behalf of.').optional(),
    slug: z.string().describe('The Team slug to perform the request on behalf of.').optional(),
  })
  .optional() as unknown as ToZod<DeleteSecretQueryParams>

export const deleteSecret200Schema = z.object({
  uid: z.string().describe('The unique identifier of the deleted secret.'),
  name: z.string().describe('The name of the deleted secret.'),
  created: z.number().describe('The date when the secret was created.'),
}) as unknown as ToZod<DeleteSecret200>

/**
 * @description One of the provided values in the request query is invalid.
 */
export const deleteSecret400Schema = z.unknown() as unknown as ToZod<DeleteSecret400>

export const deleteSecret401Schema = z.unknown() as unknown as ToZod<DeleteSecret401>

/**
 * @description You do not have permission to access this resource.
 */
export const deleteSecret403Schema = z.unknown() as unknown as ToZod<DeleteSecret403>

export const deleteSecret410Schema = z.unknown() as unknown as ToZod<DeleteSecret410>

export const deleteSecretMutationResponseSchema = z.lazy(() => deleteSecret200Schema) as unknown as ToZod<DeleteSecretMutationResponse>