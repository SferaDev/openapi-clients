/**
 * Generated by @openapi-codegen
 *
 * @version 0.0.1
 */
import type * as Fetcher from './fetcher';
import { fetch, FetcherExtraProps } from './fetcher';
import type * as Schemas from './schemas';

export type RecordEventsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type RecordEventsError = Fetcher.ErrorWrapper<undefined>;

export type RecordEventsVariables = {
  queryParams?: RecordEventsQueryParams;
} & FetcherExtraProps;

/**
 * Records an artifacts cache usage event. The body of this request is an array of cache usage events. The supported event types are `HIT` and `MISS`. The source is either `LOCAL` the cache event was on the users filesystem cache or `REMOTE` if the cache event is for a remote cache. When the event is a `HIT` the request also accepts a number `duration` which is the time taken to generate the artifact in the cache.
 */
export const recordEvents = (variables: RecordEventsVariables, signal?: AbortSignal) =>
  fetch<undefined, RecordEventsError, undefined, {}, RecordEventsQueryParams, {}>({
    url: '/v8/artifacts/events',
    method: 'post',
    ...variables,
    signal
  });

export type StatusQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type StatusError = Fetcher.ErrorWrapper<undefined>;

export type StatusVariables = {
  queryParams?: StatusQueryParams;
} & FetcherExtraProps;

/**
 * Check the status of Remote Caching for this principal. Returns a JSON-encoded status indicating if Remote Caching is enabled, disabled, or disabled due to usage limits.
 */
export const status = (variables: StatusVariables, signal?: AbortSignal) =>
  fetch<undefined, StatusError, undefined, {}, StatusQueryParams, {}>({
    url: '/v8/artifacts/status',
    method: 'get',
    ...variables,
    signal
  });

export type UploadArtifactQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type UploadArtifactError = Fetcher.ErrorWrapper<undefined>;

export type UploadArtifactVariables = {
  body?: Blob;
  queryParams?: UploadArtifactQueryParams;
} & FetcherExtraProps;

/**
 * Uploads a cache artifact identified by the `hash` specified on the path. The cache artifact can then be downloaded with the provided `hash`.
 */
export const uploadArtifact = (variables: UploadArtifactVariables, signal?: AbortSignal) =>
  fetch<undefined, UploadArtifactError, Blob, {}, UploadArtifactQueryParams, {}>({
    url: '/v8/artifacts/{hash}',
    method: 'put',
    ...variables,
    signal
  });

export type DownloadArtifactQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DownloadArtifactError = Fetcher.ErrorWrapper<undefined>;

export type DownloadArtifactVariables = {
  queryParams?: DownloadArtifactQueryParams;
} & FetcherExtraProps;

/**
 * Downloads a cache artifact indentified by its `hash` specified on the request path. The artifact is downloaded as an octet-stream. The client should verify the content-length header and response body.
 */
export const downloadArtifact = (variables: DownloadArtifactVariables, signal?: AbortSignal) =>
  fetch<undefined, DownloadArtifactError, undefined, {}, DownloadArtifactQueryParams, {}>({
    url: '/v8/artifacts/{hash}',
    method: 'get',
    ...variables,
    signal
  });

export type ArtifactQueryQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type ArtifactQueryError = Fetcher.ErrorWrapper<undefined>;

export type ArtifactQueryVariables = {
  queryParams?: ArtifactQueryQueryParams;
} & FetcherExtraProps;

/**
 * Query information about an array of artifacts.
 */
export const artifactQuery = (variables: ArtifactQueryVariables, signal?: AbortSignal) =>
  fetch<undefined, ArtifactQueryError, undefined, {}, ArtifactQueryQueryParams, {}>({
    url: '/v8/artifacts',
    method: 'post',
    ...variables,
    signal
  });

export type GetDeploymentQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetDeploymentError = Fetcher.ErrorWrapper<undefined>;

export type GetDeploymentVariables = {
  queryParams?: GetDeploymentQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves information for a deployment either by supplying its ID (`id` property) or Hostname (`url` property). Additional details will be included when the authenticated user is an owner of the deployment.
 */
export const getDeployment = (variables: GetDeploymentVariables, signal?: AbortSignal) =>
  fetch<
    | {
        aliasAssignedAt?: number | boolean | null;
        build: {
          /**
           * The keys of the environment variables that were assigned during the build phase.
           *
           * @example MY_ENV_VAR
           */
          env: string[];
        };
        builds?: Record<string, any>[];
        /**
         * The ID of Vercel Connect configuration used for this deployment
         */
        connectConfigurationId?: string;
        /**
         * The region where the deployment was first created
         *
         * @example sfo1
         */
        createdIn: string;
        /**
         * The keys of the environment variables that were assigned during runtime
         *
         * @example MY_SECRET
         */
        env: string[];
        /**
         * An object used to configure your Serverless Functions
         *
         * @example {"api/test.js":{"memory":3008}}
         */
        functions?: {
          [key: string]: {
            memory?: number;
            maxDuration?: number;
            runtime?: string;
            includeFiles?: string;
            excludeFiles?: string;
          };
        } | null;
        /**
         * Vercel URL to inspect the deployment.
         *
         * @example https://vercel.com/acme/nextjs/J1hXN00qjUeoYfpEEf7dnDtpSiVq
         */
        inspectorUrl: string | null;
        /**
         * Is the deployment currently queued waiting for a Concurrent Build Slot to be available
         *
         * @example false
         */
        isInConcurrentBuildsQueue: boolean;
        /**
         * An object containing the deployment's metadata
         *
         * @example {"foo":"bar"}
         */
        meta: {
          [key: string]: string;
        };
        /**
         * An monorepo manager that was used for the deployment
         *
         * @example turbo
         */
        monorepoManager?: string | null;
        /**
         * The name of the project associated with the deployment at the time that the deployment was created
         *
         * @example my-project
         */
        name: string;
        /**
         * The unique ID of the user or team the deployment belongs to
         *
         * @example ZspSRT4ljIEEmMHgoDwKWDei
         */
        ownerId: string;
        /**
         * The pricing plan the deployment was made under
         *
         * @example pro
         */
        plan: 'hobby' | 'enterprise' | 'pro' | 'oss';
        /**
         * The ID of the project the deployment is associated with
         *
         * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
         */
        projectId: string;
        /**
         * A list of routes objects used to rewrite paths to point towards other internal or external paths
         *
         * @example {"src":"/docs","dest":"https://docs.example.com"}
         */
        routes:
          | (
              | {
                  src: string;
                  dest?: string;
                  headers?: {
                    [key: string]: string;
                  };
                  methods?: string[];
                  ['continue']?: boolean;
                  override?: boolean;
                  caseSensitive?: boolean;
                  check?: boolean;
                  important?: boolean;
                  status?: number;
                  has?: (
                    | {
                        type: 'host';
                        value: string;
                      }
                    | {
                        type: 'header' | 'cookie' | 'query';
                        key: string;
                        value?: string;
                      }
                  )[];
                  missing?: (
                    | {
                        type: 'host';
                        value: string;
                      }
                    | {
                        type: 'header' | 'cookie' | 'query';
                        key: string;
                        value?: string;
                      }
                  )[];
                  locale?: {
                    /**
                     * Construct a type with a set of properties K of type T
                     */
                    redirect?: {
                      [key: string]: string;
                    };
                    cookie?: string;
                  };
                  /**
                   * A middleware key within the `output` key under the build result. Overrides a `middleware` definition.
                   */
                  middlewarePath?: string;
                  /**
                   * The original middleware matchers.
                   */
                  middlewareRawSrc?: string[];
                  /**
                   * A middleware index in the `middleware` key under the build result
                   */
                  middleware?: number;
                }
              | {
                  handle: 'filesystem' | 'hit' | 'miss' | 'rewrite' | 'error' | 'resource';
                  src?: string;
                  dest?: string;
                  status?: number;
                }
              | {
                  src: string;
                  ['continue']: boolean;
                  middleware: 0;
                }
            )[]
          | null;
        gitRepo?:
          | {
              namespace: string;
              projectId: number;
              type: 'gitlab';
              url: string;
              path: string;
              defaultBranch: string;
              name: string;
              private: boolean;
              ownerType: 'team' | 'user';
            }
          | {
              org: string;
              repo: string;
              repoId: number;
              type: 'github';
              repoOwnerId: string;
              path: string;
              defaultBranch: string;
              name: string;
              private: boolean;
              ownerType: 'team' | 'user';
            }
          | {
              owner: string;
              repoUuid: string;
              slug: string;
              type: 'bitbucket';
              workspaceUuid: string;
              path: string;
              defaultBranch: string;
              name: string;
              private: boolean;
              ownerType: 'team' | 'user';
            }
          | null;
        /**
         * A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation
         */
        alias: string[];
        /**
         * A boolean that will be true when the aliases from the alias property were assigned successfully
         *
         * @example true
         */
        aliasAssigned: boolean;
        /**
         * An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null`
         *
         * @example null
         */
        aliasError?: {
          code: string;
          message: string;
        } | null;
        aliasFinal?: string | null;
        aliasWarning?: {
          code: string;
          message: string;
          link?: string;
          action?: string;
        } | null;
        automaticAliases?: string[];
        bootedAt: number;
        buildErrorAt?: number;
        buildingAt: number;
        canceledAt?: number;
        checksState?: 'registered' | 'running' | 'completed';
        checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
        /**
         * A number containing the date when the deployment was created in milliseconds
         *
         * @example 1540257589405
         */
        createdAt: number;
        /**
         * Information about the deployment creator
         */
        creator: {
          /**
           * The ID of the user that created the deployment
           *
           * @example 96SnxkFiMyVKsK3pnoHfx3Hz
           */
          uid: string;
          /**
           * The username of the user that created the deployment
           *
           * @example john-doe
           */
          username?: string;
        };
        errorCode?: string;
        errorLink?: string;
        errorMessage?: string | null;
        errorStep?: string;
        gitSource?:
          | {
              type: 'github';
              repoId: string | number;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'github';
              org: string;
              repo: string;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'gitlab';
              projectId: string | number;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'bitbucket';
              workspaceUuid?: string;
              repoUuid: string;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'bitbucket';
              owner: string;
              slug: string;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'custom';
              ref: string;
              sha: string;
              gitUrl: string;
            }
          | {
              type: 'github';
              ref: string;
              sha: string;
              repoId: number;
              org?: string;
              repo?: string;
            }
          | {
              type: 'gitlab';
              ref: string;
              sha: string;
              projectId: number;
            }
          | {
              type: 'bitbucket';
              ref: string;
              sha: string;
              owner?: string;
              slug?: string;
              workspaceUuid: string;
              repoUuid: string;
            };
        /**
         * A string holding the unique ID of the deployment
         *
         * @example dpl_89qyp1cskzkLrVicDaZoDbjyHuDJ
         */
        id: string;
        lambdas?: {
          id: string;
          createdAt?: number;
          entrypoint?: string | null;
          readyState?: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'READY';
          readyStateAt?: number;
          output: {
            path: string;
            functionName: string;
          }[];
        }[];
        /**
         * A boolean representing if the deployment is public or not. By default this is `false`
         *
         * @example false
         */
        public: boolean;
        /**
         * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
         *
         * @example READY
         */
        readyState: 'QUEUED' | 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'READY' | 'CANCELED';
        /**
         * The regions the deployment exists in
         *
         * @example sfo1
         */
        regions: string[];
        /**
         * Where was the deployment created from
         *
         * @example cli
         */
        source?: 'cli' | 'git' | 'import' | 'import/repo' | 'clone/repo';
        /**
         * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned
         *
         * @example null
         */
        target?: 'production' | 'staging' | null;
        /**
         * The team that owns the deployment if any
         */
        team?: {
          /**
           * The ID of the team owner
           *
           * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
           */
          id: string;
          /**
           * The name of the team owner
           *
           * @example FSociety
           */
          name: string;
          /**
           * The slug of the team owner
           *
           * @example fsociety
           */
          slug: string;
        };
        type: 'LAMBDAS';
        /**
         * A string with the unique URL of the deployment
         *
         * @example my-instant-deployment-3ij3cxz9qr.now.sh
         */
        url: string;
        /**
         * An array of domains that were provided by the user when creating the Deployment.
         *
         * @example sub1.example.com
         * @example sub2.example.com
         */
        userAliases?: string[];
        /**
         * The platform version that was used to create the deployment.
         *
         * @example 2
         */
        version: 2;
        /**
         * Whether or not preview comments are enabled for the deployment
         *
         * @example false
         */
        previewCommentsEnabled?: boolean;
      }
    | {
        /**
         * A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation
         */
        alias: string[];
        /**
         * A boolean that will be true when the aliases from the alias property were assigned successfully
         *
         * @example true
         */
        aliasAssigned: boolean;
        /**
         * An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null`
         *
         * @example null
         */
        aliasError?: {
          code: string;
          message: string;
        } | null;
        aliasFinal?: string | null;
        aliasWarning?: {
          code: string;
          message: string;
          link?: string;
          action?: string;
        } | null;
        automaticAliases?: string[];
        bootedAt: number;
        buildErrorAt?: number;
        buildingAt: number;
        canceledAt?: number;
        checksState?: 'registered' | 'running' | 'completed';
        checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
        /**
         * A number containing the date when the deployment was created in milliseconds
         *
         * @example 1540257589405
         */
        createdAt: number;
        /**
         * Information about the deployment creator
         */
        creator: {
          /**
           * The ID of the user that created the deployment
           *
           * @example 96SnxkFiMyVKsK3pnoHfx3Hz
           */
          uid: string;
          /**
           * The username of the user that created the deployment
           *
           * @example john-doe
           */
          username?: string;
        };
        errorCode?: string;
        errorLink?: string;
        errorMessage?: string | null;
        errorStep?: string;
        gitSource?:
          | {
              type: 'github';
              repoId: string | number;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'github';
              org: string;
              repo: string;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'gitlab';
              projectId: string | number;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'bitbucket';
              workspaceUuid?: string;
              repoUuid: string;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'bitbucket';
              owner: string;
              slug: string;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'custom';
              ref: string;
              sha: string;
              gitUrl: string;
            }
          | {
              type: 'github';
              ref: string;
              sha: string;
              repoId: number;
              org?: string;
              repo?: string;
            }
          | {
              type: 'gitlab';
              ref: string;
              sha: string;
              projectId: number;
            }
          | {
              type: 'bitbucket';
              ref: string;
              sha: string;
              owner?: string;
              slug?: string;
              workspaceUuid: string;
              repoUuid: string;
            };
        /**
         * A string holding the unique ID of the deployment
         *
         * @example dpl_89qyp1cskzkLrVicDaZoDbjyHuDJ
         */
        id: string;
        lambdas?: {
          id: string;
          createdAt?: number;
          entrypoint?: string | null;
          readyState?: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'READY';
          readyStateAt?: number;
          output: {
            path: string;
            functionName: string;
          }[];
        }[];
        /**
         * The name of the project associated with the deployment at the time that the deployment was created
         *
         * @example my-project
         */
        name: string;
        /**
         * An object containing the deployment's metadata
         *
         * @example {"foo":"bar"}
         */
        meta: {
          [key: string]: string;
        };
        /**
         * A boolean representing if the deployment is public or not. By default this is `false`
         *
         * @example false
         */
        public: boolean;
        /**
         * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
         *
         * @example READY
         */
        readyState: 'QUEUED' | 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'READY' | 'CANCELED';
        /**
         * The regions the deployment exists in
         *
         * @example sfo1
         */
        regions: string[];
        /**
         * Where was the deployment created from
         *
         * @example cli
         */
        source?: 'cli' | 'git' | 'import' | 'import/repo' | 'clone/repo';
        /**
         * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned
         *
         * @example null
         */
        target?: 'production' | 'staging' | null;
        /**
         * The team that owns the deployment if any
         */
        team?: {
          /**
           * The ID of the team owner
           *
           * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
           */
          id: string;
          /**
           * The name of the team owner
           *
           * @example FSociety
           */
          name: string;
          /**
           * The slug of the team owner
           *
           * @example fsociety
           */
          slug: string;
        };
        type: 'LAMBDAS';
        /**
         * A string with the unique URL of the deployment
         *
         * @example my-instant-deployment-3ij3cxz9qr.now.sh
         */
        url: string;
        /**
         * An array of domains that were provided by the user when creating the Deployment.
         *
         * @example sub1.example.com
         * @example sub2.example.com
         */
        userAliases?: string[];
        /**
         * The platform version that was used to create the deployment.
         *
         * @example 2
         */
        version: 2;
        /**
         * Whether or not preview comments are enabled for the deployment
         *
         * @example false
         */
        previewCommentsEnabled?: boolean;
      },
    GetDeploymentError,
    undefined,
    {},
    GetDeploymentQueryParams,
    {}
  >({ url: '/v13/deployments/{idOrUrl}', method: 'get', ...variables, signal });

export type CreateDeploymentQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateDeploymentError = Fetcher.ErrorWrapper<undefined>;

export type CreateDeploymentResponse = {
  aliasAssignedAt?: number | boolean | null;
  build: {
    /**
     * The keys of the environment variables that were assigned during the build phase.
     *
     * @example MY_ENV_VAR
     */
    env: string[];
  };
  builds?: {
    use: string;
    src?: string;
    /**
     * An object containing the deployment's metadata
     *
     * @example {"foo":"bar"}
     */
    config?: {
      [key: string]: string;
    };
  }[];
  /**
   * The ID of Vercel Connect configuration used for this deployment
   */
  connectConfigurationId?: string;
  /**
   * The region where the deployment was first created
   *
   * @example sfo1
   */
  createdIn: string;
  /**
   * The keys of the environment variables that were assigned during runtime
   *
   * @example MY_SECRET
   */
  env: string[];
  /**
   * An object used to configure your Serverless Functions
   *
   * @example {"api/test.js":{"memory":3008}}
   */
  functions?: {
    [key: string]: {
      memory?: number;
      maxDuration?: number;
      runtime?: string;
      includeFiles?: string;
      excludeFiles?: string;
    };
  } | null;
  /**
   * Vercel URL to inspect the deployment.
   *
   * @example https://vercel.com/acme/nextjs/J1hXN00qjUeoYfpEEf7dnDtpSiVq
   */
  inspectorUrl: string | null;
  /**
   * Is the deployment currently queued waiting for a Concurrent Build Slot to be available
   *
   * @example false
   */
  isInConcurrentBuildsQueue: boolean;
  /**
   * An object containing the deployment's metadata
   *
   * @example {"foo":"bar"}
   */
  meta: {
    [key: string]: string;
  };
  /**
   * An monorepo manager that was used for the deployment
   *
   * @example turbo
   */
  monorepoManager?: string | null;
  /**
   * The name of the project associated with the deployment at the time that the deployment was created
   *
   * @example my-project
   */
  name: string;
  /**
   * The unique ID of the user or team the deployment belongs to
   *
   * @example ZspSRT4ljIEEmMHgoDwKWDei
   */
  ownerId: string;
  /**
   * The pricing plan the deployment was made under
   *
   * @example pro
   */
  plan: 'hobby' | 'enterprise' | 'pro' | 'oss';
  /**
   * The ID of the project the deployment is associated with
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectId: string;
  /**
   * A list of routes objects used to rewrite paths to point towards other internal or external paths
   *
   * @example {"src":"/docs","dest":"https://docs.example.com"}
   */
  routes:
    | (
        | {
            src: string;
            dest?: string;
            headers?: {
              [key: string]: string;
            };
            methods?: string[];
            ['continue']?: boolean;
            override?: boolean;
            caseSensitive?: boolean;
            check?: boolean;
            important?: boolean;
            status?: number;
            has?: (
              | {
                  type: 'host';
                  value: string;
                }
              | {
                  type: 'header' | 'cookie' | 'query';
                  key: string;
                  value?: string;
                }
            )[];
            missing?: (
              | {
                  type: 'host';
                  value: string;
                }
              | {
                  type: 'header' | 'cookie' | 'query';
                  key: string;
                  value?: string;
                }
            )[];
            locale?: {
              /**
               * Construct a type with a set of properties K of type T
               */
              redirect?: {
                [key: string]: string;
              };
              cookie?: string;
            };
            /**
             * A middleware key within the `output` key under the build result. Overrides a `middleware` definition.
             */
            middlewarePath?: string;
            /**
             * The original middleware matchers.
             */
            middlewareRawSrc?: string[];
            /**
             * A middleware index in the `middleware` key under the build result
             */
            middleware?: number;
          }
        | {
            handle: 'filesystem' | 'hit' | 'miss' | 'rewrite' | 'error' | 'resource';
            src?: string;
            dest?: string;
            status?: number;
          }
        | {
            src: string;
            ['continue']: boolean;
            middleware: 0;
          }
      )[]
    | null;
  gitRepo?:
    | {
        namespace: string;
        projectId: number;
        type: 'gitlab';
        url: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: 'team' | 'user';
      }
    | {
        org: string;
        repo: string;
        repoId: number;
        type: 'github';
        repoOwnerId: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: 'team' | 'user';
      }
    | {
        owner: string;
        repoUuid: string;
        slug: string;
        type: 'bitbucket';
        workspaceUuid: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: 'team' | 'user';
      }
    | null;
  /**
   * A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation
   */
  alias: string[];
  /**
   * A boolean that will be true when the aliases from the alias property were assigned successfully
   *
   * @example true
   */
  aliasAssigned: boolean;
  /**
   * An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null`
   *
   * @example null
   */
  aliasError?: {
    code: string;
    message: string;
  } | null;
  aliasFinal?: string | null;
  aliasWarning?: {
    code: string;
    message: string;
    link?: string;
    action?: string;
  } | null;
  automaticAliases?: string[];
  bootedAt: number;
  buildErrorAt?: number;
  buildingAt: number;
  canceledAt?: number;
  checksState?: 'registered' | 'running' | 'completed';
  checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
  /**
   * A number containing the date when the deployment was created in milliseconds
   *
   * @example 1540257589405
   */
  createdAt: number;
  /**
   * Information about the deployment creator
   */
  creator: {
    /**
     * The ID of the user that created the deployment
     *
     * @example 96SnxkFiMyVKsK3pnoHfx3Hz
     */
    uid: string;
    /**
     * The username of the user that created the deployment
     *
     * @example john-doe
     */
    username?: string;
  };
  errorCode?: string;
  errorLink?: string;
  errorMessage?: string | null;
  errorStep?: string;
  gitSource?:
    | {
        type: 'github';
        repoId: string | number;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'github';
        org: string;
        repo: string;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'gitlab';
        projectId: string | number;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'bitbucket';
        workspaceUuid?: string;
        repoUuid: string;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'bitbucket';
        owner: string;
        slug: string;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'custom';
        ref: string;
        sha: string;
        gitUrl: string;
      }
    | {
        type: 'github';
        ref: string;
        sha: string;
        repoId: number;
        org?: string;
        repo?: string;
      }
    | {
        type: 'gitlab';
        ref: string;
        sha: string;
        projectId: number;
      }
    | {
        type: 'bitbucket';
        ref: string;
        sha: string;
        owner?: string;
        slug?: string;
        workspaceUuid: string;
        repoUuid: string;
      };
  /**
   * A string holding the unique ID of the deployment
   *
   * @example dpl_89qyp1cskzkLrVicDaZoDbjyHuDJ
   */
  id: string;
  lambdas?: {
    id: string;
    createdAt?: number;
    entrypoint?: string | null;
    readyState?: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'READY';
    readyStateAt?: number;
    output: {
      path: string;
      functionName: string;
    }[];
  }[];
  /**
   * A boolean representing if the deployment is public or not. By default this is `false`
   *
   * @example false
   */
  public: boolean;
  /**
   * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
   *
   * @example READY
   */
  readyState: 'QUEUED' | 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'READY' | 'CANCELED';
  /**
   * The regions the deployment exists in
   *
   * @example sfo1
   */
  regions: string[];
  /**
   * Where was the deployment created from
   *
   * @example cli
   */
  source?: 'cli' | 'git' | 'import' | 'import/repo' | 'clone/repo';
  /**
   * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned
   *
   * @example null
   */
  target?: 'production' | 'staging' | null;
  /**
   * The team that owns the deployment if any
   */
  team?: {
    /**
     * The ID of the team owner
     *
     * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
     */
    id: string;
    /**
     * The name of the team owner
     *
     * @example FSociety
     */
    name: string;
    /**
     * The slug of the team owner
     *
     * @example fsociety
     */
    slug: string;
  };
  type: 'LAMBDAS';
  /**
   * A string with the unique URL of the deployment
   *
   * @example my-instant-deployment-3ij3cxz9qr.now.sh
   */
  url: string;
  /**
   * An array of domains that were provided by the user when creating the Deployment.
   *
   * @example sub1.example.com
   * @example sub2.example.com
   */
  userAliases?: string[];
  /**
   * The platform version that was used to create the deployment.
   *
   * @example 2
   */
  version: 2;
  /**
   * Whether or not preview comments are enabled for the deployment
   *
   * @example false
   */
  previewCommentsEnabled?: boolean;
};

export type CreateDeploymentVariables = {
  queryParams?: CreateDeploymentQueryParams;
} & FetcherExtraProps;

/**
 * Create a new deployment with all the required and intended data. If the deployment is not a git deployment, all files must be provided with the request, either referenced or inlined. Additionally, a deployment id can be specified to redeploy a previous deployment.
 */
export const createDeployment = (variables: CreateDeploymentVariables, signal?: AbortSignal) =>
  fetch<CreateDeploymentResponse, CreateDeploymentError, undefined, {}, CreateDeploymentQueryParams, {}>({
    url: '/v13/deployments',
    method: 'post',
    ...variables,
    signal
  });

export type CancelDeploymentQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CancelDeploymentError = Fetcher.ErrorWrapper<undefined>;

export type CancelDeploymentResponse = {
  aliasAssignedAt?: number | boolean | null;
  build: {
    /**
     * The keys of the environment variables that were assigned during the build phase.
     *
     * @example MY_ENV_VAR
     */
    env: string[];
  };
  builds?: {
    use: string;
    src?: string;
    /**
     * An object containing the deployment's metadata
     *
     * @example {"foo":"bar"}
     */
    config?: {
      [key: string]: string;
    };
  }[];
  /**
   * The ID of Vercel Connect configuration used for this deployment
   */
  connectConfigurationId?: string;
  /**
   * The region where the deployment was first created
   *
   * @example sfo1
   */
  createdIn: string;
  /**
   * The keys of the environment variables that were assigned during runtime
   *
   * @example MY_SECRET
   */
  env: string[];
  /**
   * An object used to configure your Serverless Functions
   *
   * @example {"api/test.js":{"memory":3008}}
   */
  functions?: {
    [key: string]: {
      memory?: number;
      maxDuration?: number;
      runtime?: string;
      includeFiles?: string;
      excludeFiles?: string;
    };
  } | null;
  /**
   * Vercel URL to inspect the deployment.
   *
   * @example https://vercel.com/acme/nextjs/J1hXN00qjUeoYfpEEf7dnDtpSiVq
   */
  inspectorUrl: string | null;
  /**
   * Is the deployment currently queued waiting for a Concurrent Build Slot to be available
   *
   * @example false
   */
  isInConcurrentBuildsQueue: boolean;
  /**
   * An object containing the deployment's metadata
   *
   * @example {"foo":"bar"}
   */
  meta: {
    [key: string]: string;
  };
  /**
   * An monorepo manager that was used for the deployment
   *
   * @example turbo
   */
  monorepoManager?: string | null;
  /**
   * The name of the project associated with the deployment at the time that the deployment was created
   *
   * @example my-project
   */
  name: string;
  /**
   * The unique ID of the user or team the deployment belongs to
   *
   * @example ZspSRT4ljIEEmMHgoDwKWDei
   */
  ownerId: string;
  /**
   * The pricing plan the deployment was made under
   *
   * @example pro
   */
  plan: 'hobby' | 'enterprise' | 'pro' | 'oss';
  /**
   * The ID of the project the deployment is associated with
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectId: string;
  /**
   * A list of routes objects used to rewrite paths to point towards other internal or external paths
   *
   * @example {"src":"/docs","dest":"https://docs.example.com"}
   */
  routes:
    | (
        | {
            src: string;
            dest?: string;
            headers?: {
              [key: string]: string;
            };
            methods?: string[];
            ['continue']?: boolean;
            override?: boolean;
            caseSensitive?: boolean;
            check?: boolean;
            important?: boolean;
            status?: number;
            has?: (
              | {
                  type: 'host';
                  value: string;
                }
              | {
                  type: 'header' | 'cookie' | 'query';
                  key: string;
                  value?: string;
                }
            )[];
            missing?: (
              | {
                  type: 'host';
                  value: string;
                }
              | {
                  type: 'header' | 'cookie' | 'query';
                  key: string;
                  value?: string;
                }
            )[];
            locale?: {
              /**
               * Construct a type with a set of properties K of type T
               */
              redirect?: {
                [key: string]: string;
              };
              cookie?: string;
            };
            /**
             * A middleware key within the `output` key under the build result. Overrides a `middleware` definition.
             */
            middlewarePath?: string;
            /**
             * The original middleware matchers.
             */
            middlewareRawSrc?: string[];
            /**
             * A middleware index in the `middleware` key under the build result
             */
            middleware?: number;
          }
        | {
            handle: 'filesystem' | 'hit' | 'miss' | 'rewrite' | 'error' | 'resource';
            src?: string;
            dest?: string;
            status?: number;
          }
        | {
            src: string;
            ['continue']: boolean;
            middleware: 0;
          }
      )[]
    | null;
  gitRepo?:
    | {
        namespace: string;
        projectId: number;
        type: 'gitlab';
        url: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: 'user' | 'team';
      }
    | {
        org: string;
        repo: string;
        repoId: number;
        type: 'github';
        repoOwnerId: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: 'user' | 'team';
      }
    | {
        owner: string;
        repoUuid: string;
        slug: string;
        type: 'bitbucket';
        workspaceUuid: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: 'user' | 'team';
      }
    | null;
  /**
   * A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation
   */
  alias: string[];
  /**
   * A boolean that will be true when the aliases from the alias property were assigned successfully
   *
   * @example true
   */
  aliasAssigned: boolean;
  /**
   * An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null`
   *
   * @example null
   */
  aliasError?: {
    code: string;
    message: string;
  } | null;
  aliasFinal?: string | null;
  aliasWarning?: {
    code: string;
    message: string;
    link?: string;
    action?: string;
  } | null;
  automaticAliases?: string[];
  bootedAt: number;
  buildErrorAt?: number;
  buildingAt: number;
  canceledAt?: number;
  checksState?: 'registered' | 'running' | 'completed';
  checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
  /**
   * A number containing the date when the deployment was created in milliseconds
   *
   * @example 1540257589405
   */
  createdAt: number;
  /**
   * Information about the deployment creator
   */
  creator: {
    /**
     * The ID of the user that created the deployment
     *
     * @example 96SnxkFiMyVKsK3pnoHfx3Hz
     */
    uid: string;
    /**
     * The username of the user that created the deployment
     *
     * @example john-doe
     */
    username?: string;
  };
  errorCode?: string;
  errorLink?: string;
  errorMessage?: string | null;
  errorStep?: string;
  gitSource?:
    | {
        type: 'github';
        repoId: string | number;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'github';
        org: string;
        repo: string;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'gitlab';
        projectId: string | number;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'bitbucket';
        workspaceUuid?: string;
        repoUuid: string;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'bitbucket';
        owner: string;
        slug: string;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'custom';
        ref: string;
        sha: string;
        gitUrl: string;
      }
    | {
        type: 'github';
        ref: string;
        sha: string;
        repoId: number;
        org?: string;
        repo?: string;
      }
    | {
        type: 'gitlab';
        ref: string;
        sha: string;
        projectId: number;
      }
    | {
        type: 'bitbucket';
        ref: string;
        sha: string;
        owner?: string;
        slug?: string;
        workspaceUuid: string;
        repoUuid: string;
      };
  /**
   * A string holding the unique ID of the deployment
   *
   * @example dpl_89qyp1cskzkLrVicDaZoDbjyHuDJ
   */
  id: string;
  lambdas?: {
    id: string;
    createdAt?: number;
    entrypoint?: string | null;
    readyState?: 'INITIALIZING' | 'BUILDING' | 'READY' | 'ERROR';
    readyStateAt?: number;
    output: {
      path: string;
      functionName: string;
    }[];
  }[];
  /**
   * A boolean representing if the deployment is public or not. By default this is `false`
   *
   * @example false
   */
  public: boolean;
  /**
   * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
   *
   * @example READY
   */
  readyState: 'INITIALIZING' | 'BUILDING' | 'READY' | 'ERROR' | 'QUEUED' | 'CANCELED';
  /**
   * The regions the deployment exists in
   *
   * @example sfo1
   */
  regions: string[];
  /**
   * Where was the deployment created from
   *
   * @example cli
   */
  source?: 'cli' | 'git' | 'import' | 'import/repo' | 'clone/repo';
  /**
   * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned
   *
   * @example null
   */
  target?: 'staging' | 'production' | null;
  /**
   * The team that owns the deployment if any
   */
  team?: {
    /**
     * The ID of the team owner
     *
     * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
     */
    id: string;
    /**
     * The name of the team owner
     *
     * @example FSociety
     */
    name: string;
    /**
     * The slug of the team owner
     *
     * @example fsociety
     */
    slug: string;
  };
  type: 'LAMBDAS';
  /**
   * A string with the unique URL of the deployment
   *
   * @example my-instant-deployment-3ij3cxz9qr.now.sh
   */
  url: string;
  /**
   * An array of domains that were provided by the user when creating the Deployment.
   *
   * @example sub1.example.com
   * @example sub2.example.com
   */
  userAliases?: string[];
  /**
   * The platform version that was used to create the deployment.
   *
   * @example 2
   */
  version: 2;
  /**
   * Whether or not preview comments are enabled for the deployment
   *
   * @example false
   */
  previewCommentsEnabled?: boolean;
};

export type CancelDeploymentVariables = {
  queryParams?: CancelDeploymentQueryParams;
} & FetcherExtraProps;

/**
 * This endpoint allows you to cancel a deployment which is currently building, by supplying its `id` in the URL.
 */
export const cancelDeployment = (variables: CancelDeploymentVariables, signal?: AbortSignal) =>
  fetch<CancelDeploymentResponse, CancelDeploymentError, undefined, {}, CancelDeploymentQueryParams, {}>({
    url: '/v12/deployments/{id}/cancel',
    method: 'patch',
    ...variables,
    signal
  });

export type GetCertByIdQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetCertByIdError = Fetcher.ErrorWrapper<undefined>;

export type GetCertByIdResponse = {
  id: string;
  createdAt: number;
  expiresAt: number;
  autoRenew: boolean;
  cns: string[];
};

export type GetCertByIdVariables = {
  queryParams?: GetCertByIdQueryParams;
} & FetcherExtraProps;

/**
 * Get cert by id
 */
export const getCertById = (variables: GetCertByIdVariables, signal?: AbortSignal) =>
  fetch<GetCertByIdResponse, GetCertByIdError, undefined, {}, GetCertByIdQueryParams, {}>({
    url: '/v7/certs/{id}',
    method: 'get',
    ...variables,
    signal
  });

export type RemoveCertQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type RemoveCertError = Fetcher.ErrorWrapper<undefined>;

export type RemoveCertVariables = {
  queryParams?: RemoveCertQueryParams;
} & FetcherExtraProps;

/**
 * Remove cert
 */
export const removeCert = (variables: RemoveCertVariables, signal?: AbortSignal) =>
  fetch<Record<string, any>, RemoveCertError, undefined, {}, RemoveCertQueryParams, {}>({
    url: '/v7/certs/{id}',
    method: 'delete',
    ...variables,
    signal
  });

export type IssueCertQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type IssueCertError = Fetcher.ErrorWrapper<undefined>;

export type IssueCertResponse = {
  id: string;
  createdAt: number;
  expiresAt: number;
  autoRenew: boolean;
  cns: string[];
};

export type IssueCertVariables = {
  queryParams?: IssueCertQueryParams;
} & FetcherExtraProps;

/**
 * Issue a new cert
 */
export const issueCert = (variables: IssueCertVariables, signal?: AbortSignal) =>
  fetch<IssueCertResponse, IssueCertError, undefined, {}, IssueCertQueryParams, {}>({
    url: '/v7/certs',
    method: 'post',
    ...variables,
    signal
  });

export type UploadCertQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type UploadCertError = Fetcher.ErrorWrapper<undefined>;

export type UploadCertResponse = {
  id: string;
  createdAt: number;
  expiresAt: number;
  autoRenew: boolean;
  cns: string[];
};

export type UploadCertVariables = {
  queryParams?: UploadCertQueryParams;
} & FetcherExtraProps;

/**
 * Upload a cert
 */
export const uploadCert = (variables: UploadCertVariables, signal?: AbortSignal) =>
  fetch<UploadCertResponse, UploadCertError, undefined, {}, UploadCertQueryParams, {}>({
    url: '/v7/certs',
    method: 'put',
    ...variables,
    signal
  });

export type GetDeploymentEventsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetDeploymentEventsError = Fetcher.ErrorWrapper<undefined>;

export type GetDeploymentEventsResponse = (
  | {
      type: 'command';
      created: number;
      payload: {
        deploymentId: string;
        text?: string;
        id: string;
        date: number;
        serial: string;
      };
    }
  | {
      type: 'deployment-state';
      created: number;
      payload: {
        deploymentId: string;
        info: {
          type: string;
          name: string;
          entrypoint?: string;
          path?: string;
          step?: string;
        };
        id: string;
        date: number;
        serial: string;
      };
    }
  | {
      type: 'delimiter';
      created: number;
      payload: {
        deploymentId: string;
        info: {
          type: string;
          name: string;
          entrypoint?: string;
          path?: string;
          step?: string;
        };
        id: string;
        date: number;
        serial: string;
      };
    }
  | {
      type: 'exit';
      created: number;
      payload: {
        date: number;
        text?: string;
        id: string;
        deploymentId: string;
        created: number;
        serial: string;
      };
    }
  | {
      type: 'middleware';
      created: number;
      payload: {
        deploymentId: string;
        info: {
          type: string;
          name: string;
          entrypoint?: string;
          path?: string;
          step?: string;
        };
        text?: string;
        id: string;
        date: number;
        serial: string;
        requestId?: string;
      };
    }
  | {
      type:
        | 'command'
        | 'stdout'
        | 'stderr'
        | 'exit'
        | 'deployment-state'
        | 'delimiter'
        | 'middleware'
        | 'middleware-invocation'
        | 'edge-function-invocation'
        | 'fatal';
      created: number;
      payload: {
        deploymentId: string;
        info: {
          type: string;
          name: string;
          entrypoint?: string;
          path?: string;
          step?: string;
        };
        text?: string;
        id: string;
        date: number;
        serial: string;
        statusCode?: number;
        requestId?: string;
      };
    }
)[];

export type GetDeploymentEventsVariables = {
  queryParams?: GetDeploymentEventsQueryParams;
} & FetcherExtraProps;

/**
 * Get the build logs of a deployment by deployment ID and build ID. It can work as an infinite stream of logs or as a JSON endpoint depending on the input parameters.
 */
export const getDeploymentEvents = (variables: GetDeploymentEventsVariables, signal?: AbortSignal) =>
  fetch<GetDeploymentEventsResponse, GetDeploymentEventsError, undefined, {}, GetDeploymentEventsQueryParams, {}>({
    url: '/v2/deployments/{idOrUrl}/events',
    method: 'get',
    ...variables,
    signal
  });

export type ListUserEventsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type ListUserEventsError = Fetcher.ErrorWrapper<undefined>;

export type ListUserEventsResponse = {
  /**
   * Array of events generated by the User.
   */
  events: Schemas.UserEvent[];
};

export type ListUserEventsVariables = {
  queryParams?: ListUserEventsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of "events" generated by the User on Vercel. Events are generated when the User performs a particular action, such as logging in, creating a deployment, and joining a Team (just to name a few). When the `teamId` parameter is supplied, then the events that are returned will be in relation to the Team that was specified.
 */
export const listUserEvents = (variables: ListUserEventsVariables, signal?: AbortSignal) =>
  fetch<ListUserEventsResponse, ListUserEventsError, undefined, {}, ListUserEventsQueryParams, {}>({
    url: '/v3/events',
    method: 'get',
    ...variables,
    signal
  });

export type ListAliasesQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type ListAliasesError = Fetcher.ErrorWrapper<undefined>;

export type ListAliasesResponse = {
  aliases: {
    /**
     * The alias name, it could be a `.vercel.app` subdomain or a custom domain
     *
     * @example my-alias.vercel.app
     */
    alias: string;
    /**
     * The date when the alias was created
     *
     * @format date-time
     * @example 2017-04-26T23:00:34.232Z
     */
    created: string;
    /**
     * The date when the alias was created in milliseconds since the UNIX epoch
     *
     * @example 1540095775941
     */
    createdAt?: number;
    /**
     * Information of the user who created the alias
     */
    creator?: {
      /**
       * ID of the user who created the alias
       *
       * @example 96SnxkFiMyVKsK3pnoHfx3Hz
       */
      uid: string;
      /**
       * Email of the user who created the alias
       *
       * @example john-doe@gmail.com
       */
      email: string;
      /**
       * Username of the user who created the alias
       *
       * @example john-doe
       */
      username: string;
    };
    /**
     * The date when the alias was deleted in milliseconds since the UNIX epoch
     *
     * @example 1540095775941
     */
    deletedAt?: number;
    /**
     * A map with the deployment ID, URL and metadata
     */
    deployment?: {
      /**
       * The deployment unique identifier
       *
       * @example dpl_5m8CQaRBm3FnWRW1od3wKTpaECPx
       */
      id: string;
      /**
       * The deployment unique URL
       *
       * @example my-instant-deployment-3ij3cxz9qr.now.sh
       */
      url: string;
      /**
       * The deployment metadata
       *
       * @example {}
       */
      meta?: string;
    };
    /**
     * The deployment ID
     *
     * @example dpl_5m8CQaRBm3FnWRW1od3wKTpaECPx
     */
    deploymentId: string | null;
    /**
     * The unique identifier of the project
     *
     * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
     */
    projectId: string | null;
    /**
     * Target destination domain for redirect when the alias is a redirect
     */
    redirect?: string | null;
    /**
     * Status code to be used on redirect
     */
    redirectStatusCode?: 301 | 302 | 307 | 308 | null;
    /**
     * The unique identifier of the alias
     */
    uid: string;
    /**
     * The date when the alias was updated in milliseconds since the UNIX epoch
     *
     * @example 1540095775941
     */
    updatedAt?: number;
    /**
     * Construct a type with a set of properties K of type T
     */
    protectionBypass?: {
      [key: string]: string;
    };
  }[];
  pagination: Schemas.Pagination;
};

export type ListAliasesVariables = {
  queryParams?: ListAliasesQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of aliases for the authenticated User or Team. When `domain` is provided, only aliases for that domain will be returned. When `projectId` is provided, it will only return the given project aliases.
 */
export const listAliases = (variables: ListAliasesVariables, signal?: AbortSignal) =>
  fetch<ListAliasesResponse, ListAliasesError, undefined, {}, ListAliasesQueryParams, {}>({
    url: '/v4/aliases',
    method: 'get',
    ...variables,
    signal
  });

export type GetAliasQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetAliasError = Fetcher.ErrorWrapper<undefined>;

export type GetAliasResponse = {
  /**
   * The alias name, it could be a `.vercel.app` subdomain or a custom domain
   *
   * @example my-alias.vercel.app
   */
  alias: string;
  /**
   * The date when the alias was created
   *
   * @format date-time
   * @example 2017-04-26T23:00:34.232Z
   */
  created: string;
  /**
   * The date when the alias was created in milliseconds since the UNIX epoch
   *
   * @example 1540095775941
   */
  createdAt?: number;
  /**
   * Information of the user who created the alias
   */
  creator?: {
    /**
     * ID of the user who created the alias
     *
     * @example 96SnxkFiMyVKsK3pnoHfx3Hz
     */
    uid: string;
    /**
     * Email of the user who created the alias
     *
     * @example john-doe@gmail.com
     */
    email: string;
    /**
     * Username of the user who created the alias
     *
     * @example john-doe
     */
    username: string;
  };
  /**
   * The date when the alias was deleted in milliseconds since the UNIX epoch
   *
   * @example 1540095775941
   */
  deletedAt?: number;
  /**
   * A map with the deployment ID, URL and metadata
   */
  deployment?: {
    /**
     * The deployment unique identifier
     *
     * @example dpl_5m8CQaRBm3FnWRW1od3wKTpaECPx
     */
    id: string;
    /**
     * The deployment unique URL
     *
     * @example my-instant-deployment-3ij3cxz9qr.now.sh
     */
    url: string;
    /**
     * The deployment metadata
     *
     * @example {}
     */
    meta?: string;
  };
  /**
   * The deployment ID
   *
   * @example dpl_5m8CQaRBm3FnWRW1od3wKTpaECPx
   */
  deploymentId: string | null;
  /**
   * The unique identifier of the project
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectId: string | null;
  /**
   * Target destination domain for redirect when the alias is a redirect
   */
  redirect?: string | null;
  /**
   * Status code to be used on redirect
   */
  redirectStatusCode?: 301 | 302 | 307 | 308 | null;
  /**
   * The unique identifier of the alias
   */
  uid: string;
  /**
   * The date when the alias was updated in milliseconds since the UNIX epoch
   *
   * @example 1540095775941
   */
  updatedAt?: number;
  /**
   * Construct a type with a set of properties K of type T
   */
  protectionBypass?: {
    [key: string]: string;
  };
};

export type GetAliasVariables = {
  queryParams?: GetAliasQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves an Alias for the given host name or alias ID.
 */
export const getAlias = (variables: GetAliasVariables, signal?: AbortSignal) =>
  fetch<GetAliasResponse, GetAliasError, undefined, {}, GetAliasQueryParams, {}>({
    url: '/v4/aliases/{idOrAlias}',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteAliasQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteAliasError = Fetcher.ErrorWrapper<undefined>;

export type DeleteAliasResponse = {
  status: 'SUCCESS';
};

export type DeleteAliasVariables = {
  queryParams?: DeleteAliasQueryParams;
} & FetcherExtraProps;

/**
 * Delete an Alias with the specified ID.
 */
export const deleteAlias = (variables: DeleteAliasVariables, signal?: AbortSignal) =>
  fetch<DeleteAliasResponse, DeleteAliasError, undefined, {}, DeleteAliasQueryParams, {}>({
    url: '/v2/aliases/{aliasId}',
    method: 'delete',
    ...variables,
    signal
  });

export type ListDeploymentAliasesQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type ListDeploymentAliasesError = Fetcher.ErrorWrapper<undefined>;

export type ListDeploymentAliasesResponse = {
  /**
   * A list of the aliases assigned to the deployment
   */
  aliases: {
    /**
     * The unique identifier of the alias
     *
     * @example 2WjyKQmM8ZnGcJsPWMrHRHrE
     */
    uid: string;
    /**
     * The alias name, it could be a `.vercel.app` subdomain or a custom domain
     *
     * @example my-alias.vercel.app
     */
    alias: string;
    /**
     * The date when the alias was created
     *
     * @format date-time
     * @example 2017-04-26T23:00:34.232Z
     */
    created: string;
    /**
     * Target destination domain for redirect when the alias is a redirect
     */
    redirect?: string | null;
    /**
     * Construct a type with a set of properties K of type T
     */
    protectionBypass?: {
      [key: string]: string;
    };
  }[];
};

export type ListDeploymentAliasesVariables = {
  queryParams?: ListDeploymentAliasesQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves all Aliases for the Deployment with the given ID. The authenticated User must own the deployment.
 */
export const listDeploymentAliases = (variables: ListDeploymentAliasesVariables, signal?: AbortSignal) =>
  fetch<ListDeploymentAliasesResponse, ListDeploymentAliasesError, undefined, {}, ListDeploymentAliasesQueryParams, {}>(
    { url: '/v2/deployments/{id}/aliases', method: 'get', ...variables, signal }
  );

export type AssignAliasQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type AssignAliasError = Fetcher.ErrorWrapper<undefined>;

export type AssignAliasResponse = {
  /**
   * The unique identifier of the alias
   *
   * @example 2WjyKQmM8ZnGcJsPWMrHRHrE
   */
  uid: string;
  /**
   * The assigned alias name
   *
   * @example my-alias.vercel.app
   */
  alias: string;
  /**
   * The date when the alias was created
   *
   * @format date-time
   * @example 2017-04-26T23:00:34.232Z
   */
  created: string;
  /**
   * The unique identifier of the previously aliased deployment, only received when the alias was used before
   *
   * @example dpl_FjvFJncQHQcZMznrUm9EoB8sFuPa
   */
  oldDeploymentId?: string | null;
};

export type AssignAliasVariables = {
  queryParams?: AssignAliasQueryParams;
} & FetcherExtraProps;

/**
 * Creates a new alias for the deployment with the given deployment ID. The authenticated user must own this deployment. If the desired alias is already assigned to another deployment, then it will be removed from the old deployment and assigned to the new one.
 */
export const assignAlias = (variables: AssignAliasVariables, signal?: AbortSignal) =>
  fetch<AssignAliasResponse, AssignAliasError, undefined, {}, AssignAliasQueryParams, {}>({
    url: '/v2/deployments/{id}/aliases',
    method: 'post',
    ...variables,
    signal
  });

export type UploadFileQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type UploadFileError = Fetcher.ErrorWrapper<undefined>;

export type UploadFileVariables = {
  queryParams?: UploadFileQueryParams;
} & FetcherExtraProps;

/**
 * Before you create a deployment you need to upload the required files for that deployment. To do it, you need to first upload each file to this endpoint. Once that's completed, you can create a new deployment with the uploaded files. The file content must be placed inside the body of the request. In the case of a successful response you'll receive a status code 200 with an empty body.
 */
export const uploadFile = (variables: UploadFileVariables, signal?: AbortSignal) =>
  fetch<
    | {
        /**
         * Array of URLs where the file was updated
         *
         * @example example-upload.aws.com
         */
        urls: string[];
      }
    | Record<string, any>,
    UploadFileError,
    undefined,
    {},
    UploadFileQueryParams,
    {}
  >({ url: '/v2/files', method: 'post', ...variables, signal });

export type GetAuthUserError = Fetcher.ErrorWrapper<undefined>;

export type GetAuthUserResponse = {
  user: Schemas.AuthUser | Schemas.AuthUserLimited;
};

export type GetAuthUserVariables = FetcherExtraProps;

/**
 * Retrieves information related to the currently authenticated User.
 */
export const getAuthUser = (variables: GetAuthUserVariables, signal?: AbortSignal) =>
  fetch<GetAuthUserResponse, GetAuthUserError, undefined, {}, {}, {}>({
    url: '/v2/user',
    method: 'get',
    ...variables,
    signal
  });

export type RequestDeleteError = Fetcher.ErrorWrapper<undefined>;

export type RequestDeleteResponse = {
  /**
   * Unique identifier of the User who has initiated deletion.
   */
  id: string;
  /**
   * Email address of the User who has initiated deletion.
   */
  email: string;
  /**
   * User deletion progress status.
   *
   * @example Verification email sent
   */
  message: string;
};

export type RequestDeleteVariables = FetcherExtraProps;

/**
 * Initiates the deletion process for the currently authenticated User, by sending a deletion confirmation email. The email contains a link that the user needs to visit in order to proceed with the deletion process.
 */
export const requestDelete = (variables: RequestDeleteVariables, signal?: AbortSignal) =>
  fetch<RequestDeleteResponse, RequestDeleteError, undefined, {}, {}, {}>({
    url: '/v1/user',
    method: 'delete',
    ...variables,
    signal
  });

export type ListAuthTokensError = Fetcher.ErrorWrapper<undefined>;

export type ListAuthTokensResponse = {
  tokens: Schemas.AuthToken[];
  testingToken?: Schemas.AuthToken;
  pagination: Schemas.Pagination;
};

export type ListAuthTokensVariables = FetcherExtraProps;

/**
 * Retrieve a list of the current User's authentication tokens.
 */
export const listAuthTokens = (variables: ListAuthTokensVariables, signal?: AbortSignal) =>
  fetch<ListAuthTokensResponse, ListAuthTokensError, undefined, {}, {}, {}>({
    url: '/v5/user/tokens',
    method: 'get',
    ...variables,
    signal
  });

export type CreateAuthTokenQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateAuthTokenError = Fetcher.ErrorWrapper<undefined>;

export type CreateAuthTokenResponse = {
  token: Schemas.AuthToken;
  /**
   * The authentication token's actual value. This token is only provided in this response, and can never be retrieved again in the future. Be sure to save it somewhere safe!
   *
   * @example uRKJSTt0L4RaSkiMj41QTkxM
   */
  bearerToken: string;
};

export type CreateAuthTokenVariables = {
  queryParams?: CreateAuthTokenQueryParams;
} & FetcherExtraProps;

/**
 * Creates and returns a new authentication token for the currently authenticated User. The `bearerToken` property is only provided once, in the response body, so be sure to save it on the client for use with API requests.
 */
export const createAuthToken = (variables: CreateAuthTokenVariables, signal?: AbortSignal) =>
  fetch<CreateAuthTokenResponse, CreateAuthTokenError, undefined, {}, CreateAuthTokenQueryParams, {}>({
    url: '/v3/user/tokens',
    method: 'post',
    ...variables,
    signal
  });

export type GetAuthTokenError = Fetcher.ErrorWrapper<undefined>;

export type GetAuthTokenResponse = {
  token: Schemas.AuthToken;
};

export type GetAuthTokenVariables = FetcherExtraProps;

/**
 * Retrieve metadata about an authentication token belonging to the currently authenticated User.
 */
export const getAuthToken = (variables: GetAuthTokenVariables, signal?: AbortSignal) =>
  fetch<GetAuthTokenResponse, GetAuthTokenError, undefined, {}, {}, {}>({
    url: '/v5/user/tokens/{tokenId}',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteAuthTokenError = Fetcher.ErrorWrapper<undefined>;

export type DeleteAuthTokenResponse = {
  /**
   * The unique identifier of the token that was deleted.
   *
   * @example 5d9f2ebd38ddca62e5d51e9c1704c72530bdc8bfdd41e782a6687c48399e8391
   */
  tokenId: string;
};

export type DeleteAuthTokenVariables = FetcherExtraProps;

/**
 * Invalidate an authentication token, such that it will no longer be valid for future HTTP requests.
 */
export const deleteAuthToken = (variables: DeleteAuthTokenVariables, signal?: AbortSignal) =>
  fetch<DeleteAuthTokenResponse, DeleteAuthTokenError, undefined, {}, {}, {}>({
    url: '/v3/user/tokens/{tokenId}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetRecordsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetRecordsError = Fetcher.ErrorWrapper<undefined>;

export type GetRecordsVariables = {
  queryParams?: GetRecordsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of DNS records created for a domain name. By default it returns 20 records if no limit is provided. The rest can be retrieved using the pagination options.
 */
export const getRecords = (variables: GetRecordsVariables, signal?: AbortSignal) =>
  fetch<
    | string
    | {
        records: {
          id: string;
          slug: string;
          name: string;
          type: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
          value: string;
          mxPriority?: number;
          priority?: number;
          creator: string;
          created: number | null;
          updated: number | null;
          createdAt: number | null;
          updatedAt: number | null;
        }[];
      }
    | {
        records: {
          id: string;
          slug: string;
          name: string;
          type: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
          value: string;
          mxPriority?: number;
          priority?: number;
          creator: string;
          created: number | null;
          updated: number | null;
          createdAt: number | null;
          updatedAt: number | null;
        }[];
        pagination: Schemas.Pagination;
      },
    GetRecordsError,
    undefined,
    {},
    GetRecordsQueryParams,
    {}
  >({ url: '/v4/domains/{domain}/records', method: 'get', ...variables, signal });

export type CreateRecordQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateRecordError = Fetcher.ErrorWrapper<undefined>;

export type CreateRecordVariables = {
  queryParams?: CreateRecordQueryParams;
} & FetcherExtraProps;

/**
 * Creates a DNS record for a domain.
 */
export const createRecord = (variables: CreateRecordVariables, signal?: AbortSignal) =>
  fetch<
    | {
        uid: string;
        updated: number;
      }
    | {
        /**
         * The id of the newly created DNS record
         *
         * @example rec_V0fra8eEgQwEpFhYG2vTzC3K
         */
        uid: string;
      },
    CreateRecordError,
    undefined,
    {},
    CreateRecordQueryParams,
    {}
  >({ url: '/v2/domains/{domain}/records', method: 'post', ...variables, signal });

export type UpdateRecordQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type UpdateRecordError = Fetcher.ErrorWrapper<undefined>;

export type UpdateRecordResponse = {
  createdAt?: number | null;
  creator: string;
  domain: string;
  id: string;
  name: string;
  recordType: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
  ttl?: number;
  type: 'record' | 'record-sys';
  value: string;
};

export type UpdateRecordVariables = {
  queryParams?: UpdateRecordQueryParams;
} & FetcherExtraProps;

/**
 * Updates an existing DNS record for a domain name.
 */
export const updateRecord = (variables: UpdateRecordVariables, signal?: AbortSignal) =>
  fetch<UpdateRecordResponse, UpdateRecordError, undefined, {}, UpdateRecordQueryParams, {}>({
    url: '/v1/domains/records/{recordId}',
    method: 'patch',
    ...variables,
    signal
  });

export type RemoveRecordQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type RemoveRecordError = Fetcher.ErrorWrapper<undefined>;

export type RemoveRecordVariables = {
  queryParams?: RemoveRecordQueryParams;
} & FetcherExtraProps;

/**
 * Removes an existing DNS record from a domain name.
 */
export const removeRecord = (variables: RemoveRecordVariables, signal?: AbortSignal) =>
  fetch<Record<string, any>, RemoveRecordError, undefined, {}, RemoveRecordQueryParams, {}>({
    url: '/v2/domains/{domain}/records/{recordId}',
    method: 'delete',
    ...variables,
    signal
  });

export type CheckDomainStatusQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CheckDomainStatusError = Fetcher.ErrorWrapper<undefined>;

export type CheckDomainStatusResponse = {
  available: boolean;
};

export type CheckDomainStatusVariables = {
  queryParams?: CheckDomainStatusQueryParams;
} & FetcherExtraProps;

/**
 * Check if a domain name is available for purchase.
 */
export const checkDomainStatus = (variables: CheckDomainStatusVariables, signal?: AbortSignal) =>
  fetch<CheckDomainStatusResponse, CheckDomainStatusError, undefined, {}, CheckDomainStatusQueryParams, {}>({
    url: '/v4/domains/status',
    method: 'get',
    ...variables,
    signal
  });

export type CheckDomainPriceQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CheckDomainPriceError = Fetcher.ErrorWrapper<undefined>;

export type CheckDomainPriceResponse = {
  /**
   * The domain price in USD.
   *
   * @example 20
   */
  price: number;
  /**
   * The number of years the domain could be held before paying again.
   *
   * @example 1
   */
  period: number;
};

export type CheckDomainPriceVariables = {
  queryParams?: CheckDomainPriceQueryParams;
} & FetcherExtraProps;

/**
 * Check the price to purchase a domain and how long a single purchase period is.
 */
export const checkDomainPrice = (variables: CheckDomainPriceVariables, signal?: AbortSignal) =>
  fetch<CheckDomainPriceResponse, CheckDomainPriceError, undefined, {}, CheckDomainPriceQueryParams, {}>({
    url: '/v4/domains/price',
    method: 'get',
    ...variables,
    signal
  });

export type BuyDomainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type BuyDomainError = Fetcher.ErrorWrapper<undefined>;

export type BuyDomainResponse = {
  domain: {
    uid: string;
    ns: string[];
    verified: boolean;
    created: number;
    pending: boolean;
  };
};

export type BuyDomainVariables = {
  queryParams?: BuyDomainQueryParams;
} & FetcherExtraProps;

/**
 * Allows to purchase the specified domain.
 */
export const buyDomain = (variables: BuyDomainVariables, signal?: AbortSignal) =>
  fetch<BuyDomainResponse, BuyDomainError, undefined, {}, BuyDomainQueryParams, {}>({
    url: '/v4/domains/buy',
    method: 'post',
    ...variables,
    signal
  });

export type GetDomainConfigQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetDomainConfigError = Fetcher.ErrorWrapper<undefined>;

export type GetDomainConfigResponse = {
  /**
   * How we see the domain's configuration. - `CNAME`: Domain has a CNAME pointing to Vercel. - `A`: Domain's A record is resolving to Vercel. - `http`: Domain is resolving to Vercel but may be behind a Proxy. - `null`: Domain is not resolving to Vercel.
   */
  configuredBy?: 'CNAME' | 'A' | 'http' | null;
  /**
   * Which challenge types the domain can use for issuing certs.
   */
  acceptedChallenges?: ('dns-01' | 'http-01')[];
  /**
   * Whether or not the domain is configured AND we can automatically generate a TLS certificate.
   */
  misconfigured: boolean;
};

export type GetDomainConfigVariables = {
  queryParams?: GetDomainConfigQueryParams;
} & FetcherExtraProps;

/**
 * Get a Domain's configuration.
 */
export const getDomainConfig = (variables: GetDomainConfigVariables, signal?: AbortSignal) =>
  fetch<GetDomainConfigResponse, GetDomainConfigError, undefined, {}, GetDomainConfigQueryParams, {}>({
    url: '/v6/domains/{domain}/config',
    method: 'get',
    ...variables,
    signal
  });

export type GetDomainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetDomainError = Fetcher.ErrorWrapper<undefined>;

export type GetDomainResponse = {
  domain: {
    suffix: boolean;
    /**
     * If the domain has the ownership verified.
     *
     * @example true
     */
    verified: boolean;
    /**
     * A list of the current nameservers of the domain.
     *
     * @example ns1.nameserver.net
     * @example ns2.nameserver.net
     */
    nameservers: string[];
    /**
     * A list of the intended nameservers for the domain to point to Vercel DNS.
     *
     * @example ns1.vercel-dns.com
     * @example ns2.vercel-dns.com
     */
    intendedNameservers: string[];
    /**
     * A list of custom nameservers for the domain to point to. Only applies to domains purchased with Vercel.
     *
     * @example ns1.nameserver.net
     * @example ns2.nameserver.net
     */
    customNameservers?: string[];
    /**
     * An object containing information of the domain creator, including the user's id, username, and email.
     *
     * @example {"id":"ZspSRT4ljIEEmMHgoDwKWDei","username":"vercel_user","email":"demo@example.com"}
     */
    creator: {
      username: string;
      email: string;
      customerId?: string | null;
      isDomainReseller?: boolean;
      id: string;
    };
    /**
     * Timestamp in milliseconds when the domain was created in the registry.
     *
     * @example 1613602938882
     */
    createdAt: number;
    /**
     * The unique identifier of the domain.
     *
     * @example EmTbe5CEJyTk2yVAHBUWy4A3sRusca3GCwRjTC1bpeVnt1
     */
    id: string;
    /**
     * The domain name.
     *
     * @example example.com
     */
    name: string;
    /**
     * Timestamp in milliseconds at which the domain is set to expire. `null` if not bought with Vercel.
     *
     * @example 1613602938882
     */
    expiresAt: number | null;
    /**
     * If it was purchased through Vercel, the timestamp in milliseconds when it was purchased.
     *
     * @example 1613602938882
     */
    boughtAt: number | null;
    /**
     * Timestamp in milliseconds at which the domain was ordered.
     *
     * @example 1613602938882
     */
    orderedAt?: number;
    /**
     * Indicates whether the domain is set to automatically renew.
     *
     * @example true
     */
    renew?: boolean;
    /**
     * The type of service the domain is handled by. `external` if the DNS is externally handled, `zeit.world` if handled with Vercel, or `na` if the service is not available.
     *
     * @example zeit.world
     */
    serviceType: 'zeit.world' | 'external' | 'na';
    /**
     * Timestamp in milliseconds at which the domain was successfully transferred into Vercel. `null` if the transfer is still processing or was never transferred in.
     *
     * @example 1613602938882
     */
    transferredAt?: number | null;
    /**
     * If transferred into Vercel, timestamp in milliseconds when the domain transfer was initiated.
     *
     * @example 1613602938882
     */
    transferStartedAt?: number;
  };
};

export type GetDomainVariables = {
  queryParams?: GetDomainQueryParams;
} & FetcherExtraProps;

/**
 * Get information for a single domain in an account or team.
 */
export const getDomain = (variables: GetDomainVariables, signal?: AbortSignal) =>
  fetch<GetDomainResponse, GetDomainError, undefined, {}, GetDomainQueryParams, {}>({
    url: '/v5/domains/{domain}',
    method: 'get',
    ...variables,
    signal
  });

export type GetDomainsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetDomainsError = Fetcher.ErrorWrapper<undefined>;

export type GetDomainsResponse = {
  domains: {
    /**
     * If the domain has the ownership verified.
     *
     * @example true
     */
    verified: boolean;
    /**
     * A list of the current nameservers of the domain.
     *
     * @example ns1.nameserver.net
     * @example ns2.nameserver.net
     */
    nameservers: string[];
    /**
     * A list of the intended nameservers for the domain to point to Vercel DNS.
     *
     * @example ns1.vercel-dns.com
     * @example ns2.vercel-dns.com
     */
    intendedNameservers: string[];
    /**
     * A list of custom nameservers for the domain to point to. Only applies to domains purchased with Vercel.
     *
     * @example ns1.nameserver.net
     * @example ns2.nameserver.net
     */
    customNameservers?: string[];
    /**
     * An object containing information of the domain creator, including the user's id, username, and email.
     *
     * @example {"id":"ZspSRT4ljIEEmMHgoDwKWDei","username":"vercel_user","email":"demo@example.com"}
     */
    creator: {
      username: string;
      email: string;
      customerId?: string | null;
      isDomainReseller?: boolean;
      id: string;
    };
    /**
     * Timestamp in milliseconds when the domain was created in the registry.
     *
     * @example 1613602938882
     */
    createdAt: number;
    /**
     * The unique identifier of the domain.
     *
     * @example EmTbe5CEJyTk2yVAHBUWy4A3sRusca3GCwRjTC1bpeVnt1
     */
    id: string;
    /**
     * The domain name.
     *
     * @example example.com
     */
    name: string;
    /**
     * Timestamp in milliseconds at which the domain is set to expire. `null` if not bought with Vercel.
     *
     * @example 1613602938882
     */
    expiresAt: number | null;
    /**
     * Indicates whether the domain is set to automatically renew.
     *
     * @example true
     */
    renew?: boolean;
    /**
     * If it was purchased through Vercel, the timestamp in milliseconds when it was purchased.
     *
     * @example 1613602938882
     */
    boughtAt: number | null;
    /**
     * Timestamp in milliseconds at which the domain was ordered.
     *
     * @example 1613602938882
     */
    orderedAt?: number;
    /**
     * The type of service the domain is handled by. `external` if the DNS is externally handled, `zeit.world` if handled with Vercel, or `na` if the service is not available.
     *
     * @example zeit.world
     */
    serviceType: 'zeit.world' | 'external' | 'na';
    /**
     * Timestamp in milliseconds at which the domain was successfully transferred into Vercel. `null` if the transfer is still processing or was never transferred in.
     *
     * @example 1613602938882
     */
    transferredAt?: number | null;
    /**
     * If transferred into Vercel, timestamp in milliseconds when the domain transfer was initiated.
     *
     * @example 1613602938882
     */
    transferStartedAt?: number;
  }[];
  pagination: Schemas.Pagination;
};

export type GetDomainsVariables = {
  queryParams?: GetDomainsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of domains registered for the authenticating user. By default it returns the last 20 domains if no limit is provided.
 */
export const getDomains = (variables: GetDomainsVariables, signal?: AbortSignal) =>
  fetch<GetDomainsResponse, GetDomainsError, undefined, {}, GetDomainsQueryParams, {}>({
    url: '/v5/domains',
    method: 'get',
    ...variables,
    signal
  });

export type CreateOrTransferDomainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateOrTransferDomainError = Fetcher.ErrorWrapper<undefined>;

export type CreateOrTransferDomainResponse = {
  domain: {
    /**
     * If the domain has the ownership verified.
     *
     * @example true
     */
    verified: boolean;
    /**
     * A list of the current nameservers of the domain.
     *
     * @example ns1.nameserver.net
     * @example ns2.nameserver.net
     */
    nameservers: string[];
    /**
     * A list of the intended nameservers for the domain to point to Vercel DNS.
     *
     * @example ns1.vercel-dns.com
     * @example ns2.vercel-dns.com
     */
    intendedNameservers: string[];
    /**
     * A list of custom nameservers for the domain to point to. Only applies to domains purchased with Vercel.
     *
     * @example ns1.nameserver.net
     * @example ns2.nameserver.net
     */
    customNameservers?: string[];
    /**
     * An object containing information of the domain creator, including the user's id, username, and email.
     *
     * @example {"id":"ZspSRT4ljIEEmMHgoDwKWDei","username":"vercel_user","email":"demo@example.com"}
     */
    creator: {
      username: string;
      email: string;
      customerId?: string | null;
      isDomainReseller?: boolean;
      id: string;
    };
    /**
     * The domain name.
     *
     * @example example.com
     */
    name: string;
    /**
     * Timestamp in milliseconds when the domain was created in the registry.
     *
     * @example 1613602938882
     */
    createdAt: number;
    /**
     * The unique identifier of the domain.
     *
     * @example EmTbe5CEJyTk2yVAHBUWy4A3sRusca3GCwRjTC1bpeVnt1
     */
    id: string;
    /**
     * Timestamp in milliseconds at which the domain is set to expire. `null` if not bought with Vercel.
     *
     * @example 1613602938882
     */
    expiresAt: number | null;
    /**
     * If it was purchased through Vercel, the timestamp in milliseconds when it was purchased.
     *
     * @example 1613602938882
     */
    boughtAt: number | null;
    /**
     * Timestamp in milliseconds at which the domain was ordered.
     *
     * @example 1613602938882
     */
    orderedAt?: number;
    /**
     * Indicates whether the domain is set to automatically renew.
     *
     * @example true
     */
    renew?: boolean;
    /**
     * The type of service the domain is handled by. `external` if the DNS is externally handled, `zeit.world` if handled with Vercel, or `na` if the service is not available.
     *
     * @example zeit.world
     */
    serviceType: 'zeit.world' | 'external' | 'na';
    /**
     * Timestamp in milliseconds at which the domain was successfully transferred into Vercel. `null` if the transfer is still processing or was never transferred in.
     *
     * @example 1613602938882
     */
    transferredAt?: number | null;
    /**
     * If transferred into Vercel, timestamp in milliseconds when the domain transfer was initiated.
     *
     * @example 1613602938882
     */
    transferStartedAt?: number;
  };
};

export type CreateOrTransferDomainVariables = {
  queryParams?: CreateOrTransferDomainQueryParams;
} & FetcherExtraProps;

/**
 * This endpoint is used for registering a new domain name with Vercel for the authenticating user, and also for initiating a domain transfer request from an external Registrar to Vercel.
 */
export const createOrTransferDomain = (variables: CreateOrTransferDomainVariables, signal?: AbortSignal) =>
  fetch<
    CreateOrTransferDomainResponse,
    CreateOrTransferDomainError,
    undefined,
    {},
    CreateOrTransferDomainQueryParams,
    {}
  >({ url: '/v5/domains', method: 'post', ...variables, signal });

export type DeleteDomainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteDomainError = Fetcher.ErrorWrapper<undefined>;

export type DeleteDomainResponse = {
  uid: string;
};

export type DeleteDomainVariables = {
  queryParams?: DeleteDomainQueryParams;
} & FetcherExtraProps;

/**
 * Delete a previously registered domain name from Vercel. Deleting a domain will automatically remove any associated aliases.
 */
export const deleteDomain = (variables: DeleteDomainVariables, signal?: AbortSignal) =>
  fetch<DeleteDomainResponse, DeleteDomainError, undefined, {}, DeleteDomainQueryParams, {}>({
    url: '/v6/domains/{domain}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetSecretsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetSecretsError = Fetcher.ErrorWrapper<undefined>;

export type GetSecretsResponse = {
  secrets: {
    /**
     * The date when the secret was created.
     *
     * @format date-time
     * @example 2021-02-10T13:11:49.180Z
     */
    created: string;
    /**
     * The name of the secret.
     *
     * @example my-api-key
     */
    name: string;
    /**
     * The unique identifier of the team the secret was created for.
     *
     * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
     */
    teamId?: string | null;
    /**
     * The unique identifier of the secret.
     *
     * @example sec_XCG7t7AIHuO2SBA8667zNUiM
     */
    uid: string;
    /**
     * The unique identifier of the user who created the secret.
     *
     * @example 2qDDuGFTWXBLDNnqZfWPDp1A
     */
    userId?: string;
    /**
     * The value of the secret.
     */
    value?: string;
    /**
     * Timestamp for when the secret was created.
     *
     * @example 1609492210000
     */
    createdAt?: number;
    /**
     * The unique identifier of the project which the secret belongs to.
     *
     * @example prj_2WjyKQmM8ZnGcJsPWMrHRHrE
     */
    projectId?: string;
    /**
     * Indicates whether the secret value can be decrypted after it has been created.
     *
     * @example true
     */
    decryptable?: boolean;
  }[];
  pagination: Schemas.Pagination;
};

export type GetSecretsVariables = {
  queryParams?: GetSecretsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves the active Vercel secrets for the authenticated user. By default it returns 20 secrets. The rest can be retrieved using the pagination options. The body will contain an entry for each secret.
 */
export const getSecrets = (variables: GetSecretsVariables, signal?: AbortSignal) =>
  fetch<GetSecretsResponse, GetSecretsError, undefined, {}, GetSecretsQueryParams, {}>({
    url: '/v3/secrets',
    method: 'get',
    ...variables,
    signal
  });

export type CreateSecretQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateSecretError = Fetcher.ErrorWrapper<undefined>;

export type CreateSecretResponse = {
  value: {
    type?: 'Buffer';
    data?: number[];
  };
  /**
   * The date when the secret was created.
   *
   * @format date-time
   * @example 2021-02-10T13:11:49.180Z
   */
  created: string;
  /**
   * The name of the secret.
   *
   * @example my-api-key
   */
  name: string;
  /**
   * The unique identifier of the team the secret was created for.
   *
   * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
   */
  teamId?: string | null;
  /**
   * The unique identifier of the secret.
   *
   * @example sec_XCG7t7AIHuO2SBA8667zNUiM
   */
  uid: string;
  /**
   * The unique identifier of the user who created the secret.
   *
   * @example 2qDDuGFTWXBLDNnqZfWPDp1A
   */
  userId?: string;
  /**
   * Timestamp for when the secret was created.
   *
   * @example 1609492210000
   */
  createdAt?: number;
  /**
   * The unique identifier of the project which the secret belongs to.
   *
   * @example prj_2WjyKQmM8ZnGcJsPWMrHRHrE
   */
  projectId?: string;
  /**
   * Indicates whether the secret value can be decrypted after it has been created.
   *
   * @example true
   */
  decryptable?: boolean;
};

export type CreateSecretVariables = {
  queryParams?: CreateSecretQueryParams;
} & FetcherExtraProps;

/**
 * Allows to create a new secret.
 */
export const createSecret = (variables: CreateSecretVariables, signal?: AbortSignal) =>
  fetch<CreateSecretResponse, CreateSecretError, undefined, {}, CreateSecretQueryParams, {}>({
    url: '/v2/secrets/{name}',
    method: 'post',
    ...variables,
    signal
  });

export type RenameSecretQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type RenameSecretError = Fetcher.ErrorWrapper<undefined>;

export type RenameSecretResponse = {
  uid: string;
  name: string;
  /**
   * Enables basic storage and retrieval of dates and times.
   *
   * @format date-time
   */
  created: string;
  oldName: string;
};

export type RenameSecretVariables = {
  queryParams?: RenameSecretQueryParams;
} & FetcherExtraProps;

/**
 * Enables to edit the name of a user's secret. The name has to be unique to that user's secrets.
 */
export const renameSecret = (variables: RenameSecretVariables, signal?: AbortSignal) =>
  fetch<RenameSecretResponse, RenameSecretError, undefined, {}, RenameSecretQueryParams, {}>({
    url: '/v2/secrets/{name}',
    method: 'patch',
    ...variables,
    signal
  });

export type GetSecretQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetSecretError = Fetcher.ErrorWrapper<undefined>;

export type GetSecretResponse = {
  /**
   * The date when the secret was created.
   *
   * @format date-time
   * @example 2021-02-10T13:11:49.180Z
   */
  created: string;
  /**
   * The name of the secret.
   *
   * @example my-api-key
   */
  name: string;
  /**
   * The unique identifier of the team the secret was created for.
   *
   * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
   */
  teamId?: string | null;
  /**
   * The unique identifier of the secret.
   *
   * @example sec_XCG7t7AIHuO2SBA8667zNUiM
   */
  uid: string;
  /**
   * The unique identifier of the user who created the secret.
   *
   * @example 2qDDuGFTWXBLDNnqZfWPDp1A
   */
  userId?: string;
  /**
   * The value of the secret.
   */
  value?: string;
  /**
   * Timestamp for when the secret was created.
   *
   * @example 1609492210000
   */
  createdAt?: number;
  /**
   * The unique identifier of the project which the secret belongs to.
   *
   * @example prj_2WjyKQmM8ZnGcJsPWMrHRHrE
   */
  projectId?: string;
  /**
   * Indicates whether the secret value can be decrypted after it has been created.
   *
   * @example true
   */
  decryptable?: boolean;
};

export type GetSecretVariables = {
  queryParams?: GetSecretQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves the information for a specific secret by passing either the secret id or name in the URL.
 */
export const getSecret = (variables: GetSecretVariables, signal?: AbortSignal) =>
  fetch<GetSecretResponse, GetSecretError, undefined, {}, GetSecretQueryParams, {}>({
    url: '/v3/secrets/{idOrName}',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteSecretQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteSecretError = Fetcher.ErrorWrapper<undefined>;

export type DeleteSecretResponse = {
  /**
   * The unique identifier of the deleted secret.
   *
   * @example sec_XCG7t7AIHuO2SBA8667zNUiM
   */
  uid: string;
  /**
   * The name of the deleted secret.
   *
   * @example my-api-key
   */
  name: string;
  /**
   * The date when the secret was created.
   *
   * @example 2021-02-10T13:11:49.180Z
   */
  created: number;
};

export type DeleteSecretVariables = {
  queryParams?: DeleteSecretQueryParams;
} & FetcherExtraProps;

/**
 * This deletes the user's secret defined in the URL.
 */
export const deleteSecret = (variables: DeleteSecretVariables, signal?: AbortSignal) =>
  fetch<DeleteSecretResponse, DeleteSecretError, undefined, {}, DeleteSecretQueryParams, {}>({
    url: '/v2/secrets/{idOrName}',
    method: 'delete',
    ...variables,
    signal
  });

export type DeleteDeploymentQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteDeploymentError = Fetcher.ErrorWrapper<undefined>;

export type DeleteDeploymentResponse = {
  /**
   * The removed deployment ID.
   *
   * @example dpl_5WJWYSyB7BpgTj3EuwF37WMRBXBtPQ2iTMJHJBJyRfd
   */
  uid: string;
  /**
   * A constant with the final state of the deployment.
   */
  state: 'DELETED';
};

export type DeleteDeploymentVariables = {
  queryParams?: DeleteDeploymentQueryParams;
} & FetcherExtraProps;

/**
 * This API allows you to delete a deployment, either by supplying its `id` in the URL or the `url` of the deployment as a query parameter. You can obtain the ID, for example, by listing all deployments.
 */
export const deleteDeployment = (variables: DeleteDeploymentVariables, signal?: AbortSignal) =>
  fetch<DeleteDeploymentResponse, DeleteDeploymentError, undefined, {}, DeleteDeploymentQueryParams, {}>({
    url: '/v13/deployments/{id}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetDeploymentsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetDeploymentsError = Fetcher.ErrorWrapper<undefined>;

export type GetDeploymentsResponse = {
  pagination: Schemas.Pagination;
  deployments: {
    /**
     * The unique identifier of the deployment.
     *
     * @example dpl_2euZBFqxYdDMDG1jTrHFnNZ2eUVa
     */
    uid: string;
    /**
     * The name of the deployment.
     *
     * @example docs
     */
    name: string;
    /**
     * The URL of the deployment.
     *
     * @example docs-9jaeg38me.vercel.app
     */
    url: string;
    /**
     * Timestamp of when the deployment got created.
     *
     * @example 1609492210000
     */
    created: number;
    /**
     * The source of the deployment.
     *
     * @example cli
     */
    source?: 'cli' | 'git' | 'import' | 'import/repo' | 'clone/repo';
    /**
     * In which state is the deployment.
     *
     * @example READY
     */
    state?: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED';
    /**
     * The type of the deployment.
     *
     * @example LAMBDAS
     */
    type: 'LAMBDAS';
    /**
     * Metadata information of the user who created the deployment.
     */
    creator: {
      /**
       * The unique identifier of the user.
       *
       * @example eLrCnEgbKhsHyfbiNR7E8496
       */
      uid: string;
      /**
       * The email address of the user.
       *
       * @example example@example.com
       */
      email?: string;
      /**
       * The username of the user.
       *
       * @example johndoe
       */
      username?: string;
      /**
       * The GitHub login of the user.
       *
       * @example johndoe
       */
      githubLogin?: string;
      /**
       * The GitLab login of the user.
       *
       * @example johndoe
       */
      gitlabLogin?: string;
    };
    /**
     * An object containing the deployment's metadata
     *
     * @example {"foo":"bar"}
     */
    meta?: {
      [key: string]: string;
    };
    /**
     * On which environment has the deployment been deployed to.
     *
     * @example production
     */
    target?: 'staging' | 'production' | null;
    /**
     * An error object in case aliasing of the deployment failed.
     */
    aliasError?: {
      code: string;
      message: string;
    } | null;
    aliasAssigned?: number | boolean | null;
    /**
     * Timestamp of when the deployment got created.
     *
     * @example 1609492210000
     */
    createdAt?: number;
    /**
     * Timestamp of when the deployment started building at.
     *
     * @example 1609492210000
     */
    buildingAt?: number;
    /**
     * Timestamp of when the deployment got ready.
     *
     * @example 1609492210000
     */
    ready?: number;
    /**
     * State of all registered checks
     */
    checksState?: 'registered' | 'running' | 'completed';
    /**
     * Conclusion for checks
     */
    checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
    /**
     * Vercel URL to inspect the deployment.
     *
     * @example https://vercel.com/acme/nextjs/J1hXN00qjUeoYfpEEf7dnDtpSiVq
     */
    inspectorUrl: string | null;
    /**
     * Deployment can be used for instant rollback
     */
    isRollbackCandidate?: boolean | null;
    /**
     * The project settings which was used for this deployment
     */
    projectSettings?: {
      framework?:
        | 'blitzjs'
        | 'nextjs'
        | 'gatsby'
        | 'remix'
        | 'astro'
        | 'hexo'
        | 'eleventy'
        | 'docusaurus-2'
        | 'docusaurus'
        | 'preact'
        | 'solidstart'
        | 'dojo'
        | 'ember'
        | 'vue'
        | 'scully'
        | 'ionic-angular'
        | 'angular'
        | 'polymer'
        | 'svelte'
        | 'sveltekit'
        | 'sveltekit-1'
        | 'ionic-react'
        | 'create-react-app'
        | 'gridsome'
        | 'umijs'
        | 'sapper'
        | 'saber'
        | 'stencil'
        | 'nuxtjs'
        | 'redwoodjs'
        | 'hugo'
        | 'jekyll'
        | 'brunch'
        | 'middleman'
        | 'zola'
        | 'hydrogen'
        | 'vite'
        | 'vitepress'
        | 'vuepress'
        | 'parcel'
        | 'sanity'
        | null;
      gitForkProtection?: boolean;
      gitLFS?: boolean;
      devCommand?: string | null;
      installCommand?: string | null;
      buildCommand?: string | null;
      nodeVersion?: '18.x' | '16.x' | '14.x' | '12.x' | '10.x';
      outputDirectory?: string | null;
      publicSource?: boolean | null;
      rootDirectory?: string | null;
      serverlessFunctionRegion?: string | null;
      sourceFilesOutsideRootDirectory?: boolean;
      commandForIgnoringBuildStep?: string | null;
      createdAt?: number;
      skipGitConnectDuringLink?: boolean;
    };
    /**
     * The ID of Vercel Connect configuration used for this deployment
     */
    connectConfigurationId?: string;
  }[];
};

export type GetDeploymentsVariables = {
  queryParams?: GetDeploymentsQueryParams;
} & FetcherExtraProps;

/**
 * List deployments under the account corresponding to the API token. If a deployment hasn't finished uploading (is incomplete), the `url` property will have a value of `null`.
 */
export const getDeployments = (variables: GetDeploymentsVariables, signal?: AbortSignal) =>
  fetch<GetDeploymentsResponse, GetDeploymentsError, undefined, {}, GetDeploymentsQueryParams, {}>({
    url: '/v6/deployments',
    method: 'get',
    ...variables,
    signal
  });

export type GetProjectsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetProjectsError = Fetcher.ErrorWrapper<undefined>;

export type GetProjectsResponse = {
  projects: {
    accountId: string;
    analytics?: {
      id: string;
      canceledAt: number | null;
      disabledAt: number;
      enabledAt: number;
      paidAt?: number;
      sampleRatePercent?: number | null;
      spendLimitInDollars?: number | null;
    };
    autoExposeSystemEnvs?: boolean;
    buildCommand?: string | null;
    commandForIgnoringBuildStep?: string | null;
    connectConfigurationId?: string | null;
    connectBuildsEnabled?: boolean;
    createdAt?: number;
    devCommand?: string | null;
    directoryListing: boolean;
    installCommand?: string | null;
    env?: {
      target?:
        | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
        | ('production' | 'preview' | 'development' | 'preview' | 'development');
      type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
      id?: string;
      key: string;
      value: string;
      configurationId?: string | null;
      createdAt?: number;
      updatedAt?: number;
      createdBy?: string | null;
      updatedBy?: string | null;
      gitBranch?: string;
      edgeConfigId?: string | null;
      edgeConfigTokenId?: string | null;
      contentHint?:
        | {
            type: 'redis-url';
            storeId: string;
          }
        | {
            type: 'redis-rest-api-url';
            storeId: string;
          }
        | {
            type: 'redis-rest-api-token';
            storeId: string;
          }
        | {
            type: 'redis-rest-api-read-only-token';
            storeId: string;
          }
        | {
            type: 'blob-read-write-token';
            storeId: string;
          }
        | {
            type: 'postgres-url';
            storeId: string;
          }
        | {
            type: 'postgres-url-non-pooling';
            storeId: string;
          }
        | {
            type: 'postgres-prisma-url';
            storeId: string;
          }
        | {
            type: 'postgres-user';
            storeId: string;
          }
        | {
            type: 'postgres-host';
            storeId: string;
          }
        | {
            type: 'postgres-password';
            storeId: string;
          }
        | {
            type: 'postgres-database';
            storeId: string;
          }
        | null;
      /**
       * Whether `value` is decrypted.
       */
      decrypted?: boolean;
    }[];
    framework?:
      | 'blitzjs'
      | 'nextjs'
      | 'gatsby'
      | 'remix'
      | 'astro'
      | 'hexo'
      | 'eleventy'
      | 'docusaurus-2'
      | 'docusaurus'
      | 'preact'
      | 'solidstart'
      | 'dojo'
      | 'ember'
      | 'vue'
      | 'scully'
      | 'ionic-angular'
      | 'angular'
      | 'polymer'
      | 'svelte'
      | 'sveltekit'
      | 'sveltekit-1'
      | 'ionic-react'
      | 'create-react-app'
      | 'gridsome'
      | 'umijs'
      | 'sapper'
      | 'saber'
      | 'stencil'
      | 'nuxtjs'
      | 'redwoodjs'
      | 'hugo'
      | 'jekyll'
      | 'brunch'
      | 'middleman'
      | 'zola'
      | 'hydrogen'
      | 'vite'
      | 'vitepress'
      | 'vuepress'
      | 'parcel'
      | 'sanity'
      | null;
    gitForkProtection?: boolean;
    gitLFS?: boolean;
    id: string;
    latestDeployments?: {
      alias?: string[];
      aliasAssigned?: number | boolean | null;
      aliasError?: {
        code: string;
        message: string;
      } | null;
      aliasFinal?: string | null;
      automaticAliases?: string[];
      builds?: {
        use: string;
        src?: string;
        dest?: string;
      }[];
      connectConfigurationId?: string;
      createdAt: number;
      createdIn: string;
      creator: {
        email: string;
        githubLogin?: string;
        gitlabLogin?: string;
        uid: string;
        username: string;
      } | null;
      deploymentHostname: string;
      name: string;
      forced?: boolean;
      id: string;
      /**
       * Construct a type with a set of properties K of type T
       */
      meta?: {
        [key: string]: string;
      };
      monorepoManager?: string | null;
      plan: 'hobby' | 'enterprise' | 'pro' | 'oss';
      private: boolean;
      readyState: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED';
      requestedAt?: number;
      target?: string | null;
      teamId?: string | null;
      type: 'LAMBDAS';
      url: string;
      userId: string;
      withCache?: boolean;
      checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
      checksState?: 'registered' | 'running' | 'completed';
      readyAt?: number;
      buildingAt?: number;
      /**
       * Whether or not preview comments are enabled for the deployment
       *
       * @example false
       */
      previewCommentsEnabled?: boolean;
    }[];
    link?:
      | {
          org?: string;
          repo?: string;
          repoId?: number;
          type?: 'github';
          createdAt?: number;
          deployHooks: {
            createdAt?: number;
            id: string;
            name: string;
            ref: string;
            url: string;
          }[];
          gitCredentialId?: string;
          updatedAt?: number;
          sourceless?: boolean;
          productionBranch?: string;
        }
      | {
          projectId?: string;
          projectName?: string;
          projectNameWithNamespace?: string;
          projectNamespace?: string;
          projectUrl?: string;
          type?: 'gitlab';
          createdAt?: number;
          deployHooks: {
            createdAt?: number;
            id: string;
            name: string;
            ref: string;
            url: string;
          }[];
          gitCredentialId?: string;
          updatedAt?: number;
          sourceless?: boolean;
          productionBranch?: string;
        }
      | {
          name?: string;
          slug?: string;
          owner?: string;
          type?: 'bitbucket';
          uuid?: string;
          workspaceUuid?: string;
          createdAt?: number;
          deployHooks: {
            createdAt?: number;
            id: string;
            name: string;
            ref: string;
            url: string;
          }[];
          gitCredentialId?: string;
          updatedAt?: number;
          sourceless?: boolean;
          productionBranch?: string;
        };
    name: string;
    nodeVersion: '18.x' | '16.x' | '14.x' | '12.x' | '10.x';
    outputDirectory?: string | null;
    passwordProtection?: {
      deploymentType: 'preview' | 'all';
    } | null;
    publicSource?: boolean | null;
    rootDirectory?: string | null;
    serverlessFunctionRegion?: string | null;
    skipGitConnectDuringLink?: boolean;
    sourceFilesOutsideRootDirectory?: boolean;
    ssoProtection?: {
      deploymentType: 'preview' | 'all';
    } | null;
    /**
     * An object containing the deployment's metadata
     *
     * @example {"foo":"bar"}
     */
    targets?: {
      [key: string]: string;
    };
    transferCompletedAt?: number;
    transferStartedAt?: number;
    transferToAccountId?: string;
    transferredFromAccountId?: string;
    updatedAt?: number;
    live?: boolean;
    enablePreviewFeedback?: boolean | null;
    permissions?: {
      aliasGlobal?: Schemas.ACLAction[];
      aliasProject?: Schemas.ACLAction[];
      analytics?: Schemas.ACLAction[];
      analyticsSampling?: Schemas.ACLAction[];
      analyticsUsage?: Schemas.ACLAction[];
      auditLog?: Schemas.ACLAction[];
      billingAddress?: Schemas.ACLAction[];
      billingInformation?: Schemas.ACLAction[];
      billingInvoice?: Schemas.ACLAction[];
      billingInvoiceEmailRecipient?: Schemas.ACLAction[];
      billingInvoiceLanguage?: Schemas.ACLAction[];
      billingPlan?: Schemas.ACLAction[];
      billingPurchaseOrder?: Schemas.ACLAction[];
      billingTaxId?: Schemas.ACLAction[];
      blob?: Schemas.ACLAction[];
      cacheArtifact?: Schemas.ACLAction[];
      cacheArtifactUsageEvent?: Schemas.ACLAction[];
      concurrentBuilds?: Schemas.ACLAction[];
      connect?: Schemas.ACLAction[];
      connectConfiguration?: Schemas.ACLAction[];
      connectConfigurationLink?: Schemas.ACLAction[];
      deployment?: Schemas.ACLAction[];
      deploymentProductionGit?: Schemas.ACLAction[];
      deploymentCheck?: Schemas.ACLAction[];
      deploymentCheckPreview?: Schemas.ACLAction[];
      deploymentPreview?: Schemas.ACLAction[];
      deploymentPrivate?: Schemas.ACLAction[];
      deploymentCheckReRunFromProductionBranch?: Schemas.ACLAction[];
      deploymentRollback?: Schemas.ACLAction[];
      domain?: Schemas.ACLAction[];
      domainAcceptDelegation?: Schemas.ACLAction[];
      domainAuthCodes?: Schemas.ACLAction[];
      domainCertificate?: Schemas.ACLAction[];
      domainCheckConfig?: Schemas.ACLAction[];
      domainMove?: Schemas.ACLAction[];
      domainPurchase?: Schemas.ACLAction[];
      domainRecord?: Schemas.ACLAction[];
      domainTransferIn?: Schemas.ACLAction[];
      event?: Schemas.ACLAction[];
      sensitiveEnvironmentVariablePolicy?: Schemas.ACLAction[];
      fileUpload?: Schemas.ACLAction[];
      gitRepository?: Schemas.ACLAction[];
      ipBlocking?: Schemas.ACLAction[];
      ipAllowlist?: Schemas.ACLAction[];
      integration?: Schemas.ACLAction[];
      integrationConfiguration?: Schemas.ACLAction[];
      integrationConfigurationTransfer?: Schemas.ACLAction[];
      integrationConfigurationProjects?: Schemas.ACLAction[];
      integrationVercelConfigurationOverride?: Schemas.ACLAction[];
      job?: Schemas.ACLAction[];
      logDrain?: Schemas.ACLAction[];
      Monitoring?: Schemas.ACLAction[];
      monitoringQuery?: Schemas.ACLAction[];
      monitoringChart?: Schemas.ACLAction[];
      notificationDomainConfiguration?: Schemas.ACLAction[];
      notificationDomainExpire?: Schemas.ACLAction[];
      notificationDomainMoved?: Schemas.ACLAction[];
      notificationDomainPurchase?: Schemas.ACLAction[];
      notificationDomainRenewal?: Schemas.ACLAction[];
      notificationDomainTransfer?: Schemas.ACLAction[];
      notificationDomainUnverified?: Schemas.ACLAction[];
      notificationPaymentFailed?: Schemas.ACLAction[];
      notificationUsageAlert?: Schemas.ACLAction[];
      notificationSpendCap?: Schemas.ACLAction[];
      openTelemetryEndpoint?: Schemas.ACLAction[];
      passwordProtection?: Schemas.ACLAction[];
      paymentMethod?: Schemas.ACLAction[];
      permissions?: Schemas.ACLAction[];
      postgres?: Schemas.ACLAction[];
      previewDeploymentSuffix?: Schemas.ACLAction[];
      proTrialOnboarding?: Schemas.ACLAction[];
      project?: Schemas.ACLAction[];
      projectDeploymentHook?: Schemas.ACLAction[];
      projectDomain?: Schemas.ACLAction[];
      projectDomainMove?: Schemas.ACLAction[];
      projectEnvVars?: Schemas.ACLAction[];
      projectEnvVarsUnownedByIntegration?: Schemas.ACLAction[];
      sharedEnvVars?: Schemas.ACLAction[];
      projectEnvVarsProduction?: Schemas.ACLAction[];
      sharedEnvVarsProduction?: Schemas.ACLAction[];
      projectIntegrationConfiguration?: Schemas.ACLAction[];
      projectLink?: Schemas.ACLAction[];
      projectMember?: Schemas.ACLAction[];
      projectProductionBranch?: Schemas.ACLAction[];
      projectTransfer?: Schemas.ACLAction[];
      projectProtectionBypass?: Schemas.ACLAction[];
      rateLimit?: Schemas.ACLAction[];
      redis?: Schemas.ACLAction[];
      remoteCaching?: Schemas.ACLAction[];
      samlConfig?: Schemas.ACLAction[];
      secret?: Schemas.ACLAction[];
      spendCapConfiguration?: Schemas.ACLAction[];
      spendCapState?: Schemas.ACLAction[];
      supportCase?: Schemas.ACLAction[];
      supportCaseComment?: Schemas.ACLAction[];
      DataCacheNamespace?: Schemas.ACLAction[];
      team?: Schemas.ACLAction[];
      teamAccessRequest?: Schemas.ACLAction[];
      teamFellowMembership?: Schemas.ACLAction[];
      teamInvite?: Schemas.ACLAction[];
      teamInviteCode?: Schemas.ACLAction[];
      teamJoin?: Schemas.ACLAction[];
      teamOwnMembership?: Schemas.ACLAction[];
      teamOwnMembershipDisconnectSAML?: Schemas.ACLAction[];
      token?: Schemas.ACLAction[];
      usage?: Schemas.ACLAction[];
      user?: Schemas.ACLAction[];
      userConnection?: Schemas.ACLAction[];
      webAnalytics?: Schemas.ACLAction[];
      webAnalyticsPlan?: Schemas.ACLAction[];
      edgeConfig?: Schemas.ACLAction[];
      edgeConfigItem?: Schemas.ACLAction[];
      edgeConfigToken?: Schemas.ACLAction[];
      webhook?: Schemas.ACLAction[];
      ['webhook-event']?: Schemas.ACLAction[];
      endpointVerification?: Schemas.ACLAction[];
      aliasProtectionBypass?: Schemas.ACLAction[];
    };
    lastRollbackTarget?: {
      fromDeploymentId: string;
      toDeploymentId: string;
      jobStatus: 'succeeded' | 'failed' | 'skipped' | 'pending' | 'in-progress';
      requestedAt: number;
    } | null;
    hasFloatingAliases?: boolean;
    /**
     * Construct a type with a set of properties K of type T
     */
    protectionBypass?: {
      [key: string]: string;
    };
    hasActiveBranches?: boolean;
    ipAllowlist?: {
      deploymentType: 'preview' | 'all';
      ipAddresses: string[];
      protectionMode: 'additional' | 'exclusive';
    } | null;
  }[];
  pagination: Schemas.Pagination;
};

export type GetProjectsVariables = {
  queryParams?: GetProjectsQueryParams;
} & FetcherExtraProps;

/**
 * Allows to retrieve the list of projects of the authenticated user. The list will be paginated and the provided query parameters allow filtering the returned projects.
 */
export const getProjects = (variables: GetProjectsVariables, signal?: AbortSignal) =>
  fetch<GetProjectsResponse, GetProjectsError, undefined, {}, GetProjectsQueryParams, {}>({
    url: '/v9/projects',
    method: 'get',
    ...variables,
    signal
  });

export type CreateProjectQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateProjectError = Fetcher.ErrorWrapper<undefined>;

export type CreateProjectResponse = {
  accountId: string;
  analytics?: {
    id: string;
    canceledAt: number | null;
    disabledAt: number;
    enabledAt: number;
    paidAt?: number;
    sampleRatePercent?: number | null;
    spendLimitInDollars?: number | null;
  };
  autoExposeSystemEnvs?: boolean;
  buildCommand?: string | null;
  commandForIgnoringBuildStep?: string | null;
  connectConfigurationId?: string | null;
  connectBuildsEnabled?: boolean;
  createdAt?: number;
  devCommand?: string | null;
  directoryListing: boolean;
  installCommand?: string | null;
  env?: {
    target?:
      | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
      | ('production' | 'preview' | 'development' | 'preview' | 'development');
    type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
    id?: string;
    key: string;
    value: string;
    configurationId?: string | null;
    createdAt?: number;
    updatedAt?: number;
    createdBy?: string | null;
    updatedBy?: string | null;
    gitBranch?: string;
    edgeConfigId?: string | null;
    edgeConfigTokenId?: string | null;
    contentHint?:
      | {
          type: 'redis-url';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-url';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-token';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-read-only-token';
          storeId: string;
        }
      | {
          type: 'blob-read-write-token';
          storeId: string;
        }
      | {
          type: 'postgres-url';
          storeId: string;
        }
      | {
          type: 'postgres-url-non-pooling';
          storeId: string;
        }
      | {
          type: 'postgres-prisma-url';
          storeId: string;
        }
      | {
          type: 'postgres-user';
          storeId: string;
        }
      | {
          type: 'postgres-host';
          storeId: string;
        }
      | {
          type: 'postgres-password';
          storeId: string;
        }
      | {
          type: 'postgres-database';
          storeId: string;
        }
      | null;
    /**
     * Whether `value` is decrypted.
     */
    decrypted?: boolean;
  }[];
  framework?:
    | 'blitzjs'
    | 'nextjs'
    | 'gatsby'
    | 'remix'
    | 'astro'
    | 'hexo'
    | 'eleventy'
    | 'docusaurus-2'
    | 'docusaurus'
    | 'preact'
    | 'solidstart'
    | 'dojo'
    | 'ember'
    | 'vue'
    | 'scully'
    | 'ionic-angular'
    | 'angular'
    | 'polymer'
    | 'svelte'
    | 'sveltekit'
    | 'sveltekit-1'
    | 'ionic-react'
    | 'create-react-app'
    | 'gridsome'
    | 'umijs'
    | 'sapper'
    | 'saber'
    | 'stencil'
    | 'nuxtjs'
    | 'redwoodjs'
    | 'hugo'
    | 'jekyll'
    | 'brunch'
    | 'middleman'
    | 'zola'
    | 'hydrogen'
    | 'vite'
    | 'vitepress'
    | 'vuepress'
    | 'parcel'
    | 'sanity'
    | null;
  gitForkProtection?: boolean;
  gitLFS?: boolean;
  id: string;
  latestDeployments?: {
    alias?: string[];
    aliasAssigned?: number | boolean | null;
    aliasError?: {
      code: string;
      message: string;
    } | null;
    aliasFinal?: string | null;
    automaticAliases?: string[];
    builds?: {
      use: string;
      src?: string;
      dest?: string;
    }[];
    connectConfigurationId?: string;
    createdAt: number;
    createdIn: string;
    creator: {
      email: string;
      githubLogin?: string;
      gitlabLogin?: string;
      uid: string;
      username: string;
    } | null;
    deploymentHostname: string;
    name: string;
    forced?: boolean;
    id: string;
    /**
     * Construct a type with a set of properties K of type T
     */
    meta?: {
      [key: string]: string;
    };
    monorepoManager?: string | null;
    plan: 'hobby' | 'enterprise' | 'pro' | 'oss';
    private: boolean;
    readyState: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED';
    requestedAt?: number;
    target?: string | null;
    teamId?: string | null;
    type: 'LAMBDAS';
    url: string;
    userId: string;
    withCache?: boolean;
    checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
    checksState?: 'registered' | 'running' | 'completed';
    readyAt?: number;
    buildingAt?: number;
    /**
     * Whether or not preview comments are enabled for the deployment
     *
     * @example false
     */
    previewCommentsEnabled?: boolean;
  }[];
  link?:
    | {
        org?: string;
        repo?: string;
        repoId?: number;
        type?: 'github';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        projectId?: string;
        projectName?: string;
        projectNameWithNamespace?: string;
        projectNamespace?: string;
        projectUrl?: string;
        type?: 'gitlab';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        name?: string;
        slug?: string;
        owner?: string;
        type?: 'bitbucket';
        uuid?: string;
        workspaceUuid?: string;
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      };
  name: string;
  nodeVersion: '18.x' | '16.x' | '14.x' | '12.x' | '10.x';
  outputDirectory?: string | null;
  passwordProtection?: {
    deploymentType: 'preview' | 'all';
  } | null;
  publicSource?: boolean | null;
  rootDirectory?: string | null;
  serverlessFunctionRegion?: string | null;
  skipGitConnectDuringLink?: boolean;
  sourceFilesOutsideRootDirectory?: boolean;
  ssoProtection?: {
    deploymentType: 'preview' | 'all';
  } | null;
  /**
   * An object containing the deployment's metadata
   *
   * @example {"foo":"bar"}
   */
  targets?: {
    [key: string]: string;
  };
  transferCompletedAt?: number;
  transferStartedAt?: number;
  transferToAccountId?: string;
  transferredFromAccountId?: string;
  updatedAt?: number;
  live?: boolean;
  enablePreviewFeedback?: boolean | null;
  permissions?: {
    aliasGlobal?: Schemas.ACLAction[];
    aliasProject?: Schemas.ACLAction[];
    analytics?: Schemas.ACLAction[];
    analyticsSampling?: Schemas.ACLAction[];
    analyticsUsage?: Schemas.ACLAction[];
    auditLog?: Schemas.ACLAction[];
    billingAddress?: Schemas.ACLAction[];
    billingInformation?: Schemas.ACLAction[];
    billingInvoice?: Schemas.ACLAction[];
    billingInvoiceEmailRecipient?: Schemas.ACLAction[];
    billingInvoiceLanguage?: Schemas.ACLAction[];
    billingPlan?: Schemas.ACLAction[];
    billingPurchaseOrder?: Schemas.ACLAction[];
    billingTaxId?: Schemas.ACLAction[];
    blob?: Schemas.ACLAction[];
    cacheArtifact?: Schemas.ACLAction[];
    cacheArtifactUsageEvent?: Schemas.ACLAction[];
    concurrentBuilds?: Schemas.ACLAction[];
    connect?: Schemas.ACLAction[];
    connectConfiguration?: Schemas.ACLAction[];
    connectConfigurationLink?: Schemas.ACLAction[];
    deployment?: Schemas.ACLAction[];
    deploymentProductionGit?: Schemas.ACLAction[];
    deploymentCheck?: Schemas.ACLAction[];
    deploymentCheckPreview?: Schemas.ACLAction[];
    deploymentPreview?: Schemas.ACLAction[];
    deploymentPrivate?: Schemas.ACLAction[];
    deploymentCheckReRunFromProductionBranch?: Schemas.ACLAction[];
    deploymentRollback?: Schemas.ACLAction[];
    domain?: Schemas.ACLAction[];
    domainAcceptDelegation?: Schemas.ACLAction[];
    domainAuthCodes?: Schemas.ACLAction[];
    domainCertificate?: Schemas.ACLAction[];
    domainCheckConfig?: Schemas.ACLAction[];
    domainMove?: Schemas.ACLAction[];
    domainPurchase?: Schemas.ACLAction[];
    domainRecord?: Schemas.ACLAction[];
    domainTransferIn?: Schemas.ACLAction[];
    event?: Schemas.ACLAction[];
    sensitiveEnvironmentVariablePolicy?: Schemas.ACLAction[];
    fileUpload?: Schemas.ACLAction[];
    gitRepository?: Schemas.ACLAction[];
    ipBlocking?: Schemas.ACLAction[];
    ipAllowlist?: Schemas.ACLAction[];
    integration?: Schemas.ACLAction[];
    integrationConfiguration?: Schemas.ACLAction[];
    integrationConfigurationTransfer?: Schemas.ACLAction[];
    integrationConfigurationProjects?: Schemas.ACLAction[];
    integrationVercelConfigurationOverride?: Schemas.ACLAction[];
    job?: Schemas.ACLAction[];
    logDrain?: Schemas.ACLAction[];
    Monitoring?: Schemas.ACLAction[];
    monitoringQuery?: Schemas.ACLAction[];
    monitoringChart?: Schemas.ACLAction[];
    notificationDomainConfiguration?: Schemas.ACLAction[];
    notificationDomainExpire?: Schemas.ACLAction[];
    notificationDomainMoved?: Schemas.ACLAction[];
    notificationDomainPurchase?: Schemas.ACLAction[];
    notificationDomainRenewal?: Schemas.ACLAction[];
    notificationDomainTransfer?: Schemas.ACLAction[];
    notificationDomainUnverified?: Schemas.ACLAction[];
    notificationPaymentFailed?: Schemas.ACLAction[];
    notificationUsageAlert?: Schemas.ACLAction[];
    notificationSpendCap?: Schemas.ACLAction[];
    openTelemetryEndpoint?: Schemas.ACLAction[];
    passwordProtection?: Schemas.ACLAction[];
    paymentMethod?: Schemas.ACLAction[];
    permissions?: Schemas.ACLAction[];
    postgres?: Schemas.ACLAction[];
    previewDeploymentSuffix?: Schemas.ACLAction[];
    proTrialOnboarding?: Schemas.ACLAction[];
    project?: Schemas.ACLAction[];
    projectDeploymentHook?: Schemas.ACLAction[];
    projectDomain?: Schemas.ACLAction[];
    projectDomainMove?: Schemas.ACLAction[];
    projectEnvVars?: Schemas.ACLAction[];
    projectEnvVarsUnownedByIntegration?: Schemas.ACLAction[];
    sharedEnvVars?: Schemas.ACLAction[];
    projectEnvVarsProduction?: Schemas.ACLAction[];
    sharedEnvVarsProduction?: Schemas.ACLAction[];
    projectIntegrationConfiguration?: Schemas.ACLAction[];
    projectLink?: Schemas.ACLAction[];
    projectMember?: Schemas.ACLAction[];
    projectProductionBranch?: Schemas.ACLAction[];
    projectTransfer?: Schemas.ACLAction[];
    projectProtectionBypass?: Schemas.ACLAction[];
    rateLimit?: Schemas.ACLAction[];
    redis?: Schemas.ACLAction[];
    remoteCaching?: Schemas.ACLAction[];
    samlConfig?: Schemas.ACLAction[];
    secret?: Schemas.ACLAction[];
    spendCapConfiguration?: Schemas.ACLAction[];
    spendCapState?: Schemas.ACLAction[];
    supportCase?: Schemas.ACLAction[];
    supportCaseComment?: Schemas.ACLAction[];
    DataCacheNamespace?: Schemas.ACLAction[];
    team?: Schemas.ACLAction[];
    teamAccessRequest?: Schemas.ACLAction[];
    teamFellowMembership?: Schemas.ACLAction[];
    teamInvite?: Schemas.ACLAction[];
    teamInviteCode?: Schemas.ACLAction[];
    teamJoin?: Schemas.ACLAction[];
    teamOwnMembership?: Schemas.ACLAction[];
    teamOwnMembershipDisconnectSAML?: Schemas.ACLAction[];
    token?: Schemas.ACLAction[];
    usage?: Schemas.ACLAction[];
    user?: Schemas.ACLAction[];
    userConnection?: Schemas.ACLAction[];
    webAnalytics?: Schemas.ACLAction[];
    webAnalyticsPlan?: Schemas.ACLAction[];
    edgeConfig?: Schemas.ACLAction[];
    edgeConfigItem?: Schemas.ACLAction[];
    edgeConfigToken?: Schemas.ACLAction[];
    webhook?: Schemas.ACLAction[];
    ['webhook-event']?: Schemas.ACLAction[];
    endpointVerification?: Schemas.ACLAction[];
    aliasProtectionBypass?: Schemas.ACLAction[];
  };
  lastRollbackTarget?: {
    fromDeploymentId: string;
    toDeploymentId: string;
    jobStatus: 'succeeded' | 'failed' | 'skipped' | 'pending' | 'in-progress';
    requestedAt: number;
  } | null;
  hasFloatingAliases?: boolean;
  /**
   * Construct a type with a set of properties K of type T
   */
  protectionBypass?: {
    [key: string]: string;
  };
  hasActiveBranches?: boolean;
  ipAllowlist?: {
    deploymentType: 'preview' | 'all';
    ipAddresses: string[];
    protectionMode: 'additional' | 'exclusive';
  } | null;
};

export type CreateProjectVariables = {
  queryParams?: CreateProjectQueryParams;
} & FetcherExtraProps;

/**
 * Allows to create a new project with the provided configuration. It only requires the project `name` but more configuration can be provided to override the defaults.
 */
export const createProject = (variables: CreateProjectVariables, signal?: AbortSignal) =>
  fetch<CreateProjectResponse, CreateProjectError, undefined, {}, CreateProjectQueryParams, {}>({
    url: '/v9/projects',
    method: 'post',
    ...variables,
    signal
  });

export type GetProjectQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetProjectError = Fetcher.ErrorWrapper<undefined>;

export type GetProjectResponse = {
  accountId: string;
  analytics?: {
    id: string;
    canceledAt: number | null;
    disabledAt: number;
    enabledAt: number;
    paidAt?: number;
    sampleRatePercent?: number | null;
    spendLimitInDollars?: number | null;
  };
  autoExposeSystemEnvs?: boolean;
  buildCommand?: string | null;
  commandForIgnoringBuildStep?: string | null;
  connectConfigurationId?: string | null;
  connectBuildsEnabled?: boolean;
  createdAt?: number;
  devCommand?: string | null;
  directoryListing: boolean;
  installCommand?: string | null;
  env?: {
    target?:
      | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
      | ('production' | 'preview' | 'development' | 'preview' | 'development');
    type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
    id?: string;
    key: string;
    value: string;
    configurationId?: string | null;
    createdAt?: number;
    updatedAt?: number;
    createdBy?: string | null;
    updatedBy?: string | null;
    gitBranch?: string;
    edgeConfigId?: string | null;
    edgeConfigTokenId?: string | null;
    contentHint?:
      | {
          type: 'redis-url';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-url';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-token';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-read-only-token';
          storeId: string;
        }
      | {
          type: 'blob-read-write-token';
          storeId: string;
        }
      | {
          type: 'postgres-url';
          storeId: string;
        }
      | {
          type: 'postgres-url-non-pooling';
          storeId: string;
        }
      | {
          type: 'postgres-prisma-url';
          storeId: string;
        }
      | {
          type: 'postgres-user';
          storeId: string;
        }
      | {
          type: 'postgres-host';
          storeId: string;
        }
      | {
          type: 'postgres-password';
          storeId: string;
        }
      | {
          type: 'postgres-database';
          storeId: string;
        }
      | null;
    /**
     * Whether `value` is decrypted.
     */
    decrypted?: boolean;
  }[];
  framework?:
    | 'blitzjs'
    | 'nextjs'
    | 'gatsby'
    | 'remix'
    | 'astro'
    | 'hexo'
    | 'eleventy'
    | 'docusaurus-2'
    | 'docusaurus'
    | 'preact'
    | 'solidstart'
    | 'dojo'
    | 'ember'
    | 'vue'
    | 'scully'
    | 'ionic-angular'
    | 'angular'
    | 'polymer'
    | 'svelte'
    | 'sveltekit'
    | 'sveltekit-1'
    | 'ionic-react'
    | 'create-react-app'
    | 'gridsome'
    | 'umijs'
    | 'sapper'
    | 'saber'
    | 'stencil'
    | 'nuxtjs'
    | 'redwoodjs'
    | 'hugo'
    | 'jekyll'
    | 'brunch'
    | 'middleman'
    | 'zola'
    | 'hydrogen'
    | 'vite'
    | 'vitepress'
    | 'vuepress'
    | 'parcel'
    | 'sanity'
    | null;
  gitForkProtection?: boolean;
  gitLFS?: boolean;
  id: string;
  latestDeployments?: {
    alias?: string[];
    aliasAssigned?: number | boolean | null;
    aliasError?: {
      code: string;
      message: string;
    } | null;
    aliasFinal?: string | null;
    automaticAliases?: string[];
    builds?: {
      use: string;
      src?: string;
      dest?: string;
    }[];
    connectConfigurationId?: string;
    createdAt: number;
    createdIn: string;
    creator: {
      email: string;
      githubLogin?: string;
      gitlabLogin?: string;
      uid: string;
      username: string;
    } | null;
    deploymentHostname: string;
    name: string;
    forced?: boolean;
    id: string;
    /**
     * Construct a type with a set of properties K of type T
     */
    meta?: {
      [key: string]: string;
    };
    monorepoManager?: string | null;
    plan: 'hobby' | 'enterprise' | 'pro' | 'oss';
    private: boolean;
    readyState: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED';
    requestedAt?: number;
    target?: string | null;
    teamId?: string | null;
    type: 'LAMBDAS';
    url: string;
    userId: string;
    withCache?: boolean;
    checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
    checksState?: 'registered' | 'running' | 'completed';
    readyAt?: number;
    buildingAt?: number;
    /**
     * Whether or not preview comments are enabled for the deployment
     *
     * @example false
     */
    previewCommentsEnabled?: boolean;
  }[];
  link?:
    | {
        org?: string;
        repo?: string;
        repoId?: number;
        type?: 'github';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        projectId?: string;
        projectName?: string;
        projectNameWithNamespace?: string;
        projectNamespace?: string;
        projectUrl?: string;
        type?: 'gitlab';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        name?: string;
        slug?: string;
        owner?: string;
        type?: 'bitbucket';
        uuid?: string;
        workspaceUuid?: string;
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      };
  name: string;
  nodeVersion: '18.x' | '16.x' | '14.x' | '12.x' | '10.x';
  outputDirectory?: string | null;
  passwordProtection?: {
    deploymentType: 'preview' | 'all';
  } | null;
  publicSource?: boolean | null;
  rootDirectory?: string | null;
  serverlessFunctionRegion?: string | null;
  skipGitConnectDuringLink?: boolean;
  sourceFilesOutsideRootDirectory?: boolean;
  ssoProtection?: {
    deploymentType: 'preview' | 'all';
  } | null;
  /**
   * An object containing the deployment's metadata
   *
   * @example {"foo":"bar"}
   */
  targets?: {
    [key: string]: string;
  };
  transferCompletedAt?: number;
  transferStartedAt?: number;
  transferToAccountId?: string;
  transferredFromAccountId?: string;
  updatedAt?: number;
  live?: boolean;
  enablePreviewFeedback?: boolean | null;
  permissions?: {
    aliasGlobal?: Schemas.ACLAction[];
    aliasProject?: Schemas.ACLAction[];
    analytics?: Schemas.ACLAction[];
    analyticsSampling?: Schemas.ACLAction[];
    analyticsUsage?: Schemas.ACLAction[];
    auditLog?: Schemas.ACLAction[];
    billingAddress?: Schemas.ACLAction[];
    billingInformation?: Schemas.ACLAction[];
    billingInvoice?: Schemas.ACLAction[];
    billingInvoiceEmailRecipient?: Schemas.ACLAction[];
    billingInvoiceLanguage?: Schemas.ACLAction[];
    billingPlan?: Schemas.ACLAction[];
    billingPurchaseOrder?: Schemas.ACLAction[];
    billingTaxId?: Schemas.ACLAction[];
    blob?: Schemas.ACLAction[];
    cacheArtifact?: Schemas.ACLAction[];
    cacheArtifactUsageEvent?: Schemas.ACLAction[];
    concurrentBuilds?: Schemas.ACLAction[];
    connect?: Schemas.ACLAction[];
    connectConfiguration?: Schemas.ACLAction[];
    connectConfigurationLink?: Schemas.ACLAction[];
    deployment?: Schemas.ACLAction[];
    deploymentProductionGit?: Schemas.ACLAction[];
    deploymentCheck?: Schemas.ACLAction[];
    deploymentCheckPreview?: Schemas.ACLAction[];
    deploymentPreview?: Schemas.ACLAction[];
    deploymentPrivate?: Schemas.ACLAction[];
    deploymentCheckReRunFromProductionBranch?: Schemas.ACLAction[];
    deploymentRollback?: Schemas.ACLAction[];
    domain?: Schemas.ACLAction[];
    domainAcceptDelegation?: Schemas.ACLAction[];
    domainAuthCodes?: Schemas.ACLAction[];
    domainCertificate?: Schemas.ACLAction[];
    domainCheckConfig?: Schemas.ACLAction[];
    domainMove?: Schemas.ACLAction[];
    domainPurchase?: Schemas.ACLAction[];
    domainRecord?: Schemas.ACLAction[];
    domainTransferIn?: Schemas.ACLAction[];
    event?: Schemas.ACLAction[];
    sensitiveEnvironmentVariablePolicy?: Schemas.ACLAction[];
    fileUpload?: Schemas.ACLAction[];
    gitRepository?: Schemas.ACLAction[];
    ipBlocking?: Schemas.ACLAction[];
    ipAllowlist?: Schemas.ACLAction[];
    integration?: Schemas.ACLAction[];
    integrationConfiguration?: Schemas.ACLAction[];
    integrationConfigurationTransfer?: Schemas.ACLAction[];
    integrationConfigurationProjects?: Schemas.ACLAction[];
    integrationVercelConfigurationOverride?: Schemas.ACLAction[];
    job?: Schemas.ACLAction[];
    logDrain?: Schemas.ACLAction[];
    Monitoring?: Schemas.ACLAction[];
    monitoringQuery?: Schemas.ACLAction[];
    monitoringChart?: Schemas.ACLAction[];
    notificationDomainConfiguration?: Schemas.ACLAction[];
    notificationDomainExpire?: Schemas.ACLAction[];
    notificationDomainMoved?: Schemas.ACLAction[];
    notificationDomainPurchase?: Schemas.ACLAction[];
    notificationDomainRenewal?: Schemas.ACLAction[];
    notificationDomainTransfer?: Schemas.ACLAction[];
    notificationDomainUnverified?: Schemas.ACLAction[];
    notificationPaymentFailed?: Schemas.ACLAction[];
    notificationUsageAlert?: Schemas.ACLAction[];
    notificationSpendCap?: Schemas.ACLAction[];
    openTelemetryEndpoint?: Schemas.ACLAction[];
    passwordProtection?: Schemas.ACLAction[];
    paymentMethod?: Schemas.ACLAction[];
    permissions?: Schemas.ACLAction[];
    postgres?: Schemas.ACLAction[];
    previewDeploymentSuffix?: Schemas.ACLAction[];
    proTrialOnboarding?: Schemas.ACLAction[];
    project?: Schemas.ACLAction[];
    projectDeploymentHook?: Schemas.ACLAction[];
    projectDomain?: Schemas.ACLAction[];
    projectDomainMove?: Schemas.ACLAction[];
    projectEnvVars?: Schemas.ACLAction[];
    projectEnvVarsUnownedByIntegration?: Schemas.ACLAction[];
    sharedEnvVars?: Schemas.ACLAction[];
    projectEnvVarsProduction?: Schemas.ACLAction[];
    sharedEnvVarsProduction?: Schemas.ACLAction[];
    projectIntegrationConfiguration?: Schemas.ACLAction[];
    projectLink?: Schemas.ACLAction[];
    projectMember?: Schemas.ACLAction[];
    projectProductionBranch?: Schemas.ACLAction[];
    projectTransfer?: Schemas.ACLAction[];
    projectProtectionBypass?: Schemas.ACLAction[];
    rateLimit?: Schemas.ACLAction[];
    redis?: Schemas.ACLAction[];
    remoteCaching?: Schemas.ACLAction[];
    samlConfig?: Schemas.ACLAction[];
    secret?: Schemas.ACLAction[];
    spendCapConfiguration?: Schemas.ACLAction[];
    spendCapState?: Schemas.ACLAction[];
    supportCase?: Schemas.ACLAction[];
    supportCaseComment?: Schemas.ACLAction[];
    DataCacheNamespace?: Schemas.ACLAction[];
    team?: Schemas.ACLAction[];
    teamAccessRequest?: Schemas.ACLAction[];
    teamFellowMembership?: Schemas.ACLAction[];
    teamInvite?: Schemas.ACLAction[];
    teamInviteCode?: Schemas.ACLAction[];
    teamJoin?: Schemas.ACLAction[];
    teamOwnMembership?: Schemas.ACLAction[];
    teamOwnMembershipDisconnectSAML?: Schemas.ACLAction[];
    token?: Schemas.ACLAction[];
    usage?: Schemas.ACLAction[];
    user?: Schemas.ACLAction[];
    userConnection?: Schemas.ACLAction[];
    webAnalytics?: Schemas.ACLAction[];
    webAnalyticsPlan?: Schemas.ACLAction[];
    edgeConfig?: Schemas.ACLAction[];
    edgeConfigItem?: Schemas.ACLAction[];
    edgeConfigToken?: Schemas.ACLAction[];
    webhook?: Schemas.ACLAction[];
    ['webhook-event']?: Schemas.ACLAction[];
    endpointVerification?: Schemas.ACLAction[];
    aliasProtectionBypass?: Schemas.ACLAction[];
  };
  lastRollbackTarget?: {
    fromDeploymentId: string;
    toDeploymentId: string;
    jobStatus: 'succeeded' | 'failed' | 'skipped' | 'pending' | 'in-progress';
    requestedAt: number;
  } | null;
  hasFloatingAliases?: boolean;
  /**
   * Construct a type with a set of properties K of type T
   */
  protectionBypass?: {
    [key: string]: string;
  };
  hasActiveBranches?: boolean;
  ipAllowlist?: {
    deploymentType: 'preview' | 'all';
    ipAddresses: string[];
    protectionMode: 'additional' | 'exclusive';
  } | null;
};

export type GetProjectVariables = {
  queryParams?: GetProjectQueryParams;
} & FetcherExtraProps;

/**
 * Get the information for a specific project by passing either the project `id` or `name` in the URL.
 */
export const getProject = (variables: GetProjectVariables, signal?: AbortSignal) =>
  fetch<GetProjectResponse, GetProjectError, undefined, {}, GetProjectQueryParams, {}>({
    url: '/v9/projects/{idOrName}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateProjectQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type UpdateProjectError = Fetcher.ErrorWrapper<undefined>;

export type UpdateProjectResponse = {
  accountId: string;
  analytics?: {
    id: string;
    canceledAt: number | null;
    disabledAt: number;
    enabledAt: number;
    paidAt?: number;
    sampleRatePercent?: number | null;
    spendLimitInDollars?: number | null;
  };
  autoExposeSystemEnvs?: boolean;
  buildCommand?: string | null;
  commandForIgnoringBuildStep?: string | null;
  connectConfigurationId?: string | null;
  connectBuildsEnabled?: boolean;
  createdAt?: number;
  devCommand?: string | null;
  directoryListing: boolean;
  installCommand?: string | null;
  env?: {
    target?:
      | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
      | ('production' | 'preview' | 'development' | 'preview' | 'development');
    type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
    id?: string;
    key: string;
    value: string;
    configurationId?: string | null;
    createdAt?: number;
    updatedAt?: number;
    createdBy?: string | null;
    updatedBy?: string | null;
    gitBranch?: string;
    edgeConfigId?: string | null;
    edgeConfigTokenId?: string | null;
    contentHint?:
      | {
          type: 'redis-url';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-url';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-token';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-read-only-token';
          storeId: string;
        }
      | {
          type: 'blob-read-write-token';
          storeId: string;
        }
      | {
          type: 'postgres-url';
          storeId: string;
        }
      | {
          type: 'postgres-url-non-pooling';
          storeId: string;
        }
      | {
          type: 'postgres-prisma-url';
          storeId: string;
        }
      | {
          type: 'postgres-user';
          storeId: string;
        }
      | {
          type: 'postgres-host';
          storeId: string;
        }
      | {
          type: 'postgres-password';
          storeId: string;
        }
      | {
          type: 'postgres-database';
          storeId: string;
        }
      | null;
    /**
     * Whether `value` is decrypted.
     */
    decrypted?: boolean;
  }[];
  framework?:
    | 'blitzjs'
    | 'nextjs'
    | 'gatsby'
    | 'remix'
    | 'astro'
    | 'hexo'
    | 'eleventy'
    | 'docusaurus-2'
    | 'docusaurus'
    | 'preact'
    | 'solidstart'
    | 'dojo'
    | 'ember'
    | 'vue'
    | 'scully'
    | 'ionic-angular'
    | 'angular'
    | 'polymer'
    | 'svelte'
    | 'sveltekit'
    | 'sveltekit-1'
    | 'ionic-react'
    | 'create-react-app'
    | 'gridsome'
    | 'umijs'
    | 'sapper'
    | 'saber'
    | 'stencil'
    | 'nuxtjs'
    | 'redwoodjs'
    | 'hugo'
    | 'jekyll'
    | 'brunch'
    | 'middleman'
    | 'zola'
    | 'hydrogen'
    | 'vite'
    | 'vitepress'
    | 'vuepress'
    | 'parcel'
    | 'sanity'
    | null;
  gitForkProtection?: boolean;
  gitLFS?: boolean;
  id: string;
  latestDeployments?: {
    alias?: string[];
    aliasAssigned?: number | boolean | null;
    aliasError?: {
      code: string;
      message: string;
    } | null;
    aliasFinal?: string | null;
    automaticAliases?: string[];
    builds?: {
      use: string;
      src?: string;
      dest?: string;
    }[];
    connectConfigurationId?: string;
    createdAt: number;
    createdIn: string;
    creator: {
      email: string;
      githubLogin?: string;
      gitlabLogin?: string;
      uid: string;
      username: string;
    } | null;
    deploymentHostname: string;
    name: string;
    forced?: boolean;
    id: string;
    /**
     * Construct a type with a set of properties K of type T
     */
    meta?: {
      [key: string]: string;
    };
    monorepoManager?: string | null;
    plan: 'hobby' | 'enterprise' | 'pro' | 'oss';
    private: boolean;
    readyState: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED';
    requestedAt?: number;
    target?: string | null;
    teamId?: string | null;
    type: 'LAMBDAS';
    url: string;
    userId: string;
    withCache?: boolean;
    checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
    checksState?: 'registered' | 'running' | 'completed';
    readyAt?: number;
    buildingAt?: number;
    /**
     * Whether or not preview comments are enabled for the deployment
     *
     * @example false
     */
    previewCommentsEnabled?: boolean;
  }[];
  link?:
    | {
        org?: string;
        repo?: string;
        repoId?: number;
        type?: 'github';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        projectId?: string;
        projectName?: string;
        projectNameWithNamespace?: string;
        projectNamespace?: string;
        projectUrl?: string;
        type?: 'gitlab';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        name?: string;
        slug?: string;
        owner?: string;
        type?: 'bitbucket';
        uuid?: string;
        workspaceUuid?: string;
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      };
  name: string;
  nodeVersion: '18.x' | '16.x' | '14.x' | '12.x' | '10.x';
  outputDirectory?: string | null;
  passwordProtection?: {
    deploymentType: 'all' | 'preview';
  } | null;
  publicSource?: boolean | null;
  rootDirectory?: string | null;
  serverlessFunctionRegion?: string | null;
  skipGitConnectDuringLink?: boolean;
  sourceFilesOutsideRootDirectory?: boolean;
  ssoProtection?: {
    deploymentType: 'all' | 'preview';
  } | null;
  /**
   * An object containing the deployment's metadata
   *
   * @example {"foo":"bar"}
   */
  targets?: {
    [key: string]: string;
  };
  transferCompletedAt?: number;
  transferStartedAt?: number;
  transferToAccountId?: string;
  transferredFromAccountId?: string;
  updatedAt?: number;
  live?: boolean;
  enablePreviewFeedback?: boolean | null;
  permissions?: {
    aliasGlobal?: Schemas.ACLAction[];
    aliasProject?: Schemas.ACLAction[];
    analytics?: Schemas.ACLAction[];
    analyticsSampling?: Schemas.ACLAction[];
    analyticsUsage?: Schemas.ACLAction[];
    auditLog?: Schemas.ACLAction[];
    billingAddress?: Schemas.ACLAction[];
    billingInformation?: Schemas.ACLAction[];
    billingInvoice?: Schemas.ACLAction[];
    billingInvoiceEmailRecipient?: Schemas.ACLAction[];
    billingInvoiceLanguage?: Schemas.ACLAction[];
    billingPlan?: Schemas.ACLAction[];
    billingPurchaseOrder?: Schemas.ACLAction[];
    billingTaxId?: Schemas.ACLAction[];
    blob?: Schemas.ACLAction[];
    cacheArtifact?: Schemas.ACLAction[];
    cacheArtifactUsageEvent?: Schemas.ACLAction[];
    concurrentBuilds?: Schemas.ACLAction[];
    connect?: Schemas.ACLAction[];
    connectConfiguration?: Schemas.ACLAction[];
    connectConfigurationLink?: Schemas.ACLAction[];
    deployment?: Schemas.ACLAction[];
    deploymentProductionGit?: Schemas.ACLAction[];
    deploymentCheck?: Schemas.ACLAction[];
    deploymentCheckPreview?: Schemas.ACLAction[];
    deploymentPreview?: Schemas.ACLAction[];
    deploymentPrivate?: Schemas.ACLAction[];
    deploymentCheckReRunFromProductionBranch?: Schemas.ACLAction[];
    deploymentRollback?: Schemas.ACLAction[];
    domain?: Schemas.ACLAction[];
    domainAcceptDelegation?: Schemas.ACLAction[];
    domainAuthCodes?: Schemas.ACLAction[];
    domainCertificate?: Schemas.ACLAction[];
    domainCheckConfig?: Schemas.ACLAction[];
    domainMove?: Schemas.ACLAction[];
    domainPurchase?: Schemas.ACLAction[];
    domainRecord?: Schemas.ACLAction[];
    domainTransferIn?: Schemas.ACLAction[];
    event?: Schemas.ACLAction[];
    sensitiveEnvironmentVariablePolicy?: Schemas.ACLAction[];
    fileUpload?: Schemas.ACLAction[];
    gitRepository?: Schemas.ACLAction[];
    ipBlocking?: Schemas.ACLAction[];
    ipAllowlist?: Schemas.ACLAction[];
    integration?: Schemas.ACLAction[];
    integrationConfiguration?: Schemas.ACLAction[];
    integrationConfigurationTransfer?: Schemas.ACLAction[];
    integrationConfigurationProjects?: Schemas.ACLAction[];
    integrationVercelConfigurationOverride?: Schemas.ACLAction[];
    job?: Schemas.ACLAction[];
    logDrain?: Schemas.ACLAction[];
    Monitoring?: Schemas.ACLAction[];
    monitoringQuery?: Schemas.ACLAction[];
    monitoringChart?: Schemas.ACLAction[];
    notificationDomainConfiguration?: Schemas.ACLAction[];
    notificationDomainExpire?: Schemas.ACLAction[];
    notificationDomainMoved?: Schemas.ACLAction[];
    notificationDomainPurchase?: Schemas.ACLAction[];
    notificationDomainRenewal?: Schemas.ACLAction[];
    notificationDomainTransfer?: Schemas.ACLAction[];
    notificationDomainUnverified?: Schemas.ACLAction[];
    notificationPaymentFailed?: Schemas.ACLAction[];
    notificationUsageAlert?: Schemas.ACLAction[];
    notificationSpendCap?: Schemas.ACLAction[];
    openTelemetryEndpoint?: Schemas.ACLAction[];
    passwordProtection?: Schemas.ACLAction[];
    paymentMethod?: Schemas.ACLAction[];
    permissions?: Schemas.ACLAction[];
    postgres?: Schemas.ACLAction[];
    previewDeploymentSuffix?: Schemas.ACLAction[];
    proTrialOnboarding?: Schemas.ACLAction[];
    project?: Schemas.ACLAction[];
    projectDeploymentHook?: Schemas.ACLAction[];
    projectDomain?: Schemas.ACLAction[];
    projectDomainMove?: Schemas.ACLAction[];
    projectEnvVars?: Schemas.ACLAction[];
    projectEnvVarsUnownedByIntegration?: Schemas.ACLAction[];
    sharedEnvVars?: Schemas.ACLAction[];
    projectEnvVarsProduction?: Schemas.ACLAction[];
    sharedEnvVarsProduction?: Schemas.ACLAction[];
    projectIntegrationConfiguration?: Schemas.ACLAction[];
    projectLink?: Schemas.ACLAction[];
    projectMember?: Schemas.ACLAction[];
    projectProductionBranch?: Schemas.ACLAction[];
    projectTransfer?: Schemas.ACLAction[];
    projectProtectionBypass?: Schemas.ACLAction[];
    rateLimit?: Schemas.ACLAction[];
    redis?: Schemas.ACLAction[];
    remoteCaching?: Schemas.ACLAction[];
    samlConfig?: Schemas.ACLAction[];
    secret?: Schemas.ACLAction[];
    spendCapConfiguration?: Schemas.ACLAction[];
    spendCapState?: Schemas.ACLAction[];
    supportCase?: Schemas.ACLAction[];
    supportCaseComment?: Schemas.ACLAction[];
    DataCacheNamespace?: Schemas.ACLAction[];
    team?: Schemas.ACLAction[];
    teamAccessRequest?: Schemas.ACLAction[];
    teamFellowMembership?: Schemas.ACLAction[];
    teamInvite?: Schemas.ACLAction[];
    teamInviteCode?: Schemas.ACLAction[];
    teamJoin?: Schemas.ACLAction[];
    teamOwnMembership?: Schemas.ACLAction[];
    teamOwnMembershipDisconnectSAML?: Schemas.ACLAction[];
    token?: Schemas.ACLAction[];
    usage?: Schemas.ACLAction[];
    user?: Schemas.ACLAction[];
    userConnection?: Schemas.ACLAction[];
    webAnalytics?: Schemas.ACLAction[];
    webAnalyticsPlan?: Schemas.ACLAction[];
    edgeConfig?: Schemas.ACLAction[];
    edgeConfigItem?: Schemas.ACLAction[];
    edgeConfigToken?: Schemas.ACLAction[];
    webhook?: Schemas.ACLAction[];
    ['webhook-event']?: Schemas.ACLAction[];
    endpointVerification?: Schemas.ACLAction[];
    aliasProtectionBypass?: Schemas.ACLAction[];
  };
  lastRollbackTarget?: {
    fromDeploymentId: string;
    toDeploymentId: string;
    jobStatus: 'succeeded' | 'failed' | 'skipped' | 'pending' | 'in-progress';
    requestedAt: number;
  } | null;
  hasFloatingAliases?: boolean;
  /**
   * Construct a type with a set of properties K of type T
   */
  protectionBypass?: {
    [key: string]: string;
  };
  hasActiveBranches?: boolean;
  ipAllowlist?: {
    deploymentType: 'all' | 'preview';
    ipAddresses: string[];
    protectionMode: 'exclusive' | 'additional';
  } | null;
};

export type UpdateProjectVariables = {
  queryParams?: UpdateProjectQueryParams;
} & FetcherExtraProps;

/**
 * Update the fields of a project using either its `name` or `id`.
 */
export const updateProject = (variables: UpdateProjectVariables, signal?: AbortSignal) =>
  fetch<UpdateProjectResponse, UpdateProjectError, undefined, {}, UpdateProjectQueryParams, {}>({
    url: '/v9/projects/{idOrName}',
    method: 'patch',
    ...variables,
    signal
  });

export type DeleteProjectQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteProjectError = Fetcher.ErrorWrapper<undefined>;

export type DeleteProjectVariables = {
  queryParams?: DeleteProjectQueryParams;
} & FetcherExtraProps;

/**
 * Delete a specific project by passing either the project `id` or `name` in the URL.
 */
export const deleteProject = (variables: DeleteProjectVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteProjectError, undefined, {}, DeleteProjectQueryParams, {}>({
    url: '/v9/projects/{idOrName}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetProjectDomainsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetProjectDomainsError = Fetcher.ErrorWrapper<undefined>;

export type GetProjectDomainsResponse = {
  domains: {
    name: string;
    apexName: string;
    projectId: string;
    redirect?: string | null;
    redirectStatusCode?: 307 | 301 | 302 | 308 | null;
    gitBranch?: string | null;
    updatedAt?: number;
    createdAt?: number;
    /**
     * `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.
     */
    verified: boolean;
    /**
     * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
     */
    verification?: {
      type: string;
      domain: string;
      value: string;
      reason: string;
    }[];
  }[];
  pagination: Schemas.Pagination;
};

export type GetProjectDomainsVariables = {
  queryParams?: GetProjectDomainsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieve the domains associated with a given project by passing either the project `id` or `name` in the URL.
 */
export const getProjectDomains = (variables: GetProjectDomainsVariables, signal?: AbortSignal) =>
  fetch<GetProjectDomainsResponse, GetProjectDomainsError, undefined, {}, GetProjectDomainsQueryParams, {}>({
    url: '/v9/projects/{idOrName}/domains',
    method: 'get',
    ...variables,
    signal
  });

export type GetProjectDomainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetProjectDomainError = Fetcher.ErrorWrapper<undefined>;

export type GetProjectDomainResponse = {
  name: string;
  apexName: string;
  projectId: string;
  redirect?: string | null;
  redirectStatusCode?: 307 | 301 | 302 | 308 | null;
  gitBranch?: string | null;
  updatedAt?: number;
  createdAt?: number;
  /**
   * `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.
   */
  verified: boolean;
  /**
   * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
   */
  verification?: {
    type: string;
    domain: string;
    value: string;
    reason: string;
  }[];
};

export type GetProjectDomainVariables = {
  queryParams?: GetProjectDomainQueryParams;
} & FetcherExtraProps;

/**
 * Get project domain by project id/name and domain name.
 */
export const getProjectDomain = (variables: GetProjectDomainVariables, signal?: AbortSignal) =>
  fetch<GetProjectDomainResponse, GetProjectDomainError, undefined, {}, GetProjectDomainQueryParams, {}>({
    url: '/v9/projects/{idOrName}/domains/{domain}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateProjectDomainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type UpdateProjectDomainError = Fetcher.ErrorWrapper<undefined>;

export type UpdateProjectDomainResponse = {
  name: string;
  apexName: string;
  projectId: string;
  redirect?: string | null;
  redirectStatusCode?: 307 | 301 | 302 | 308 | null;
  gitBranch?: string | null;
  updatedAt?: number;
  createdAt?: number;
  /**
   * `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.
   */
  verified: boolean;
  /**
   * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
   */
  verification?: {
    type: string;
    domain: string;
    value: string;
    reason: string;
  }[];
};

export type UpdateProjectDomainVariables = {
  queryParams?: UpdateProjectDomainQueryParams;
} & FetcherExtraProps;

/**
 * Update a project domain's configuration, including the name, git branch and redirect of the domain.
 */
export const updateProjectDomain = (variables: UpdateProjectDomainVariables, signal?: AbortSignal) =>
  fetch<UpdateProjectDomainResponse, UpdateProjectDomainError, undefined, {}, UpdateProjectDomainQueryParams, {}>({
    url: '/v9/projects/{idOrName}/domains/{domain}',
    method: 'patch',
    ...variables,
    signal
  });

export type RemoveProjectDomainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type RemoveProjectDomainError = Fetcher.ErrorWrapper<undefined>;

export type RemoveProjectDomainVariables = {
  queryParams?: RemoveProjectDomainQueryParams;
} & FetcherExtraProps;

/**
 * Remove a domain from a project by passing the domain name and by specifying the project by either passing the project `id` or `name` in the URL.
 */
export const removeProjectDomain = (variables: RemoveProjectDomainVariables, signal?: AbortSignal) =>
  fetch<Record<string, any>, RemoveProjectDomainError, undefined, {}, RemoveProjectDomainQueryParams, {}>({
    url: '/v9/projects/{idOrName}/domains/{domain}',
    method: 'delete',
    ...variables,
    signal
  });

export type AddProjectDomainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type AddProjectDomainError = Fetcher.ErrorWrapper<undefined>;

export type AddProjectDomainResponse = {
  name: string;
  apexName: string;
  projectId: string;
  redirect?: string | null;
  redirectStatusCode?: 307 | 301 | 302 | 308 | null;
  gitBranch?: string | null;
  updatedAt?: number;
  createdAt?: number;
  /**
   * `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.
   */
  verified: boolean;
  /**
   * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
   */
  verification?: {
    type: string;
    domain: string;
    value: string;
    reason: string;
  }[];
};

export type AddProjectDomainVariables = {
  queryParams?: AddProjectDomainQueryParams;
} & FetcherExtraProps;

/**
 * Add a domain to the project by passing its domain name and by specifying the project by either passing the project `id` or `name` in the URL. If the domain is not yet verified to be used on this project, the request will return `verified = false`, and the domain will need to be verified according to the `verification` challenge via `POST /projects/:idOrName/domains/:domain/verify`. If the domain already exists on the project, the request will fail with a `400` status code.
 */
export const addProjectDomain = (variables: AddProjectDomainVariables, signal?: AbortSignal) =>
  fetch<AddProjectDomainResponse, AddProjectDomainError, undefined, {}, AddProjectDomainQueryParams, {}>({
    url: '/v10/projects/{idOrName}/domains',
    method: 'post',
    ...variables,
    signal
  });

export type VerifyProjectDomainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type VerifyProjectDomainError = Fetcher.ErrorWrapper<undefined>;

export type VerifyProjectDomainResponse = {
  name: string;
  apexName: string;
  projectId: string;
  redirect?: string | null;
  redirectStatusCode?: 307 | 301 | 302 | 308 | null;
  gitBranch?: string | null;
  updatedAt?: number;
  createdAt?: number;
  /**
   * `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.
   */
  verified: boolean;
  /**
   * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
   */
  verification?: {
    type: string;
    domain: string;
    value: string;
    reason: string;
  }[];
};

export type VerifyProjectDomainVariables = {
  queryParams?: VerifyProjectDomainQueryParams;
} & FetcherExtraProps;

/**
 * Attempts to verify a project domain with `verified = false` by checking the correctness of the project domain's `verification` challenge.
 */
export const verifyProjectDomain = (variables: VerifyProjectDomainVariables, signal?: AbortSignal) =>
  fetch<VerifyProjectDomainResponse, VerifyProjectDomainError, undefined, {}, VerifyProjectDomainQueryParams, {}>({
    url: '/v9/projects/{idOrName}/domains/{domain}/verify',
    method: 'post',
    ...variables,
    signal
  });

export type FilterProjectEnvsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type FilterProjectEnvsError = Fetcher.ErrorWrapper<undefined>;

export type FilterProjectEnvsVariables = {
  queryParams?: FilterProjectEnvsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieve the environment variables for a given project by passing either the project `id` or `name` in the URL.
 */
export const filterProjectEnvs = (variables: FilterProjectEnvsVariables, signal?: AbortSignal) =>
  fetch<
    | {
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development');
        type?: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
        id?: string;
        key?: string;
        value?: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        contentHint?:
          | {
              type: 'redis-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-token';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-read-only-token';
              storeId: string;
            }
          | {
              type: 'blob-read-write-token';
              storeId: string;
            }
          | {
              type: 'postgres-url';
              storeId: string;
            }
          | {
              type: 'postgres-url-non-pooling';
              storeId: string;
            }
          | {
              type: 'postgres-prisma-url';
              storeId: string;
            }
          | {
              type: 'postgres-user';
              storeId: string;
            }
          | {
              type: 'postgres-host';
              storeId: string;
            }
          | {
              type: 'postgres-password';
              storeId: string;
            }
          | {
              type: 'postgres-database';
              storeId: string;
            }
          | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
        system?: boolean;
      }
    | {
        envs: {
          target?:
            | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
            | ('production' | 'preview' | 'development' | 'preview' | 'development');
          type?: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
          id?: string;
          key?: string;
          value?: string;
          configurationId?: string | null;
          createdAt?: number;
          updatedAt?: number;
          createdBy?: string | null;
          updatedBy?: string | null;
          gitBranch?: string;
          edgeConfigId?: string | null;
          edgeConfigTokenId?: string | null;
          contentHint?:
            | {
                type: 'redis-url';
                storeId: string;
              }
            | {
                type: 'redis-rest-api-url';
                storeId: string;
              }
            | {
                type: 'redis-rest-api-token';
                storeId: string;
              }
            | {
                type: 'redis-rest-api-read-only-token';
                storeId: string;
              }
            | {
                type: 'blob-read-write-token';
                storeId: string;
              }
            | {
                type: 'postgres-url';
                storeId: string;
              }
            | {
                type: 'postgres-url-non-pooling';
                storeId: string;
              }
            | {
                type: 'postgres-prisma-url';
                storeId: string;
              }
            | {
                type: 'postgres-user';
                storeId: string;
              }
            | {
                type: 'postgres-host';
                storeId: string;
              }
            | {
                type: 'postgres-password';
                storeId: string;
              }
            | {
                type: 'postgres-database';
                storeId: string;
              }
            | null;
          /**
           * Whether `value` is decrypted.
           */
          decrypted?: boolean;
          system?: boolean;
        }[];
        pagination: Schemas.Pagination;
      }
    | {
        envs: {
          target?:
            | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
            | ('production' | 'preview' | 'development' | 'preview' | 'development');
          type?: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
          id?: string;
          key?: string;
          value?: string;
          configurationId?: string | null;
          createdAt?: number;
          updatedAt?: number;
          createdBy?: string | null;
          updatedBy?: string | null;
          gitBranch?: string;
          edgeConfigId?: string | null;
          edgeConfigTokenId?: string | null;
          contentHint?:
            | {
                type: 'redis-url';
                storeId: string;
              }
            | {
                type: 'redis-rest-api-url';
                storeId: string;
              }
            | {
                type: 'redis-rest-api-token';
                storeId: string;
              }
            | {
                type: 'redis-rest-api-read-only-token';
                storeId: string;
              }
            | {
                type: 'blob-read-write-token';
                storeId: string;
              }
            | {
                type: 'postgres-url';
                storeId: string;
              }
            | {
                type: 'postgres-url-non-pooling';
                storeId: string;
              }
            | {
                type: 'postgres-prisma-url';
                storeId: string;
              }
            | {
                type: 'postgres-user';
                storeId: string;
              }
            | {
                type: 'postgres-host';
                storeId: string;
              }
            | {
                type: 'postgres-password';
                storeId: string;
              }
            | {
                type: 'postgres-database';
                storeId: string;
              }
            | null;
          /**
           * Whether `value` is decrypted.
           */
          decrypted?: boolean;
          system?: boolean;
        }[];
      },
    FilterProjectEnvsError,
    undefined,
    {},
    FilterProjectEnvsQueryParams,
    {}
  >({ url: '/v9/projects/{idOrName}/env', method: 'get', ...variables, signal });

export type GetProjectEnvQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetProjectEnvError = Fetcher.ErrorWrapper<undefined>;

export type GetProjectEnvResponse = {
  target?:
    | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
    | ('production' | 'preview' | 'development' | 'preview' | 'development');
  type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
  id?: string;
  key: string;
  value: string;
  configurationId?: string | null;
  createdAt?: number;
  updatedAt?: number;
  createdBy?: string | null;
  updatedBy?: string | null;
  gitBranch?: string;
  edgeConfigId?: string | null;
  edgeConfigTokenId?: string | null;
  contentHint?:
    | {
        type: 'redis-url';
        storeId: string;
      }
    | {
        type: 'redis-rest-api-url';
        storeId: string;
      }
    | {
        type: 'redis-rest-api-token';
        storeId: string;
      }
    | {
        type: 'redis-rest-api-read-only-token';
        storeId: string;
      }
    | {
        type: 'blob-read-write-token';
        storeId: string;
      }
    | {
        type: 'postgres-url';
        storeId: string;
      }
    | {
        type: 'postgres-url-non-pooling';
        storeId: string;
      }
    | {
        type: 'postgres-prisma-url';
        storeId: string;
      }
    | {
        type: 'postgres-user';
        storeId: string;
      }
    | {
        type: 'postgres-host';
        storeId: string;
      }
    | {
        type: 'postgres-password';
        storeId: string;
      }
    | {
        type: 'postgres-database';
        storeId: string;
      }
    | null;
  /**
   * Whether `value` is decrypted.
   */
  decrypted?: boolean;
};

export type GetProjectEnvVariables = {
  queryParams?: GetProjectEnvQueryParams;
} & FetcherExtraProps;

/**
 * Retrieve the environment variable for a given project.
 */
export const getProjectEnv = (variables: GetProjectEnvVariables, signal?: AbortSignal) =>
  fetch<GetProjectEnvResponse, GetProjectEnvError, undefined, {}, GetProjectEnvQueryParams, {}>({
    url: '/v1/projects/{idOrName}/env/{id}',
    method: 'get',
    ...variables,
    signal
  });

export type CreateProjectEnvQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateProjectEnvError = Fetcher.ErrorWrapper<undefined>;

export type CreateProjectEnvResponse = {
  created:
    | {
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
        type?: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
        id?: string;
        key?: string;
        value?: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        contentHint?:
          | {
              type: 'redis-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-token';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-read-only-token';
              storeId: string;
            }
          | {
              type: 'blob-read-write-token';
              storeId: string;
            }
          | {
              type: 'postgres-url';
              storeId: string;
            }
          | {
              type: 'postgres-url-non-pooling';
              storeId: string;
            }
          | {
              type: 'postgres-prisma-url';
              storeId: string;
            }
          | {
              type: 'postgres-user';
              storeId: string;
            }
          | {
              type: 'postgres-host';
              storeId: string;
            }
          | {
              type: 'postgres-password';
              storeId: string;
            }
          | {
              type: 'postgres-database';
              storeId: string;
            }
          | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
        system?: boolean;
      }
    | {
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
        type?: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
        id?: string;
        key?: string;
        value?: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        contentHint?:
          | {
              type: 'redis-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-token';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-read-only-token';
              storeId: string;
            }
          | {
              type: 'blob-read-write-token';
              storeId: string;
            }
          | {
              type: 'postgres-url';
              storeId: string;
            }
          | {
              type: 'postgres-url-non-pooling';
              storeId: string;
            }
          | {
              type: 'postgres-prisma-url';
              storeId: string;
            }
          | {
              type: 'postgres-user';
              storeId: string;
            }
          | {
              type: 'postgres-host';
              storeId: string;
            }
          | {
              type: 'postgres-password';
              storeId: string;
            }
          | {
              type: 'postgres-database';
              storeId: string;
            }
          | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
        system?: boolean;
      }[];
  failed: {
    error: {
      code: string;
      message: string;
      key?: string;
      envVarId?: string;
      envVarKey?: string;
      action?: string;
      link?: string;
      value?:
        | string
        | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[];
      gitBranch?: string;
      target?:
        | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
        | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
      project?: string;
    };
  }[];
};

export type CreateProjectEnvVariables = {
  queryParams?: CreateProjectEnvQueryParams;
} & FetcherExtraProps;

/**
 * Create one ore more environment variables for a project by passing its `key`, `value`, `type` and `target` and by specifying the project by either passing the project `id` or `name` in the URL.
 */
export const createProjectEnv = (variables: CreateProjectEnvVariables, signal?: AbortSignal) =>
  fetch<CreateProjectEnvResponse, CreateProjectEnvError, undefined, {}, CreateProjectEnvQueryParams, {}>({
    url: '/v10/projects/{idOrName}/env',
    method: 'post',
    ...variables,
    signal
  });

export type RemoveProjectEnvQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type RemoveProjectEnvError = Fetcher.ErrorWrapper<undefined>;

export type RemoveProjectEnvVariables = {
  queryParams?: RemoveProjectEnvQueryParams;
} & FetcherExtraProps;

/**
 * Delete a specific environment variable for a given project by passing the environment variable identifier and either passing the project `id` or `name` in the URL.
 */
export const removeProjectEnv = (variables: RemoveProjectEnvVariables, signal?: AbortSignal) =>
  fetch<
    | {
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
        type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
        id?: string;
        key: string;
        value: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        contentHint?:
          | {
              type: 'redis-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-token';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-read-only-token';
              storeId: string;
            }
          | {
              type: 'blob-read-write-token';
              storeId: string;
            }
          | {
              type: 'postgres-url';
              storeId: string;
            }
          | {
              type: 'postgres-url-non-pooling';
              storeId: string;
            }
          | {
              type: 'postgres-prisma-url';
              storeId: string;
            }
          | {
              type: 'postgres-user';
              storeId: string;
            }
          | {
              type: 'postgres-host';
              storeId: string;
            }
          | {
              type: 'postgres-password';
              storeId: string;
            }
          | {
              type: 'postgres-database';
              storeId: string;
            }
          | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
      }[]
    | {
        system?: boolean;
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
        type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
        id?: string;
        key: string;
        value: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        contentHint?:
          | {
              type: 'redis-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-token';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-read-only-token';
              storeId: string;
            }
          | {
              type: 'blob-read-write-token';
              storeId: string;
            }
          | {
              type: 'postgres-url';
              storeId: string;
            }
          | {
              type: 'postgres-url-non-pooling';
              storeId: string;
            }
          | {
              type: 'postgres-prisma-url';
              storeId: string;
            }
          | {
              type: 'postgres-user';
              storeId: string;
            }
          | {
              type: 'postgres-host';
              storeId: string;
            }
          | {
              type: 'postgres-password';
              storeId: string;
            }
          | {
              type: 'postgres-database';
              storeId: string;
            }
          | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
      }
    | {
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
        type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
        id?: string;
        key: string;
        value: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        contentHint?:
          | {
              type: 'redis-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-token';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-read-only-token';
              storeId: string;
            }
          | {
              type: 'blob-read-write-token';
              storeId: string;
            }
          | {
              type: 'postgres-url';
              storeId: string;
            }
          | {
              type: 'postgres-url-non-pooling';
              storeId: string;
            }
          | {
              type: 'postgres-prisma-url';
              storeId: string;
            }
          | {
              type: 'postgres-user';
              storeId: string;
            }
          | {
              type: 'postgres-host';
              storeId: string;
            }
          | {
              type: 'postgres-password';
              storeId: string;
            }
          | {
              type: 'postgres-database';
              storeId: string;
            }
          | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
      },
    RemoveProjectEnvError,
    undefined,
    {},
    RemoveProjectEnvQueryParams,
    {}
  >({ url: '/v9/projects/{idOrName}/env/{id}', method: 'delete', ...variables, signal });

export type EditProjectEnvQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type EditProjectEnvError = Fetcher.ErrorWrapper<undefined>;

export type EditProjectEnvResponse = {
  target?:
    | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
    | ('production' | 'preview' | 'development' | 'preview' | 'development');
  type: 'system' | 'encrypted' | 'plain' | 'sensitive' | 'secret';
  id?: string;
  key: string;
  value: string;
  configurationId?: string | null;
  createdAt?: number;
  updatedAt?: number;
  createdBy?: string | null;
  updatedBy?: string | null;
  gitBranch?: string;
  edgeConfigId?: string | null;
  edgeConfigTokenId?: string | null;
  contentHint?:
    | {
        type: 'redis-url';
        storeId: string;
      }
    | {
        type: 'redis-rest-api-url';
        storeId: string;
      }
    | {
        type: 'redis-rest-api-token';
        storeId: string;
      }
    | {
        type: 'redis-rest-api-read-only-token';
        storeId: string;
      }
    | {
        type: 'blob-read-write-token';
        storeId: string;
      }
    | {
        type: 'postgres-url';
        storeId: string;
      }
    | {
        type: 'postgres-url-non-pooling';
        storeId: string;
      }
    | {
        type: 'postgres-prisma-url';
        storeId: string;
      }
    | {
        type: 'postgres-user';
        storeId: string;
      }
    | {
        type: 'postgres-host';
        storeId: string;
      }
    | {
        type: 'postgres-password';
        storeId: string;
      }
    | {
        type: 'postgres-database';
        storeId: string;
      }
    | null;
  /**
   * Whether `value` is decrypted.
   */
  decrypted?: boolean;
};

export type EditProjectEnvVariables = {
  queryParams?: EditProjectEnvQueryParams;
} & FetcherExtraProps;

/**
 * Edit a specific environment variable for a given project by passing the environment variable identifier and either passing the project `id` or `name` in the URL.
 */
export const editProjectEnv = (variables: EditProjectEnvVariables, signal?: AbortSignal) =>
  fetch<EditProjectEnvResponse, EditProjectEnvError, undefined, {}, EditProjectEnvQueryParams, {}>({
    url: '/v9/projects/{idOrName}/env/{id}',
    method: 'patch',
    ...variables,
    signal
  });

export type VerifyTokenError = Fetcher.ErrorWrapper<undefined>;

export type VerifyTokenResponse = {
  /**
   * The user authentication token that can be used to perform API requests.
   *
   * @example 1ioXyz9Ue4xdCYGROet1dlKd
   */
  token: string;
  /**
   * Email address of the authenticated user.
   *
   * @example amy@example.com
   */
  email: string;
  /**
   * When completing SAML Single Sign-On authentication, this will be the ID of the Team that was authenticated for.
   *
   * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
   */
  teamId?: string;
};

export type VerifyTokenVariables = FetcherExtraProps;

/**
 * Verify the user accepted the login request and get a authentication token. The user email address and the token received after requesting the login must be added to the URL as a query string with the names `email` and `token`.
 */
export const verifyToken = (variables: VerifyTokenVariables, signal?: AbortSignal) =>
  fetch<VerifyTokenResponse, VerifyTokenError, undefined, {}, {}, {}>({
    url: '/registration/verify',
    method: 'get',
    ...variables,
    signal
  });

export type EmailLoginError = Fetcher.ErrorWrapper<undefined>;

export type EmailLoginResponse = {
  /**
   * The token used to verify the user accepted the login request
   *
   * @example T1dmvPu36nmyYisXAs7IRzcR
   */
  token: string;
  /**
   * The code the user is going to receive on the email. **Must** be displayed to the user so they can verify the request is the correct.
   *
   * @example Practical Saola
   */
  securityCode: string;
};

export type EmailLoginVariables = FetcherExtraProps;

/**
 * Request a new login for a user to get a token. This will respond with a verification token and send an email to confirm the request. Once confirmed you can use the verification token to get an authentication token.
 */
export const emailLogin = (variables: EmailLoginVariables, signal?: AbortSignal) =>
  fetch<EmailLoginResponse, EmailLoginError, undefined, {}, {}, {}>({
    url: '/registration',
    method: 'post',
    ...variables,
    signal
  });

export type GetConfigurationsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetConfigurationsError = Fetcher.ErrorWrapper<undefined>;

export type GetConfigurationsVariables = {
  queryParams?: GetConfigurationsQueryParams;
} & FetcherExtraProps;

/**
 * Allows to retrieve all configurations for an authenticated integration. When the `project` view is used, configurations generated for the authorization flow will be filtered out of the results.
 */
export const getConfigurations = (variables: GetConfigurationsVariables, signal?: AbortSignal) =>
  fetch<
    | {
        /**
         * A timestamp that tells you when the configuration was installed successfully
         *
         * @example 1558531915505
         */
        completedAt?: number;
        /**
         * A timestamp that tells you when the configuration was created
         *
         * @example 1558531915505
         */
        createdAt: number;
        /**
         * The unique identifier of the configuration
         *
         * @example icfg_3bwCLgxL8qt5kjRLcv2Dit7F
         */
        id: string;
        /**
         * The unique identifier of the app the configuration was created for
         *
         * @example oac_xzpVzcUOgcB1nrVlirtKhbWV
         */
        integrationId: string;
        /**
         * Will be truthy in those cases where the configuration was created to authorize a client through the OAuth2 flow.
         *
         * @example false
         */
        oauthConfiguration?: boolean;
        /**
         * The user or team ID that owns the configuration
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        ownerId: string;
        /**
         * When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
         *
         * @example prj_xQxbutw1HpL6HLYPAzt5h75m8NjO
         */
        projects?: string[];
        /**
         * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
         *
         * @example marketplace
         */
        source?: 'marketplace' | 'deploy-button' | 'oauth' | 'external';
        removedLogDrainsAt?: number;
        removedProjectEnvsAt?: number;
        removedTokensAt?: number;
        removedWebhooksAt?: number;
        /**
         * The slug of the integration the configuration is created for.
         *
         * @example slack
         */
        slug: string;
        /**
         * When the configuration was created for a team, this will show the ID of the team.
         *
         * @example team_nLlpyC6RE1qxydlFKbrxDlud
         */
        teamId?: string | null;
        type: 'integration-configuration';
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        updatedAt: number;
        /**
         * The ID of the user that created the configuration.
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        userId: string;
        /**
         * The resources that are allowed to be accessed by the configuration.
         *
         * @example read:project
         * @example read-write:log-drain
         */
        scopes: string[];
        scopesQueue?: {
          scopes: {
            added: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
            )[];
            upgraded: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
            )[];
          };
          note: string;
          requestedAt: number;
          confirmedAt?: number;
        }[];
        /**
         * A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
         *
         * @example 1558531915505
         */
        disabledAt?: number;
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        deletedAt?: number | null;
      }[]
    | {
        integration: {
          name: string;
          icon: string;
          category: string;
          isLegacy: boolean;
          flags?: string[];
          assignedBetaLabelAt?: number;
        };
        /**
         * A timestamp that tells you when the configuration was installed successfully
         *
         * @example 1558531915505
         */
        completedAt?: number;
        /**
         * A timestamp that tells you when the configuration was created
         *
         * @example 1558531915505
         */
        createdAt: number;
        /**
         * The unique identifier of the configuration
         *
         * @example icfg_3bwCLgxL8qt5kjRLcv2Dit7F
         */
        id: string;
        /**
         * The unique identifier of the app the configuration was created for
         *
         * @example oac_xzpVzcUOgcB1nrVlirtKhbWV
         */
        integrationId: string;
        /**
         * Will be truthy in those cases where the configuration was created to authorize a client through the OAuth2 flow.
         *
         * @example false
         */
        oauthConfiguration?: boolean;
        /**
         * The user or team ID that owns the configuration
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        ownerId: string;
        /**
         * When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
         *
         * @example prj_xQxbutw1HpL6HLYPAzt5h75m8NjO
         */
        projects?: string[];
        /**
         * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
         *
         * @example marketplace
         */
        source?: 'marketplace' | 'deploy-button' | 'oauth' | 'external';
        removedLogDrainsAt?: number;
        removedProjectEnvsAt?: number;
        removedTokensAt?: number;
        removedWebhooksAt?: number;
        /**
         * The slug of the integration the configuration is created for.
         *
         * @example slack
         */
        slug: string;
        /**
         * When the configuration was created for a team, this will show the ID of the team.
         *
         * @example team_nLlpyC6RE1qxydlFKbrxDlud
         */
        teamId?: string | null;
        type: 'integration-configuration';
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        updatedAt: number;
        /**
         * The ID of the user that created the configuration.
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        userId: string;
        /**
         * The resources that are allowed to be accessed by the configuration.
         *
         * @example read:project
         * @example read-write:log-drain
         */
        scopes: string[];
        scopesQueue?: {
          scopes: {
            added: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
            )[];
            upgraded: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
            )[];
          };
          note: string;
          requestedAt: number;
          confirmedAt?: number;
        }[];
        /**
         * A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
         *
         * @example 1558531915505
         */
        disabledAt?: number;
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        deletedAt?: number | null;
      }[],
    GetConfigurationsError,
    undefined,
    {},
    GetConfigurationsQueryParams,
    {}
  >({ url: '/v1/integrations/configurations', method: 'get', ...variables, signal });

export type GetConfigurationQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetConfigurationError = Fetcher.ErrorWrapper<undefined>;

export type GetConfigurationVariables = {
  queryParams?: GetConfigurationQueryParams;
} & FetcherExtraProps;

/**
 * Allows to retrieve a the configuration with the provided id in case it exists. The authenticated user or team must be the owner of the config in order to access it.
 */
export const getConfiguration = (variables: GetConfigurationVariables, signal?: AbortSignal) =>
  fetch<
    | {
        /**
         * A timestamp that tells you when the configuration was installed successfully
         *
         * @example 1558531915505
         */
        completedAt?: number;
        /**
         * A timestamp that tells you when the configuration was created
         *
         * @example 1558531915505
         */
        createdAt: number;
        /**
         * The unique identifier of the configuration
         *
         * @example icfg_3bwCLgxL8qt5kjRLcv2Dit7F
         */
        id: string;
        /**
         * The unique identifier of the app the configuration was created for
         *
         * @example oac_xzpVzcUOgcB1nrVlirtKhbWV
         */
        integrationId: string;
        /**
         * Will be truthy in those cases where the configuration was created to authorize a client through the OAuth2 flow.
         *
         * @example false
         */
        oauthConfiguration?: boolean;
        /**
         * The user or team ID that owns the configuration
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        ownerId: string;
        /**
         * When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
         *
         * @example prj_xQxbutw1HpL6HLYPAzt5h75m8NjO
         */
        projects?: string[];
        /**
         * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
         *
         * @example marketplace
         */
        source?: 'marketplace' | 'deploy-button' | 'oauth' | 'external';
        removedLogDrainsAt?: number;
        removedProjectEnvsAt?: number;
        removedTokensAt?: number;
        removedWebhooksAt?: number;
        /**
         * The slug of the integration the configuration is created for.
         *
         * @example slack
         */
        slug: string;
        /**
         * When the configuration was created for a team, this will show the ID of the team.
         *
         * @example team_nLlpyC6RE1qxydlFKbrxDlud
         */
        teamId?: string | null;
        type: 'integration-configuration';
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        updatedAt: number;
        /**
         * The ID of the user that created the configuration.
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        userId: string;
        /**
         * The resources that are allowed to be accessed by the configuration.
         *
         * @example read:project
         * @example read-write:log-drain
         */
        scopes: string[];
        scopesQueue?: {
          scopes: {
            added: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
            )[];
            upgraded: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
            )[];
          };
          note: string;
          requestedAt: number;
          confirmedAt?: number;
        }[];
        /**
         * A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
         *
         * @example 1558531915505
         */
        disabledAt?: number;
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        deletedAt?: number | null;
      }
    | {
        /**
         * A string representing the permission for projects. Possible values are `all` or `selected`.
         *
         * @example all
         */
        projectSelection: 'selected' | 'all';
        /**
         * A timestamp that tells you when the configuration was created
         *
         * @example 1558531915505
         */
        createdAt: number;
        /**
         * A timestamp that tells you when the configuration was installed successfully
         *
         * @example 1558531915505
         */
        completedAt?: number;
        /**
         * The unique identifier of the configuration
         *
         * @example icfg_3bwCLgxL8qt5kjRLcv2Dit7F
         */
        id: string;
        /**
         * The unique identifier of the app the configuration was created for
         *
         * @example oac_xzpVzcUOgcB1nrVlirtKhbWV
         */
        integrationId: string;
        /**
         * Will be truthy in those cases where the configuration was created to authorize a client through the OAuth2 flow.
         *
         * @example false
         */
        oauthConfiguration?: boolean;
        /**
         * The user or team ID that owns the configuration
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        ownerId: string;
        /**
         * When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
         *
         * @example prj_xQxbutw1HpL6HLYPAzt5h75m8NjO
         */
        projects?: string[];
        /**
         * The slug of the integration the configuration is created for.
         *
         * @example slack
         */
        slug: string;
        /**
         * When the configuration was created for a team, this will show the ID of the team.
         *
         * @example team_nLlpyC6RE1qxydlFKbrxDlud
         */
        teamId?: string | null;
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        updatedAt: number;
        /**
         * The ID of the user that created the configuration.
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        userId: string;
        /**
         * The resources that are allowed to be accessed by the configuration.
         *
         * @example read:project
         * @example read-write:log-drain
         */
        scopes: string[];
        /**
         * A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
         *
         * @example 1558531915505
         */
        disabledAt?: number;
        /**
         * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
         *
         * @example marketplace
         */
        source?: 'marketplace' | 'deploy-button' | 'oauth' | 'external';
        canConfigureOpenTelemetry?: boolean;
        removedLogDrainsAt?: number;
        removedProjectEnvsAt?: number;
        removedTokensAt?: number;
        removedWebhooksAt?: number;
        type: 'integration-configuration';
        scopesQueue?: {
          scopes: {
            added: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
            )[];
            upgraded: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
            )[];
          };
          note: string;
          requestedAt: number;
          confirmedAt?: number;
        }[];
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        deletedAt?: number | null;
      },
    GetConfigurationError,
    undefined,
    {},
    GetConfigurationQueryParams,
    {}
  >({ url: '/v1/integrations/configuration/{id}', method: 'get', ...variables, signal });

export type DeleteConfigurationQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteConfigurationError = Fetcher.ErrorWrapper<undefined>;

export type DeleteConfigurationVariables = {
  queryParams?: DeleteConfigurationQueryParams;
} & FetcherExtraProps;

/**
 * Allows to remove the configuration with the `id` provided in the parameters. The configuration and all of its resources will be removed. This includes Webhooks, LogDrains and Project Env variables.
 */
export const deleteConfiguration = (variables: DeleteConfigurationVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteConfigurationError, undefined, {}, DeleteConfigurationQueryParams, {}>({
    url: '/v1/integrations/configuration/{id}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetIntegrationLogDrainsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetIntegrationLogDrainsError = Fetcher.ErrorWrapper<undefined>;

export type GetIntegrationLogDrainsResponse = {
  /**
   * The oauth2 client application id that created this log drain
   *
   * @example oac_xRhY4LAB7yLhUADD69EvV7ct
   */
  clientId?: string;
  /**
   * The client configuration this log drain was created with
   *
   * @example icfg_cuwj0AdCdH3BwWT4LPijCC7t
   */
  configurationId?: string;
  /**
   * A timestamp that tells you when the log drain was created
   *
   * @example 1558531915505
   */
  createdAt: number;
  /**
   * The unique identifier of the log drain. Always prefixed with `ld_`
   *
   * @example ld_nBuA7zCID8g4QZ8g
   */
  id: string;
  /**
   * The delivery log format
   *
   * @example json
   */
  deliveryFormat?: 'json' | 'ndjson' | 'syslog';
  /**
   * The name of the log drain
   *
   * @example My first log drain
   */
  name: string;
  /**
   * The identifier of the team or user whose events will trigger the log drain
   *
   * @example kr1PsOIzqEL5Xg6M4VZcZosf
   */
  ownerId: string;
  /**
   * @example AbCgVkqoxXeXCDWehVir51LHGrrcWL4mkYm14W6UBPWQeb
   */
  projectId?: string | null;
  /**
   * The identifier of the projects this log drain is associated with
   *
   * @example AbCgVkqoxXeXCDWehVir51LHGrrcWL4mkYm14W6UBPWQeb
   */
  projectIds?: string[];
  /**
   * The URL to call when logs are generated
   *
   * @example https://example.com/log-drain
   */
  url: string;
  /**
   * The sources from which logs are currently being delivered to this log drain.
   *
   * @example build
   * @example edge
   */
  sources?: ('static' | 'lambda' | 'build' | 'edge' | 'external' | 'deployment')[];
  /**
   * Whether the log drain was created by an integration or by a user
   *
   * @example integration
   */
  createdFrom?: 'self-served' | 'integration';
  /**
   * Construct a type with a set of properties K of type T
   *
   * @example {"Authorization": "Bearer 123"}
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * The environment of log drain
   *
   * @example production
   */
  environment?: 'production' | 'preview';
  /**
   * The branch regexp of log drain
   *
   * @example feature/*
   */
  branch?: string;
}[];

export type GetIntegrationLogDrainsVariables = {
  queryParams?: GetIntegrationLogDrainsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of all Integration log drains that are defined for the authorized account. When using an OAuth2 token, the list is limited to log drains created by the authenticated integration.
 */
export const getIntegrationLogDrains = (variables: GetIntegrationLogDrainsVariables, signal?: AbortSignal) =>
  fetch<
    GetIntegrationLogDrainsResponse,
    GetIntegrationLogDrainsError,
    undefined,
    {},
    GetIntegrationLogDrainsQueryParams,
    {}
  >({ url: '/v2/integrations/log-drains', method: 'get', ...variables, signal });

export type CreateLogDrainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateLogDrainError = Fetcher.ErrorWrapper<undefined>;

export type CreateLogDrainResponse = {
  /**
   * The oauth2 client application id that created this log drain
   *
   * @example oac_xRhY4LAB7yLhUADD69EvV7ct
   */
  clientId?: string;
  /**
   * The client configuration this log drain was created with
   *
   * @example icfg_cuwj0AdCdH3BwWT4LPijCC7t
   */
  configurationId?: string;
  /**
   * A timestamp that tells you when the log drain was created
   *
   * @example 1558531915505
   */
  createdAt: number;
  /**
   * The unique identifier of the log drain. Always prefixed with `ld_`
   *
   * @example ld_nBuA7zCID8g4QZ8g
   */
  id: string;
  /**
   * The delivery log format
   *
   * @example json
   */
  deliveryFormat?: 'json' | 'ndjson' | 'syslog';
  /**
   * The name of the log drain
   *
   * @example My first log drain
   */
  name: string;
  /**
   * The identifier of the team or user whose events will trigger the log drain
   *
   * @example kr1PsOIzqEL5Xg6M4VZcZosf
   */
  ownerId: string;
  /**
   * @example AbCgVkqoxXeXCDWehVir51LHGrrcWL4mkYm14W6UBPWQeb
   */
  projectId?: string | null;
  /**
   * The identifier of the projects this log drain is associated with
   *
   * @example AbCgVkqoxXeXCDWehVir51LHGrrcWL4mkYm14W6UBPWQeb
   */
  projectIds?: string[];
  /**
   * The URL to call when logs are generated
   *
   * @example https://example.com/log-drain
   */
  url: string;
  /**
   * The sources from which logs are currently being delivered to this log drain.
   *
   * @example build
   * @example edge
   */
  sources?: ('static' | 'lambda' | 'build' | 'edge' | 'external' | 'deployment')[];
  /**
   * Whether the log drain was created by an integration or by a user
   *
   * @example integration
   */
  createdFrom?: 'self-served' | 'integration';
  /**
   * Construct a type with a set of properties K of type T
   *
   * @example {"Authorization": "Bearer 123"}
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * The environment of log drain
   *
   * @example production
   */
  environment?: 'preview' | 'production';
  /**
   * The branch regexp of log drain
   *
   * @example feature/*
   */
  branch?: string;
};

export type CreateLogDrainVariables = {
  queryParams?: CreateLogDrainQueryParams;
} & FetcherExtraProps;

/**
 * Creates an Integration log drain. This endpoint must be called with an OAuth2 client (integration), since log drains are tied to integrations. If it is called with a different token type it will produce a 400 error.
 */
export const createLogDrain = (variables: CreateLogDrainVariables, signal?: AbortSignal) =>
  fetch<CreateLogDrainResponse, CreateLogDrainError, undefined, {}, CreateLogDrainQueryParams, {}>({
    url: '/v2/integrations/log-drains',
    method: 'post',
    ...variables,
    signal
  });

export type DeleteIntegrationLogDrainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteIntegrationLogDrainError = Fetcher.ErrorWrapper<undefined>;

export type DeleteIntegrationLogDrainVariables = {
  queryParams?: DeleteIntegrationLogDrainQueryParams;
} & FetcherExtraProps;

/**
 * Deletes the Integration log drain with the provided `id`. When using an OAuth2 Token, the log drain can be deleted only if the integration owns it.
 */
export const deleteIntegrationLogDrain = (variables: DeleteIntegrationLogDrainVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteIntegrationLogDrainError, undefined, {}, DeleteIntegrationLogDrainQueryParams, {}>({
    url: '/v1/integrations/log-drains/{id}',
    method: 'delete',
    ...variables,
    signal
  });

export type GitNamespacesQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GitNamespacesError = Fetcher.ErrorWrapper<undefined>;

export type GitNamespacesResponse = {
  provider: string;
  slug: string;
  id: string | number;
  name?: string;
  ownerType: string;
}[];

export type GitNamespacesVariables = {
  queryParams?: GitNamespacesQueryParams;
} & FetcherExtraProps;

/**
 * Lists git namespaces for a supported provider. Supported providers are `github`, `gitlab` and `bitbucket`. If the provider is not provided, it will try to obtain it from the user that authenticated the request.
 */
export const gitNamespaces = (variables: GitNamespacesVariables, signal?: AbortSignal) =>
  fetch<GitNamespacesResponse, GitNamespacesError, undefined, {}, GitNamespacesQueryParams, {}>({
    url: '/v1/integrations/git-namespaces',
    method: 'get',
    ...variables,
    signal
  });

export type SearchRepoQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type SearchRepoError = Fetcher.ErrorWrapper<undefined>;

export type SearchRepoResponse = {
  gitAccount: {
    provider: 'github' | 'gitlab' | 'bitbucket';
    namespaceId: string | number | null;
  };
  repos: {
    id: string | number;
    name: string;
    slug: string;
    namespace: string;
    private: boolean;
    defaultBranch: string;
    url: string;
    updatedAt: number;
    ownerType: 'team' | 'user';
  }[];
};

export type SearchRepoVariables = {
  queryParams?: SearchRepoQueryParams;
} & FetcherExtraProps;

/**
 * Lists git repositories linked to a namespace `id` for a supported provider. A specific namespace `id` can be obtained via the `git-namespaces`  endpoint. Supported providers are `github`, `gitlab` and `bitbucket`. If the provider or namespace is not provided, it will try to obtain it from the user that authenticated the request.
 */
export const searchRepo = (variables: SearchRepoVariables, signal?: AbortSignal) =>
  fetch<SearchRepoResponse, SearchRepoError, undefined, {}, SearchRepoQueryParams, {}>({
    url: '/v1/integrations/search-repo',
    method: 'get',
    ...variables,
    signal
  });

export type CreateWebhookQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateWebhookError = Fetcher.ErrorWrapper<undefined>;

export type CreateWebhookResponse = {
  /**
   * The webhook secret used to sign the payload
   */
  secret: string;
  /**
   * The webhooks events
   *
   * @example deployment.created
   */
  events: (
    | 'domain.created'
    | 'deployment.created'
    | 'deployment.error'
    | 'deployment.canceled'
    | 'deployment.succeeded'
    | 'deployment.ready'
    | 'deployment.check-rerequested'
    | 'integration-configuration.permission-upgraded'
    | 'integration-configuration.removed'
    | 'integration-configuration.scope-change-confirmed'
    | 'project.created'
    | 'project.removed'
    | 'deployment-checks-completed'
    | 'deployment-ready'
    | 'deployment-prepared'
    | 'deployment-error'
    | 'deployment-check-rerequested'
    | 'deployment-canceled'
    | 'project-created'
    | 'project-removed'
    | 'domain-created'
    | 'deployment'
    | 'integration-configuration-permission-updated'
    | 'integration-configuration-removed'
    | 'integration-configuration-scope-change-confirmed'
  )[];
  /**
   * The webhook id
   *
   * @example account_hook_GflD6EYyo7F4ViYS
   */
  id: string;
  /**
   * A string with the URL of the webhook
   *
   * @example https://my-webhook.com
   */
  url: string;
  /**
   * The unique ID of the team the webhook belongs to
   *
   * @example ZspSRT4ljIEEmMHgoDwKWDei
   */
  ownerId: string;
  /**
   * A number containing the date when the webhook was created in in milliseconds
   *
   * @example 1567024758130
   */
  createdAt: number;
  /**
   * A number containing the date when the webhook was updated in in milliseconds
   *
   * @example 1567024758130
   */
  updatedAt: number;
  /**
   * The ID of the projects the webhook is associated with
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectIds?: string[];
};

export type CreateWebhookVariables = {
  queryParams?: CreateWebhookQueryParams;
} & FetcherExtraProps;

/**
 * Creates a webhook
 */
export const createWebhook = (variables: CreateWebhookVariables, signal?: AbortSignal) =>
  fetch<CreateWebhookResponse, CreateWebhookError, undefined, {}, CreateWebhookQueryParams, {}>({
    url: '/v1/webhooks',
    method: 'post',
    ...variables,
    signal
  });

export type GetWebhooksQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetWebhooksError = Fetcher.ErrorWrapper<undefined>;

export type GetWebhooksVariables = {
  queryParams?: GetWebhooksQueryParams;
} & FetcherExtraProps;

/**
 * Get a list of webhooks
 */
export const getWebhooks = (variables: GetWebhooksVariables, signal?: AbortSignal) =>
  fetch<
    | {
        projectsMetadata:
          | {
              id: string;
              name: string;
              framework?:
                | 'blitzjs'
                | 'nextjs'
                | 'gatsby'
                | 'remix'
                | 'astro'
                | 'hexo'
                | 'eleventy'
                | 'docusaurus-2'
                | 'docusaurus'
                | 'preact'
                | 'solidstart'
                | 'dojo'
                | 'ember'
                | 'vue'
                | 'scully'
                | 'ionic-angular'
                | 'angular'
                | 'polymer'
                | 'svelte'
                | 'sveltekit'
                | 'sveltekit-1'
                | 'ionic-react'
                | 'create-react-app'
                | 'gridsome'
                | 'umijs'
                | 'sapper'
                | 'saber'
                | 'stencil'
                | 'nuxtjs'
                | 'redwoodjs'
                | 'hugo'
                | 'jekyll'
                | 'brunch'
                | 'middleman'
                | 'zola'
                | 'hydrogen'
                | 'vite'
                | 'vitepress'
                | 'vuepress'
                | 'parcel'
                | 'sanity'
                | null;
              latestDeployment?: string;
            }[]
          | null;
        /**
         * The webhooks events
         *
         * @example deployment.created
         */
        events: (
          | 'domain.created'
          | 'deployment.created'
          | 'deployment.error'
          | 'deployment.canceled'
          | 'deployment.succeeded'
          | 'deployment.ready'
          | 'deployment.check-rerequested'
          | 'integration-configuration.permission-upgraded'
          | 'integration-configuration.removed'
          | 'integration-configuration.scope-change-confirmed'
          | 'project.created'
          | 'project.removed'
          | 'deployment-checks-completed'
          | 'deployment-ready'
          | 'deployment-prepared'
          | 'deployment-error'
          | 'deployment-check-rerequested'
          | 'deployment-canceled'
          | 'project-created'
          | 'project-removed'
          | 'domain-created'
          | 'deployment'
          | 'integration-configuration-permission-updated'
          | 'integration-configuration-removed'
          | 'integration-configuration-scope-change-confirmed'
        )[];
        /**
         * The webhook id
         *
         * @example account_hook_GflD6EYyo7F4ViYS
         */
        id: string;
        /**
         * A string with the URL of the webhook
         *
         * @example https://my-webhook.com
         */
        url: string;
        /**
         * The unique ID of the team the webhook belongs to
         *
         * @example ZspSRT4ljIEEmMHgoDwKWDei
         */
        ownerId: string;
        /**
         * A number containing the date when the webhook was created in in milliseconds
         *
         * @example 1567024758130
         */
        createdAt: number;
        /**
         * A number containing the date when the webhook was updated in in milliseconds
         *
         * @example 1567024758130
         */
        updatedAt: number;
        /**
         * The ID of the projects the webhook is associated with
         *
         * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
         */
        projectIds?: string[];
      }[]
    | {
        /**
         * The webhooks events
         *
         * @example deployment.created
         */
        events: (
          | 'domain.created'
          | 'deployment.created'
          | 'deployment.error'
          | 'deployment.canceled'
          | 'deployment.succeeded'
          | 'deployment.ready'
          | 'deployment.check-rerequested'
          | 'integration-configuration.permission-upgraded'
          | 'integration-configuration.removed'
          | 'integration-configuration.scope-change-confirmed'
          | 'project.created'
          | 'project.removed'
          | 'deployment-checks-completed'
          | 'deployment-ready'
          | 'deployment-prepared'
          | 'deployment-error'
          | 'deployment-check-rerequested'
          | 'deployment-canceled'
          | 'project-created'
          | 'project-removed'
          | 'domain-created'
          | 'deployment'
          | 'integration-configuration-permission-updated'
          | 'integration-configuration-removed'
          | 'integration-configuration-scope-change-confirmed'
        )[];
        /**
         * The webhook id
         *
         * @example account_hook_GflD6EYyo7F4ViYS
         */
        id: string;
        /**
         * A string with the URL of the webhook
         *
         * @example https://my-webhook.com
         */
        url: string;
        /**
         * The unique ID of the team the webhook belongs to
         *
         * @example ZspSRT4ljIEEmMHgoDwKWDei
         */
        ownerId: string;
        /**
         * A number containing the date when the webhook was created in in milliseconds
         *
         * @example 1567024758130
         */
        createdAt: number;
        /**
         * A number containing the date when the webhook was updated in in milliseconds
         *
         * @example 1567024758130
         */
        updatedAt: number;
        /**
         * The ID of the projects the webhook is associated with
         *
         * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
         */
        projectIds?: string[];
      }[],
    GetWebhooksError,
    undefined,
    {},
    GetWebhooksQueryParams,
    {}
  >({ url: '/v1/webhooks', method: 'get', ...variables, signal });

export type GetWebhookQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetWebhookError = Fetcher.ErrorWrapper<undefined>;

export type GetWebhookResponse = {
  /**
   * The webhooks events
   *
   * @example deployment.created
   */
  events: (
    | 'domain.created'
    | 'deployment.created'
    | 'deployment.error'
    | 'deployment.canceled'
    | 'deployment.succeeded'
    | 'deployment.ready'
    | 'deployment.check-rerequested'
    | 'integration-configuration.permission-upgraded'
    | 'integration-configuration.removed'
    | 'integration-configuration.scope-change-confirmed'
    | 'project.created'
    | 'project.removed'
    | 'deployment-checks-completed'
    | 'deployment-ready'
    | 'deployment-prepared'
    | 'deployment-error'
    | 'deployment-check-rerequested'
    | 'deployment-canceled'
    | 'project-created'
    | 'project-removed'
    | 'domain-created'
    | 'deployment'
    | 'integration-configuration-permission-updated'
    | 'integration-configuration-removed'
    | 'integration-configuration-scope-change-confirmed'
  )[];
  /**
   * The webhook id
   *
   * @example account_hook_GflD6EYyo7F4ViYS
   */
  id: string;
  /**
   * A string with the URL of the webhook
   *
   * @example https://my-webhook.com
   */
  url: string;
  /**
   * The unique ID of the team the webhook belongs to
   *
   * @example ZspSRT4ljIEEmMHgoDwKWDei
   */
  ownerId: string;
  /**
   * A number containing the date when the webhook was created in in milliseconds
   *
   * @example 1567024758130
   */
  createdAt: number;
  /**
   * A number containing the date when the webhook was updated in in milliseconds
   *
   * @example 1567024758130
   */
  updatedAt: number;
  /**
   * The ID of the projects the webhook is associated with
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectIds?: string[];
};

export type GetWebhookVariables = {
  queryParams?: GetWebhookQueryParams;
} & FetcherExtraProps;

/**
 * Get a webhook
 */
export const getWebhook = (variables: GetWebhookVariables, signal?: AbortSignal) =>
  fetch<GetWebhookResponse, GetWebhookError, undefined, {}, GetWebhookQueryParams, {}>({
    url: '/v1/webhooks/{id}',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteWebhookQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteWebhookError = Fetcher.ErrorWrapper<undefined>;

export type DeleteWebhookVariables = {
  queryParams?: DeleteWebhookQueryParams;
} & FetcherExtraProps;

/**
 * Deletes a webhook
 */
export const deleteWebhook = (variables: DeleteWebhookVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteWebhookError, undefined, {}, DeleteWebhookQueryParams, {}>({
    url: '/v1/webhooks/{id}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetConfigurableLogDrainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetConfigurableLogDrainError = Fetcher.ErrorWrapper<undefined>;

export type GetConfigurableLogDrainResponse = {
  /**
   * The environment to filter logs by
   *
   * @example production
   */
  environment?: 'preview' | 'production';
  /**
   * The branch to filter logs by
   *
   * @example main
   */
  branch?: string;
  /**
   * The ID of the related integration configuration
   */
  configurationId?: string;
  /**
   * Construct a type with a set of properties K of type T
   *
   * @example {"foo":"bar"}
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * The ID of the projects the deployment is associated with
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectIds?: string[];
  /**
   * A number containing the date when the log-drain was created in in milliseconds
   *
   * @example 1567024758130
   */
  createdAt: number;
  /**
   * The log-drain id
   *
   * @example ld_GflD6EYyo7F4ViYS
   */
  id: string;
  /**
   * The unique ID of the team the deployment belongs to
   *
   * @example team_ZspSRT4ljIEEmMHgoDwKWDei
   */
  ownerId: string;
  /**
   * The log-drain defined sources
   *
   * @example lambda
   * @example build
   */
  sources?: ('static' | 'lambda' | 'build' | 'edge' | 'external' | 'deployment')[];
  /**
   * The log-drain defined delivery format
   *
   * @example json
   * @example ndjson
   */
  deliveryFormat: 'json' | 'ndjson' | 'syslog';
  /**
   * A string with the URL of the log-drain
   *
   * @example https://my-log-drain.com
   */
  url: string;
};

export type GetConfigurableLogDrainVariables = {
  queryParams?: GetConfigurableLogDrainQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a Configurable Log Drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be accessed.
 */
export const getConfigurableLogDrain = (variables: GetConfigurableLogDrainVariables, signal?: AbortSignal) =>
  fetch<
    GetConfigurableLogDrainResponse,
    GetConfigurableLogDrainError,
    undefined,
    {},
    GetConfigurableLogDrainQueryParams,
    {}
  >({ url: '/v1/log-drains/{id}', method: 'get', ...variables, signal });

export type DeleteConfigurableLogDrainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteConfigurableLogDrainError = Fetcher.ErrorWrapper<undefined>;

export type DeleteConfigurableLogDrainVariables = {
  queryParams?: DeleteConfigurableLogDrainQueryParams;
} & FetcherExtraProps;

/**
 * Deletes a Configurable Log Drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be deleted.
 */
export const deleteConfigurableLogDrain = (variables: DeleteConfigurableLogDrainVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteConfigurableLogDrainError, undefined, {}, DeleteConfigurableLogDrainQueryParams, {}>({
    url: '/v1/log-drains/{id}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetConfigurableLogDrainsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetConfigurableLogDrainsError = Fetcher.ErrorWrapper<undefined>;

export type GetConfigurableLogDrainsResponse = {
  /**
   * The environment to filter logs by
   *
   * @example production
   */
  environment?: 'preview' | 'production';
  /**
   * The branch to filter logs by
   *
   * @example main
   */
  branch?: string;
  /**
   * The ID of the related integration configuration
   */
  configurationId?: string;
  /**
   * Construct a type with a set of properties K of type T
   *
   * @example {"foo":"bar"}
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * The ID of the projects the deployment is associated with
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectIds?: string[];
  /**
   * A number containing the date when the log-drain was created in in milliseconds
   *
   * @example 1567024758130
   */
  createdAt: number;
  /**
   * The log-drain id
   *
   * @example ld_GflD6EYyo7F4ViYS
   */
  id: string;
  /**
   * The unique ID of the team the deployment belongs to
   *
   * @example team_ZspSRT4ljIEEmMHgoDwKWDei
   */
  ownerId: string;
  /**
   * The log-drain defined sources
   *
   * @example lambda
   * @example build
   */
  sources?: ('static' | 'lambda' | 'build' | 'edge' | 'external' | 'deployment')[];
  /**
   * The log-drain defined delivery format
   *
   * @example json
   * @example ndjson
   */
  deliveryFormat: 'json' | 'ndjson' | 'syslog';
  /**
   * A string with the URL of the log-drain
   *
   * @example https://my-log-drain.com
   */
  url: string;
}[];

export type GetConfigurableLogDrainsVariables = {
  queryParams?: GetConfigurableLogDrainsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of Configurable Log Drains. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be accessed.
 */
export const getConfigurableLogDrains = (variables: GetConfigurableLogDrainsVariables, signal?: AbortSignal) =>
  fetch<
    GetConfigurableLogDrainsResponse,
    GetConfigurableLogDrainsError,
    undefined,
    {},
    GetConfigurableLogDrainsQueryParams,
    {}
  >({ url: '/v1/log-drains', method: 'get', ...variables, signal });

export type CreateConfigurableLogDrainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateConfigurableLogDrainError = Fetcher.ErrorWrapper<undefined>;

export type CreateConfigurableLogDrainResponse = {
  /**
   * The secret to validate the log-drain payload
   */
  secret?: string;
  /**
   * The environment to filter logs by
   *
   * @example production
   */
  environment?: 'preview' | 'production';
  /**
   * The branch to filter logs by
   *
   * @example main
   */
  branch?: string;
  /**
   * The ID of the related integration configuration
   */
  configurationId?: string;
  /**
   * Construct a type with a set of properties K of type T
   *
   * @example {"foo":"bar"}
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * The ID of the projects the deployment is associated with
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectIds?: string[];
  /**
   * A number containing the date when the log-drain was created in in milliseconds
   *
   * @example 1567024758130
   */
  createdAt: number;
  /**
   * The log-drain id
   *
   * @example ld_GflD6EYyo7F4ViYS
   */
  id: string;
  /**
   * The unique ID of the team the deployment belongs to
   *
   * @example team_ZspSRT4ljIEEmMHgoDwKWDei
   */
  ownerId: string;
  /**
   * The log-drain defined sources
   *
   * @example lambda
   * @example build
   */
  sources?: ('static' | 'lambda' | 'build' | 'edge' | 'external' | 'deployment')[];
  /**
   * The log-drain defined delivery format
   *
   * @example json
   * @example ndjson
   */
  deliveryFormat: 'json' | 'ndjson' | 'syslog';
  /**
   * A string with the URL of the log-drain
   *
   * @example https://my-log-drain.com
   */
  url: string;
};

export type CreateConfigurableLogDrainVariables = {
  queryParams?: CreateConfigurableLogDrainQueryParams;
} & FetcherExtraProps;

/**
 * Creates a configurable log drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed)
 */
export const createConfigurableLogDrain = (variables: CreateConfigurableLogDrainVariables, signal?: AbortSignal) =>
  fetch<
    CreateConfigurableLogDrainResponse,
    CreateConfigurableLogDrainError,
    undefined,
    {},
    CreateConfigurableLogDrainQueryParams,
    {}
  >({ url: '/v1/log-drains', method: 'post', ...variables, signal });

export type GetTeamPathParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetTeamError = Fetcher.ErrorWrapper<undefined>;

export type GetTeamVariables = {
  pathParams?: GetTeamPathParams;
} & FetcherExtraProps;

/**
 * Get information for the Team specified by the `teamId` parameter.
 */
export const getTeam = (variables: GetTeamVariables, signal?: AbortSignal) =>
  fetch<Schemas.Team, GetTeamError, undefined, {}, {}, GetTeamPathParams>({
    url: '/v2/teams/{teamId}',
    method: 'get',
    ...variables,
    signal
  });

export type PatchTeamPathParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId: string;
};

export type PatchTeamError = Fetcher.ErrorWrapper<undefined>;

export type PatchTeamVariables = {
  pathParams: PatchTeamPathParams;
} & FetcherExtraProps;

/**
 * Update the information of a Team specified by the `teamId` parameter. The request body should contain the information that will be updated on the Team.
 */
export const patchTeam = (variables: PatchTeamVariables, signal?: AbortSignal) =>
  fetch<Schemas.Team, PatchTeamError, undefined, {}, {}, PatchTeamPathParams>({
    url: '/v2/teams/{teamId}',
    method: 'patch',
    ...variables,
    signal
  });

export type GetTeamsError = Fetcher.ErrorWrapper<undefined>;

export type GetTeamsResponse = {
  teams: (Schemas.Team | Schemas.TeamLimited)[];
  pagination: Schemas.Pagination;
};

export type GetTeamsVariables = FetcherExtraProps;

/**
 * Get a paginated list of all the Teams the authenticated User is a member of.
 */
export const getTeams = (variables: GetTeamsVariables, signal?: AbortSignal) =>
  fetch<GetTeamsResponse, GetTeamsError, undefined, {}, {}, {}>({
    url: '/v2/teams',
    method: 'get',
    ...variables,
    signal
  });

export type CreateTeamError = Fetcher.ErrorWrapper<undefined>;

export type CreateTeamResponse = {
  /**
   * Id of the created team
   *
   * @example team_nLlpyC6RE1qxqglFKbrMxlud
   */
  id: string;
};

export type CreateTeamVariables = FetcherExtraProps;

/**
 * Create a new Team under your account. You need to send a POST request with the desired Team slug, and optionally the Team name.
 */
export const createTeam = (variables: CreateTeamVariables, signal?: AbortSignal) =>
  fetch<CreateTeamResponse, CreateTeamError, undefined, {}, {}, {}>({
    url: '/v1/teams',
    method: 'post',
    ...variables,
    signal
  });

export type DeleteTeamPathParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId: string;
};

export type DeleteTeamError = Fetcher.ErrorWrapper<undefined>;

export type DeleteTeamResponse = {
  /**
   * The ID of the deleted Team
   *
   * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
   */
  id: string;
};

export type DeleteTeamVariables = {
  pathParams: DeleteTeamPathParams;
} & FetcherExtraProps;

/**
 * Delete a team under your account. You need to send a `DELETE` request with the desired team `id`. An optional array of reasons for deletion may also be sent.
 */
export const deleteTeam = (variables: DeleteTeamVariables, signal?: AbortSignal) =>
  fetch<DeleteTeamResponse, DeleteTeamError, undefined, {}, {}, DeleteTeamPathParams>({
    url: '/v1/teams/{teamId}',
    method: 'delete',
    ...variables,
    signal
  });

export type DeleteTeamInviteCodeError = Fetcher.ErrorWrapper<undefined>;

export type DeleteTeamInviteCodeResponse = {
  /**
   * ID of the team.
   */
  id: string;
};

export type DeleteTeamInviteCodeVariables = FetcherExtraProps;

/**
 * Delete an active Team invite code.
 */
export const deleteTeamInviteCode = (variables: DeleteTeamInviteCodeVariables, signal?: AbortSignal) =>
  fetch<DeleteTeamInviteCodeResponse, DeleteTeamInviteCodeError, undefined, {}, {}, {}>({
    url: '/v1/teams/{teamId}/invites/{inviteId}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetTeamMembersError = Fetcher.ErrorWrapper<undefined>;

export type GetTeamMembersResponse = {
  members: {
    /**
     * ID of the file for the Avatar of this member.
     *
     * @example 123a6c5209bc3778245d011443644c8d27dc2c50
     */
    avatar?: string;
    /**
     * Boolean that indicates if this member was confirmed by an owner.
     *
     * @example true
     */
    confirmed: boolean;
    /**
     * The email of this member.
     *
     * @example jane.doe@example.com
     */
    email: string;
    /**
     * Information about the GitHub account for this user.
     */
    github?: {
      userId?: number;
      accountId?: string;
      email?: string;
      login?: string;
    };
    /**
     * Information about the GitLab account of this user.
     */
    gitlab?: {
      userId?: number;
      accountId?: string;
      email?: string;
      login?: string;
    };
    /**
     * Information about the Bitbucket account of this user.
     */
    bitbucket?: {
      userId?: number;
      accountId?: string;
      email?: string;
      login?: string;
    };
    /**
     * Role of this user in the team.
     *
     * @example OWNER
     */
    role: 'MEMBER' | 'OWNER' | 'VIEWER' | 'DEVELOPER' | 'BILLING';
    /**
     * The ID of this user.
     *
     * @example zTuNVUXEAvvnNN3IaqinkyMw
     */
    uid: string;
    /**
     * The unique username of this user.
     *
     * @example jane-doe
     */
    username: string;
    /**
     * The name of this user.
     *
     * @example Jane Doe
     */
    name?: string;
    /**
     * Timestamp in milliseconds when this member was added.
     *
     * @example 1588720733602
     */
    createdAt: number;
    /**
     * Timestamp in milliseconds for when this team member was accepted by an owner.
     *
     * @example 1588820733602
     */
    accessRequestedAt?: number;
    /**
     * Map with information about the members origin if they joined by requesting access.
     */
    joinedFrom?: {
      origin:
        | 'import'
        | 'gitlab'
        | 'bitbucket'
        | 'github'
        | 'mail'
        | 'link'
        | 'teams'
        | 'saml'
        | 'dsync'
        | 'feedback'
        | 'organization-teams';
      commitId?: string;
      repoId?: string;
      repoPath?: string;
      gitUserId?: string | number;
      gitUserLogin?: string;
      ssoUserId?: string;
      ssoConnectedAt?: number;
      idpUserId?: string;
      dsyncUserId?: string;
      dsyncConnectedAt?: number;
    };
  }[];
  emailInviteCodes?: {
    id: string;
    email?: string;
    role?: 'MEMBER' | 'OWNER' | 'VIEWER' | 'DEVELOPER' | 'BILLING';
    isDSyncUser: boolean;
    createdAt?: number;
  }[];
  pagination: {
    hasNext: boolean;
    /**
     * Amount of items in the current page.
     *
     * @example 20
     */
    count: number;
    /**
     * Timestamp that must be used to request the next page.
     *
     * @example 1540095775951
     */
    next: number | null;
    /**
     * Timestamp that must be used to request the previous page.
     *
     * @example 1540095775951
     */
    prev: number | null;
  };
};

export type GetTeamMembersVariables = FetcherExtraProps;

/**
 * Get a paginated list of team members for the provided team.
 */
export const getTeamMembers = (variables: GetTeamMembersVariables, signal?: AbortSignal) =>
  fetch<GetTeamMembersResponse, GetTeamMembersError, undefined, {}, {}, {}>({
    url: '/v2/teams/{teamId}/members',
    method: 'get',
    ...variables,
    signal
  });

export type InviteUserToTeamError = Fetcher.ErrorWrapper<undefined>;

export type InviteUserToTeamVariables = FetcherExtraProps;

/**
 * Invite a user to join the team specified in the URL. The authenticated user needs to be an `OWNER` in order to successfully invoke this endpoint. The user can be specified with an email or an ID. If both email and ID are provided, ID will take priority.
 */
export const inviteUserToTeam = (variables: InviteUserToTeamVariables, signal?: AbortSignal) =>
  fetch<
    | {
        /**
         * The ID of the invited user
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        uid: string;
        /**
         * The username of the invited user
         *
         * @example john-doe
         */
        username: string;
        /**
         * The email of the invited user. Not included if the user was invited via their UID.
         *
         * @example john@user.co
         */
        email: string;
        /**
         * The role used for the invitation
         *
         * @example MEMBER
         */
        role: string;
      }
    | {
        uid: string;
        username: string;
        role: string;
      },
    InviteUserToTeamError,
    undefined,
    {},
    {},
    {}
  >({ url: '/v1/teams/{teamId}/members', method: 'post', ...variables, signal });

export type RequestAccessToTeamError = Fetcher.ErrorWrapper<undefined>;

export type RequestAccessToTeamResponse = {
  teamSlug: string;
  teamName: string;
  confirmed?: boolean;
  joinedFrom?: {
    origin:
      | 'import'
      | 'teams'
      | 'github'
      | 'gitlab'
      | 'bitbucket'
      | 'feedback'
      | 'organization-teams'
      | 'mail'
      | 'link'
      | 'saml'
      | 'dsync';
    commitId?: string;
    repoId?: string;
    repoPath?: string;
    gitUserId?: string | number;
    gitUserLogin?: string;
    ssoUserId?: string;
    ssoConnectedAt?: number;
    idpUserId?: string;
    dsyncUserId?: string;
    dsyncConnectedAt?: number;
  };
  accessRequestedAt?: number;
  github: {
    login?: string;
  } | null;
  gitlab: {
    login?: string;
  } | null;
  bitbucket: {
    login?: string;
  } | null;
};

export type RequestAccessToTeamVariables = FetcherExtraProps;

/**
 * Request access to a team as a member. An owner has to approve the request. Only 10 users can request access to a team at the same time.
 */
export const requestAccessToTeam = (variables: RequestAccessToTeamVariables, signal?: AbortSignal) =>
  fetch<RequestAccessToTeamResponse, RequestAccessToTeamError, undefined, {}, {}, {}>({
    url: '/v1/teams/{teamId}/request',
    method: 'post',
    ...variables,
    signal
  });

export type GetTeamAccessRequestError = Fetcher.ErrorWrapper<undefined>;

export type GetTeamAccessRequestResponse = {
  /**
   * The slug of the team.
   *
   * @example my-team
   */
  teamSlug: string;
  /**
   * The name of the team.
   *
   * @example My Team
   */
  teamName: string;
  /**
   * Current status of the membership. Will be `true` if confirmed, if pending it'll be `false`.
   *
   * @example false
   */
  confirmed: boolean;
  /**
   * A map that describes the origin from where the user joined.
   */
  joinedFrom: {
    origin:
      | 'import'
      | 'mail'
      | 'link'
      | 'teams'
      | 'github'
      | 'gitlab'
      | 'bitbucket'
      | 'saml'
      | 'dsync'
      | 'feedback'
      | 'organization-teams';
    commitId?: string;
    repoId?: string;
    repoPath?: string;
    gitUserId?: string | number;
    gitUserLogin?: string;
    ssoUserId?: string;
    ssoConnectedAt?: number;
    idpUserId?: string;
    dsyncUserId?: string;
    dsyncConnectedAt?: number;
  };
  /**
   * Timestamp in milliseconds when the user requested access to the team.
   *
   * @example 1588720733602
   */
  accessRequestedAt: number;
  /**
   * Map of the connected GitHub account.
   */
  github: {
    login?: string;
  } | null;
  /**
   * Map of the connected GitLab account.
   */
  gitlab: {
    login?: string;
  } | null;
  /**
   * Map of the connected Bitbucket account.
   */
  bitbucket: {
    login?: string;
  } | null;
};

export type GetTeamAccessRequestVariables = FetcherExtraProps;

/**
 * Check the status of a join request. It'll respond with a 404 if the request has been declined. If no `userId` path segment was provided, this endpoint will instead return the status of the authenticated user.
 */
export const getTeamAccessRequest = (variables: GetTeamAccessRequestVariables, signal?: AbortSignal) =>
  fetch<GetTeamAccessRequestResponse, GetTeamAccessRequestError, undefined, {}, {}, {}>({
    url: '/v1/teams/{teamId}/request/{userId}',
    method: 'get',
    ...variables,
    signal
  });

export type JoinTeamError = Fetcher.ErrorWrapper<undefined>;

export type JoinTeamResponse = {
  /**
   * The ID of the team the user joined.
   *
   * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
   */
  teamId: string;
  /**
   * The slug of the team the user joined.
   *
   * @example my-team
   */
  slug: string;
  /**
   * The name of the team the user joined.
   *
   * @example My Team
   */
  name: string;
  /**
   * The origin of how the user joined.
   *
   * @example email
   */
  from: string;
};

export type JoinTeamVariables = FetcherExtraProps;

/**
 * Join a team with a provided invite code or team ID.
 */
export const joinTeam = (variables: JoinTeamVariables, signal?: AbortSignal) =>
  fetch<JoinTeamResponse, JoinTeamError, undefined, {}, {}, {}>({
    url: '/v1/teams/{teamId}/members/teams/join',
    method: 'post',
    ...variables,
    signal
  });

export type UpdateTeamMemberError = Fetcher.ErrorWrapper<undefined>;

export type UpdateTeamMemberResponse = {
  /**
   * ID of the team.
   */
  id: string;
};

export type UpdateTeamMemberVariables = FetcherExtraProps;

/**
 * Update the membership of a Team Member on the Team specified by `teamId`, such as changing the _role_ of the member, or confirming a request to join the Team for an unconfirmed member. The authenticated user must be an `OWNER` of the Team.
 */
export const updateTeamMember = (variables: UpdateTeamMemberVariables, signal?: AbortSignal) =>
  fetch<UpdateTeamMemberResponse, UpdateTeamMemberError, undefined, {}, {}, {}>({
    url: '/v1/teams/{teamId}/members/{uid}',
    method: 'patch',
    ...variables,
    signal
  });

export type RemoveTeamMemberError = Fetcher.ErrorWrapper<undefined>;

export type RemoveTeamMemberResponse = {
  /**
   * ID of the team.
   */
  id: string;
};

export type RemoveTeamMemberVariables = FetcherExtraProps;

/**
 * Remove a Team Member from the Team, or dismiss a user that requested access, or leave a team.
 */
export const removeTeamMember = (variables: RemoveTeamMemberVariables, signal?: AbortSignal) =>
  fetch<RemoveTeamMemberResponse, RemoveTeamMemberError, undefined, {}, {}, {}>({
    url: '/v1/teams/{teamId}/members/{uid}',
    method: 'delete',
    ...variables,
    signal
  });

export type ListDeploymentFilesQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type ListDeploymentFilesError = Fetcher.ErrorWrapper<undefined>;

export type ListDeploymentFilesResponse = Schemas.FileTree[];

export type ListDeploymentFilesVariables = {
  queryParams?: ListDeploymentFilesQueryParams;
} & FetcherExtraProps;

/**
 * Allows to retrieve the file structure of a deployment by supplying the deployment unique identifier.
 */
export const listDeploymentFiles = (variables: ListDeploymentFilesVariables, signal?: AbortSignal) =>
  fetch<ListDeploymentFilesResponse, ListDeploymentFilesError, undefined, {}, ListDeploymentFilesQueryParams, {}>({
    url: '/v6/deployments/{id}/files',
    method: 'get',
    ...variables,
    signal
  });

export type GetDeploymentFileContentsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetDeploymentFileContentsError = Fetcher.ErrorWrapper<undefined>;

export type GetDeploymentFileContentsVariables = {
  queryParams?: GetDeploymentFileContentsQueryParams;
} & FetcherExtraProps;

/**
 * Allows to retrieve the content of a file by supplying the file identifier and the deployment unique identifier. The response body will contain the raw content of the file.
 */
export const getDeploymentFileContents = (variables: GetDeploymentFileContentsVariables, signal?: AbortSignal) =>
  fetch<undefined, GetDeploymentFileContentsError, undefined, {}, GetDeploymentFileContentsQueryParams, {}>({
    url: '/v6/deployments/{id}/files/{fileId}',
    method: 'get',
    ...variables,
    signal
  });

export type CreateCheckQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateCheckError = Fetcher.ErrorWrapper<undefined>;

export type CreateCheckResponse = {
  createdAt?: number | null;
  creator: string;
  domain: string;
  id: string;
  name: string;
  recordType: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
  ttl?: number;
  type: 'record' | 'record-sys';
  value: string;
};

export type CreateCheckVariables = {
  queryParams?: CreateCheckQueryParams;
} & FetcherExtraProps;

/**
 * Creates a new check. This endpoint must be called with an OAuth2 or it will produce a 400 error.
 */
export const createCheck = (variables: CreateCheckVariables, signal?: AbortSignal) =>
  fetch<CreateCheckResponse, CreateCheckError, undefined, {}, CreateCheckQueryParams, {}>({
    url: '/v1/deployments/{deploymentId}/checks',
    method: 'post',
    ...variables,
    signal
  });

export type GetAllChecksQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetAllChecksError = Fetcher.ErrorWrapper<undefined>;

export type GetAllChecksResponse = {
  checks: {
    completedAt?: number;
    conclusion?: 'canceled' | 'failed' | 'neutral' | 'succeeded' | 'skipped' | 'stale';
    createdAt: number;
    detailsUrl?: string;
    id: string;
    integrationId: string;
    name: string;
    output?: {
      metrics?: {
        FCP: {
          value: number | null;
          previousValue?: number;
          source: 'web-vitals';
        };
        LCP: {
          value: number | null;
          previousValue?: number;
          source: 'web-vitals';
        };
        CLS: {
          value: number | null;
          previousValue?: number;
          source: 'web-vitals';
        };
        TBT: {
          value: number | null;
          previousValue?: number;
          source: 'web-vitals';
        };
        virtualExperienceScore?: {
          value: number | null;
          previousValue?: number;
          source: 'web-vitals';
        };
      };
    };
    path?: string;
    rerequestable: boolean;
    startedAt?: number;
    status: 'registered' | 'running' | 'completed';
    updatedAt: number;
  }[];
};

export type GetAllChecksVariables = {
  queryParams?: GetAllChecksQueryParams;
} & FetcherExtraProps;

/**
 * List all of the checks created for a deployment.
 */
export const getAllChecks = (variables: GetAllChecksVariables, signal?: AbortSignal) =>
  fetch<GetAllChecksResponse, GetAllChecksError, undefined, {}, GetAllChecksQueryParams, {}>({
    url: '/v1/deployments/{deploymentId}/checks',
    method: 'get',
    ...variables,
    signal
  });

export type GetCheckQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetCheckError = Fetcher.ErrorWrapper<undefined>;

export type GetCheckResponse = {
  createdAt?: number | null;
  creator: string;
  domain: string;
  id: string;
  name: string;
  recordType: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
  ttl?: number;
  type: 'record' | 'record-sys';
  value: string;
};

export type GetCheckVariables = {
  queryParams?: GetCheckQueryParams;
} & FetcherExtraProps;

/**
 * Return a detailed response for a single check.
 */
export const getCheck = (variables: GetCheckVariables, signal?: AbortSignal) =>
  fetch<GetCheckResponse, GetCheckError, undefined, {}, GetCheckQueryParams, {}>({
    url: '/v1/deployments/{deploymentId}/checks/{checkId}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateCheckQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type UpdateCheckError = Fetcher.ErrorWrapper<undefined>;

export type UpdateCheckResponse = {
  createdAt?: number | null;
  creator: string;
  domain: string;
  id: string;
  name: string;
  recordType: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
  ttl?: number;
  type: 'record' | 'record-sys';
  value: string;
};

export type UpdateCheckVariables = {
  queryParams?: UpdateCheckQueryParams;
} & FetcherExtraProps;

/**
 * Update an existing check. This endpoint must be called with an OAuth2 or it will produce a 400 error.
 */
export const updateCheck = (variables: UpdateCheckVariables, signal?: AbortSignal) =>
  fetch<UpdateCheckResponse, UpdateCheckError, undefined, {}, UpdateCheckQueryParams, {}>({
    url: '/v1/deployments/{deploymentId}/checks/{checkId}',
    method: 'patch',
    ...variables,
    signal
  });

export type RerequestCheckQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type RerequestCheckError = Fetcher.ErrorWrapper<undefined>;

export type RerequestCheckVariables = {
  queryParams?: RerequestCheckQueryParams;
} & FetcherExtraProps;

/**
 * Rerequest a selected check that has failed.
 */
export const rerequestCheck = (variables: RerequestCheckVariables, signal?: AbortSignal) =>
  fetch<Record<string, any>, RerequestCheckError, undefined, {}, RerequestCheckQueryParams, {}>({
    url: '/v1/deployments/{deploymentId}/checks/{checkId}/rerequest',
    method: 'post',
    ...variables,
    signal
  });

export type GetEdgeConfigsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetEdgeConfigsError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigsResponse = {
  createdAt?: number | null;
  creator?: string;
  domain?: string;
  id?: string;
  name?: string;
  recordType?: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
  ttl?: number;
  type?: 'record' | 'record-sys';
  value?: string;
  sizeInBytes: number;
  itemCount: number;
};

export type GetEdgeConfigsVariables = {
  queryParams?: GetEdgeConfigsQueryParams;
} & FetcherExtraProps;

/**
 * Returns all Edge Configs.
 */
export const getEdgeConfigs = (variables: GetEdgeConfigsVariables, signal?: AbortSignal) =>
  fetch<GetEdgeConfigsResponse, GetEdgeConfigsError, undefined, {}, GetEdgeConfigsQueryParams, {}>({
    url: '/v1/edge-config',
    method: 'get',
    ...variables,
    signal
  });

export type CreateEdgeConfigQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateEdgeConfigError = Fetcher.ErrorWrapper<undefined>;

export type CreateEdgeConfigResponse = {
  createdAt?: number | null;
  creator?: string;
  domain?: string;
  id?: string;
  name?: string;
  recordType?: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
  ttl?: number;
  type?: 'record' | 'record-sys';
  value?: string;
  sizeInBytes: number;
  itemCount: number;
};

export type CreateEdgeConfigVariables = {
  queryParams?: CreateEdgeConfigQueryParams;
} & FetcherExtraProps;

/**
 * Creates an Edge Config.
 */
export const createEdgeConfig = (variables: CreateEdgeConfigVariables, signal?: AbortSignal) =>
  fetch<CreateEdgeConfigResponse, CreateEdgeConfigError, undefined, {}, CreateEdgeConfigQueryParams, {}>({
    url: '/v1/edge-config',
    method: 'post',
    ...variables,
    signal
  });

export type GetEdgeConfigQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetEdgeConfigError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigResponse = {
  createdAt?: number | null;
  creator?: string;
  domain?: string;
  id?: string;
  name?: string;
  recordType?: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
  ttl?: number;
  type?: 'record' | 'record-sys';
  value?: string;
  sizeInBytes: number;
  itemCount: number;
};

export type GetEdgeConfigVariables = {
  queryParams?: GetEdgeConfigQueryParams;
} & FetcherExtraProps;

/**
 * Returns an Edge Config.
 */
export const getEdgeConfig = (variables: GetEdgeConfigVariables, signal?: AbortSignal) =>
  fetch<GetEdgeConfigResponse, GetEdgeConfigError, undefined, {}, GetEdgeConfigQueryParams, {}>({
    url: '/v1/edge-config/{edgeConfigId}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateEdgeConfigQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type UpdateEdgeConfigError = Fetcher.ErrorWrapper<undefined>;

export type UpdateEdgeConfigResponse = {
  createdAt?: number | null;
  creator?: string;
  domain?: string;
  id?: string;
  name?: string;
  recordType?: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
  ttl?: number;
  type?: 'record' | 'record-sys';
  value?: string;
  sizeInBytes: number;
  itemCount: number;
};

export type UpdateEdgeConfigVariables = {
  queryParams?: UpdateEdgeConfigQueryParams;
} & FetcherExtraProps;

/**
 * Updates an Edge Config.
 */
export const updateEdgeConfig = (variables: UpdateEdgeConfigVariables, signal?: AbortSignal) =>
  fetch<UpdateEdgeConfigResponse, UpdateEdgeConfigError, undefined, {}, UpdateEdgeConfigQueryParams, {}>({
    url: '/v1/edge-config/{edgeConfigId}',
    method: 'put',
    ...variables,
    signal
  });

export type DeleteEdgeConfigQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteEdgeConfigError = Fetcher.ErrorWrapper<undefined>;

export type DeleteEdgeConfigVariables = {
  queryParams?: DeleteEdgeConfigQueryParams;
} & FetcherExtraProps;

/**
 * Delete an Edge Config by id.
 */
export const deleteEdgeConfig = (variables: DeleteEdgeConfigVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteEdgeConfigError, undefined, {}, DeleteEdgeConfigQueryParams, {}>({
    url: '/v1/edge-config/{edgeConfigId}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetEdgeConfigItemsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetEdgeConfigItemsError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigItemsVariables = {
  queryParams?: GetEdgeConfigItemsQueryParams;
} & FetcherExtraProps;

/**
 * Returns all items of an Edge Config.
 */
export const getEdgeConfigItems = (variables: GetEdgeConfigItemsVariables, signal?: AbortSignal) =>
  fetch<Schemas.EdgeConfigItem, GetEdgeConfigItemsError, undefined, {}, GetEdgeConfigItemsQueryParams, {}>({
    url: '/v1/edge-config/{edgeConfigId}/items',
    method: 'get',
    ...variables,
    signal
  });

export type PatchtEdgeConfigItemsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type PatchtEdgeConfigItemsError = Fetcher.ErrorWrapper<undefined>;

export type PatchtEdgeConfigItemsResponse = {
  status: string;
};

export type PatchtEdgeConfigItemsVariables = {
  queryParams?: PatchtEdgeConfigItemsQueryParams;
} & FetcherExtraProps;

/**
 * Update multiple Edge Config Items in batch.
 */
export const patchtEdgeConfigItems = (variables: PatchtEdgeConfigItemsVariables, signal?: AbortSignal) =>
  fetch<PatchtEdgeConfigItemsResponse, PatchtEdgeConfigItemsError, undefined, {}, PatchtEdgeConfigItemsQueryParams, {}>(
    { url: '/v1/edge-config/{edgeConfigId}/items', method: 'patch', ...variables, signal }
  );

export type GetEdgeConfigItemQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetEdgeConfigItemError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigItemVariables = {
  queryParams?: GetEdgeConfigItemQueryParams;
} & FetcherExtraProps;

/**
 * Returns a specific Edge Config Item.
 */
export const getEdgeConfigItem = (variables: GetEdgeConfigItemVariables, signal?: AbortSignal) =>
  fetch<Schemas.EdgeConfigItem, GetEdgeConfigItemError, undefined, {}, GetEdgeConfigItemQueryParams, {}>({
    url: '/v1/edge-config/{edgeConfigId}/item/{edgeConfigItemKey}',
    method: 'get',
    ...variables,
    signal
  });

export type GetEdgeConfigTokensQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetEdgeConfigTokensError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigTokensVariables = {
  queryParams?: GetEdgeConfigTokensQueryParams;
} & FetcherExtraProps;

/**
 * Returns all tokens of an Edge Config.
 */
export const getEdgeConfigTokens = (variables: GetEdgeConfigTokensVariables, signal?: AbortSignal) =>
  fetch<Schemas.EdgeConfigToken, GetEdgeConfigTokensError, undefined, {}, GetEdgeConfigTokensQueryParams, {}>({
    url: '/v1/edge-config/{edgeConfigId}/tokens',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteEdgeConfigTokensQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteEdgeConfigTokensError = Fetcher.ErrorWrapper<undefined>;

export type DeleteEdgeConfigTokensVariables = {
  queryParams?: DeleteEdgeConfigTokensQueryParams;
} & FetcherExtraProps;

/**
 * Deletes one or more tokens of an existing Edge Config.
 */
export const deleteEdgeConfigTokens = (variables: DeleteEdgeConfigTokensVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteEdgeConfigTokensError, undefined, {}, DeleteEdgeConfigTokensQueryParams, {}>({
    url: '/v1/edge-config/{edgeConfigId}/tokens',
    method: 'delete',
    ...variables,
    signal
  });

export type GetEdgeConfigTokenQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetEdgeConfigTokenError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigTokenVariables = {
  queryParams?: GetEdgeConfigTokenQueryParams;
} & FetcherExtraProps;

/**
 * Return meta data about an Edge Config token.
 */
export const getEdgeConfigToken = (variables: GetEdgeConfigTokenVariables, signal?: AbortSignal) =>
  fetch<Schemas.EdgeConfigToken, GetEdgeConfigTokenError, undefined, {}, GetEdgeConfigTokenQueryParams, {}>({
    url: '/v1/edge-config/{edgeConfigId}/token/{token}',
    method: 'get',
    ...variables,
    signal
  });

export type CreateEdgeConfigTokenQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateEdgeConfigTokenError = Fetcher.ErrorWrapper<undefined>;

export type CreateEdgeConfigTokenResponse = {
  token: string;
  id: string;
};

export type CreateEdgeConfigTokenVariables = {
  queryParams?: CreateEdgeConfigTokenQueryParams;
} & FetcherExtraProps;

/**
 * Adds a token to an existing Edge Config.
 */
export const createEdgeConfigToken = (variables: CreateEdgeConfigTokenVariables, signal?: AbortSignal) =>
  fetch<CreateEdgeConfigTokenResponse, CreateEdgeConfigTokenError, undefined, {}, CreateEdgeConfigTokenQueryParams, {}>(
    { url: '/v1/edge-config/{edgeConfigId}/token', method: 'post', ...variables, signal }
  );

export const operationsByTag = {
  artifacts: { recordEvents, status, uploadArtifact, downloadArtifact, artifactQuery },
  deployments: {
    getDeployment,
    createDeployment,
    cancelDeployment,
    getDeploymentEvents,
    uploadFile,
    deleteDeployment,
    getDeployments,
    listDeploymentFiles,
    getDeploymentFileContents
  },
  certs: { getCertById, removeCert, issueCert, uploadCert },
  user: { listUserEvents, getAuthUser, requestDelete },
  aliases: { listAliases, getAlias, deleteAlias, listDeploymentAliases, assignAlias },
  authentication: { listAuthTokens, createAuthToken, getAuthToken, deleteAuthToken, verifyToken, emailLogin },
  dns: { getRecords, createRecord, updateRecord, removeRecord },
  domains: {
    checkDomainStatus,
    checkDomainPrice,
    buyDomain,
    getDomainConfig,
    getDomain,
    getDomains,
    createOrTransferDomain,
    deleteDomain
  },
  secrets: { getSecrets, createSecret, renameSecret, getSecret, deleteSecret },
  projects: {
    getProjects,
    createProject,
    getProject,
    updateProject,
    deleteProject,
    getProjectDomains,
    getProjectDomain,
    updateProjectDomain,
    removeProjectDomain,
    addProjectDomain,
    verifyProjectDomain,
    filterProjectEnvs,
    getProjectEnv,
    createProjectEnv,
    removeProjectEnv,
    editProjectEnv
  },
  integrations: { getConfigurations, getConfiguration, deleteConfiguration, gitNamespaces, searchRepo },
  logDrains: {
    getIntegrationLogDrains,
    createLogDrain,
    deleteIntegrationLogDrain,
    getConfigurableLogDrain,
    deleteConfigurableLogDrain,
    getConfigurableLogDrains,
    createConfigurableLogDrain
  },
  webhooks: { createWebhook, getWebhooks, getWebhook, deleteWebhook },
  teams: {
    getTeam,
    patchTeam,
    getTeams,
    createTeam,
    deleteTeam,
    deleteTeamInviteCode,
    getTeamMembers,
    inviteUserToTeam,
    requestAccessToTeam,
    getTeamAccessRequest,
    joinTeam,
    updateTeamMember,
    removeTeamMember
  },
  checks: { createCheck, getAllChecks, getCheck, updateCheck, rerequestCheck },
  edgeConfig: {
    getEdgeConfigs,
    createEdgeConfig,
    getEdgeConfig,
    updateEdgeConfig,
    deleteEdgeConfig,
    getEdgeConfigItems,
    patchtEdgeConfigItems,
    getEdgeConfigItem,
    getEdgeConfigTokens,
    deleteEdgeConfigTokens,
    getEdgeConfigToken,
    createEdgeConfigToken
  }
};
