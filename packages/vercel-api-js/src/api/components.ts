/**
 * Generated by @openapi-codegen
 *
 * @version 0.0.1
 */
import type * as Fetcher from './fetcher';
import { fetch, FetcherExtraProps } from './fetcher';
import type * as Schemas from './schemas';

export type RecordEventsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type RecordEventsHeaders = {
  /**
   * The continuous integration or delivery environment where this artifact is downloaded.
   *
   * @example VERCEL
   * @maxLength 50
   */
  ['x-artifact-client-ci']?: string;
  /**
   * 1 if the client is an interactive shell. Otherwise 0
   *
   * @example 0
   * @minimum 0
   * @maximum 1
   */
  ['x-artifact-client-interactive']?: number;
};

export type RecordEventsError = Fetcher.ErrorWrapper<undefined>;

export type RecordEventsRequestBody = {
  /**
   * A UUID (universally unique identifer) for the session that generated this event.
   */
  sessionId: string;
  /**
   * One of `LOCAL` or `REMOTE`. `LOCAL` specifies that the cache event was from the user's filesystem cache. `REMOTE` specifies that the cache event is from a remote cache.
   */
  source: 'LOCAL' | 'REMOTE';
  /**
   * One of `HIT` or `MISS`. `HIT` specifies that a cached artifact for `hash` was found in the cache. `MISS` specifies that a cached artifact with `hash` was not found.
   */
  event: 'HIT' | 'MISS';
  /**
   * The artifact hash
   *
   * @example 12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  hash: string;
  /**
   * The time taken to generate the artifact. This should be sent as a body parameter on `HIT` events.
   *
   * @example 400
   */
  duration?: number;
}[];

export type RecordEventsVariables = {
  body?: RecordEventsRequestBody;
  headers?: RecordEventsHeaders;
  queryParams?: RecordEventsQueryParams;
} & FetcherExtraProps;

/**
 * Records an artifacts cache usage event. The body of this request is an array of cache usage events. The supported event types are `HIT` and `MISS`. The source is either `LOCAL` the cache event was on the users filesystem cache or `REMOTE` if the cache event is for a remote cache. When the event is a `HIT` the request also accepts a number `duration` which is the time taken to generate the artifact in the cache.
 */
export const recordEvents = (variables: RecordEventsVariables, signal?: AbortSignal) =>
  fetch<undefined, RecordEventsError, RecordEventsRequestBody, RecordEventsHeaders, RecordEventsQueryParams, {}>({
    url: '/v8/artifacts/events',
    method: 'post',
    ...variables,
    signal
  });

export type StatusQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type StatusError = Fetcher.ErrorWrapper<undefined>;

export type StatusResponse = {
  status: 'disabled' | 'enabled' | 'over_limit' | 'paused';
};

export type StatusVariables = {
  queryParams?: StatusQueryParams;
} & FetcherExtraProps;

/**
 * Check the status of Remote Caching for this principal. Returns a JSON-encoded status indicating if Remote Caching is enabled, disabled, or disabled due to usage limits.
 */
export const status = (variables: StatusVariables, signal?: AbortSignal) =>
  fetch<StatusResponse, StatusError, undefined, {}, StatusQueryParams, {}>({
    url: '/v8/artifacts/status',
    method: 'get',
    ...variables,
    signal
  });

export type UploadArtifactPathParams = {
  /**
   * The artifact hash
   *
   * @example 12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  hash: string;
};

export type UploadArtifactQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type UploadArtifactHeaders = {
  /**
   * The artifact size in bytes
   */
  ['Content-Length']: number;
  /**
   * The time taken to generate the uploaded artifact in milliseconds.
   *
   * @example 400
   */
  ['x-artifact-duration']?: number;
  /**
   * The continuous integration or delivery environment where this artifact was generated.
   *
   * @example VERCEL
   * @maxLength 50
   */
  ['x-artifact-client-ci']?: string;
  /**
   * 1 if the client is an interactive shell. Otherwise 0
   *
   * @example 0
   * @minimum 0
   * @maximum 1
   */
  ['x-artifact-client-interactive']?: number;
  /**
   * The base64 encoded tag for this artifact. The value is sent back to clients when the artifact is downloaded as the header `x-artifact-tag`
   *
   * @example Tc0BmHvJYMIYJ62/zx87YqO0Flxk+5Ovip25NY825CQ=
   * @maxLength 600
   */
  ['x-artifact-tag']?: string;
};

export type UploadArtifactError = Fetcher.ErrorWrapper<undefined>;

export type UploadArtifactResponse = {
  /**
   * Array of URLs where the artifact was updated
   *
   * @example https://api.vercel.com/v2/now/artifact/12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  urls: string[];
};

export type UploadArtifactVariables = {
  body?: Blob;
  headers: UploadArtifactHeaders;
  pathParams: UploadArtifactPathParams;
  queryParams?: UploadArtifactQueryParams;
} & FetcherExtraProps;

/**
 * Uploads a cache artifact identified by the `hash` specified on the path. The cache artifact can then be downloaded with the provided `hash`.
 */
export const uploadArtifact = (variables: UploadArtifactVariables, signal?: AbortSignal) =>
  fetch<
    UploadArtifactResponse,
    UploadArtifactError,
    Blob,
    UploadArtifactHeaders,
    UploadArtifactQueryParams,
    UploadArtifactPathParams
  >({ url: '/v8/artifacts/{hash}', method: 'put', ...variables, signal });

export type DownloadArtifactPathParams = {
  /**
   * The artifact hash
   *
   * @example 12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  hash: string;
};

export type DownloadArtifactQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DownloadArtifactHeaders = {
  /**
   * The continuous integration or delivery environment where this artifact is downloaded.
   *
   * @example VERCEL
   * @maxLength 50
   */
  ['x-artifact-client-ci']?: string;
  /**
   * 1 if the client is an interactive shell. Otherwise 0
   *
   * @example 0
   * @minimum 0
   * @maximum 1
   */
  ['x-artifact-client-interactive']?: number;
};

export type DownloadArtifactError = Fetcher.ErrorWrapper<undefined>;

export type DownloadArtifactVariables = {
  headers?: DownloadArtifactHeaders;
  pathParams: DownloadArtifactPathParams;
  queryParams?: DownloadArtifactQueryParams;
} & FetcherExtraProps;

/**
 * Downloads a cache artifact indentified by its `hash` specified on the request path. The artifact is downloaded as an octet-stream. The client should verify the content-length header and response body.
 */
export const downloadArtifact = (variables: DownloadArtifactVariables, signal?: AbortSignal) =>
  fetch<
    Blob,
    DownloadArtifactError,
    undefined,
    DownloadArtifactHeaders,
    DownloadArtifactQueryParams,
    DownloadArtifactPathParams
  >({ url: '/v8/artifacts/{hash}', method: 'get', ...variables, signal });

export type ArtifactQueryQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type ArtifactQueryError = Fetcher.ErrorWrapper<undefined>;

export type ArtifactQueryResponse = {
  [key: string]:
    | {
        size: number;
        taskDurationMs: number;
        tag?: string;
      }
    | {
        name: string;
        message: string;
        stack?: string;
      }
    | null;
};

export type ArtifactQueryRequestBody = {
  /**
   * artifact hashes
   */
  hashes: string[];
};

export type ArtifactQueryVariables = {
  body: ArtifactQueryRequestBody;
  queryParams?: ArtifactQueryQueryParams;
} & FetcherExtraProps;

/**
 * Query information about an array of artifacts.
 */
export const artifactQuery = (variables: ArtifactQueryVariables, signal?: AbortSignal) =>
  fetch<ArtifactQueryResponse, ArtifactQueryError, ArtifactQueryRequestBody, {}, ArtifactQueryQueryParams, {}>({
    url: '/v8/artifacts',
    method: 'post',
    ...variables,
    signal
  });

export type GetDeploymentPathParams = {
  /**
   * The unique identifier or hostname of the deployment.
   *
   * @example dpl_89qyp1cskzkLrVicDaZoDbjyHuDJ
   */
  idOrUrl: string;
};

export type GetDeploymentQueryParams = {
  /**
   * Whether to add in gitRepo information.
   *
   * @example true
   */
  withGitRepoInfo?: string;
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetDeploymentError = Fetcher.ErrorWrapper<undefined>;

export type GetDeploymentVariables = {
  pathParams: GetDeploymentPathParams;
  queryParams?: GetDeploymentQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves information for a deployment either by supplying its ID (`id` property) or Hostname (`url` property). Additional details will be included when the authenticated user is an owner of the deployment.
 */
export const getDeployment = (variables: GetDeploymentVariables, signal?: AbortSignal) =>
  fetch<
    | {
        aliasAssignedAt?: number | boolean | null;
        build: {
          /**
           * The keys of the environment variables that were assigned during the build phase.
           *
           * @example MY_ENV_VAR
           */
          env: string[];
        };
        builds?: Record<string, any>[];
        /**
         * The region where the deployment was first created
         *
         * @example sfo1
         */
        createdIn: string;
        /**
         * The keys of the environment variables that were assigned during runtime
         *
         * @example MY_SECRET
         */
        env: string[];
        /**
         * An object used to configure your Serverless Functions
         *
         * @example {"api/test.js":{"memory":3008}}
         */
        functions?: {
          [key: string]: {
            memory?: number;
            maxDuration?: number;
            runtime?: string;
            includeFiles?: string;
            excludeFiles?: string;
          };
        } | null;
        /**
         * Vercel URL to inspect the deployment.
         *
         * @example https://vercel.com/acme/nextjs/J1hXN00qjUeoYfpEEf7dnDtpSiVq
         */
        inspectorUrl: string | null;
        /**
         * Is the deployment currently queued waiting for a Concurrent Build Slot to be available
         *
         * @example false
         */
        isInConcurrentBuildsQueue: boolean;
        /**
         * An object containing the deployment's metadata
         *
         * @example {"foo":"bar"}
         */
        meta: {
          [key: string]: string;
        };
        /**
         * An monorepo manager that was used for the deployment
         *
         * @example turbo
         */
        monorepoManager?: string | null;
        /**
         * The name of the project associated with the deployment at the time that the deployment was created
         *
         * @example my-project
         */
        name: string;
        /**
         * The unique ID of the user or team the deployment belongs to
         *
         * @example ZspSRT4ljIEEmMHgoDwKWDei
         */
        ownerId: string;
        /**
         * The pricing plan the deployment was made under
         *
         * @example pro
         */
        plan: 'hobby' | 'enterprise' | 'pro' | 'oss';
        /**
         * The ID of the project the deployment is associated with
         *
         * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
         */
        projectId: string;
        /**
         * A list of routes objects used to rewrite paths to point towards other internal or external paths
         *
         * @example {"src":"/docs","dest":"https://docs.example.com"}
         */
        routes:
          | (
              | {
                  src: string;
                  dest?: string;
                  headers?: {
                    [key: string]: string;
                  };
                  methods?: string[];
                  ['continue']?: boolean;
                  override?: boolean;
                  caseSensitive?: boolean;
                  check?: boolean;
                  important?: boolean;
                  status?: number;
                  has?: (
                    | {
                        type: 'host';
                        value: string;
                      }
                    | {
                        type: 'header' | 'cookie' | 'query';
                        key: string;
                        value?: string;
                      }
                  )[];
                  missing?: (
                    | {
                        type: 'host';
                        value: string;
                      }
                    | {
                        type: 'header' | 'cookie' | 'query';
                        key: string;
                        value?: string;
                      }
                  )[];
                  locale?: {
                    /**
                     * Construct a type with a set of properties K of type T
                     */
                    redirect?: {
                      [key: string]: string;
                    };
                    cookie?: string;
                  };
                  /**
                   * A middleware key within the `output` key under the build result. Overrides a `middleware` definition.
                   */
                  middlewarePath?: string;
                  /**
                   * The original middleware matchers.
                   */
                  middlewareRawSrc?: string[];
                  /**
                   * A middleware index in the `middleware` key under the build result
                   */
                  middleware?: number;
                }
              | {
                  handle: 'filesystem' | 'hit' | 'miss' | 'rewrite' | 'error' | 'resource';
                  src?: string;
                  dest?: string;
                  status?: number;
                }
              | {
                  src: string;
                  ['continue']: boolean;
                  middleware: 0;
                }
            )[]
          | null;
        gitRepo?:
          | {
              namespace: string;
              projectId: number;
              type: 'gitlab';
              url: string;
              path: string;
              defaultBranch: string;
              name: string;
              private: boolean;
              ownerType: 'team' | 'user';
            }
          | {
              org: string;
              repo: string;
              repoId: number;
              type: 'github';
              repoOwnerId: string;
              path: string;
              defaultBranch: string;
              name: string;
              private: boolean;
              ownerType: 'team' | 'user';
            }
          | {
              owner: string;
              repoUuid: string;
              slug: string;
              type: 'bitbucket';
              workspaceUuid: string;
              path: string;
              defaultBranch: string;
              name: string;
              private: boolean;
              ownerType: 'team' | 'user';
            }
          | null;
        /**
         * A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation
         */
        alias: string[];
        /**
         * A boolean that will be true when the aliases from the alias property were assigned successfully
         *
         * @example true
         */
        aliasAssigned: boolean;
        /**
         * An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null`
         *
         * @example null
         */
        aliasError?: {
          code: string;
          message: string;
        } | null;
        aliasFinal?: string | null;
        aliasWarning?: {
          code: string;
          message: string;
          link?: string;
          action?: string;
        } | null;
        automaticAliases?: string[];
        bootedAt: number;
        buildErrorAt?: number;
        buildingAt: number;
        canceledAt?: number;
        checksState?: 'registered' | 'running' | 'completed';
        checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
        /**
         * A number containing the date when the deployment was created in milliseconds
         *
         * @example 1540257589405
         */
        createdAt: number;
        /**
         * Information about the deployment creator
         */
        creator: {
          /**
           * The ID of the user that created the deployment
           *
           * @example 96SnxkFiMyVKsK3pnoHfx3Hz
           */
          uid: string;
          /**
           * The username of the user that created the deployment
           *
           * @example john-doe
           */
          username?: string;
        };
        errorCode?: string;
        errorLink?: string;
        errorMessage?: string | null;
        errorStep?: string;
        gitSource?:
          | {
              type: 'github';
              repoId: string | number;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'github';
              org: string;
              repo: string;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'gitlab';
              projectId: string | number;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'bitbucket';
              workspaceUuid?: string;
              repoUuid: string;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'bitbucket';
              owner: string;
              slug: string;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'custom';
              ref: string;
              sha: string;
              gitUrl: string;
            }
          | {
              type: 'github';
              ref: string;
              sha: string;
              repoId: number;
              org?: string;
              repo?: string;
            }
          | {
              type: 'gitlab';
              ref: string;
              sha: string;
              projectId: number;
            }
          | {
              type: 'bitbucket';
              ref: string;
              sha: string;
              owner?: string;
              slug?: string;
              workspaceUuid: string;
              repoUuid: string;
            };
        /**
         * A string holding the unique ID of the deployment
         *
         * @example dpl_89qyp1cskzkLrVicDaZoDbjyHuDJ
         */
        id: string;
        lambdas?: {
          id: string;
          createdAt?: number;
          entrypoint?: string | null;
          readyState?: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'READY';
          readyStateAt?: number;
          output: {
            path: string;
            functionName: string;
          }[];
        }[];
        /**
         * A boolean representing if the deployment is public or not. By default this is `false`
         *
         * @example false
         */
        public: boolean;
        /**
         * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
         *
         * @example READY
         */
        readyState: 'QUEUED' | 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'READY' | 'CANCELED';
        /**
         * The regions the deployment exists in
         *
         * @example sfo1
         */
        regions: string[];
        /**
         * Where was the deployment created from
         *
         * @example cli
         */
        source?: 'cli' | 'git' | 'import' | 'import/repo' | 'clone/repo';
        /**
         * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned
         *
         * @example null
         */
        target?: 'production' | 'staging' | null;
        /**
         * The team that owns the deployment if any
         */
        team?: {
          /**
           * The ID of the team owner
           *
           * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
           */
          id: string;
          /**
           * The name of the team owner
           *
           * @example FSociety
           */
          name: string;
          /**
           * The slug of the team owner
           *
           * @example fsociety
           */
          slug: string;
        };
        type: 'LAMBDAS';
        /**
         * A string with the unique URL of the deployment
         *
         * @example my-instant-deployment-3ij3cxz9qr.now.sh
         */
        url: string;
        /**
         * An array of domains that were provided by the user when creating the Deployment.
         *
         * @example sub1.example.com
         * @example sub2.example.com
         */
        userAliases?: string[];
        /**
         * The platform version that was used to create the deployment.
         *
         * @example 2
         */
        version: 2;
        /**
         * Whether or not preview comments are enabled for the deployment
         *
         * @example false
         */
        previewCommentsEnabled?: boolean;
      }
    | {
        /**
         * A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation
         */
        alias: string[];
        /**
         * A boolean that will be true when the aliases from the alias property were assigned successfully
         *
         * @example true
         */
        aliasAssigned: boolean;
        /**
         * An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null`
         *
         * @example null
         */
        aliasError?: {
          code: string;
          message: string;
        } | null;
        aliasFinal?: string | null;
        aliasWarning?: {
          code: string;
          message: string;
          link?: string;
          action?: string;
        } | null;
        automaticAliases?: string[];
        bootedAt: number;
        buildErrorAt?: number;
        buildingAt: number;
        canceledAt?: number;
        checksState?: 'registered' | 'running' | 'completed';
        checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
        /**
         * A number containing the date when the deployment was created in milliseconds
         *
         * @example 1540257589405
         */
        createdAt: number;
        /**
         * Information about the deployment creator
         */
        creator: {
          /**
           * The ID of the user that created the deployment
           *
           * @example 96SnxkFiMyVKsK3pnoHfx3Hz
           */
          uid: string;
          /**
           * The username of the user that created the deployment
           *
           * @example john-doe
           */
          username?: string;
        };
        errorCode?: string;
        errorLink?: string;
        errorMessage?: string | null;
        errorStep?: string;
        gitSource?:
          | {
              type: 'github';
              repoId: string | number;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'github';
              org: string;
              repo: string;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'gitlab';
              projectId: string | number;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'bitbucket';
              workspaceUuid?: string;
              repoUuid: string;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'bitbucket';
              owner: string;
              slug: string;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'custom';
              ref: string;
              sha: string;
              gitUrl: string;
            }
          | {
              type: 'github';
              ref: string;
              sha: string;
              repoId: number;
              org?: string;
              repo?: string;
            }
          | {
              type: 'gitlab';
              ref: string;
              sha: string;
              projectId: number;
            }
          | {
              type: 'bitbucket';
              ref: string;
              sha: string;
              owner?: string;
              slug?: string;
              workspaceUuid: string;
              repoUuid: string;
            };
        /**
         * A string holding the unique ID of the deployment
         *
         * @example dpl_89qyp1cskzkLrVicDaZoDbjyHuDJ
         */
        id: string;
        lambdas?: {
          id: string;
          createdAt?: number;
          entrypoint?: string | null;
          readyState?: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'READY';
          readyStateAt?: number;
          output: {
            path: string;
            functionName: string;
          }[];
        }[];
        /**
         * The name of the project associated with the deployment at the time that the deployment was created
         *
         * @example my-project
         */
        name: string;
        /**
         * An object containing the deployment's metadata
         *
         * @example {"foo":"bar"}
         */
        meta: {
          [key: string]: string;
        };
        /**
         * A boolean representing if the deployment is public or not. By default this is `false`
         *
         * @example false
         */
        public: boolean;
        /**
         * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
         *
         * @example READY
         */
        readyState: 'QUEUED' | 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'READY' | 'CANCELED';
        /**
         * The regions the deployment exists in
         *
         * @example sfo1
         */
        regions: string[];
        /**
         * Where was the deployment created from
         *
         * @example cli
         */
        source?: 'cli' | 'git' | 'import' | 'import/repo' | 'clone/repo';
        /**
         * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned
         *
         * @example null
         */
        target?: 'production' | 'staging' | null;
        /**
         * The team that owns the deployment if any
         */
        team?: {
          /**
           * The ID of the team owner
           *
           * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
           */
          id: string;
          /**
           * The name of the team owner
           *
           * @example FSociety
           */
          name: string;
          /**
           * The slug of the team owner
           *
           * @example fsociety
           */
          slug: string;
        };
        type: 'LAMBDAS';
        /**
         * A string with the unique URL of the deployment
         *
         * @example my-instant-deployment-3ij3cxz9qr.now.sh
         */
        url: string;
        /**
         * An array of domains that were provided by the user when creating the Deployment.
         *
         * @example sub1.example.com
         * @example sub2.example.com
         */
        userAliases?: string[];
        /**
         * The platform version that was used to create the deployment.
         *
         * @example 2
         */
        version: 2;
        /**
         * Whether or not preview comments are enabled for the deployment
         *
         * @example false
         */
        previewCommentsEnabled?: boolean;
      },
    GetDeploymentError,
    undefined,
    {},
    GetDeploymentQueryParams,
    GetDeploymentPathParams
  >({ url: '/v13/deployments/{idOrUrl}', method: 'get', ...variables, signal });

export type CreateDeploymentQueryParams = {
  /**
   * Forces a new deployment even if there is a previous similar deployment
   */
  forceNew?: '0' | '1';
  /**
   * Allows to skip framework detection so the API would not fail to ask for confirmation
   */
  skipAutoDetectionConfirmation?: '0' | '1';
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateDeploymentError = Fetcher.ErrorWrapper<undefined>;

export type CreateDeploymentResponse = {
  aliasAssignedAt?: number | boolean | null;
  build: {
    /**
     * The keys of the environment variables that were assigned during the build phase.
     *
     * @example MY_ENV_VAR
     */
    env: string[];
  };
  builds?: {
    use: string;
    src?: string;
    /**
     * An object containing the deployment's metadata
     *
     * @example {"foo":"bar"}
     */
    config?: {
      [key: string]: string;
    };
  }[];
  /**
   * The region where the deployment was first created
   *
   * @example sfo1
   */
  createdIn: string;
  /**
   * The keys of the environment variables that were assigned during runtime
   *
   * @example MY_SECRET
   */
  env: string[];
  /**
   * An object used to configure your Serverless Functions
   *
   * @example {"api/test.js":{"memory":3008}}
   */
  functions?: {
    [key: string]: {
      memory?: number;
      maxDuration?: number;
      runtime?: string;
      includeFiles?: string;
      excludeFiles?: string;
    };
  } | null;
  /**
   * Vercel URL to inspect the deployment.
   *
   * @example https://vercel.com/acme/nextjs/J1hXN00qjUeoYfpEEf7dnDtpSiVq
   */
  inspectorUrl: string | null;
  /**
   * Is the deployment currently queued waiting for a Concurrent Build Slot to be available
   *
   * @example false
   */
  isInConcurrentBuildsQueue: boolean;
  /**
   * An object containing the deployment's metadata
   *
   * @example {"foo":"bar"}
   */
  meta: {
    [key: string]: string;
  };
  /**
   * An monorepo manager that was used for the deployment
   *
   * @example turbo
   */
  monorepoManager?: string | null;
  /**
   * The name of the project associated with the deployment at the time that the deployment was created
   *
   * @example my-project
   */
  name: string;
  /**
   * The unique ID of the user or team the deployment belongs to
   *
   * @example ZspSRT4ljIEEmMHgoDwKWDei
   */
  ownerId: string;
  /**
   * The pricing plan the deployment was made under
   *
   * @example pro
   */
  plan: 'hobby' | 'enterprise' | 'pro' | 'oss';
  /**
   * The ID of the project the deployment is associated with
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectId: string;
  /**
   * A list of routes objects used to rewrite paths to point towards other internal or external paths
   *
   * @example {"src":"/docs","dest":"https://docs.example.com"}
   */
  routes:
    | (
        | {
            src: string;
            dest?: string;
            headers?: {
              [key: string]: string;
            };
            methods?: string[];
            ['continue']?: boolean;
            override?: boolean;
            caseSensitive?: boolean;
            check?: boolean;
            important?: boolean;
            status?: number;
            has?: (
              | {
                  type: 'host';
                  value: string;
                }
              | {
                  type: 'header' | 'cookie' | 'query';
                  key: string;
                  value?: string;
                }
            )[];
            missing?: (
              | {
                  type: 'host';
                  value: string;
                }
              | {
                  type: 'header' | 'cookie' | 'query';
                  key: string;
                  value?: string;
                }
            )[];
            locale?: {
              /**
               * Construct a type with a set of properties K of type T
               */
              redirect?: {
                [key: string]: string;
              };
              cookie?: string;
            };
            /**
             * A middleware key within the `output` key under the build result. Overrides a `middleware` definition.
             */
            middlewarePath?: string;
            /**
             * The original middleware matchers.
             */
            middlewareRawSrc?: string[];
            /**
             * A middleware index in the `middleware` key under the build result
             */
            middleware?: number;
          }
        | {
            handle: 'filesystem' | 'hit' | 'miss' | 'rewrite' | 'error' | 'resource';
            src?: string;
            dest?: string;
            status?: number;
          }
        | {
            src: string;
            ['continue']: boolean;
            middleware: 0;
          }
      )[]
    | null;
  gitRepo?:
    | {
        namespace: string;
        projectId: number;
        type: 'gitlab';
        url: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: 'team' | 'user';
      }
    | {
        org: string;
        repo: string;
        repoId: number;
        type: 'github';
        repoOwnerId: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: 'team' | 'user';
      }
    | {
        owner: string;
        repoUuid: string;
        slug: string;
        type: 'bitbucket';
        workspaceUuid: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: 'team' | 'user';
      }
    | null;
  /**
   * A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation
   */
  alias: string[];
  /**
   * A boolean that will be true when the aliases from the alias property were assigned successfully
   *
   * @example true
   */
  aliasAssigned: boolean;
  /**
   * An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null`
   *
   * @example null
   */
  aliasError?: {
    code: string;
    message: string;
  } | null;
  aliasFinal?: string | null;
  aliasWarning?: {
    code: string;
    message: string;
    link?: string;
    action?: string;
  } | null;
  automaticAliases?: string[];
  bootedAt: number;
  buildErrorAt?: number;
  buildingAt: number;
  canceledAt?: number;
  checksState?: 'registered' | 'running' | 'completed';
  checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
  /**
   * A number containing the date when the deployment was created in milliseconds
   *
   * @example 1540257589405
   */
  createdAt: number;
  /**
   * Information about the deployment creator
   */
  creator: {
    /**
     * The ID of the user that created the deployment
     *
     * @example 96SnxkFiMyVKsK3pnoHfx3Hz
     */
    uid: string;
    /**
     * The username of the user that created the deployment
     *
     * @example john-doe
     */
    username?: string;
  };
  errorCode?: string;
  errorLink?: string;
  errorMessage?: string | null;
  errorStep?: string;
  gitSource?:
    | {
        type: 'github';
        repoId: string | number;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'github';
        org: string;
        repo: string;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'gitlab';
        projectId: string | number;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'bitbucket';
        workspaceUuid?: string;
        repoUuid: string;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'bitbucket';
        owner: string;
        slug: string;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'custom';
        ref: string;
        sha: string;
        gitUrl: string;
      }
    | {
        type: 'github';
        ref: string;
        sha: string;
        repoId: number;
        org?: string;
        repo?: string;
      }
    | {
        type: 'gitlab';
        ref: string;
        sha: string;
        projectId: number;
      }
    | {
        type: 'bitbucket';
        ref: string;
        sha: string;
        owner?: string;
        slug?: string;
        workspaceUuid: string;
        repoUuid: string;
      };
  /**
   * A string holding the unique ID of the deployment
   *
   * @example dpl_89qyp1cskzkLrVicDaZoDbjyHuDJ
   */
  id: string;
  lambdas?: {
    id: string;
    createdAt?: number;
    entrypoint?: string | null;
    readyState?: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'READY';
    readyStateAt?: number;
    output: {
      path: string;
      functionName: string;
    }[];
  }[];
  /**
   * A boolean representing if the deployment is public or not. By default this is `false`
   *
   * @example false
   */
  public: boolean;
  /**
   * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
   *
   * @example READY
   */
  readyState: 'QUEUED' | 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'READY' | 'CANCELED';
  /**
   * The regions the deployment exists in
   *
   * @example sfo1
   */
  regions: string[];
  /**
   * Where was the deployment created from
   *
   * @example cli
   */
  source?: 'cli' | 'git' | 'import' | 'import/repo' | 'clone/repo';
  /**
   * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned
   *
   * @example null
   */
  target?: 'production' | 'staging' | null;
  /**
   * The team that owns the deployment if any
   */
  team?: {
    /**
     * The ID of the team owner
     *
     * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
     */
    id: string;
    /**
     * The name of the team owner
     *
     * @example FSociety
     */
    name: string;
    /**
     * The slug of the team owner
     *
     * @example fsociety
     */
    slug: string;
  };
  type: 'LAMBDAS';
  /**
   * A string with the unique URL of the deployment
   *
   * @example my-instant-deployment-3ij3cxz9qr.now.sh
   */
  url: string;
  /**
   * An array of domains that were provided by the user when creating the Deployment.
   *
   * @example sub1.example.com
   * @example sub2.example.com
   */
  userAliases?: string[];
  /**
   * The platform version that was used to create the deployment.
   *
   * @example 2
   */
  version: 2;
  /**
   * Whether or not preview comments are enabled for the deployment
   *
   * @example false
   */
  previewCommentsEnabled?: boolean;
};

export type CreateDeploymentRequestBody = {
  /**
   * Ignored. Can be set to get completions, validations and documentation in some editors.
   *
   * @example https://openapi.vercel.sh/vercel.json
   */
  $schema?: string;
  /**
   * Aliases that will get assigned when the deployment is `READY` and the target is `production`. The client needs to make a `GET` request to its API to ensure the assignment
   *
   * @example example.vercel.app
   * @maxItems 50
   * @maxLength 253
   */
  alias?: string[];
  /**
   * An object containing another object with information to be passed to the Build Process
   *
   * @deprecated true
   */
  build?: {
    /**
     * An object containing the deployment's environment variable names and values to be passed to Builds. Secrets can be referenced by prefixing the value with `@`
     *
     * @example {"A_SECRET":"@a-secret"}
     * @deprecated true
     * @maxProperties 100
     * @minProperties 0
     */
    env?: {
      [key: string]: string;
    };
  };
  /**
   * A list of build descriptions whose src references valid source files.
   *
   * @deprecated true
   * @maxItems 128
   * @minItems 0
   */
  builds?: {
    /**
     * Optionally, an object including arbitrary metadata to be passed to the Builder
     */
    config?: Record<string, any>;
    /**
     * A glob expression or pathname. If more than one file is resolved, one build will be created per matched file. It can include `*` and `**`
     *
     * @maxLength 4096
     */
    src?: string;
    /**
     * An npm module to be installed by the build process. It can include a semver compatible version (e.g.: `@org/proj@1`)
     *
     * @maxLength 256
     */
    use: string;
  }[];
  /**
   * When set to `true`, all HTML files and Serverless Functions will have their extension removed. When visiting a path that ends with the extension, a 308 response will redirect the client to the extensionless path.
   */
  cleanUrls?: boolean;
  /**
   * An object containing the deployment's environment variable names and values. Secrets can be referenced by prefixing the value with `@`
   *
   * @example {"A_SECRET":"@a-secret"}
   * @deprecated true
   * @maxProperties 100
   * @minProperties 0
   */
  env?: {
    [key: string]: string;
  };
  /**
   * An object describing custom options for your Serverless Functions. Each key must be glob pattern that matches the paths of the Serverless Functions you would like to customize (like `api/*.js` or `api/test.js`).
   *
   * @example {"src/pages/**":{"maxDuration":6,"memory":1024}}
   * @maxProperties 50
   * @minProperties 1
   */
  functions?: {
    [key: string]: {
      /**
       * A glob pattern to match files that should be excluded from your Serverless Function. If you’re using a Community Runtime, the behavior might vary.
       *
       * @maxLength 256
       */
      excludeFiles?: string;
      /**
       * A glob pattern to match files that should be included in your Serverless Function. If you’re using a Community Runtime, the behavior might vary.
       *
       * @maxLength 256
       */
      includeFiles?: string;
      /**
       * An integer defining how long your Serverless Function should be allowed to run on every request in seconds (between 1 and the maximum limit of your plan).
       *
       * @maximum 900
       * @minimum 1
       */
      maxDuration?: number;
      /**
       * An integer defining the memory your Serverless Function should be provided with (between 128 and 3008).
       *
       * @maximum 3008
       * @minimum 128
       */
      memory?: number;
      /**
       * The npm package name of a Runtime, including its version
       *
       * @maxLength 256
       */
      runtime?: string;
    };
  };
  git?: {
    /**
     * Specifies the branches that will not trigger an auto-deployment when committing to them. Any non specified branch is `true` by default.
     *
     * @example {"main":false}
     */
    deploymentEnabled?:
      | boolean
      | {
          [key: string]: boolean;
        };
  };
  /**
   * A list of header definitions.
   *
   * @maxItems 1024
   */
  headers?: {
    /**
     * A pattern that matches each incoming pathname (excluding querystring)
     *
     * @maxLength 4096
     */
    source: string;
    /**
     * An array of key/value pairs representing each response header.
     *
     * @maxItems 1024
     */
    headers: {
      /**
       * @maxLength 4096
       */
      key: string;
      /**
       * @maxLength 4096
       */
      value: string;
    }[];
    /**
     * An array of requirements that are needed to match
     *
     * @maxItems 16
     */
    has?: (
      | {
          /**
           * The type of request element to check
           */
          type: 'host';
          /**
           * A regular expression used to match the value. Named groups can be used in the destination
           *
           * @maxLength 4096
           */
          value: string;
        }
      | {
          /**
           * The type of request element to check
           */
          type: 'header' | 'cookie' | 'query';
          /**
           * The name of the element contained in the particular type
           *
           * @maxLength 4096
           */
          key: string;
          /**
           * A regular expression used to match the value. Named groups can be used in the destination
           *
           * @maxLength 4096
           */
          value?: string;
        }
    )[];
    /**
     * An array of requirements that are needed to match
     *
     * @maxItems 16
     */
    missing?: (
      | {
          /**
           * The type of request element to check
           */
          type: 'host';
          /**
           * A regular expression used to match the value. Named groups can be used in the destination
           *
           * @maxLength 4096
           */
          value: string;
        }
      | {
          /**
           * The type of request element to check
           */
          type: 'header' | 'cookie' | 'query';
          /**
           * The name of the element contained in the particular type
           *
           * @maxLength 4096
           */
          key: string;
          /**
           * A regular expression used to match the value. Named groups can be used in the destination
           *
           * @maxLength 4096
           */
          value?: string;
        }
    )[];
  }[];
  images?: {
    contentDispositionType?: 'inline' | 'attachment';
    /**
     * @maxLength 256
     */
    contentSecurityPolicy?: string;
    dangerouslyAllowSVG?: boolean;
    /**
     * @minItems 0
     * @maxItems 50
     */
    domains?: string[];
    /**
     * @minItems 1
     * @maxItems 4
     */
    formats?: ('image/avif' | 'image/webp' | 'image/jpeg' | 'image/png')[];
    /**
     * @minimum 1
     * @maximum 315360000
     */
    minimumCacheTTL?: number;
    /**
     * @minItems 0
     * @maxItems 50
     */
    remotePatterns?: {
      protocol?: 'http' | 'https';
      /**
       * @maxLength 256
       */
      hostname: string;
      /**
       * @maxLength 5
       */
      port?: string;
      /**
       * @maxLength 256
       */
      pathname?: string;
    }[];
    /**
     * @minItems 1
     * @maxItems 50
     */
    sizes: number[];
  };
  /**
   * A string with the project name used in the deployment URL
   *
   * @example my-instant-deployment
   */
  name: string;
  /**
   * Whether a deployment's source and logs are available publicly
   */
  public?: boolean;
  /**
   * A list of redirect definitions.
   *
   * @maxItems 1024
   */
  redirects?: {
    /**
     * A pattern that matches each incoming pathname (excluding querystring).
     *
     * @maxLength 4096
     */
    source: string;
    /**
     * A location destination defined as an absolute pathname or external URL.
     *
     * @maxLength 4096
     */
    destination: string;
    /**
     * A boolean to toggle between permanent and temporary redirect. When `true`, the status code is `308`. When `false` the status code is `307`.
     */
    permanent?: boolean;
    /**
     * An array of requirements that are needed to match
     *
     * @maxItems 16
     */
    has?: (
      | {
          /**
           * The type of request element to check
           */
          type: 'host';
          /**
           * A regular expression used to match the value. Named groups can be used in the destination
           *
           * @maxLength 4096
           */
          value: string;
        }
      | {
          /**
           * The type of request element to check
           */
          type: 'header' | 'cookie' | 'query';
          /**
           * The name of the element contained in the particular type
           *
           * @maxLength 4096
           */
          key: string;
          /**
           * A regular expression used to match the value. Named groups can be used in the destination
           *
           * @maxLength 4096
           */
          value?: string;
        }
    )[];
    /**
     * An array of requirements that are needed to match
     *
     * @maxItems 16
     */
    missing?: (
      | {
          /**
           * The type of request element to check
           */
          type: 'host';
          /**
           * A regular expression used to match the value. Named groups can be used in the destination
           *
           * @maxLength 4096
           */
          value: string;
        }
      | {
          /**
           * The type of request element to check
           */
          type: 'header' | 'cookie' | 'query';
          /**
           * The name of the element contained in the particular type
           *
           * @maxLength 4096
           */
          key: string;
          /**
           * A regular expression used to match the value. Named groups can be used in the destination
           *
           * @maxLength 4096
           */
          value?: string;
        }
    )[];
  }[];
  /**
   * An array of the regions the deployment's Serverless Functions should be deployed to
   *
   * @example sfo
   * @example bru
   * @maxItems 1000
   * @minItems 1
   */
  regions?: string[];
  /**
   * A list of rewrite definitions.
   *
   * @maxItems 1024
   */
  rewrites?: {
    /**
     * A pattern that matches each incoming pathname (excluding querystring).
     *
     * @maxLength 4096
     */
    source: string;
    /**
     * An absolute pathname to an existing resource or an external URL.
     *
     * @maxLength 4096
     */
    destination: string;
    /**
     * An array of requirements that are needed to match
     *
     * @maxItems 16
     */
    has?: (
      | {
          /**
           * The type of request element to check
           */
          type: 'host';
          /**
           * A regular expression used to match the value. Named groups can be used in the destination
           *
           * @maxLength 4096
           */
          value: string;
        }
      | {
          /**
           * The type of request element to check
           */
          type: 'header' | 'cookie' | 'query';
          /**
           * The name of the element contained in the particular type
           *
           * @maxLength 4096
           */
          key: string;
          /**
           * A regular expression used to match the value. Named groups can be used in the destination
           *
           * @maxLength 4096
           */
          value?: string;
        }
    )[];
    /**
     * An array of requirements that are needed to match
     *
     * @maxItems 16
     */
    missing?: (
      | {
          /**
           * The type of request element to check
           */
          type: 'host';
          /**
           * A regular expression used to match the value. Named groups can be used in the destination
           *
           * @maxLength 4096
           */
          value: string;
        }
      | {
          /**
           * The type of request element to check
           */
          type: 'header' | 'cookie' | 'query';
          /**
           * The name of the element contained in the particular type
           *
           * @maxLength 4096
           */
          key: string;
          /**
           * A regular expression used to match the value. Named groups can be used in the destination
           *
           * @maxLength 4096
           */
          value?: string;
        }
    )[];
  }[];
  /**
   * A list of routes objects used to rewrite paths to point towards other internal or external paths
   *
   * @maxItems 1024
   * @deprecated true
   * @example {"dest":"https://docs.example.com","src":"/docs"}
   */
  routes?: (
    | {
        /**
         * @maxLength 4096
         */
        src: string;
        /**
         * @maxLength 4096
         */
        dest?: string;
        /**
         * @minProperties 1
         * @maxProperties 100
         */
        headers?: {
          [key: string]: string;
        };
        /**
         * @maxItems 10
         */
        methods?: string[];
        caseSensitive?: boolean;
        important?: boolean;
        user?: boolean;
        ['continue']?: boolean;
        override?: boolean;
        check?: boolean;
        /**
         * @minimum 100
         * @maximum 999
         */
        status?: number;
        /**
         * @minProperties 1
         */
        locale?: {
          /**
           * @minProperties 1
           * @maxProperties 100
           */
          redirect?: {
            [key: string]: string;
          };
          /**
           * @maxLength 4096
           */
          value?: string;
          /**
           * @maxLength 4096
           */
          path?: string;
          /**
           * @maxLength 4096
           */
          cookie?: string;
          /**
           * @maxLength 4096
           */
          ['default']?: string;
        };
        middleware?: number;
        middlewarePath?: string;
        middlewareRawSrc?: string[];
        /**
         * An array of requirements that are needed to match
         *
         * @maxItems 16
         */
        has?: (
          | {
              /**
               * The type of request element to check
               */
              type: 'host';
              /**
               * A regular expression used to match the value. Named groups can be used in the destination
               *
               * @maxLength 4096
               */
              value: string;
            }
          | {
              /**
               * The type of request element to check
               */
              type: 'header' | 'cookie' | 'query';
              /**
               * The name of the element contained in the particular type
               *
               * @maxLength 4096
               */
              key: string;
              /**
               * A regular expression used to match the value. Named groups can be used in the destination
               *
               * @maxLength 4096
               */
              value?: string;
            }
        )[];
        /**
         * An array of requirements that are needed to match
         *
         * @maxItems 16
         */
        missing?: (
          | {
              /**
               * The type of request element to check
               */
              type: 'host';
              /**
               * A regular expression used to match the value. Named groups can be used in the destination
               *
               * @maxLength 4096
               */
              value: string;
            }
          | {
              /**
               * The type of request element to check
               */
              type: 'header' | 'cookie' | 'query';
              /**
               * The name of the element contained in the particular type
               *
               * @maxLength 4096
               */
              key: string;
              /**
               * A regular expression used to match the value. Named groups can be used in the destination
               *
               * @maxLength 4096
               */
              value?: string;
            }
        )[];
      }
    | {
        /**
         * @maxLength 32
         */
        handle: 'error' | 'filesystem' | 'hit' | 'miss' | 'resource' | 'rewrite';
      }
  )[];
  /**
   * When `false`, visiting a path that ends with a forward slash will respond with a `308` status code and redirect to the path without the trailing slash.
   */
  trailingSlash?: boolean;
  /**
   * The build command for this project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  buildCommand?: string | null;
  /**
   * @maxLength 256
   */
  ignoreCommand?: string | null;
  /**
   * The dev command for this project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  devCommand?: string | null;
  /**
   * The framework that is being used for this project. When `null` is used no framework is selected
   */
  framework?:
    | any
    | 'blitzjs'
    | 'nextjs'
    | 'gatsby'
    | 'remix'
    | 'astro'
    | 'hexo'
    | 'eleventy'
    | 'docusaurus-2'
    | 'docusaurus'
    | 'preact'
    | 'solidstart'
    | 'dojo'
    | 'ember'
    | 'vue'
    | 'scully'
    | 'ionic-angular'
    | 'angular'
    | 'polymer'
    | 'svelte'
    | 'sveltekit'
    | 'sveltekit-1'
    | 'ionic-react'
    | 'create-react-app'
    | 'gridsome'
    | 'umijs'
    | 'sapper'
    | 'saber'
    | 'stencil'
    | 'nuxtjs'
    | 'redwoodjs'
    | 'hugo'
    | 'jekyll'
    | 'brunch'
    | 'middleman'
    | 'zola'
    | 'hydrogen'
    | 'vite'
    | 'vitepress'
    | 'vuepress'
    | 'parcel'
    | 'sanity'
    | null;
  /**
   * The install command for this project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  installCommand?: string | null;
  /**
   * The output directory of the project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  outputDirectory?: string | null;
  /**
   * An array of cron jobs that should be created for production Deployments.
   *
   * @maxItems 20
   */
  crons?: {
    /**
     * @maxLength 256
     */
    schedule: string;
    /**
     * @maxLength 512
     * @pattern ^/.*
     */
    path: string;
  }[];
  /**
   * An deployment id for an existing deployment to redeploy
   */
  deploymentId?: string;
  /**
   * A list of objects with the files to be deployed
   */
  files?: (
    | {
        /**
         * The file content, it could be either a `base64` (useful for images, etc.) of the files or the plain content for source code
         */
        data: string;
        /**
         * The file content encoding, it could be either a base64 (useful for images, etc.) of the files or the plain text for source code.
         */
        encoding?: 'base64' | 'utf-8';
        /**
         * The file name including the whole path
         *
         * @example folder/file.js
         */
        file: string;
      }
    | {
        /**
         * The file path relative to the project root
         *
         * @example folder/file.js
         */
        file: string;
        /**
         * The file contents hashed with SHA1, used to check the integrity
         */
        sha?: string;
        /**
         * The file size in bytes
         */
        size?: number;
      }
  )[];
  /**
   * Populates initial git metadata for different git providers.
   */
  gitMetadata?: {
    /**
     * The git repository's remote origin url
     *
     * @example https://github.com/vercel/next.js
     */
    remoteUrl: string;
    /**
     * The name of the author of the commit
     *
     * @example kyliau
     */
    commitAuthorName?: string;
    /**
     * The commit message
     *
     * @example add method to measure Interaction to Next Paint (INP) (#36490)
     */
    commitMessage?: string;
    /**
     * The branch on which the commit was made
     *
     * @example main
     */
    commitRef?: string;
    /**
     * The hash of the commit
     *
     * @example dc36199b2234c6586ebe05ec94078a895c707e29
     */
    commitSha?: string;
    /**
     * Whether or not there have been modifications to the working tree since the latest commit
     *
     * @example true
     */
    dirty?: boolean;
  };
  /**
   * Defines the Git Repository source to be deployed. This property can not be used in combination with `files`.
   */
  gitSource?:
    | {
        ref: string;
        repoId: number | string;
        sha?: string;
        type: 'github';
      }
    | {
        org: string;
        ref: string;
        repo: string;
        sha?: string;
        type: 'github';
      }
    | {
        projectId: number | string;
        ref: string;
        sha?: string;
        type: 'gitlab';
      }
    | {
        ref: string;
        repoUuid: string;
        sha?: string;
        type: 'bitbucket';
        workspaceUuid?: string;
      }
    | {
        owner: string;
        ref: string;
        sha?: string;
        slug: string;
        type: 'bitbucket';
      };
  /**
   * An object containing the deployment's metadata. Multiple key-value pairs can be attached to a deployment
   *
   * @example {"foo":"bar"}
   * @maxProperties 100
   */
  meta?: {
    [key: string]: string;
  };
  /**
   * The monorepo manager that is being used for this deployment. When `null` is used no monorepo manager is selected
   */
  monorepoManager?: string | null;
  /**
   * The target project identifier in which the deployment will be created. When defined, this parameter overrides name
   *
   * @example my-deployment-project
   */
  project?: string;
  /**
   * Project settings that will be applied to the deployment. It is required for the first deployment of a project and will be saved for any following deployments
   */
  projectSettings?: {
    /**
     * The build command for this project. When `null` is used this value will be automatically detected
     *
     * @maxLength 256
     */
    buildCommand?: string | null;
    /**
     * @maxLength 256
     */
    commandForIgnoringBuildStep?: string | null;
    /**
     * The dev command for this project. When `null` is used this value will be automatically detected
     *
     * @maxLength 256
     */
    devCommand?: string | null;
    /**
     * The framework that is being used for this project. When `null` is used no framework is selected
     */
    framework?:
      | any
      | 'blitzjs'
      | 'nextjs'
      | 'gatsby'
      | 'remix'
      | 'astro'
      | 'hexo'
      | 'eleventy'
      | 'docusaurus-2'
      | 'docusaurus'
      | 'preact'
      | 'solidstart'
      | 'dojo'
      | 'ember'
      | 'vue'
      | 'scully'
      | 'ionic-angular'
      | 'angular'
      | 'polymer'
      | 'svelte'
      | 'sveltekit'
      | 'sveltekit-1'
      | 'ionic-react'
      | 'create-react-app'
      | 'gridsome'
      | 'umijs'
      | 'sapper'
      | 'saber'
      | 'stencil'
      | 'nuxtjs'
      | 'redwoodjs'
      | 'hugo'
      | 'jekyll'
      | 'brunch'
      | 'middleman'
      | 'zola'
      | 'hydrogen'
      | 'vite'
      | 'vitepress'
      | 'vuepress'
      | 'parcel'
      | 'sanity'
      | null;
    /**
     * The install command for this project. When `null` is used this value will be automatically detected
     *
     * @maxLength 256
     */
    installCommand?: string | null;
    /**
     * The output directory of the project. When `null` is used this value will be automatically detected
     *
     * @maxLength 256
     */
    outputDirectory?: string | null;
    /**
     * The name of a directory or relative path to the source code of your project. When `null` is used it will default to the project root
     *
     * @maxLength 256
     */
    rootDirectory?: string | null;
    /**
     * The region to deploy Serverless Functions in this project
     *
     * @maxLength 4
     */
    serverlessFunctionRegion?: string | null;
    /**
     * Opts-out of the message prompting a CLI user to connect a Git repository in `vercel link`.
     *
     * @deprecated true
     */
    skipGitConnectDuringLink?: boolean;
    /**
     * Indicates if there are source files outside of the root directory, typically used for monorepos
     */
    sourceFilesOutsideRootDirectory?: boolean;
  };
  /**
   * Either not defined, `staging`, or `production`. If `staging`, a staging alias in the format `<project>.<team>.now.sh` will be assigned. If `production`, any aliases defined in `alias` will be assigned
   */
  target?: 'staging' | 'production';
  /**
   * When `true` and `deploymentId` is passed in, the sha from the previous deployment's `gitSource` is removed forcing the latest commit to be used.
   */
  withLatestCommit?: boolean;
};

export type CreateDeploymentVariables = {
  body: CreateDeploymentRequestBody;
  queryParams?: CreateDeploymentQueryParams;
} & FetcherExtraProps;

/**
 * Create a new deployment with all the required and intended data. If the deployment is not a git deployment, all files must be provided with the request, either referenced or inlined. Additionally, a deployment id can be specified to redeploy a previous deployment.
 */
export const createDeployment = (variables: CreateDeploymentVariables, signal?: AbortSignal) =>
  fetch<
    CreateDeploymentResponse,
    CreateDeploymentError,
    CreateDeploymentRequestBody,
    {},
    CreateDeploymentQueryParams,
    {}
  >({ url: '/v13/deployments', method: 'post', ...variables, signal });

export type CancelDeploymentPathParams = {
  /**
   * The unique identifier of the deployment.
   *
   * @example dpl_5WJWYSyB7BpgTj3EuwF37WMRBXBtPQ2iTMJHJBJyRfd
   */
  id: string;
};

export type CancelDeploymentQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CancelDeploymentError = Fetcher.ErrorWrapper<undefined>;

export type CancelDeploymentResponse = {
  aliasAssignedAt?: number | boolean | null;
  build: {
    /**
     * The keys of the environment variables that were assigned during the build phase.
     *
     * @example MY_ENV_VAR
     */
    env: string[];
  };
  builds?: {
    use: string;
    src?: string;
    /**
     * An object containing the deployment's metadata
     *
     * @example {"foo":"bar"}
     */
    config?: {
      [key: string]: string;
    };
  }[];
  /**
   * The region where the deployment was first created
   *
   * @example sfo1
   */
  createdIn: string;
  /**
   * The keys of the environment variables that were assigned during runtime
   *
   * @example MY_SECRET
   */
  env: string[];
  /**
   * An object used to configure your Serverless Functions
   *
   * @example {"api/test.js":{"memory":3008}}
   */
  functions?: {
    [key: string]: {
      memory?: number;
      maxDuration?: number;
      runtime?: string;
      includeFiles?: string;
      excludeFiles?: string;
    };
  } | null;
  /**
   * Vercel URL to inspect the deployment.
   *
   * @example https://vercel.com/acme/nextjs/J1hXN00qjUeoYfpEEf7dnDtpSiVq
   */
  inspectorUrl: string | null;
  /**
   * Is the deployment currently queued waiting for a Concurrent Build Slot to be available
   *
   * @example false
   */
  isInConcurrentBuildsQueue: boolean;
  /**
   * An object containing the deployment's metadata
   *
   * @example {"foo":"bar"}
   */
  meta: {
    [key: string]: string;
  };
  /**
   * An monorepo manager that was used for the deployment
   *
   * @example turbo
   */
  monorepoManager?: string | null;
  /**
   * The name of the project associated with the deployment at the time that the deployment was created
   *
   * @example my-project
   */
  name: string;
  /**
   * The unique ID of the user or team the deployment belongs to
   *
   * @example ZspSRT4ljIEEmMHgoDwKWDei
   */
  ownerId: string;
  /**
   * The pricing plan the deployment was made under
   *
   * @example pro
   */
  plan: 'hobby' | 'enterprise' | 'pro' | 'oss';
  /**
   * The ID of the project the deployment is associated with
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectId: string;
  /**
   * A list of routes objects used to rewrite paths to point towards other internal or external paths
   *
   * @example {"src":"/docs","dest":"https://docs.example.com"}
   */
  routes:
    | (
        | {
            src: string;
            dest?: string;
            headers?: {
              [key: string]: string;
            };
            methods?: string[];
            ['continue']?: boolean;
            override?: boolean;
            caseSensitive?: boolean;
            check?: boolean;
            important?: boolean;
            status?: number;
            has?: (
              | {
                  type: 'host';
                  value: string;
                }
              | {
                  type: 'header' | 'cookie' | 'query';
                  key: string;
                  value?: string;
                }
            )[];
            missing?: (
              | {
                  type: 'host';
                  value: string;
                }
              | {
                  type: 'header' | 'cookie' | 'query';
                  key: string;
                  value?: string;
                }
            )[];
            locale?: {
              /**
               * Construct a type with a set of properties K of type T
               */
              redirect?: {
                [key: string]: string;
              };
              cookie?: string;
            };
            /**
             * A middleware key within the `output` key under the build result. Overrides a `middleware` definition.
             */
            middlewarePath?: string;
            /**
             * The original middleware matchers.
             */
            middlewareRawSrc?: string[];
            /**
             * A middleware index in the `middleware` key under the build result
             */
            middleware?: number;
          }
        | {
            handle: 'filesystem' | 'hit' | 'miss' | 'rewrite' | 'error' | 'resource';
            src?: string;
            dest?: string;
            status?: number;
          }
        | {
            src: string;
            ['continue']: boolean;
            middleware: 0;
          }
      )[]
    | null;
  gitRepo?:
    | {
        namespace: string;
        projectId: number;
        type: 'gitlab';
        url: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: 'user' | 'team';
      }
    | {
        org: string;
        repo: string;
        repoId: number;
        type: 'github';
        repoOwnerId: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: 'user' | 'team';
      }
    | {
        owner: string;
        repoUuid: string;
        slug: string;
        type: 'bitbucket';
        workspaceUuid: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: 'user' | 'team';
      }
    | null;
  /**
   * A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation
   */
  alias: string[];
  /**
   * A boolean that will be true when the aliases from the alias property were assigned successfully
   *
   * @example true
   */
  aliasAssigned: boolean;
  /**
   * An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null`
   *
   * @example null
   */
  aliasError?: {
    code: string;
    message: string;
  } | null;
  aliasFinal?: string | null;
  aliasWarning?: {
    code: string;
    message: string;
    link?: string;
    action?: string;
  } | null;
  automaticAliases?: string[];
  bootedAt: number;
  buildErrorAt?: number;
  buildingAt: number;
  canceledAt?: number;
  checksState?: 'registered' | 'running' | 'completed';
  checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
  /**
   * A number containing the date when the deployment was created in milliseconds
   *
   * @example 1540257589405
   */
  createdAt: number;
  /**
   * Information about the deployment creator
   */
  creator: {
    /**
     * The ID of the user that created the deployment
     *
     * @example 96SnxkFiMyVKsK3pnoHfx3Hz
     */
    uid: string;
    /**
     * The username of the user that created the deployment
     *
     * @example john-doe
     */
    username?: string;
  };
  errorCode?: string;
  errorLink?: string;
  errorMessage?: string | null;
  errorStep?: string;
  gitSource?:
    | {
        type: 'github';
        repoId: string | number;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'github';
        org: string;
        repo: string;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'gitlab';
        projectId: string | number;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'bitbucket';
        workspaceUuid?: string;
        repoUuid: string;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'bitbucket';
        owner: string;
        slug: string;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'custom';
        ref: string;
        sha: string;
        gitUrl: string;
      }
    | {
        type: 'github';
        ref: string;
        sha: string;
        repoId: number;
        org?: string;
        repo?: string;
      }
    | {
        type: 'gitlab';
        ref: string;
        sha: string;
        projectId: number;
      }
    | {
        type: 'bitbucket';
        ref: string;
        sha: string;
        owner?: string;
        slug?: string;
        workspaceUuid: string;
        repoUuid: string;
      };
  /**
   * A string holding the unique ID of the deployment
   *
   * @example dpl_89qyp1cskzkLrVicDaZoDbjyHuDJ
   */
  id: string;
  lambdas?: {
    id: string;
    createdAt?: number;
    entrypoint?: string | null;
    readyState?: 'INITIALIZING' | 'BUILDING' | 'READY' | 'ERROR';
    readyStateAt?: number;
    output: {
      path: string;
      functionName: string;
    }[];
  }[];
  /**
   * A boolean representing if the deployment is public or not. By default this is `false`
   *
   * @example false
   */
  public: boolean;
  /**
   * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
   *
   * @example READY
   */
  readyState: 'INITIALIZING' | 'BUILDING' | 'READY' | 'ERROR' | 'QUEUED' | 'CANCELED';
  /**
   * The regions the deployment exists in
   *
   * @example sfo1
   */
  regions: string[];
  /**
   * Where was the deployment created from
   *
   * @example cli
   */
  source?: 'cli' | 'git' | 'import' | 'import/repo' | 'clone/repo';
  /**
   * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned
   *
   * @example null
   */
  target?: 'staging' | 'production' | null;
  /**
   * The team that owns the deployment if any
   */
  team?: {
    /**
     * The ID of the team owner
     *
     * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
     */
    id: string;
    /**
     * The name of the team owner
     *
     * @example FSociety
     */
    name: string;
    /**
     * The slug of the team owner
     *
     * @example fsociety
     */
    slug: string;
  };
  type: 'LAMBDAS';
  /**
   * A string with the unique URL of the deployment
   *
   * @example my-instant-deployment-3ij3cxz9qr.now.sh
   */
  url: string;
  /**
   * An array of domains that were provided by the user when creating the Deployment.
   *
   * @example sub1.example.com
   * @example sub2.example.com
   */
  userAliases?: string[];
  /**
   * The platform version that was used to create the deployment.
   *
   * @example 2
   */
  version: 2;
  /**
   * Whether or not preview comments are enabled for the deployment
   *
   * @example false
   */
  previewCommentsEnabled?: boolean;
};

export type CancelDeploymentVariables = {
  pathParams: CancelDeploymentPathParams;
  queryParams?: CancelDeploymentQueryParams;
} & FetcherExtraProps;

/**
 * This endpoint allows you to cancel a deployment which is currently building, by supplying its `id` in the URL.
 */
export const cancelDeployment = (variables: CancelDeploymentVariables, signal?: AbortSignal) =>
  fetch<
    CancelDeploymentResponse,
    CancelDeploymentError,
    undefined,
    {},
    CancelDeploymentQueryParams,
    CancelDeploymentPathParams
  >({ url: '/v12/deployments/{id}/cancel', method: 'patch', ...variables, signal });

export type GetCertByIdPathParams = {
  /**
   * The cert id
   */
  id: string;
};

export type GetCertByIdQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetCertByIdError = Fetcher.ErrorWrapper<undefined>;

export type GetCertByIdResponse = {
  id: string;
  createdAt: number;
  expiresAt: number;
  autoRenew: boolean;
  cns: string[];
};

export type GetCertByIdVariables = {
  pathParams: GetCertByIdPathParams;
  queryParams?: GetCertByIdQueryParams;
} & FetcherExtraProps;

/**
 * Get cert by id
 */
export const getCertById = (variables: GetCertByIdVariables, signal?: AbortSignal) =>
  fetch<GetCertByIdResponse, GetCertByIdError, undefined, {}, GetCertByIdQueryParams, GetCertByIdPathParams>({
    url: '/v7/certs/{id}',
    method: 'get',
    ...variables,
    signal
  });

export type RemoveCertPathParams = {
  /**
   * The cert id to remove
   */
  id: string;
};

export type RemoveCertQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type RemoveCertError = Fetcher.ErrorWrapper<undefined>;

export type RemoveCertVariables = {
  pathParams: RemoveCertPathParams;
  queryParams?: RemoveCertQueryParams;
} & FetcherExtraProps;

/**
 * Remove cert
 */
export const removeCert = (variables: RemoveCertVariables, signal?: AbortSignal) =>
  fetch<Record<string, any>, RemoveCertError, undefined, {}, RemoveCertQueryParams, RemoveCertPathParams>({
    url: '/v7/certs/{id}',
    method: 'delete',
    ...variables,
    signal
  });

export type IssueCertQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type IssueCertError = Fetcher.ErrorWrapper<undefined>;

export type IssueCertResponse = {
  id: string;
  createdAt: number;
  expiresAt: number;
  autoRenew: boolean;
  cns: string[];
};

export type IssueCertRequestBody = {
  /**
   * The common names the cert should be issued for
   */
  cns?: string[];
};

export type IssueCertVariables = {
  body?: IssueCertRequestBody;
  queryParams?: IssueCertQueryParams;
} & FetcherExtraProps;

/**
 * Issue a new cert
 */
export const issueCert = (variables: IssueCertVariables, signal?: AbortSignal) =>
  fetch<IssueCertResponse, IssueCertError, IssueCertRequestBody, {}, IssueCertQueryParams, {}>({
    url: '/v7/certs',
    method: 'post',
    ...variables,
    signal
  });

export type UploadCertQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type UploadCertError = Fetcher.ErrorWrapper<undefined>;

export type UploadCertResponse = {
  id: string;
  createdAt: number;
  expiresAt: number;
  autoRenew: boolean;
  cns: string[];
};

export type UploadCertRequestBody = {
  /**
   * The certificate authority
   */
  ca: string;
  /**
   * The certificate key
   */
  key: string;
  /**
   * The certificate
   */
  cert: string;
  /**
   * Skip validation of the certificate
   */
  skipValidation?: boolean;
};

export type UploadCertVariables = {
  body: UploadCertRequestBody;
  queryParams?: UploadCertQueryParams;
} & FetcherExtraProps;

/**
 * Upload a cert
 */
export const uploadCert = (variables: UploadCertVariables, signal?: AbortSignal) =>
  fetch<UploadCertResponse, UploadCertError, UploadCertRequestBody, {}, UploadCertQueryParams, {}>({
    url: '/v7/certs',
    method: 'put',
    ...variables,
    signal
  });

export type GetDeploymentEventsPathParams = {
  /**
   * The unique identifier or hostname of the deployment.
   *
   * @example dpl_5WJWYSyB7BpgTj3EuwF37WMRBXBtPQ2iTMJHJBJyRfd
   */
  idOrUrl: string;
};

export type GetDeploymentEventsQueryParams = {
  /**
   * Order of the returned events based on the timestamp.
   *
   * @default forward
   * @example backward
   */
  direction?: 'backward' | 'forward';
  /**
   * When enabled, this endpoint will return live events as they happen.
   *
   * @example 1
   */
  follow?: 0 | 1;
  /**
   * Maximum number of events to return. Provide `-1` to return all available logs.
   *
   * @example 100
   */
  limit?: number;
  /**
   * Deployment build ID.
   *
   * @example bld_cotnkcr76
   */
  name?: string;
  /**
   * Timestamp for when build logs should be pulled from.
   *
   * @example 1540095775941
   */
  since?: number;
  /**
   * Timestamp for when the build logs should be pulled up until.
   *
   * @example 1540106318643
   */
  until?: number;
  /**
   * HTTP status code range to filter events by.
   *
   * @example 5xx
   */
  statusCode?: number | string;
  /**
   * @example 1
   */
  delimiter?: 0 | 1;
  /**
   * @example 1
   */
  builds?: 0 | 1;
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetDeploymentEventsError = Fetcher.ErrorWrapper<undefined>;

export type GetDeploymentEventsResponse = (
  | {
      type: 'command';
      created: number;
      payload: {
        deploymentId: string;
        text?: string;
        id: string;
        date: number;
        serial: string;
      };
    }
  | {
      type: 'deployment-state';
      created: number;
      payload: {
        deploymentId: string;
        info: {
          type: string;
          name: string;
          entrypoint?: string;
          path?: string;
          step?: string;
        };
        id: string;
        date: number;
        serial: string;
      };
    }
  | {
      type: 'delimiter';
      created: number;
      payload: {
        deploymentId: string;
        info: {
          type: string;
          name: string;
          entrypoint?: string;
          path?: string;
          step?: string;
        };
        id: string;
        date: number;
        serial: string;
      };
    }
  | {
      type: 'exit';
      created: number;
      payload: {
        date: number;
        text?: string;
        id: string;
        deploymentId: string;
        created: number;
        serial: string;
      };
    }
  | {
      type: 'middleware';
      created: number;
      payload: {
        deploymentId: string;
        info: {
          type: string;
          name: string;
          entrypoint?: string;
          path?: string;
          step?: string;
        };
        text?: string;
        id: string;
        date: number;
        serial: string;
        requestId?: string;
      };
    }
  | {
      type:
        | 'delimiter'
        | 'command'
        | 'stdout'
        | 'stderr'
        | 'exit'
        | 'deployment-state'
        | 'middleware'
        | 'middleware-invocation'
        | 'edge-function-invocation'
        | 'fatal';
      created: number;
      payload: {
        deploymentId: string;
        info: {
          type: string;
          name: string;
          entrypoint?: string;
          path?: string;
          step?: string;
        };
        text?: string;
        id: string;
        date: number;
        serial: string;
        statusCode?: number;
        requestId?: string;
      };
    }
)[];

export type GetDeploymentEventsVariables = {
  pathParams: GetDeploymentEventsPathParams;
  queryParams?: GetDeploymentEventsQueryParams;
} & FetcherExtraProps;

/**
 * Get the build logs of a deployment by deployment ID and build ID. It can work as an infinite stream of logs or as a JSON endpoint depending on the input parameters.
 */
export const getDeploymentEvents = (variables: GetDeploymentEventsVariables, signal?: AbortSignal) =>
  fetch<
    GetDeploymentEventsResponse,
    GetDeploymentEventsError,
    undefined,
    {},
    GetDeploymentEventsQueryParams,
    GetDeploymentEventsPathParams
  >({ url: '/v2/deployments/{idOrUrl}/events', method: 'get', ...variables, signal });

export type ListUserEventsQueryParams = {
  /**
   * Maximum number of items which may be returned.
   *
   * @example 20
   */
  limit?: number;
  /**
   * Timestamp to only include items created since then.
   *
   * @example 2019-12-08T10:00:38.976Z
   */
  since?: string;
  /**
   * Timestamp to only include items created until then.
   *
   * @example 2019-12-09T23:00:38.976Z
   */
  until?: string;
  /**
   * Comma-delimited list of event \"types\" to filter the results by.
   *
   * @example login,team-member-join,domain-buy
   */
  types?: string;
  /**
   * When retrieving events for a Team, the `userId` parameter may be specified to filter events generated by a specific member of the Team.
   *
   * @example aeIInYVk59zbFF2SxfyxxmuO
   */
  userId?: string;
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type ListUserEventsError = Fetcher.ErrorWrapper<undefined>;

export type ListUserEventsResponse = {
  /**
   * Array of events generated by the User.
   */
  events: Schemas.UserEvent[];
};

export type ListUserEventsVariables = {
  queryParams?: ListUserEventsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of "events" generated by the User on Vercel. Events are generated when the User performs a particular action, such as logging in, creating a deployment, and joining a Team (just to name a few). When the `teamId` parameter is supplied, then the events that are returned will be in relation to the Team that was specified.
 */
export const listUserEvents = (variables: ListUserEventsVariables, signal?: AbortSignal) =>
  fetch<ListUserEventsResponse, ListUserEventsError, undefined, {}, ListUserEventsQueryParams, {}>({
    url: '/v3/events',
    method: 'get',
    ...variables,
    signal
  });

export type ListAliasesQueryParams = {
  /**
   * Get only aliases of the given domain name
   *
   * @example my-test-domain.com
   * @maxItems 20
   */
  domain?: string[] | string;
  /**
   * Get only aliases created after the provided timestamp
   *
   * @deprecated true
   * @example 1540095775951
   */
  from?: number;
  /**
   * Maximum number of aliases to list from a request
   *
   * @example 10
   */
  limit?: number;
  /**
   * Filter aliases from the given `projectId`
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectId?: string;
  /**
   * Get aliases created after this JavaScript timestamp
   *
   * @example 1540095775941
   */
  since?: number;
  /**
   * Get aliases created before this JavaScript timestamp
   *
   * @example 1540095775951
   */
  until?: number;
  /**
   * Get aliases that would be rolled back for the given deployment
   *
   * @example dpl_XXX
   */
  rollbackDeploymentId?: string;
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type ListAliasesError = Fetcher.ErrorWrapper<undefined>;

export type ListAliasesResponse = {
  aliases: {
    /**
     * The alias name, it could be a `.vercel.app` subdomain or a custom domain
     *
     * @example my-alias.vercel.app
     */
    alias: string;
    /**
     * The date when the alias was created
     *
     * @format date-time
     * @example 2017-04-26T23:00:34.232Z
     */
    created: string;
    /**
     * The date when the alias was created in milliseconds since the UNIX epoch
     *
     * @example 1540095775941
     */
    createdAt?: number;
    /**
     * Information of the user who created the alias
     */
    creator?: {
      /**
       * ID of the user who created the alias
       *
       * @example 96SnxkFiMyVKsK3pnoHfx3Hz
       */
      uid: string;
      /**
       * Email of the user who created the alias
       *
       * @example john-doe@gmail.com
       */
      email: string;
      /**
       * Username of the user who created the alias
       *
       * @example john-doe
       */
      username: string;
    };
    /**
     * The date when the alias was deleted in milliseconds since the UNIX epoch
     *
     * @example 1540095775941
     */
    deletedAt?: number;
    /**
     * A map with the deployment ID, URL and metadata
     */
    deployment?: {
      /**
       * The deployment unique identifier
       *
       * @example dpl_5m8CQaRBm3FnWRW1od3wKTpaECPx
       */
      id: string;
      /**
       * The deployment unique URL
       *
       * @example my-instant-deployment-3ij3cxz9qr.now.sh
       */
      url: string;
      /**
       * The deployment metadata
       *
       * @example {}
       */
      meta?: string;
    };
    /**
     * The deployment ID
     *
     * @example dpl_5m8CQaRBm3FnWRW1od3wKTpaECPx
     */
    deploymentId: string | null;
    /**
     * The unique identifier of the project
     *
     * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
     */
    projectId: string | null;
    /**
     * Target destination domain for redirect when the alias is a redirect
     */
    redirect?: string | null;
    /**
     * Status code to be used on redirect
     */
    redirectStatusCode?: 301 | 302 | 307 | 308 | null;
    /**
     * The unique identifier of the alias
     */
    uid: string;
    /**
     * The date when the alias was updated in milliseconds since the UNIX epoch
     *
     * @example 1540095775941
     */
    updatedAt?: number;
    /**
     * Construct a type with a set of properties K of type T
     */
    protectionBypass?: {
      [key: string]: string;
    };
  }[];
  pagination: Schemas.Pagination;
};

export type ListAliasesVariables = {
  queryParams?: ListAliasesQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of aliases for the authenticated User or Team. When `domain` is provided, only aliases for that domain will be returned. When `projectId` is provided, it will only return the given project aliases.
 */
export const listAliases = (variables: ListAliasesVariables, signal?: AbortSignal) =>
  fetch<ListAliasesResponse, ListAliasesError, undefined, {}, ListAliasesQueryParams, {}>({
    url: '/v4/aliases',
    method: 'get',
    ...variables,
    signal
  });

export type GetAliasPathParams = {
  /**
   * The alias or alias ID to be retrieved
   *
   * @example example.vercel.app
   */
  idOrAlias: string;
};

export type GetAliasQueryParams = {
  /**
   * Get the alias only if it was created after the provided timestamp
   *
   * @deprecated true
   * @example 1540095775951
   */
  from?: number;
  /**
   * Get the alias only if it is assigned to the provided project ID
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectId?: string;
  /**
   * Get the alias only if it was created after this JavaScript timestamp
   *
   * @example 1540095775941
   */
  since?: number;
  /**
   * Get the alias only if it was created before this JavaScript timestamp
   *
   * @example 1540095775951
   */
  until?: number;
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetAliasError = Fetcher.ErrorWrapper<undefined>;

export type GetAliasResponse = {
  /**
   * The alias name, it could be a `.vercel.app` subdomain or a custom domain
   *
   * @example my-alias.vercel.app
   */
  alias: string;
  /**
   * The date when the alias was created
   *
   * @format date-time
   * @example 2017-04-26T23:00:34.232Z
   */
  created: string;
  /**
   * The date when the alias was created in milliseconds since the UNIX epoch
   *
   * @example 1540095775941
   */
  createdAt?: number;
  /**
   * Information of the user who created the alias
   */
  creator?: {
    /**
     * ID of the user who created the alias
     *
     * @example 96SnxkFiMyVKsK3pnoHfx3Hz
     */
    uid: string;
    /**
     * Email of the user who created the alias
     *
     * @example john-doe@gmail.com
     */
    email: string;
    /**
     * Username of the user who created the alias
     *
     * @example john-doe
     */
    username: string;
  };
  /**
   * The date when the alias was deleted in milliseconds since the UNIX epoch
   *
   * @example 1540095775941
   */
  deletedAt?: number;
  /**
   * A map with the deployment ID, URL and metadata
   */
  deployment?: {
    /**
     * The deployment unique identifier
     *
     * @example dpl_5m8CQaRBm3FnWRW1od3wKTpaECPx
     */
    id: string;
    /**
     * The deployment unique URL
     *
     * @example my-instant-deployment-3ij3cxz9qr.now.sh
     */
    url: string;
    /**
     * The deployment metadata
     *
     * @example {}
     */
    meta?: string;
  };
  /**
   * The deployment ID
   *
   * @example dpl_5m8CQaRBm3FnWRW1od3wKTpaECPx
   */
  deploymentId: string | null;
  /**
   * The unique identifier of the project
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectId: string | null;
  /**
   * Target destination domain for redirect when the alias is a redirect
   */
  redirect?: string | null;
  /**
   * Status code to be used on redirect
   */
  redirectStatusCode?: 301 | 302 | 307 | 308 | null;
  /**
   * The unique identifier of the alias
   */
  uid: string;
  /**
   * The date when the alias was updated in milliseconds since the UNIX epoch
   *
   * @example 1540095775941
   */
  updatedAt?: number;
  /**
   * Construct a type with a set of properties K of type T
   */
  protectionBypass?: {
    [key: string]: string;
  };
};

export type GetAliasVariables = {
  pathParams: GetAliasPathParams;
  queryParams?: GetAliasQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves an Alias for the given host name or alias ID.
 */
export const getAlias = (variables: GetAliasVariables, signal?: AbortSignal) =>
  fetch<GetAliasResponse, GetAliasError, undefined, {}, GetAliasQueryParams, GetAliasPathParams>({
    url: '/v4/aliases/{idOrAlias}',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteAliasPathParams = {
  /**
   * The ID or alias that will be removed
   *
   * @example 2WjyKQmM8ZnGcJsPWMrHRHrE
   */
  aliasId: string;
};

export type DeleteAliasQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteAliasError = Fetcher.ErrorWrapper<undefined>;

export type DeleteAliasResponse = {
  status: 'SUCCESS';
};

export type DeleteAliasVariables = {
  pathParams: DeleteAliasPathParams;
  queryParams?: DeleteAliasQueryParams;
} & FetcherExtraProps;

/**
 * Delete an Alias with the specified ID.
 */
export const deleteAlias = (variables: DeleteAliasVariables, signal?: AbortSignal) =>
  fetch<DeleteAliasResponse, DeleteAliasError, undefined, {}, DeleteAliasQueryParams, DeleteAliasPathParams>({
    url: '/v2/aliases/{aliasId}',
    method: 'delete',
    ...variables,
    signal
  });

export type ListDeploymentAliasesPathParams = {
  /**
   * The ID of the deployment the aliases should be listed for
   *
   * @example dpl_FjvFJncQHQcZMznrUm9EoB8sFuPa
   */
  id: string;
};

export type ListDeploymentAliasesQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type ListDeploymentAliasesError = Fetcher.ErrorWrapper<undefined>;

export type ListDeploymentAliasesResponse = {
  /**
   * A list of the aliases assigned to the deployment
   */
  aliases: {
    /**
     * The unique identifier of the alias
     *
     * @example 2WjyKQmM8ZnGcJsPWMrHRHrE
     */
    uid: string;
    /**
     * The alias name, it could be a `.vercel.app` subdomain or a custom domain
     *
     * @example my-alias.vercel.app
     */
    alias: string;
    /**
     * The date when the alias was created
     *
     * @format date-time
     * @example 2017-04-26T23:00:34.232Z
     */
    created: string;
    /**
     * Target destination domain for redirect when the alias is a redirect
     */
    redirect?: string | null;
    /**
     * Construct a type with a set of properties K of type T
     */
    protectionBypass?: {
      [key: string]: string;
    };
  }[];
};

export type ListDeploymentAliasesVariables = {
  pathParams: ListDeploymentAliasesPathParams;
  queryParams?: ListDeploymentAliasesQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves all Aliases for the Deployment with the given ID. The authenticated User must own the deployment.
 */
export const listDeploymentAliases = (variables: ListDeploymentAliasesVariables, signal?: AbortSignal) =>
  fetch<
    ListDeploymentAliasesResponse,
    ListDeploymentAliasesError,
    undefined,
    {},
    ListDeploymentAliasesQueryParams,
    ListDeploymentAliasesPathParams
  >({ url: '/v2/deployments/{id}/aliases', method: 'get', ...variables, signal });

export type AssignAliasPathParams = {
  /**
   * The ID of the deployment the aliases should be listed for
   *
   * @example dpl_FjvFJncQHQcZMznrUm9EoB8sFuPa
   */
  id: string;
};

export type AssignAliasQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type AssignAliasError = Fetcher.ErrorWrapper<undefined>;

export type AssignAliasResponse = {
  /**
   * The unique identifier of the alias
   *
   * @example 2WjyKQmM8ZnGcJsPWMrHRHrE
   */
  uid: string;
  /**
   * The assigned alias name
   *
   * @example my-alias.vercel.app
   */
  alias: string;
  /**
   * The date when the alias was created
   *
   * @format date-time
   * @example 2017-04-26T23:00:34.232Z
   */
  created: string;
  /**
   * The unique identifier of the previously aliased deployment, only received when the alias was used before
   *
   * @example dpl_FjvFJncQHQcZMznrUm9EoB8sFuPa
   */
  oldDeploymentId?: string | null;
};

export type AssignAliasRequestBody = {
  /**
   * The alias we want to assign to the deployment defined in the URL
   *
   * @example my-alias.vercel.app
   */
  alias?: string;
  /**
   * The redirect property will take precedence over the deployment id from the URL and consists of a hostname (like test.com) to which the alias should redirect using status code 307
   *
   * @example null
   */
  redirect?: string | null;
};

export type AssignAliasVariables = {
  body?: AssignAliasRequestBody;
  pathParams: AssignAliasPathParams;
  queryParams?: AssignAliasQueryParams;
} & FetcherExtraProps;

/**
 * Creates a new alias for the deployment with the given deployment ID. The authenticated user must own this deployment. If the desired alias is already assigned to another deployment, then it will be removed from the old deployment and assigned to the new one.
 */
export const assignAlias = (variables: AssignAliasVariables, signal?: AbortSignal) =>
  fetch<
    AssignAliasResponse,
    AssignAliasError,
    AssignAliasRequestBody,
    {},
    AssignAliasQueryParams,
    AssignAliasPathParams
  >({ url: '/v2/deployments/{id}/aliases', method: 'post', ...variables, signal });

export type UploadFileQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type UploadFileHeaders = {
  /**
   * The file size in bytes
   */
  ['Content-Length']?: number;
  /**
   * The file SHA1 used to check the integrity
   *
   * @maxLength 40
   */
  ['x-vercel-digest']?: string;
  /**
   * The file SHA1 used to check the integrity
   *
   * @deprecated true
   * @maxLength 40
   */
  ['x-now-digest']?: string;
  /**
   * The file size as an alternative to `Content-Length`
   *
   * @deprecated true
   */
  ['x-now-size']?: number;
};

export type UploadFileError = Fetcher.ErrorWrapper<undefined>;

export type UploadFileVariables = {
  headers?: UploadFileHeaders;
  queryParams?: UploadFileQueryParams;
} & FetcherExtraProps;

/**
 * Before you create a deployment you need to upload the required files for that deployment. To do it, you need to first upload each file to this endpoint. Once that's completed, you can create a new deployment with the uploaded files. The file content must be placed inside the body of the request. In the case of a successful response you'll receive a status code 200 with an empty body.
 */
export const uploadFile = (variables: UploadFileVariables, signal?: AbortSignal) =>
  fetch<
    | {
        /**
         * Array of URLs where the file was updated
         *
         * @example example-upload.aws.com
         */
        urls: string[];
      }
    | Record<string, any>,
    UploadFileError,
    undefined,
    UploadFileHeaders,
    UploadFileQueryParams,
    {}
  >({ url: '/v2/files', method: 'post', ...variables, signal });

export type GetAuthUserError = Fetcher.ErrorWrapper<undefined>;

export type GetAuthUserResponse = {
  user: Schemas.AuthUser | Schemas.AuthUserLimited;
};

export type GetAuthUserVariables = FetcherExtraProps;

/**
 * Retrieves information related to the currently authenticated User.
 */
export const getAuthUser = (variables: GetAuthUserVariables, signal?: AbortSignal) =>
  fetch<GetAuthUserResponse, GetAuthUserError, undefined, {}, {}, {}>({
    url: '/v2/user',
    method: 'get',
    ...variables,
    signal
  });

export type RequestDeleteError = Fetcher.ErrorWrapper<undefined>;

export type RequestDeleteResponse = {
  /**
   * Unique identifier of the User who has initiated deletion.
   */
  id: string;
  /**
   * Email address of the User who has initiated deletion.
   */
  email: string;
  /**
   * User deletion progress status.
   *
   * @example Verification email sent
   */
  message: string;
};

export type RequestDeleteRequestBody = {
  /**
   * Optional array of objects that describe the reason why the User account is being deleted.
   */
  reasons?: {
    /**
     * Idenitifier slug of the reason why the User account is being deleted.
     */
    slug: string;
    /**
     * Description of the reason why the User account is being deleted.
     */
    description: string;
  }[];
};

export type RequestDeleteVariables = {
  body?: RequestDeleteRequestBody;
} & FetcherExtraProps;

/**
 * Initiates the deletion process for the currently authenticated User, by sending a deletion confirmation email. The email contains a link that the user needs to visit in order to proceed with the deletion process.
 */
export const requestDelete = (variables: RequestDeleteVariables, signal?: AbortSignal) =>
  fetch<RequestDeleteResponse, RequestDeleteError, RequestDeleteRequestBody, {}, {}, {}>({
    url: '/v1/user',
    method: 'delete',
    ...variables,
    signal
  });

export type ListAuthTokensError = Fetcher.ErrorWrapper<undefined>;

export type ListAuthTokensResponse = {
  tokens: Schemas.AuthToken[];
  testingToken?: Schemas.AuthToken;
  pagination: Schemas.Pagination;
};

export type ListAuthTokensVariables = FetcherExtraProps;

/**
 * Retrieve a list of the current User's authentication tokens.
 */
export const listAuthTokens = (variables: ListAuthTokensVariables, signal?: AbortSignal) =>
  fetch<ListAuthTokensResponse, ListAuthTokensError, undefined, {}, {}, {}>({
    url: '/v5/user/tokens',
    method: 'get',
    ...variables,
    signal
  });

export type CreateAuthTokenQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateAuthTokenError = Fetcher.ErrorWrapper<undefined>;

export type CreateAuthTokenResponse = {
  token: Schemas.AuthToken;
  /**
   * The authentication token's actual value. This token is only provided in this response, and can never be retrieved again in the future. Be sure to save it somewhere safe!
   *
   * @example uRKJSTt0L4RaSkiMj41QTkxM
   */
  bearerToken: string;
};

export type CreateAuthTokenVariables = {
  body?:
    | {
        name: string;
        expiresAt?: number;
      }
    | {
        type: 'oauth2-token';
        name: string;
        clientId?: string;
        installationId?: string;
        expiresAt?: number;
      };
  queryParams?: CreateAuthTokenQueryParams;
} & FetcherExtraProps;

/**
 * Creates and returns a new authentication token for the currently authenticated User. The `bearerToken` property is only provided once, in the response body, so be sure to save it on the client for use with API requests.
 */
export const createAuthToken = (variables: CreateAuthTokenVariables, signal?: AbortSignal) =>
  fetch<
    CreateAuthTokenResponse,
    CreateAuthTokenError,
    | {
        name: string;
        expiresAt?: number;
      }
    | {
        type: 'oauth2-token';
        name: string;
        clientId?: string;
        installationId?: string;
        expiresAt?: number;
      },
    {},
    CreateAuthTokenQueryParams,
    {}
  >({ url: '/v3/user/tokens', method: 'post', ...variables, signal });

export type GetAuthTokenPathParams = {
  /**
   * The identifier of the token to retrieve. The special value \"current\" may be supplied, which returns the metadata for the token that the current HTTP request is authenticated with.
   *
   * @example 5d9f2ebd38ddca62e5d51e9c1704c72530bdc8bfdd41e782a6687c48399e8391
   */
  tokenId: string;
};

export type GetAuthTokenError = Fetcher.ErrorWrapper<undefined>;

export type GetAuthTokenResponse = {
  token: Schemas.AuthToken;
};

export type GetAuthTokenVariables = {
  pathParams: GetAuthTokenPathParams;
} & FetcherExtraProps;

/**
 * Retrieve metadata about an authentication token belonging to the currently authenticated User.
 */
export const getAuthToken = (variables: GetAuthTokenVariables, signal?: AbortSignal) =>
  fetch<GetAuthTokenResponse, GetAuthTokenError, undefined, {}, {}, GetAuthTokenPathParams>({
    url: '/v5/user/tokens/{tokenId}',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteAuthTokenPathParams = {
  /**
   * The identifier of the token to invalidate. The special value \"current\" may be supplied, which invalidates the token that the HTTP request was authenticated with.
   *
   * @example 5d9f2ebd38ddca62e5d51e9c1704c72530bdc8bfdd41e782a6687c48399e8391
   */
  tokenId: string;
};

export type DeleteAuthTokenError = Fetcher.ErrorWrapper<undefined>;

export type DeleteAuthTokenResponse = {
  /**
   * The unique identifier of the token that was deleted.
   *
   * @example 5d9f2ebd38ddca62e5d51e9c1704c72530bdc8bfdd41e782a6687c48399e8391
   */
  tokenId: string;
};

export type DeleteAuthTokenVariables = {
  pathParams: DeleteAuthTokenPathParams;
} & FetcherExtraProps;

/**
 * Invalidate an authentication token, such that it will no longer be valid for future HTTP requests.
 */
export const deleteAuthToken = (variables: DeleteAuthTokenVariables, signal?: AbortSignal) =>
  fetch<DeleteAuthTokenResponse, DeleteAuthTokenError, undefined, {}, {}, DeleteAuthTokenPathParams>({
    url: '/v3/user/tokens/{tokenId}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetRecordsPathParams = {
  /**
   * @example example.com
   */
  domain: string;
};

export type GetRecordsQueryParams = {
  /**
   * Maximum number of records to list from a request.
   *
   * @example 20
   */
  limit?: string;
  /**
   * Get records created after this JavaScript timestamp.
   *
   * @example 1609499532000
   */
  since?: string;
  /**
   * Get records created before this JavaScript timestamp.
   *
   * @example 1612264332000
   */
  until?: string;
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetRecordsError = Fetcher.ErrorWrapper<undefined>;

export type GetRecordsVariables = {
  pathParams: GetRecordsPathParams;
  queryParams?: GetRecordsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of DNS records created for a domain name. By default it returns 20 records if no limit is provided. The rest can be retrieved using the pagination options.
 */
export const getRecords = (variables: GetRecordsVariables, signal?: AbortSignal) =>
  fetch<
    | string
    | {
        records: {
          id: string;
          slug: string;
          name: string;
          type: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
          value: string;
          mxPriority?: number;
          priority?: number;
          creator: string;
          created: number | null;
          updated: number | null;
          createdAt: number | null;
          updatedAt: number | null;
        }[];
      }
    | {
        records: {
          id: string;
          slug: string;
          name: string;
          type: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
          value: string;
          mxPriority?: number;
          priority?: number;
          creator: string;
          created: number | null;
          updated: number | null;
          createdAt: number | null;
          updatedAt: number | null;
        }[];
        pagination: Schemas.Pagination;
      },
    GetRecordsError,
    undefined,
    {},
    GetRecordsQueryParams,
    GetRecordsPathParams
  >({ url: '/v4/domains/{domain}/records', method: 'get', ...variables, signal });

export type CreateRecordPathParams = {
  /**
   * The domain used to create the DNS record.
   *
   * @example example.com
   */
  domain: string;
};

export type CreateRecordQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateRecordError = Fetcher.ErrorWrapper<undefined>;

export type CreateRecordVariables = {
  body:
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `A`.
         */
        type: 'A';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * The record value must be a valid IPv4 address.
         *
         * @format ipv4
         * @example 192.0.2.42
         */
        value: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `AAAA`.
         */
        type: 'AAAA';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * An AAAA record pointing to an IPv6 address.
         *
         * @format ipv6
         * @example 2001:DB8::42
         */
        value: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `ALIAS`.
         */
        type: 'ALIAS';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * An ALIAS virtual record pointing to a hostname resolved to an A record on server side.
         *
         * @example cname.vercel-dns.com
         */
        value: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `CAA`.
         */
        type: 'CAA';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * A CAA record to specify which Certificate Authorities (CAs) are allowed to issue certificates for the domain.
         *
         * @example 0 issue \"letsencrypt.org\"
         */
        value: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `CNAME`.
         */
        type: 'CNAME';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * A CNAME record mapping to another domain name.
         *
         * @example cname.vercel-dns.com
         */
        value?: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `MX`.
         */
        type: 'MX';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * An MX record specifying the mail server responsible for accepting messages on behalf of the domain name.
         *
         * @example 10 mail.example.com.
         */
        value: string;
        /**
         * @minimum 0
         * @maximum 65535
         * @example 10
         */
        mxPriority: number;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         */
        name: string;
        /**
         * Must be of type `SRV`.
         */
        type: 'SRV';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        srv: {
          priority: number | null;
          weight: number | null;
          port: number | null;
          /**
           * @example host.example.com
           */
          target?: string;
        };
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         */
        name: string;
        /**
         * Must be of type `TXT`.
         */
        type: 'TXT';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * A TXT record containing arbitrary text.
         *
         * @example hello
         */
        value: string;
      }
    | {
        /**
         * A subdomain name.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `NS`.
         */
        type: 'NS';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * An NS domain value.
         *
         * @example ns1.example.com
         */
        value?: string;
      };
  pathParams: CreateRecordPathParams;
  queryParams?: CreateRecordQueryParams;
} & FetcherExtraProps;

/**
 * Creates a DNS record for a domain.
 */
export const createRecord = (variables: CreateRecordVariables, signal?: AbortSignal) =>
  fetch<
    | {
        uid: string;
        updated: number;
      }
    | {
        /**
         * The id of the newly created DNS record
         *
         * @example rec_V0fra8eEgQwEpFhYG2vTzC3K
         */
        uid: string;
      },
    CreateRecordError,
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `A`.
         */
        type: 'A';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * The record value must be a valid IPv4 address.
         *
         * @format ipv4
         * @example 192.0.2.42
         */
        value: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `AAAA`.
         */
        type: 'AAAA';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * An AAAA record pointing to an IPv6 address.
         *
         * @format ipv6
         * @example 2001:DB8::42
         */
        value: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `ALIAS`.
         */
        type: 'ALIAS';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * An ALIAS virtual record pointing to a hostname resolved to an A record on server side.
         *
         * @example cname.vercel-dns.com
         */
        value: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `CAA`.
         */
        type: 'CAA';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * A CAA record to specify which Certificate Authorities (CAs) are allowed to issue certificates for the domain.
         *
         * @example 0 issue \"letsencrypt.org\"
         */
        value: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `CNAME`.
         */
        type: 'CNAME';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * A CNAME record mapping to another domain name.
         *
         * @example cname.vercel-dns.com
         */
        value?: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `MX`.
         */
        type: 'MX';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * An MX record specifying the mail server responsible for accepting messages on behalf of the domain name.
         *
         * @example 10 mail.example.com.
         */
        value: string;
        /**
         * @minimum 0
         * @maximum 65535
         * @example 10
         */
        mxPriority: number;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         */
        name: string;
        /**
         * Must be of type `SRV`.
         */
        type: 'SRV';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        srv: {
          priority: number | null;
          weight: number | null;
          port: number | null;
          /**
           * @example host.example.com
           */
          target?: string;
        };
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         */
        name: string;
        /**
         * Must be of type `TXT`.
         */
        type: 'TXT';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * A TXT record containing arbitrary text.
         *
         * @example hello
         */
        value: string;
      }
    | {
        /**
         * A subdomain name.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `NS`.
         */
        type: 'NS';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * An NS domain value.
         *
         * @example ns1.example.com
         */
        value?: string;
      },
    {},
    CreateRecordQueryParams,
    CreateRecordPathParams
  >({ url: '/v2/domains/{domain}/records', method: 'post', ...variables, signal });

export type UpdateRecordPathParams = {
  /**
   * The id of the DNS record
   *
   * @example rec_2qn7pzrx89yxy34vezpd31y9
   */
  recordId: string;
};

export type UpdateRecordQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type UpdateRecordError = Fetcher.ErrorWrapper<undefined>;

export type UpdateRecordResponse = {
  createdAt?: number | null;
  creator: string;
  domain: string;
  id: string;
  name: string;
  recordType: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
  ttl?: number;
  type: 'record' | 'record-sys';
  value: string;
};

export type UpdateRecordRequestBody = {
  additionalProperties?: void;
  /**
   * The name of the DNS record
   *
   * @example example-1
   */
  name?: string | null;
  /**
   * The value of the DNS record
   *
   * @example google.com
   */
  value?: string | null;
  /**
   * The type of the DNS record
   *
   * @example A
   * @maxLength 255
   */
  type?: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS' | null;
  /**
   * The Time to live (TTL) value of the DNS record
   *
   * @example 60
   * @minimum 60
   * @maximum 2147483647
   */
  ttl?: number | null;
  /**
   * The MX priority value of the DNS record
   */
  mxPriority?: number | null;
  srv?: {
    /**
     * @example example2.com.
     * @maxLength 255
     */
    target: string | null;
    weight: number | null;
    port: number | null;
    priority: number | null;
  } | null;
};

export type UpdateRecordVariables = {
  body?: UpdateRecordRequestBody;
  pathParams: UpdateRecordPathParams;
  queryParams?: UpdateRecordQueryParams;
} & FetcherExtraProps;

/**
 * Updates an existing DNS record for a domain name.
 */
export const updateRecord = (variables: UpdateRecordVariables, signal?: AbortSignal) =>
  fetch<
    UpdateRecordResponse,
    UpdateRecordError,
    UpdateRecordRequestBody,
    {},
    UpdateRecordQueryParams,
    UpdateRecordPathParams
  >({ url: '/v1/domains/records/{recordId}', method: 'patch', ...variables, signal });

export type RemoveRecordPathParams = {
  /**
   * @example example.com
   */
  domain: string;
  /**
   * @example rec_V0fra8eEgQwEpFhYG2vTzC3K
   */
  recordId: string;
};

export type RemoveRecordQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type RemoveRecordError = Fetcher.ErrorWrapper<undefined>;

export type RemoveRecordVariables = {
  pathParams: RemoveRecordPathParams;
  queryParams?: RemoveRecordQueryParams;
} & FetcherExtraProps;

/**
 * Removes an existing DNS record from a domain name.
 */
export const removeRecord = (variables: RemoveRecordVariables, signal?: AbortSignal) =>
  fetch<Record<string, any>, RemoveRecordError, undefined, {}, RemoveRecordQueryParams, RemoveRecordPathParams>({
    url: '/v2/domains/{domain}/records/{recordId}',
    method: 'delete',
    ...variables,
    signal
  });

export type CheckDomainStatusQueryParams = {
  /**
   * The name of the domain for which we would like to check the status.
   *
   * @example example.com
   */
  name: string;
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CheckDomainStatusError = Fetcher.ErrorWrapper<undefined>;

export type CheckDomainStatusResponse = {
  available: boolean;
};

export type CheckDomainStatusVariables = {
  queryParams: CheckDomainStatusQueryParams;
} & FetcherExtraProps;

/**
 * Check if a domain name is available for purchase.
 */
export const checkDomainStatus = (variables: CheckDomainStatusVariables, signal?: AbortSignal) =>
  fetch<CheckDomainStatusResponse, CheckDomainStatusError, undefined, {}, CheckDomainStatusQueryParams, {}>({
    url: '/v4/domains/status',
    method: 'get',
    ...variables,
    signal
  });

export type CheckDomainPriceQueryParams = {
  /**
   * The name of the domain for which the price needs to be checked.
   *
   * @example example.com
   */
  name: string;
  /**
   * In which status of the domain the price needs to be checked.
   *
   * @example new
   */
  type?: 'new' | 'renewal';
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CheckDomainPriceError = Fetcher.ErrorWrapper<undefined>;

export type CheckDomainPriceResponse = {
  /**
   * The domain price in USD.
   *
   * @example 20
   */
  price: number;
  /**
   * The number of years the domain could be held before paying again.
   *
   * @example 1
   */
  period: number;
};

export type CheckDomainPriceVariables = {
  queryParams: CheckDomainPriceQueryParams;
} & FetcherExtraProps;

/**
 * Check the price to purchase a domain and how long a single purchase period is.
 */
export const checkDomainPrice = (variables: CheckDomainPriceVariables, signal?: AbortSignal) =>
  fetch<CheckDomainPriceResponse, CheckDomainPriceError, undefined, {}, CheckDomainPriceQueryParams, {}>({
    url: '/v4/domains/price',
    method: 'get',
    ...variables,
    signal
  });

export type BuyDomainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type BuyDomainError = Fetcher.ErrorWrapper<undefined>;

export type BuyDomainResponse = {
  domain: {
    uid: string;
    ns: string[];
    verified: boolean;
    created: number;
    pending: boolean;
  };
};

export type BuyDomainRequestBody = {
  /**
   * The domain name to purchase.
   *
   * @example example.com
   */
  name: string;
  /**
   * The price you expect to be charged for the purchase.
   *
   * @example 10
   */
  expectedPrice?: number;
  /**
   * Indicates whether the domain should be automatically renewed.
   *
   * @example true
   */
  renew?: boolean;
};

export type BuyDomainVariables = {
  body: BuyDomainRequestBody;
  queryParams?: BuyDomainQueryParams;
} & FetcherExtraProps;

/**
 * Allows to purchase the specified domain.
 */
export const buyDomain = (variables: BuyDomainVariables, signal?: AbortSignal) =>
  fetch<BuyDomainResponse, BuyDomainError, BuyDomainRequestBody, {}, BuyDomainQueryParams, {}>({
    url: '/v4/domains/buy',
    method: 'post',
    ...variables,
    signal
  });

export type GetDomainConfigPathParams = {
  /**
   * The name of the domain.
   *
   * @example example.com
   */
  domain: string;
};

export type GetDomainConfigQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetDomainConfigError = Fetcher.ErrorWrapper<undefined>;

export type GetDomainConfigResponse = {
  /**
   * How we see the domain's configuration. - `CNAME`: Domain has a CNAME pointing to Vercel. - `A`: Domain's A record is resolving to Vercel. - `http`: Domain is resolving to Vercel but may be behind a Proxy. - `null`: Domain is not resolving to Vercel.
   */
  configuredBy?: 'CNAME' | 'A' | 'http' | null;
  /**
   * Which challenge types the domain can use for issuing certs.
   */
  acceptedChallenges?: ('dns-01' | 'http-01')[];
  /**
   * Whether or not the domain is configured AND we can automatically generate a TLS certificate.
   */
  misconfigured: boolean;
};

export type GetDomainConfigVariables = {
  pathParams: GetDomainConfigPathParams;
  queryParams?: GetDomainConfigQueryParams;
} & FetcherExtraProps;

/**
 * Get a Domain's configuration.
 */
export const getDomainConfig = (variables: GetDomainConfigVariables, signal?: AbortSignal) =>
  fetch<
    GetDomainConfigResponse,
    GetDomainConfigError,
    undefined,
    {},
    GetDomainConfigQueryParams,
    GetDomainConfigPathParams
  >({ url: '/v6/domains/{domain}/config', method: 'get', ...variables, signal });

export type GetDomainPathParams = {
  /**
   * The name of the domain.
   *
   * @example example.com
   */
  domain: string;
};

export type GetDomainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetDomainError = Fetcher.ErrorWrapper<undefined>;

export type GetDomainResponse = {
  domain: {
    suffix: boolean;
    /**
     * If the domain has the ownership verified.
     *
     * @example true
     */
    verified: boolean;
    /**
     * A list of the current nameservers of the domain.
     *
     * @example ns1.nameserver.net
     * @example ns2.nameserver.net
     */
    nameservers: string[];
    /**
     * A list of the intended nameservers for the domain to point to Vercel DNS.
     *
     * @example ns1.vercel-dns.com
     * @example ns2.vercel-dns.com
     */
    intendedNameservers: string[];
    /**
     * A list of custom nameservers for the domain to point to. Only applies to domains purchased with Vercel.
     *
     * @example ns1.nameserver.net
     * @example ns2.nameserver.net
     */
    customNameservers?: string[];
    /**
     * An object containing information of the domain creator, including the user's id, username, and email.
     *
     * @example {"id":"ZspSRT4ljIEEmMHgoDwKWDei","username":"vercel_user","email":"demo@example.com"}
     */
    creator: {
      username: string;
      email: string;
      customerId?: string | null;
      isDomainReseller?: boolean;
      id: string;
    };
    /**
     * Timestamp in milliseconds when the domain was created in the registry.
     *
     * @example 1613602938882
     */
    createdAt: number;
    /**
     * The unique identifier of the domain.
     *
     * @example EmTbe5CEJyTk2yVAHBUWy4A3sRusca3GCwRjTC1bpeVnt1
     */
    id: string;
    /**
     * The domain name.
     *
     * @example example.com
     */
    name: string;
    /**
     * Timestamp in milliseconds at which the domain is set to expire. `null` if not bought with Vercel.
     *
     * @example 1613602938882
     */
    expiresAt: number | null;
    /**
     * If it was purchased through Vercel, the timestamp in milliseconds when it was purchased.
     *
     * @example 1613602938882
     */
    boughtAt: number | null;
    /**
     * Timestamp in milliseconds at which the domain was ordered.
     *
     * @example 1613602938882
     */
    orderedAt?: number;
    /**
     * Indicates whether the domain is set to automatically renew.
     *
     * @example true
     */
    renew?: boolean;
    /**
     * The type of service the domain is handled by. `external` if the DNS is externally handled, `zeit.world` if handled with Vercel, or `na` if the service is not available.
     *
     * @example zeit.world
     */
    serviceType: 'zeit.world' | 'external' | 'na';
    /**
     * Timestamp in milliseconds at which the domain was successfully transferred into Vercel. `null` if the transfer is still processing or was never transferred in.
     *
     * @example 1613602938882
     */
    transferredAt?: number | null;
    /**
     * If transferred into Vercel, timestamp in milliseconds when the domain transfer was initiated.
     *
     * @example 1613602938882
     */
    transferStartedAt?: number;
  };
};

export type GetDomainVariables = {
  pathParams: GetDomainPathParams;
  queryParams?: GetDomainQueryParams;
} & FetcherExtraProps;

/**
 * Get information for a single domain in an account or team.
 */
export const getDomain = (variables: GetDomainVariables, signal?: AbortSignal) =>
  fetch<GetDomainResponse, GetDomainError, undefined, {}, GetDomainQueryParams, GetDomainPathParams>({
    url: '/v5/domains/{domain}',
    method: 'get',
    ...variables,
    signal
  });

export type GetDomainsQueryParams = {
  /**
   * Maximum number of domains to list from a request.
   *
   * @example 20
   */
  limit?: number;
  /**
   * Get domains created after this JavaScript timestamp.
   *
   * @example 1609499532000
   */
  since?: number;
  /**
   * Get domains created before this JavaScript timestamp.
   *
   * @example 1612264332000
   */
  until?: number;
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetDomainsError = Fetcher.ErrorWrapper<undefined>;

export type GetDomainsResponse = {
  domains: {
    /**
     * If the domain has the ownership verified.
     *
     * @example true
     */
    verified: boolean;
    /**
     * A list of the current nameservers of the domain.
     *
     * @example ns1.nameserver.net
     * @example ns2.nameserver.net
     */
    nameservers: string[];
    /**
     * A list of the intended nameservers for the domain to point to Vercel DNS.
     *
     * @example ns1.vercel-dns.com
     * @example ns2.vercel-dns.com
     */
    intendedNameservers: string[];
    /**
     * A list of custom nameservers for the domain to point to. Only applies to domains purchased with Vercel.
     *
     * @example ns1.nameserver.net
     * @example ns2.nameserver.net
     */
    customNameservers?: string[];
    /**
     * An object containing information of the domain creator, including the user's id, username, and email.
     *
     * @example {"id":"ZspSRT4ljIEEmMHgoDwKWDei","username":"vercel_user","email":"demo@example.com"}
     */
    creator: {
      username: string;
      email: string;
      customerId?: string | null;
      isDomainReseller?: boolean;
      id: string;
    };
    /**
     * Timestamp in milliseconds when the domain was created in the registry.
     *
     * @example 1613602938882
     */
    createdAt: number;
    /**
     * The unique identifier of the domain.
     *
     * @example EmTbe5CEJyTk2yVAHBUWy4A3sRusca3GCwRjTC1bpeVnt1
     */
    id: string;
    /**
     * The domain name.
     *
     * @example example.com
     */
    name: string;
    /**
     * Timestamp in milliseconds at which the domain is set to expire. `null` if not bought with Vercel.
     *
     * @example 1613602938882
     */
    expiresAt: number | null;
    /**
     * Indicates whether the domain is set to automatically renew.
     *
     * @example true
     */
    renew?: boolean;
    /**
     * If it was purchased through Vercel, the timestamp in milliseconds when it was purchased.
     *
     * @example 1613602938882
     */
    boughtAt: number | null;
    /**
     * Timestamp in milliseconds at which the domain was ordered.
     *
     * @example 1613602938882
     */
    orderedAt?: number;
    /**
     * The type of service the domain is handled by. `external` if the DNS is externally handled, `zeit.world` if handled with Vercel, or `na` if the service is not available.
     *
     * @example zeit.world
     */
    serviceType: 'zeit.world' | 'external' | 'na';
    /**
     * Timestamp in milliseconds at which the domain was successfully transferred into Vercel. `null` if the transfer is still processing or was never transferred in.
     *
     * @example 1613602938882
     */
    transferredAt?: number | null;
    /**
     * If transferred into Vercel, timestamp in milliseconds when the domain transfer was initiated.
     *
     * @example 1613602938882
     */
    transferStartedAt?: number;
  }[];
  pagination: Schemas.Pagination;
};

export type GetDomainsVariables = {
  queryParams?: GetDomainsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of domains registered for the authenticating user. By default it returns the last 20 domains if no limit is provided.
 */
export const getDomains = (variables: GetDomainsVariables, signal?: AbortSignal) =>
  fetch<GetDomainsResponse, GetDomainsError, undefined, {}, GetDomainsQueryParams, {}>({
    url: '/v5/domains',
    method: 'get',
    ...variables,
    signal
  });

export type CreateOrTransferDomainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateOrTransferDomainError = Fetcher.ErrorWrapper<undefined>;

export type CreateOrTransferDomainResponse = {
  domain: {
    /**
     * If the domain has the ownership verified.
     *
     * @example true
     */
    verified: boolean;
    /**
     * A list of the current nameservers of the domain.
     *
     * @example ns1.nameserver.net
     * @example ns2.nameserver.net
     */
    nameservers: string[];
    /**
     * A list of the intended nameservers for the domain to point to Vercel DNS.
     *
     * @example ns1.vercel-dns.com
     * @example ns2.vercel-dns.com
     */
    intendedNameservers: string[];
    /**
     * A list of custom nameservers for the domain to point to. Only applies to domains purchased with Vercel.
     *
     * @example ns1.nameserver.net
     * @example ns2.nameserver.net
     */
    customNameservers?: string[];
    /**
     * An object containing information of the domain creator, including the user's id, username, and email.
     *
     * @example {"id":"ZspSRT4ljIEEmMHgoDwKWDei","username":"vercel_user","email":"demo@example.com"}
     */
    creator: {
      username: string;
      email: string;
      customerId?: string | null;
      isDomainReseller?: boolean;
      id: string;
    };
    /**
     * Timestamp in milliseconds when the domain was created in the registry.
     *
     * @example 1613602938882
     */
    createdAt: number;
    /**
     * The unique identifier of the domain.
     *
     * @example EmTbe5CEJyTk2yVAHBUWy4A3sRusca3GCwRjTC1bpeVnt1
     */
    id: string;
    /**
     * The domain name.
     *
     * @example example.com
     */
    name: string;
    /**
     * Timestamp in milliseconds at which the domain is set to expire. `null` if not bought with Vercel.
     *
     * @example 1613602938882
     */
    expiresAt: number | null;
    /**
     * If it was purchased through Vercel, the timestamp in milliseconds when it was purchased.
     *
     * @example 1613602938882
     */
    boughtAt: number | null;
    /**
     * Timestamp in milliseconds at which the domain was ordered.
     *
     * @example 1613602938882
     */
    orderedAt?: number;
    /**
     * Indicates whether the domain is set to automatically renew.
     *
     * @example true
     */
    renew?: boolean;
    /**
     * The type of service the domain is handled by. `external` if the DNS is externally handled, `zeit.world` if handled with Vercel, or `na` if the service is not available.
     *
     * @example zeit.world
     */
    serviceType: 'zeit.world' | 'external' | 'na';
    /**
     * Timestamp in milliseconds at which the domain was successfully transferred into Vercel. `null` if the transfer is still processing or was never transferred in.
     *
     * @example 1613602938882
     */
    transferredAt?: number | null;
    /**
     * If transferred into Vercel, timestamp in milliseconds when the domain transfer was initiated.
     *
     * @example 1613602938882
     */
    transferStartedAt?: number;
  };
};

export type CreateOrTransferDomainVariables = {
  body?:
    | {
        /**
         * The domain name you want to add.
         *
         * @example example.com
         */
        name: string;
        /**
         * The domain operation to perform.
         *
         * @example move-in
         */
        method: string;
        /**
         * The move-in token from Move Requested email.
         *
         * @example fdhfr820ad#@FAdlj$$
         */
        token?: string;
      }
    | {
        /**
         * The domain name you want to add.
         *
         * @example example.com
         */
        name: string;
        /**
         * The domain operation to perform.
         *
         * @example transfer-in
         */
        method: string;
        /**
         * The authorization code assigned to the domain.
         *
         * @example fdhfr820ad#@FAdlj$$
         */
        authCode?: string;
        /**
         * The price you expect to be charged for the required 1 year renewal.
         *
         * @example 8
         */
        expectedPrice?: number;
      }
    | {
        /**
         * The domain name you want to add.
         *
         * @example example.com
         */
        name: string;
        /**
         * Whether the domain has the Vercel Edge Network enabled or not.
         *
         * @example true
         */
        cdnEnabled?: boolean;
        zone?: boolean;
        /**
         * The domain operation to perform.
         *
         * @example add
         */
        method?: string;
      };
  queryParams?: CreateOrTransferDomainQueryParams;
} & FetcherExtraProps;

/**
 * This endpoint is used for registering a new domain name with Vercel for the authenticating user, and also for initiating a domain transfer request from an external Registrar to Vercel.
 */
export const createOrTransferDomain = (variables: CreateOrTransferDomainVariables, signal?: AbortSignal) =>
  fetch<
    CreateOrTransferDomainResponse,
    CreateOrTransferDomainError,
    | {
        /**
         * The domain name you want to add.
         *
         * @example example.com
         */
        name: string;
        /**
         * The domain operation to perform.
         *
         * @example move-in
         */
        method: string;
        /**
         * The move-in token from Move Requested email.
         *
         * @example fdhfr820ad#@FAdlj$$
         */
        token?: string;
      }
    | {
        /**
         * The domain name you want to add.
         *
         * @example example.com
         */
        name: string;
        /**
         * The domain operation to perform.
         *
         * @example transfer-in
         */
        method: string;
        /**
         * The authorization code assigned to the domain.
         *
         * @example fdhfr820ad#@FAdlj$$
         */
        authCode?: string;
        /**
         * The price you expect to be charged for the required 1 year renewal.
         *
         * @example 8
         */
        expectedPrice?: number;
      }
    | {
        /**
         * The domain name you want to add.
         *
         * @example example.com
         */
        name: string;
        /**
         * Whether the domain has the Vercel Edge Network enabled or not.
         *
         * @example true
         */
        cdnEnabled?: boolean;
        zone?: boolean;
        /**
         * The domain operation to perform.
         *
         * @example add
         */
        method?: string;
      },
    {},
    CreateOrTransferDomainQueryParams,
    {}
  >({ url: '/v5/domains', method: 'post', ...variables, signal });

export type DeleteDomainPathParams = {
  /**
   * The name of the domain.
   *
   * @example example.com
   */
  domain: string;
};

export type DeleteDomainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteDomainError = Fetcher.ErrorWrapper<undefined>;

export type DeleteDomainResponse = {
  uid: string;
};

export type DeleteDomainVariables = {
  pathParams: DeleteDomainPathParams;
  queryParams?: DeleteDomainQueryParams;
} & FetcherExtraProps;

/**
 * Delete a previously registered domain name from Vercel. Deleting a domain will automatically remove any associated aliases.
 */
export const deleteDomain = (variables: DeleteDomainVariables, signal?: AbortSignal) =>
  fetch<DeleteDomainResponse, DeleteDomainError, undefined, {}, DeleteDomainQueryParams, DeleteDomainPathParams>({
    url: '/v6/domains/{domain}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetSecretsQueryParams = {
  /**
   * Filter out secrets based on comma separated secret ids.
   *
   * @example sec_RKc5iV0rV3ZSrFrHiruRno7k,sec_fGc5iV0rV3ZSrFrHiruRnouQ
   * @deprecated true
   */
  id?: string;
  /**
   * Filter out secrets that belong to a project.
   *
   * @example prj_2WjyKQmM8ZnGcJsPWMrHRHrE
   * @deprecated true
   */
  projectId?: string;
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetSecretsError = Fetcher.ErrorWrapper<undefined>;

export type GetSecretsResponse = {
  secrets: {
    /**
     * The date when the secret was created.
     *
     * @format date-time
     * @example 2021-02-10T13:11:49.180Z
     */
    created: string;
    /**
     * The name of the secret.
     *
     * @example my-api-key
     */
    name: string;
    /**
     * The unique identifier of the team the secret was created for.
     *
     * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
     */
    teamId?: string | null;
    /**
     * The unique identifier of the secret.
     *
     * @example sec_XCG7t7AIHuO2SBA8667zNUiM
     */
    uid: string;
    /**
     * The unique identifier of the user who created the secret.
     *
     * @example 2qDDuGFTWXBLDNnqZfWPDp1A
     */
    userId?: string;
    /**
     * The value of the secret.
     */
    value?: string;
    /**
     * Timestamp for when the secret was created.
     *
     * @example 1609492210000
     */
    createdAt?: number;
    /**
     * The unique identifier of the project which the secret belongs to.
     *
     * @example prj_2WjyKQmM8ZnGcJsPWMrHRHrE
     */
    projectId?: string;
    /**
     * Indicates whether the secret value can be decrypted after it has been created.
     *
     * @example true
     */
    decryptable?: boolean;
  }[];
  pagination: Schemas.Pagination;
};

export type GetSecretsVariables = {
  queryParams?: GetSecretsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves the active Vercel secrets for the authenticated user. By default it returns 20 secrets. The rest can be retrieved using the pagination options. The body will contain an entry for each secret.
 */
export const getSecrets = (variables: GetSecretsVariables, signal?: AbortSignal) =>
  fetch<GetSecretsResponse, GetSecretsError, undefined, {}, GetSecretsQueryParams, {}>({
    url: '/v3/secrets',
    method: 'get',
    ...variables,
    signal
  });

export type CreateSecretQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateSecretError = Fetcher.ErrorWrapper<undefined>;

export type CreateSecretResponse = {
  value: {
    type?: 'Buffer';
    data?: number[];
  };
  /**
   * The date when the secret was created.
   *
   * @format date-time
   * @example 2021-02-10T13:11:49.180Z
   */
  created: string;
  /**
   * The name of the secret.
   *
   * @example my-api-key
   */
  name: string;
  /**
   * The unique identifier of the team the secret was created for.
   *
   * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
   */
  teamId?: string | null;
  /**
   * The unique identifier of the secret.
   *
   * @example sec_XCG7t7AIHuO2SBA8667zNUiM
   */
  uid: string;
  /**
   * The unique identifier of the user who created the secret.
   *
   * @example 2qDDuGFTWXBLDNnqZfWPDp1A
   */
  userId?: string;
  /**
   * Timestamp for when the secret was created.
   *
   * @example 1609492210000
   */
  createdAt?: number;
  /**
   * The unique identifier of the project which the secret belongs to.
   *
   * @example prj_2WjyKQmM8ZnGcJsPWMrHRHrE
   */
  projectId?: string;
  /**
   * Indicates whether the secret value can be decrypted after it has been created.
   *
   * @example true
   */
  decryptable?: boolean;
};

export type CreateSecretRequestBody = {
  /**
   * The name of the secret (max 100 characters).
   *
   * @example my-api-key
   * @maximum 100
   */
  name: string;
  /**
   * The value of the new secret.
   *
   * @example some secret value
   */
  value: string;
  /**
   * Whether the secret value can be decrypted after it has been created.
   *
   * @example true
   */
  decryptable?: boolean;
  /**
   * Associate a secret to a project.
   *
   * @example prj_2WjyKQmM8ZnGcJsPWMrHRHrE
   * @deprecated true
   */
  projectId?: string;
};

export type CreateSecretVariables = {
  body: CreateSecretRequestBody;
  queryParams?: CreateSecretQueryParams;
} & FetcherExtraProps;

/**
 * Allows to create a new secret.
 */
export const createSecret = (variables: CreateSecretVariables, signal?: AbortSignal) =>
  fetch<CreateSecretResponse, CreateSecretError, CreateSecretRequestBody, {}, CreateSecretQueryParams, {}>({
    url: '/v2/secrets/{name}',
    method: 'post',
    ...variables,
    signal
  });

export type RenameSecretPathParams = {
  /**
   * The name of the secret.
   *
   * @example my-api-key
   */
  name: string;
};

export type RenameSecretQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type RenameSecretError = Fetcher.ErrorWrapper<undefined>;

export type RenameSecretResponse = {
  uid: string;
  name: string;
  /**
   * Enables basic storage and retrieval of dates and times.
   *
   * @format date-time
   */
  created: string;
  oldName: string;
};

export type RenameSecretRequestBody = {
  /**
   * The name of the new secret.
   *
   * @example my-api-key
   * @maximum 100
   */
  name: string;
};

export type RenameSecretVariables = {
  body: RenameSecretRequestBody;
  pathParams: RenameSecretPathParams;
  queryParams?: RenameSecretQueryParams;
} & FetcherExtraProps;

/**
 * Enables to edit the name of a user's secret. The name has to be unique to that user's secrets.
 */
export const renameSecret = (variables: RenameSecretVariables, signal?: AbortSignal) =>
  fetch<
    RenameSecretResponse,
    RenameSecretError,
    RenameSecretRequestBody,
    {},
    RenameSecretQueryParams,
    RenameSecretPathParams
  >({ url: '/v2/secrets/{name}', method: 'patch', ...variables, signal });

export type GetSecretPathParams = {
  /**
   * The name or the unique identifier to which the secret belongs to.
   *
   * @example sec_RKc5iV0rV3ZSrFrHiruRno7k
   */
  idOrName: string;
};

export type GetSecretQueryParams = {
  /**
   * Whether to try to decrypt the value of the secret. Only works if `decryptable` has been set to `true` when the secret was created.
   *
   * @example true
   */
  decrypt?: 'true' | 'false';
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetSecretError = Fetcher.ErrorWrapper<undefined>;

export type GetSecretResponse = {
  /**
   * The date when the secret was created.
   *
   * @format date-time
   * @example 2021-02-10T13:11:49.180Z
   */
  created: string;
  /**
   * The name of the secret.
   *
   * @example my-api-key
   */
  name: string;
  /**
   * The unique identifier of the team the secret was created for.
   *
   * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
   */
  teamId?: string | null;
  /**
   * The unique identifier of the secret.
   *
   * @example sec_XCG7t7AIHuO2SBA8667zNUiM
   */
  uid: string;
  /**
   * The unique identifier of the user who created the secret.
   *
   * @example 2qDDuGFTWXBLDNnqZfWPDp1A
   */
  userId?: string;
  /**
   * The value of the secret.
   */
  value?: string;
  /**
   * Timestamp for when the secret was created.
   *
   * @example 1609492210000
   */
  createdAt?: number;
  /**
   * The unique identifier of the project which the secret belongs to.
   *
   * @example prj_2WjyKQmM8ZnGcJsPWMrHRHrE
   */
  projectId?: string;
  /**
   * Indicates whether the secret value can be decrypted after it has been created.
   *
   * @example true
   */
  decryptable?: boolean;
};

export type GetSecretVariables = {
  pathParams: GetSecretPathParams;
  queryParams?: GetSecretQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves the information for a specific secret by passing either the secret id or name in the URL.
 */
export const getSecret = (variables: GetSecretVariables, signal?: AbortSignal) =>
  fetch<GetSecretResponse, GetSecretError, undefined, {}, GetSecretQueryParams, GetSecretPathParams>({
    url: '/v3/secrets/{idOrName}',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteSecretPathParams = {
  /**
   * The name or the unique identifier to which the secret belongs to.
   *
   * @example sec_RKc5iV0rV3ZSrFrHiruRno7k
   */
  idOrName: string;
};

export type DeleteSecretQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteSecretError = Fetcher.ErrorWrapper<undefined>;

export type DeleteSecretResponse = {
  /**
   * The unique identifier of the deleted secret.
   *
   * @example sec_XCG7t7AIHuO2SBA8667zNUiM
   */
  uid: string;
  /**
   * The name of the deleted secret.
   *
   * @example my-api-key
   */
  name: string;
  /**
   * The date when the secret was created.
   *
   * @example 2021-02-10T13:11:49.180Z
   */
  created: number;
};

export type DeleteSecretVariables = {
  pathParams: DeleteSecretPathParams;
  queryParams?: DeleteSecretQueryParams;
} & FetcherExtraProps;

/**
 * This deletes the user's secret defined in the URL.
 */
export const deleteSecret = (variables: DeleteSecretVariables, signal?: AbortSignal) =>
  fetch<DeleteSecretResponse, DeleteSecretError, undefined, {}, DeleteSecretQueryParams, DeleteSecretPathParams>({
    url: '/v2/secrets/{idOrName}',
    method: 'delete',
    ...variables,
    signal
  });

export type DeleteDeploymentPathParams = {
  /**
   * The ID of the deployment to be deleted
   *
   * @example dpl_5WJWYSyB7BpgTj3EuwF37WMRBXBtPQ2iTMJHJBJyRfd
   */
  id: string;
};

export type DeleteDeploymentQueryParams = {
  /**
   * A Deployment or Alias URL. In case it is passed, the ID will be ignored
   *
   * @example https://files-orcin-xi.vercel.app/
   */
  url?: string;
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteDeploymentError = Fetcher.ErrorWrapper<undefined>;

export type DeleteDeploymentResponse = {
  /**
   * The removed deployment ID.
   *
   * @example dpl_5WJWYSyB7BpgTj3EuwF37WMRBXBtPQ2iTMJHJBJyRfd
   */
  uid: string;
  /**
   * A constant with the final state of the deployment.
   */
  state: 'DELETED';
};

export type DeleteDeploymentVariables = {
  pathParams: DeleteDeploymentPathParams;
  queryParams?: DeleteDeploymentQueryParams;
} & FetcherExtraProps;

/**
 * This API allows you to delete a deployment, either by supplying its `id` in the URL or the `url` of the deployment as a query parameter. You can obtain the ID, for example, by listing all deployments.
 */
export const deleteDeployment = (variables: DeleteDeploymentVariables, signal?: AbortSignal) =>
  fetch<
    DeleteDeploymentResponse,
    DeleteDeploymentError,
    undefined,
    {},
    DeleteDeploymentQueryParams,
    DeleteDeploymentPathParams
  >({ url: '/v13/deployments/{id}', method: 'delete', ...variables, signal });

export type GetDeploymentsQueryParams = {
  /**
   * Name of the deployment.
   *
   * @example docs
   */
  app?: string;
  /**
   * Gets the deployment created after this Date timestamp. (default: current time)
   *
   * @example 1612948664566
   * @deprecated true
   */
  from?: number;
  /**
   * Maximum number of deployments to list from a request.
   *
   * @example 10
   */
  limit?: number;
  /**
   * Filter deployments from the given `projectId`.
   *
   * @example QmXGTs7mvAMMC7WW5ebrM33qKG32QK3h4vmQMjmY
   */
  projectId?: string;
  /**
   * Filter deployments based on the environment.
   *
   * @example production
   */
  target?: 'production' | 'preview';
  /**
   * Gets the deployment created before this Date timestamp. (default: current time)
   *
   * @example 1612948664566
   * @deprecated true
   */
  to?: number;
  /**
   * Filter out deployments based on users who have created the deployment.
   *
   * @example kr1PsOIzqEL5Xg6M4VZcZosf,K4amb7K9dAt5R2vBJWF32bmY
   */
  users?: string;
  /**
   * Get Deployments created after this JavaScript timestamp.
   *
   * @example 1540095775941
   */
  since?: number;
  /**
   * Get Deployments created before this JavaScript timestamp.
   *
   * @example 1540095775951
   */
  until?: number;
  /**
   * Filter deployments based on their state (`BUILDING`, `ERROR`, `INITIALIZING`, `QUEUED`, `READY`, `CANCELED`)
   *
   * @example BUILDING,READY
   */
  state?: string;
  /**
   * Filter deployments based on their rollback candidacy
   */
  rollbackCandidate?: boolean;
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetDeploymentsError = Fetcher.ErrorWrapper<undefined>;

export type GetDeploymentsResponse = {
  pagination: Schemas.Pagination;
  deployments: {
    /**
     * The unique identifier of the deployment.
     *
     * @example dpl_2euZBFqxYdDMDG1jTrHFnNZ2eUVa
     */
    uid: string;
    /**
     * The name of the deployment.
     *
     * @example docs
     */
    name: string;
    /**
     * The URL of the deployment.
     *
     * @example docs-9jaeg38me.vercel.app
     */
    url: string;
    /**
     * Timestamp of when the deployment got created.
     *
     * @example 1609492210000
     */
    created: number;
    /**
     * The source of the deployment.
     *
     * @example cli
     */
    source?: 'cli' | 'git' | 'import' | 'import/repo' | 'clone/repo';
    /**
     * In which state is the deployment.
     *
     * @example READY
     */
    state?: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED';
    /**
     * The type of the deployment.
     *
     * @example LAMBDAS
     */
    type: 'LAMBDAS';
    /**
     * Metadata information of the user who created the deployment.
     */
    creator: {
      /**
       * The unique identifier of the user.
       *
       * @example eLrCnEgbKhsHyfbiNR7E8496
       */
      uid: string;
      /**
       * The email address of the user.
       *
       * @example example@example.com
       */
      email?: string;
      /**
       * The username of the user.
       *
       * @example johndoe
       */
      username?: string;
      /**
       * The GitHub login of the user.
       *
       * @example johndoe
       */
      githubLogin?: string;
      /**
       * The GitLab login of the user.
       *
       * @example johndoe
       */
      gitlabLogin?: string;
    };
    /**
     * An object containing the deployment's metadata
     *
     * @example {"foo":"bar"}
     */
    meta?: {
      [key: string]: string;
    };
    /**
     * On which environment has the deployment been deployed to.
     *
     * @example production
     */
    target?: 'production' | 'staging' | null;
    /**
     * An error object in case aliasing of the deployment failed.
     */
    aliasError?: {
      code: string;
      message: string;
    } | null;
    aliasAssigned?: number | boolean | null;
    /**
     * Timestamp of when the deployment got created.
     *
     * @example 1609492210000
     */
    createdAt?: number;
    /**
     * Timestamp of when the deployment started building at.
     *
     * @example 1609492210000
     */
    buildingAt?: number;
    /**
     * Timestamp of when the deployment got ready.
     *
     * @example 1609492210000
     */
    ready?: number;
    /**
     * State of all registered checks
     */
    checksState?: 'registered' | 'running' | 'completed';
    /**
     * Conclusion for checks
     */
    checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
    /**
     * Vercel URL to inspect the deployment.
     *
     * @example https://vercel.com/acme/nextjs/J1hXN00qjUeoYfpEEf7dnDtpSiVq
     */
    inspectorUrl: string | null;
    /**
     * Deployment can be used for instant rollback
     */
    isRollbackCandidate?: boolean | null;
    /**
     * The project settings which was used for this deployment
     */
    projectSettings?: {
      framework?:
        | 'blitzjs'
        | 'nextjs'
        | 'gatsby'
        | 'remix'
        | 'astro'
        | 'hexo'
        | 'eleventy'
        | 'docusaurus-2'
        | 'docusaurus'
        | 'preact'
        | 'solidstart'
        | 'dojo'
        | 'ember'
        | 'vue'
        | 'scully'
        | 'ionic-angular'
        | 'angular'
        | 'polymer'
        | 'svelte'
        | 'sveltekit'
        | 'sveltekit-1'
        | 'ionic-react'
        | 'create-react-app'
        | 'gridsome'
        | 'umijs'
        | 'sapper'
        | 'saber'
        | 'stencil'
        | 'nuxtjs'
        | 'redwoodjs'
        | 'hugo'
        | 'jekyll'
        | 'brunch'
        | 'middleman'
        | 'zola'
        | 'hydrogen'
        | 'vite'
        | 'vitepress'
        | 'vuepress'
        | 'parcel'
        | 'sanity'
        | null;
      gitForkProtection?: boolean;
      gitLFS?: boolean;
      devCommand?: string | null;
      installCommand?: string | null;
      buildCommand?: string | null;
      nodeVersion?: '18.x' | '16.x' | '14.x' | '12.x' | '10.x';
      outputDirectory?: string | null;
      publicSource?: boolean | null;
      rootDirectory?: string | null;
      serverlessFunctionRegion?: string | null;
      sourceFilesOutsideRootDirectory?: boolean;
      commandForIgnoringBuildStep?: string | null;
      createdAt?: number;
      skipGitConnectDuringLink?: boolean;
    };
  }[];
};

export type GetDeploymentsVariables = {
  queryParams?: GetDeploymentsQueryParams;
} & FetcherExtraProps;

/**
 * List deployments under the account corresponding to the API token. If a deployment hasn't finished uploading (is incomplete), the `url` property will have a value of `null`.
 */
export const getDeployments = (variables: GetDeploymentsVariables, signal?: AbortSignal) =>
  fetch<GetDeploymentsResponse, GetDeploymentsError, undefined, {}, GetDeploymentsQueryParams, {}>({
    url: '/v6/deployments',
    method: 'get',
    ...variables,
    signal
  });

export type GetProjectsQueryParams = {
  /**
   * Query only projects updated after the given timestamp
   */
  from?: string;
  /**
   * Specifies whether PRs from Git forks should require a team member's authorization before it can be deployed
   *
   * @example 1
   */
  gitForkProtection?: '1' | '0';
  /**
   * Limit the number of projects returned
   */
  limit?: string;
  /**
   * Search projects by the name field
   */
  search?: string;
  /**
   * Filter results by repo. Also used for project count
   */
  repo?: string;
  /**
   * Filter results by Repository ID.
   */
  repoId?: string;
  /**
   * Filter results by Repository URL.
   *
   * @example https://github.com/vercel/next.js
   */
  repoUrl?: string;
  /**
   * Filter results by excluding those projects that belong to a repo
   */
  excludeRepos?: string;
  /**
   * Filter results by connected Edge Config ID
   */
  edgeConfigId?: string;
  /**
   * Filter results by connected Edge Config Token ID
   */
  edgeConfigTokenId?: string;
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetProjectsError = Fetcher.ErrorWrapper<undefined>;

export type GetProjectsResponse = {
  projects: {
    accountId: string;
    analytics?: {
      id: string;
      canceledAt: number | null;
      disabledAt: number;
      enabledAt: number;
      paidAt?: number;
      sampleRatePercent?: number | null;
      spendLimitInDollars?: number | null;
    };
    autoExposeSystemEnvs?: boolean;
    buildCommand?: string | null;
    commandForIgnoringBuildStep?: string | null;
    connectConfigurationId?: string | null;
    connectBuildsEnabled?: boolean;
    createdAt?: number;
    devCommand?: string | null;
    directoryListing: boolean;
    installCommand?: string | null;
    env?: {
      target?:
        | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
        | ('production' | 'preview' | 'development' | 'preview' | 'development');
      type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
      id?: string;
      key: string;
      value: string;
      configurationId?: string | null;
      createdAt?: number;
      updatedAt?: number;
      createdBy?: string | null;
      updatedBy?: string | null;
      gitBranch?: string;
      edgeConfigId?: string | null;
      edgeConfigTokenId?: string | null;
      /**
       * Whether `value` is decrypted.
       */
      decrypted?: boolean;
    }[];
    framework?:
      | 'blitzjs'
      | 'nextjs'
      | 'gatsby'
      | 'remix'
      | 'astro'
      | 'hexo'
      | 'eleventy'
      | 'docusaurus-2'
      | 'docusaurus'
      | 'preact'
      | 'solidstart'
      | 'dojo'
      | 'ember'
      | 'vue'
      | 'scully'
      | 'ionic-angular'
      | 'angular'
      | 'polymer'
      | 'svelte'
      | 'sveltekit'
      | 'sveltekit-1'
      | 'ionic-react'
      | 'create-react-app'
      | 'gridsome'
      | 'umijs'
      | 'sapper'
      | 'saber'
      | 'stencil'
      | 'nuxtjs'
      | 'redwoodjs'
      | 'hugo'
      | 'jekyll'
      | 'brunch'
      | 'middleman'
      | 'zola'
      | 'hydrogen'
      | 'vite'
      | 'vitepress'
      | 'vuepress'
      | 'parcel'
      | 'sanity'
      | null;
    gitForkProtection?: boolean;
    gitLFS?: boolean;
    id: string;
    latestDeployments?: {
      alias?: string[];
      aliasAssigned?: number | boolean | null;
      aliasError?: {
        code: string;
        message: string;
      } | null;
      aliasFinal?: string | null;
      automaticAliases?: string[];
      builds?: {
        use: string;
        src?: string;
        dest?: string;
      }[];
      createdAt: number;
      createdIn: string;
      creator: {
        email: string;
        githubLogin?: string;
        gitlabLogin?: string;
        uid: string;
        username: string;
      } | null;
      deploymentHostname: string;
      name: string;
      forced?: boolean;
      id: string;
      /**
       * Construct a type with a set of properties K of type T
       */
      meta?: {
        [key: string]: string;
      };
      monorepoManager?: string | null;
      plan: 'hobby' | 'enterprise' | 'pro' | 'oss';
      private: boolean;
      readyState: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED';
      requestedAt?: number;
      target?: string | null;
      teamId?: string | null;
      type: 'LAMBDAS';
      url: string;
      userId: string;
      withCache?: boolean;
      checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
      checksState?: 'registered' | 'running' | 'completed';
      readyAt?: number;
      buildingAt?: number;
      /**
       * Whether or not preview comments are enabled for the deployment
       *
       * @example false
       */
      previewCommentsEnabled?: boolean;
    }[];
    link?:
      | {
          org?: string;
          repo?: string;
          repoId?: number;
          type?: 'github';
          createdAt?: number;
          deployHooks: {
            createdAt?: number;
            id: string;
            name: string;
            ref: string;
            url: string;
          }[];
          gitCredentialId?: string;
          updatedAt?: number;
          sourceless?: boolean;
          productionBranch?: string;
        }
      | {
          projectId?: string;
          projectName?: string;
          projectNameWithNamespace?: string;
          projectNamespace?: string;
          projectUrl?: string;
          type?: 'gitlab';
          createdAt?: number;
          deployHooks: {
            createdAt?: number;
            id: string;
            name: string;
            ref: string;
            url: string;
          }[];
          gitCredentialId?: string;
          updatedAt?: number;
          sourceless?: boolean;
          productionBranch?: string;
        }
      | {
          name?: string;
          slug?: string;
          owner?: string;
          type?: 'bitbucket';
          uuid?: string;
          workspaceUuid?: string;
          createdAt?: number;
          deployHooks: {
            createdAt?: number;
            id: string;
            name: string;
            ref: string;
            url: string;
          }[];
          gitCredentialId?: string;
          updatedAt?: number;
          sourceless?: boolean;
          productionBranch?: string;
        };
    name: string;
    nodeVersion: '18.x' | '16.x' | '14.x' | '12.x' | '10.x';
    outputDirectory?: string | null;
    passwordProtection?: {
      deploymentType: 'preview' | 'all';
    } | null;
    publicSource?: boolean | null;
    rootDirectory?: string | null;
    serverlessFunctionRegion?: string | null;
    skipGitConnectDuringLink?: boolean;
    sourceFilesOutsideRootDirectory?: boolean;
    ssoProtection?: {
      deploymentType: 'preview' | 'all';
    } | null;
    /**
     * An object containing the deployment's metadata
     *
     * @example {"foo":"bar"}
     */
    targets?: {
      [key: string]: string;
    };
    transferCompletedAt?: number;
    transferStartedAt?: number;
    transferToAccountId?: string;
    transferredFromAccountId?: string;
    updatedAt?: number;
    live?: boolean;
    enablePreviewFeedback?: boolean | null;
    permissions?: {
      aliasGlobal?: Schemas.ACLAction[];
      aliasProject?: Schemas.ACLAction[];
      analytics?: Schemas.ACLAction[];
      analyticsSampling?: Schemas.ACLAction[];
      analyticsUsage?: Schemas.ACLAction[];
      auditLog?: Schemas.ACLAction[];
      billingAddress?: Schemas.ACLAction[];
      billingInformation?: Schemas.ACLAction[];
      billingInvoice?: Schemas.ACLAction[];
      billingInvoiceEmailRecipient?: Schemas.ACLAction[];
      billingInvoiceLanguage?: Schemas.ACLAction[];
      billingPlan?: Schemas.ACLAction[];
      billingPurchaseOrder?: Schemas.ACLAction[];
      billingTaxId?: Schemas.ACLAction[];
      cacheArtifact?: Schemas.ACLAction[];
      cacheArtifactUsageEvent?: Schemas.ACLAction[];
      concurrentBuilds?: Schemas.ACLAction[];
      connect?: Schemas.ACLAction[];
      connectConfiguration?: Schemas.ACLAction[];
      connectConfigurationLink?: Schemas.ACLAction[];
      deployment?: Schemas.ACLAction[];
      deploymentProductionGit?: Schemas.ACLAction[];
      deploymentCheck?: Schemas.ACLAction[];
      deploymentCheckPreview?: Schemas.ACLAction[];
      deploymentPreview?: Schemas.ACLAction[];
      deploymentPrivate?: Schemas.ACLAction[];
      deploymentCheckReRunFromProductionBranch?: Schemas.ACLAction[];
      deploymentRollback?: Schemas.ACLAction[];
      domain?: Schemas.ACLAction[];
      domainAcceptDelegation?: Schemas.ACLAction[];
      domainAuthCodes?: Schemas.ACLAction[];
      domainCertificate?: Schemas.ACLAction[];
      domainCheckConfig?: Schemas.ACLAction[];
      domainMove?: Schemas.ACLAction[];
      domainPurchase?: Schemas.ACLAction[];
      domainRecord?: Schemas.ACLAction[];
      domainTransferIn?: Schemas.ACLAction[];
      event?: Schemas.ACLAction[];
      sensitiveEnvironmentVariablePolicy?: Schemas.ACLAction[];
      fileUpload?: Schemas.ACLAction[];
      gitRepository?: Schemas.ACLAction[];
      ipBlocking?: Schemas.ACLAction[];
      integration?: Schemas.ACLAction[];
      integrationConfiguration?: Schemas.ACLAction[];
      integrationConfigurationTransfer?: Schemas.ACLAction[];
      integrationConfigurationProjects?: Schemas.ACLAction[];
      integrationVercelConfigurationOverride?: Schemas.ACLAction[];
      job?: Schemas.ACLAction[];
      logDrain?: Schemas.ACLAction[];
      Monitoring?: Schemas.ACLAction[];
      monitoringQuery?: Schemas.ACLAction[];
      monitoringChart?: Schemas.ACLAction[];
      notificationDomainConfiguration?: Schemas.ACLAction[];
      notificationDomainExpire?: Schemas.ACLAction[];
      notificationDomainMoved?: Schemas.ACLAction[];
      notificationDomainPurchase?: Schemas.ACLAction[];
      notificationDomainRenewal?: Schemas.ACLAction[];
      notificationDomainTransfer?: Schemas.ACLAction[];
      notificationDomainUnverified?: Schemas.ACLAction[];
      notificationPaymentFailed?: Schemas.ACLAction[];
      notificationUsageAlert?: Schemas.ACLAction[];
      notificationSpendCap?: Schemas.ACLAction[];
      openTelemetryEndpoint?: Schemas.ACLAction[];
      passwordProtection?: Schemas.ACLAction[];
      paymentMethod?: Schemas.ACLAction[];
      permissions?: Schemas.ACLAction[];
      postgres?: Schemas.ACLAction[];
      previewDeploymentSuffix?: Schemas.ACLAction[];
      proTrialOnboarding?: Schemas.ACLAction[];
      project?: Schemas.ACLAction[];
      projectDeploymentHook?: Schemas.ACLAction[];
      projectDomain?: Schemas.ACLAction[];
      projectDomainMove?: Schemas.ACLAction[];
      projectEnvVars?: Schemas.ACLAction[];
      projectEnvVarsUnownedByIntegration?: Schemas.ACLAction[];
      sharedEnvVars?: Schemas.ACLAction[];
      projectEnvVarsProduction?: Schemas.ACLAction[];
      sharedEnvVarsProduction?: Schemas.ACLAction[];
      projectIntegrationConfiguration?: Schemas.ACLAction[];
      projectLink?: Schemas.ACLAction[];
      projectMember?: Schemas.ACLAction[];
      projectProductionBranch?: Schemas.ACLAction[];
      projectTransfer?: Schemas.ACLAction[];
      projectProtectionBypass?: Schemas.ACLAction[];
      rateLimit?: Schemas.ACLAction[];
      redis?: Schemas.ACLAction[];
      remoteCaching?: Schemas.ACLAction[];
      samlConfig?: Schemas.ACLAction[];
      secret?: Schemas.ACLAction[];
      spendCapConfiguration?: Schemas.ACLAction[];
      spendCapState?: Schemas.ACLAction[];
      supportCase?: Schemas.ACLAction[];
      supportCaseComment?: Schemas.ACLAction[];
      team?: Schemas.ACLAction[];
      teamAccessRequest?: Schemas.ACLAction[];
      teamFellowMembership?: Schemas.ACLAction[];
      teamInvite?: Schemas.ACLAction[];
      teamInviteCode?: Schemas.ACLAction[];
      teamJoin?: Schemas.ACLAction[];
      teamOwnMembership?: Schemas.ACLAction[];
      teamOwnMembershipDisconnectSAML?: Schemas.ACLAction[];
      token?: Schemas.ACLAction[];
      usage?: Schemas.ACLAction[];
      user?: Schemas.ACLAction[];
      userConnection?: Schemas.ACLAction[];
      webAnalytics?: Schemas.ACLAction[];
      webAnalyticsPlan?: Schemas.ACLAction[];
      edgeConfig?: Schemas.ACLAction[];
      edgeConfigItem?: Schemas.ACLAction[];
      edgeConfigToken?: Schemas.ACLAction[];
      webhook?: Schemas.ACLAction[];
      ['webhook-event']?: Schemas.ACLAction[];
      endpointVerification?: Schemas.ACLAction[];
      aliasProtectionBypass?: Schemas.ACLAction[];
    };
    lastRollbackTarget?: {
      fromDeploymentId: string;
      toDeploymentId: string;
      jobStatus: 'succeeded' | 'failed' | 'skipped' | 'pending' | 'in-progress';
      requestedAt: number;
    } | null;
    hasFloatingAliases?: boolean;
    /**
     * Construct a type with a set of properties K of type T
     */
    protectionBypass?: {
      [key: string]: string;
    };
    hasActiveBranches?: boolean;
  }[];
  pagination: Schemas.Pagination;
};

export type GetProjectsVariables = {
  queryParams?: GetProjectsQueryParams;
} & FetcherExtraProps;

/**
 * Allows to retrieve the list of projects of the authenticated user. The list will be paginated and the provided query parameters allow filtering the returned projects.
 */
export const getProjects = (variables: GetProjectsVariables, signal?: AbortSignal) =>
  fetch<GetProjectsResponse, GetProjectsError, undefined, {}, GetProjectsQueryParams, {}>({
    url: '/v9/projects',
    method: 'get',
    ...variables,
    signal
  });

export type CreateProjectQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateProjectError = Fetcher.ErrorWrapper<undefined>;

export type CreateProjectResponse = {
  accountId: string;
  analytics?: {
    id: string;
    canceledAt: number | null;
    disabledAt: number;
    enabledAt: number;
    paidAt?: number;
    sampleRatePercent?: number | null;
    spendLimitInDollars?: number | null;
  };
  autoExposeSystemEnvs?: boolean;
  buildCommand?: string | null;
  commandForIgnoringBuildStep?: string | null;
  connectConfigurationId?: string | null;
  connectBuildsEnabled?: boolean;
  createdAt?: number;
  devCommand?: string | null;
  directoryListing: boolean;
  installCommand?: string | null;
  env?: {
    target?:
      | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
      | ('production' | 'preview' | 'development' | 'preview' | 'development');
    type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
    id?: string;
    key: string;
    value: string;
    configurationId?: string | null;
    createdAt?: number;
    updatedAt?: number;
    createdBy?: string | null;
    updatedBy?: string | null;
    gitBranch?: string;
    edgeConfigId?: string | null;
    edgeConfigTokenId?: string | null;
    /**
     * Whether `value` is decrypted.
     */
    decrypted?: boolean;
  }[];
  framework?:
    | 'blitzjs'
    | 'nextjs'
    | 'gatsby'
    | 'remix'
    | 'astro'
    | 'hexo'
    | 'eleventy'
    | 'docusaurus-2'
    | 'docusaurus'
    | 'preact'
    | 'solidstart'
    | 'dojo'
    | 'ember'
    | 'vue'
    | 'scully'
    | 'ionic-angular'
    | 'angular'
    | 'polymer'
    | 'svelte'
    | 'sveltekit'
    | 'sveltekit-1'
    | 'ionic-react'
    | 'create-react-app'
    | 'gridsome'
    | 'umijs'
    | 'sapper'
    | 'saber'
    | 'stencil'
    | 'nuxtjs'
    | 'redwoodjs'
    | 'hugo'
    | 'jekyll'
    | 'brunch'
    | 'middleman'
    | 'zola'
    | 'hydrogen'
    | 'vite'
    | 'vitepress'
    | 'vuepress'
    | 'parcel'
    | 'sanity'
    | null;
  gitForkProtection?: boolean;
  gitLFS?: boolean;
  id: string;
  latestDeployments?: {
    alias?: string[];
    aliasAssigned?: number | boolean | null;
    aliasError?: {
      code: string;
      message: string;
    } | null;
    aliasFinal?: string | null;
    automaticAliases?: string[];
    builds?: {
      use: string;
      src?: string;
      dest?: string;
    }[];
    createdAt: number;
    createdIn: string;
    creator: {
      email: string;
      githubLogin?: string;
      gitlabLogin?: string;
      uid: string;
      username: string;
    } | null;
    deploymentHostname: string;
    name: string;
    forced?: boolean;
    id: string;
    /**
     * Construct a type with a set of properties K of type T
     */
    meta?: {
      [key: string]: string;
    };
    monorepoManager?: string | null;
    plan: 'hobby' | 'enterprise' | 'pro' | 'oss';
    private: boolean;
    readyState: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED';
    requestedAt?: number;
    target?: string | null;
    teamId?: string | null;
    type: 'LAMBDAS';
    url: string;
    userId: string;
    withCache?: boolean;
    checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
    checksState?: 'registered' | 'running' | 'completed';
    readyAt?: number;
    buildingAt?: number;
    /**
     * Whether or not preview comments are enabled for the deployment
     *
     * @example false
     */
    previewCommentsEnabled?: boolean;
  }[];
  link?:
    | {
        org?: string;
        repo?: string;
        repoId?: number;
        type?: 'github';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        projectId?: string;
        projectName?: string;
        projectNameWithNamespace?: string;
        projectNamespace?: string;
        projectUrl?: string;
        type?: 'gitlab';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        name?: string;
        slug?: string;
        owner?: string;
        type?: 'bitbucket';
        uuid?: string;
        workspaceUuid?: string;
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      };
  name: string;
  nodeVersion: '18.x' | '16.x' | '14.x' | '12.x' | '10.x';
  outputDirectory?: string | null;
  passwordProtection?: {
    deploymentType: 'preview' | 'all';
  } | null;
  publicSource?: boolean | null;
  rootDirectory?: string | null;
  serverlessFunctionRegion?: string | null;
  skipGitConnectDuringLink?: boolean;
  sourceFilesOutsideRootDirectory?: boolean;
  ssoProtection?: {
    deploymentType: 'preview' | 'all';
  } | null;
  /**
   * An object containing the deployment's metadata
   *
   * @example {"foo":"bar"}
   */
  targets?: {
    [key: string]: string;
  };
  transferCompletedAt?: number;
  transferStartedAt?: number;
  transferToAccountId?: string;
  transferredFromAccountId?: string;
  updatedAt?: number;
  live?: boolean;
  enablePreviewFeedback?: boolean | null;
  permissions?: {
    aliasGlobal?: Schemas.ACLAction[];
    aliasProject?: Schemas.ACLAction[];
    analytics?: Schemas.ACLAction[];
    analyticsSampling?: Schemas.ACLAction[];
    analyticsUsage?: Schemas.ACLAction[];
    auditLog?: Schemas.ACLAction[];
    billingAddress?: Schemas.ACLAction[];
    billingInformation?: Schemas.ACLAction[];
    billingInvoice?: Schemas.ACLAction[];
    billingInvoiceEmailRecipient?: Schemas.ACLAction[];
    billingInvoiceLanguage?: Schemas.ACLAction[];
    billingPlan?: Schemas.ACLAction[];
    billingPurchaseOrder?: Schemas.ACLAction[];
    billingTaxId?: Schemas.ACLAction[];
    cacheArtifact?: Schemas.ACLAction[];
    cacheArtifactUsageEvent?: Schemas.ACLAction[];
    concurrentBuilds?: Schemas.ACLAction[];
    connect?: Schemas.ACLAction[];
    connectConfiguration?: Schemas.ACLAction[];
    connectConfigurationLink?: Schemas.ACLAction[];
    deployment?: Schemas.ACLAction[];
    deploymentProductionGit?: Schemas.ACLAction[];
    deploymentCheck?: Schemas.ACLAction[];
    deploymentCheckPreview?: Schemas.ACLAction[];
    deploymentPreview?: Schemas.ACLAction[];
    deploymentPrivate?: Schemas.ACLAction[];
    deploymentCheckReRunFromProductionBranch?: Schemas.ACLAction[];
    deploymentRollback?: Schemas.ACLAction[];
    domain?: Schemas.ACLAction[];
    domainAcceptDelegation?: Schemas.ACLAction[];
    domainAuthCodes?: Schemas.ACLAction[];
    domainCertificate?: Schemas.ACLAction[];
    domainCheckConfig?: Schemas.ACLAction[];
    domainMove?: Schemas.ACLAction[];
    domainPurchase?: Schemas.ACLAction[];
    domainRecord?: Schemas.ACLAction[];
    domainTransferIn?: Schemas.ACLAction[];
    event?: Schemas.ACLAction[];
    sensitiveEnvironmentVariablePolicy?: Schemas.ACLAction[];
    fileUpload?: Schemas.ACLAction[];
    gitRepository?: Schemas.ACLAction[];
    ipBlocking?: Schemas.ACLAction[];
    integration?: Schemas.ACLAction[];
    integrationConfiguration?: Schemas.ACLAction[];
    integrationConfigurationTransfer?: Schemas.ACLAction[];
    integrationConfigurationProjects?: Schemas.ACLAction[];
    integrationVercelConfigurationOverride?: Schemas.ACLAction[];
    job?: Schemas.ACLAction[];
    logDrain?: Schemas.ACLAction[];
    Monitoring?: Schemas.ACLAction[];
    monitoringQuery?: Schemas.ACLAction[];
    monitoringChart?: Schemas.ACLAction[];
    notificationDomainConfiguration?: Schemas.ACLAction[];
    notificationDomainExpire?: Schemas.ACLAction[];
    notificationDomainMoved?: Schemas.ACLAction[];
    notificationDomainPurchase?: Schemas.ACLAction[];
    notificationDomainRenewal?: Schemas.ACLAction[];
    notificationDomainTransfer?: Schemas.ACLAction[];
    notificationDomainUnverified?: Schemas.ACLAction[];
    notificationPaymentFailed?: Schemas.ACLAction[];
    notificationUsageAlert?: Schemas.ACLAction[];
    notificationSpendCap?: Schemas.ACLAction[];
    openTelemetryEndpoint?: Schemas.ACLAction[];
    passwordProtection?: Schemas.ACLAction[];
    paymentMethod?: Schemas.ACLAction[];
    permissions?: Schemas.ACLAction[];
    postgres?: Schemas.ACLAction[];
    previewDeploymentSuffix?: Schemas.ACLAction[];
    proTrialOnboarding?: Schemas.ACLAction[];
    project?: Schemas.ACLAction[];
    projectDeploymentHook?: Schemas.ACLAction[];
    projectDomain?: Schemas.ACLAction[];
    projectDomainMove?: Schemas.ACLAction[];
    projectEnvVars?: Schemas.ACLAction[];
    projectEnvVarsUnownedByIntegration?: Schemas.ACLAction[];
    sharedEnvVars?: Schemas.ACLAction[];
    projectEnvVarsProduction?: Schemas.ACLAction[];
    sharedEnvVarsProduction?: Schemas.ACLAction[];
    projectIntegrationConfiguration?: Schemas.ACLAction[];
    projectLink?: Schemas.ACLAction[];
    projectMember?: Schemas.ACLAction[];
    projectProductionBranch?: Schemas.ACLAction[];
    projectTransfer?: Schemas.ACLAction[];
    projectProtectionBypass?: Schemas.ACLAction[];
    rateLimit?: Schemas.ACLAction[];
    redis?: Schemas.ACLAction[];
    remoteCaching?: Schemas.ACLAction[];
    samlConfig?: Schemas.ACLAction[];
    secret?: Schemas.ACLAction[];
    spendCapConfiguration?: Schemas.ACLAction[];
    spendCapState?: Schemas.ACLAction[];
    supportCase?: Schemas.ACLAction[];
    supportCaseComment?: Schemas.ACLAction[];
    team?: Schemas.ACLAction[];
    teamAccessRequest?: Schemas.ACLAction[];
    teamFellowMembership?: Schemas.ACLAction[];
    teamInvite?: Schemas.ACLAction[];
    teamInviteCode?: Schemas.ACLAction[];
    teamJoin?: Schemas.ACLAction[];
    teamOwnMembership?: Schemas.ACLAction[];
    teamOwnMembershipDisconnectSAML?: Schemas.ACLAction[];
    token?: Schemas.ACLAction[];
    usage?: Schemas.ACLAction[];
    user?: Schemas.ACLAction[];
    userConnection?: Schemas.ACLAction[];
    webAnalytics?: Schemas.ACLAction[];
    webAnalyticsPlan?: Schemas.ACLAction[];
    edgeConfig?: Schemas.ACLAction[];
    edgeConfigItem?: Schemas.ACLAction[];
    edgeConfigToken?: Schemas.ACLAction[];
    webhook?: Schemas.ACLAction[];
    ['webhook-event']?: Schemas.ACLAction[];
    endpointVerification?: Schemas.ACLAction[];
    aliasProtectionBypass?: Schemas.ACLAction[];
  };
  lastRollbackTarget?: {
    fromDeploymentId: string;
    toDeploymentId: string;
    jobStatus: 'succeeded' | 'failed' | 'skipped' | 'pending' | 'in-progress';
    requestedAt: number;
  } | null;
  hasFloatingAliases?: boolean;
  /**
   * Construct a type with a set of properties K of type T
   */
  protectionBypass?: {
    [key: string]: string;
  };
  hasActiveBranches?: boolean;
};

export type CreateProjectRequestBody = {
  /**
   * The build command for this project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  buildCommand?: string | null;
  /**
   * @maxLength 256
   */
  commandForIgnoringBuildStep?: string | null;
  /**
   * The dev command for this project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  devCommand?: string | null;
  /**
   * Collection of ENV Variables the Project will use
   */
  environmentVariables?: {
    /**
     * Name of the ENV variable
     */
    key: string;
    /**
     * Deployment Target or Targets in which the ENV variable will be used
     */
    target:
      | (
          | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Productio'
          | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Previe'
          | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Developmen'
        )
      | (
          | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Productio'
          | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Previe'
          | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Developmen'
        )[];
    /**
     * The git branch of the environment variable
     *
     * @maxLength 250
     * @example feature-1
     */
    gitBranch?: string;
    /**
     * Type of the ENV variable
     */
    type?: 'system' | 'secret' | 'encrypted' | 'plain';
    /**
     * Value for the ENV variable
     */
    value: string;
  }[];
  /**
   * The framework that is being used for this project. When `null` is used no framework is selected
   */
  framework?:
    | any
    | 'blitzjs'
    | 'nextjs'
    | 'gatsby'
    | 'remix'
    | 'astro'
    | 'hexo'
    | 'eleventy'
    | 'docusaurus-2'
    | 'docusaurus'
    | 'preact'
    | 'solidstart'
    | 'dojo'
    | 'ember'
    | 'vue'
    | 'scully'
    | 'ionic-angular'
    | 'angular'
    | 'polymer'
    | 'svelte'
    | 'sveltekit'
    | 'sveltekit-1'
    | 'ionic-react'
    | 'create-react-app'
    | 'gridsome'
    | 'umijs'
    | 'sapper'
    | 'saber'
    | 'stencil'
    | 'nuxtjs'
    | 'redwoodjs'
    | 'hugo'
    | 'jekyll'
    | 'brunch'
    | 'middleman'
    | 'zola'
    | 'hydrogen'
    | 'vite'
    | 'vitepress'
    | 'vuepress'
    | 'parcel'
    | 'sanity';
  /**
   * The Git Repository that will be connected to the project. When this is defined, any pushes to the specified connected Git Repository will be automatically deployed
   */
  gitRepository?: {
    /**
     * The name of the git repository. For example: \"vercel/next.js\"
     */
    repo: string;
    /**
     * The Git Provider of the repository
     */
    type: 'github' | 'gitlab' | 'bitbucket';
  };
  /**
   * The install command for this project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  installCommand?: string | null;
  /**
   * The desired name for the project
   *
   * @example a-project-name
   * @maxLength 100
   * @pattern ^[a-z0-9]([a-z0-9]|-[a-z0-9])*$
   */
  name: string;
  /**
   * Opts-out of the message prompting a CLI user to connect a Git repository in `vercel link`.
   *
   * @deprecated true
   */
  skipGitConnectDuringLink?: boolean;
  /**
   * The output directory of the project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  outputDirectory?: string | null;
  /**
   * Specifies whether the source code and logs of the deployments for this project should be public or not
   */
  publicSource?: boolean | null;
  /**
   * The name of a directory or relative path to the source code of your project. When `null` is used it will default to the project root
   *
   * @maxLength 256
   */
  rootDirectory?: string | null;
  /**
   * The region to deploy Serverless Functions in this project
   *
   * @maxLength 4
   */
  serverlessFunctionRegion?: string | null;
};

export type CreateProjectVariables = {
  body: CreateProjectRequestBody;
  queryParams?: CreateProjectQueryParams;
} & FetcherExtraProps;

/**
 * Allows to create a new project with the provided configuration. It only requires the project `name` but more configuration can be provided to override the defaults.
 */
export const createProject = (variables: CreateProjectVariables, signal?: AbortSignal) =>
  fetch<CreateProjectResponse, CreateProjectError, CreateProjectRequestBody, {}, CreateProjectQueryParams, {}>({
    url: '/v9/projects',
    method: 'post',
    ...variables,
    signal
  });

export type GetProjectPathParams = {
  /**
   * The unique project identifier or the project name
   */
  idOrName: string | boolean;
};

export type GetProjectQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetProjectError = Fetcher.ErrorWrapper<undefined>;

export type GetProjectResponse = {
  accountId: string;
  analytics?: {
    id: string;
    canceledAt: number | null;
    disabledAt: number;
    enabledAt: number;
    paidAt?: number;
    sampleRatePercent?: number | null;
    spendLimitInDollars?: number | null;
  };
  autoExposeSystemEnvs?: boolean;
  buildCommand?: string | null;
  commandForIgnoringBuildStep?: string | null;
  connectConfigurationId?: string | null;
  connectBuildsEnabled?: boolean;
  createdAt?: number;
  devCommand?: string | null;
  directoryListing: boolean;
  installCommand?: string | null;
  env?: {
    target?:
      | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
      | ('production' | 'preview' | 'development' | 'preview' | 'development');
    type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
    id?: string;
    key: string;
    value: string;
    configurationId?: string | null;
    createdAt?: number;
    updatedAt?: number;
    createdBy?: string | null;
    updatedBy?: string | null;
    gitBranch?: string;
    edgeConfigId?: string | null;
    edgeConfigTokenId?: string | null;
    /**
     * Whether `value` is decrypted.
     */
    decrypted?: boolean;
  }[];
  framework?:
    | 'blitzjs'
    | 'nextjs'
    | 'gatsby'
    | 'remix'
    | 'astro'
    | 'hexo'
    | 'eleventy'
    | 'docusaurus-2'
    | 'docusaurus'
    | 'preact'
    | 'solidstart'
    | 'dojo'
    | 'ember'
    | 'vue'
    | 'scully'
    | 'ionic-angular'
    | 'angular'
    | 'polymer'
    | 'svelte'
    | 'sveltekit'
    | 'sveltekit-1'
    | 'ionic-react'
    | 'create-react-app'
    | 'gridsome'
    | 'umijs'
    | 'sapper'
    | 'saber'
    | 'stencil'
    | 'nuxtjs'
    | 'redwoodjs'
    | 'hugo'
    | 'jekyll'
    | 'brunch'
    | 'middleman'
    | 'zola'
    | 'hydrogen'
    | 'vite'
    | 'vitepress'
    | 'vuepress'
    | 'parcel'
    | 'sanity'
    | null;
  gitForkProtection?: boolean;
  gitLFS?: boolean;
  id: string;
  latestDeployments?: {
    alias?: string[];
    aliasAssigned?: number | boolean | null;
    aliasError?: {
      code: string;
      message: string;
    } | null;
    aliasFinal?: string | null;
    automaticAliases?: string[];
    builds?: {
      use: string;
      src?: string;
      dest?: string;
    }[];
    createdAt: number;
    createdIn: string;
    creator: {
      email: string;
      githubLogin?: string;
      gitlabLogin?: string;
      uid: string;
      username: string;
    } | null;
    deploymentHostname: string;
    name: string;
    forced?: boolean;
    id: string;
    /**
     * Construct a type with a set of properties K of type T
     */
    meta?: {
      [key: string]: string;
    };
    monorepoManager?: string | null;
    plan: 'hobby' | 'enterprise' | 'pro' | 'oss';
    private: boolean;
    readyState: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED';
    requestedAt?: number;
    target?: string | null;
    teamId?: string | null;
    type: 'LAMBDAS';
    url: string;
    userId: string;
    withCache?: boolean;
    checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
    checksState?: 'registered' | 'running' | 'completed';
    readyAt?: number;
    buildingAt?: number;
    /**
     * Whether or not preview comments are enabled for the deployment
     *
     * @example false
     */
    previewCommentsEnabled?: boolean;
  }[];
  link?:
    | {
        org?: string;
        repo?: string;
        repoId?: number;
        type?: 'github';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        projectId?: string;
        projectName?: string;
        projectNameWithNamespace?: string;
        projectNamespace?: string;
        projectUrl?: string;
        type?: 'gitlab';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        name?: string;
        slug?: string;
        owner?: string;
        type?: 'bitbucket';
        uuid?: string;
        workspaceUuid?: string;
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      };
  name: string;
  nodeVersion: '18.x' | '16.x' | '14.x' | '12.x' | '10.x';
  outputDirectory?: string | null;
  passwordProtection?: {
    deploymentType: 'preview' | 'all';
  } | null;
  publicSource?: boolean | null;
  rootDirectory?: string | null;
  serverlessFunctionRegion?: string | null;
  skipGitConnectDuringLink?: boolean;
  sourceFilesOutsideRootDirectory?: boolean;
  ssoProtection?: {
    deploymentType: 'preview' | 'all';
  } | null;
  /**
   * An object containing the deployment's metadata
   *
   * @example {"foo":"bar"}
   */
  targets?: {
    [key: string]: string;
  };
  transferCompletedAt?: number;
  transferStartedAt?: number;
  transferToAccountId?: string;
  transferredFromAccountId?: string;
  updatedAt?: number;
  live?: boolean;
  enablePreviewFeedback?: boolean | null;
  permissions?: {
    aliasGlobal?: Schemas.ACLAction[];
    aliasProject?: Schemas.ACLAction[];
    analytics?: Schemas.ACLAction[];
    analyticsSampling?: Schemas.ACLAction[];
    analyticsUsage?: Schemas.ACLAction[];
    auditLog?: Schemas.ACLAction[];
    billingAddress?: Schemas.ACLAction[];
    billingInformation?: Schemas.ACLAction[];
    billingInvoice?: Schemas.ACLAction[];
    billingInvoiceEmailRecipient?: Schemas.ACLAction[];
    billingInvoiceLanguage?: Schemas.ACLAction[];
    billingPlan?: Schemas.ACLAction[];
    billingPurchaseOrder?: Schemas.ACLAction[];
    billingTaxId?: Schemas.ACLAction[];
    cacheArtifact?: Schemas.ACLAction[];
    cacheArtifactUsageEvent?: Schemas.ACLAction[];
    concurrentBuilds?: Schemas.ACLAction[];
    connect?: Schemas.ACLAction[];
    connectConfiguration?: Schemas.ACLAction[];
    connectConfigurationLink?: Schemas.ACLAction[];
    deployment?: Schemas.ACLAction[];
    deploymentProductionGit?: Schemas.ACLAction[];
    deploymentCheck?: Schemas.ACLAction[];
    deploymentCheckPreview?: Schemas.ACLAction[];
    deploymentPreview?: Schemas.ACLAction[];
    deploymentPrivate?: Schemas.ACLAction[];
    deploymentCheckReRunFromProductionBranch?: Schemas.ACLAction[];
    deploymentRollback?: Schemas.ACLAction[];
    domain?: Schemas.ACLAction[];
    domainAcceptDelegation?: Schemas.ACLAction[];
    domainAuthCodes?: Schemas.ACLAction[];
    domainCertificate?: Schemas.ACLAction[];
    domainCheckConfig?: Schemas.ACLAction[];
    domainMove?: Schemas.ACLAction[];
    domainPurchase?: Schemas.ACLAction[];
    domainRecord?: Schemas.ACLAction[];
    domainTransferIn?: Schemas.ACLAction[];
    event?: Schemas.ACLAction[];
    sensitiveEnvironmentVariablePolicy?: Schemas.ACLAction[];
    fileUpload?: Schemas.ACLAction[];
    gitRepository?: Schemas.ACLAction[];
    ipBlocking?: Schemas.ACLAction[];
    integration?: Schemas.ACLAction[];
    integrationConfiguration?: Schemas.ACLAction[];
    integrationConfigurationTransfer?: Schemas.ACLAction[];
    integrationConfigurationProjects?: Schemas.ACLAction[];
    integrationVercelConfigurationOverride?: Schemas.ACLAction[];
    job?: Schemas.ACLAction[];
    logDrain?: Schemas.ACLAction[];
    Monitoring?: Schemas.ACLAction[];
    monitoringQuery?: Schemas.ACLAction[];
    monitoringChart?: Schemas.ACLAction[];
    notificationDomainConfiguration?: Schemas.ACLAction[];
    notificationDomainExpire?: Schemas.ACLAction[];
    notificationDomainMoved?: Schemas.ACLAction[];
    notificationDomainPurchase?: Schemas.ACLAction[];
    notificationDomainRenewal?: Schemas.ACLAction[];
    notificationDomainTransfer?: Schemas.ACLAction[];
    notificationDomainUnverified?: Schemas.ACLAction[];
    notificationPaymentFailed?: Schemas.ACLAction[];
    notificationUsageAlert?: Schemas.ACLAction[];
    notificationSpendCap?: Schemas.ACLAction[];
    openTelemetryEndpoint?: Schemas.ACLAction[];
    passwordProtection?: Schemas.ACLAction[];
    paymentMethod?: Schemas.ACLAction[];
    permissions?: Schemas.ACLAction[];
    postgres?: Schemas.ACLAction[];
    previewDeploymentSuffix?: Schemas.ACLAction[];
    proTrialOnboarding?: Schemas.ACLAction[];
    project?: Schemas.ACLAction[];
    projectDeploymentHook?: Schemas.ACLAction[];
    projectDomain?: Schemas.ACLAction[];
    projectDomainMove?: Schemas.ACLAction[];
    projectEnvVars?: Schemas.ACLAction[];
    projectEnvVarsUnownedByIntegration?: Schemas.ACLAction[];
    sharedEnvVars?: Schemas.ACLAction[];
    projectEnvVarsProduction?: Schemas.ACLAction[];
    sharedEnvVarsProduction?: Schemas.ACLAction[];
    projectIntegrationConfiguration?: Schemas.ACLAction[];
    projectLink?: Schemas.ACLAction[];
    projectMember?: Schemas.ACLAction[];
    projectProductionBranch?: Schemas.ACLAction[];
    projectTransfer?: Schemas.ACLAction[];
    projectProtectionBypass?: Schemas.ACLAction[];
    rateLimit?: Schemas.ACLAction[];
    redis?: Schemas.ACLAction[];
    remoteCaching?: Schemas.ACLAction[];
    samlConfig?: Schemas.ACLAction[];
    secret?: Schemas.ACLAction[];
    spendCapConfiguration?: Schemas.ACLAction[];
    spendCapState?: Schemas.ACLAction[];
    supportCase?: Schemas.ACLAction[];
    supportCaseComment?: Schemas.ACLAction[];
    team?: Schemas.ACLAction[];
    teamAccessRequest?: Schemas.ACLAction[];
    teamFellowMembership?: Schemas.ACLAction[];
    teamInvite?: Schemas.ACLAction[];
    teamInviteCode?: Schemas.ACLAction[];
    teamJoin?: Schemas.ACLAction[];
    teamOwnMembership?: Schemas.ACLAction[];
    teamOwnMembershipDisconnectSAML?: Schemas.ACLAction[];
    token?: Schemas.ACLAction[];
    usage?: Schemas.ACLAction[];
    user?: Schemas.ACLAction[];
    userConnection?: Schemas.ACLAction[];
    webAnalytics?: Schemas.ACLAction[];
    webAnalyticsPlan?: Schemas.ACLAction[];
    edgeConfig?: Schemas.ACLAction[];
    edgeConfigItem?: Schemas.ACLAction[];
    edgeConfigToken?: Schemas.ACLAction[];
    webhook?: Schemas.ACLAction[];
    ['webhook-event']?: Schemas.ACLAction[];
    endpointVerification?: Schemas.ACLAction[];
    aliasProtectionBypass?: Schemas.ACLAction[];
  };
  lastRollbackTarget?: {
    fromDeploymentId: string;
    toDeploymentId: string;
    jobStatus: 'succeeded' | 'failed' | 'skipped' | 'pending' | 'in-progress';
    requestedAt: number;
  } | null;
  hasFloatingAliases?: boolean;
  /**
   * Construct a type with a set of properties K of type T
   */
  protectionBypass?: {
    [key: string]: string;
  };
  hasActiveBranches?: boolean;
};

export type GetProjectVariables = {
  pathParams: GetProjectPathParams;
  queryParams?: GetProjectQueryParams;
} & FetcherExtraProps;

/**
 * Get the information for a specific project by passing either the project `id` or `name` in the URL.
 */
export const getProject = (variables: GetProjectVariables, signal?: AbortSignal) =>
  fetch<GetProjectResponse, GetProjectError, undefined, {}, GetProjectQueryParams, GetProjectPathParams>({
    url: '/v9/projects/{idOrName}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateProjectPathParams = {
  /**
   * The unique project identifier or the project name
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  idOrName: string;
};

export type UpdateProjectQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type UpdateProjectError = Fetcher.ErrorWrapper<undefined>;

export type UpdateProjectResponse = {
  accountId: string;
  analytics?: {
    id: string;
    canceledAt: number | null;
    disabledAt: number;
    enabledAt: number;
    paidAt?: number;
    sampleRatePercent?: number | null;
    spendLimitInDollars?: number | null;
  };
  autoExposeSystemEnvs?: boolean;
  buildCommand?: string | null;
  commandForIgnoringBuildStep?: string | null;
  connectConfigurationId?: string | null;
  connectBuildsEnabled?: boolean;
  createdAt?: number;
  devCommand?: string | null;
  directoryListing: boolean;
  installCommand?: string | null;
  env?: {
    target?:
      | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
      | ('production' | 'preview' | 'development' | 'preview' | 'development');
    type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
    id?: string;
    key: string;
    value: string;
    configurationId?: string | null;
    createdAt?: number;
    updatedAt?: number;
    createdBy?: string | null;
    updatedBy?: string | null;
    gitBranch?: string;
    edgeConfigId?: string | null;
    edgeConfigTokenId?: string | null;
    /**
     * Whether `value` is decrypted.
     */
    decrypted?: boolean;
  }[];
  framework?:
    | 'blitzjs'
    | 'nextjs'
    | 'gatsby'
    | 'remix'
    | 'astro'
    | 'hexo'
    | 'eleventy'
    | 'docusaurus-2'
    | 'docusaurus'
    | 'preact'
    | 'solidstart'
    | 'dojo'
    | 'ember'
    | 'vue'
    | 'scully'
    | 'ionic-angular'
    | 'angular'
    | 'polymer'
    | 'svelte'
    | 'sveltekit'
    | 'sveltekit-1'
    | 'ionic-react'
    | 'create-react-app'
    | 'gridsome'
    | 'umijs'
    | 'sapper'
    | 'saber'
    | 'stencil'
    | 'nuxtjs'
    | 'redwoodjs'
    | 'hugo'
    | 'jekyll'
    | 'brunch'
    | 'middleman'
    | 'zola'
    | 'hydrogen'
    | 'vite'
    | 'vitepress'
    | 'vuepress'
    | 'parcel'
    | 'sanity'
    | null;
  gitForkProtection?: boolean;
  gitLFS?: boolean;
  id: string;
  latestDeployments?: {
    alias?: string[];
    aliasAssigned?: number | boolean | null;
    aliasError?: {
      code: string;
      message: string;
    } | null;
    aliasFinal?: string | null;
    automaticAliases?: string[];
    builds?: {
      use: string;
      src?: string;
      dest?: string;
    }[];
    createdAt: number;
    createdIn: string;
    creator: {
      email: string;
      githubLogin?: string;
      gitlabLogin?: string;
      uid: string;
      username: string;
    } | null;
    deploymentHostname: string;
    name: string;
    forced?: boolean;
    id: string;
    /**
     * Construct a type with a set of properties K of type T
     */
    meta?: {
      [key: string]: string;
    };
    monorepoManager?: string | null;
    plan: 'hobby' | 'enterprise' | 'pro' | 'oss';
    private: boolean;
    readyState: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED';
    requestedAt?: number;
    target?: string | null;
    teamId?: string | null;
    type: 'LAMBDAS';
    url: string;
    userId: string;
    withCache?: boolean;
    checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
    checksState?: 'registered' | 'running' | 'completed';
    readyAt?: number;
    buildingAt?: number;
    /**
     * Whether or not preview comments are enabled for the deployment
     *
     * @example false
     */
    previewCommentsEnabled?: boolean;
  }[];
  link?:
    | {
        org?: string;
        repo?: string;
        repoId?: number;
        type?: 'github';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        projectId?: string;
        projectName?: string;
        projectNameWithNamespace?: string;
        projectNamespace?: string;
        projectUrl?: string;
        type?: 'gitlab';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        name?: string;
        slug?: string;
        owner?: string;
        type?: 'bitbucket';
        uuid?: string;
        workspaceUuid?: string;
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      };
  name: string;
  nodeVersion: '18.x' | '16.x' | '14.x' | '12.x' | '10.x';
  outputDirectory?: string | null;
  passwordProtection?: {
    deploymentType: 'all' | 'preview';
  } | null;
  publicSource?: boolean | null;
  rootDirectory?: string | null;
  serverlessFunctionRegion?: string | null;
  skipGitConnectDuringLink?: boolean;
  sourceFilesOutsideRootDirectory?: boolean;
  ssoProtection?: {
    deploymentType: 'all' | 'preview';
  } | null;
  /**
   * An object containing the deployment's metadata
   *
   * @example {"foo":"bar"}
   */
  targets?: {
    [key: string]: string;
  };
  transferCompletedAt?: number;
  transferStartedAt?: number;
  transferToAccountId?: string;
  transferredFromAccountId?: string;
  updatedAt?: number;
  live?: boolean;
  enablePreviewFeedback?: boolean | null;
  permissions?: {
    aliasGlobal?: Schemas.ACLAction[];
    aliasProject?: Schemas.ACLAction[];
    analytics?: Schemas.ACLAction[];
    analyticsSampling?: Schemas.ACLAction[];
    analyticsUsage?: Schemas.ACLAction[];
    auditLog?: Schemas.ACLAction[];
    billingAddress?: Schemas.ACLAction[];
    billingInformation?: Schemas.ACLAction[];
    billingInvoice?: Schemas.ACLAction[];
    billingInvoiceEmailRecipient?: Schemas.ACLAction[];
    billingInvoiceLanguage?: Schemas.ACLAction[];
    billingPlan?: Schemas.ACLAction[];
    billingPurchaseOrder?: Schemas.ACLAction[];
    billingTaxId?: Schemas.ACLAction[];
    cacheArtifact?: Schemas.ACLAction[];
    cacheArtifactUsageEvent?: Schemas.ACLAction[];
    concurrentBuilds?: Schemas.ACLAction[];
    connect?: Schemas.ACLAction[];
    connectConfiguration?: Schemas.ACLAction[];
    connectConfigurationLink?: Schemas.ACLAction[];
    deployment?: Schemas.ACLAction[];
    deploymentProductionGit?: Schemas.ACLAction[];
    deploymentCheck?: Schemas.ACLAction[];
    deploymentCheckPreview?: Schemas.ACLAction[];
    deploymentPreview?: Schemas.ACLAction[];
    deploymentPrivate?: Schemas.ACLAction[];
    deploymentCheckReRunFromProductionBranch?: Schemas.ACLAction[];
    deploymentRollback?: Schemas.ACLAction[];
    domain?: Schemas.ACLAction[];
    domainAcceptDelegation?: Schemas.ACLAction[];
    domainAuthCodes?: Schemas.ACLAction[];
    domainCertificate?: Schemas.ACLAction[];
    domainCheckConfig?: Schemas.ACLAction[];
    domainMove?: Schemas.ACLAction[];
    domainPurchase?: Schemas.ACLAction[];
    domainRecord?: Schemas.ACLAction[];
    domainTransferIn?: Schemas.ACLAction[];
    event?: Schemas.ACLAction[];
    sensitiveEnvironmentVariablePolicy?: Schemas.ACLAction[];
    fileUpload?: Schemas.ACLAction[];
    gitRepository?: Schemas.ACLAction[];
    ipBlocking?: Schemas.ACLAction[];
    integration?: Schemas.ACLAction[];
    integrationConfiguration?: Schemas.ACLAction[];
    integrationConfigurationTransfer?: Schemas.ACLAction[];
    integrationConfigurationProjects?: Schemas.ACLAction[];
    integrationVercelConfigurationOverride?: Schemas.ACLAction[];
    job?: Schemas.ACLAction[];
    logDrain?: Schemas.ACLAction[];
    Monitoring?: Schemas.ACLAction[];
    monitoringQuery?: Schemas.ACLAction[];
    monitoringChart?: Schemas.ACLAction[];
    notificationDomainConfiguration?: Schemas.ACLAction[];
    notificationDomainExpire?: Schemas.ACLAction[];
    notificationDomainMoved?: Schemas.ACLAction[];
    notificationDomainPurchase?: Schemas.ACLAction[];
    notificationDomainRenewal?: Schemas.ACLAction[];
    notificationDomainTransfer?: Schemas.ACLAction[];
    notificationDomainUnverified?: Schemas.ACLAction[];
    notificationPaymentFailed?: Schemas.ACLAction[];
    notificationUsageAlert?: Schemas.ACLAction[];
    notificationSpendCap?: Schemas.ACLAction[];
    openTelemetryEndpoint?: Schemas.ACLAction[];
    passwordProtection?: Schemas.ACLAction[];
    paymentMethod?: Schemas.ACLAction[];
    permissions?: Schemas.ACLAction[];
    postgres?: Schemas.ACLAction[];
    previewDeploymentSuffix?: Schemas.ACLAction[];
    proTrialOnboarding?: Schemas.ACLAction[];
    project?: Schemas.ACLAction[];
    projectDeploymentHook?: Schemas.ACLAction[];
    projectDomain?: Schemas.ACLAction[];
    projectDomainMove?: Schemas.ACLAction[];
    projectEnvVars?: Schemas.ACLAction[];
    projectEnvVarsUnownedByIntegration?: Schemas.ACLAction[];
    sharedEnvVars?: Schemas.ACLAction[];
    projectEnvVarsProduction?: Schemas.ACLAction[];
    sharedEnvVarsProduction?: Schemas.ACLAction[];
    projectIntegrationConfiguration?: Schemas.ACLAction[];
    projectLink?: Schemas.ACLAction[];
    projectMember?: Schemas.ACLAction[];
    projectProductionBranch?: Schemas.ACLAction[];
    projectTransfer?: Schemas.ACLAction[];
    projectProtectionBypass?: Schemas.ACLAction[];
    rateLimit?: Schemas.ACLAction[];
    redis?: Schemas.ACLAction[];
    remoteCaching?: Schemas.ACLAction[];
    samlConfig?: Schemas.ACLAction[];
    secret?: Schemas.ACLAction[];
    spendCapConfiguration?: Schemas.ACLAction[];
    spendCapState?: Schemas.ACLAction[];
    supportCase?: Schemas.ACLAction[];
    supportCaseComment?: Schemas.ACLAction[];
    team?: Schemas.ACLAction[];
    teamAccessRequest?: Schemas.ACLAction[];
    teamFellowMembership?: Schemas.ACLAction[];
    teamInvite?: Schemas.ACLAction[];
    teamInviteCode?: Schemas.ACLAction[];
    teamJoin?: Schemas.ACLAction[];
    teamOwnMembership?: Schemas.ACLAction[];
    teamOwnMembershipDisconnectSAML?: Schemas.ACLAction[];
    token?: Schemas.ACLAction[];
    usage?: Schemas.ACLAction[];
    user?: Schemas.ACLAction[];
    userConnection?: Schemas.ACLAction[];
    webAnalytics?: Schemas.ACLAction[];
    webAnalyticsPlan?: Schemas.ACLAction[];
    edgeConfig?: Schemas.ACLAction[];
    edgeConfigItem?: Schemas.ACLAction[];
    edgeConfigToken?: Schemas.ACLAction[];
    webhook?: Schemas.ACLAction[];
    ['webhook-event']?: Schemas.ACLAction[];
    endpointVerification?: Schemas.ACLAction[];
    aliasProtectionBypass?: Schemas.ACLAction[];
  };
  lastRollbackTarget?: {
    fromDeploymentId: string;
    toDeploymentId: string;
    jobStatus: 'succeeded' | 'failed' | 'skipped' | 'pending' | 'in-progress';
    requestedAt: number;
  } | null;
  hasFloatingAliases?: boolean;
  /**
   * Construct a type with a set of properties K of type T
   */
  protectionBypass?: {
    [key: string]: string;
  };
  hasActiveBranches?: boolean;
};

export type UpdateProjectRequestBody = {
  autoExposeSystemEnvs?: boolean;
  /**
   * The build command for this project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  buildCommand?: string | null;
  /**
   * @maxLength 256
   */
  commandForIgnoringBuildStep?: string | null;
  /**
   * The dev command for this project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  devCommand?: string | null;
  directoryListing?: boolean;
  /**
   * The framework that is being used for this project. When `null` is used no framework is selected
   */
  framework?:
    | any
    | 'blitzjs'
    | 'nextjs'
    | 'gatsby'
    | 'remix'
    | 'astro'
    | 'hexo'
    | 'eleventy'
    | 'docusaurus-2'
    | 'docusaurus'
    | 'preact'
    | 'solidstart'
    | 'dojo'
    | 'ember'
    | 'vue'
    | 'scully'
    | 'ionic-angular'
    | 'angular'
    | 'polymer'
    | 'svelte'
    | 'sveltekit'
    | 'sveltekit-1'
    | 'ionic-react'
    | 'create-react-app'
    | 'gridsome'
    | 'umijs'
    | 'sapper'
    | 'saber'
    | 'stencil'
    | 'nuxtjs'
    | 'redwoodjs'
    | 'hugo'
    | 'jekyll'
    | 'brunch'
    | 'middleman'
    | 'zola'
    | 'hydrogen'
    | 'vite'
    | 'vitepress'
    | 'vuepress'
    | 'parcel'
    | 'sanity'
    | null;
  /**
   * Specifies whether PRs from Git forks should require a team member's authorization before it can be deployed
   */
  gitForkProtection?: boolean;
  /**
   * Specifies whether Git LFS is enabled for this project.
   */
  gitLFS?: boolean;
  /**
   * The install command for this project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  installCommand?: string | null;
  /**
   * The desired name for the project
   *
   * @example a-project-name
   * @maxLength 100
   * @pattern ^[a-z0-9]([a-z0-9]|-[a-z0-9])*$
   */
  name?: string;
  nodeVersion?: '18.x' | '16.x' | '14.x' | '12.x' | '10.x';
  /**
   * The output directory of the project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  outputDirectory?: string | null;
  /**
   * Allows to protect project deployments with a password
   */
  passwordProtection?: {
    /**
     * Specify if the password will apply to every Deployment Target or just Preview
     */
    deploymentType: 'all' | 'preview';
    /**
     * The password that will be used to protect Project Deployments
     *
     * @maxLength 72
     */
    password?: string | null;
  } | null;
  /**
   * Specifies whether the source code and logs of the deployments for this project should be public or not
   */
  publicSource?: boolean | null;
  /**
   * The name of a directory or relative path to the source code of your project. When `null` is used it will default to the project root
   *
   * @maxLength 256
   */
  rootDirectory?: string | null;
  /**
   * The region to deploy Serverless Functions in this project
   *
   * @maxLength 4
   */
  serverlessFunctionRegion?: string | null;
  /**
   * Opts-out of the message prompting a CLI user to connect a Git repository in `vercel link`.
   *
   * @deprecated true
   */
  skipGitConnectDuringLink?: boolean;
  /**
   * Indicates if there are source files outside of the root directory
   */
  sourceFilesOutsideRootDirectory?: boolean;
  /**
   * Ensures visitors to your Preview Deployments are logged into Vercel and have a minimum of Viewer access on your team
   */
  ssoProtection?: {
    /**
     * Specify if the Vercel Authentication (SSO Protection) will apply to every Deployment Target or just Preview
     *
     * @default preview
     */
    deploymentType: 'all' | 'preview';
  } | null;
  /**
   * Opt-in to Preview comments on the project level
   */
  enablePreviewFeedback?: boolean | null;
};

export type UpdateProjectVariables = {
  body?: UpdateProjectRequestBody;
  pathParams: UpdateProjectPathParams;
  queryParams?: UpdateProjectQueryParams;
} & FetcherExtraProps;

/**
 * Update the fields of a project using either its `name` or `id`.
 */
export const updateProject = (variables: UpdateProjectVariables, signal?: AbortSignal) =>
  fetch<
    UpdateProjectResponse,
    UpdateProjectError,
    UpdateProjectRequestBody,
    {},
    UpdateProjectQueryParams,
    UpdateProjectPathParams
  >({ url: '/v9/projects/{idOrName}', method: 'patch', ...variables, signal });

export type DeleteProjectPathParams = {
  /**
   * The unique project identifier or the project name
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  idOrName: string;
};

export type DeleteProjectQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteProjectError = Fetcher.ErrorWrapper<undefined>;

export type DeleteProjectVariables = {
  pathParams: DeleteProjectPathParams;
  queryParams?: DeleteProjectQueryParams;
} & FetcherExtraProps;

/**
 * Delete a specific project by passing either the project `id` or `name` in the URL.
 */
export const deleteProject = (variables: DeleteProjectVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteProjectError, undefined, {}, DeleteProjectQueryParams, DeleteProjectPathParams>({
    url: '/v9/projects/{idOrName}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetProjectDomainsPathParams = {
  /**
   * The unique project identifier or the project name
   */
  idOrName: string | number;
};

export type GetProjectDomainsQueryParams = {
  /**
   * Filters only production domains when set to `true`.
   *
   * @default false
   */
  production?: 'true' | 'false';
  /**
   * Filters domains based on specific branch.
   */
  gitBranch?: string;
  /**
   * Excludes redirect project domains when \"false\". Includes redirect project domains when \"true\" (default).
   *
   * @default true
   */
  redirects?: 'true' | 'false';
  /**
   * Filters domains based on their redirect target.
   *
   * @example example.com
   */
  redirect?: string;
  /**
   * Filters domains based on their verification status.
   */
  verified?: 'true' | 'false';
  /**
   * Maximum number of domains to list from a request (max 100).
   *
   * @example 20
   */
  limit?: number;
  /**
   * Get domains created after this JavaScript timestamp.
   *
   * @example 1609499532000
   */
  since?: number;
  /**
   * Get domains created before this JavaScript timestamp.
   *
   * @example 1612264332000
   */
  until?: number;
  /**
   * Domains sort order by createdAt
   *
   * @default DESC
   */
  order?: 'ASC' | 'DESC';
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetProjectDomainsError = Fetcher.ErrorWrapper<undefined>;

export type GetProjectDomainsResponse = {
  domains: {
    name: string;
    apexName: string;
    projectId: string;
    redirect?: string | null;
    redirectStatusCode?: 307 | 301 | 302 | 308 | null;
    gitBranch?: string | null;
    updatedAt?: number;
    createdAt?: number;
    /**
     * `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.
     */
    verified: boolean;
    /**
     * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
     */
    verification?: {
      type: string;
      domain: string;
      value: string;
      reason: string;
    }[];
  }[];
  pagination: Schemas.Pagination;
};

export type GetProjectDomainsVariables = {
  pathParams: GetProjectDomainsPathParams;
  queryParams?: GetProjectDomainsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieve the domains associated with a given project by passing either the project `id` or `name` in the URL.
 */
export const getProjectDomains = (variables: GetProjectDomainsVariables, signal?: AbortSignal) =>
  fetch<
    GetProjectDomainsResponse,
    GetProjectDomainsError,
    undefined,
    {},
    GetProjectDomainsQueryParams,
    GetProjectDomainsPathParams
  >({ url: '/v9/projects/{idOrName}/domains', method: 'get', ...variables, signal });

export type GetProjectDomainPathParams = {
  /**
   * The unique project identifier or the project name
   */
  idOrName: string;
  /**
   * The project domain name
   *
   * @example www.example.com
   */
  domain: string;
};

export type GetProjectDomainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetProjectDomainError = Fetcher.ErrorWrapper<undefined>;

export type GetProjectDomainResponse = {
  name: string;
  apexName: string;
  projectId: string;
  redirect?: string | null;
  redirectStatusCode?: 307 | 301 | 302 | 308 | null;
  gitBranch?: string | null;
  updatedAt?: number;
  createdAt?: number;
  /**
   * `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.
   */
  verified: boolean;
  /**
   * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
   */
  verification?: {
    type: string;
    domain: string;
    value: string;
    reason: string;
  }[];
};

export type GetProjectDomainVariables = {
  pathParams: GetProjectDomainPathParams;
  queryParams?: GetProjectDomainQueryParams;
} & FetcherExtraProps;

/**
 * Get project domain by project id/name and domain name.
 */
export const getProjectDomain = (variables: GetProjectDomainVariables, signal?: AbortSignal) =>
  fetch<
    GetProjectDomainResponse,
    GetProjectDomainError,
    undefined,
    {},
    GetProjectDomainQueryParams,
    GetProjectDomainPathParams
  >({ url: '/v9/projects/{idOrName}/domains/{domain}', method: 'get', ...variables, signal });

export type UpdateProjectDomainPathParams = {
  /**
   * The unique project identifier or the project name
   */
  idOrName: string;
  /**
   * The project domain name
   *
   * @example www.example.com
   */
  domain: string;
};

export type UpdateProjectDomainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type UpdateProjectDomainError = Fetcher.ErrorWrapper<undefined>;

export type UpdateProjectDomainResponse = {
  name: string;
  apexName: string;
  projectId: string;
  redirect?: string | null;
  redirectStatusCode?: 307 | 301 | 302 | 308 | null;
  gitBranch?: string | null;
  updatedAt?: number;
  createdAt?: number;
  /**
   * `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.
   */
  verified: boolean;
  /**
   * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
   */
  verification?: {
    type: string;
    domain: string;
    value: string;
    reason: string;
  }[];
};

export type UpdateProjectDomainRequestBody = {
  /**
   * Git branch to link the project domain
   *
   * @example null
   * @maxLength 250
   */
  gitBranch?: string | null;
  /**
   * Target destination domain for redirect
   *
   * @example foobar.com
   */
  redirect?: string | null;
  /**
   * Status code for domain redirect
   *
   * @example 307
   */
  redirectStatusCode?: any | 301 | 302 | 307 | 308 | null;
};

export type UpdateProjectDomainVariables = {
  body?: UpdateProjectDomainRequestBody;
  pathParams: UpdateProjectDomainPathParams;
  queryParams?: UpdateProjectDomainQueryParams;
} & FetcherExtraProps;

/**
 * Update a project domain's configuration, including the name, git branch and redirect of the domain.
 */
export const updateProjectDomain = (variables: UpdateProjectDomainVariables, signal?: AbortSignal) =>
  fetch<
    UpdateProjectDomainResponse,
    UpdateProjectDomainError,
    UpdateProjectDomainRequestBody,
    {},
    UpdateProjectDomainQueryParams,
    UpdateProjectDomainPathParams
  >({ url: '/v9/projects/{idOrName}/domains/{domain}', method: 'patch', ...variables, signal });

export type RemoveProjectDomainPathParams = {
  /**
   * The unique project identifier or the project name
   */
  idOrName: string;
  /**
   * The project domain name
   *
   * @example www.example.com
   */
  domain: string;
};

export type RemoveProjectDomainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type RemoveProjectDomainError = Fetcher.ErrorWrapper<undefined>;

export type RemoveProjectDomainVariables = {
  pathParams: RemoveProjectDomainPathParams;
  queryParams?: RemoveProjectDomainQueryParams;
} & FetcherExtraProps;

/**
 * Remove a domain from a project by passing the domain name and by specifying the project by either passing the project `id` or `name` in the URL.
 */
export const removeProjectDomain = (variables: RemoveProjectDomainVariables, signal?: AbortSignal) =>
  fetch<
    Record<string, any>,
    RemoveProjectDomainError,
    undefined,
    {},
    RemoveProjectDomainQueryParams,
    RemoveProjectDomainPathParams
  >({ url: '/v9/projects/{idOrName}/domains/{domain}', method: 'delete', ...variables, signal });

export type AddProjectDomainPathParams = {
  /**
   * The unique project identifier or the project name
   */
  idOrName: string;
};

export type AddProjectDomainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type AddProjectDomainError = Fetcher.ErrorWrapper<undefined>;

export type AddProjectDomainResponse = {
  name: string;
  apexName: string;
  projectId: string;
  redirect?: string | null;
  redirectStatusCode?: 307 | 301 | 302 | 308 | null;
  gitBranch?: string | null;
  updatedAt?: number;
  createdAt?: number;
  /**
   * `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.
   */
  verified: boolean;
  /**
   * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
   */
  verification?: {
    type: string;
    domain: string;
    value: string;
    reason: string;
  }[];
};

export type AddProjectDomainRequestBody = {
  /**
   * The project domain name
   *
   * @example www.example.com
   */
  name: string;
  /**
   * Git branch to link the project domain
   *
   * @example null
   * @maxLength 250
   */
  gitBranch?: string | null;
  /**
   * Target destination domain for redirect
   *
   * @example foobar.com
   */
  redirect?: string | null;
  /**
   * Status code for domain redirect
   *
   * @example 307
   */
  redirectStatusCode?: any | 301 | 302 | 307 | 308 | null;
};

export type AddProjectDomainVariables = {
  body: AddProjectDomainRequestBody;
  pathParams: AddProjectDomainPathParams;
  queryParams?: AddProjectDomainQueryParams;
} & FetcherExtraProps;

/**
 * Add a domain to the project by passing its domain name and by specifying the project by either passing the project `id` or `name` in the URL. If the domain is not yet verified to be used on this project, the request will return `verified = false`, and the domain will need to be verified according to the `verification` challenge via `POST /projects/:idOrName/domains/:domain/verify`. If the domain already exists on the project, the request will fail with a `400` status code.
 */
export const addProjectDomain = (variables: AddProjectDomainVariables, signal?: AbortSignal) =>
  fetch<
    AddProjectDomainResponse,
    AddProjectDomainError,
    AddProjectDomainRequestBody,
    {},
    AddProjectDomainQueryParams,
    AddProjectDomainPathParams
  >({ url: '/v10/projects/{idOrName}/domains', method: 'post', ...variables, signal });

export type VerifyProjectDomainPathParams = {
  /**
   * The unique project identifier or the project name
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  idOrName: string;
  /**
   * The domain name you want to verify
   *
   * @example example.com
   */
  domain: string;
};

export type VerifyProjectDomainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type VerifyProjectDomainError = Fetcher.ErrorWrapper<undefined>;

export type VerifyProjectDomainResponse = {
  name: string;
  apexName: string;
  projectId: string;
  redirect?: string | null;
  redirectStatusCode?: 307 | 301 | 302 | 308 | null;
  gitBranch?: string | null;
  updatedAt?: number;
  createdAt?: number;
  /**
   * `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.
   */
  verified: boolean;
  /**
   * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
   */
  verification?: {
    type: string;
    domain: string;
    value: string;
    reason: string;
  }[];
};

export type VerifyProjectDomainVariables = {
  pathParams: VerifyProjectDomainPathParams;
  queryParams?: VerifyProjectDomainQueryParams;
} & FetcherExtraProps;

/**
 * Attempts to verify a project domain with `verified = false` by checking the correctness of the project domain's `verification` challenge.
 */
export const verifyProjectDomain = (variables: VerifyProjectDomainVariables, signal?: AbortSignal) =>
  fetch<
    VerifyProjectDomainResponse,
    VerifyProjectDomainError,
    undefined,
    {},
    VerifyProjectDomainQueryParams,
    VerifyProjectDomainPathParams
  >({ url: '/v9/projects/{idOrName}/domains/{domain}/verify', method: 'post', ...variables, signal });

export type FilterProjectEnvsPathParams = {
  /**
   * The unique project identifier or the project name
   *
   * @example prj_XLKmu1DyR1eY7zq8UgeRKbA7yVLA
   */
  idOrName: string;
};

export type FilterProjectEnvsQueryParams = {
  /**
   * If defined, the git branch of the environment variable to filter the results
   *
   * @maxLength 250
   * @example feature-1
   */
  gitBranch?: string;
  /**
   * If true, the environment variable value will be decrypted
   *
   * @example true
   * @deprecated true
   */
  decrypt?: 'true' | 'false';
  /**
   * The source that is calling the endpoint.
   *
   * @example vercel-cli:pull
   */
  source?: string;
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type FilterProjectEnvsError = Fetcher.ErrorWrapper<undefined>;

export type FilterProjectEnvsVariables = {
  pathParams: FilterProjectEnvsPathParams;
  queryParams?: FilterProjectEnvsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieve the environment variables for a given project by passing either the project `id` or `name` in the URL.
 */
export const filterProjectEnvs = (variables: FilterProjectEnvsVariables, signal?: AbortSignal) =>
  fetch<
    | {
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development');
        type?: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
        id?: string;
        key?: string;
        value?: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
        system?: boolean;
      }
    | {
        envs: {
          target?:
            | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
            | ('production' | 'preview' | 'development' | 'preview' | 'development');
          type?: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
          id?: string;
          key?: string;
          value?: string;
          configurationId?: string | null;
          createdAt?: number;
          updatedAt?: number;
          createdBy?: string | null;
          updatedBy?: string | null;
          gitBranch?: string;
          edgeConfigId?: string | null;
          edgeConfigTokenId?: string | null;
          /**
           * Whether `value` is decrypted.
           */
          decrypted?: boolean;
          system?: boolean;
        }[];
        pagination: Schemas.Pagination;
      }
    | {
        envs: {
          target?:
            | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
            | ('production' | 'preview' | 'development' | 'preview' | 'development');
          type?: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
          id?: string;
          key?: string;
          value?: string;
          configurationId?: string | null;
          createdAt?: number;
          updatedAt?: number;
          createdBy?: string | null;
          updatedBy?: string | null;
          gitBranch?: string;
          edgeConfigId?: string | null;
          edgeConfigTokenId?: string | null;
          /**
           * Whether `value` is decrypted.
           */
          decrypted?: boolean;
          system?: boolean;
        }[];
      },
    FilterProjectEnvsError,
    undefined,
    {},
    FilterProjectEnvsQueryParams,
    FilterProjectEnvsPathParams
  >({ url: '/v9/projects/{idOrName}/env', method: 'get', ...variables, signal });

export type GetProjectEnvPathParams = {
  /**
   * The unique project identifier or the project name
   *
   * @example prj_XLKmu1DyR1eY7zq8UgeRKbA7yVLA
   */
  idOrName: string;
  /**
   * The unique ID for the environment variable to get the decrypted value.
   */
  id: string;
};

export type GetProjectEnvQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetProjectEnvError = Fetcher.ErrorWrapper<undefined>;

export type GetProjectEnvResponse = {
  target?:
    | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
    | ('production' | 'preview' | 'development' | 'preview' | 'development');
  type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
  id?: string;
  key: string;
  value: string;
  configurationId?: string | null;
  createdAt?: number;
  updatedAt?: number;
  createdBy?: string | null;
  updatedBy?: string | null;
  gitBranch?: string;
  edgeConfigId?: string | null;
  edgeConfigTokenId?: string | null;
  /**
   * Whether `value` is decrypted.
   */
  decrypted?: boolean;
};

export type GetProjectEnvVariables = {
  pathParams: GetProjectEnvPathParams;
  queryParams?: GetProjectEnvQueryParams;
} & FetcherExtraProps;

/**
 * Retrieve the environment variable for a given project.
 */
export const getProjectEnv = (variables: GetProjectEnvVariables, signal?: AbortSignal) =>
  fetch<GetProjectEnvResponse, GetProjectEnvError, undefined, {}, GetProjectEnvQueryParams, GetProjectEnvPathParams>({
    url: '/v1/projects/{idOrName}/env/{id}',
    method: 'get',
    ...variables,
    signal
  });

export type CreateProjectEnvPathParams = {
  /**
   * The unique project identifier or the project name
   *
   * @example prj_XLKmu1DyR1eY7zq8UgeRKbA7yVLA
   */
  idOrName: string;
};

export type CreateProjectEnvQueryParams = {
  /**
   * Allow override of environment variable if it already exists
   *
   * @example true
   */
  upsert?: string;
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateProjectEnvError = Fetcher.ErrorWrapper<undefined>;

export type CreateProjectEnvResponse = {
  created:
    | {
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
        type?: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
        id?: string;
        key?: string;
        value?: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
        system?: boolean;
      }
    | {
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
        type?: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
        id?: string;
        key?: string;
        value?: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
        system?: boolean;
      }[];
  failed: {
    error: {
      code: string;
      message: string;
      key?: string;
      envVarId?: string;
      envVarKey?: string;
      action?: string;
      link?: string;
      value?:
        | string
        | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[];
      gitBranch?: string;
      target?:
        | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
        | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
      project?: string;
    };
  }[];
};

export type CreateProjectEnvVariables = {
  body?:
    | {
        /**
         * The name of the environment variable
         *
         * @example API_URL
         */
        key: string;
        /**
         * The value of the environment variable
         *
         * @example https://api.vercel.com
         */
        value: string;
        /**
         * The type of environment variable
         *
         * @example plain
         */
        type: 'system' | 'secret' | 'encrypted' | 'plain' | 'sensitive';
        /**
         * The target environment of the environment variable
         *
         * @example production
         * @example preview
         */
        target: (
          | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Productio'
          | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Previe'
          | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Developmen'
        )[];
        /**
         * The git branch of the environment variable
         *
         * @maxLength 250
         * @example feature-1
         */
        gitBranch?: string | null;
      }
    | {
        /**
         * The name of the environment variable
         *
         * @example API_URL
         */
        key: string;
        /**
         * The value of the environment variable
         *
         * @example https://api.vercel.com
         */
        value: string;
        /**
         * The type of environment variable
         *
         * @example plain
         */
        type: 'system' | 'secret' | 'encrypted' | 'plain' | 'sensitive';
        /**
         * The target environment of the environment variable
         *
         * @example production
         * @example preview
         */
        target: (
          | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Productio'
          | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Previe'
          | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Developmen'
        )[];
        /**
         * The git branch of the environment variable
         *
         * @maxLength 250
         * @example feature-1
         */
        gitBranch?: string | null;
      }[];
  pathParams: CreateProjectEnvPathParams;
  queryParams?: CreateProjectEnvQueryParams;
} & FetcherExtraProps;

/**
 * Create one ore more environment variables for a project by passing its `key`, `value`, `type` and `target` and by specifying the project by either passing the project `id` or `name` in the URL.
 */
export const createProjectEnv = (variables: CreateProjectEnvVariables, signal?: AbortSignal) =>
  fetch<
    CreateProjectEnvResponse,
    CreateProjectEnvError,
    | {
        /**
         * The name of the environment variable
         *
         * @example API_URL
         */
        key: string;
        /**
         * The value of the environment variable
         *
         * @example https://api.vercel.com
         */
        value: string;
        /**
         * The type of environment variable
         *
         * @example plain
         */
        type: 'system' | 'secret' | 'encrypted' | 'plain' | 'sensitive';
        /**
         * The target environment of the environment variable
         *
         * @example production
         * @example preview
         */
        target: (
          | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Productio'
          | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Previe'
          | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Developmen'
        )[];
        /**
         * The git branch of the environment variable
         *
         * @maxLength 250
         * @example feature-1
         */
        gitBranch?: string | null;
      }
    | {
        /**
         * The name of the environment variable
         *
         * @example API_URL
         */
        key: string;
        /**
         * The value of the environment variable
         *
         * @example https://api.vercel.com
         */
        value: string;
        /**
         * The type of environment variable
         *
         * @example plain
         */
        type: 'system' | 'secret' | 'encrypted' | 'plain' | 'sensitive';
        /**
         * The target environment of the environment variable
         *
         * @example production
         * @example preview
         */
        target: (
          | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Productio'
          | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Previe'
          | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Developmen'
        )[];
        /**
         * The git branch of the environment variable
         *
         * @maxLength 250
         * @example feature-1
         */
        gitBranch?: string | null;
      }[],
    {},
    CreateProjectEnvQueryParams,
    CreateProjectEnvPathParams
  >({ url: '/v10/projects/{idOrName}/env', method: 'post', ...variables, signal });

export type RemoveProjectEnvPathParams = {
  /**
   * The unique project identifier or the project name
   *
   * @example prj_XLKmu1DyR1eY7zq8UgeRKbA7yVLA
   */
  idOrName: string;
  /**
   * The unique environment variable identifier
   *
   * @example XMbOEya1gUUO1ir4
   */
  id: string;
};

export type RemoveProjectEnvQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type RemoveProjectEnvError = Fetcher.ErrorWrapper<undefined>;

export type RemoveProjectEnvVariables = {
  pathParams: RemoveProjectEnvPathParams;
  queryParams?: RemoveProjectEnvQueryParams;
} & FetcherExtraProps;

/**
 * Delete a specific environment variable for a given project by passing the environment variable identifier and either passing the project `id` or `name` in the URL.
 */
export const removeProjectEnv = (variables: RemoveProjectEnvVariables, signal?: AbortSignal) =>
  fetch<
    | {
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
        type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
        id?: string;
        key: string;
        value: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
      }[]
    | {
        system?: boolean;
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
        type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
        id?: string;
        key: string;
        value: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
      }
    | {
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
        type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
        id?: string;
        key: string;
        value: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
      },
    RemoveProjectEnvError,
    undefined,
    {},
    RemoveProjectEnvQueryParams,
    RemoveProjectEnvPathParams
  >({ url: '/v9/projects/{idOrName}/env/{id}', method: 'delete', ...variables, signal });

export type EditProjectEnvPathParams = {
  /**
   * The unique project identifier or the project name
   *
   * @example prj_XLKmu1DyR1eY7zq8UgeRKbA7yVLA
   */
  idOrName: string;
  /**
   * The unique environment variable identifier
   *
   * @example XMbOEya1gUUO1ir4
   */
  id: string;
};

export type EditProjectEnvQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type EditProjectEnvError = Fetcher.ErrorWrapper<undefined>;

export type EditProjectEnvResponse = {
  target?:
    | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
    | ('production' | 'preview' | 'development' | 'preview' | 'development');
  type: 'system' | 'encrypted' | 'plain' | 'sensitive' | 'secret';
  id?: string;
  key: string;
  value: string;
  configurationId?: string | null;
  createdAt?: number;
  updatedAt?: number;
  createdBy?: string | null;
  updatedBy?: string | null;
  gitBranch?: string;
  edgeConfigId?: string | null;
  edgeConfigTokenId?: string | null;
  /**
   * Whether `value` is decrypted.
   */
  decrypted?: boolean;
};

export type EditProjectEnvRequestBody = {
  /**
   * The name of the environment variable
   *
   * @example GITHUB_APP_ID
   */
  key?: string;
  /**
   * The target environment of the environment variable
   *
   * @example preview
   */
  target?: (
    | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Productio'
    | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Previe'
    | 'mport("/vercel/path0/utils/env-variable-util/types").EnvTarget.Developmen'
  )[];
  /**
   * The git branch of the environment variable
   *
   * @maxLength 250
   * @example feature-1
   */
  gitBranch?: string | null;
  /**
   * The type of environment variable
   *
   * @example plain
   */
  type?: 'system' | 'secret' | 'encrypted' | 'plain' | 'sensitive';
  /**
   * The value of the environment variable
   *
   * @example bkWIjbnxcvo78
   */
  value?: string;
};

export type EditProjectEnvVariables = {
  body?: EditProjectEnvRequestBody;
  pathParams: EditProjectEnvPathParams;
  queryParams?: EditProjectEnvQueryParams;
} & FetcherExtraProps;

/**
 * Edit a specific environment variable for a given project by passing the environment variable identifier and either passing the project `id` or `name` in the URL.
 */
export const editProjectEnv = (variables: EditProjectEnvVariables, signal?: AbortSignal) =>
  fetch<
    EditProjectEnvResponse,
    EditProjectEnvError,
    EditProjectEnvRequestBody,
    {},
    EditProjectEnvQueryParams,
    EditProjectEnvPathParams
  >({ url: '/v9/projects/{idOrName}/env/{id}', method: 'patch', ...variables, signal });

export type VerifyTokenQueryParams = {
  /**
   * Email to verify the login.
   */
  email?: string;
  /**
   * The token returned when the login was requested.
   */
  token: string;
  /**
   * The desired name for the token. It will be displayed on the user account details.
   *
   * @example Your Client App Name
   */
  tokenName?: string;
  /**
   * The SAML Profile ID, when connecting a SAML Profile to a Team member for the first time.
   */
  ssoUserId?: string;
};

export type VerifyTokenError = Fetcher.ErrorWrapper<undefined>;

export type VerifyTokenResponse = {
  /**
   * The user authentication token that can be used to perform API requests.
   *
   * @example 1ioXyz9Ue4xdCYGROet1dlKd
   */
  token: string;
  /**
   * Email address of the authenticated user.
   *
   * @example amy@example.com
   */
  email: string;
  /**
   * When completing SAML Single Sign-On authentication, this will be the ID of the Team that was authenticated for.
   *
   * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
   */
  teamId?: string;
};

export type VerifyTokenVariables = {
  queryParams: VerifyTokenQueryParams;
} & FetcherExtraProps;

/**
 * Verify the user accepted the login request and get a authentication token. The user email address and the token received after requesting the login must be added to the URL as a query string with the names `email` and `token`.
 */
export const verifyToken = (variables: VerifyTokenVariables, signal?: AbortSignal) =>
  fetch<VerifyTokenResponse, VerifyTokenError, undefined, {}, VerifyTokenQueryParams, {}>({
    url: '/registration/verify',
    method: 'get',
    ...variables,
    signal
  });

export type EmailLoginError = Fetcher.ErrorWrapper<undefined>;

export type EmailLoginResponse = {
  /**
   * The token used to verify the user accepted the login request
   *
   * @example T1dmvPu36nmyYisXAs7IRzcR
   */
  token: string;
  /**
   * The code the user is going to receive on the email. **Must** be displayed to the user so they can verify the request is the correct.
   *
   * @example Practical Saola
   */
  securityCode: string;
};

export type EmailLoginRequestBody = {
  /**
   * The user email.
   *
   * @example user@mail.com
   */
  email: string;
  /**
   * The desired name for the token. It will be displayed on the user account details.
   *
   * @example Your Client App Name
   */
  tokenName?: string;
};

export type EmailLoginVariables = {
  body: EmailLoginRequestBody;
} & FetcherExtraProps;

/**
 * Request a new login for a user to get a token. This will respond with a verification token and send an email to confirm the request. Once confirmed you can use the verification token to get an authentication token.
 */
export const emailLogin = (variables: EmailLoginVariables, signal?: AbortSignal) =>
  fetch<EmailLoginResponse, EmailLoginError, EmailLoginRequestBody, {}, {}, {}>({
    url: '/registration',
    method: 'post',
    ...variables,
    signal
  });

export type GetConfigurationsQueryParams = {
  view: 'account' | 'project';
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetConfigurationsError = Fetcher.ErrorWrapper<undefined>;

export type GetConfigurationsVariables = {
  queryParams: GetConfigurationsQueryParams;
} & FetcherExtraProps;

/**
 * Allows to retrieve all configurations for an authenticated integration. When the `project` view is used, configurations generated for the authorization flow will be filtered out of the results.
 */
export const getConfigurations = (variables: GetConfigurationsVariables, signal?: AbortSignal) =>
  fetch<
    | {
        /**
         * A timestamp that tells you when the configuration was installed successfully
         *
         * @example 1558531915505
         */
        completedAt?: number;
        /**
         * A timestamp that tells you when the configuration was created
         *
         * @example 1558531915505
         */
        createdAt: number;
        /**
         * The unique identifier of the configuration
         *
         * @example icfg_3bwCLgxL8qt5kjRLcv2Dit7F
         */
        id: string;
        /**
         * The unique identifier of the app the configuration was created for
         *
         * @example oac_xzpVzcUOgcB1nrVlirtKhbWV
         */
        integrationId: string;
        /**
         * Will be truthy in those cases where the configuration was created to authorize a client through the OAuth2 flow.
         *
         * @example false
         */
        oauthConfiguration?: boolean;
        /**
         * The user or team ID that owns the configuration
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        ownerId: string;
        /**
         * When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
         *
         * @example prj_xQxbutw1HpL6HLYPAzt5h75m8NjO
         */
        projects?: string[];
        /**
         * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
         *
         * @example marketplace
         */
        source?: 'marketplace' | 'deploy-button' | 'oauth' | 'external';
        removedLogDrainsAt?: number;
        removedProjectEnvsAt?: number;
        removedTokensAt?: number;
        removedWebhooksAt?: number;
        /**
         * The slug of the integration the configuration is created for.
         *
         * @example slack
         */
        slug: string;
        /**
         * When the configuration was created for a team, this will show the ID of the team.
         *
         * @example team_nLlpyC6RE1qxydlFKbrxDlud
         */
        teamId?: string | null;
        type: 'integration-configuration';
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        updatedAt: number;
        /**
         * The ID of the user that created the configuration.
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        userId: string;
        /**
         * The resources that are allowed to be accessed by the configuration.
         *
         * @example read:project
         * @example read-write:log-drain
         */
        scopes: string[];
        scopesQueue?: {
          scopes: {
            added: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
            )[];
            upgraded: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
            )[];
          };
          note: string;
          requestedAt: number;
          confirmedAt?: number;
        }[];
        /**
         * A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
         *
         * @example 1558531915505
         */
        disabledAt?: number;
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        deletedAt?: number | null;
      }[]
    | {
        integration: {
          name: string;
          icon: string;
          category: string;
          isLegacy: boolean;
          flags?: string[];
          assignedBetaLabelAt?: number;
        };
        /**
         * A timestamp that tells you when the configuration was installed successfully
         *
         * @example 1558531915505
         */
        completedAt?: number;
        /**
         * A timestamp that tells you when the configuration was created
         *
         * @example 1558531915505
         */
        createdAt: number;
        /**
         * The unique identifier of the configuration
         *
         * @example icfg_3bwCLgxL8qt5kjRLcv2Dit7F
         */
        id: string;
        /**
         * The unique identifier of the app the configuration was created for
         *
         * @example oac_xzpVzcUOgcB1nrVlirtKhbWV
         */
        integrationId: string;
        /**
         * Will be truthy in those cases where the configuration was created to authorize a client through the OAuth2 flow.
         *
         * @example false
         */
        oauthConfiguration?: boolean;
        /**
         * The user or team ID that owns the configuration
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        ownerId: string;
        /**
         * When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
         *
         * @example prj_xQxbutw1HpL6HLYPAzt5h75m8NjO
         */
        projects?: string[];
        /**
         * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
         *
         * @example marketplace
         */
        source?: 'marketplace' | 'deploy-button' | 'oauth' | 'external';
        removedLogDrainsAt?: number;
        removedProjectEnvsAt?: number;
        removedTokensAt?: number;
        removedWebhooksAt?: number;
        /**
         * The slug of the integration the configuration is created for.
         *
         * @example slack
         */
        slug: string;
        /**
         * When the configuration was created for a team, this will show the ID of the team.
         *
         * @example team_nLlpyC6RE1qxydlFKbrxDlud
         */
        teamId?: string | null;
        type: 'integration-configuration';
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        updatedAt: number;
        /**
         * The ID of the user that created the configuration.
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        userId: string;
        /**
         * The resources that are allowed to be accessed by the configuration.
         *
         * @example read:project
         * @example read-write:log-drain
         */
        scopes: string[];
        scopesQueue?: {
          scopes: {
            added: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
            )[];
            upgraded: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
            )[];
          };
          note: string;
          requestedAt: number;
          confirmedAt?: number;
        }[];
        /**
         * A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
         *
         * @example 1558531915505
         */
        disabledAt?: number;
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        deletedAt?: number | null;
      }[],
    GetConfigurationsError,
    undefined,
    {},
    GetConfigurationsQueryParams,
    {}
  >({ url: '/v1/integrations/configurations', method: 'get', ...variables, signal });

export type GetConfigurationPathParams = {
  /**
   * ID of the configuration to check
   *
   * @example icfg_cuwj0AdCdH3BwWT4LPijCC7t
   */
  id: string;
};

export type GetConfigurationQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetConfigurationError = Fetcher.ErrorWrapper<undefined>;

export type GetConfigurationVariables = {
  pathParams: GetConfigurationPathParams;
  queryParams?: GetConfigurationQueryParams;
} & FetcherExtraProps;

/**
 * Allows to retrieve a the configuration with the provided id in case it exists. The authenticated user or team must be the owner of the config in order to access it.
 */
export const getConfiguration = (variables: GetConfigurationVariables, signal?: AbortSignal) =>
  fetch<
    | {
        /**
         * A timestamp that tells you when the configuration was installed successfully
         *
         * @example 1558531915505
         */
        completedAt?: number;
        /**
         * A timestamp that tells you when the configuration was created
         *
         * @example 1558531915505
         */
        createdAt: number;
        /**
         * The unique identifier of the configuration
         *
         * @example icfg_3bwCLgxL8qt5kjRLcv2Dit7F
         */
        id: string;
        /**
         * The unique identifier of the app the configuration was created for
         *
         * @example oac_xzpVzcUOgcB1nrVlirtKhbWV
         */
        integrationId: string;
        /**
         * Will be truthy in those cases where the configuration was created to authorize a client through the OAuth2 flow.
         *
         * @example false
         */
        oauthConfiguration?: boolean;
        /**
         * The user or team ID that owns the configuration
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        ownerId: string;
        /**
         * When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
         *
         * @example prj_xQxbutw1HpL6HLYPAzt5h75m8NjO
         */
        projects?: string[];
        /**
         * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
         *
         * @example marketplace
         */
        source?: 'marketplace' | 'deploy-button' | 'oauth' | 'external';
        removedLogDrainsAt?: number;
        removedProjectEnvsAt?: number;
        removedTokensAt?: number;
        removedWebhooksAt?: number;
        /**
         * The slug of the integration the configuration is created for.
         *
         * @example slack
         */
        slug: string;
        /**
         * When the configuration was created for a team, this will show the ID of the team.
         *
         * @example team_nLlpyC6RE1qxydlFKbrxDlud
         */
        teamId?: string | null;
        type: 'integration-configuration';
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        updatedAt: number;
        /**
         * The ID of the user that created the configuration.
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        userId: string;
        /**
         * The resources that are allowed to be accessed by the configuration.
         *
         * @example read:project
         * @example read-write:log-drain
         */
        scopes: string[];
        scopesQueue?: {
          scopes: {
            added: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
            )[];
            upgraded: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
            )[];
          };
          note: string;
          requestedAt: number;
          confirmedAt?: number;
        }[];
        /**
         * A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
         *
         * @example 1558531915505
         */
        disabledAt?: number;
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        deletedAt?: number | null;
      }
    | {
        /**
         * A string representing the permission for projects. Possible values are `all` or `selected`.
         *
         * @example all
         */
        projectSelection: 'selected' | 'all';
        /**
         * A timestamp that tells you when the configuration was created
         *
         * @example 1558531915505
         */
        createdAt: number;
        /**
         * A timestamp that tells you when the configuration was installed successfully
         *
         * @example 1558531915505
         */
        completedAt?: number;
        /**
         * The unique identifier of the configuration
         *
         * @example icfg_3bwCLgxL8qt5kjRLcv2Dit7F
         */
        id: string;
        /**
         * The unique identifier of the app the configuration was created for
         *
         * @example oac_xzpVzcUOgcB1nrVlirtKhbWV
         */
        integrationId: string;
        /**
         * Will be truthy in those cases where the configuration was created to authorize a client through the OAuth2 flow.
         *
         * @example false
         */
        oauthConfiguration?: boolean;
        /**
         * The user or team ID that owns the configuration
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        ownerId: string;
        /**
         * When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
         *
         * @example prj_xQxbutw1HpL6HLYPAzt5h75m8NjO
         */
        projects?: string[];
        /**
         * The slug of the integration the configuration is created for.
         *
         * @example slack
         */
        slug: string;
        /**
         * When the configuration was created for a team, this will show the ID of the team.
         *
         * @example team_nLlpyC6RE1qxydlFKbrxDlud
         */
        teamId?: string | null;
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        updatedAt: number;
        /**
         * The ID of the user that created the configuration.
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        userId: string;
        /**
         * The resources that are allowed to be accessed by the configuration.
         *
         * @example read:project
         * @example read-write:log-drain
         */
        scopes: string[];
        /**
         * A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
         *
         * @example 1558531915505
         */
        disabledAt?: number;
        /**
         * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
         *
         * @example marketplace
         */
        source?: 'marketplace' | 'deploy-button' | 'oauth' | 'external';
        canConfigureOpenTelemetry?: boolean;
      },
    GetConfigurationError,
    undefined,
    {},
    GetConfigurationQueryParams,
    GetConfigurationPathParams
  >({ url: '/v1/integrations/configuration/{id}', method: 'get', ...variables, signal });

export type DeleteConfigurationPathParams = {
  id: string;
};

export type DeleteConfigurationQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteConfigurationError = Fetcher.ErrorWrapper<undefined>;

export type DeleteConfigurationVariables = {
  pathParams: DeleteConfigurationPathParams;
  queryParams?: DeleteConfigurationQueryParams;
} & FetcherExtraProps;

/**
 * Allows to remove the configuration with the `id` provided in the parameters. The configuration and all of its resources will be removed. This includes Webhooks, LogDrains and Project Env variables.
 */
export const deleteConfiguration = (variables: DeleteConfigurationVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    DeleteConfigurationError,
    undefined,
    {},
    DeleteConfigurationQueryParams,
    DeleteConfigurationPathParams
  >({ url: '/v1/integrations/configuration/{id}', method: 'delete', ...variables, signal });

export type GetIntegrationLogDrainsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetIntegrationLogDrainsError = Fetcher.ErrorWrapper<undefined>;

export type GetIntegrationLogDrainsResponse = {
  /**
   * The oauth2 client application id that created this log drain
   *
   * @example oac_xRhY4LAB7yLhUADD69EvV7ct
   */
  clientId?: string;
  /**
   * The client configuration this log drain was created with
   *
   * @example icfg_cuwj0AdCdH3BwWT4LPijCC7t
   */
  configurationId?: string;
  /**
   * A timestamp that tells you when the log drain was created
   *
   * @example 1558531915505
   */
  createdAt: number;
  /**
   * The unique identifier of the log drain. Always prefixed with `ld_`
   *
   * @example ld_nBuA7zCID8g4QZ8g
   */
  id: string;
  /**
   * The delivery log format
   *
   * @example json
   */
  deliveryFormat?: 'json' | 'ndjson' | 'syslog';
  /**
   * The name of the log drain
   *
   * @example My first log drain
   */
  name: string;
  /**
   * The identifier of the team or user whose events will trigger the log drain
   *
   * @example kr1PsOIzqEL5Xg6M4VZcZosf
   */
  ownerId: string;
  /**
   * @example AbCgVkqoxXeXCDWehVir51LHGrrcWL4mkYm14W6UBPWQeb
   */
  projectId?: string | null;
  /**
   * The identifier of the projects this log drain is associated with
   *
   * @example AbCgVkqoxXeXCDWehVir51LHGrrcWL4mkYm14W6UBPWQeb
   */
  projectIds?: string[];
  /**
   * The URL to call when logs are generated
   *
   * @example https://example.com/log-drain
   */
  url: string;
  /**
   * The sources from which logs are currently being delivered to this log drain.
   *
   * @example build
   * @example edge
   */
  sources?: ('static' | 'lambda' | 'build' | 'edge' | 'external' | 'deployment')[];
  /**
   * Whether the log drain was created by an integration or by a user
   *
   * @example integration
   */
  createdFrom?: 'self-served' | 'integration';
  /**
   * Construct a type with a set of properties K of type T
   *
   * @example {"Authorization": "Bearer 123"}
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * The environment of log drain
   *
   * @example production
   */
  environment?: 'production' | 'preview';
  /**
   * The branch regexp of log drain
   *
   * @example feature/*
   */
  branch?: string;
}[];

export type GetIntegrationLogDrainsVariables = {
  queryParams?: GetIntegrationLogDrainsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of all Integration log drains that are defined for the authorized account. When using an OAuth2 token, the list is limited to log drains created by the authenticated integration.
 */
export const getIntegrationLogDrains = (variables: GetIntegrationLogDrainsVariables, signal?: AbortSignal) =>
  fetch<
    GetIntegrationLogDrainsResponse,
    GetIntegrationLogDrainsError,
    undefined,
    {},
    GetIntegrationLogDrainsQueryParams,
    {}
  >({ url: '/v2/integrations/log-drains', method: 'get', ...variables, signal });

export type CreateLogDrainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateLogDrainError = Fetcher.ErrorWrapper<undefined>;

export type CreateLogDrainResponse = {
  /**
   * The oauth2 client application id that created this log drain
   *
   * @example oac_xRhY4LAB7yLhUADD69EvV7ct
   */
  clientId?: string;
  /**
   * The client configuration this log drain was created with
   *
   * @example icfg_cuwj0AdCdH3BwWT4LPijCC7t
   */
  configurationId?: string;
  /**
   * A timestamp that tells you when the log drain was created
   *
   * @example 1558531915505
   */
  createdAt: number;
  /**
   * The unique identifier of the log drain. Always prefixed with `ld_`
   *
   * @example ld_nBuA7zCID8g4QZ8g
   */
  id: string;
  /**
   * The delivery log format
   *
   * @example json
   */
  deliveryFormat?: 'json' | 'ndjson' | 'syslog';
  /**
   * The name of the log drain
   *
   * @example My first log drain
   */
  name: string;
  /**
   * The identifier of the team or user whose events will trigger the log drain
   *
   * @example kr1PsOIzqEL5Xg6M4VZcZosf
   */
  ownerId: string;
  /**
   * @example AbCgVkqoxXeXCDWehVir51LHGrrcWL4mkYm14W6UBPWQeb
   */
  projectId?: string | null;
  /**
   * The identifier of the projects this log drain is associated with
   *
   * @example AbCgVkqoxXeXCDWehVir51LHGrrcWL4mkYm14W6UBPWQeb
   */
  projectIds?: string[];
  /**
   * The URL to call when logs are generated
   *
   * @example https://example.com/log-drain
   */
  url: string;
  /**
   * The sources from which logs are currently being delivered to this log drain.
   *
   * @example build
   * @example edge
   */
  sources?: ('static' | 'lambda' | 'build' | 'edge' | 'external' | 'deployment')[];
  /**
   * Whether the log drain was created by an integration or by a user
   *
   * @example integration
   */
  createdFrom?: 'self-served' | 'integration';
  /**
   * Construct a type with a set of properties K of type T
   *
   * @example {"Authorization": "Bearer 123"}
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * The environment of log drain
   *
   * @example production
   */
  environment?: 'preview' | 'production';
  /**
   * The branch regexp of log drain
   *
   * @example feature/*
   */
  branch?: string;
};

export type CreateLogDrainRequestBody = {
  /**
   * The name of the log drain
   *
   * @example My first log drain
   * @maxLength 100
   * @pattern ^[A-z0-9_ -]+$
   */
  name: string;
  /**
   * @minItems 1
   * @maxItems 50
   */
  projectIds?: string[];
  /**
   * A secret to sign log drain notification headers so a consumer can verify their authenticity
   *
   * @example a1Xsfd325fXcs
   * @maxLength 100
   * @pattern ^[A-z0-9_ -]+$
   */
  secret?: string;
  /**
   * The delivery log format
   *
   * @example json
   */
  deliveryFormat?: 'json' | 'ndjson' | 'syslog';
  /**
   * The url where you will receive logs. The protocol must be `https://` or `http://` when type is `json` and `ndjson`, and `syslog+tls:` or `syslog:` when the type is `syslog`.
   *
   * @example https://example.com/log-drain
   * @format uri
   * @pattern ^(https?|syslog\\+tls|syslog)://
   */
  url: string;
  /**
   * @uniqueItems true
   * @minItems 1
   */
  sources?: ('static' | 'lambda' | 'build' | 'edge' | 'external')[];
  /**
   * Headers to be sent together with the request
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * The environment of log drain
   *
   * @example production
   */
  environment?: 'preview' | 'production';
  /**
   * The branch regexp of log drain
   *
   * @example feature/*
   */
  branch?: string;
};

export type CreateLogDrainVariables = {
  body: CreateLogDrainRequestBody;
  queryParams?: CreateLogDrainQueryParams;
} & FetcherExtraProps;

/**
 * Creates an Integration log drain. This endpoint must be called with an OAuth2 client (integration), since log drains are tied to integrations. If it is called with a different token type it will produce a 400 error.
 */
export const createLogDrain = (variables: CreateLogDrainVariables, signal?: AbortSignal) =>
  fetch<CreateLogDrainResponse, CreateLogDrainError, CreateLogDrainRequestBody, {}, CreateLogDrainQueryParams, {}>({
    url: '/v2/integrations/log-drains',
    method: 'post',
    ...variables,
    signal
  });

export type DeleteIntegrationLogDrainPathParams = {
  /**
   * ID of the log drain to be deleted
   */
  id: string;
};

export type DeleteIntegrationLogDrainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteIntegrationLogDrainError = Fetcher.ErrorWrapper<undefined>;

export type DeleteIntegrationLogDrainVariables = {
  pathParams: DeleteIntegrationLogDrainPathParams;
  queryParams?: DeleteIntegrationLogDrainQueryParams;
} & FetcherExtraProps;

/**
 * Deletes the Integration log drain with the provided `id`. When using an OAuth2 Token, the log drain can be deleted only if the integration owns it.
 */
export const deleteIntegrationLogDrain = (variables: DeleteIntegrationLogDrainVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    DeleteIntegrationLogDrainError,
    undefined,
    {},
    DeleteIntegrationLogDrainQueryParams,
    DeleteIntegrationLogDrainPathParams
  >({ url: '/v1/integrations/log-drains/{id}', method: 'delete', ...variables, signal });

export type GitNamespacesQueryParams = {
  provider?: 'github' | 'gitlab' | 'bitbucket';
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GitNamespacesError = Fetcher.ErrorWrapper<undefined>;

export type GitNamespacesResponse = {
  provider: string;
  slug: string;
  id: string | number;
  name?: string;
  ownerType: string;
}[];

export type GitNamespacesVariables = {
  queryParams?: GitNamespacesQueryParams;
} & FetcherExtraProps;

/**
 * Lists git namespaces for a supported provider. Supported providers are `github`, `gitlab` and `bitbucket`. If the provider is not provided, it will try to obtain it from the user that authenticated the request.
 */
export const gitNamespaces = (variables: GitNamespacesVariables, signal?: AbortSignal) =>
  fetch<GitNamespacesResponse, GitNamespacesError, undefined, {}, GitNamespacesQueryParams, {}>({
    url: '/v1/integrations/git-namespaces',
    method: 'get',
    ...variables,
    signal
  });

export type SearchRepoQueryParams = {
  query?: string;
  namespaceId?: void | null;
  provider?: 'github' | 'gitlab' | 'bitbucket';
  installationId?: string;
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type SearchRepoError = Fetcher.ErrorWrapper<undefined>;

export type SearchRepoResponse = {
  gitAccount: {
    provider: 'github' | 'gitlab' | 'bitbucket';
    namespaceId: string | number | null;
  };
  repos: {
    id: string | number;
    name: string;
    slug: string;
    namespace: string;
    private: boolean;
    defaultBranch: string;
    url: string;
    updatedAt: number;
    ownerType: 'team' | 'user';
  }[];
};

export type SearchRepoVariables = {
  queryParams?: SearchRepoQueryParams;
} & FetcherExtraProps;

/**
 * Lists git repositories linked to a namespace `id` for a supported provider. A specific namespace `id` can be obtained via the `git-namespaces`  endpoint. Supported providers are `github`, `gitlab` and `bitbucket`. If the provider or namespace is not provided, it will try to obtain it from the user that authenticated the request.
 */
export const searchRepo = (variables: SearchRepoVariables, signal?: AbortSignal) =>
  fetch<SearchRepoResponse, SearchRepoError, undefined, {}, SearchRepoQueryParams, {}>({
    url: '/v1/integrations/search-repo',
    method: 'get',
    ...variables,
    signal
  });

export type CreateWebhookQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateWebhookError = Fetcher.ErrorWrapper<undefined>;

export type CreateWebhookResponse = {
  /**
   * The webhook secret used to sign the payload
   */
  secret: string;
  /**
   * The webhooks events
   *
   * @example deployment.created
   */
  events: (
    | 'domain.created'
    | 'deployment.created'
    | 'deployment.error'
    | 'deployment.canceled'
    | 'deployment.succeeded'
    | 'deployment.ready'
    | 'deployment.check-rerequested'
    | 'integration-configuration.permission-upgraded'
    | 'integration-configuration.removed'
    | 'integration-configuration.scope-change-confirmed'
    | 'project.created'
    | 'project.removed'
    | 'deployment-checks-completed'
    | 'deployment-ready'
    | 'deployment-prepared'
    | 'deployment-error'
    | 'deployment-check-rerequested'
    | 'deployment-canceled'
    | 'project-created'
    | 'project-removed'
    | 'domain-created'
    | 'deployment'
    | 'integration-configuration-permission-updated'
    | 'integration-configuration-removed'
    | 'integration-configuration-scope-change-confirmed'
  )[];
  /**
   * The webhook id
   *
   * @example account_hook_GflD6EYyo7F4ViYS
   */
  id: string;
  /**
   * A string with the URL of the webhook
   *
   * @example https://my-webhook.com
   */
  url: string;
  /**
   * The unique ID of the team the webhook belongs to
   *
   * @example ZspSRT4ljIEEmMHgoDwKWDei
   */
  ownerId: string;
  /**
   * A number containing the date when the webhook was created in in milliseconds
   *
   * @example 1567024758130
   */
  createdAt: number;
  /**
   * A number containing the date when the webhook was updated in in milliseconds
   *
   * @example 1567024758130
   */
  updatedAt: number;
  /**
   * The ID of the projects the webhook is associated with
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectIds?: string[];
};

export type CreateWebhookRequestBody = {
  /**
   * @format uri
   * @pattern ^https?://
   */
  url: string;
  /**
   * @minItems 1
   */
  events: (
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.DomainCreate'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.DeploymentCreate'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.DeploymentErro'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.DeploymentCancele'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.DeploymentSucceede'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.DeploymentRead'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.DeploymentCheckRerequeste'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.IntegrationConfigurationPermissionUpgrade'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.IntegrationConfigurationRemove'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.IntegrationConfigurationScopeChangeConfirme'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.ProjectCreate'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.ProjectRemove'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.LegacyDeploymentChecksComplete'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.LegacyDeploymentRead'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.LegacyDeploymentPrepare'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.LegacyDeploymentErro'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.LegacyDeploymentCheckRerequeste'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.LegacyDeploymentCancele'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.LegacyProjectCreate'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.LegacyProjectRemove'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.LegacyDomainCreate'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.LegacyDeploymen'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.LegacyIntegrationConfigurationPermissionUpdate'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.LegacyIntegrationConfigurationRemove'
    | 'mport("/vercel/path0/utils/webhooks/webhooks/types").WebhookName.LegacyIntegrationConfigurationScopeChangeConfirme'
  )[];
  /**
   * @minItems 1
   * @maxItems 50
   */
  projectIds?: string[];
};

export type CreateWebhookVariables = {
  body: CreateWebhookRequestBody;
  queryParams?: CreateWebhookQueryParams;
} & FetcherExtraProps;

/**
 * Creates a webhook
 */
export const createWebhook = (variables: CreateWebhookVariables, signal?: AbortSignal) =>
  fetch<CreateWebhookResponse, CreateWebhookError, CreateWebhookRequestBody, {}, CreateWebhookQueryParams, {}>({
    url: '/v1/webhooks',
    method: 'post',
    ...variables,
    signal
  });

export type GetWebhooksQueryParams = {
  /**
   * @pattern ^[a-zA-z0-9_]+$
   */
  projectId?: string;
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetWebhooksError = Fetcher.ErrorWrapper<undefined>;

export type GetWebhooksVariables = {
  queryParams?: GetWebhooksQueryParams;
} & FetcherExtraProps;

/**
 * Get a list of webhooks
 */
export const getWebhooks = (variables: GetWebhooksVariables, signal?: AbortSignal) =>
  fetch<
    | {
        projectsMetadata:
          | {
              id: string;
              name: string;
              framework?:
                | 'blitzjs'
                | 'nextjs'
                | 'gatsby'
                | 'remix'
                | 'astro'
                | 'hexo'
                | 'eleventy'
                | 'docusaurus-2'
                | 'docusaurus'
                | 'preact'
                | 'solidstart'
                | 'dojo'
                | 'ember'
                | 'vue'
                | 'scully'
                | 'ionic-angular'
                | 'angular'
                | 'polymer'
                | 'svelte'
                | 'sveltekit'
                | 'sveltekit-1'
                | 'ionic-react'
                | 'create-react-app'
                | 'gridsome'
                | 'umijs'
                | 'sapper'
                | 'saber'
                | 'stencil'
                | 'nuxtjs'
                | 'redwoodjs'
                | 'hugo'
                | 'jekyll'
                | 'brunch'
                | 'middleman'
                | 'zola'
                | 'hydrogen'
                | 'vite'
                | 'vitepress'
                | 'vuepress'
                | 'parcel'
                | 'sanity'
                | null;
              latestDeployment?: string;
            }[]
          | null;
        /**
         * The webhooks events
         *
         * @example deployment.created
         */
        events: (
          | 'domain.created'
          | 'deployment.created'
          | 'deployment.error'
          | 'deployment.canceled'
          | 'deployment.succeeded'
          | 'deployment.ready'
          | 'deployment.check-rerequested'
          | 'integration-configuration.permission-upgraded'
          | 'integration-configuration.removed'
          | 'integration-configuration.scope-change-confirmed'
          | 'project.created'
          | 'project.removed'
          | 'deployment-checks-completed'
          | 'deployment-ready'
          | 'deployment-prepared'
          | 'deployment-error'
          | 'deployment-check-rerequested'
          | 'deployment-canceled'
          | 'project-created'
          | 'project-removed'
          | 'domain-created'
          | 'deployment'
          | 'integration-configuration-permission-updated'
          | 'integration-configuration-removed'
          | 'integration-configuration-scope-change-confirmed'
        )[];
        /**
         * The webhook id
         *
         * @example account_hook_GflD6EYyo7F4ViYS
         */
        id: string;
        /**
         * A string with the URL of the webhook
         *
         * @example https://my-webhook.com
         */
        url: string;
        /**
         * The unique ID of the team the webhook belongs to
         *
         * @example ZspSRT4ljIEEmMHgoDwKWDei
         */
        ownerId: string;
        /**
         * A number containing the date when the webhook was created in in milliseconds
         *
         * @example 1567024758130
         */
        createdAt: number;
        /**
         * A number containing the date when the webhook was updated in in milliseconds
         *
         * @example 1567024758130
         */
        updatedAt: number;
        /**
         * The ID of the projects the webhook is associated with
         *
         * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
         */
        projectIds?: string[];
      }[]
    | {
        /**
         * The webhooks events
         *
         * @example deployment.created
         */
        events: (
          | 'domain.created'
          | 'deployment.created'
          | 'deployment.error'
          | 'deployment.canceled'
          | 'deployment.succeeded'
          | 'deployment.ready'
          | 'deployment.check-rerequested'
          | 'integration-configuration.permission-upgraded'
          | 'integration-configuration.removed'
          | 'integration-configuration.scope-change-confirmed'
          | 'project.created'
          | 'project.removed'
          | 'deployment-checks-completed'
          | 'deployment-ready'
          | 'deployment-prepared'
          | 'deployment-error'
          | 'deployment-check-rerequested'
          | 'deployment-canceled'
          | 'project-created'
          | 'project-removed'
          | 'domain-created'
          | 'deployment'
          | 'integration-configuration-permission-updated'
          | 'integration-configuration-removed'
          | 'integration-configuration-scope-change-confirmed'
        )[];
        /**
         * The webhook id
         *
         * @example account_hook_GflD6EYyo7F4ViYS
         */
        id: string;
        /**
         * A string with the URL of the webhook
         *
         * @example https://my-webhook.com
         */
        url: string;
        /**
         * The unique ID of the team the webhook belongs to
         *
         * @example ZspSRT4ljIEEmMHgoDwKWDei
         */
        ownerId: string;
        /**
         * A number containing the date when the webhook was created in in milliseconds
         *
         * @example 1567024758130
         */
        createdAt: number;
        /**
         * A number containing the date when the webhook was updated in in milliseconds
         *
         * @example 1567024758130
         */
        updatedAt: number;
        /**
         * The ID of the projects the webhook is associated with
         *
         * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
         */
        projectIds?: string[];
      }[],
    GetWebhooksError,
    undefined,
    {},
    GetWebhooksQueryParams,
    {}
  >({ url: '/v1/webhooks', method: 'get', ...variables, signal });

export type GetWebhookPathParams = {
  id: string;
};

export type GetWebhookQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetWebhookError = Fetcher.ErrorWrapper<undefined>;

export type GetWebhookResponse = {
  /**
   * The webhooks events
   *
   * @example deployment.created
   */
  events: (
    | 'domain.created'
    | 'deployment.created'
    | 'deployment.error'
    | 'deployment.canceled'
    | 'deployment.succeeded'
    | 'deployment.ready'
    | 'deployment.check-rerequested'
    | 'integration-configuration.permission-upgraded'
    | 'integration-configuration.removed'
    | 'integration-configuration.scope-change-confirmed'
    | 'project.created'
    | 'project.removed'
    | 'deployment-checks-completed'
    | 'deployment-ready'
    | 'deployment-prepared'
    | 'deployment-error'
    | 'deployment-check-rerequested'
    | 'deployment-canceled'
    | 'project-created'
    | 'project-removed'
    | 'domain-created'
    | 'deployment'
    | 'integration-configuration-permission-updated'
    | 'integration-configuration-removed'
    | 'integration-configuration-scope-change-confirmed'
  )[];
  /**
   * The webhook id
   *
   * @example account_hook_GflD6EYyo7F4ViYS
   */
  id: string;
  /**
   * A string with the URL of the webhook
   *
   * @example https://my-webhook.com
   */
  url: string;
  /**
   * The unique ID of the team the webhook belongs to
   *
   * @example ZspSRT4ljIEEmMHgoDwKWDei
   */
  ownerId: string;
  /**
   * A number containing the date when the webhook was created in in milliseconds
   *
   * @example 1567024758130
   */
  createdAt: number;
  /**
   * A number containing the date when the webhook was updated in in milliseconds
   *
   * @example 1567024758130
   */
  updatedAt: number;
  /**
   * The ID of the projects the webhook is associated with
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectIds?: string[];
};

export type GetWebhookVariables = {
  pathParams: GetWebhookPathParams;
  queryParams?: GetWebhookQueryParams;
} & FetcherExtraProps;

/**
 * Get a webhook
 */
export const getWebhook = (variables: GetWebhookVariables, signal?: AbortSignal) =>
  fetch<GetWebhookResponse, GetWebhookError, undefined, {}, GetWebhookQueryParams, GetWebhookPathParams>({
    url: '/v1/webhooks/{id}',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteWebhookPathParams = {
  id: string;
};

export type DeleteWebhookQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteWebhookError = Fetcher.ErrorWrapper<undefined>;

export type DeleteWebhookVariables = {
  pathParams: DeleteWebhookPathParams;
  queryParams?: DeleteWebhookQueryParams;
} & FetcherExtraProps;

/**
 * Deletes a webhook
 */
export const deleteWebhook = (variables: DeleteWebhookVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteWebhookError, undefined, {}, DeleteWebhookQueryParams, DeleteWebhookPathParams>({
    url: '/v1/webhooks/{id}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetConfigurableLogDrainPathParams = {
  id: string;
};

export type GetConfigurableLogDrainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetConfigurableLogDrainError = Fetcher.ErrorWrapper<undefined>;

export type GetConfigurableLogDrainResponse = {
  /**
   * The environment to filter logs by
   *
   * @example production
   */
  environment?: 'preview' | 'production';
  /**
   * The branch to filter logs by
   *
   * @example main
   */
  branch?: string;
  /**
   * The ID of the related integration configuration
   */
  configurationId?: string;
  /**
   * Construct a type with a set of properties K of type T
   *
   * @example {"foo":"bar"}
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * The ID of the projects the deployment is associated with
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectIds?: string[];
  /**
   * A number containing the date when the log-drain was created in in milliseconds
   *
   * @example 1567024758130
   */
  createdAt: number;
  /**
   * The log-drain id
   *
   * @example ld_GflD6EYyo7F4ViYS
   */
  id: string;
  /**
   * The unique ID of the team the deployment belongs to
   *
   * @example team_ZspSRT4ljIEEmMHgoDwKWDei
   */
  ownerId: string;
  /**
   * The log-drain defined sources
   *
   * @example lambda
   * @example build
   */
  sources?: ('static' | 'lambda' | 'build' | 'edge' | 'external' | 'deployment')[];
  /**
   * The log-drain defined delivery format
   *
   * @example json
   * @example ndjson
   */
  deliveryFormat: 'json' | 'ndjson' | 'syslog';
  /**
   * A string with the URL of the log-drain
   *
   * @example https://my-log-drain.com
   */
  url: string;
};

export type GetConfigurableLogDrainVariables = {
  pathParams: GetConfigurableLogDrainPathParams;
  queryParams?: GetConfigurableLogDrainQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a Configurable Log Drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be accessed.
 */
export const getConfigurableLogDrain = (variables: GetConfigurableLogDrainVariables, signal?: AbortSignal) =>
  fetch<
    GetConfigurableLogDrainResponse,
    GetConfigurableLogDrainError,
    undefined,
    {},
    GetConfigurableLogDrainQueryParams,
    GetConfigurableLogDrainPathParams
  >({ url: '/v1/log-drains/{id}', method: 'get', ...variables, signal });

export type DeleteConfigurableLogDrainPathParams = {
  id: string;
};

export type DeleteConfigurableLogDrainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteConfigurableLogDrainError = Fetcher.ErrorWrapper<undefined>;

export type DeleteConfigurableLogDrainVariables = {
  pathParams: DeleteConfigurableLogDrainPathParams;
  queryParams?: DeleteConfigurableLogDrainQueryParams;
} & FetcherExtraProps;

/**
 * Deletes a Configurable Log Drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be deleted.
 */
export const deleteConfigurableLogDrain = (variables: DeleteConfigurableLogDrainVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    DeleteConfigurableLogDrainError,
    undefined,
    {},
    DeleteConfigurableLogDrainQueryParams,
    DeleteConfigurableLogDrainPathParams
  >({ url: '/v1/log-drains/{id}', method: 'delete', ...variables, signal });

export type GetConfigurableLogDrainsQueryParams = {
  /**
   * @pattern ^[a-zA-z0-9_]+$
   */
  projectId?: string;
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetConfigurableLogDrainsError = Fetcher.ErrorWrapper<undefined>;

export type GetConfigurableLogDrainsResponse = {
  /**
   * The environment to filter logs by
   *
   * @example production
   */
  environment?: 'preview' | 'production';
  /**
   * The branch to filter logs by
   *
   * @example main
   */
  branch?: string;
  /**
   * The ID of the related integration configuration
   */
  configurationId?: string;
  /**
   * Construct a type with a set of properties K of type T
   *
   * @example {"foo":"bar"}
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * The ID of the projects the deployment is associated with
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectIds?: string[];
  /**
   * A number containing the date when the log-drain was created in in milliseconds
   *
   * @example 1567024758130
   */
  createdAt: number;
  /**
   * The log-drain id
   *
   * @example ld_GflD6EYyo7F4ViYS
   */
  id: string;
  /**
   * The unique ID of the team the deployment belongs to
   *
   * @example team_ZspSRT4ljIEEmMHgoDwKWDei
   */
  ownerId: string;
  /**
   * The log-drain defined sources
   *
   * @example lambda
   * @example build
   */
  sources?: ('static' | 'lambda' | 'build' | 'edge' | 'external' | 'deployment')[];
  /**
   * The log-drain defined delivery format
   *
   * @example json
   * @example ndjson
   */
  deliveryFormat: 'json' | 'ndjson' | 'syslog';
  /**
   * A string with the URL of the log-drain
   *
   * @example https://my-log-drain.com
   */
  url: string;
}[];

export type GetConfigurableLogDrainsVariables = {
  queryParams?: GetConfigurableLogDrainsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of Configurable Log Drains. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be accessed.
 */
export const getConfigurableLogDrains = (variables: GetConfigurableLogDrainsVariables, signal?: AbortSignal) =>
  fetch<
    GetConfigurableLogDrainsResponse,
    GetConfigurableLogDrainsError,
    undefined,
    {},
    GetConfigurableLogDrainsQueryParams,
    {}
  >({ url: '/v1/log-drains', method: 'get', ...variables, signal });

export type CreateConfigurableLogDrainQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateConfigurableLogDrainError = Fetcher.ErrorWrapper<undefined>;

export type CreateConfigurableLogDrainResponse = {
  /**
   * The secret to validate the log-drain payload
   */
  secret?: string;
  /**
   * The environment to filter logs by
   *
   * @example production
   */
  environment?: 'preview' | 'production';
  /**
   * The branch to filter logs by
   *
   * @example main
   */
  branch?: string;
  /**
   * The ID of the related integration configuration
   */
  configurationId?: string;
  /**
   * Construct a type with a set of properties K of type T
   *
   * @example {"foo":"bar"}
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * The ID of the projects the deployment is associated with
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectIds?: string[];
  /**
   * A number containing the date when the log-drain was created in in milliseconds
   *
   * @example 1567024758130
   */
  createdAt: number;
  /**
   * The log-drain id
   *
   * @example ld_GflD6EYyo7F4ViYS
   */
  id: string;
  /**
   * The unique ID of the team the deployment belongs to
   *
   * @example team_ZspSRT4ljIEEmMHgoDwKWDei
   */
  ownerId: string;
  /**
   * The log-drain defined sources
   *
   * @example lambda
   * @example build
   */
  sources?: ('static' | 'lambda' | 'build' | 'edge' | 'external' | 'deployment')[];
  /**
   * The log-drain defined delivery format
   *
   * @example json
   * @example ndjson
   */
  deliveryFormat: 'json' | 'ndjson' | 'syslog';
  /**
   * A string with the URL of the log-drain
   *
   * @example https://my-log-drain.com
   */
  url: string;
};

export type CreateConfigurableLogDrainRequestBody = {
  /**
   * The delivery log format
   *
   * @example json
   */
  deliveryFormat: 'json' | 'ndjson';
  /**
   * The log drain url
   *
   * @format uri
   * @pattern ^(http|https)?://
   */
  url: string;
  /**
   * Headers to be sent together with the request
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * @minItems 1
   * @maxItems 50
   */
  projectIds?: string[];
  /**
   * @uniqueItems true
   * @minItems 1
   */
  sources: ('static' | 'lambda' | 'build' | 'edge' | 'external')[];
  /**
   * The environment of log drain
   *
   * @example production
   */
  environment?: 'preview' | 'production';
  /**
   * The branch regexp of log drain
   *
   * @example feature/*
   */
  branch?: string;
};

export type CreateConfigurableLogDrainVariables = {
  body: CreateConfigurableLogDrainRequestBody;
  queryParams?: CreateConfigurableLogDrainQueryParams;
} & FetcherExtraProps;

/**
 * Creates a configurable log drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed)
 */
export const createConfigurableLogDrain = (variables: CreateConfigurableLogDrainVariables, signal?: AbortSignal) =>
  fetch<
    CreateConfigurableLogDrainResponse,
    CreateConfigurableLogDrainError,
    CreateConfigurableLogDrainRequestBody,
    {},
    CreateConfigurableLogDrainQueryParams,
    {}
  >({ url: '/v1/log-drains', method: 'post', ...variables, signal });

export type GetTeamPathParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetTeamQueryParams = {
  slug?: string;
};

export type GetTeamError = Fetcher.ErrorWrapper<undefined>;

export type GetTeamVariables = {
  pathParams?: GetTeamPathParams;
  queryParams?: GetTeamQueryParams;
} & FetcherExtraProps;

/**
 * Get information for the Team specified by the `teamId` parameter.
 */
export const getTeam = (variables: GetTeamVariables, signal?: AbortSignal) =>
  fetch<Schemas.Team, GetTeamError, undefined, {}, GetTeamQueryParams, GetTeamPathParams>({
    url: '/v2/teams/{teamId}',
    method: 'get',
    ...variables,
    signal
  });

export type PatchTeamPathParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId: string;
};

export type PatchTeamError = Fetcher.ErrorWrapper<undefined>;

export type PatchTeamRequestBody = {
  /**
   * The hash value of an uploaded image.
   *
   * @format regex
   */
  avatar?: string;
  /**
   * A short text that describes the team.
   *
   * @maxLength 140
   * @example Our mission is to make cloud computing accessible to everyone
   */
  description?: string;
  /**
   * @format regex
   * @example example.com
   */
  emailDomain?: string | null;
  /**
   * The name of the team.
   *
   * @maxLength 256
   * @example My Team
   */
  name?: string;
  /**
   * Suffix that will be used for all preview deployments.
   *
   * @format hostname
   * @example example.dev
   */
  previewDeploymentSuffix?: string | null;
  /**
   * Create a new invite code and replace the current one.
   *
   * @example true
   */
  regenerateInviteCode?: boolean;
  saml?: {
    /**
     * Require that members of the team use SAML Single Sign-On.
     *
     * @example true
     */
    enforced?: boolean;
    roles?: {
      [key: string]: 'OWNER' | 'MEMBER' | 'VIEWER' | 'DEVELOPER' | 'BILLING';
    };
  };
  /**
   * A new slug for the team.
   *
   * @example my-team
   */
  slug?: string;
  /**
   * Enable preview comments: one of on, off or default.
   *
   * @example on
   */
  enablePreviewFeedback?: string;
  /**
   * Sensitive environment variable policy: one of on, off or default.
   *
   * @example on
   */
  sensitiveEnvironmentVariablePolicy?: string;
  /**
   * Runs a task that migrates all existing environment variables to sensitive environment variables.
   *
   * @example false
   */
  migrateExistingEnvVariablesToSensitive?: boolean;
  /**
   * Whether or not remote caching is enabled for the team
   */
  remoteCaching?: {
    /**
     * Enable or disable remote caching for the team.
     *
     * @example true
     */
    enabled?: boolean;
  };
};

export type PatchTeamVariables = {
  body?: PatchTeamRequestBody;
  pathParams: PatchTeamPathParams;
} & FetcherExtraProps;

/**
 * Update the information of a Team specified by the `teamId` parameter. The request body should contain the information that will be updated on the Team.
 */
export const patchTeam = (variables: PatchTeamVariables, signal?: AbortSignal) =>
  fetch<Schemas.Team, PatchTeamError, PatchTeamRequestBody, {}, {}, PatchTeamPathParams>({
    url: '/v2/teams/{teamId}',
    method: 'patch',
    ...variables,
    signal
  });

export type GetTeamsQueryParams = {
  /**
   * Maximum number of Teams which may be returned.
   *
   * @example 20
   */
  limit?: number;
  /**
   * Timestamp (in milliseconds) to only include Teams created since then.
   *
   * @example 1540095775951
   */
  since?: number;
  /**
   * Timestamp (in milliseconds) to only include Teams created until then.
   *
   * @example 1540095775951
   */
  until?: number;
};

export type GetTeamsError = Fetcher.ErrorWrapper<undefined>;

export type GetTeamsResponse = {
  teams: (Schemas.Team | Schemas.TeamLimited)[];
  pagination: Schemas.Pagination;
};

export type GetTeamsVariables = {
  queryParams?: GetTeamsQueryParams;
} & FetcherExtraProps;

/**
 * Get a paginated list of all the Teams the authenticated User is a member of.
 */
export const getTeams = (variables: GetTeamsVariables, signal?: AbortSignal) =>
  fetch<GetTeamsResponse, GetTeamsError, undefined, {}, GetTeamsQueryParams, {}>({
    url: '/v2/teams',
    method: 'get',
    ...variables,
    signal
  });

export type CreateTeamError = Fetcher.ErrorWrapper<undefined>;

export type CreateTeamResponse = {
  /**
   * Id of the created team
   *
   * @example team_nLlpyC6RE1qxqglFKbrMxlud
   */
  id: string;
};

export type CreateTeamRequestBody = {
  /**
   * The desired slug for the Team
   *
   * @example a-random-team
   * @maxLength 48
   */
  slug: string;
  /**
   * The desired name for the Team. It will be generated from the provided slug if nothing is provided
   *
   * @example A Random Team
   * @maxLength 256
   */
  name?: string;
};

export type CreateTeamVariables = {
  body: CreateTeamRequestBody;
} & FetcherExtraProps;

/**
 * Create a new Team under your account. You need to send a POST request with the desired Team slug, and optionally the Team name.
 */
export const createTeam = (variables: CreateTeamVariables, signal?: AbortSignal) =>
  fetch<CreateTeamResponse, CreateTeamError, CreateTeamRequestBody, {}, {}, {}>({
    url: '/v1/teams',
    method: 'post',
    ...variables,
    signal
  });

export type DeleteTeamPathParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId: string;
};

export type DeleteTeamError = Fetcher.ErrorWrapper<undefined>;

export type DeleteTeamResponse = {
  /**
   * The ID of the deleted Team
   *
   * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
   */
  id: string;
};

export type DeleteTeamRequestBody = {
  /**
   * Optional array of objects that describe the reason why the team is being deleted.
   */
  reasons?: {
    /**
     * Idenitifier slug of the reason why the team is being deleted.
     */
    slug: string;
    /**
     * Description of the reason why the team is being deleted.
     */
    description: string;
  }[];
};

export type DeleteTeamVariables = {
  body?: DeleteTeamRequestBody;
  pathParams: DeleteTeamPathParams;
} & FetcherExtraProps;

/**
 * Delete a team under your account. You need to send a `DELETE` request with the desired team `id`. An optional array of reasons for deletion may also be sent.
 */
export const deleteTeam = (variables: DeleteTeamVariables, signal?: AbortSignal) =>
  fetch<DeleteTeamResponse, DeleteTeamError, DeleteTeamRequestBody, {}, {}, DeleteTeamPathParams>({
    url: '/v1/teams/{teamId}',
    method: 'delete',
    ...variables,
    signal
  });

export type DeleteTeamInviteCodePathParams = {
  /**
   * The Team invite code ID.
   *
   * @example 2wn2hudbr4chb1ecywo9dvzo7g9sscs6mzcz8htdde0txyom4l
   */
  inviteId: string;
};

export type DeleteTeamInviteCodeError = Fetcher.ErrorWrapper<undefined>;

export type DeleteTeamInviteCodeResponse = {
  /**
   * ID of the team.
   */
  id: string;
};

export type DeleteTeamInviteCodeVariables = {
  pathParams: DeleteTeamInviteCodePathParams;
} & FetcherExtraProps;

/**
 * Delete an active Team invite code.
 */
export const deleteTeamInviteCode = (variables: DeleteTeamInviteCodeVariables, signal?: AbortSignal) =>
  fetch<DeleteTeamInviteCodeResponse, DeleteTeamInviteCodeError, undefined, {}, {}, DeleteTeamInviteCodePathParams>({
    url: '/v1/teams/{teamId}/invites/{inviteId}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetTeamMembersQueryParams = {
  /**
   * Limit how many teams should be returned
   *
   * @example 20
   */
  limit?: number;
  /**
   * Timestamp in milliseconds to only include members added since then.
   *
   * @example 1540095775951
   */
  since?: number;
  /**
   * Timestamp in milliseconds to only include members added until then.
   *
   * @example 1540095775951
   */
  until?: number;
  /**
   * Search team members by their name, username, and email.
   */
  search?: string;
  /**
   * Only return members with the specified team role.
   *
   * @example OWNER
   */
  role?: 'OWNER' | 'MEMBER' | 'DEVELOPER' | 'VIEWER';
  /**
   * Exclude members who belong to the specified project.
   */
  excludeProject?: string;
};

export type GetTeamMembersError = Fetcher.ErrorWrapper<undefined>;

export type GetTeamMembersResponse = {
  members: {
    /**
     * ID of the file for the Avatar of this member.
     *
     * @example 123a6c5209bc3778245d011443644c8d27dc2c50
     */
    avatar?: string;
    /**
     * Boolean that indicates if this member was confirmed by an owner.
     *
     * @example true
     */
    confirmed: boolean;
    /**
     * The email of this member.
     *
     * @example jane.doe@example.com
     */
    email: string;
    /**
     * Information about the GitHub account for this user.
     */
    github?: {
      userId?: number;
      accountId?: string;
      email?: string;
      login?: string;
    };
    /**
     * Information about the GitLab account of this user.
     */
    gitlab?: {
      userId?: number;
      accountId?: string;
      email?: string;
      login?: string;
    };
    /**
     * Information about the Bitbucket account of this user.
     */
    bitbucket?: {
      userId?: number;
      accountId?: string;
      email?: string;
      login?: string;
    };
    /**
     * Role of this user in the team.
     *
     * @example OWNER
     */
    role: 'MEMBER' | 'OWNER' | 'VIEWER' | 'DEVELOPER' | 'BILLING';
    /**
     * The ID of this user.
     *
     * @example zTuNVUXEAvvnNN3IaqinkyMw
     */
    uid: string;
    /**
     * The unique username of this user.
     *
     * @example jane-doe
     */
    username: string;
    /**
     * The name of this user.
     *
     * @example Jane Doe
     */
    name?: string;
    /**
     * Timestamp in milliseconds when this member was added.
     *
     * @example 1588720733602
     */
    createdAt: number;
    /**
     * Timestamp in milliseconds for when this team member was accepted by an owner.
     *
     * @example 1588820733602
     */
    accessRequestedAt?: number;
    /**
     * Map with information about the members origin if they joined by requesting access.
     */
    joinedFrom?: {
      origin:
        | 'import'
        | 'gitlab'
        | 'bitbucket'
        | 'github'
        | 'mail'
        | 'link'
        | 'teams'
        | 'saml'
        | 'dsync'
        | 'feedback'
        | 'organization-teams';
      commitId?: string;
      repoId?: string;
      repoPath?: string;
      gitUserId?: string | number;
      gitUserLogin?: string;
      ssoUserId?: string;
      ssoConnectedAt?: number;
      idpUserId?: string;
      dsyncUserId?: string;
      dsyncConnectedAt?: number;
    };
  }[];
  emailInviteCodes?: {
    id: string;
    email?: string;
    role?: 'MEMBER' | 'OWNER' | 'VIEWER' | 'DEVELOPER' | 'BILLING';
    isDSyncUser: boolean;
    createdAt?: number;
  }[];
  pagination: {
    hasNext: boolean;
    /**
     * Amount of items in the current page.
     *
     * @example 20
     */
    count: number;
    /**
     * Timestamp that must be used to request the next page.
     *
     * @example 1540095775951
     */
    next: number | null;
    /**
     * Timestamp that must be used to request the previous page.
     *
     * @example 1540095775951
     */
    prev: number | null;
  };
};

export type GetTeamMembersVariables = {
  queryParams?: GetTeamMembersQueryParams;
} & FetcherExtraProps;

/**
 * Get a paginated list of team members for the provided team.
 */
export const getTeamMembers = (variables: GetTeamMembersVariables, signal?: AbortSignal) =>
  fetch<GetTeamMembersResponse, GetTeamMembersError, undefined, {}, GetTeamMembersQueryParams, {}>({
    url: '/v2/teams/{teamId}/members',
    method: 'get',
    ...variables,
    signal
  });

export type InviteUserToTeamError = Fetcher.ErrorWrapper<undefined>;

export type InviteUserToTeamResponse = {
  /**
   * The ID of the invited user
   *
   * @example kr1PsOIzqEL5Xg6M4VZcZosf
   */
  uid: string;
  /**
   * The username of the invited user
   *
   * @example john-doe
   */
  username: string;
  /**
   * The email of the invited user
   *
   * @example john@user.co
   */
  email: string;
  /**
   * The role used for the invitation
   *
   * @example MEMBER
   */
  role: string;
};

export type InviteUserToTeamRequestBody = {
  /**
   * The id of the user to invite
   *
   * @example kr1PsOIzqEL5Xg6M4VZcZosf
   */
  uid?: string;
  /**
   * The email address of the user to invite
   *
   * @format email
   * @example john@example.com
   */
  email?: string;
  role?: void;
};

export type InviteUserToTeamVariables = {
  body?: InviteUserToTeamRequestBody;
} & FetcherExtraProps;

/**
 * Invite a user to join the team specified in the URL. The authenticated user needs to be an `OWNER` in order to successfully invoke this endpoint. The user can be specified with an email or an ID. If both email and ID are provided, ID will take priority.
 */
export const inviteUserToTeam = (variables: InviteUserToTeamVariables, signal?: AbortSignal) =>
  fetch<InviteUserToTeamResponse, InviteUserToTeamError, InviteUserToTeamRequestBody, {}, {}, {}>({
    url: '/v1/teams/{teamId}/members',
    method: 'post',
    ...variables,
    signal
  });

export type RequestAccessToTeamError = Fetcher.ErrorWrapper<undefined>;

export type RequestAccessToTeamResponse = {
  teamSlug: string;
  teamName: string;
  confirmed?: boolean;
  joinedFrom?: {
    origin:
      | 'import'
      | 'teams'
      | 'github'
      | 'gitlab'
      | 'bitbucket'
      | 'feedback'
      | 'organization-teams'
      | 'mail'
      | 'link'
      | 'saml'
      | 'dsync';
    commitId?: string;
    repoId?: string;
    repoPath?: string;
    gitUserId?: string | number;
    gitUserLogin?: string;
    ssoUserId?: string;
    ssoConnectedAt?: number;
    idpUserId?: string;
    dsyncUserId?: string;
    dsyncConnectedAt?: number;
  };
  accessRequestedAt?: number;
  github: {
    login?: string;
  } | null;
  gitlab: {
    login?: string;
  } | null;
  bitbucket: {
    login?: string;
  } | null;
};

export type RequestAccessToTeamRequestBody = {
  joinedFrom: {
    /**
     * The origin of the request.
     *
     * @example github
     */
    origin: 'import' | 'teams' | 'github' | 'gitlab' | 'bitbucket' | 'feedback' | 'organization-teams';
    /**
     * The commit sha if the origin is a git provider.
     *
     * @example f498d25d8bd654b578716203be73084b31130cd7
     */
    commitId?: string;
    /**
     * The ID of the repository for the given Git provider.
     *
     * @example 67753070
     */
    repoId?: string;
    /**
     * The path to the repository for the given Git provider.
     *
     * @example jane-doe/example
     */
    repoPath?: string;
    /**
     * The ID of the Git account of the user who requests access.
     *
     * @example 103053343
     */
    gitUserId?: string | number;
    /**
     * The login name for the Git account of the user who requests access.
     *
     * @example jane-doe
     */
    gitUserLogin?: string;
  };
};

export type RequestAccessToTeamVariables = {
  body: RequestAccessToTeamRequestBody;
} & FetcherExtraProps;

/**
 * Request access to a team as a member. An owner has to approve the request. Only 10 users can request access to a team at the same time.
 */
export const requestAccessToTeam = (variables: RequestAccessToTeamVariables, signal?: AbortSignal) =>
  fetch<RequestAccessToTeamResponse, RequestAccessToTeamError, RequestAccessToTeamRequestBody, {}, {}, {}>({
    url: '/v1/teams/{teamId}/request',
    method: 'post',
    ...variables,
    signal
  });

export type GetTeamAccessRequestPathParams = {
  userId?: string;
};

export type GetTeamAccessRequestError = Fetcher.ErrorWrapper<undefined>;

export type GetTeamAccessRequestResponse = {
  /**
   * The slug of the team.
   *
   * @example my-team
   */
  teamSlug: string;
  /**
   * The name of the team.
   *
   * @example My Team
   */
  teamName: string;
  /**
   * Current status of the membership. Will be `true` if confirmed, if pending it'll be `false`.
   *
   * @example false
   */
  confirmed: boolean;
  /**
   * A map that describes the origin from where the user joined.
   */
  joinedFrom: {
    origin:
      | 'import'
      | 'mail'
      | 'link'
      | 'teams'
      | 'github'
      | 'gitlab'
      | 'bitbucket'
      | 'saml'
      | 'dsync'
      | 'feedback'
      | 'organization-teams';
    commitId?: string;
    repoId?: string;
    repoPath?: string;
    gitUserId?: string | number;
    gitUserLogin?: string;
    ssoUserId?: string;
    ssoConnectedAt?: number;
    idpUserId?: string;
    dsyncUserId?: string;
    dsyncConnectedAt?: number;
  };
  /**
   * Timestamp in milliseconds when the user requested access to the team.
   *
   * @example 1588720733602
   */
  accessRequestedAt: number;
  /**
   * Map of the connected GitHub account.
   */
  github: {
    login?: string;
  } | null;
  /**
   * Map of the connected GitLab account.
   */
  gitlab: {
    login?: string;
  } | null;
  /**
   * Map of the connected Bitbucket account.
   */
  bitbucket: {
    login?: string;
  } | null;
};

export type GetTeamAccessRequestVariables = {
  pathParams?: GetTeamAccessRequestPathParams;
} & FetcherExtraProps;

/**
 * Check the status of a join request. It'll respond with a 404 if the request has been declined. If no `userId` path segment was provided, this endpoint will instead return the status of the authenticated user.
 */
export const getTeamAccessRequest = (variables: GetTeamAccessRequestVariables, signal?: AbortSignal) =>
  fetch<GetTeamAccessRequestResponse, GetTeamAccessRequestError, undefined, {}, {}, GetTeamAccessRequestPathParams>({
    url: '/v1/teams/{teamId}/request/{userId}',
    method: 'get',
    ...variables,
    signal
  });

export type JoinTeamError = Fetcher.ErrorWrapper<undefined>;

export type JoinTeamResponse = {
  /**
   * The ID of the team the user joined.
   *
   * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
   */
  teamId: string;
  /**
   * The slug of the team the user joined.
   *
   * @example my-team
   */
  slug: string;
  /**
   * The name of the team the user joined.
   *
   * @example My Team
   */
  name: string;
  /**
   * The origin of how the user joined.
   *
   * @example email
   */
  from: string;
};

export type JoinTeamRequestBody = {
  /**
   * The invite code to join the team.
   *
   * @example fisdh38aejkeivn34nslfore9vjtn4ls
   */
  inviteCode?: string;
  /**
   * The team ID.
   *
   * @example team_3oNwMKqLHqEBh02CTPsrbNbe
   */
  teamId?: string;
};

export type JoinTeamVariables = {
  body?: JoinTeamRequestBody;
} & FetcherExtraProps;

/**
 * Join a team with a provided invite code or team ID.
 */
export const joinTeam = (variables: JoinTeamVariables, signal?: AbortSignal) =>
  fetch<JoinTeamResponse, JoinTeamError, JoinTeamRequestBody, {}, {}, {}>({
    url: '/v1/teams/{teamId}/members/teams/join',
    method: 'post',
    ...variables,
    signal
  });

export type UpdateTeamMemberPathParams = {
  /**
   * The ID of the member.
   *
   * @example ndfasllgPyCtREAqxxdyFKb
   */
  uid: string;
};

export type UpdateTeamMemberError = Fetcher.ErrorWrapper<undefined>;

export type UpdateTeamMemberResponse = {
  /**
   * ID of the team.
   */
  id: string;
};

export type UpdateTeamMemberRequestBody = {
  /**
   * Accept a user who requested access to the team.
   *
   * @example true
   */
  confirmed?: true;
  /**
   * The role in the team of the member.
   *
   * @default MEMBER
   * @default VIEWER
   * @example MEMBER
   * @example VIEWER
   */
  role?: string;
  joinedFrom?: {
    ssoUserId?: null;
  };
};

export type UpdateTeamMemberVariables = {
  body?: UpdateTeamMemberRequestBody;
  pathParams: UpdateTeamMemberPathParams;
} & FetcherExtraProps;

/**
 * Update the membership of a Team Member on the Team specified by `teamId`, such as changing the _role_ of the member, or confirming a request to join the Team for an unconfirmed member. The authenticated user must be an `OWNER` of the Team.
 */
export const updateTeamMember = (variables: UpdateTeamMemberVariables, signal?: AbortSignal) =>
  fetch<
    UpdateTeamMemberResponse,
    UpdateTeamMemberError,
    UpdateTeamMemberRequestBody,
    {},
    {},
    UpdateTeamMemberPathParams
  >({ url: '/v1/teams/{teamId}/members/{uid}', method: 'patch', ...variables, signal });

export type RemoveTeamMemberPathParams = {
  /**
   * The user ID of the member.
   *
   * @example ndlgr43fadlPyCtREAqxxdyFK
   */
  uid: string;
};

export type RemoveTeamMemberError = Fetcher.ErrorWrapper<undefined>;

export type RemoveTeamMemberResponse = {
  /**
   * ID of the team.
   */
  id: string;
};

export type RemoveTeamMemberVariables = {
  pathParams: RemoveTeamMemberPathParams;
} & FetcherExtraProps;

/**
 * Remove a Team Member from the Team, or dismiss a user that requested access, or leave a team.
 */
export const removeTeamMember = (variables: RemoveTeamMemberVariables, signal?: AbortSignal) =>
  fetch<RemoveTeamMemberResponse, RemoveTeamMemberError, undefined, {}, {}, RemoveTeamMemberPathParams>({
    url: '/v1/teams/{teamId}/members/{uid}',
    method: 'delete',
    ...variables,
    signal
  });

export type ListDeploymentFilesPathParams = {
  /**
   * The unique deployment identifier
   */
  id: string;
};

export type ListDeploymentFilesQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type ListDeploymentFilesError = Fetcher.ErrorWrapper<undefined>;

export type ListDeploymentFilesResponse = Schemas.FileTree[];

export type ListDeploymentFilesVariables = {
  pathParams: ListDeploymentFilesPathParams;
  queryParams?: ListDeploymentFilesQueryParams;
} & FetcherExtraProps;

/**
 * Allows to retrieve the file structure of a deployment by supplying the deployment unique identifier.
 */
export const listDeploymentFiles = (variables: ListDeploymentFilesVariables, signal?: AbortSignal) =>
  fetch<
    ListDeploymentFilesResponse,
    ListDeploymentFilesError,
    undefined,
    {},
    ListDeploymentFilesQueryParams,
    ListDeploymentFilesPathParams
  >({ url: '/v6/deployments/{id}/files', method: 'get', ...variables, signal });

export type GetDeploymentFileContentsPathParams = {
  /**
   * The unique deployment identifier
   */
  id: string;
  /**
   * The unique file identifier
   */
  fileId: string;
};

export type GetDeploymentFileContentsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetDeploymentFileContentsError = Fetcher.ErrorWrapper<undefined>;

export type GetDeploymentFileContentsVariables = {
  pathParams: GetDeploymentFileContentsPathParams;
  queryParams?: GetDeploymentFileContentsQueryParams;
} & FetcherExtraProps;

/**
 * Allows to retrieve the content of a file by supplying the file identifier and the deployment unique identifier. The response body will contain the raw content of the file.
 */
export const getDeploymentFileContents = (variables: GetDeploymentFileContentsVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    GetDeploymentFileContentsError,
    undefined,
    {},
    GetDeploymentFileContentsQueryParams,
    GetDeploymentFileContentsPathParams
  >({ url: '/v6/deployments/{id}/files/{fileId}', method: 'get', ...variables, signal });

export type ListDeploymentBuildsPathParams = {
  /**
   * The deployment unique identifier
   */
  deploymentId: string;
};

export type ListDeploymentBuildsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type ListDeploymentBuildsError = Fetcher.ErrorWrapper<undefined>;

export type ListDeploymentBuildsResponse = {
  builds: {
    /**
     * The unique identifier of the Build
     *
     * @example bld_q5fj68jh7eewfe8
     */
    id: string;
    /**
     * The unique identifier of the deployment
     *
     * @example dpl_BRGyoU2Jzzwx7myBnqv3xjRDD2GnHTwUWyFybnrUvjDD
     */
    deploymentId: string;
    /**
     * The entrypoint of the deployment
     *
     * @example api/index.js
     */
    entrypoint: string;
    /**
     * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
     *
     * @example READY
     */
    readyState:
      | 'BUILDING'
      | 'ERROR'
      | 'INITIALIZING'
      | 'QUEUED'
      | 'READY'
      | 'CANCELED'
      | 'UPLOADING'
      | 'DEPLOYING'
      | 'ARCHIVED';
    /**
     * The time at which the Build state was last modified
     *
     * @example 1567024758130
     */
    readyStateAt?: number;
    /**
     * The time at which the Build was scheduled to be built
     *
     * @example 1567024756543
     */
    scheduledAt?: number | null;
    /**
     * The time at which the Build was created
     *
     * @example 1567071524208
     */
    createdAt?: number;
    /**
     * The time at which the Build was deployed
     *
     * @example 1567071598563
     */
    deployedAt?: number;
    /**
     * The region where the Build was first created
     *
     * @example sfo1
     */
    createdIn?: string;
    /**
     * The Runtime the Build used to generate the output
     *
     * @example @vercel/node
     */
    use?: string;
    /**
     * An object that contains the Build's configuration
     *
     * @example {"zeroConfig":true}
     */
    config?: {
      distDir?: string;
      forceBuildIn?: string;
      reuseWorkPathFrom?: string;
      zeroConfig?: boolean;
    };
    /**
     * A list of outputs for the Build that can be either Serverless Functions or static files
     */
    output: {
      /**
       * The type of the output
       */
      type?: 'lambda' | 'file' | 'edge';
      /**
       * The absolute path of the file or Serverless Function
       */
      path: string;
      /**
       * The SHA1 of the file
       */
      digest: string;
      /**
       * The POSIX file permissions
       */
      mode: number;
      /**
       * The size of the file in bytes
       */
      size?: number;
      /**
       * If the output is a Serverless Function, an object containing the name, location and memory size of the function
       */
      lambda?: {
        functionName: string;
        deployedTo: string[];
        memorySize?: number;
        timeout?: number;
        layers?: string[];
      } | null;
      /**
       * Exists if the output is an edge function.
       */
      edge?: {
        /**
         * The regions where the edge function will be invoked. Only exists if the edge function as a regional edge function, see: https://vercel.com/docs/concepts/edge-network/regions#setting-edge-function-regions
         */
        regions: string[] | null;
      } | null;
    }[];
    /**
     * If the Build uses the `@vercel/static` Runtime, it contains a hashed string of all outputs
     *
     * @example null
     */
    fingerprint?: string | null;
    copiedFrom?: string;
  }[];
};

export type ListDeploymentBuildsVariables = {
  pathParams: ListDeploymentBuildsPathParams;
  queryParams?: ListDeploymentBuildsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves the list of builds given their deployment's unique identifier.
 */
export const listDeploymentBuilds = (variables: ListDeploymentBuildsVariables, signal?: AbortSignal) =>
  fetch<
    ListDeploymentBuildsResponse,
    ListDeploymentBuildsError,
    undefined,
    {},
    ListDeploymentBuildsQueryParams,
    ListDeploymentBuildsPathParams
  >({ url: '/v11/deployments/{deploymentId}/builds', method: 'get', ...variables, signal });

export type CreateCheckPathParams = {
  /**
   * The deployment to create the check for.
   *
   * @example dpl_2qn7PZrx89yxY34vEZPD31Y9XVj6
   */
  deploymentId: string;
};

export type CreateCheckQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateCheckError = Fetcher.ErrorWrapper<undefined>;

export type CreateCheckResponse = {
  createdAt?: number | null;
  creator: string;
  domain: string;
  id: string;
  name: string;
  recordType: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
  ttl?: number;
  type: 'record' | 'record-sys';
  value: string;
};

export type CreateCheckRequestBody = {
  /**
   * The name of the check being created
   *
   * @maxLength 100
   * @example Performance Check
   */
  name: string;
  /**
   * Path of the page that is being checked
   *
   * @maxLength 255
   * @example /
   */
  path?: string;
  /**
   * Whether the check should block a deployment from succeeding
   *
   * @example true
   */
  blocking: boolean;
  /**
   * URL to display for further details
   *
   * @example http://example.com
   */
  detailsUrl?: string;
  /**
   * An identifier that can be used as an external reference
   *
   * @example 1234abc
   */
  externalId?: string;
  /**
   * Whether a user should be able to request for the check to be rerun if it fails
   *
   * @example true
   */
  rerequestable?: boolean;
};

export type CreateCheckVariables = {
  body: CreateCheckRequestBody;
  pathParams: CreateCheckPathParams;
  queryParams?: CreateCheckQueryParams;
} & FetcherExtraProps;

/**
 * Creates a new check. This endpoint must be called with an OAuth2 or it will produce a 400 error.
 */
export const createCheck = (variables: CreateCheckVariables, signal?: AbortSignal) =>
  fetch<
    CreateCheckResponse,
    CreateCheckError,
    CreateCheckRequestBody,
    {},
    CreateCheckQueryParams,
    CreateCheckPathParams
  >({ url: '/v1/deployments/{deploymentId}/checks', method: 'post', ...variables, signal });

export type GetAllChecksPathParams = {
  /**
   * The deployment to get all checks for
   *
   * @example dpl_2qn7PZrx89yxY34vEZPD31Y9XVj6
   */
  deploymentId: string;
};

export type GetAllChecksQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetAllChecksError = Fetcher.ErrorWrapper<undefined>;

export type GetAllChecksResponse = {
  checks: {
    completedAt?: number;
    conclusion?: 'canceled' | 'failed' | 'neutral' | 'succeeded' | 'skipped' | 'stale';
    createdAt: number;
    detailsUrl?: string;
    id: string;
    integrationId: string;
    name: string;
    output?: {
      metrics?: {
        FCP: {
          value: number | null;
          previousValue?: number;
          source: 'web-vitals';
        };
        LCP: {
          value: number | null;
          previousValue?: number;
          source: 'web-vitals';
        };
        CLS: {
          value: number | null;
          previousValue?: number;
          source: 'web-vitals';
        };
        TBT: {
          value: number | null;
          previousValue?: number;
          source: 'web-vitals';
        };
        virtualExperienceScore?: {
          value: number | null;
          previousValue?: number;
          source: 'web-vitals';
        };
      };
    };
    path?: string;
    rerequestable: boolean;
    startedAt?: number;
    status: 'registered' | 'running' | 'completed';
    updatedAt: number;
  }[];
};

export type GetAllChecksVariables = {
  pathParams: GetAllChecksPathParams;
  queryParams?: GetAllChecksQueryParams;
} & FetcherExtraProps;

/**
 * List all of the checks created for a deployment.
 */
export const getAllChecks = (variables: GetAllChecksVariables, signal?: AbortSignal) =>
  fetch<GetAllChecksResponse, GetAllChecksError, undefined, {}, GetAllChecksQueryParams, GetAllChecksPathParams>({
    url: '/v1/deployments/{deploymentId}/checks',
    method: 'get',
    ...variables,
    signal
  });

export type GetCheckPathParams = {
  /**
   * The deployment to get the check for.
   *
   * @example dpl_2qn7PZrx89yxY34vEZPD31Y9XVj6
   */
  deploymentId: string;
  /**
   * The check to fetch
   *
   * @example check_2qn7PZrx89yxY34vEZPD31Y9XVj6
   */
  checkId: string;
};

export type GetCheckQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetCheckError = Fetcher.ErrorWrapper<undefined>;

export type GetCheckResponse = {
  createdAt?: number | null;
  creator: string;
  domain: string;
  id: string;
  name: string;
  recordType: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
  ttl?: number;
  type: 'record' | 'record-sys';
  value: string;
};

export type GetCheckVariables = {
  pathParams: GetCheckPathParams;
  queryParams?: GetCheckQueryParams;
} & FetcherExtraProps;

/**
 * Return a detailed response for a single check.
 */
export const getCheck = (variables: GetCheckVariables, signal?: AbortSignal) =>
  fetch<GetCheckResponse, GetCheckError, undefined, {}, GetCheckQueryParams, GetCheckPathParams>({
    url: '/v1/deployments/{deploymentId}/checks/{checkId}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateCheckPathParams = {
  /**
   * The deployment to update the check for.
   *
   * @example dpl_2qn7PZrx89yxY34vEZPD31Y9XVj6
   */
  deploymentId: string;
  /**
   * The check being updated
   *
   * @example check_2qn7PZrx89yxY34vEZPD31Y9XVj6
   */
  checkId: string;
};

export type UpdateCheckQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type UpdateCheckError = Fetcher.ErrorWrapper<undefined>;

export type UpdateCheckResponse = {
  createdAt?: number | null;
  creator: string;
  domain: string;
  id: string;
  name: string;
  recordType: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
  ttl?: number;
  type: 'record' | 'record-sys';
  value: string;
};

export type UpdateCheckRequestBody = {
  /**
   * The name of the check being created
   *
   * @maxLength 100
   * @example Performance Check
   */
  name?: string;
  /**
   * Path of the page that is being checked
   *
   * @maxLength 255
   * @example /
   */
  path?: string;
  /**
   * The current status of the check
   */
  status?: 'running' | 'completed';
  /**
   * The result of the check being run
   */
  conclusion?: 'canceled' | 'failed' | 'neutral' | 'succeeded' | 'skipped';
  /**
   * A URL a user may visit to see more information about the check
   *
   * @example https://example.com/check/run/1234abc
   */
  detailsUrl?: string;
  /**
   * The results of the check Run
   */
  output?: {
    /**
     * Metrics about the page
     */
    metrics?: {
      FCP: {
        /**
         * First Contentful Paint value
         *
         * @example 1200
         */
        value: number | null;
        /**
         * Previous First Contentful Paint value to display a delta
         *
         * @example 900
         */
        previousValue?: number;
        source: 'web-vitals';
      };
      LCP: {
        /**
         * Largest Contentful Paint value
         *
         * @example 1200
         */
        value: number | null;
        /**
         * Previous Largest Contentful Paint value to display a delta
         *
         * @example 1000
         */
        previousValue?: number;
        source: 'web-vitals';
      };
      CLS: {
        /**
         * Cumulative Layout Shift value
         *
         * @example 4
         */
        value: number | null;
        /**
         * Previous Cumulative Layout Shift value to display a delta
         *
         * @example 2
         */
        previousValue?: number;
        source: 'web-vitals';
      };
      TBT: {
        /**
         * Total Blocking Time value
         *
         * @example 3000
         */
        value: number | null;
        /**
         * Previous Total Blocking Time value to display a delta
         *
         * @example 3500
         */
        previousValue?: number;
        source: 'web-vitals';
      };
      virtualExperienceScore?: {
        /**
         * The calculated Virtual Experience Score value, between 0 and 100
         *
         * @maximum 100
         * @minimum 0
         * @example 30
         */
        value: number | null;
        /**
         * A previous Virtual Experience Score value to display a delta, between 0 and 100
         *
         * @maximum 100
         * @minimum 0
         * @example 35
         */
        previousValue?: number;
        source: 'web-vitals';
      };
    };
  };
  /**
   * An identifier that can be used as an external reference
   *
   * @example 1234abc
   */
  externalId?: string;
};

export type UpdateCheckVariables = {
  body?: UpdateCheckRequestBody;
  pathParams: UpdateCheckPathParams;
  queryParams?: UpdateCheckQueryParams;
} & FetcherExtraProps;

/**
 * Update an existing check. This endpoint must be called with an OAuth2 or it will produce a 400 error.
 */
export const updateCheck = (variables: UpdateCheckVariables, signal?: AbortSignal) =>
  fetch<
    UpdateCheckResponse,
    UpdateCheckError,
    UpdateCheckRequestBody,
    {},
    UpdateCheckQueryParams,
    UpdateCheckPathParams
  >({ url: '/v1/deployments/{deploymentId}/checks/{checkId}', method: 'patch', ...variables, signal });

export type RerequestCheckPathParams = {
  /**
   * The deployment to rerun the check for.
   *
   * @example dpl_2qn7PZrx89yxY34vEZPD31Y9XVj6
   */
  deploymentId: string;
  /**
   * The check to rerun
   *
   * @example check_2qn7PZrx89yxY34vEZPD31Y9XVj6
   */
  checkId: string;
};

export type RerequestCheckQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type RerequestCheckError = Fetcher.ErrorWrapper<undefined>;

export type RerequestCheckVariables = {
  pathParams: RerequestCheckPathParams;
  queryParams?: RerequestCheckQueryParams;
} & FetcherExtraProps;

/**
 * Rerequest a selected check that has failed.
 */
export const rerequestCheck = (variables: RerequestCheckVariables, signal?: AbortSignal) =>
  fetch<Record<string, any>, RerequestCheckError, undefined, {}, RerequestCheckQueryParams, RerequestCheckPathParams>({
    url: '/v1/deployments/{deploymentId}/checks/{checkId}/rerequest',
    method: 'post',
    ...variables,
    signal
  });

export type GetEdgeConfigsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetEdgeConfigsError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigsResponse = {
  createdAt?: number | null;
  creator?: string;
  domain?: string;
  id?: string;
  name?: string;
  recordType?: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
  ttl?: number;
  type?: 'record' | 'record-sys';
  value?: string;
  sizeInBytes: number;
  itemCount: number;
};

export type GetEdgeConfigsVariables = {
  queryParams?: GetEdgeConfigsQueryParams;
} & FetcherExtraProps;

/**
 * Returns all Edge Configs.
 */
export const getEdgeConfigs = (variables: GetEdgeConfigsVariables, signal?: AbortSignal) =>
  fetch<GetEdgeConfigsResponse, GetEdgeConfigsError, undefined, {}, GetEdgeConfigsQueryParams, {}>({
    url: '/v1/edge-config',
    method: 'get',
    ...variables,
    signal
  });

export type CreateEdgeConfigQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateEdgeConfigError = Fetcher.ErrorWrapper<undefined>;

export type CreateEdgeConfigResponse = {
  createdAt?: number | null;
  creator?: string;
  domain?: string;
  id?: string;
  name?: string;
  recordType?: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
  ttl?: number;
  type?: 'record' | 'record-sys';
  value?: string;
  sizeInBytes: number;
  itemCount: number;
};

export type CreateEdgeConfigRequestBody = {
  /**
   * @maxLength 32
   * @pattern ^[\\w-]+$
   */
  slug: string;
  items?: {
    [key: string]:
      | (string | number | boolean | null | Record<string, any>)
      | (string | number | boolean | null | Record<string, any>)[];
  };
};

export type CreateEdgeConfigVariables = {
  body: CreateEdgeConfigRequestBody;
  queryParams?: CreateEdgeConfigQueryParams;
} & FetcherExtraProps;

/**
 * Creates an Edge Config.
 */
export const createEdgeConfig = (variables: CreateEdgeConfigVariables, signal?: AbortSignal) =>
  fetch<
    CreateEdgeConfigResponse,
    CreateEdgeConfigError,
    CreateEdgeConfigRequestBody,
    {},
    CreateEdgeConfigQueryParams,
    {}
  >({ url: '/v1/edge-config', method: 'post', ...variables, signal });

export type GetEdgeConfigPathParams = {
  edgeConfigId: string;
};

export type GetEdgeConfigQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetEdgeConfigError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigResponse = {
  createdAt?: number | null;
  creator?: string;
  domain?: string;
  id?: string;
  name?: string;
  recordType?: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
  ttl?: number;
  type?: 'record' | 'record-sys';
  value?: string;
  sizeInBytes: number;
  itemCount: number;
};

export type GetEdgeConfigVariables = {
  pathParams: GetEdgeConfigPathParams;
  queryParams?: GetEdgeConfigQueryParams;
} & FetcherExtraProps;

/**
 * Returns an Edge Config.
 */
export const getEdgeConfig = (variables: GetEdgeConfigVariables, signal?: AbortSignal) =>
  fetch<GetEdgeConfigResponse, GetEdgeConfigError, undefined, {}, GetEdgeConfigQueryParams, GetEdgeConfigPathParams>({
    url: '/v1/edge-config/{edgeConfigId}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateEdgeConfigPathParams = {
  edgeConfigId: string;
};

export type UpdateEdgeConfigQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type UpdateEdgeConfigError = Fetcher.ErrorWrapper<undefined>;

export type UpdateEdgeConfigResponse = {
  createdAt?: number | null;
  creator?: string;
  domain?: string;
  id?: string;
  name?: string;
  recordType?: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'MX' | 'SRV' | 'TXT' | 'NS';
  ttl?: number;
  type?: 'record' | 'record-sys';
  value?: string;
  sizeInBytes: number;
  itemCount: number;
};

export type UpdateEdgeConfigRequestBody = {
  /**
   * @maxLength 32
   * @pattern ^[\\w-]+$
   */
  slug: string;
};

export type UpdateEdgeConfigVariables = {
  body: UpdateEdgeConfigRequestBody;
  pathParams: UpdateEdgeConfigPathParams;
  queryParams?: UpdateEdgeConfigQueryParams;
} & FetcherExtraProps;

/**
 * Updates an Edge Config.
 */
export const updateEdgeConfig = (variables: UpdateEdgeConfigVariables, signal?: AbortSignal) =>
  fetch<
    UpdateEdgeConfigResponse,
    UpdateEdgeConfigError,
    UpdateEdgeConfigRequestBody,
    {},
    UpdateEdgeConfigQueryParams,
    UpdateEdgeConfigPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}', method: 'put', ...variables, signal });

export type DeleteEdgeConfigPathParams = {
  edgeConfigId: string;
};

export type DeleteEdgeConfigQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteEdgeConfigError = Fetcher.ErrorWrapper<undefined>;

export type DeleteEdgeConfigVariables = {
  pathParams: DeleteEdgeConfigPathParams;
  queryParams?: DeleteEdgeConfigQueryParams;
} & FetcherExtraProps;

/**
 * Delete an Edge Config by id.
 */
export const deleteEdgeConfig = (variables: DeleteEdgeConfigVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteEdgeConfigError, undefined, {}, DeleteEdgeConfigQueryParams, DeleteEdgeConfigPathParams>({
    url: '/v1/edge-config/{edgeConfigId}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetEdgeConfigItemsPathParams = {
  edgeConfigId: string;
};

export type GetEdgeConfigItemsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetEdgeConfigItemsError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigItemsVariables = {
  pathParams: GetEdgeConfigItemsPathParams;
  queryParams?: GetEdgeConfigItemsQueryParams;
} & FetcherExtraProps;

/**
 * Returns all items of an Edge Config.
 */
export const getEdgeConfigItems = (variables: GetEdgeConfigItemsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.EdgeConfigItem,
    GetEdgeConfigItemsError,
    undefined,
    {},
    GetEdgeConfigItemsQueryParams,
    GetEdgeConfigItemsPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}/items', method: 'get', ...variables, signal });

export type PatchtEdgeConfigItemsPathParams = {
  edgeConfigId: string;
};

export type PatchtEdgeConfigItemsQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type PatchtEdgeConfigItemsError = Fetcher.ErrorWrapper<undefined>;

export type PatchtEdgeConfigItemsResponse = {
  status: string;
};

export type PatchtEdgeConfigItemsRequestBody = {
  items: (
    | {
        operation: void | void | void;
        /**
         * @maxLength 256
         * @pattern ^[\\w-]+$
         */
        key: string;
        value:
          | (string | number | boolean | null | Record<string, any>)
          | (string | number | boolean | null | Record<string, any>)[];
      }
    | {
        operation: void;
        /**
         * @maxLength 256
         * @pattern ^[\\w-]+$
         */
        key: string;
      }
  )[];
};

export type PatchtEdgeConfigItemsVariables = {
  body: PatchtEdgeConfigItemsRequestBody;
  pathParams: PatchtEdgeConfigItemsPathParams;
  queryParams?: PatchtEdgeConfigItemsQueryParams;
} & FetcherExtraProps;

/**
 * Update multiple Edge Config Items in batch.
 */
export const patchtEdgeConfigItems = (variables: PatchtEdgeConfigItemsVariables, signal?: AbortSignal) =>
  fetch<
    PatchtEdgeConfigItemsResponse,
    PatchtEdgeConfigItemsError,
    PatchtEdgeConfigItemsRequestBody,
    {},
    PatchtEdgeConfigItemsQueryParams,
    PatchtEdgeConfigItemsPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}/items', method: 'patch', ...variables, signal });

export type GetEdgeConfigItemPathParams = {
  edgeConfigId: string;
  edgeConfigItemKey: string;
};

export type GetEdgeConfigItemQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetEdgeConfigItemError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigItemVariables = {
  pathParams: GetEdgeConfigItemPathParams;
  queryParams?: GetEdgeConfigItemQueryParams;
} & FetcherExtraProps;

/**
 * Returns a specific Edge Config Item.
 */
export const getEdgeConfigItem = (variables: GetEdgeConfigItemVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.EdgeConfigItem,
    GetEdgeConfigItemError,
    undefined,
    {},
    GetEdgeConfigItemQueryParams,
    GetEdgeConfigItemPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}/item/{edgeConfigItemKey}', method: 'get', ...variables, signal });

export type GetEdgeConfigTokensPathParams = {
  edgeConfigId: string;
};

export type GetEdgeConfigTokensQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetEdgeConfigTokensError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigTokensVariables = {
  pathParams: GetEdgeConfigTokensPathParams;
  queryParams?: GetEdgeConfigTokensQueryParams;
} & FetcherExtraProps;

/**
 * Returns all tokens of an Edge Config.
 */
export const getEdgeConfigTokens = (variables: GetEdgeConfigTokensVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.EdgeConfigToken,
    GetEdgeConfigTokensError,
    undefined,
    {},
    GetEdgeConfigTokensQueryParams,
    GetEdgeConfigTokensPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}/tokens', method: 'get', ...variables, signal });

export type DeleteEdgeConfigTokensPathParams = {
  edgeConfigId: string;
};

export type DeleteEdgeConfigTokensQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type DeleteEdgeConfigTokensError = Fetcher.ErrorWrapper<undefined>;

export type DeleteEdgeConfigTokensRequestBody = {
  tokens: string[];
};

export type DeleteEdgeConfigTokensVariables = {
  body: DeleteEdgeConfigTokensRequestBody;
  pathParams: DeleteEdgeConfigTokensPathParams;
  queryParams?: DeleteEdgeConfigTokensQueryParams;
} & FetcherExtraProps;

/**
 * Deletes one or more tokens of an existing Edge Config.
 */
export const deleteEdgeConfigTokens = (variables: DeleteEdgeConfigTokensVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    DeleteEdgeConfigTokensError,
    DeleteEdgeConfigTokensRequestBody,
    {},
    DeleteEdgeConfigTokensQueryParams,
    DeleteEdgeConfigTokensPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}/tokens', method: 'delete', ...variables, signal });

export type GetEdgeConfigTokenPathParams = {
  edgeConfigId: string;
  token: string;
};

export type GetEdgeConfigTokenQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetEdgeConfigTokenError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigTokenVariables = {
  pathParams: GetEdgeConfigTokenPathParams;
  queryParams?: GetEdgeConfigTokenQueryParams;
} & FetcherExtraProps;

/**
 * Return meta data about an Edge Config token.
 */
export const getEdgeConfigToken = (variables: GetEdgeConfigTokenVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.EdgeConfigToken,
    GetEdgeConfigTokenError,
    undefined,
    {},
    GetEdgeConfigTokenQueryParams,
    GetEdgeConfigTokenPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}/token/{token}', method: 'get', ...variables, signal });

export type CreateEdgeConfigTokenPathParams = {
  edgeConfigId: string;
};

export type CreateEdgeConfigTokenQueryParams = {
  /**
   * The Team identifier or slug to perform the request on behalf of.
   */
  teamId?: string;
};

export type CreateEdgeConfigTokenError = Fetcher.ErrorWrapper<undefined>;

export type CreateEdgeConfigTokenResponse = {
  token: string;
  id: string;
};

export type CreateEdgeConfigTokenRequestBody = {
  /**
   * @maxLength 52
   */
  label: string;
};

export type CreateEdgeConfigTokenVariables = {
  body: CreateEdgeConfigTokenRequestBody;
  pathParams: CreateEdgeConfigTokenPathParams;
  queryParams?: CreateEdgeConfigTokenQueryParams;
} & FetcherExtraProps;

/**
 * Adds a token to an existing Edge Config.
 */
export const createEdgeConfigToken = (variables: CreateEdgeConfigTokenVariables, signal?: AbortSignal) =>
  fetch<
    CreateEdgeConfigTokenResponse,
    CreateEdgeConfigTokenError,
    CreateEdgeConfigTokenRequestBody,
    {},
    CreateEdgeConfigTokenQueryParams,
    CreateEdgeConfigTokenPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}/token', method: 'post', ...variables, signal });

export const operationsByTag = {
  artifacts: { recordEvents, status, uploadArtifact, downloadArtifact, artifactQuery },
  deployments: {
    getDeployment,
    createDeployment,
    cancelDeployment,
    getDeploymentEvents,
    uploadFile,
    deleteDeployment,
    getDeployments,
    listDeploymentFiles,
    getDeploymentFileContents,
    listDeploymentBuilds
  },
  certs: { getCertById, removeCert, issueCert, uploadCert },
  user: { listUserEvents, getAuthUser, requestDelete },
  aliases: { listAliases, getAlias, deleteAlias, listDeploymentAliases, assignAlias },
  authentication: { listAuthTokens, createAuthToken, getAuthToken, deleteAuthToken, verifyToken, emailLogin },
  dns: { getRecords, createRecord, updateRecord, removeRecord },
  domains: {
    checkDomainStatus,
    checkDomainPrice,
    buyDomain,
    getDomainConfig,
    getDomain,
    getDomains,
    createOrTransferDomain,
    deleteDomain
  },
  secrets: { getSecrets, createSecret, renameSecret, getSecret, deleteSecret },
  projects: {
    getProjects,
    createProject,
    getProject,
    updateProject,
    deleteProject,
    getProjectDomains,
    getProjectDomain,
    updateProjectDomain,
    removeProjectDomain,
    addProjectDomain,
    verifyProjectDomain,
    filterProjectEnvs,
    getProjectEnv,
    createProjectEnv,
    removeProjectEnv,
    editProjectEnv
  },
  integrations: { getConfigurations, getConfiguration, deleteConfiguration, gitNamespaces, searchRepo },
  logDrains: {
    getIntegrationLogDrains,
    createLogDrain,
    deleteIntegrationLogDrain,
    getConfigurableLogDrain,
    deleteConfigurableLogDrain,
    getConfigurableLogDrains,
    createConfigurableLogDrain
  },
  webhooks: { createWebhook, getWebhooks, getWebhook, deleteWebhook },
  teams: {
    getTeam,
    patchTeam,
    getTeams,
    createTeam,
    deleteTeam,
    deleteTeamInviteCode,
    getTeamMembers,
    inviteUserToTeam,
    requestAccessToTeam,
    getTeamAccessRequest,
    joinTeam,
    updateTeamMember,
    removeTeamMember
  },
  checks: { createCheck, getAllChecks, getCheck, updateCheck, rerequestCheck },
  edgeConfig: {
    getEdgeConfigs,
    createEdgeConfig,
    getEdgeConfig,
    updateEdgeConfig,
    deleteEdgeConfig,
    getEdgeConfigItems,
    patchtEdgeConfigItems,
    getEdgeConfigItem,
    getEdgeConfigTokens,
    deleteEdgeConfigTokens,
    getEdgeConfigToken,
    createEdgeConfigToken
  }
};
