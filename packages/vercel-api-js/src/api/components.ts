/**
 * Generated by @openapi-codegen
 *
 * @version 0.0.1
 */
import type * as Fetcher from './fetcher';
import { fetch, FetcherExtraProps } from './fetcher';
import type * as Schemas from './schemas';

export type ReadAccessGroupPathParams = {
  idOrName: string;
};

export type ReadAccessGroupQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type ReadAccessGroupError = Fetcher.ErrorWrapper<undefined>;

export type ReadAccessGroupResponse = {
  isDsyncManaged: boolean;
  /**
   * The name of this access group.
   *
   * @example my-access-group
   */
  name: string;
  /**
   * Timestamp in milliseconds when the access group was created.
   *
   * @example 1588720733602
   */
  createdAt: string;
  /**
   * ID of the team that this access group belongs to.
   *
   * @example team_123a6c5209bc3778245d011443644c8d27dc2c50
   */
  teamId: string;
  /**
   * Timestamp in milliseconds when the access group was last updated.
   *
   * @example 1588720733602
   */
  updatedAt: string;
  /**
   * ID of the access group.
   *
   * @example ag_123a6c5209bc3778245d011443644c8d27dc2c50
   */
  accessGroupId: string;
  /**
   * Number of members in the access group.
   *
   * @example 5
   */
  membersCount: number;
  /**
   * Number of projects in the access group.
   *
   * @example 2
   */
  projectsCount: number;
};

export type ReadAccessGroupVariables = {
  pathParams: ReadAccessGroupPathParams;
  queryParams?: ReadAccessGroupQueryParams;
} & FetcherExtraProps;

/**
 * Allows to read an access group
 */
export const readAccessGroup = (variables: ReadAccessGroupVariables, signal?: AbortSignal) =>
  fetch<
    ReadAccessGroupResponse,
    ReadAccessGroupError,
    undefined,
    {},
    ReadAccessGroupQueryParams,
    ReadAccessGroupPathParams
  >({ url: '/v1/access-groups/{idOrName}', method: 'get', ...variables, signal });

export type UpdateAccessGroupPathParams = {
  idOrName: string;
};

export type UpdateAccessGroupQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type UpdateAccessGroupError = Fetcher.ErrorWrapper<undefined>;

export type UpdateAccessGroupRequestBody = {
  /**
   * The name of the access group
   *
   * @maxLength 50
   * @pattern ^[A-z0-9_ -]+$
   * @example My access group
   */
  name?: string;
  projects?: {
    /**
     * The ID of the project.
     *
     * @maxLength 256
     * @example prj_ndlgr43fadlPyCtREAqxxdyFK
     */
    projectId: string;
    /**
     * The project role that will be added to this Access Group. \"null\" will remove this project level role.
     *
     * @example ADMIN
     */
    role: 'ADMIN' | 'PROJECT_VIEWER' | 'PROJECT_DEVELOPER' | any | null;
  }[];
  /**
   * List of members to add to the access group.
   */
  membersToAdd?: string[];
  /**
   * List of members to remove from the access group.
   */
  membersToRemove?: string[];
};

export type UpdateAccessGroupVariables = {
  body?: UpdateAccessGroupRequestBody;
  pathParams: UpdateAccessGroupPathParams;
  queryParams?: UpdateAccessGroupQueryParams;
} & FetcherExtraProps;

/**
 * Allows to update an access group metadata
 */
export const updateAccessGroup = (variables: UpdateAccessGroupVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.AccessGroup,
    UpdateAccessGroupError,
    UpdateAccessGroupRequestBody,
    {},
    UpdateAccessGroupQueryParams,
    UpdateAccessGroupPathParams
  >({ url: '/v1/access-groups/{idOrName}', method: 'post', ...variables, signal });

export type DeleteAccessGroupPathParams = {
  idOrName: string;
};

export type DeleteAccessGroupQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type DeleteAccessGroupError = Fetcher.ErrorWrapper<undefined>;

export type DeleteAccessGroupVariables = {
  pathParams: DeleteAccessGroupPathParams;
  queryParams?: DeleteAccessGroupQueryParams;
} & FetcherExtraProps;

/**
 * Allows to delete an access group
 */
export const deleteAccessGroup = (variables: DeleteAccessGroupVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteAccessGroupError, undefined, {}, DeleteAccessGroupQueryParams, DeleteAccessGroupPathParams>({
    url: '/v1/access-groups/{idOrName}',
    method: 'delete',
    ...variables,
    signal
  });

export type ListAccessGroupMembersPathParams = {
  /**
   * The ID or name of the Access Group.
   *
   * @example ag_pavWOn1iLObbXLRiwVvzmPrTWyTf
   */
  idOrName: string;
};

export type ListAccessGroupMembersQueryParams = {
  /**
   * Limit how many access group members should be returned.
   *
   * @example 20
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
  /**
   * Continuation cursor to retrieve the next page of results.
   */
  next?: string;
  /**
   * Search project members by their name, username, and email.
   */
  search?: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type ListAccessGroupMembersError = Fetcher.ErrorWrapper<undefined>;

export type ListAccessGroupMembersResponse = {
  members: {
    avatar?: string;
    email: string;
    uid: string;
    username: string;
    name?: string;
    createdAt?: string;
    teamRole: 'OWNER' | 'MEMBER' | 'DEVELOPER' | 'BILLING' | 'VIEWER' | 'CONTRIBUTOR';
  }[];
  pagination: {
    count: number;
    next: string | null;
  };
};

export type ListAccessGroupMembersVariables = {
  pathParams: ListAccessGroupMembersPathParams;
  queryParams?: ListAccessGroupMembersQueryParams;
} & FetcherExtraProps;

/**
 * List members of an access group
 */
export const listAccessGroupMembers = (variables: ListAccessGroupMembersVariables, signal?: AbortSignal) =>
  fetch<
    ListAccessGroupMembersResponse,
    ListAccessGroupMembersError,
    undefined,
    {},
    ListAccessGroupMembersQueryParams,
    ListAccessGroupMembersPathParams
  >({ url: '/v1/access-groups/{idOrName}/members', method: 'get', ...variables, signal });

export type ListAccessGroupsQueryParams = {
  /**
   * Filter access groups by project.
   *
   * @example prj_pavWOn1iLObbx3RowVvzmPrTWyTf
   */
  projectId?: string;
  /**
   * Search for access groups by name.
   *
   * @example example
   */
  search?: string;
  /**
   * Number of members to include in the response.
   *
   * @example 20
   * @minimum 1
   * @maximum 100
   */
  membersLimit?: number;
  /**
   * Number of projects to include in the response.
   *
   * @example 20
   * @minimum 1
   * @maximum 100
   */
  projectsLimit?: number;
  /**
   * Limit how many access group should be returned.
   *
   * @example 20
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
  /**
   * Continuation cursor to retrieve the next page of results.
   */
  next?: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type ListAccessGroupsError = Fetcher.ErrorWrapper<undefined>;

export type ListAccessGroupsVariables = {
  queryParams?: ListAccessGroupsQueryParams;
} & FetcherExtraProps;

/**
 * List access groups
 */
export const listAccessGroups = (variables: ListAccessGroupsVariables, signal?: AbortSignal) =>
  fetch<
    | Record<string, any>
    | {
        accessGroups: {
          members?: string[];
          projects?: string[];
          isDsyncManaged: boolean;
          /**
           * The name of this access group.
           *
           * @example my-access-group
           */
          name: string;
          /**
           * Timestamp in milliseconds when the access group was created.
           *
           * @example 1588720733602
           */
          createdAt: string;
          /**
           * ID of the team that this access group belongs to.
           *
           * @example team_123a6c5209bc3778245d011443644c8d27dc2c50
           */
          teamId: string;
          /**
           * Timestamp in milliseconds when the access group was last updated.
           *
           * @example 1588720733602
           */
          updatedAt: string;
          /**
           * ID of the access group.
           *
           * @example ag_123a6c5209bc3778245d011443644c8d27dc2c50
           */
          accessGroupId: string;
          /**
           * Number of members in the access group.
           *
           * @example 5
           */
          membersCount: number;
          /**
           * Number of projects in the access group.
           *
           * @example 2
           */
          projectsCount: number;
        }[];
        pagination: {
          count: number;
          next: string | null;
        };
      },
    ListAccessGroupsError,
    undefined,
    {},
    ListAccessGroupsQueryParams,
    {}
  >({ url: '/v1/access-groups', method: 'get', ...variables, signal });

export type CreateAccessGroupQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type CreateAccessGroupError = Fetcher.ErrorWrapper<undefined>;

export type CreateAccessGroupResponse = {
  membersCount: number;
  projectsCount: number;
  /**
   * The name of this access group.
   *
   * @example my-access-group
   */
  name: string;
  /**
   * Timestamp in milliseconds when the access group was created.
   *
   * @example 1588720733602
   */
  createdAt: string;
  /**
   * ID of the team that this access group belongs to.
   *
   * @example team_123a6c5209bc3778245d011443644c8d27dc2c50
   */
  teamId: string;
  /**
   * Timestamp in milliseconds when the access group was last updated.
   *
   * @example 1588720733602
   */
  updatedAt: string;
  /**
   * ID of the access group.
   *
   * @example ag_123a6c5209bc3778245d011443644c8d27dc2c50
   */
  accessGroupId: string;
};

export type CreateAccessGroupRequestBody = {
  /**
   * The name of the access group
   *
   * @maxLength 50
   * @pattern ^[A-z0-9_ -]+$
   * @example My access group
   */
  name: string;
  projects?: {
    /**
     * The ID of the project.
     *
     * @maxLength 256
     * @example prj_ndlgr43fadlPyCtREAqxxdyFK
     */
    projectId: string;
    /**
     * The project role that will be added to this Access Group. \"null\" will remove this project level role.
     *
     * @example ADMIN
     */
    role: 'ADMIN' | 'PROJECT_VIEWER' | 'PROJECT_DEVELOPER' | null;
  }[];
  /**
   * List of members to add to the access group.
   */
  membersToAdd?: string[];
};

export type CreateAccessGroupVariables = {
  body: CreateAccessGroupRequestBody;
  queryParams?: CreateAccessGroupQueryParams;
} & FetcherExtraProps;

/**
 * Allows to create an access group
 */
export const createAccessGroup = (variables: CreateAccessGroupVariables, signal?: AbortSignal) =>
  fetch<
    CreateAccessGroupResponse,
    CreateAccessGroupError,
    CreateAccessGroupRequestBody,
    {},
    CreateAccessGroupQueryParams,
    {}
  >({ url: '/v1/access-groups', method: 'post', ...variables, signal });

export type ListAccessGroupProjectsPathParams = {
  /**
   * The ID or name of the Access Group.
   *
   * @example ag_pavWOn1iLObbXLRiwVvzmPrTWyTf
   */
  idOrName: string;
};

export type ListAccessGroupProjectsQueryParams = {
  /**
   * Limit how many access group projects should be returned.
   *
   * @example 20
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
  /**
   * Continuation cursor to retrieve the next page of results.
   */
  next?: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type ListAccessGroupProjectsError = Fetcher.ErrorWrapper<undefined>;

export type ListAccessGroupProjectsResponse = {
  projects: {
    projectId: string;
    role: 'ADMIN' | 'PROJECT_DEVELOPER' | 'PROJECT_VIEWER';
    createdAt: string;
    updatedAt: string;
    project: {
      name?: string;
      framework?: string | null;
      latestDeploymentId?: string;
    };
  }[];
  pagination: {
    count: number;
    next: string | null;
  };
};

export type ListAccessGroupProjectsVariables = {
  pathParams: ListAccessGroupProjectsPathParams;
  queryParams?: ListAccessGroupProjectsQueryParams;
} & FetcherExtraProps;

/**
 * List projects of an access group
 */
export const listAccessGroupProjects = (variables: ListAccessGroupProjectsVariables, signal?: AbortSignal) =>
  fetch<
    ListAccessGroupProjectsResponse,
    ListAccessGroupProjectsError,
    undefined,
    {},
    ListAccessGroupProjectsQueryParams,
    ListAccessGroupProjectsPathParams
  >({ url: '/v1/access-groups/{idOrName}/projects', method: 'get', ...variables, signal });

export type RecordEventsQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type RecordEventsHeaders = {
  /**
   * The continuous integration or delivery environment where this artifact is downloaded.
   *
   * @example VERCEL
   * @maxLength 50
   */
  ['x-artifact-client-ci']?: string;
  /**
   * 1 if the client is an interactive shell. Otherwise 0
   *
   * @example 0
   * @minimum 0
   * @maximum 1
   */
  ['x-artifact-client-interactive']?: number;
};

export type RecordEventsError = Fetcher.ErrorWrapper<undefined>;

export type RecordEventsRequestBody = {
  /**
   * A UUID (universally unique identifer) for the session that generated this event.
   */
  sessionId: string;
  /**
   * One of `LOCAL` or `REMOTE`. `LOCAL` specifies that the cache event was from the user's filesystem cache. `REMOTE` specifies that the cache event is from a remote cache.
   */
  source: 'LOCAL' | 'REMOTE';
  /**
   * One of `HIT` or `MISS`. `HIT` specifies that a cached artifact for `hash` was found in the cache. `MISS` specifies that a cached artifact with `hash` was not found.
   */
  event: 'HIT' | 'MISS';
  /**
   * The artifact hash
   *
   * @example 12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  hash: string;
  /**
   * The time taken to generate the artifact. This should be sent as a body parameter on `HIT` events.
   *
   * @example 400
   */
  duration?: number;
}[];

export type RecordEventsVariables = {
  body?: RecordEventsRequestBody;
  headers?: RecordEventsHeaders;
  queryParams?: RecordEventsQueryParams;
} & FetcherExtraProps;

/**
 * Records an artifacts cache usage event. The body of this request is an array of cache usage events. The supported event types are `HIT` and `MISS`. The source is either `LOCAL` the cache event was on the users filesystem cache or `REMOTE` if the cache event is for a remote cache. When the event is a `HIT` the request also accepts a number `duration` which is the time taken to generate the artifact in the cache.
 */
export const recordEvents = (variables: RecordEventsVariables, signal?: AbortSignal) =>
  fetch<undefined, RecordEventsError, RecordEventsRequestBody, RecordEventsHeaders, RecordEventsQueryParams, {}>({
    url: '/v8/artifacts/events',
    method: 'post',
    ...variables,
    signal
  });

export type StatusQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type StatusError = Fetcher.ErrorWrapper<undefined>;

export type StatusResponse = {
  status: 'disabled' | 'enabled' | 'over_limit' | 'paused';
};

export type StatusVariables = {
  queryParams?: StatusQueryParams;
} & FetcherExtraProps;

/**
 * Check the status of Remote Caching for this principal. Returns a JSON-encoded status indicating if Remote Caching is enabled, disabled, or disabled due to usage limits.
 */
export const status = (variables: StatusVariables, signal?: AbortSignal) =>
  fetch<StatusResponse, StatusError, undefined, {}, StatusQueryParams, {}>({
    url: '/v8/artifacts/status',
    method: 'get',
    ...variables,
    signal
  });

export type UploadArtifactPathParams = {
  /**
   * The artifact hash
   *
   * @example 12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  hash: string;
};

export type UploadArtifactQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type UploadArtifactHeaders = {
  /**
   * The artifact size in bytes
   */
  ['Content-Length']: number;
  /**
   * The time taken to generate the uploaded artifact in milliseconds.
   *
   * @example 400
   */
  ['x-artifact-duration']?: number;
  /**
   * The continuous integration or delivery environment where this artifact was generated.
   *
   * @example VERCEL
   * @maxLength 50
   */
  ['x-artifact-client-ci']?: string;
  /**
   * 1 if the client is an interactive shell. Otherwise 0
   *
   * @example 0
   * @minimum 0
   * @maximum 1
   */
  ['x-artifact-client-interactive']?: number;
  /**
   * The base64 encoded tag for this artifact. The value is sent back to clients when the artifact is downloaded as the header `x-artifact-tag`
   *
   * @example Tc0BmHvJYMIYJ62/zx87YqO0Flxk+5Ovip25NY825CQ=
   * @maxLength 600
   */
  ['x-artifact-tag']?: string;
};

export type UploadArtifactError = Fetcher.ErrorWrapper<undefined>;

export type UploadArtifactResponse = {
  /**
   * Array of URLs where the artifact was updated
   *
   * @example https://api.vercel.com/v2/now/artifact/12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  urls: string[];
};

export type UploadArtifactVariables = {
  body?: Blob;
  headers: UploadArtifactHeaders;
  pathParams: UploadArtifactPathParams;
  queryParams?: UploadArtifactQueryParams;
} & FetcherExtraProps;

/**
 * Uploads a cache artifact identified by the `hash` specified on the path. The cache artifact can then be downloaded with the provided `hash`.
 */
export const uploadArtifact = (variables: UploadArtifactVariables, signal?: AbortSignal) =>
  fetch<
    UploadArtifactResponse,
    UploadArtifactError,
    Blob,
    UploadArtifactHeaders,
    UploadArtifactQueryParams,
    UploadArtifactPathParams
  >({ url: '/v8/artifacts/{hash}', method: 'put', ...variables, signal });

export type DownloadArtifactPathParams = {
  /**
   * The artifact hash
   *
   * @example 12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  hash: string;
};

export type DownloadArtifactQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type DownloadArtifactHeaders = {
  /**
   * The continuous integration or delivery environment where this artifact is downloaded.
   *
   * @example VERCEL
   * @maxLength 50
   */
  ['x-artifact-client-ci']?: string;
  /**
   * 1 if the client is an interactive shell. Otherwise 0
   *
   * @example 0
   * @minimum 0
   * @maximum 1
   */
  ['x-artifact-client-interactive']?: number;
};

export type DownloadArtifactError = Fetcher.ErrorWrapper<undefined>;

export type DownloadArtifactVariables = {
  headers?: DownloadArtifactHeaders;
  pathParams: DownloadArtifactPathParams;
  queryParams?: DownloadArtifactQueryParams;
} & FetcherExtraProps;

/**
 * Downloads a cache artifact indentified by its `hash` specified on the request path. The artifact is downloaded as an octet-stream. The client should verify the content-length header and response body.
 */
export const downloadArtifact = (variables: DownloadArtifactVariables, signal?: AbortSignal) =>
  fetch<
    Blob,
    DownloadArtifactError,
    undefined,
    DownloadArtifactHeaders,
    DownloadArtifactQueryParams,
    DownloadArtifactPathParams
  >({ url: '/v8/artifacts/{hash}', method: 'get', ...variables, signal });

export type ArtifactQueryQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type ArtifactQueryError = Fetcher.ErrorWrapper<undefined>;

export type ArtifactQueryResponse = {
  [key: string]:
    | {
        size: number;
        taskDurationMs: number;
        tag?: string;
      }
    | {
        error: {
          message: string;
        };
      }
    | null;
};

export type ArtifactQueryRequestBody = {
  /**
   * artifact hashes
   */
  hashes: string[];
};

export type ArtifactQueryVariables = {
  body: ArtifactQueryRequestBody;
  queryParams?: ArtifactQueryQueryParams;
} & FetcherExtraProps;

/**
 * Query information about an array of artifacts.
 */
export const artifactQuery = (variables: ArtifactQueryVariables, signal?: AbortSignal) =>
  fetch<ArtifactQueryResponse, ArtifactQueryError, ArtifactQueryRequestBody, {}, ArtifactQueryQueryParams, {}>({
    url: '/v8/artifacts',
    method: 'post',
    ...variables,
    signal
  });

export type CreateCheckPathParams = {
  /**
   * The deployment to create the check for.
   *
   * @example dpl_2qn7PZrx89yxY34vEZPD31Y9XVj6
   */
  deploymentId: string;
};

export type CreateCheckQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type CreateCheckError = Fetcher.ErrorWrapper<undefined>;

export type CreateCheckResponse = {
  id: string;
  name: string;
  path?: string;
  status: 'registered' | 'running' | 'completed';
  conclusion?: 'canceled' | 'failed' | 'neutral' | 'succeeded' | 'skipped' | 'stale';
  blocking: boolean;
  output?: {
    metrics?: {
      FCP: {
        value: number | null;
        previousValue?: number;
        source: 'web-vitals';
      };
      LCP: {
        value: number | null;
        previousValue?: number;
        source: 'web-vitals';
      };
      CLS: {
        value: number | null;
        previousValue?: number;
        source: 'web-vitals';
      };
      TBT: {
        value: number | null;
        previousValue?: number;
        source: 'web-vitals';
      };
      virtualExperienceScore?: {
        value: number | null;
        previousValue?: number;
        source: 'web-vitals';
      };
    };
  };
  detailsUrl?: string;
  integrationId: string;
  deploymentId: string;
  externalId?: string;
  createdAt: number;
  updatedAt: number;
  startedAt?: number;
  completedAt?: number;
  rerequestable?: boolean;
};

export type CreateCheckRequestBody = {
  /**
   * The name of the check being created
   *
   * @maxLength 100
   * @example Performance Check
   */
  name: string;
  /**
   * Path of the page that is being checked
   *
   * @maxLength 255
   * @example /
   */
  path?: string;
  /**
   * Whether the check should block a deployment from succeeding
   *
   * @example true
   */
  blocking: boolean;
  /**
   * URL to display for further details
   *
   * @example http://example.com
   */
  detailsUrl?: string;
  /**
   * An identifier that can be used as an external reference
   *
   * @example 1234abc
   */
  externalId?: string;
  /**
   * Whether a user should be able to request for the check to be rerun if it fails
   *
   * @example true
   */
  rerequestable?: boolean;
};

export type CreateCheckVariables = {
  body: CreateCheckRequestBody;
  pathParams: CreateCheckPathParams;
  queryParams?: CreateCheckQueryParams;
} & FetcherExtraProps;

/**
 * Creates a new check. This endpoint must be called with an OAuth2 or it will produce a 400 error.
 */
export const createCheck = (variables: CreateCheckVariables, signal?: AbortSignal) =>
  fetch<
    CreateCheckResponse,
    CreateCheckError,
    CreateCheckRequestBody,
    {},
    CreateCheckQueryParams,
    CreateCheckPathParams
  >({ url: '/v1/deployments/{deploymentId}/checks', method: 'post', ...variables, signal });

export type GetAllChecksPathParams = {
  /**
   * The deployment to get all checks for
   *
   * @example dpl_2qn7PZrx89yxY34vEZPD31Y9XVj6
   */
  deploymentId: string;
};

export type GetAllChecksQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetAllChecksError = Fetcher.ErrorWrapper<undefined>;

export type GetAllChecksResponse = {
  checks: {
    completedAt?: number;
    conclusion?: 'canceled' | 'failed' | 'neutral' | 'succeeded' | 'skipped' | 'stale';
    createdAt: number;
    detailsUrl?: string;
    id: string;
    integrationId: string;
    name: string;
    output?: {
      metrics?: {
        FCP: {
          value: number | null;
          previousValue?: number;
          source: 'web-vitals';
        };
        LCP: {
          value: number | null;
          previousValue?: number;
          source: 'web-vitals';
        };
        CLS: {
          value: number | null;
          previousValue?: number;
          source: 'web-vitals';
        };
        TBT: {
          value: number | null;
          previousValue?: number;
          source: 'web-vitals';
        };
        virtualExperienceScore?: {
          value: number | null;
          previousValue?: number;
          source: 'web-vitals';
        };
      };
    };
    path?: string;
    rerequestable: boolean;
    startedAt?: number;
    status: 'registered' | 'running' | 'completed';
    updatedAt: number;
  }[];
};

export type GetAllChecksVariables = {
  pathParams: GetAllChecksPathParams;
  queryParams?: GetAllChecksQueryParams;
} & FetcherExtraProps;

/**
 * List all of the checks created for a deployment.
 */
export const getAllChecks = (variables: GetAllChecksVariables, signal?: AbortSignal) =>
  fetch<GetAllChecksResponse, GetAllChecksError, undefined, {}, GetAllChecksQueryParams, GetAllChecksPathParams>({
    url: '/v1/deployments/{deploymentId}/checks',
    method: 'get',
    ...variables,
    signal
  });

export type GetCheckPathParams = {
  /**
   * The deployment to get the check for.
   *
   * @example dpl_2qn7PZrx89yxY34vEZPD31Y9XVj6
   */
  deploymentId: string;
  /**
   * The check to fetch
   *
   * @example check_2qn7PZrx89yxY34vEZPD31Y9XVj6
   */
  checkId: string;
};

export type GetCheckQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetCheckError = Fetcher.ErrorWrapper<undefined>;

export type GetCheckResponse = {
  id: string;
  name: string;
  path?: string;
  status: 'registered' | 'running' | 'completed';
  conclusion?: 'canceled' | 'failed' | 'neutral' | 'succeeded' | 'skipped' | 'stale';
  blocking: boolean;
  output?: {
    metrics?: {
      FCP: {
        value: number | null;
        previousValue?: number;
        source: 'web-vitals';
      };
      LCP: {
        value: number | null;
        previousValue?: number;
        source: 'web-vitals';
      };
      CLS: {
        value: number | null;
        previousValue?: number;
        source: 'web-vitals';
      };
      TBT: {
        value: number | null;
        previousValue?: number;
        source: 'web-vitals';
      };
      virtualExperienceScore?: {
        value: number | null;
        previousValue?: number;
        source: 'web-vitals';
      };
    };
  };
  detailsUrl?: string;
  integrationId: string;
  deploymentId: string;
  externalId?: string;
  createdAt: number;
  updatedAt: number;
  startedAt?: number;
  completedAt?: number;
  rerequestable?: boolean;
};

export type GetCheckVariables = {
  pathParams: GetCheckPathParams;
  queryParams?: GetCheckQueryParams;
} & FetcherExtraProps;

/**
 * Return a detailed response for a single check.
 */
export const getCheck = (variables: GetCheckVariables, signal?: AbortSignal) =>
  fetch<GetCheckResponse, GetCheckError, undefined, {}, GetCheckQueryParams, GetCheckPathParams>({
    url: '/v1/deployments/{deploymentId}/checks/{checkId}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateCheckPathParams = {
  /**
   * The deployment to update the check for.
   *
   * @example dpl_2qn7PZrx89yxY34vEZPD31Y9XVj6
   */
  deploymentId: string;
  /**
   * The check being updated
   *
   * @example check_2qn7PZrx89yxY34vEZPD31Y9XVj6
   */
  checkId: string;
};

export type UpdateCheckQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type UpdateCheckError = Fetcher.ErrorWrapper<undefined>;

export type UpdateCheckResponse = {
  id: string;
  name: string;
  path?: string;
  status: 'registered' | 'running' | 'completed';
  conclusion?: 'canceled' | 'failed' | 'neutral' | 'succeeded' | 'skipped' | 'stale';
  blocking: boolean;
  output?: {
    metrics?: {
      FCP: {
        value: number | null;
        previousValue?: number;
        source: 'web-vitals';
      };
      LCP: {
        value: number | null;
        previousValue?: number;
        source: 'web-vitals';
      };
      CLS: {
        value: number | null;
        previousValue?: number;
        source: 'web-vitals';
      };
      TBT: {
        value: number | null;
        previousValue?: number;
        source: 'web-vitals';
      };
      virtualExperienceScore?: {
        value: number | null;
        previousValue?: number;
        source: 'web-vitals';
      };
    };
  };
  detailsUrl?: string;
  integrationId: string;
  deploymentId: string;
  externalId?: string;
  createdAt: number;
  updatedAt: number;
  startedAt?: number;
  completedAt?: number;
  rerequestable?: boolean;
};

export type UpdateCheckRequestBody = {
  /**
   * The name of the check being created
   *
   * @maxLength 100
   * @example Performance Check
   */
  name?: string;
  /**
   * Path of the page that is being checked
   *
   * @maxLength 255
   * @example /
   */
  path?: string;
  /**
   * The current status of the check
   */
  status?: 'running' | 'completed';
  /**
   * The result of the check being run
   */
  conclusion?: 'canceled' | 'failed' | 'neutral' | 'succeeded' | 'skipped';
  /**
   * A URL a user may visit to see more information about the check
   *
   * @example https://example.com/check/run/1234abc
   */
  detailsUrl?: string;
  /**
   * The results of the check Run
   */
  output?: {
    /**
     * Metrics about the page
     */
    metrics?: {
      FCP: {
        /**
         * First Contentful Paint value
         *
         * @example 1200
         */
        value: number | null;
        /**
         * Previous First Contentful Paint value to display a delta
         *
         * @example 900
         */
        previousValue?: number;
        source: 'web-vitals';
      };
      LCP: {
        /**
         * Largest Contentful Paint value
         *
         * @example 1200
         */
        value: number | null;
        /**
         * Previous Largest Contentful Paint value to display a delta
         *
         * @example 1000
         */
        previousValue?: number;
        source: 'web-vitals';
      };
      CLS: {
        /**
         * Cumulative Layout Shift value
         *
         * @example 4
         */
        value: number | null;
        /**
         * Previous Cumulative Layout Shift value to display a delta
         *
         * @example 2
         */
        previousValue?: number;
        source: 'web-vitals';
      };
      TBT: {
        /**
         * Total Blocking Time value
         *
         * @example 3000
         */
        value: number | null;
        /**
         * Previous Total Blocking Time value to display a delta
         *
         * @example 3500
         */
        previousValue?: number;
        source: 'web-vitals';
      };
      virtualExperienceScore?: {
        /**
         * The calculated Virtual Experience Score value, between 0 and 100
         *
         * @maximum 100
         * @minimum 0
         * @example 30
         */
        value: number | null;
        /**
         * A previous Virtual Experience Score value to display a delta, between 0 and 100
         *
         * @maximum 100
         * @minimum 0
         * @example 35
         */
        previousValue?: number;
        source: 'web-vitals';
      };
    };
  };
  /**
   * An identifier that can be used as an external reference
   *
   * @example 1234abc
   */
  externalId?: string;
};

export type UpdateCheckVariables = {
  body?: UpdateCheckRequestBody;
  pathParams: UpdateCheckPathParams;
  queryParams?: UpdateCheckQueryParams;
} & FetcherExtraProps;

/**
 * Update an existing check. This endpoint must be called with an OAuth2 or it will produce a 400 error.
 */
export const updateCheck = (variables: UpdateCheckVariables, signal?: AbortSignal) =>
  fetch<
    UpdateCheckResponse,
    UpdateCheckError,
    UpdateCheckRequestBody,
    {},
    UpdateCheckQueryParams,
    UpdateCheckPathParams
  >({ url: '/v1/deployments/{deploymentId}/checks/{checkId}', method: 'patch', ...variables, signal });

export type RerequestCheckPathParams = {
  /**
   * The deployment to rerun the check for.
   *
   * @example dpl_2qn7PZrx89yxY34vEZPD31Y9XVj6
   */
  deploymentId: string;
  /**
   * The check to rerun
   *
   * @example check_2qn7PZrx89yxY34vEZPD31Y9XVj6
   */
  checkId: string;
};

export type RerequestCheckQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type RerequestCheckError = Fetcher.ErrorWrapper<undefined>;

export type RerequestCheckVariables = {
  pathParams: RerequestCheckPathParams;
  queryParams?: RerequestCheckQueryParams;
} & FetcherExtraProps;

/**
 * Rerequest a selected check that has failed.
 */
export const rerequestCheck = (variables: RerequestCheckVariables, signal?: AbortSignal) =>
  fetch<Record<string, any>, RerequestCheckError, undefined, {}, RerequestCheckQueryParams, RerequestCheckPathParams>({
    url: '/v1/deployments/{deploymentId}/checks/{checkId}/rerequest',
    method: 'post',
    ...variables,
    signal
  });

export type UpdateProjectDataCachePathParams = {
  /**
   * The unique project identifier
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectId: string;
};

export type UpdateProjectDataCacheQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type UpdateProjectDataCacheError = Fetcher.ErrorWrapper<undefined>;

export type UpdateProjectDataCacheResponse = {
  accountId: string;
  analytics?: {
    id: string;
    canceledAt?: number | null;
    disabledAt: number;
    enabledAt: number;
    paidAt?: number;
    sampleRatePercent?: number | null;
    spendLimitInDollars?: number | null;
  };
  speedInsights?: {
    id: string;
    enabledAt?: number;
    disabledAt?: number;
    canceledAt?: number;
    hasData?: boolean;
    paidAt?: number;
  };
  autoExposeSystemEnvs?: boolean;
  autoAssignCustomDomains?: boolean;
  autoAssignCustomDomainsUpdatedBy?: string;
  buildCommand?: string | null;
  commandForIgnoringBuildStep?: string | null;
  connectConfigurationId?: string | null;
  connectBuildsEnabled?: boolean;
  createdAt?: number;
  customerSupportCodeVisibility?: boolean;
  crons?: {
    /**
     * The time the feature was enabled for this project. Note: It enables automatically with the first Deployment that outputs cronjobs.
     */
    enabledAt: number;
    /**
     * The time the feature was disabled for this project.
     */
    disabledAt: number | null;
    updatedAt: number;
    /**
     * The ID of the Deployment from which the definitions originated.
     */
    deploymentId: string | null;
    definitions: {
      /**
       * The hostname that should be used.
       *
       * @example vercel.com
       */
      host: string;
      /**
       * The path that should be called for the cronjob.
       *
       * @example /api/crons/sync-something?hello=world
       */
      path: string;
      /**
       * The cron expression.
       *
       * @example 0 0 * * *
       */
      schedule: string;
    }[];
  };
  dataCache?: {
    userDisabled: boolean;
    storageSizeBytes?: number | null;
    unlimited?: boolean;
  };
  deploymentExpiration?: {
    expirationDays?: number;
    expirationDaysProduction?: number;
    expirationDaysCanceled?: number;
    expirationDaysErrored?: number;
    deploymentsToKeep?: number;
  } | null;
  devCommand?: string | null;
  directoryListing: boolean;
  installCommand?: string | null;
  env?: {
    target?:
      | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
      | ('production' | 'preview' | 'development' | 'preview' | 'development');
    type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
    /**
     * This is used to identiy variables that have been migrated from type secret to sensitive.
     */
    sunsetSecretId?: string;
    id?: string;
    key: string;
    value: string;
    configurationId?: string | null;
    createdAt?: number;
    updatedAt?: number;
    createdBy?: string | null;
    updatedBy?: string | null;
    gitBranch?: string;
    edgeConfigId?: string | null;
    edgeConfigTokenId?: string | null;
    contentHint?:
      | {
          type: 'redis-url';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-url';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-token';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-read-only-token';
          storeId: string;
        }
      | {
          type: 'blob-read-write-token';
          storeId: string;
        }
      | {
          type: 'postgres-url';
          storeId: string;
        }
      | {
          type: 'postgres-url-non-pooling';
          storeId: string;
        }
      | {
          type: 'postgres-prisma-url';
          storeId: string;
        }
      | {
          type: 'postgres-user';
          storeId: string;
        }
      | {
          type: 'postgres-host';
          storeId: string;
        }
      | {
          type: 'postgres-password';
          storeId: string;
        }
      | {
          type: 'postgres-database';
          storeId: string;
        }
      | {
          type: 'postgres-url-no-ssl';
          storeId: string;
        }
      | {
          type: 'integration-store-secret';
          storeId: string;
        }
      | null;
    /**
     * Similar to `contentHints`, but should not be exposed to the user.
     */
    internalContentHint?: {
      type: 'flags-secret';
      /**
       * Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
       */
      encryptedValue: string;
    } | null;
    /**
     * Whether `value` is decrypted.
     */
    decrypted?: boolean;
    comment?: string;
    customEnvironmentIds?: string[];
  }[];
  framework?:
    | 'blitzjs'
    | 'nextjs'
    | 'gatsby'
    | 'remix'
    | 'astro'
    | 'hexo'
    | 'eleventy'
    | 'docusaurus-2'
    | 'docusaurus'
    | 'preact'
    | 'solidstart-1'
    | 'solidstart'
    | 'dojo'
    | 'ember'
    | 'vue'
    | 'scully'
    | 'ionic-angular'
    | 'angular'
    | 'polymer'
    | 'svelte'
    | 'sveltekit'
    | 'sveltekit-1'
    | 'ionic-react'
    | 'create-react-app'
    | 'gridsome'
    | 'umijs'
    | 'sapper'
    | 'saber'
    | 'stencil'
    | 'nuxtjs'
    | 'redwoodjs'
    | 'hugo'
    | 'jekyll'
    | 'brunch'
    | 'middleman'
    | 'zola'
    | 'hydrogen'
    | 'vite'
    | 'vitepress'
    | 'vuepress'
    | 'parcel'
    | 'sanity'
    | 'storybook'
    | null;
  gitForkProtection?: boolean;
  gitLFS?: boolean;
  id: string;
  latestDeployments?: {
    alias?: string[];
    aliasAssigned?: number | boolean | null;
    aliasError?: {
      code: string;
      message: string;
    } | null;
    aliasFinal?: string | null;
    automaticAliases?: string[];
    builds?: {
      use: string;
      src?: string;
      dest?: string;
    }[];
    connectBuildsEnabled?: boolean;
    connectConfigurationId?: string;
    createdAt: number;
    createdIn: string;
    creator: {
      email: string;
      githubLogin?: string;
      gitlabLogin?: string;
      uid: string;
      username: string;
    } | null;
    deletedAt?: number;
    deploymentHostname: string;
    name: string;
    forced?: boolean;
    id: string;
    meta?: {
      [key: string]: string;
    };
    monorepoManager?: string | null;
    plan: 'pro' | 'enterprise' | 'hobby';
    private: boolean;
    readyState: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED';
    readySubstate?: 'STAGED' | 'PROMOTED';
    requestedAt?: number;
    target?: string | null;
    teamId?: string | null;
    type: 'LAMBDAS';
    url: string;
    userId: string;
    withCache?: boolean;
    checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
    checksState?: 'registered' | 'running' | 'completed';
    readyAt?: number;
    buildingAt?: number;
    /**
     * Whether or not preview comments are enabled for the deployment
     *
     * @example false
     */
    previewCommentsEnabled?: boolean;
    oidcTokenClaims?: {
      [key: string]: string | string[];
    };
  }[];
  link?:
    | {
        org?: string;
        repo?: string;
        repoId?: number;
        type?: 'github';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        projectId?: string;
        projectName?: string;
        projectNameWithNamespace?: string;
        projectNamespace?: string;
        projectUrl?: string;
        type?: 'gitlab';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        name?: string;
        slug?: string;
        owner?: string;
        type?: 'bitbucket';
        uuid?: string;
        workspaceUuid?: string;
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      };
  name: string;
  nodeVersion: '20.x' | '18.x' | '16.x' | '14.x' | '12.x' | '10.x' | '8.10.x';
  optionsAllowlist?: {
    paths: {
      value: string;
    }[];
  } | null;
  outputDirectory?: string | null;
  passiveConnectConfigurationId?: string | null;
  passwordProtection?: Record<string, any> | null;
  productionDeploymentsFastLane?: boolean;
  publicSource?: boolean | null;
  rootDirectory?: string | null;
  serverlessFunctionRegion?: string | null;
  serverlessFunctionZeroConfigFailover?: boolean;
  skewProtectionBoundaryAt?: number;
  skewProtectionMaxAge?: number;
  skipGitConnectDuringLink?: boolean;
  sourceFilesOutsideRootDirectory?: boolean;
  ssoProtection?: {
    deploymentType: 'all' | 'preview' | 'prod_deployment_urls_and_all_previews';
  } | null;
  targets?: {
    [key: string]: string | string[];
  };
  transferCompletedAt?: number;
  transferStartedAt?: number;
  transferToAccountId?: string;
  transferredFromAccountId?: string;
  updatedAt?: number;
  live?: boolean;
  enablePreviewFeedback?: boolean | null;
  permissions?: {
    accessGroup?: Schemas.ACLAction[];
    aliasGlobal?: Schemas.ACLAction[];
    analyticsSampling?: Schemas.ACLAction[];
    analyticsUsage?: Schemas.ACLAction[];
    auditLog?: Schemas.ACLAction[];
    billingAddress?: Schemas.ACLAction[];
    billingInformation?: Schemas.ACLAction[];
    billingInvoice?: Schemas.ACLAction[];
    billingInvoiceEmailRecipient?: Schemas.ACLAction[];
    billingInvoiceLanguage?: Schemas.ACLAction[];
    billingPlan?: Schemas.ACLAction[];
    billingPurchaseOrder?: Schemas.ACLAction[];
    billingTaxId?: Schemas.ACLAction[];
    blob?: Schemas.ACLAction[];
    budget?: Schemas.ACLAction[];
    cacheArtifact?: Schemas.ACLAction[];
    cacheArtifactUsageEvent?: Schemas.ACLAction[];
    codeChecks?: Schemas.ACLAction[];
    concurrentBuilds?: Schemas.ACLAction[];
    connect?: Schemas.ACLAction[];
    connectConfiguration?: Schemas.ACLAction[];
    domain?: Schemas.ACLAction[];
    domainAcceptDelegation?: Schemas.ACLAction[];
    domainAuthCodes?: Schemas.ACLAction[];
    domainCertificate?: Schemas.ACLAction[];
    domainCheckConfig?: Schemas.ACLAction[];
    domainMove?: Schemas.ACLAction[];
    domainPurchase?: Schemas.ACLAction[];
    domainRecord?: Schemas.ACLAction[];
    domainTransferIn?: Schemas.ACLAction[];
    event?: Schemas.ACLAction[];
    ownEvent?: Schemas.ACLAction[];
    sensitiveEnvironmentVariablePolicy?: Schemas.ACLAction[];
    fileUpload?: Schemas.ACLAction[];
    gitRepository?: Schemas.ACLAction[];
    ipBlocking?: Schemas.ACLAction[];
    integration?: Schemas.ACLAction[];
    integrationAccount?: Schemas.ACLAction[];
    integrationConfiguration?: Schemas.ACLAction[];
    integrationConfigurationTransfer?: Schemas.ACLAction[];
    integrationConfigurationProjects?: Schemas.ACLAction[];
    integrationVercelConfigurationOverride?: Schemas.ACLAction[];
    integrationResource?: Schemas.ACLAction[];
    integrationEvent?: Schemas.ACLAction[];
    integrationResourceSecrets?: Schemas.ACLAction[];
    marketplaceBillingData?: Schemas.ACLAction[];
    marketplaceInvoice?: Schemas.ACLAction[];
    jobGlobal?: Schemas.ACLAction[];
    logDrain?: Schemas.ACLAction[];
    Monitoring?: Schemas.ACLAction[];
    monitoringSettings?: Schemas.ACLAction[];
    monitoringQuery?: Schemas.ACLAction[];
    monitoringChart?: Schemas.ACLAction[];
    monitoringAlert?: Schemas.ACLAction[];
    notificationDeploymentFailed?: Schemas.ACLAction[];
    notificationDomainConfiguration?: Schemas.ACLAction[];
    notificationDomainExpire?: Schemas.ACLAction[];
    notificationDomainMoved?: Schemas.ACLAction[];
    notificationDomainPurchase?: Schemas.ACLAction[];
    notificationDomainRenewal?: Schemas.ACLAction[];
    notificationDomainTransfer?: Schemas.ACLAction[];
    notificationDomainUnverified?: Schemas.ACLAction[];
    NotificationMonitoringAlert?: Schemas.ACLAction[];
    notificationPaymentFailed?: Schemas.ACLAction[];
    notificationUsageAlert?: Schemas.ACLAction[];
    notificationCustomerBudget?: Schemas.ACLAction[];
    notificationStatementOfReasons?: Schemas.ACLAction[];
    oauth2Connection?: Schemas.ACLAction[];
    openTelemetryEndpoint?: Schemas.ACLAction[];
    paymentMethod?: Schemas.ACLAction[];
    permissions?: Schemas.ACLAction[];
    postgres?: Schemas.ACLAction[];
    previewDeploymentSuffix?: Schemas.ACLAction[];
    proTrialOnboarding?: Schemas.ACLAction[];
    sharedEnvVars?: Schemas.ACLAction[];
    sharedEnvVarsProduction?: Schemas.ACLAction[];
    space?: Schemas.ACLAction[];
    spaceRun?: Schemas.ACLAction[];
    passwordProtectionInvoiceItem?: Schemas.ACLAction[];
    rateLimit?: Schemas.ACLAction[];
    redis?: Schemas.ACLAction[];
    repository?: Schemas.ACLAction[];
    remoteCaching?: Schemas.ACLAction[];
    samlConfig?: Schemas.ACLAction[];
    secret?: Schemas.ACLAction[];
    redisStoreTokenSet?: Schemas.ACLAction[];
    blobStoreTokenSet?: Schemas.ACLAction[];
    postgresStoreTokenSet?: Schemas.ACLAction[];
    integrationStoreTokenSet?: Schemas.ACLAction[];
    supportCase?: Schemas.ACLAction[];
    supportCaseComment?: Schemas.ACLAction[];
    dataCacheBillingSettings?: Schemas.ACLAction[];
    team?: Schemas.ACLAction[];
    teamAccessRequest?: Schemas.ACLAction[];
    teamFellowMembership?: Schemas.ACLAction[];
    teamGitExclusivity?: Schemas.ACLAction[];
    teamInvite?: Schemas.ACLAction[];
    teamInviteCode?: Schemas.ACLAction[];
    teamJoin?: Schemas.ACLAction[];
    teamOwnMembership?: Schemas.ACLAction[];
    teamOwnMembershipDisconnectSAML?: Schemas.ACLAction[];
    token?: Schemas.ACLAction[];
    usage?: Schemas.ACLAction[];
    usageCycle?: Schemas.ACLAction[];
    user?: Schemas.ACLAction[];
    userConnection?: Schemas.ACLAction[];
    webAnalyticsPlan?: Schemas.ACLAction[];
    webAuthn?: Schemas.ACLAction[];
    edgeConfig?: Schemas.ACLAction[];
    edgeConfigItem?: Schemas.ACLAction[];
    edgeConfigSchema?: Schemas.ACLAction[];
    edgeConfigToken?: Schemas.ACLAction[];
    webhook?: Schemas.ACLAction[];
    ['webhook-event']?: Schemas.ACLAction[];
    endpointVerification?: Schemas.ACLAction[];
    projectTransferIn?: Schemas.ACLAction[];
    oauth2Application?: Schemas.ACLAction[];
    aliasProject?: Schemas.ACLAction[];
    aliasProtectionBypass?: Schemas.ACLAction[];
    productionAliasProtectionBypass?: Schemas.ACLAction[];
    connectConfigurationLink?: Schemas.ACLAction[];
    dataCacheNamespace?: Schemas.ACLAction[];
    deployment?: Schemas.ACLAction[];
    deploymentCheck?: Schemas.ACLAction[];
    deploymentCheckPreview?: Schemas.ACLAction[];
    deploymentCheckReRunFromProductionBranch?: Schemas.ACLAction[];
    deploymentProductionGit?: Schemas.ACLAction[];
    deploymentPreview?: Schemas.ACLAction[];
    deploymentPrivate?: Schemas.ACLAction[];
    deploymentPromote?: Schemas.ACLAction[];
    deploymentRollback?: Schemas.ACLAction[];
    environments?: Schemas.ACLAction[];
    logs?: Schemas.ACLAction[];
    logsPreset?: Schemas.ACLAction[];
    passwordProtection?: Schemas.ACLAction[];
    optionsAllowlist?: Schemas.ACLAction[];
    job?: Schemas.ACLAction[];
    project?: Schemas.ACLAction[];
    projectAccessGroup?: Schemas.ACLAction[];
    projectAnalyticsSampling?: Schemas.ACLAction[];
    projectDeploymentHook?: Schemas.ACLAction[];
    projectDomain?: Schemas.ACLAction[];
    projectDomainMove?: Schemas.ACLAction[];
    projectDomainCheckConfig?: Schemas.ACLAction[];
    projectEnvVars?: Schemas.ACLAction[];
    projectEnvVarsProduction?: Schemas.ACLAction[];
    projectEnvVarsUnownedByIntegration?: Schemas.ACLAction[];
    projectId?: Schemas.ACLAction[];
    projectIntegrationConfiguration?: Schemas.ACLAction[];
    projectLink?: Schemas.ACLAction[];
    projectMember?: Schemas.ACLAction[];
    projectMonitoring?: Schemas.ACLAction[];
    projectPermissions?: Schemas.ACLAction[];
    projectProductionBranch?: Schemas.ACLAction[];
    projectTransfer?: Schemas.ACLAction[];
    projectTransferOut?: Schemas.ACLAction[];
    projectProtectionBypass?: Schemas.ACLAction[];
    projectUsage?: Schemas.ACLAction[];
    projectAnalyticsUsage?: Schemas.ACLAction[];
    projectSupportCase?: Schemas.ACLAction[];
    projectSupportCaseComment?: Schemas.ACLAction[];
    projectDeploymentExpiration?: Schemas.ACLAction[];
    seawallConfig?: Schemas.ACLAction[];
    skewProtection?: Schemas.ACLAction[];
    analytics?: Schemas.ACLAction[];
    trustedIps?: Schemas.ACLAction[];
    webAnalytics?: Schemas.ACLAction[];
    sharedEnvVarConnection?: Schemas.ACLAction[];
  };
  lastRollbackTarget?: Record<string, any> | null;
  lastAliasRequest?: {
    fromDeploymentId: string;
    toDeploymentId: string;
    jobStatus: 'succeeded' | 'failed' | 'skipped' | 'pending' | 'in-progress';
    requestedAt: number;
    type: 'promote' | 'rollback';
  } | null;
  hasFloatingAliases?: boolean;
  protectionBypass?: {
    [key: string]: {
      createdAt: number;
      createdBy: string;
      scope: 'automation-bypass';
    };
  };
  hasActiveBranches?: boolean;
  trustedIps?:
    | {
        deploymentType: 'all' | 'preview' | 'prod_deployment_urls_and_all_previews' | 'production';
        addresses: {
          value: string;
          note?: string;
        }[];
        protectionMode: 'additional' | 'exclusive';
      }
    | {
        deploymentType: 'all' | 'preview' | 'prod_deployment_urls_and_all_previews' | 'production';
      }
    | null;
  gitComments?: {
    /**
     * Whether the Vercel bot should comment on PRs
     */
    onPullRequest: boolean;
    /**
     * Whether the Vercel bot should comment on commits
     */
    onCommit: boolean;
  };
  paused?: boolean;
  concurrencyBucketName?: string;
  webAnalytics?: {
    id: string;
    disabledAt?: number;
    canceledAt?: number;
    enabledAt?: number;
    hasData?: boolean;
  };
  security?: {
    attackModeEnabled?: boolean;
    attackModeUpdatedAt?: number;
    firewallEnabled?: boolean;
    firewallUpdatedAt?: number;
    attackModeActiveUntil?: number | null;
    firewallConfigVersion?: number;
    firewallRoutes?: {
      src?:
        | string
        | {
            re?: string;
            eq?: string;
            neq?: string;
            inc?: string[];
            ninc?: string[];
            pre?: string;
            suf?: string;
            gt?: number;
            gte?: number;
            lt?: number;
            lte?: number;
          };
      has?: {
        type:
          | 'host'
          | 'method'
          | 'path'
          | 'header'
          | 'cookie'
          | 'query'
          | 'ip_address'
          | 'protocol'
          | 'scheme'
          | 'region';
        key?: string;
        value?:
          | string
          | {
              re?: string;
              eq?: string;
              neq?: string;
              inc?: string[];
              ninc?: string[];
              pre?: string;
              suf?: string;
              gt?: number;
              gte?: number;
              lt?: number;
              lte?: number;
            };
      }[];
      missing?: {
        type:
          | 'host'
          | 'method'
          | 'path'
          | 'header'
          | 'cookie'
          | 'query'
          | 'ip_address'
          | 'protocol'
          | 'scheme'
          | 'region';
        key?: string;
        value?:
          | string
          | {
              re?: string;
              eq?: string;
              neq?: string;
              inc?: string[];
              ninc?: string[];
              pre?: string;
              suf?: string;
              gt?: number;
              gte?: number;
              lt?: number;
              lte?: number;
            };
      }[];
      dest?: string;
      status?: number;
      handle?: 'init' | 'finalize';
      mitigate?: {
        action: 'deny' | 'challenge' | 'log' | 'bypass' | 'rate_limit';
        rule_id: string;
        erl?: {
          algo: 'fixed_window' | 'token_bucket';
          window: number;
          limit: number;
          keys: string[];
        };
      };
    }[];
    firewallSeawallEnabled?: boolean;
    ja3Enabled?: boolean;
    ja4Enabled?: boolean;
  };
  oidcTokenConfig?: {
    enabled: boolean;
  };
};

export type UpdateProjectDataCacheRequestBody = {
  /**
   * Enable or disable data cache for the project - default: false
   *
   * @example true
   */
  disabled?: boolean;
};

export type UpdateProjectDataCacheVariables = {
  body?: UpdateProjectDataCacheRequestBody;
  pathParams: UpdateProjectDataCachePathParams;
  queryParams?: UpdateProjectDataCacheQueryParams;
} & FetcherExtraProps;

/**
 * Update the data cache feature on a project.
 */
export const updateProjectDataCache = (variables: UpdateProjectDataCacheVariables, signal?: AbortSignal) =>
  fetch<
    UpdateProjectDataCacheResponse,
    UpdateProjectDataCacheError,
    UpdateProjectDataCacheRequestBody,
    {},
    UpdateProjectDataCacheQueryParams,
    UpdateProjectDataCachePathParams
  >({ url: '/v1/data-cache/projects/{projectId}', method: 'patch', ...variables, signal });

export type GetDeploymentEventsPathParams = {
  /**
   * The unique identifier or hostname of the deployment.
   *
   * @example dpl_5WJWYSyB7BpgTj3EuwF37WMRBXBtPQ2iTMJHJBJyRfd
   */
  idOrUrl: string;
};

export type GetDeploymentEventsQueryParams = {
  /**
   * Order of the returned events based on the timestamp.
   *
   * @default forward
   * @example backward
   */
  direction?: 'backward' | 'forward';
  /**
   * When enabled, this endpoint will return live events as they happen.
   *
   * @example 1
   */
  follow?: 0 | 1;
  /**
   * Maximum number of events to return. Provide `-1` to return all available logs.
   *
   * @example 100
   */
  limit?: number;
  /**
   * Deployment build ID.
   *
   * @example bld_cotnkcr76
   */
  name?: string;
  /**
   * Timestamp for when build logs should be pulled from.
   *
   * @example 1540095775941
   */
  since?: number;
  /**
   * Timestamp for when the build logs should be pulled up until.
   *
   * @example 1540106318643
   */
  until?: number;
  /**
   * HTTP status code range to filter events by.
   *
   * @example 5xx
   */
  statusCode?: number | string;
  /**
   * @example 1
   */
  delimiter?: 0 | 1;
  /**
   * @example 1
   */
  builds?: 0 | 1;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetDeploymentEventsError = Fetcher.ErrorWrapper<undefined>;

export type GetDeploymentEventsResponse = (
  | {
      created: number;
      date: number;
      deploymentId: string;
      id: string;
      info: {
        type: string;
        name: string;
        entrypoint?: string;
        path?: string;
        step?: string;
        readyState?: string;
      };
      proxy?: {
        timestamp: number;
        method: string;
        host: string;
        path: string;
        statusCode?: number;
        userAgent: string[];
        referer: string;
        clientIp: string;
        region: string;
        scheme?: string;
        responseByteSize?: number;
        cacheId?: string;
        pathType?: string;
        vercelId?: string;
        vercelCache?: 'MISS' | 'HIT' | 'STALE' | 'BYPASS' | 'PRERENDER' | 'REVALIDATED';
        lambdaRegion?: string;
      };
      requestId?: string;
      serial: string;
      statusCode?: number;
      text?: string;
      type:
        | 'command'
        | 'stdout'
        | 'stderr'
        | 'exit'
        | 'deployment-state'
        | 'delimiter'
        | 'middleware'
        | 'middleware-invocation'
        | 'edge-function-invocation'
        | 'fatal';
    }
  | {
      type:
        | 'command'
        | 'stdout'
        | 'stderr'
        | 'exit'
        | 'deployment-state'
        | 'delimiter'
        | 'middleware'
        | 'middleware-invocation'
        | 'edge-function-invocation'
        | 'fatal';
      created: number;
      payload: {
        deploymentId: string;
        info?: {
          type: string;
          name: string;
          entrypoint?: string;
          path?: string;
          step?: string;
          readyState?: string;
        };
        text?: string;
        id: string;
        date: number;
        serial: string;
        created?: number;
        statusCode?: number;
        requestId?: string;
        proxy?: {
          timestamp: number;
          method: string;
          host: string;
          path: string;
          statusCode?: number;
          userAgent: string[];
          referer: string;
          clientIp: string;
          region: string;
          scheme?: string;
          responseByteSize?: number;
          cacheId?: string;
          pathType?: string;
          vercelId?: string;
          vercelCache?: 'MISS' | 'HIT' | 'STALE' | 'BYPASS' | 'PRERENDER' | 'REVALIDATED';
          lambdaRegion?: string;
        };
      };
    }
)[];

export type GetDeploymentEventsVariables = {
  pathParams: GetDeploymentEventsPathParams;
  queryParams?: GetDeploymentEventsQueryParams;
} & FetcherExtraProps;

/**
 * Get the build logs of a deployment by deployment ID and build ID. It can work as an infinite stream of logs or as a JSON endpoint depending on the input parameters.
 */
export const getDeploymentEvents = (variables: GetDeploymentEventsVariables, signal?: AbortSignal) =>
  fetch<
    GetDeploymentEventsResponse,
    GetDeploymentEventsError,
    undefined,
    {},
    GetDeploymentEventsQueryParams,
    GetDeploymentEventsPathParams
  >({ url: '/v3/deployments/{idOrUrl}/events', method: 'get', ...variables, signal });

export type GetDeploymentPathParams = {
  /**
   * The unique identifier or hostname of the deployment.
   *
   * @example dpl_89qyp1cskzkLrVicDaZoDbjyHuDJ
   */
  idOrUrl: string;
};

export type GetDeploymentQueryParams = {
  /**
   * Whether to add in gitRepo information.
   *
   * @example true
   */
  withGitRepoInfo?: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetDeploymentError = Fetcher.ErrorWrapper<undefined>;

export type GetDeploymentVariables = {
  pathParams: GetDeploymentPathParams;
  queryParams?: GetDeploymentQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves information for a deployment either by supplying its ID (`id` property) or Hostname (`url` property). Additional details will be included when the authenticated user or team is an owner of the deployment.
 */
export const getDeployment = (variables: GetDeploymentVariables, signal?: AbortSignal) =>
  fetch<
    | {
        aliasAssignedAt?: number | boolean | null;
        alwaysRefuseToBuild?: boolean;
        build: {
          env: string[];
        };
        builds?: Record<string, any>[];
        env: string[];
        inspectorUrl: string | null;
        isInConcurrentBuildsQueue: boolean;
        projectSettings: {
          buildCommand?: string | null;
          devCommand?: string | null;
          framework?:
            | 'blitzjs'
            | 'nextjs'
            | 'gatsby'
            | 'remix'
            | 'astro'
            | 'hexo'
            | 'eleventy'
            | 'docusaurus-2'
            | 'docusaurus'
            | 'preact'
            | 'solidstart-1'
            | 'solidstart'
            | 'dojo'
            | 'ember'
            | 'vue'
            | 'scully'
            | 'ionic-angular'
            | 'angular'
            | 'polymer'
            | 'svelte'
            | 'sveltekit'
            | 'sveltekit-1'
            | 'ionic-react'
            | 'create-react-app'
            | 'gridsome'
            | 'umijs'
            | 'sapper'
            | 'saber'
            | 'stencil'
            | 'nuxtjs'
            | 'redwoodjs'
            | 'hugo'
            | 'jekyll'
            | 'brunch'
            | 'middleman'
            | 'zola'
            | 'hydrogen'
            | 'vite'
            | 'vitepress'
            | 'vuepress'
            | 'parcel'
            | 'sanity'
            | 'storybook'
            | null;
          commandForIgnoringBuildStep?: string | null;
          installCommand?: string | null;
          outputDirectory?: string | null;
          speedInsights?: {
            id: string;
            enabledAt?: number;
            disabledAt?: number;
            canceledAt?: number;
            hasData?: boolean;
            paidAt?: number;
          };
          webAnalytics?: {
            id: string;
            disabledAt?: number;
            canceledAt?: number;
            enabledAt?: number;
            hasData?: boolean;
          };
        };
        readyStateReason?: string;
        alias?: string[];
        aliasAssigned: boolean;
        bootedAt: number;
        buildingAt: number;
        buildSkipped: boolean;
        creator: {
          uid: string;
          username?: string;
          avatar?: string;
        };
        initReadyAt?: number;
        isFirstBranchDeployment?: boolean;
        lambdas?: {
          buildCommand?: string | null;
          devCommand?: string | null;
          framework?:
            | 'blitzjs'
            | 'nextjs'
            | 'gatsby'
            | 'remix'
            | 'astro'
            | 'hexo'
            | 'eleventy'
            | 'docusaurus-2'
            | 'docusaurus'
            | 'preact'
            | 'solidstart-1'
            | 'solidstart'
            | 'dojo'
            | 'ember'
            | 'vue'
            | 'scully'
            | 'ionic-angular'
            | 'angular'
            | 'polymer'
            | 'svelte'
            | 'sveltekit'
            | 'sveltekit-1'
            | 'ionic-react'
            | 'create-react-app'
            | 'gridsome'
            | 'umijs'
            | 'sapper'
            | 'saber'
            | 'stencil'
            | 'nuxtjs'
            | 'redwoodjs'
            | 'hugo'
            | 'jekyll'
            | 'brunch'
            | 'middleman'
            | 'zola'
            | 'hydrogen'
            | 'vite'
            | 'vitepress'
            | 'vuepress'
            | 'parcel'
            | 'sanity'
            | 'storybook'
            | null;
          commandForIgnoringBuildStep?: string | null;
          installCommand?: string | null;
          outputDirectory?: string | null;
          speedInsights?: {
            id: string;
            enabledAt?: number;
            disabledAt?: number;
            canceledAt?: number;
            hasData?: boolean;
            paidAt?: number;
          };
          webAnalytics?: {
            id: string;
            disabledAt?: number;
            canceledAt?: number;
            enabledAt?: number;
            hasData?: boolean;
          };
          output: {
            path: string;
            functionName: string;
          }[];
        }[];
        public: boolean;
        ready?: number;
        status: 'QUEUED' | 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'READY' | 'CANCELED';
        team?: {
          buildCommand?: string | null;
          devCommand?: string | null;
          framework?:
            | 'blitzjs'
            | 'nextjs'
            | 'gatsby'
            | 'remix'
            | 'astro'
            | 'hexo'
            | 'eleventy'
            | 'docusaurus-2'
            | 'docusaurus'
            | 'preact'
            | 'solidstart-1'
            | 'solidstart'
            | 'dojo'
            | 'ember'
            | 'vue'
            | 'scully'
            | 'ionic-angular'
            | 'angular'
            | 'polymer'
            | 'svelte'
            | 'sveltekit'
            | 'sveltekit-1'
            | 'ionic-react'
            | 'create-react-app'
            | 'gridsome'
            | 'umijs'
            | 'sapper'
            | 'saber'
            | 'stencil'
            | 'nuxtjs'
            | 'redwoodjs'
            | 'hugo'
            | 'jekyll'
            | 'brunch'
            | 'middleman'
            | 'zola'
            | 'hydrogen'
            | 'vite'
            | 'vitepress'
            | 'vuepress'
            | 'parcel'
            | 'sanity'
            | 'storybook'
            | null;
          commandForIgnoringBuildStep?: string | null;
          installCommand?: string | null;
          outputDirectory?: string | null;
          speedInsights?: {
            id: string;
            enabledAt?: number;
            disabledAt?: number;
            canceledAt?: number;
            hasData?: boolean;
            paidAt?: number;
          };
          webAnalytics?: {
            id: string;
            disabledAt?: number;
            canceledAt?: number;
            enabledAt?: number;
            hasData?: boolean;
          };
        };
        userAliases?: string[];
        previewCommentsEnabled?: boolean;
        ttyBuildLogs?: boolean;
        customEnvironment?:
          | {
              id: string;
              name: string;
              slug: string;
              type: 'production' | 'preview' | 'development';
              description?: string;
              branchMatcher?: {
                type: 'startsWith' | 'equals' | 'endsWith';
                pattern: string;
              };
              createdAt: number;
              updatedAt: number;
            }
          | {
              id: string;
            };
        aliasWarning?: {
          code: string;
          message: string;
          link?: string;
          action?: string;
        } | null;
        aliasError?: {
          code: string;
          message: string;
        } | null;
        aliasFinal?: string | null;
        automaticAliases?: string[];
        /**
         * applies to custom domains only, defaults to `true`
         */
        autoAssignCustomDomains?: boolean;
        type: 'LAMBDAS';
        id: string;
        createdAt: number;
        deletedAt?: number | null;
        name: string;
        version: 2;
        readyState: 'QUEUED' | 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'READY' | 'CANCELED';
        buildErrorAt?: number;
        checksState?: 'registered' | 'running' | 'completed';
        checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
        canceledAt?: number;
        errorCode?: string;
        errorLink?: string;
        errorMessage?: string | null;
        errorStep?: string;
        /**
         * Since November 2023 this field defines a set of regions that we will deploy the lambda to passively Lambdas will be deployed to these regions but only invoked if all of the primary `regions` are marked as out of service
         */
        passiveRegions?: string[];
        gitSource?:
          | {
              type: 'github';
              repoId: string | number;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'github';
              org: string;
              repo: string;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'gitlab';
              projectId: string | number;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'bitbucket';
              workspaceUuid?: string;
              repoUuid: string;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'bitbucket';
              owner: string;
              slug: string;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'custom';
              ref: string;
              sha: string;
              gitUrl: string;
            }
          | {
              type: 'github';
              ref: string;
              sha: string;
              repoId: number;
              org?: string;
              repo?: string;
            }
          | {
              type: 'gitlab';
              ref: string;
              sha: string;
              projectId: number;
            }
          | {
              type: 'bitbucket';
              ref: string;
              sha: string;
              owner?: string;
              slug?: string;
              workspaceUuid: string;
              repoUuid: string;
            };
        meta: {
          [key: string]: string;
        };
        project?: {
          id: string;
          name: string;
          framework?: string | null;
        };
        /**
         * Since June 2023 Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - PROMOTED: has seen production traffic
         */
        readySubstate?: 'STAGED' | 'PROMOTED';
        regions: string[];
        source?: 'api-trigger-git-deploy' | 'cli' | 'clone/repo' | 'git' | 'import' | 'import/repo';
        target?: 'staging' | 'production' | null;
        undeletedAt?: number;
        url: string;
        oidcTokenClaims?: {
          [key: string]: string;
        };
        plan: 'pro' | 'enterprise' | 'hobby';
        connectBuildsEnabled?: boolean;
        connectConfigurationId?: string;
        createdIn: string;
        crons?: {
          schedule: string;
          path: string;
        }[];
        functions?: {
          [key: string]: {
            memory?: number;
            maxDuration?: number;
            runtime?: string;
            includeFiles?: string;
            excludeFiles?: string;
          };
        } | null;
        monorepoManager?: string | null;
        ownerId: string;
        /**
         * Since November 2023 this field defines a connect configuration that will only be used to deploy passive lambdas to (as in passiveRegions)
         */
        passiveConnectConfigurationId?: string;
        projectId: string;
        routes:
          | (
              | {
                  src: string;
                  dest?: string;
                  headers?: {
                    [key: string]: string;
                  };
                  methods?: string[];
                  ['continue']?: boolean;
                  override?: boolean;
                  caseSensitive?: boolean;
                  check?: boolean;
                  important?: boolean;
                  status?: number;
                  has?: (
                    | {
                        type: 'host';
                        value: string;
                      }
                    | {
                        type: 'header' | 'cookie' | 'query';
                        key: string;
                        value?: string;
                      }
                  )[];
                  missing?: (
                    | {
                        type: 'host';
                        value: string;
                      }
                    | {
                        type: 'header' | 'cookie' | 'query';
                        key: string;
                        value?: string;
                      }
                  )[];
                  locale?: {
                    redirect?: {
                      [key: string]: string;
                    };
                    cookie?: string;
                  };
                  /**
                   * A middleware key within the `output` key under the build result. Overrides a `middleware` definition.
                   */
                  middlewarePath?: string;
                  /**
                   * The original middleware matchers.
                   */
                  middlewareRawSrc?: string[];
                  /**
                   * A middleware index in the `middleware` key under the build result
                   */
                  middleware?: number;
                }
              | {
                  handle: 'error' | 'filesystem' | 'hit' | 'miss' | 'rewrite' | 'resource';
                  src?: string;
                  dest?: string;
                  status?: number;
                }
              | {
                  src: string;
                  ['continue']: boolean;
                  middleware: 0;
                }
            )[]
          | null;
        gitRepo?:
          | {
              namespace: string;
              projectId: number;
              type: 'gitlab';
              url: string;
              path: string;
              defaultBranch: string;
              name: string;
              private: boolean;
              ownerType: 'team' | 'user';
            }
          | {
              org: string;
              repo: string;
              repoId: number;
              type: 'github';
              repoOwnerId: string;
              path: string;
              defaultBranch: string;
              name: string;
              private: boolean;
              ownerType: 'team' | 'user';
            }
          | {
              owner: string;
              repoUuid: string;
              slug: string;
              type: 'bitbucket';
              workspaceUuid: string;
              path: string;
              defaultBranch: string;
              name: string;
              private: boolean;
              ownerType: 'team' | 'user';
            }
          | null;
        flags?:
          | {
              definitions: {
                [key: string]: string;
              };
            }
          | Record<string, any>[];
      }
    | {
        alias?: string[];
        aliasAssigned: boolean;
        bootedAt: number;
        buildingAt: number;
        buildSkipped: boolean;
        creator: {
          uid: string;
          username?: string;
          avatar?: string;
        };
        initReadyAt?: number;
        isFirstBranchDeployment?: boolean;
        lambdas?: {
          buildCommand?: string | null;
          devCommand?: string | null;
          framework?:
            | 'blitzjs'
            | 'nextjs'
            | 'gatsby'
            | 'remix'
            | 'astro'
            | 'hexo'
            | 'eleventy'
            | 'docusaurus-2'
            | 'docusaurus'
            | 'preact'
            | 'solidstart-1'
            | 'solidstart'
            | 'dojo'
            | 'ember'
            | 'vue'
            | 'scully'
            | 'ionic-angular'
            | 'angular'
            | 'polymer'
            | 'svelte'
            | 'sveltekit'
            | 'sveltekit-1'
            | 'ionic-react'
            | 'create-react-app'
            | 'gridsome'
            | 'umijs'
            | 'sapper'
            | 'saber'
            | 'stencil'
            | 'nuxtjs'
            | 'redwoodjs'
            | 'hugo'
            | 'jekyll'
            | 'brunch'
            | 'middleman'
            | 'zola'
            | 'hydrogen'
            | 'vite'
            | 'vitepress'
            | 'vuepress'
            | 'parcel'
            | 'sanity'
            | 'storybook'
            | null;
          commandForIgnoringBuildStep?: string | null;
          installCommand?: string | null;
          outputDirectory?: string | null;
          speedInsights?: {
            id: string;
            enabledAt?: number;
            disabledAt?: number;
            canceledAt?: number;
            hasData?: boolean;
            paidAt?: number;
          };
          webAnalytics?: {
            id: string;
            disabledAt?: number;
            canceledAt?: number;
            enabledAt?: number;
            hasData?: boolean;
          };
          output: {
            path: string;
            functionName: string;
          }[];
        }[];
        public: boolean;
        ready?: number;
        status: 'QUEUED' | 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'READY' | 'CANCELED';
        team?: {
          buildCommand?: string | null;
          devCommand?: string | null;
          framework?:
            | 'blitzjs'
            | 'nextjs'
            | 'gatsby'
            | 'remix'
            | 'astro'
            | 'hexo'
            | 'eleventy'
            | 'docusaurus-2'
            | 'docusaurus'
            | 'preact'
            | 'solidstart-1'
            | 'solidstart'
            | 'dojo'
            | 'ember'
            | 'vue'
            | 'scully'
            | 'ionic-angular'
            | 'angular'
            | 'polymer'
            | 'svelte'
            | 'sveltekit'
            | 'sveltekit-1'
            | 'ionic-react'
            | 'create-react-app'
            | 'gridsome'
            | 'umijs'
            | 'sapper'
            | 'saber'
            | 'stencil'
            | 'nuxtjs'
            | 'redwoodjs'
            | 'hugo'
            | 'jekyll'
            | 'brunch'
            | 'middleman'
            | 'zola'
            | 'hydrogen'
            | 'vite'
            | 'vitepress'
            | 'vuepress'
            | 'parcel'
            | 'sanity'
            | 'storybook'
            | null;
          commandForIgnoringBuildStep?: string | null;
          installCommand?: string | null;
          outputDirectory?: string | null;
          speedInsights?: {
            id: string;
            enabledAt?: number;
            disabledAt?: number;
            canceledAt?: number;
            hasData?: boolean;
            paidAt?: number;
          };
          webAnalytics?: {
            id: string;
            disabledAt?: number;
            canceledAt?: number;
            enabledAt?: number;
            hasData?: boolean;
          };
        };
        userAliases?: string[];
        previewCommentsEnabled?: boolean;
        ttyBuildLogs?: boolean;
        customEnvironment?:
          | {
              id: string;
              name: string;
              slug: string;
              type: 'production' | 'preview' | 'development';
              description?: string;
              branchMatcher?: {
                type: 'startsWith' | 'equals' | 'endsWith';
                pattern: string;
              };
              createdAt: number;
              updatedAt: number;
            }
          | {
              id: string;
            };
        aliasWarning?: {
          code: string;
          message: string;
          link?: string;
          action?: string;
        } | null;
        aliasError?: {
          code: string;
          message: string;
        } | null;
        aliasFinal?: string | null;
        automaticAliases?: string[];
        /**
         * applies to custom domains only, defaults to `true`
         */
        autoAssignCustomDomains?: boolean;
        type: 'LAMBDAS';
        id: string;
        createdAt: number;
        deletedAt?: number | null;
        name: string;
        version: 2;
        readyState: 'QUEUED' | 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'READY' | 'CANCELED';
        buildErrorAt?: number;
        checksState?: 'registered' | 'running' | 'completed';
        checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
        canceledAt?: number;
        errorCode?: string;
        errorLink?: string;
        errorMessage?: string | null;
        errorStep?: string;
        /**
         * Since November 2023 this field defines a set of regions that we will deploy the lambda to passively Lambdas will be deployed to these regions but only invoked if all of the primary `regions` are marked as out of service
         */
        passiveRegions?: string[];
        gitSource?:
          | {
              type: 'github';
              repoId: string | number;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'github';
              org: string;
              repo: string;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'gitlab';
              projectId: string | number;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'bitbucket';
              workspaceUuid?: string;
              repoUuid: string;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'bitbucket';
              owner: string;
              slug: string;
              ref?: string | null;
              sha?: string;
              prId?: number | null;
            }
          | {
              type: 'custom';
              ref: string;
              sha: string;
              gitUrl: string;
            }
          | {
              type: 'github';
              ref: string;
              sha: string;
              repoId: number;
              org?: string;
              repo?: string;
            }
          | {
              type: 'gitlab';
              ref: string;
              sha: string;
              projectId: number;
            }
          | {
              type: 'bitbucket';
              ref: string;
              sha: string;
              owner?: string;
              slug?: string;
              workspaceUuid: string;
              repoUuid: string;
            };
        meta: {
          [key: string]: string;
        };
        project?: {
          id: string;
          name: string;
          framework?: string | null;
        };
        /**
         * Since June 2023 Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - PROMOTED: has seen production traffic
         */
        readySubstate?: 'STAGED' | 'PROMOTED';
        regions: string[];
        source?: 'api-trigger-git-deploy' | 'cli' | 'clone/repo' | 'git' | 'import' | 'import/repo';
        target?: 'staging' | 'production' | null;
        undeletedAt?: number;
        url: string;
        oidcTokenClaims?: {
          [key: string]: string;
        };
      },
    GetDeploymentError,
    undefined,
    {},
    GetDeploymentQueryParams,
    GetDeploymentPathParams
  >({ url: '/v13/deployments/{idOrUrl}', method: 'get', ...variables, signal });

export type CreateDeploymentQueryParams = {
  /**
   * Forces a new deployment even if there is a previous similar deployment
   */
  forceNew?: '0' | '1';
  /**
   * Allows to skip framework detection so the API would not fail to ask for confirmation
   */
  skipAutoDetectionConfirmation?: '0' | '1';
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type CreateDeploymentError = Fetcher.ErrorWrapper<undefined>;

export type CreateDeploymentResponse = {
  aliasAssignedAt?: number | boolean | null;
  alwaysRefuseToBuild?: boolean;
  build: {
    env: string[];
  };
  builds?: Record<string, any>[];
  env: string[];
  inspectorUrl: string | null;
  isInConcurrentBuildsQueue: boolean;
  projectSettings: {
    buildCommand?: string | null;
    commandForIgnoringBuildStep?: string | null;
    devCommand?: string | null;
    framework?:
      | 'blitzjs'
      | 'nextjs'
      | 'gatsby'
      | 'remix'
      | 'astro'
      | 'hexo'
      | 'eleventy'
      | 'docusaurus-2'
      | 'docusaurus'
      | 'preact'
      | 'solidstart-1'
      | 'solidstart'
      | 'dojo'
      | 'ember'
      | 'vue'
      | 'scully'
      | 'ionic-angular'
      | 'angular'
      | 'polymer'
      | 'svelte'
      | 'sveltekit'
      | 'sveltekit-1'
      | 'ionic-react'
      | 'create-react-app'
      | 'gridsome'
      | 'umijs'
      | 'sapper'
      | 'saber'
      | 'stencil'
      | 'nuxtjs'
      | 'redwoodjs'
      | 'hugo'
      | 'jekyll'
      | 'brunch'
      | 'middleman'
      | 'zola'
      | 'hydrogen'
      | 'vite'
      | 'vitepress'
      | 'vuepress'
      | 'parcel'
      | 'sanity'
      | 'storybook'
      | null;
    installCommand?: string | null;
    outputDirectory?: string | null;
    speedInsights?: {
      id: string;
      enabledAt?: number;
      disabledAt?: number;
      canceledAt?: number;
      hasData?: boolean;
      paidAt?: number;
    };
    webAnalytics?: {
      id: string;
      disabledAt?: number;
      canceledAt?: number;
      enabledAt?: number;
      hasData?: boolean;
    };
  };
  readyStateReason?: string;
  alias?: string[];
  aliasAssigned: boolean;
  bootedAt: number;
  buildingAt: number;
  buildSkipped: boolean;
  creator: {
    uid: string;
    username?: string;
    avatar?: string;
  };
  initReadyAt?: number;
  isFirstBranchDeployment?: boolean;
  lambdas?: {
    buildCommand?: string | null;
    commandForIgnoringBuildStep?: string | null;
    devCommand?: string | null;
    framework?:
      | 'blitzjs'
      | 'nextjs'
      | 'gatsby'
      | 'remix'
      | 'astro'
      | 'hexo'
      | 'eleventy'
      | 'docusaurus-2'
      | 'docusaurus'
      | 'preact'
      | 'solidstart-1'
      | 'solidstart'
      | 'dojo'
      | 'ember'
      | 'vue'
      | 'scully'
      | 'ionic-angular'
      | 'angular'
      | 'polymer'
      | 'svelte'
      | 'sveltekit'
      | 'sveltekit-1'
      | 'ionic-react'
      | 'create-react-app'
      | 'gridsome'
      | 'umijs'
      | 'sapper'
      | 'saber'
      | 'stencil'
      | 'nuxtjs'
      | 'redwoodjs'
      | 'hugo'
      | 'jekyll'
      | 'brunch'
      | 'middleman'
      | 'zola'
      | 'hydrogen'
      | 'vite'
      | 'vitepress'
      | 'vuepress'
      | 'parcel'
      | 'sanity'
      | 'storybook'
      | null;
    installCommand?: string | null;
    outputDirectory?: string | null;
    speedInsights?: {
      id: string;
      enabledAt?: number;
      disabledAt?: number;
      canceledAt?: number;
      hasData?: boolean;
      paidAt?: number;
    };
    webAnalytics?: {
      id: string;
      disabledAt?: number;
      canceledAt?: number;
      enabledAt?: number;
      hasData?: boolean;
    };
    output: {
      path: string;
      functionName: string;
    }[];
  }[];
  public: boolean;
  ready?: number;
  status: 'CANCELED' | 'ERROR' | 'QUEUED' | 'BUILDING' | 'INITIALIZING' | 'READY';
  team?: {
    buildCommand?: string | null;
    commandForIgnoringBuildStep?: string | null;
    devCommand?: string | null;
    framework?:
      | 'blitzjs'
      | 'nextjs'
      | 'gatsby'
      | 'remix'
      | 'astro'
      | 'hexo'
      | 'eleventy'
      | 'docusaurus-2'
      | 'docusaurus'
      | 'preact'
      | 'solidstart-1'
      | 'solidstart'
      | 'dojo'
      | 'ember'
      | 'vue'
      | 'scully'
      | 'ionic-angular'
      | 'angular'
      | 'polymer'
      | 'svelte'
      | 'sveltekit'
      | 'sveltekit-1'
      | 'ionic-react'
      | 'create-react-app'
      | 'gridsome'
      | 'umijs'
      | 'sapper'
      | 'saber'
      | 'stencil'
      | 'nuxtjs'
      | 'redwoodjs'
      | 'hugo'
      | 'jekyll'
      | 'brunch'
      | 'middleman'
      | 'zola'
      | 'hydrogen'
      | 'vite'
      | 'vitepress'
      | 'vuepress'
      | 'parcel'
      | 'sanity'
      | 'storybook'
      | null;
    installCommand?: string | null;
    outputDirectory?: string | null;
    speedInsights?: {
      id: string;
      enabledAt?: number;
      disabledAt?: number;
      canceledAt?: number;
      hasData?: boolean;
      paidAt?: number;
    };
    webAnalytics?: {
      id: string;
      disabledAt?: number;
      canceledAt?: number;
      enabledAt?: number;
      hasData?: boolean;
    };
  };
  userAliases?: string[];
  previewCommentsEnabled?: boolean;
  ttyBuildLogs?: boolean;
  customEnvironment?:
    | {
        id: string;
        name: string;
        slug: string;
        type: 'production' | 'preview' | 'development';
        description?: string;
        branchMatcher?: {
          type: 'endsWith' | 'startsWith' | 'equals';
          pattern: string;
        };
        createdAt: number;
        updatedAt: number;
      }
    | {
        id: string;
      };
  type: 'LAMBDAS';
  name: string;
  createdAt: number;
  deletedAt?: number | null;
  id: string;
  version: 2;
  /**
   * applies to custom domains only, defaults to `true`
   */
  autoAssignCustomDomains?: boolean;
  gitSource?:
    | {
        type: 'github';
        repoId: string | number;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'github';
        org: string;
        repo: string;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'gitlab';
        projectId: string | number;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'bitbucket';
        workspaceUuid?: string;
        repoUuid: string;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'bitbucket';
        owner: string;
        slug: string;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'custom';
        ref: string;
        sha: string;
        gitUrl: string;
      }
    | {
        type: 'github';
        ref: string;
        sha: string;
        repoId: number;
        org?: string;
        repo?: string;
      }
    | {
        type: 'gitlab';
        ref: string;
        sha: string;
        projectId: number;
      }
    | {
        type: 'bitbucket';
        ref: string;
        sha: string;
        owner?: string;
        slug?: string;
        workspaceUuid: string;
        repoUuid: string;
      };
  meta: {
    [key: string]: string;
  };
  project?: {
    id: string;
    name: string;
    framework?: string | null;
  };
  readyState: 'CANCELED' | 'ERROR' | 'QUEUED' | 'BUILDING' | 'INITIALIZING' | 'READY';
  source?: 'cli' | 'git' | 'import' | 'import/repo' | 'clone/repo' | 'api-trigger-git-deploy';
  target?: 'staging' | 'production' | null;
  /**
   * Since November 2023 this field defines a set of regions that we will deploy the lambda to passively Lambdas will be deployed to these regions but only invoked if all of the primary `regions` are marked as out of service
   */
  passiveRegions?: string[];
  regions: string[];
  errorMessage?: string | null;
  aliasWarning?: {
    code: string;
    message: string;
    link?: string;
    action?: string;
  } | null;
  aliasError?: {
    code: string;
    message: string;
  } | null;
  aliasFinal?: string | null;
  automaticAliases?: string[];
  buildErrorAt?: number;
  checksState?: 'registered' | 'running' | 'completed';
  checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
  canceledAt?: number;
  errorCode?: string;
  errorLink?: string;
  errorStep?: string;
  /**
   * Since June 2023 Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - PROMOTED: has seen production traffic
   */
  readySubstate?: 'STAGED' | 'PROMOTED';
  undeletedAt?: number;
  url: string;
  oidcTokenClaims?: {
    [key: string]: string;
  };
  projectId: string;
  ownerId: string;
  monorepoManager?: string | null;
  functions?: {
    [key: string]: {
      memory?: number;
      maxDuration?: number;
      runtime?: string;
      includeFiles?: string;
      excludeFiles?: string;
    };
  } | null;
  routes:
    | (
        | {
            src: string;
            dest?: string;
            headers?: {
              [key: string]: string;
            };
            methods?: string[];
            ['continue']?: boolean;
            override?: boolean;
            caseSensitive?: boolean;
            check?: boolean;
            important?: boolean;
            status?: number;
            has?: (
              | {
                  type: 'host';
                  value: string;
                }
              | {
                  type: 'header' | 'cookie' | 'query';
                  key: string;
                  value?: string;
                }
            )[];
            missing?: (
              | {
                  type: 'host';
                  value: string;
                }
              | {
                  type: 'header' | 'cookie' | 'query';
                  key: string;
                  value?: string;
                }
            )[];
            locale?: {
              redirect?: {
                [key: string]: string;
              };
              cookie?: string;
            };
            /**
             * A middleware key within the `output` key under the build result. Overrides a `middleware` definition.
             */
            middlewarePath?: string;
            /**
             * The original middleware matchers.
             */
            middlewareRawSrc?: string[];
            /**
             * A middleware index in the `middleware` key under the build result
             */
            middleware?: number;
          }
        | {
            handle: 'error' | 'filesystem' | 'hit' | 'miss' | 'resource' | 'rewrite';
            src?: string;
            dest?: string;
            status?: number;
          }
        | {
            src: string;
            ['continue']: boolean;
            middleware: 0;
          }
      )[]
    | null;
  crons?: {
    schedule: string;
    path: string;
  }[];
  plan: 'pro' | 'enterprise' | 'hobby';
  connectBuildsEnabled?: boolean;
  connectConfigurationId?: string;
  createdIn: string;
  /**
   * Since November 2023 this field defines a connect configuration that will only be used to deploy passive lambdas to (as in passiveRegions)
   */
  passiveConnectConfigurationId?: string;
  gitRepo?:
    | {
        namespace: string;
        projectId: number;
        type: 'gitlab';
        url: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: 'user' | 'team';
      }
    | {
        org: string;
        repo: string;
        repoId: number;
        type: 'github';
        repoOwnerId: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: 'user' | 'team';
      }
    | {
        owner: string;
        repoUuid: string;
        slug: string;
        type: 'bitbucket';
        workspaceUuid: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: 'user' | 'team';
      }
    | null;
  flags?:
    | {
        definitions: {
          [key: string]: string;
        };
      }
    | Record<string, any>[];
};

export type CreateDeploymentRequestBody = {
  /**
   * Deploy to a custom environment, which will override the default environment
   */
  customEnvironmentSlugOrId?: string;
  /**
   * An deployment id for an existing deployment to redeploy
   */
  deploymentId?: string;
  /**
   * A list of objects with the files to be deployed
   */
  files?: (
    | {
        /**
         * The file content, it could be either a `base64` (useful for images, etc.) of the files or the plain content for source code
         */
        data: string;
        /**
         * The file content encoding, it could be either a base64 (useful for images, etc.) of the files or the plain text for source code.
         */
        encoding?: 'base64' | 'utf-8';
        /**
         * The file name including the whole path
         *
         * @example folder/file.js
         */
        file: string;
      }
    | {
        /**
         * The file path relative to the project root
         *
         * @example folder/file.js
         */
        file: string;
        /**
         * The file contents hashed with SHA1, used to check the integrity
         */
        sha?: string;
        /**
         * The file size in bytes
         */
        size?: number;
      }
  )[];
  /**
   * Populates initial git metadata for different git providers.
   */
  gitMetadata?: {
    /**
     * The git repository's remote origin url
     *
     * @example https://github.com/vercel/next.js
     */
    remoteUrl?: string;
    /**
     * The name of the author of the commit
     *
     * @example kyliau
     */
    commitAuthorName?: string;
    /**
     * The commit message
     *
     * @example add method to measure Interaction to Next Paint (INP) (#36490)
     */
    commitMessage?: string;
    /**
     * The branch on which the commit was made
     *
     * @example main
     */
    commitRef?: string;
    /**
     * The hash of the commit
     *
     * @example dc36199b2234c6586ebe05ec94078a895c707e29
     */
    commitSha?: string;
    /**
     * Whether or not there have been modifications to the working tree since the latest commit
     *
     * @example true
     */
    dirty?: boolean;
  };
  /**
   * Defines the Git Repository source to be deployed. This property can not be used in combination with `files`.
   */
  gitSource?:
    | {
        ref: string;
        repoId: number | string;
        sha?: string;
        type: 'github';
      }
    | {
        org: string;
        ref: string;
        repo: string;
        sha?: string;
        type: 'github';
      }
    | {
        projectId: number | string;
        ref: string;
        sha?: string;
        type: 'gitlab';
      }
    | {
        ref: string;
        repoUuid: string;
        sha?: string;
        type: 'bitbucket';
        workspaceUuid?: string;
      }
    | {
        owner: string;
        ref: string;
        sha?: string;
        slug: string;
        type: 'bitbucket';
      };
  /**
   * An object containing the deployment's metadata. Multiple key-value pairs can be attached to a deployment
   *
   * @example {"foo":"bar"}
   * @maxProperties 100
   */
  meta?: {
    [key: string]: string;
  };
  /**
   * The monorepo manager that is being used for this deployment. When `null` is used no monorepo manager is selected
   */
  monorepoManager?: string | null;
  /**
   * A string with the project name used in the deployment URL
   *
   * @example my-instant-deployment
   */
  name: string;
  /**
   * The target project identifier in which the deployment will be created. When defined, this parameter overrides name
   *
   * @example my-deployment-project
   */
  project?: string;
  /**
   * Project settings that will be applied to the deployment. It is required for the first deployment of a project and will be saved for any following deployments
   */
  projectSettings?: {
    /**
     * The build command for this project. When `null` is used this value will be automatically detected
     *
     * @maxLength 256
     */
    buildCommand?: string | null;
    /**
     * @maxLength 256
     */
    commandForIgnoringBuildStep?: string | null;
    /**
     * The dev command for this project. When `null` is used this value will be automatically detected
     *
     * @maxLength 256
     */
    devCommand?: string | null;
    /**
     * The framework that is being used for this project. When `null` is used no framework is selected
     */
    framework?:
      | any
      | 'blitzjs'
      | 'nextjs'
      | 'gatsby'
      | 'remix'
      | 'astro'
      | 'hexo'
      | 'eleventy'
      | 'docusaurus-2'
      | 'docusaurus'
      | 'preact'
      | 'solidstart-1'
      | 'solidstart'
      | 'dojo'
      | 'ember'
      | 'vue'
      | 'scully'
      | 'ionic-angular'
      | 'angular'
      | 'polymer'
      | 'svelte'
      | 'sveltekit'
      | 'sveltekit-1'
      | 'ionic-react'
      | 'create-react-app'
      | 'gridsome'
      | 'umijs'
      | 'sapper'
      | 'saber'
      | 'stencil'
      | 'nuxtjs'
      | 'redwoodjs'
      | 'hugo'
      | 'jekyll'
      | 'brunch'
      | 'middleman'
      | 'zola'
      | 'hydrogen'
      | 'vite'
      | 'vitepress'
      | 'vuepress'
      | 'parcel'
      | 'sanity'
      | 'storybook'
      | null;
    /**
     * The install command for this project. When `null` is used this value will be automatically detected
     *
     * @maxLength 256
     */
    installCommand?: string | null;
    /**
     * Override the Node.js version that should be used for this deployment
     */
    nodeVersion?: '20.x' | '18.x' | '16.x';
    /**
     * The output directory of the project. When `null` is used this value will be automatically detected
     *
     * @maxLength 256
     */
    outputDirectory?: string | null;
    /**
     * The name of a directory or relative path to the source code of your project. When `null` is used it will default to the project root
     *
     * @maxLength 256
     */
    rootDirectory?: string | null;
    /**
     * The region to deploy Serverless Functions in this project
     *
     * @maxLength 4
     */
    serverlessFunctionRegion?: string | null;
    /**
     * Opts-out of the message prompting a CLI user to connect a Git repository in `vercel link`.
     *
     * @deprecated true
     */
    skipGitConnectDuringLink?: boolean;
    /**
     * Indicates if there are source files outside of the root directory, typically used for monorepos
     */
    sourceFilesOutsideRootDirectory?: boolean;
  };
  /**
   * Either not defined, `staging`, or `production`. If `staging`, a staging alias in the format `<project>-<team>.vercel.app` will be assigned. If `production`, any aliases defined in `alias` will be assigned. If omitted, the target will be `preview`
   */
  target?: 'staging' | 'production';
  /**
   * When `true` and `deploymentId` is passed in, the sha from the previous deployment's `gitSource` is removed forcing the latest commit to be used.
   */
  withLatestCommit?: boolean;
};

export type CreateDeploymentVariables = {
  body: CreateDeploymentRequestBody;
  queryParams?: CreateDeploymentQueryParams;
} & FetcherExtraProps;

/**
 * Create a new deployment with all the required and intended data. If the deployment is not a git deployment, all files must be provided with the request, either referenced or inlined. Additionally, a deployment id can be specified to redeploy a previous deployment.
 */
export const createDeployment = (variables: CreateDeploymentVariables, signal?: AbortSignal) =>
  fetch<
    CreateDeploymentResponse,
    CreateDeploymentError,
    CreateDeploymentRequestBody,
    {},
    CreateDeploymentQueryParams,
    {}
  >({ url: '/v13/deployments', method: 'post', ...variables, signal });

export type CancelDeploymentPathParams = {
  /**
   * The unique identifier of the deployment.
   *
   * @example dpl_5WJWYSyB7BpgTj3EuwF37WMRBXBtPQ2iTMJHJBJyRfd
   */
  id: string;
};

export type CancelDeploymentQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type CancelDeploymentError = Fetcher.ErrorWrapper<undefined>;

export type CancelDeploymentResponse = {
  aliasAssignedAt?: number | boolean | null;
  alwaysRefuseToBuild?: boolean;
  build: {
    env: string[];
  };
  builds?: Record<string, any>[];
  env: string[];
  inspectorUrl: string | null;
  isInConcurrentBuildsQueue: boolean;
  projectSettings: {
    buildCommand?: string | null;
    devCommand?: string | null;
    framework?:
      | 'blitzjs'
      | 'nextjs'
      | 'gatsby'
      | 'remix'
      | 'astro'
      | 'hexo'
      | 'eleventy'
      | 'docusaurus-2'
      | 'docusaurus'
      | 'preact'
      | 'solidstart-1'
      | 'solidstart'
      | 'dojo'
      | 'ember'
      | 'vue'
      | 'scully'
      | 'ionic-angular'
      | 'angular'
      | 'polymer'
      | 'svelte'
      | 'sveltekit'
      | 'sveltekit-1'
      | 'ionic-react'
      | 'create-react-app'
      | 'gridsome'
      | 'umijs'
      | 'sapper'
      | 'saber'
      | 'stencil'
      | 'nuxtjs'
      | 'redwoodjs'
      | 'hugo'
      | 'jekyll'
      | 'brunch'
      | 'middleman'
      | 'zola'
      | 'hydrogen'
      | 'vite'
      | 'vitepress'
      | 'vuepress'
      | 'parcel'
      | 'sanity'
      | 'storybook'
      | null;
    commandForIgnoringBuildStep?: string | null;
    installCommand?: string | null;
    outputDirectory?: string | null;
    speedInsights?: {
      id: string;
      enabledAt?: number;
      disabledAt?: number;
      canceledAt?: number;
      hasData?: boolean;
      paidAt?: number;
    };
    webAnalytics?: {
      id: string;
      disabledAt?: number;
      canceledAt?: number;
      enabledAt?: number;
      hasData?: boolean;
    };
  };
  readyStateReason?: string;
  alias?: string[];
  aliasAssigned: boolean;
  bootedAt: number;
  buildingAt: number;
  buildSkipped: boolean;
  creator: {
    uid: string;
    username?: string;
    avatar?: string;
  };
  initReadyAt?: number;
  isFirstBranchDeployment?: boolean;
  lambdas?: {
    buildCommand?: string | null;
    devCommand?: string | null;
    framework?:
      | 'blitzjs'
      | 'nextjs'
      | 'gatsby'
      | 'remix'
      | 'astro'
      | 'hexo'
      | 'eleventy'
      | 'docusaurus-2'
      | 'docusaurus'
      | 'preact'
      | 'solidstart-1'
      | 'solidstart'
      | 'dojo'
      | 'ember'
      | 'vue'
      | 'scully'
      | 'ionic-angular'
      | 'angular'
      | 'polymer'
      | 'svelte'
      | 'sveltekit'
      | 'sveltekit-1'
      | 'ionic-react'
      | 'create-react-app'
      | 'gridsome'
      | 'umijs'
      | 'sapper'
      | 'saber'
      | 'stencil'
      | 'nuxtjs'
      | 'redwoodjs'
      | 'hugo'
      | 'jekyll'
      | 'brunch'
      | 'middleman'
      | 'zola'
      | 'hydrogen'
      | 'vite'
      | 'vitepress'
      | 'vuepress'
      | 'parcel'
      | 'sanity'
      | 'storybook'
      | null;
    commandForIgnoringBuildStep?: string | null;
    installCommand?: string | null;
    outputDirectory?: string | null;
    speedInsights?: {
      id: string;
      enabledAt?: number;
      disabledAt?: number;
      canceledAt?: number;
      hasData?: boolean;
      paidAt?: number;
    };
    webAnalytics?: {
      id: string;
      disabledAt?: number;
      canceledAt?: number;
      enabledAt?: number;
      hasData?: boolean;
    };
    output: {
      path: string;
      functionName: string;
    }[];
  }[];
  public: boolean;
  ready?: number;
  status: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED';
  team?: {
    buildCommand?: string | null;
    devCommand?: string | null;
    framework?:
      | 'blitzjs'
      | 'nextjs'
      | 'gatsby'
      | 'remix'
      | 'astro'
      | 'hexo'
      | 'eleventy'
      | 'docusaurus-2'
      | 'docusaurus'
      | 'preact'
      | 'solidstart-1'
      | 'solidstart'
      | 'dojo'
      | 'ember'
      | 'vue'
      | 'scully'
      | 'ionic-angular'
      | 'angular'
      | 'polymer'
      | 'svelte'
      | 'sveltekit'
      | 'sveltekit-1'
      | 'ionic-react'
      | 'create-react-app'
      | 'gridsome'
      | 'umijs'
      | 'sapper'
      | 'saber'
      | 'stencil'
      | 'nuxtjs'
      | 'redwoodjs'
      | 'hugo'
      | 'jekyll'
      | 'brunch'
      | 'middleman'
      | 'zola'
      | 'hydrogen'
      | 'vite'
      | 'vitepress'
      | 'vuepress'
      | 'parcel'
      | 'sanity'
      | 'storybook'
      | null;
    commandForIgnoringBuildStep?: string | null;
    installCommand?: string | null;
    outputDirectory?: string | null;
    speedInsights?: {
      id: string;
      enabledAt?: number;
      disabledAt?: number;
      canceledAt?: number;
      hasData?: boolean;
      paidAt?: number;
    };
    webAnalytics?: {
      id: string;
      disabledAt?: number;
      canceledAt?: number;
      enabledAt?: number;
      hasData?: boolean;
    };
  };
  userAliases?: string[];
  previewCommentsEnabled?: boolean;
  ttyBuildLogs?: boolean;
  customEnvironment?:
    | {
        id: string;
        name: string;
        slug: string;
        type: 'production' | 'preview' | 'development';
        description?: string;
        branchMatcher?: {
          type: 'startsWith' | 'equals' | 'endsWith';
          pattern: string;
        };
        createdAt: number;
        updatedAt: number;
      }
    | {
        id: string;
      };
  id: string;
  aliasError?: {
    code: string;
    message: string;
  } | null;
  aliasFinal?: string | null;
  aliasWarning?: {
    code: string;
    message: string;
    link?: string;
    action?: string;
  } | null;
  /**
   * applies to custom domains only, defaults to `true`
   */
  autoAssignCustomDomains?: boolean;
  automaticAliases?: string[];
  buildErrorAt?: number;
  checksState?: 'registered' | 'running' | 'completed';
  checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
  createdAt: number;
  deletedAt?: number | null;
  canceledAt?: number;
  errorCode?: string;
  errorLink?: string;
  errorMessage?: string | null;
  errorStep?: string;
  /**
   * Since November 2023 this field defines a set of regions that we will deploy the lambda to passively Lambdas will be deployed to these regions but only invoked if all of the primary `regions` are marked as out of service
   */
  passiveRegions?: string[];
  gitSource?:
    | {
        type: 'github';
        repoId: string | number;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'github';
        org: string;
        repo: string;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'gitlab';
        projectId: string | number;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'bitbucket';
        workspaceUuid?: string;
        repoUuid: string;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'bitbucket';
        owner: string;
        slug: string;
        ref?: string | null;
        sha?: string;
        prId?: number | null;
      }
    | {
        type: 'custom';
        ref: string;
        sha: string;
        gitUrl: string;
      }
    | {
        type: 'github';
        ref: string;
        sha: string;
        repoId: number;
        org?: string;
        repo?: string;
      }
    | {
        type: 'gitlab';
        ref: string;
        sha: string;
        projectId: number;
      }
    | {
        type: 'bitbucket';
        ref: string;
        sha: string;
        owner?: string;
        slug?: string;
        workspaceUuid: string;
        repoUuid: string;
      };
  name: string;
  meta: {
    [key: string]: string;
  };
  project?: {
    id: string;
    name: string;
    framework?: string | null;
  };
  readyState: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED';
  /**
   * Since June 2023 Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - PROMOTED: has seen production traffic
   */
  readySubstate?: 'STAGED' | 'PROMOTED';
  regions: string[];
  source?: 'api-trigger-git-deploy' | 'cli' | 'clone/repo' | 'git' | 'import' | 'import/repo';
  target?: 'production' | 'staging' | null;
  type: 'LAMBDAS';
  undeletedAt?: number;
  url: string;
  version: 2;
  oidcTokenClaims?: {
    [key: string]: string;
  };
  connectBuildsEnabled?: boolean;
  connectConfigurationId?: string;
  createdIn: string;
  crons?: {
    schedule: string;
    path: string;
  }[];
  functions?: {
    [key: string]: {
      memory?: number;
      maxDuration?: number;
      runtime?: string;
      includeFiles?: string;
      excludeFiles?: string;
    };
  } | null;
  monorepoManager?: string | null;
  ownerId: string;
  /**
   * Since November 2023 this field defines a connect configuration that will only be used to deploy passive lambdas to (as in passiveRegions)
   */
  passiveConnectConfigurationId?: string;
  plan: 'pro' | 'enterprise' | 'hobby';
  projectId: string;
  routes:
    | (
        | {
            src: string;
            dest?: string;
            headers?: {
              [key: string]: string;
            };
            methods?: string[];
            ['continue']?: boolean;
            override?: boolean;
            caseSensitive?: boolean;
            check?: boolean;
            important?: boolean;
            status?: number;
            has?: (
              | {
                  type: 'host';
                  value: string;
                }
              | {
                  type: 'header' | 'cookie' | 'query';
                  key: string;
                  value?: string;
                }
            )[];
            missing?: (
              | {
                  type: 'host';
                  value: string;
                }
              | {
                  type: 'header' | 'cookie' | 'query';
                  key: string;
                  value?: string;
                }
            )[];
            locale?: {
              redirect?: {
                [key: string]: string;
              };
              cookie?: string;
            };
            /**
             * A middleware key within the `output` key under the build result. Overrides a `middleware` definition.
             */
            middlewarePath?: string;
            /**
             * The original middleware matchers.
             */
            middlewareRawSrc?: string[];
            /**
             * A middleware index in the `middleware` key under the build result
             */
            middleware?: number;
          }
        | {
            handle: 'filesystem' | 'hit' | 'miss' | 'rewrite' | 'error' | 'resource';
            src?: string;
            dest?: string;
            status?: number;
          }
        | {
            src: string;
            ['continue']: boolean;
            middleware: 0;
          }
      )[]
    | null;
  gitRepo?:
    | {
        namespace: string;
        projectId: number;
        type: 'gitlab';
        url: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: 'team' | 'user';
      }
    | {
        org: string;
        repo: string;
        repoId: number;
        type: 'github';
        repoOwnerId: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: 'team' | 'user';
      }
    | {
        owner: string;
        repoUuid: string;
        slug: string;
        type: 'bitbucket';
        workspaceUuid: string;
        path: string;
        defaultBranch: string;
        name: string;
        private: boolean;
        ownerType: 'team' | 'user';
      }
    | null;
  flags?:
    | {
        definitions: {
          [key: string]: string;
        };
      }
    | Record<string, any>[];
};

export type CancelDeploymentVariables = {
  pathParams: CancelDeploymentPathParams;
  queryParams?: CancelDeploymentQueryParams;
} & FetcherExtraProps;

/**
 * This endpoint allows you to cancel a deployment which is currently building, by supplying its `id` in the URL.
 */
export const cancelDeployment = (variables: CancelDeploymentVariables, signal?: AbortSignal) =>
  fetch<
    CancelDeploymentResponse,
    CancelDeploymentError,
    undefined,
    {},
    CancelDeploymentQueryParams,
    CancelDeploymentPathParams
  >({ url: '/v12/deployments/{id}/cancel', method: 'patch', ...variables, signal });

export type BuyDomainQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type BuyDomainError = Fetcher.ErrorWrapper<undefined>;

export type BuyDomainResponse = {
  domain: {
    uid: string;
    ns: string[];
    verified: boolean;
    created: number;
    pending: boolean;
  };
};

export type BuyDomainRequestBody = {
  /**
   * The domain name to purchase.
   *
   * @example example.com
   */
  name: string;
  /**
   * The price you expect to be charged for the purchase.
   *
   * @example 10
   */
  expectedPrice?: number;
  /**
   * Indicates whether the domain should be automatically renewed.
   *
   * @example true
   */
  renew?: boolean;
};

export type BuyDomainVariables = {
  body: BuyDomainRequestBody;
  queryParams?: BuyDomainQueryParams;
} & FetcherExtraProps;

/**
 * Allows to purchase the specified domain.
 */
export const buyDomain = (variables: BuyDomainVariables, signal?: AbortSignal) =>
  fetch<BuyDomainResponse, BuyDomainError, BuyDomainRequestBody, {}, BuyDomainQueryParams, {}>({
    url: '/v4/domains/buy',
    method: 'post',
    ...variables,
    signal
  });

export type CheckDomainPriceQueryParams = {
  /**
   * The name of the domain for which the price needs to be checked.
   *
   * @example example.com
   */
  name: string;
  /**
   * In which status of the domain the price needs to be checked.
   *
   * @example new
   */
  type?: 'new' | 'renewal';
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type CheckDomainPriceError = Fetcher.ErrorWrapper<undefined>;

export type CheckDomainPriceResponse = {
  /**
   * The domain price in USD.
   *
   * @example 20
   */
  price: number;
  /**
   * The number of years the domain could be held before paying again.
   *
   * @example 1
   */
  period: number;
};

export type CheckDomainPriceVariables = {
  queryParams: CheckDomainPriceQueryParams;
} & FetcherExtraProps;

/**
 * Check the price to purchase a domain and how long a single purchase period is.
 */
export const checkDomainPrice = (variables: CheckDomainPriceVariables, signal?: AbortSignal) =>
  fetch<CheckDomainPriceResponse, CheckDomainPriceError, undefined, {}, CheckDomainPriceQueryParams, {}>({
    url: '/v4/domains/price',
    method: 'get',
    ...variables,
    signal
  });

export type GetRecordsPathParams = {
  /**
   * @example example.com
   */
  domain: string;
};

export type GetRecordsQueryParams = {
  /**
   * Maximum number of records to list from a request.
   *
   * @example 20
   */
  limit?: string;
  /**
   * Get records created after this JavaScript timestamp.
   *
   * @example 1609499532000
   */
  since?: string;
  /**
   * Get records created before this JavaScript timestamp.
   *
   * @example 1612264332000
   */
  until?: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetRecordsError = Fetcher.ErrorWrapper<undefined>;

export type GetRecordsVariables = {
  pathParams: GetRecordsPathParams;
  queryParams?: GetRecordsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of DNS records created for a domain name. By default it returns 20 records if no limit is provided. The rest can be retrieved using the pagination options.
 */
export const getRecords = (variables: GetRecordsVariables, signal?: AbortSignal) =>
  fetch<
    | string
    | {
        records: {
          id: string;
          slug: string;
          name: string;
          type: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'HTTPS' | 'MX' | 'SRV' | 'TXT' | 'NS';
          value: string;
          mxPriority?: number;
          priority?: number;
          creator: string;
          created: number | null;
          updated: number | null;
          createdAt: number | null;
          updatedAt: number | null;
        }[];
      }
    | {
        records: {
          id: string;
          slug: string;
          name: string;
          type: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'HTTPS' | 'MX' | 'SRV' | 'TXT' | 'NS';
          value: string;
          mxPriority?: number;
          priority?: number;
          creator: string;
          created: number | null;
          updated: number | null;
          createdAt: number | null;
          updatedAt: number | null;
        }[];
        pagination: Schemas.Pagination;
      },
    GetRecordsError,
    undefined,
    {},
    GetRecordsQueryParams,
    GetRecordsPathParams
  >({ url: '/v4/domains/{domain}/records', method: 'get', ...variables, signal });

export type CreateRecordPathParams = {
  /**
   * The domain used to create the DNS record.
   *
   * @example example.com
   */
  domain: string;
};

export type CreateRecordQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type CreateRecordError = Fetcher.ErrorWrapper<undefined>;

export type CreateRecordVariables = {
  body:
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `A`.
         */
        type: 'A';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * The record value must be a valid IPv4 address.
         *
         * @format ipv4
         * @example 192.0.2.42
         */
        value: string;
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `AAAA`.
         */
        type: 'AAAA';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * An AAAA record pointing to an IPv6 address.
         *
         * @format ipv6
         * @example 2001:DB8::42
         */
        value: string;
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `ALIAS`.
         */
        type: 'ALIAS';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * An ALIAS virtual record pointing to a hostname resolved to an A record on server side.
         *
         * @example cname.vercel-dns.com
         */
        value: string;
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `CAA`.
         */
        type: 'CAA';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * A CAA record to specify which Certificate Authorities (CAs) are allowed to issue certificates for the domain.
         *
         * @example 0 issue \"letsencrypt.org\"
         */
        value: string;
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `CNAME`.
         */
        type: 'CNAME';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * A CNAME record mapping to another domain name.
         *
         * @example cname.vercel-dns.com
         */
        value?: string;
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `MX`.
         */
        type: 'MX';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * An MX record specifying the mail server responsible for accepting messages on behalf of the domain name.
         *
         * @example 10 mail.example.com.
         */
        value: string;
        /**
         * @minimum 0
         * @maximum 65535
         * @example 10
         */
        mxPriority: number;
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         */
        name: string;
        /**
         * Must be of type `SRV`.
         */
        type: 'SRV';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        srv: {
          priority: number | null;
          weight: number | null;
          port: number | null;
          /**
           * @example host.example.com
           */
          target: string;
        };
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         */
        name: string;
        /**
         * Must be of type `TXT`.
         */
        type: 'TXT';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * A TXT record containing arbitrary text.
         *
         * @example hello
         */
        value: string;
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      }
    | {
        /**
         * A subdomain name.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `NS`.
         */
        type: 'NS';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * An NS domain value.
         *
         * @example ns1.example.com
         */
        value?: string;
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         */
        name: string;
        /**
         * Must be of type `HTTPS`.
         */
        type: 'HTTPS';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        https: {
          priority: number | null;
          /**
           * @example host.example.com
           */
          target: string;
          /**
           * @example alpn=h2,h3
           */
          params?: string;
        };
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      };
  pathParams: CreateRecordPathParams;
  queryParams?: CreateRecordQueryParams;
} & FetcherExtraProps;

/**
 * Creates a DNS record for a domain.
 */
export const createRecord = (variables: CreateRecordVariables, signal?: AbortSignal) =>
  fetch<
    | {
        uid: string;
        updated: number;
      }
    | {
        /**
         * The id of the newly created DNS record
         *
         * @example rec_V0fra8eEgQwEpFhYG2vTzC3K
         */
        uid: string;
      },
    CreateRecordError,
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `A`.
         */
        type: 'A';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * The record value must be a valid IPv4 address.
         *
         * @format ipv4
         * @example 192.0.2.42
         */
        value: string;
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `AAAA`.
         */
        type: 'AAAA';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * An AAAA record pointing to an IPv6 address.
         *
         * @format ipv6
         * @example 2001:DB8::42
         */
        value: string;
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `ALIAS`.
         */
        type: 'ALIAS';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * An ALIAS virtual record pointing to a hostname resolved to an A record on server side.
         *
         * @example cname.vercel-dns.com
         */
        value: string;
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `CAA`.
         */
        type: 'CAA';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * A CAA record to specify which Certificate Authorities (CAs) are allowed to issue certificates for the domain.
         *
         * @example 0 issue \"letsencrypt.org\"
         */
        value: string;
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `CNAME`.
         */
        type: 'CNAME';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * A CNAME record mapping to another domain name.
         *
         * @example cname.vercel-dns.com
         */
        value?: string;
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `MX`.
         */
        type: 'MX';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * An MX record specifying the mail server responsible for accepting messages on behalf of the domain name.
         *
         * @example 10 mail.example.com.
         */
        value: string;
        /**
         * @minimum 0
         * @maximum 65535
         * @example 10
         */
        mxPriority: number;
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         */
        name: string;
        /**
         * Must be of type `SRV`.
         */
        type: 'SRV';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        srv: {
          priority: number | null;
          weight: number | null;
          port: number | null;
          /**
           * @example host.example.com
           */
          target: string;
        };
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         */
        name: string;
        /**
         * Must be of type `TXT`.
         */
        type: 'TXT';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * A TXT record containing arbitrary text.
         *
         * @example hello
         */
        value: string;
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      }
    | {
        /**
         * A subdomain name.
         *
         * @example subdomain
         */
        name: string;
        /**
         * Must be of type `NS`.
         */
        type: 'NS';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        /**
         * An NS domain value.
         *
         * @example ns1.example.com
         */
        value?: string;
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      }
    | {
        /**
         * A subdomain name or an empty string for the root domain.
         */
        name: string;
        /**
         * Must be of type `HTTPS`.
         */
        type: 'HTTPS';
        /**
         * The TTL value. Must be a number between 60 and 2147483647. Default value is 60.
         *
         * @minimum 60
         * @maximum 2147483647
         * @example 60
         */
        ttl?: number;
        https: {
          priority: number | null;
          /**
           * @example host.example.com
           */
          target: string;
          /**
           * @example alpn=h2,h3
           */
          params?: string;
        };
        /**
         * A comment to add context on what this DNS record is for
         *
         * @example used to verify ownership of domain
         * @maxLength 500
         */
        comment?: string;
      },
    {},
    CreateRecordQueryParams,
    CreateRecordPathParams
  >({ url: '/v2/domains/{domain}/records', method: 'post', ...variables, signal });

export type UpdateRecordPathParams = {
  /**
   * The id of the DNS record
   *
   * @example rec_2qn7pzrx89yxy34vezpd31y9
   */
  recordId: string;
};

export type UpdateRecordQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type UpdateRecordError = Fetcher.ErrorWrapper<undefined>;

export type UpdateRecordResponse = {
  createdAt?: number | null;
  creator: string;
  domain: string;
  id: string;
  name: string;
  recordType: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'HTTPS' | 'MX' | 'SRV' | 'TXT' | 'NS';
  ttl?: number;
  type: 'record' | 'record-sys';
  value: string;
  comment?: string;
};

export type UpdateRecordRequestBody = {
  additionalProperties?: void;
  /**
   * The name of the DNS record
   *
   * @example example-1
   */
  name?: string | null;
  /**
   * The value of the DNS record
   *
   * @example google.com
   */
  value?: string | null;
  /**
   * The type of the DNS record
   *
   * @example A
   * @maxLength 255
   */
  type?: 'A' | 'AAAA' | 'ALIAS' | 'CAA' | 'CNAME' | 'HTTPS' | 'MX' | 'SRV' | 'TXT' | 'NS' | null;
  /**
   * The Time to live (TTL) value of the DNS record
   *
   * @example 60
   * @minimum 60
   * @maximum 2147483647
   */
  ttl?: number | null;
  /**
   * The MX priority value of the DNS record
   */
  mxPriority?: number | null;
  srv?: {
    /**
     * @example example2.com.
     * @maxLength 255
     */
    target: string | null;
    weight: number | null;
    port: number | null;
    priority: number | null;
  } | null;
  https?: {
    priority: number | null;
    /**
     * @example example2.com.
     * @maxLength 255
     */
    target: string | null;
    params?: string | null;
  } | null;
  /**
   * A comment to add context on what this DNS record is for
   *
   * @example used to verify ownership of domain
   * @maxLength 500
   */
  comment?: string;
};

export type UpdateRecordVariables = {
  body?: UpdateRecordRequestBody;
  pathParams: UpdateRecordPathParams;
  queryParams?: UpdateRecordQueryParams;
} & FetcherExtraProps;

/**
 * Updates an existing DNS record for a domain name.
 */
export const updateRecord = (variables: UpdateRecordVariables, signal?: AbortSignal) =>
  fetch<
    UpdateRecordResponse,
    UpdateRecordError,
    UpdateRecordRequestBody,
    {},
    UpdateRecordQueryParams,
    UpdateRecordPathParams
  >({ url: '/v1/domains/records/{recordId}', method: 'patch', ...variables, signal });

export type RemoveRecordPathParams = {
  /**
   * @example example.com
   */
  domain: string;
  /**
   * @example rec_V0fra8eEgQwEpFhYG2vTzC3K
   */
  recordId: string;
};

export type RemoveRecordQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type RemoveRecordError = Fetcher.ErrorWrapper<undefined>;

export type RemoveRecordVariables = {
  pathParams: RemoveRecordPathParams;
  queryParams?: RemoveRecordQueryParams;
} & FetcherExtraProps;

/**
 * Removes an existing DNS record from a domain name.
 */
export const removeRecord = (variables: RemoveRecordVariables, signal?: AbortSignal) =>
  fetch<Record<string, any>, RemoveRecordError, undefined, {}, RemoveRecordQueryParams, RemoveRecordPathParams>({
    url: '/v2/domains/{domain}/records/{recordId}',
    method: 'delete',
    ...variables,
    signal
  });

export type CheckDomainStatusQueryParams = {
  /**
   * The name of the domain for which we would like to check the status.
   *
   * @example example.com
   */
  name: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type CheckDomainStatusError = Fetcher.ErrorWrapper<undefined>;

export type CheckDomainStatusResponse = {
  available: boolean;
};

export type CheckDomainStatusVariables = {
  queryParams: CheckDomainStatusQueryParams;
} & FetcherExtraProps;

/**
 * Check if a domain name is available for purchase.
 */
export const checkDomainStatus = (variables: CheckDomainStatusVariables, signal?: AbortSignal) =>
  fetch<CheckDomainStatusResponse, CheckDomainStatusError, undefined, {}, CheckDomainStatusQueryParams, {}>({
    url: '/v4/domains/status',
    method: 'get',
    ...variables,
    signal
  });

export type GetDomainTransferQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetDomainTransferError = Fetcher.ErrorWrapper<undefined>;

export type GetDomainTransferResponse = {
  /**
   * Whether or not the domain is transferable
   */
  transferable: boolean;
  /**
   * The domain's transfer policy (depends on TLD requirements). `charge-and-renew`: transfer will charge for renewal and will renew the existing domain's registration. `no-charge-no-change`: transfer will have no change to registration period and does not require charge. `no-change`: transfer charge is required, but no change in registration period. `new-term`: transfer charge is required and a new registry term is set based on the transfer date. `not-supported`: transfers are not supported for this domain or TLD. `null`: This TLD is not supported by Vercel's Registrar.
   */
  transferPolicy: 'charge-and-renew' | 'no-charge-no-change' | 'no-change' | 'new-term' | 'not-supported' | null;
  /**
   * Description associated with transferable state.
   */
  reason: string;
  /**
   * The current state of an ongoing transfer. `pending_owner`: Awaiting approval by domain's admin contact (every transfer begins with this status). If approval is not given within five days, the transfer is cancelled. `pending_admin`: Waiting for approval by Vercel Registrar admin. `pending_registry`: Awaiting registry approval (the transfer completes after 7 days unless it is declined by the current registrar). `completed`: The transfer completed successfully. `cancelled`: The transfer was cancelled. `undef`: No transfer exists for this domain. `unknown`: This TLD is not supported by Vercel's Registrar.
   */
  status: 'pending_owner' | 'pending_admin' | 'pending_registry' | 'completed' | 'cancelled' | 'undef' | 'unknown';
};

export type GetDomainTransferVariables = {
  queryParams?: GetDomainTransferQueryParams;
} & FetcherExtraProps;

/**
 * Fetch domain transfer availability or transfer status if a transfer is in progress.
 */
export const getDomainTransfer = (variables: GetDomainTransferVariables, signal?: AbortSignal) =>
  fetch<GetDomainTransferResponse, GetDomainTransferError, undefined, {}, GetDomainTransferQueryParams, {}>({
    url: '/v1/domains/{domain}/registry',
    method: 'get',
    ...variables,
    signal
  });

export type GetDomainConfigPathParams = {
  /**
   * The name of the domain.
   *
   * @example example.com
   */
  domain: string;
};

export type GetDomainConfigQueryParams = {
  /**
   * When true, the response will only include the nameservers assigned directly to the specified domain. When false and there are no nameservers assigned directly to the specified domain, the response will include the nameservers of the domain's parent zone.
   */
  strict?: 'true' | 'false';
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetDomainConfigError = Fetcher.ErrorWrapper<undefined>;

export type GetDomainConfigResponse = {
  /**
   * How we see the domain's configuration. - `CNAME`: Domain has a CNAME pointing to Vercel. - `A`: Domain's A record is resolving to Vercel. - `http`: Domain is resolving to Vercel but may be behind a Proxy. - `dns-01`: Domain is not resolving to Vercel but dns-01 challenge is enabled. - `null`: Domain is not resolving to Vercel.
   */
  configuredBy?: 'CNAME' | 'A' | 'http' | 'dns-01' | null;
  /**
   * Which challenge types the domain can use for issuing certs.
   */
  acceptedChallenges?: ('dns-01' | 'http-01')[];
  /**
   * Whether or not the domain is configured AND we can automatically generate a TLS certificate.
   */
  misconfigured: boolean;
};

export type GetDomainConfigVariables = {
  pathParams: GetDomainConfigPathParams;
  queryParams?: GetDomainConfigQueryParams;
} & FetcherExtraProps;

/**
 * Get a Domain's configuration.
 */
export const getDomainConfig = (variables: GetDomainConfigVariables, signal?: AbortSignal) =>
  fetch<
    GetDomainConfigResponse,
    GetDomainConfigError,
    undefined,
    {},
    GetDomainConfigQueryParams,
    GetDomainConfigPathParams
  >({ url: '/v6/domains/{domain}/config', method: 'get', ...variables, signal });

export type GetDomainPathParams = {
  /**
   * The name of the domain.
   *
   * @example example.com
   */
  domain: string;
};

export type GetDomainQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetDomainError = Fetcher.ErrorWrapper<undefined>;

export type GetDomainResponse = {
  domain: {
    suffix: boolean;
    /**
     * If the domain has the ownership verified.
     *
     * @example true
     */
    verified: boolean;
    /**
     * A list of the current nameservers of the domain.
     *
     * @example ns1.nameserver.net
     * @example ns2.nameserver.net
     */
    nameservers: string[];
    /**
     * A list of the intended nameservers for the domain to point to Vercel DNS.
     *
     * @example ns1.vercel-dns.com
     * @example ns2.vercel-dns.com
     */
    intendedNameservers: string[];
    /**
     * A list of custom nameservers for the domain to point to. Only applies to domains purchased with Vercel.
     *
     * @example ns1.nameserver.net
     * @example ns2.nameserver.net
     */
    customNameservers?: string[];
    /**
     * An object containing information of the domain creator, including the user's id, username, and email.
     *
     * @example {"id":"ZspSRT4ljIEEmMHgoDwKWDei","username":"vercel_user","email":"demo@example.com"}
     */
    creator: {
      username: string;
      email: string;
      customerId?: string | null;
      isDomainReseller?: boolean;
      id: string;
    };
    /**
     * If it was purchased through Vercel, the timestamp in milliseconds when it was purchased.
     *
     * @example 1613602938882
     */
    boughtAt: number | null;
    /**
     * Timestamp in milliseconds when the domain was created in the registry.
     *
     * @example 1613602938882
     */
    createdAt: number;
    /**
     * Timestamp in milliseconds at which the domain is set to expire. `null` if not bought with Vercel.
     *
     * @example 1613602938882
     */
    expiresAt: number | null;
    /**
     * The unique identifier of the domain.
     *
     * @example EmTbe5CEJyTk2yVAHBUWy4A3sRusca3GCwRjTC1bpeVnt1
     */
    id: string;
    /**
     * The domain name.
     *
     * @example example.com
     */
    name: string;
    /**
     * Timestamp in milliseconds at which the domain was ordered.
     *
     * @example 1613602938882
     */
    orderedAt?: number;
    /**
     * Indicates whether the domain is set to automatically renew.
     *
     * @example true
     */
    renew?: boolean;
    /**
     * The type of service the domain is handled by. `external` if the DNS is externally handled, `zeit.world` if handled with Vercel, or `na` if the service is not available.
     *
     * @example zeit.world
     */
    serviceType: 'zeit.world' | 'external' | 'na';
    /**
     * Timestamp in milliseconds at which the domain was successfully transferred into Vercel. `null` if the transfer is still processing or was never transferred in.
     *
     * @example 1613602938882
     */
    transferredAt?: number | null;
    /**
     * If transferred into Vercel, timestamp in milliseconds when the domain transfer was initiated.
     *
     * @example 1613602938882
     */
    transferStartedAt?: number;
  };
};

export type GetDomainVariables = {
  pathParams: GetDomainPathParams;
  queryParams?: GetDomainQueryParams;
} & FetcherExtraProps;

/**
 * Get information for a single domain in an account or team.
 */
export const getDomain = (variables: GetDomainVariables, signal?: AbortSignal) =>
  fetch<GetDomainResponse, GetDomainError, undefined, {}, GetDomainQueryParams, GetDomainPathParams>({
    url: '/v5/domains/{domain}',
    method: 'get',
    ...variables,
    signal
  });

export type GetDomainsQueryParams = {
  /**
   * Maximum number of domains to list from a request.
   *
   * @example 20
   */
  limit?: number;
  /**
   * Get domains created after this JavaScript timestamp.
   *
   * @example 1609499532000
   */
  since?: number;
  /**
   * Get domains created before this JavaScript timestamp.
   *
   * @example 1612264332000
   */
  until?: number;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetDomainsError = Fetcher.ErrorWrapper<undefined>;

export type GetDomainsResponse = {
  domains: {
    /**
     * If the domain has the ownership verified.
     *
     * @example true
     */
    verified: boolean;
    /**
     * A list of the current nameservers of the domain.
     *
     * @example ns1.nameserver.net
     * @example ns2.nameserver.net
     */
    nameservers: string[];
    /**
     * A list of the intended nameservers for the domain to point to Vercel DNS.
     *
     * @example ns1.vercel-dns.com
     * @example ns2.vercel-dns.com
     */
    intendedNameservers: string[];
    /**
     * A list of custom nameservers for the domain to point to. Only applies to domains purchased with Vercel.
     *
     * @example ns1.nameserver.net
     * @example ns2.nameserver.net
     */
    customNameservers?: string[];
    /**
     * An object containing information of the domain creator, including the user's id, username, and email.
     *
     * @example {"id":"ZspSRT4ljIEEmMHgoDwKWDei","username":"vercel_user","email":"demo@example.com"}
     */
    creator: {
      username: string;
      email: string;
      customerId?: string | null;
      isDomainReseller?: boolean;
      id: string;
    };
    /**
     * If it was purchased through Vercel, the timestamp in milliseconds when it was purchased.
     *
     * @example 1613602938882
     */
    boughtAt: number | null;
    /**
     * Timestamp in milliseconds when the domain was created in the registry.
     *
     * @example 1613602938882
     */
    createdAt: number;
    /**
     * Timestamp in milliseconds at which the domain is set to expire. `null` if not bought with Vercel.
     *
     * @example 1613602938882
     */
    expiresAt: number | null;
    /**
     * The unique identifier of the domain.
     *
     * @example EmTbe5CEJyTk2yVAHBUWy4A3sRusca3GCwRjTC1bpeVnt1
     */
    id: string;
    /**
     * The domain name.
     *
     * @example example.com
     */
    name: string;
    /**
     * Timestamp in milliseconds at which the domain was ordered.
     *
     * @example 1613602938882
     */
    orderedAt?: number;
    /**
     * Indicates whether the domain is set to automatically renew.
     *
     * @example true
     */
    renew?: boolean;
    /**
     * The type of service the domain is handled by. `external` if the DNS is externally handled, `zeit.world` if handled with Vercel, or `na` if the service is not available.
     *
     * @example zeit.world
     */
    serviceType: 'zeit.world' | 'external' | 'na';
    /**
     * Timestamp in milliseconds at which the domain was successfully transferred into Vercel. `null` if the transfer is still processing or was never transferred in.
     *
     * @example 1613602938882
     */
    transferredAt?: number | null;
    /**
     * If transferred into Vercel, timestamp in milliseconds when the domain transfer was initiated.
     *
     * @example 1613602938882
     */
    transferStartedAt?: number;
  }[];
  pagination: Schemas.Pagination;
};

export type GetDomainsVariables = {
  queryParams?: GetDomainsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of domains registered for the authenticated user or team. By default it returns the last 20 domains if no limit is provided.
 */
export const getDomains = (variables: GetDomainsVariables, signal?: AbortSignal) =>
  fetch<GetDomainsResponse, GetDomainsError, undefined, {}, GetDomainsQueryParams, {}>({
    url: '/v5/domains',
    method: 'get',
    ...variables,
    signal
  });

export type CreateOrTransferDomainQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type CreateOrTransferDomainError = Fetcher.ErrorWrapper<undefined>;

export type CreateOrTransferDomainResponse = {
  domain: {
    /**
     * If the domain has the ownership verified.
     *
     * @example true
     */
    verified: boolean;
    /**
     * A list of the current nameservers of the domain.
     *
     * @example ns1.nameserver.net
     * @example ns2.nameserver.net
     */
    nameservers: string[];
    /**
     * A list of the intended nameservers for the domain to point to Vercel DNS.
     *
     * @example ns1.vercel-dns.com
     * @example ns2.vercel-dns.com
     */
    intendedNameservers: string[];
    /**
     * A list of custom nameservers for the domain to point to. Only applies to domains purchased with Vercel.
     *
     * @example ns1.nameserver.net
     * @example ns2.nameserver.net
     */
    customNameservers?: string[];
    /**
     * An object containing information of the domain creator, including the user's id, username, and email.
     *
     * @example {"id":"ZspSRT4ljIEEmMHgoDwKWDei","username":"vercel_user","email":"demo@example.com"}
     */
    creator: {
      username: string;
      email: string;
      customerId?: string | null;
      isDomainReseller?: boolean;
      id: string;
    };
    /**
     * If it was purchased through Vercel, the timestamp in milliseconds when it was purchased.
     *
     * @example 1613602938882
     */
    boughtAt: number | null;
    /**
     * Timestamp in milliseconds when the domain was created in the registry.
     *
     * @example 1613602938882
     */
    createdAt: number;
    /**
     * Timestamp in milliseconds at which the domain is set to expire. `null` if not bought with Vercel.
     *
     * @example 1613602938882
     */
    expiresAt: number | null;
    /**
     * The unique identifier of the domain.
     *
     * @example EmTbe5CEJyTk2yVAHBUWy4A3sRusca3GCwRjTC1bpeVnt1
     */
    id: string;
    /**
     * The domain name.
     *
     * @example example.com
     */
    name: string;
    /**
     * Timestamp in milliseconds at which the domain was ordered.
     *
     * @example 1613602938882
     */
    orderedAt?: number;
    /**
     * Indicates whether the domain is set to automatically renew.
     *
     * @example true
     */
    renew?: boolean;
    /**
     * The type of service the domain is handled by. `external` if the DNS is externally handled, `zeit.world` if handled with Vercel, or `na` if the service is not available.
     *
     * @example zeit.world
     */
    serviceType: 'zeit.world' | 'external' | 'na';
    /**
     * Timestamp in milliseconds at which the domain was successfully transferred into Vercel. `null` if the transfer is still processing or was never transferred in.
     *
     * @example 1613602938882
     */
    transferredAt?: number | null;
    /**
     * If transferred into Vercel, timestamp in milliseconds when the domain transfer was initiated.
     *
     * @example 1613602938882
     */
    transferStartedAt?: number;
  };
};

export type CreateOrTransferDomainVariables = {
  body?:
    | {
        /**
         * The domain name you want to add.
         *
         * @example example.com
         */
        name: string;
        /**
         * Whether the domain has the Vercel Edge Network enabled or not.
         *
         * @example true
         */
        cdnEnabled?: boolean;
        zone?: boolean;
        /**
         * The domain operation to perform.
         *
         * @example add
         */
        method?: string;
      }
    | {
        /**
         * The domain name you want to add.
         *
         * @example example.com
         */
        name: string;
        /**
         * The domain operation to perform.
         *
         * @example move-in
         */
        method: string;
        /**
         * The move-in token from Move Requested email.
         *
         * @example fdhfr820ad#@FAdlj$$
         */
        token?: string;
      }
    | {
        /**
         * The domain name you want to add.
         *
         * @example example.com
         */
        name: string;
        /**
         * The domain operation to perform.
         *
         * @example transfer-in
         */
        method: string;
        /**
         * The authorization code assigned to the domain.
         *
         * @example fdhfr820ad#@FAdlj$$
         */
        authCode?: string;
        /**
         * The price you expect to be charged for the required 1 year renewal.
         *
         * @example 8
         */
        expectedPrice?: number;
      };
  queryParams?: CreateOrTransferDomainQueryParams;
} & FetcherExtraProps;

/**
 * This endpoint is used for adding a new apex domain name with Vercel for the authenticating user. Can also be used for initiating a domain transfer request from an external Registrar to Vercel.
 */
export const createOrTransferDomain = (variables: CreateOrTransferDomainVariables, signal?: AbortSignal) =>
  fetch<
    CreateOrTransferDomainResponse,
    CreateOrTransferDomainError,
    | {
        /**
         * The domain name you want to add.
         *
         * @example example.com
         */
        name: string;
        /**
         * Whether the domain has the Vercel Edge Network enabled or not.
         *
         * @example true
         */
        cdnEnabled?: boolean;
        zone?: boolean;
        /**
         * The domain operation to perform.
         *
         * @example add
         */
        method?: string;
      }
    | {
        /**
         * The domain name you want to add.
         *
         * @example example.com
         */
        name: string;
        /**
         * The domain operation to perform.
         *
         * @example move-in
         */
        method: string;
        /**
         * The move-in token from Move Requested email.
         *
         * @example fdhfr820ad#@FAdlj$$
         */
        token?: string;
      }
    | {
        /**
         * The domain name you want to add.
         *
         * @example example.com
         */
        name: string;
        /**
         * The domain operation to perform.
         *
         * @example transfer-in
         */
        method: string;
        /**
         * The authorization code assigned to the domain.
         *
         * @example fdhfr820ad#@FAdlj$$
         */
        authCode?: string;
        /**
         * The price you expect to be charged for the required 1 year renewal.
         *
         * @example 8
         */
        expectedPrice?: number;
      },
    {},
    CreateOrTransferDomainQueryParams,
    {}
  >({ url: '/v5/domains', method: 'post', ...variables, signal });

export type PatchDomainPathParams = {
  domain?: string;
};

export type PatchDomainQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type PatchDomainError = Fetcher.ErrorWrapper<undefined>;

export type PatchDomainVariables = {
  body?:
    | {
        /**
         * @example update
         */
        op?: string;
        /**
         * Specifies whether domain should be renewed.
         */
        renew?: boolean;
        /**
         * The custom nameservers for this project.
         *
         * @maxItems 4
         * @minItems 0
         * @uniqueItems true
         */
        customNameservers?: string[];
        /**
         * Specifies whether this is a DNS zone that intends to use Vercel's nameservers.
         */
        zone?: boolean;
      }
    | {
        /**
         * @example move-out
         */
        op?: string;
        /**
         * User or team to move domain to
         */
        destination?: string;
      };
  pathParams?: PatchDomainPathParams;
  queryParams?: PatchDomainQueryParams;
} & FetcherExtraProps;

/**
 * Update or move apex domain.
 */
export const patchDomain = (variables: PatchDomainVariables, signal?: AbortSignal) =>
  fetch<
    | {
        moved: boolean;
      }
    | {
        moved: boolean;
        token: string;
      }
    | {
        renew?: boolean;
        customNameservers?: string[];
        zone?: boolean;
      },
    PatchDomainError,
    | {
        /**
         * @example update
         */
        op?: string;
        /**
         * Specifies whether domain should be renewed.
         */
        renew?: boolean;
        /**
         * The custom nameservers for this project.
         *
         * @maxItems 4
         * @minItems 0
         * @uniqueItems true
         */
        customNameservers?: string[];
        /**
         * Specifies whether this is a DNS zone that intends to use Vercel's nameservers.
         */
        zone?: boolean;
      }
    | {
        /**
         * @example move-out
         */
        op?: string;
        /**
         * User or team to move domain to
         */
        destination?: string;
      },
    {},
    PatchDomainQueryParams,
    PatchDomainPathParams
  >({ url: '/v3/domains/{domain}', method: 'patch', ...variables, signal });

export type DeleteDomainPathParams = {
  /**
   * The name of the domain.
   *
   * @example example.com
   */
  domain: string;
};

export type DeleteDomainQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type DeleteDomainError = Fetcher.ErrorWrapper<undefined>;

export type DeleteDomainResponse = {
  uid: string;
};

export type DeleteDomainVariables = {
  pathParams: DeleteDomainPathParams;
  queryParams?: DeleteDomainQueryParams;
} & FetcherExtraProps;

/**
 * Delete a previously registered domain name from Vercel. Deleting a domain will automatically remove any associated aliases.
 */
export const deleteDomain = (variables: DeleteDomainVariables, signal?: AbortSignal) =>
  fetch<DeleteDomainResponse, DeleteDomainError, undefined, {}, DeleteDomainQueryParams, DeleteDomainPathParams>({
    url: '/v6/domains/{domain}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetEdgeConfigsQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetEdgeConfigsError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigsResponse = {
  id?: string;
  createdAt?: number;
  ownerId?: string;
  /**
   * Name for the Edge Config Names are not unique. Must start with an alphabetic character and can contain only alphanumeric characters and underscores).
   */
  slug?: string;
  updatedAt?: number;
  digest?: string;
  /**
   * Keeps track of the current state of the Edge Config while it gets transferred.
   */
  transfer?: {
    fromAccountId: string;
    startedAt: number;
    doneAt: number | null;
  };
  schema?: Record<string, any>;
  sizeInBytes: number;
  itemCount: number;
};

export type GetEdgeConfigsVariables = {
  queryParams?: GetEdgeConfigsQueryParams;
} & FetcherExtraProps;

/**
 * Returns all Edge Configs.
 */
export const getEdgeConfigs = (variables: GetEdgeConfigsVariables, signal?: AbortSignal) =>
  fetch<GetEdgeConfigsResponse, GetEdgeConfigsError, undefined, {}, GetEdgeConfigsQueryParams, {}>({
    url: '/v1/edge-config',
    method: 'get',
    ...variables,
    signal
  });

export type CreateEdgeConfigQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type CreateEdgeConfigError = Fetcher.ErrorWrapper<undefined>;

export type CreateEdgeConfigResponse = {
  createdAt?: number;
  updatedAt?: number;
  id?: string;
  /**
   * Name for the Edge Config Names are not unique. Must start with an alphabetic character and can contain only alphanumeric characters and underscores).
   */
  slug?: string;
  ownerId?: string;
  digest?: string;
  /**
   * Keeps track of the current state of the Edge Config while it gets transferred.
   */
  transfer?: {
    fromAccountId: string;
    startedAt: number;
    doneAt: number | null;
  };
  schema?: Record<string, any>;
  sizeInBytes: number;
  itemCount: number;
};

export type CreateEdgeConfigRequestBody = {
  /**
   * @maxLength 32
   * @pattern ^[\\w-]+$
   */
  slug: string;
  items?: {
    [key: string]:
      | (string | number | boolean | null | Record<string, any>)
      | (string | number | boolean | null | Record<string, any>)[];
  };
};

export type CreateEdgeConfigVariables = {
  body: CreateEdgeConfigRequestBody;
  queryParams?: CreateEdgeConfigQueryParams;
} & FetcherExtraProps;

/**
 * Creates an Edge Config.
 */
export const createEdgeConfig = (variables: CreateEdgeConfigVariables, signal?: AbortSignal) =>
  fetch<
    CreateEdgeConfigResponse,
    CreateEdgeConfigError,
    CreateEdgeConfigRequestBody,
    {},
    CreateEdgeConfigQueryParams,
    {}
  >({ url: '/v1/edge-config', method: 'post', ...variables, signal });

export type GetEdgeConfigPathParams = {
  edgeConfigId: string;
};

export type GetEdgeConfigQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetEdgeConfigError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigResponse = {
  createdAt?: number;
  updatedAt?: number;
  id?: string;
  /**
   * Name for the Edge Config Names are not unique. Must start with an alphabetic character and can contain only alphanumeric characters and underscores).
   */
  slug?: string;
  ownerId?: string;
  digest?: string;
  /**
   * Keeps track of the current state of the Edge Config while it gets transferred.
   */
  transfer?: {
    fromAccountId: string;
    startedAt: number;
    doneAt: number | null;
  };
  schema?: Record<string, any>;
  sizeInBytes: number;
  itemCount: number;
};

export type GetEdgeConfigVariables = {
  pathParams: GetEdgeConfigPathParams;
  queryParams?: GetEdgeConfigQueryParams;
} & FetcherExtraProps;

/**
 * Returns an Edge Config.
 */
export const getEdgeConfig = (variables: GetEdgeConfigVariables, signal?: AbortSignal) =>
  fetch<GetEdgeConfigResponse, GetEdgeConfigError, undefined, {}, GetEdgeConfigQueryParams, GetEdgeConfigPathParams>({
    url: '/v1/edge-config/{edgeConfigId}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateEdgeConfigPathParams = {
  edgeConfigId: string;
};

export type UpdateEdgeConfigQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type UpdateEdgeConfigError = Fetcher.ErrorWrapper<undefined>;

export type UpdateEdgeConfigResponse = {
  createdAt?: number;
  updatedAt?: number;
  id?: string;
  /**
   * Name for the Edge Config Names are not unique. Must start with an alphabetic character and can contain only alphanumeric characters and underscores).
   */
  slug?: string;
  ownerId?: string;
  digest?: string;
  /**
   * Keeps track of the current state of the Edge Config while it gets transferred.
   */
  transfer?: {
    fromAccountId: string;
    startedAt: number;
    doneAt: number | null;
  };
  schema?: Record<string, any>;
  sizeInBytes: number;
  itemCount: number;
};

export type UpdateEdgeConfigRequestBody = {
  /**
   * @maxLength 32
   * @pattern ^[\\w-]+$
   */
  slug: string;
};

export type UpdateEdgeConfigVariables = {
  body: UpdateEdgeConfigRequestBody;
  pathParams: UpdateEdgeConfigPathParams;
  queryParams?: UpdateEdgeConfigQueryParams;
} & FetcherExtraProps;

/**
 * Updates an Edge Config.
 */
export const updateEdgeConfig = (variables: UpdateEdgeConfigVariables, signal?: AbortSignal) =>
  fetch<
    UpdateEdgeConfigResponse,
    UpdateEdgeConfigError,
    UpdateEdgeConfigRequestBody,
    {},
    UpdateEdgeConfigQueryParams,
    UpdateEdgeConfigPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}', method: 'put', ...variables, signal });

export type DeleteEdgeConfigPathParams = {
  edgeConfigId: string;
};

export type DeleteEdgeConfigQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type DeleteEdgeConfigError = Fetcher.ErrorWrapper<undefined>;

export type DeleteEdgeConfigVariables = {
  pathParams: DeleteEdgeConfigPathParams;
  queryParams?: DeleteEdgeConfigQueryParams;
} & FetcherExtraProps;

/**
 * Delete an Edge Config by id.
 */
export const deleteEdgeConfig = (variables: DeleteEdgeConfigVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteEdgeConfigError, undefined, {}, DeleteEdgeConfigQueryParams, DeleteEdgeConfigPathParams>({
    url: '/v1/edge-config/{edgeConfigId}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetEdgeConfigItemsPathParams = {
  /**
   * @pattern ^ecfg_
   */
  edgeConfigId: string;
};

export type GetEdgeConfigItemsQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetEdgeConfigItemsError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigItemsVariables = {
  pathParams: GetEdgeConfigItemsPathParams;
  queryParams?: GetEdgeConfigItemsQueryParams;
} & FetcherExtraProps;

/**
 * Returns all items of an Edge Config.
 */
export const getEdgeConfigItems = (variables: GetEdgeConfigItemsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.EdgeConfigItem,
    GetEdgeConfigItemsError,
    undefined,
    {},
    GetEdgeConfigItemsQueryParams,
    GetEdgeConfigItemsPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}/items', method: 'get', ...variables, signal });

export type PatchEdgeConfigItemsPathParams = {
  /**
   * @pattern ^ecfg_
   */
  edgeConfigId: string;
};

export type PatchEdgeConfigItemsQueryParams = {
  edgeConfigId: string;
  dryRun?: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type PatchEdgeConfigItemsError = Fetcher.ErrorWrapper<undefined>;

export type PatchEdgeConfigItemsResponse = {
  status: string;
};

export type PatchEdgeConfigItemsRequestBody = {
  items: (
    | {
        operation: void;
      }
    | {
        operation: 'update' | 'upsert';
      }
    | {
        operation: 'update' | 'upsert';
      }
    | {
        operation: void;
      }
  )[];
  definition: void;
};

export type PatchEdgeConfigItemsVariables = {
  body: PatchEdgeConfigItemsRequestBody;
  pathParams: PatchEdgeConfigItemsPathParams;
  queryParams: PatchEdgeConfigItemsQueryParams;
} & FetcherExtraProps;

/**
 * Update multiple Edge Config Items in batch.
 */
export const patchEdgeConfigItems = (variables: PatchEdgeConfigItemsVariables, signal?: AbortSignal) =>
  fetch<
    PatchEdgeConfigItemsResponse,
    PatchEdgeConfigItemsError,
    PatchEdgeConfigItemsRequestBody,
    {},
    PatchEdgeConfigItemsQueryParams,
    PatchEdgeConfigItemsPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}/items', method: 'patch', ...variables, signal });

export type GetEdgeConfigSchemaPathParams = {
  edgeConfigId: string;
};

export type GetEdgeConfigSchemaQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetEdgeConfigSchemaError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigSchemaVariables = {
  pathParams: GetEdgeConfigSchemaPathParams;
  queryParams?: GetEdgeConfigSchemaQueryParams;
} & FetcherExtraProps;

/**
 * Returns the schema of an Edge Config.
 */
export const getEdgeConfigSchema = (variables: GetEdgeConfigSchemaVariables, signal?: AbortSignal) =>
  fetch<
    Record<string, any> | null,
    GetEdgeConfigSchemaError,
    undefined,
    {},
    GetEdgeConfigSchemaQueryParams,
    GetEdgeConfigSchemaPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}/schema', method: 'get', ...variables, signal });

export type PatchEdgeConfigSchemaPathParams = {
  edgeConfigId: string;
};

export type PatchEdgeConfigSchemaQueryParams = {
  dryRun?: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type PatchEdgeConfigSchemaError = Fetcher.ErrorWrapper<undefined>;

export type PatchEdgeConfigSchemaRequestBody = {
  definition: void;
};

export type PatchEdgeConfigSchemaVariables = {
  body: PatchEdgeConfigSchemaRequestBody;
  pathParams: PatchEdgeConfigSchemaPathParams;
  queryParams?: PatchEdgeConfigSchemaQueryParams;
} & FetcherExtraProps;

/**
 * Update an Edge Config's schema.
 */
export const patchEdgeConfigSchema = (variables: PatchEdgeConfigSchemaVariables, signal?: AbortSignal) =>
  fetch<
    Record<string, any> | null,
    PatchEdgeConfigSchemaError,
    PatchEdgeConfigSchemaRequestBody,
    {},
    PatchEdgeConfigSchemaQueryParams,
    PatchEdgeConfigSchemaPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}/schema', method: 'post', ...variables, signal });

export type DeleteEdgeConfigSchemaPathParams = {
  edgeConfigId: string;
};

export type DeleteEdgeConfigSchemaQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type DeleteEdgeConfigSchemaError = Fetcher.ErrorWrapper<undefined>;

export type DeleteEdgeConfigSchemaVariables = {
  pathParams: DeleteEdgeConfigSchemaPathParams;
  queryParams?: DeleteEdgeConfigSchemaQueryParams;
} & FetcherExtraProps;

/**
 * Deletes the schema of existing Edge Config.
 */
export const deleteEdgeConfigSchema = (variables: DeleteEdgeConfigSchemaVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    DeleteEdgeConfigSchemaError,
    undefined,
    {},
    DeleteEdgeConfigSchemaQueryParams,
    DeleteEdgeConfigSchemaPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}/schema', method: 'delete', ...variables, signal });

export type GetEdgeConfigItemPathParams = {
  /**
   * @pattern ^ecfg_
   */
  edgeConfigId: string;
  edgeConfigItemKey: string;
};

export type GetEdgeConfigItemQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetEdgeConfigItemError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigItemVariables = {
  pathParams: GetEdgeConfigItemPathParams;
  queryParams?: GetEdgeConfigItemQueryParams;
} & FetcherExtraProps;

/**
 * Returns a specific Edge Config Item.
 */
export const getEdgeConfigItem = (variables: GetEdgeConfigItemVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.EdgeConfigItem,
    GetEdgeConfigItemError,
    undefined,
    {},
    GetEdgeConfigItemQueryParams,
    GetEdgeConfigItemPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}/item/{edgeConfigItemKey}', method: 'get', ...variables, signal });

export type GetEdgeConfigTokensPathParams = {
  edgeConfigId: string;
};

export type GetEdgeConfigTokensQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetEdgeConfigTokensError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigTokensVariables = {
  pathParams: GetEdgeConfigTokensPathParams;
  queryParams?: GetEdgeConfigTokensQueryParams;
} & FetcherExtraProps;

/**
 * Returns all tokens of an Edge Config.
 */
export const getEdgeConfigTokens = (variables: GetEdgeConfigTokensVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.EdgeConfigToken,
    GetEdgeConfigTokensError,
    undefined,
    {},
    GetEdgeConfigTokensQueryParams,
    GetEdgeConfigTokensPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}/tokens', method: 'get', ...variables, signal });

export type DeleteEdgeConfigTokensPathParams = {
  edgeConfigId: string;
};

export type DeleteEdgeConfigTokensQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type DeleteEdgeConfigTokensError = Fetcher.ErrorWrapper<undefined>;

export type DeleteEdgeConfigTokensRequestBody = {
  tokens: string[];
};

export type DeleteEdgeConfigTokensVariables = {
  body: DeleteEdgeConfigTokensRequestBody;
  pathParams: DeleteEdgeConfigTokensPathParams;
  queryParams?: DeleteEdgeConfigTokensQueryParams;
} & FetcherExtraProps;

/**
 * Deletes one or more tokens of an existing Edge Config.
 */
export const deleteEdgeConfigTokens = (variables: DeleteEdgeConfigTokensVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    DeleteEdgeConfigTokensError,
    DeleteEdgeConfigTokensRequestBody,
    {},
    DeleteEdgeConfigTokensQueryParams,
    DeleteEdgeConfigTokensPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}/tokens', method: 'delete', ...variables, signal });

export type GetEdgeConfigTokenPathParams = {
  edgeConfigId: string;
  token: string;
};

export type GetEdgeConfigTokenQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetEdgeConfigTokenError = Fetcher.ErrorWrapper<undefined>;

export type GetEdgeConfigTokenVariables = {
  pathParams: GetEdgeConfigTokenPathParams;
  queryParams?: GetEdgeConfigTokenQueryParams;
} & FetcherExtraProps;

/**
 * Return meta data about an Edge Config token.
 */
export const getEdgeConfigToken = (variables: GetEdgeConfigTokenVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.EdgeConfigToken,
    GetEdgeConfigTokenError,
    undefined,
    {},
    GetEdgeConfigTokenQueryParams,
    GetEdgeConfigTokenPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}/token/{token}', method: 'get', ...variables, signal });

export type CreateEdgeConfigTokenPathParams = {
  edgeConfigId: string;
};

export type CreateEdgeConfigTokenQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type CreateEdgeConfigTokenError = Fetcher.ErrorWrapper<undefined>;

export type CreateEdgeConfigTokenResponse = {
  token: string;
  id: string;
};

export type CreateEdgeConfigTokenRequestBody = {
  /**
   * @maxLength 52
   */
  label: string;
};

export type CreateEdgeConfigTokenVariables = {
  body: CreateEdgeConfigTokenRequestBody;
  pathParams: CreateEdgeConfigTokenPathParams;
  queryParams?: CreateEdgeConfigTokenQueryParams;
} & FetcherExtraProps;

/**
 * Adds a token to an existing Edge Config.
 */
export const createEdgeConfigToken = (variables: CreateEdgeConfigTokenVariables, signal?: AbortSignal) =>
  fetch<
    CreateEdgeConfigTokenResponse,
    CreateEdgeConfigTokenError,
    CreateEdgeConfigTokenRequestBody,
    {},
    CreateEdgeConfigTokenQueryParams,
    CreateEdgeConfigTokenPathParams
  >({ url: '/v1/edge-config/{edgeConfigId}/token', method: 'post', ...variables, signal });

export type ListUserEventsQueryParams = {
  /**
   * Maximum number of items which may be returned.
   *
   * @example 20
   */
  limit?: number;
  /**
   * Timestamp to only include items created since then.
   *
   * @example 2019-12-08T10:00:38.976Z
   */
  since?: string;
  /**
   * Timestamp to only include items created until then.
   *
   * @example 2019-12-09T23:00:38.976Z
   */
  until?: string;
  /**
   * Comma-delimited list of event \"types\" to filter the results by.
   *
   * @example login,team-member-join,domain-buy
   */
  types?: string;
  /**
   * When retrieving events for a Team, the `userId` parameter may be specified to filter events generated by a specific member of the Team.
   *
   * @example aeIInYVk59zbFF2SxfyxxmuO
   */
  userId?: string;
  /**
   * When set to `true`, the response will include the `payload` field for each event.
   *
   * @example true
   */
  withPayload?: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type ListUserEventsError = Fetcher.ErrorWrapper<undefined>;

export type ListUserEventsResponse = {
  /**
   * Array of events generated by the User.
   */
  events: Schemas.UserEvent[];
};

export type ListUserEventsVariables = {
  queryParams?: ListUserEventsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of "events" generated by the User on Vercel. Events are generated when the User performs a particular action, such as logging in, creating a deployment, and joining a Team (just to name a few). When the `teamId` parameter is supplied, then the events that are returned will be in relation to the Team that was specified.
 */
export const listUserEvents = (variables: ListUserEventsVariables, signal?: AbortSignal) =>
  fetch<ListUserEventsResponse, ListUserEventsError, undefined, {}, ListUserEventsQueryParams, {}>({
    url: '/v3/events',
    method: 'get',
    ...variables,
    signal
  });

export type GetConfigurationsQueryParams = {
  view: 'account' | 'project';
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetConfigurationsError = Fetcher.ErrorWrapper<undefined>;

export type GetConfigurationsVariables = {
  queryParams: GetConfigurationsQueryParams;
} & FetcherExtraProps;

/**
 * Allows to retrieve all configurations for an authenticated integration. When the `project` view is used, configurations generated for the authorization flow will be filtered out of the results.
 */
export const getConfigurations = (variables: GetConfigurationsVariables, signal?: AbortSignal) =>
  fetch<
    | {
        /**
         * A timestamp that tells you when the configuration was installed successfully
         *
         * @example 1558531915505
         */
        completedAt?: number;
        /**
         * A timestamp that tells you when the configuration was created
         *
         * @example 1558531915505
         */
        createdAt: number;
        /**
         * The unique identifier of the configuration
         *
         * @example icfg_3bwCLgxL8qt5kjRLcv2Dit7F
         */
        id: string;
        /**
         * The unique identifier of the app the configuration was created for
         *
         * @example oac_xzpVzcUOgcB1nrVlirtKhbWV
         */
        integrationId: string;
        /**
         * The user or team ID that owns the configuration
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        ownerId: string;
        /**
         * When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
         *
         * @example prj_xQxbutw1HpL6HLYPAzt5h75m8NjO
         */
        projects?: string[];
        /**
         * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
         *
         * @example marketplace
         */
        source?: 'marketplace' | 'deploy-button' | 'external';
        removedLogDrainsAt?: number;
        removedProjectEnvsAt?: number;
        removedTokensAt?: number;
        removedWebhooksAt?: number;
        /**
         * The slug of the integration the configuration is created for.
         *
         * @example slack
         */
        slug: string;
        /**
         * When the configuration was created for a team, this will show the ID of the team.
         *
         * @example team_nLlpyC6RE1qxydlFKbrxDlud
         */
        teamId?: string | null;
        type: 'integration-configuration';
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        updatedAt: number;
        /**
         * The ID of the user that created the configuration.
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        userId: string;
        /**
         * The resources that are allowed to be accessed by the configuration.
         *
         * @example read:project
         * @example read-write:log-drain
         */
        scopes: string[];
        scopesQueue?: {
          scopes: {
            added: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
              | 'read-write:integration-resource'
            )[];
            upgraded: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
              | 'read-write:integration-resource'
            )[];
          };
          note: string;
          requestedAt: number;
          confirmedAt?: number;
        }[];
        /**
         * A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
         *
         * @example 1558531915505
         */
        disabledAt?: number;
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        deletedAt?: number | null;
        disabledReason?:
          | 'disabled-by-owner'
          | 'feature-not-available'
          | 'disabled-by-admin'
          | 'original-owner-left-the-team'
          | 'account-plan-downgrade';
        /**
         * A timestamp that tells you when the configuration was migrated as part of the Northstar migration. In the future, if we allow integration configurations to be transferred between teams, this field should be cleared upon transfer.
         */
        northstarMigratedAt?: number;
        /**
         * Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
         */
        installationType?: 'marketplace' | 'external';
      }
    | {
        integration: {
          name: string;
          icon: string;
          category: string;
          isLegacy: boolean;
          flags?: string[];
          assignedBetaLabelAt?: number;
        };
        /**
         * A timestamp that tells you when the configuration was installed successfully
         *
         * @example 1558531915505
         */
        completedAt?: number;
        /**
         * A timestamp that tells you when the configuration was created
         *
         * @example 1558531915505
         */
        createdAt: number;
        /**
         * The unique identifier of the configuration
         *
         * @example icfg_3bwCLgxL8qt5kjRLcv2Dit7F
         */
        id: string;
        /**
         * The unique identifier of the app the configuration was created for
         *
         * @example oac_xzpVzcUOgcB1nrVlirtKhbWV
         */
        integrationId: string;
        /**
         * The user or team ID that owns the configuration
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        ownerId: string;
        /**
         * When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
         *
         * @example prj_xQxbutw1HpL6HLYPAzt5h75m8NjO
         */
        projects?: string[];
        /**
         * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
         *
         * @example marketplace
         */
        source?: 'marketplace' | 'deploy-button' | 'external';
        removedLogDrainsAt?: number;
        removedProjectEnvsAt?: number;
        removedTokensAt?: number;
        removedWebhooksAt?: number;
        /**
         * The slug of the integration the configuration is created for.
         *
         * @example slack
         */
        slug: string;
        /**
         * When the configuration was created for a team, this will show the ID of the team.
         *
         * @example team_nLlpyC6RE1qxydlFKbrxDlud
         */
        teamId?: string | null;
        type: 'integration-configuration';
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        updatedAt: number;
        /**
         * The ID of the user that created the configuration.
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        userId: string;
        /**
         * The resources that are allowed to be accessed by the configuration.
         *
         * @example read:project
         * @example read-write:log-drain
         */
        scopes: string[];
        scopesQueue?: {
          scopes: {
            added: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
              | 'read-write:integration-resource'
            )[];
            upgraded: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
              | 'read-write:integration-resource'
            )[];
          };
          note: string;
          requestedAt: number;
          confirmedAt?: number;
        }[];
        /**
         * A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
         *
         * @example 1558531915505
         */
        disabledAt?: number;
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        deletedAt?: number | null;
        disabledReason?:
          | 'disabled-by-owner'
          | 'feature-not-available'
          | 'disabled-by-admin'
          | 'original-owner-left-the-team'
          | 'account-plan-downgrade';
        /**
         * A timestamp that tells you when the configuration was migrated as part of the Northstar migration. In the future, if we allow integration configurations to be transferred between teams, this field should be cleared upon transfer.
         */
        northstarMigratedAt?: number;
        /**
         * Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
         */
        installationType?: 'marketplace' | 'external';
      }[],
    GetConfigurationsError,
    undefined,
    {},
    GetConfigurationsQueryParams,
    {}
  >({ url: '/v1/integrations/configurations', method: 'get', ...variables, signal });

export type GetConfigurationPathParams = {
  /**
   * ID of the configuration to check
   *
   * @example icfg_cuwj0AdCdH3BwWT4LPijCC7t
   */
  id: string;
};

export type GetConfigurationQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetConfigurationError = Fetcher.ErrorWrapper<undefined>;

export type GetConfigurationVariables = {
  pathParams: GetConfigurationPathParams;
  queryParams?: GetConfigurationQueryParams;
} & FetcherExtraProps;

/**
 * Allows to retrieve a the configuration with the provided id in case it exists. The authenticated user or team must be the owner of the config in order to access it.
 */
export const getConfiguration = (variables: GetConfigurationVariables, signal?: AbortSignal) =>
  fetch<
    | {
        /**
         * A timestamp that tells you when the configuration was installed successfully
         *
         * @example 1558531915505
         */
        completedAt?: number;
        /**
         * A timestamp that tells you when the configuration was created
         *
         * @example 1558531915505
         */
        createdAt: number;
        /**
         * The unique identifier of the configuration
         *
         * @example icfg_3bwCLgxL8qt5kjRLcv2Dit7F
         */
        id: string;
        /**
         * The unique identifier of the app the configuration was created for
         *
         * @example oac_xzpVzcUOgcB1nrVlirtKhbWV
         */
        integrationId: string;
        /**
         * The user or team ID that owns the configuration
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        ownerId: string;
        /**
         * When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
         *
         * @example prj_xQxbutw1HpL6HLYPAzt5h75m8NjO
         */
        projects?: string[];
        /**
         * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
         *
         * @example marketplace
         */
        source?: 'marketplace' | 'deploy-button' | 'external';
        removedLogDrainsAt?: number;
        removedProjectEnvsAt?: number;
        removedTokensAt?: number;
        removedWebhooksAt?: number;
        /**
         * The slug of the integration the configuration is created for.
         *
         * @example slack
         */
        slug: string;
        /**
         * When the configuration was created for a team, this will show the ID of the team.
         *
         * @example team_nLlpyC6RE1qxydlFKbrxDlud
         */
        teamId?: string | null;
        type: 'integration-configuration';
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        updatedAt: number;
        /**
         * The ID of the user that created the configuration.
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        userId: string;
        /**
         * The resources that are allowed to be accessed by the configuration.
         *
         * @example read:project
         * @example read-write:log-drain
         */
        scopes: string[];
        scopesQueue?: {
          scopes: {
            added: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
              | 'read-write:integration-resource'
            )[];
            upgraded: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
              | 'read-write:integration-resource'
            )[];
          };
          note: string;
          requestedAt: number;
          confirmedAt?: number;
        }[];
        /**
         * A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
         *
         * @example 1558531915505
         */
        disabledAt?: number;
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        deletedAt?: number | null;
        disabledReason?:
          | 'disabled-by-owner'
          | 'feature-not-available'
          | 'disabled-by-admin'
          | 'original-owner-left-the-team'
          | 'account-plan-downgrade';
        /**
         * A timestamp that tells you when the configuration was migrated as part of the Northstar migration. In the future, if we allow integration configurations to be transferred between teams, this field should be cleared upon transfer.
         */
        northstarMigratedAt?: number;
        /**
         * Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
         */
        installationType?: 'marketplace' | 'external';
      }
    | {
        /**
         * A string representing the permission for projects. Possible values are `all` or `selected`.
         *
         * @example all
         */
        projectSelection: 'selected' | 'all';
        /**
         * When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
         *
         * @example prj_xQxbutw1HpL6HLYPAzt5h75m8NjO
         */
        projects?: string[];
        /**
         * A timestamp that tells you when the configuration was installed successfully
         *
         * @example 1558531915505
         */
        completedAt?: number;
        /**
         * A timestamp that tells you when the configuration was created
         *
         * @example 1558531915505
         */
        createdAt: number;
        /**
         * The unique identifier of the configuration
         *
         * @example icfg_3bwCLgxL8qt5kjRLcv2Dit7F
         */
        id: string;
        /**
         * The unique identifier of the app the configuration was created for
         *
         * @example oac_xzpVzcUOgcB1nrVlirtKhbWV
         */
        integrationId: string;
        /**
         * The user or team ID that owns the configuration
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        ownerId: string;
        /**
         * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
         *
         * @example marketplace
         */
        source?: 'marketplace' | 'deploy-button' | 'external';
        removedLogDrainsAt?: number;
        removedProjectEnvsAt?: number;
        removedTokensAt?: number;
        removedWebhooksAt?: number;
        /**
         * The slug of the integration the configuration is created for.
         *
         * @example slack
         */
        slug: string;
        /**
         * When the configuration was created for a team, this will show the ID of the team.
         *
         * @example team_nLlpyC6RE1qxydlFKbrxDlud
         */
        teamId?: string | null;
        type: 'integration-configuration';
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        updatedAt: number;
        /**
         * The ID of the user that created the configuration.
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        userId: string;
        /**
         * The resources that are allowed to be accessed by the configuration.
         *
         * @example read:project
         * @example read-write:log-drain
         */
        scopes: string[];
        scopesQueue?: {
          scopes: {
            added: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
              | 'read-write:integration-resource'
            )[];
            upgraded: (
              | 'read:integration-configuration'
              | 'read-write:integration-configuration'
              | 'read:deployment'
              | 'read-write:deployment'
              | 'read-write:deployment-check'
              | 'read:project'
              | 'read-write:project'
              | 'read-write:project-env-vars'
              | 'read-write:global-project-env-vars'
              | 'read:team'
              | 'read:user'
              | 'read-write:log-drain'
              | 'read:domain'
              | 'read-write:domain'
              | 'read-write:edge-config'
              | 'read-write:otel-endpoint'
              | 'read:monitoring'
              | 'read-write:integration-resource'
            )[];
          };
          note: string;
          requestedAt: number;
          confirmedAt?: number;
        }[];
        /**
         * A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
         *
         * @example 1558531915505
         */
        disabledAt?: number;
        /**
         * A timestamp that tells you when the configuration was updated.
         *
         * @example 1558531915505
         */
        deletedAt?: number | null;
        disabledReason?:
          | 'disabled-by-owner'
          | 'feature-not-available'
          | 'disabled-by-admin'
          | 'original-owner-left-the-team'
          | 'account-plan-downgrade';
        /**
         * A timestamp that tells you when the configuration was migrated as part of the Northstar migration. In the future, if we allow integration configurations to be transferred between teams, this field should be cleared upon transfer.
         */
        northstarMigratedAt?: number;
        /**
         * Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
         */
        installationType?: 'marketplace' | 'external';
        canConfigureOpenTelemetry?: boolean;
      },
    GetConfigurationError,
    undefined,
    {},
    GetConfigurationQueryParams,
    GetConfigurationPathParams
  >({ url: '/v1/integrations/configuration/{id}', method: 'get', ...variables, signal });

export type DeleteConfigurationPathParams = {
  id: string;
};

export type DeleteConfigurationQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type DeleteConfigurationError = Fetcher.ErrorWrapper<undefined>;

export type DeleteConfigurationVariables = {
  pathParams: DeleteConfigurationPathParams;
  queryParams?: DeleteConfigurationQueryParams;
} & FetcherExtraProps;

/**
 * Allows to remove the configuration with the `id` provided in the parameters. The configuration and all of its resources will be removed. This includes Webhooks, LogDrains and Project Env variables.
 */
export const deleteConfiguration = (variables: DeleteConfigurationVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    DeleteConfigurationError,
    undefined,
    {},
    DeleteConfigurationQueryParams,
    DeleteConfigurationPathParams
  >({ url: '/v1/integrations/configuration/{id}', method: 'delete', ...variables, signal });

export type GetIntegrationLogDrainsQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetIntegrationLogDrainsError = Fetcher.ErrorWrapper<undefined>;

export type GetIntegrationLogDrainsResponse = {
  /**
   * The oauth2 client application id that created this log drain
   *
   * @example oac_xRhY4LAB7yLhUADD69EvV7ct
   */
  clientId?: string;
  /**
   * The client configuration this log drain was created with
   *
   * @example icfg_cuwj0AdCdH3BwWT4LPijCC7t
   */
  configurationId?: string;
  /**
   * A timestamp that tells you when the log drain was created
   *
   * @example 1558531915505
   */
  createdAt: number;
  /**
   * The unique identifier of the log drain. Always prefixed with `ld_`
   *
   * @example ld_nBuA7zCID8g4QZ8g
   */
  id: string;
  /**
   * The delivery log format
   *
   * @example json
   */
  deliveryFormat?: 'json' | 'ndjson' | 'syslog';
  /**
   * The name of the log drain
   *
   * @example My first log drain
   */
  name: string;
  /**
   * The identifier of the team or user whose events will trigger the log drain
   *
   * @example kr1PsOIzqEL5Xg6M4VZcZosf
   */
  ownerId: string;
  /**
   * @example AbCgVkqoxXeXCDWehVir51LHGrrcWL4mkYm14W6UBPWQeb
   */
  projectId?: string | null;
  /**
   * The identifier of the projects this log drain is associated with
   *
   * @example AbCgVkqoxXeXCDWehVir51LHGrrcWL4mkYm14W6UBPWQeb
   */
  projectIds?: string[];
  /**
   * The URL to call when logs are generated
   *
   * @example https://example.com/log-drain
   */
  url: string;
  /**
   * The sources from which logs are currently being delivered to this log drain.
   *
   * @example build
   * @example edge
   */
  sources?: ('build' | 'edge' | 'lambda' | 'static' | 'external')[];
  /**
   * Whether the log drain was created by an integration or by a user
   *
   * @example integration
   */
  createdFrom?: 'self-served' | 'integration';
  /**
   * The headers to send with the request
   *
   * @example {"Authorization": "Bearer 123"}
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * The environment of log drain
   *
   * @example production
   */
  environments: ('production' | 'preview')[];
  /**
   * The branch regexp of log drain
   *
   * @example feature/*
   */
  branch?: string;
  /**
   * The sampling rate of log drain
   *
   * @example 0.5
   */
  samplingRate?: number;
}[];

export type GetIntegrationLogDrainsVariables = {
  queryParams?: GetIntegrationLogDrainsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of all Integration log drains that are defined for the authenticated user or team. When using an OAuth2 token, the list is limited to log drains created by the authenticated integration.
 */
export const getIntegrationLogDrains = (variables: GetIntegrationLogDrainsVariables, signal?: AbortSignal) =>
  fetch<
    GetIntegrationLogDrainsResponse,
    GetIntegrationLogDrainsError,
    undefined,
    {},
    GetIntegrationLogDrainsQueryParams,
    {}
  >({ url: '/v2/integrations/log-drains', method: 'get', ...variables, signal });

export type CreateLogDrainQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type CreateLogDrainError = Fetcher.ErrorWrapper<undefined>;

export type CreateLogDrainResponse = {
  /**
   * The oauth2 client application id that created this log drain
   *
   * @example oac_xRhY4LAB7yLhUADD69EvV7ct
   */
  clientId?: string;
  /**
   * The client configuration this log drain was created with
   *
   * @example icfg_cuwj0AdCdH3BwWT4LPijCC7t
   */
  configurationId?: string;
  /**
   * A timestamp that tells you when the log drain was created
   *
   * @example 1558531915505
   */
  createdAt: number;
  /**
   * The unique identifier of the log drain. Always prefixed with `ld_`
   *
   * @example ld_nBuA7zCID8g4QZ8g
   */
  id: string;
  /**
   * The delivery log format
   *
   * @example json
   */
  deliveryFormat?: 'json' | 'ndjson' | 'syslog';
  /**
   * The name of the log drain
   *
   * @example My first log drain
   */
  name: string;
  /**
   * The identifier of the team or user whose events will trigger the log drain
   *
   * @example kr1PsOIzqEL5Xg6M4VZcZosf
   */
  ownerId: string;
  /**
   * @example AbCgVkqoxXeXCDWehVir51LHGrrcWL4mkYm14W6UBPWQeb
   */
  projectId?: string | null;
  /**
   * The identifier of the projects this log drain is associated with
   *
   * @example AbCgVkqoxXeXCDWehVir51LHGrrcWL4mkYm14W6UBPWQeb
   */
  projectIds?: string[];
  /**
   * The URL to call when logs are generated
   *
   * @example https://example.com/log-drain
   */
  url: string;
  /**
   * The sources from which logs are currently being delivered to this log drain.
   *
   * @example build
   * @example edge
   */
  sources?: ('build' | 'edge' | 'lambda' | 'static' | 'external')[];
  /**
   * Whether the log drain was created by an integration or by a user
   *
   * @example integration
   */
  createdFrom?: 'self-served' | 'integration';
  /**
   * The headers to send with the request
   *
   * @example {"Authorization": "Bearer 123"}
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * The environment of log drain
   *
   * @example production
   */
  environments: ('production' | 'preview')[];
  /**
   * The branch regexp of log drain
   *
   * @example feature/*
   */
  branch?: string;
  /**
   * The sampling rate of log drain
   *
   * @example 0.5
   */
  samplingRate?: number;
};

export type CreateLogDrainRequestBody = {
  /**
   * The name of the log drain
   *
   * @example My first log drain
   * @maxLength 100
   * @pattern ^[A-z0-9_ -]+$
   */
  name: string;
  /**
   * @minItems 1
   * @maxItems 50
   */
  projectIds?: string[];
  /**
   * A secret to sign log drain notification headers so a consumer can verify their authenticity
   *
   * @example a1Xsfd325fXcs
   * @maxLength 100
   * @pattern ^[A-z0-9_ -]+$
   */
  secret?: string;
  /**
   * The delivery log format
   *
   * @example json
   */
  deliveryFormat?: 'json' | 'ndjson' | 'syslog';
  /**
   * The url where you will receive logs. The protocol must be `https://` or `http://` when type is `json` and `ndjson`, and `syslog+tls:` or `syslog:` when the type is `syslog`.
   *
   * @example https://example.com/log-drain
   * @format uri
   * @pattern ^(https?|syslog\\+tls|syslog)://
   */
  url: string;
  /**
   * @uniqueItems true
   * @minItems 1
   */
  sources?: ('static' | 'lambda' | 'build' | 'edge' | 'external')[];
  /**
   * Headers to be sent together with the request
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * @uniqueItems true
   * @minItems 1
   */
  environments?: ('preview' | 'production')[];
};

export type CreateLogDrainVariables = {
  body: CreateLogDrainRequestBody;
  queryParams?: CreateLogDrainQueryParams;
} & FetcherExtraProps;

/**
 * Creates an Integration log drain. This endpoint must be called with an OAuth2 client (integration), since log drains are tied to integrations. If it is called with a different token type it will produce a 400 error.
 */
export const createLogDrain = (variables: CreateLogDrainVariables, signal?: AbortSignal) =>
  fetch<CreateLogDrainResponse, CreateLogDrainError, CreateLogDrainRequestBody, {}, CreateLogDrainQueryParams, {}>({
    url: '/v2/integrations/log-drains',
    method: 'post',
    ...variables,
    signal
  });

export type DeleteIntegrationLogDrainPathParams = {
  /**
   * ID of the log drain to be deleted
   */
  id: string;
};

export type DeleteIntegrationLogDrainQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type DeleteIntegrationLogDrainError = Fetcher.ErrorWrapper<undefined>;

export type DeleteIntegrationLogDrainVariables = {
  pathParams: DeleteIntegrationLogDrainPathParams;
  queryParams?: DeleteIntegrationLogDrainQueryParams;
} & FetcherExtraProps;

/**
 * Deletes the Integration log drain with the provided `id`. When using an OAuth2 Token, the log drain can be deleted only if the integration owns it.
 */
export const deleteIntegrationLogDrain = (variables: DeleteIntegrationLogDrainVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    DeleteIntegrationLogDrainError,
    undefined,
    {},
    DeleteIntegrationLogDrainQueryParams,
    DeleteIntegrationLogDrainPathParams
  >({ url: '/v1/integrations/log-drains/{id}', method: 'delete', ...variables, signal });

export type GitNamespacesQueryParams = {
  /**
   * The custom Git host if using a custom Git provider, like GitHub Enterprise Server
   *
   * @example ghes-test.now.systems
   */
  host?: string;
  provider?: 'github' | 'github-custom-host' | 'gitlab' | 'bitbucket';
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GitNamespacesError = Fetcher.ErrorWrapper<undefined>;

export type GitNamespacesResponse = {
  provider: string;
  slug: string;
  id: string | number;
  ownerType: string;
  name?: string;
  isAccessRestricted?: boolean;
  installationId?: number;
  requireReauth?: boolean;
}[];

export type GitNamespacesVariables = {
  queryParams?: GitNamespacesQueryParams;
} & FetcherExtraProps;

/**
 * Lists git namespaces for a supported provider. Supported providers are `github`, `gitlab` and `bitbucket`. If the provider is not provided, it will try to obtain it from the user that authenticated the request.
 */
export const gitNamespaces = (variables: GitNamespacesVariables, signal?: AbortSignal) =>
  fetch<GitNamespacesResponse, GitNamespacesError, undefined, {}, GitNamespacesQueryParams, {}>({
    url: '/v1/integrations/git-namespaces',
    method: 'get',
    ...variables,
    signal
  });

export type SearchRepoQueryParams = {
  query?: string;
  namespaceId?: void | null;
  provider?: 'github' | 'github-custom-host' | 'gitlab' | 'bitbucket';
  installationId?: string;
  /**
   * The custom Git host if using a custom Git provider, like GitHub Enterprise Server
   *
   * @example ghes-test.now.systems
   */
  host?: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type SearchRepoError = Fetcher.ErrorWrapper<undefined>;

export type SearchRepoResponse = {
  gitAccount: {
    provider: 'github' | 'github-custom-host' | 'gitlab' | 'bitbucket';
    namespaceId: string | number | null;
  };
  repos: {
    id: string | number;
    provider: 'github' | 'github-custom-host' | 'gitlab' | 'bitbucket';
    url: string;
    name: string;
    slug: string;
    namespace: string;
    owner: {
      id: string | number;
      name: string;
    };
    ownerType: 'user' | 'team';
    private: boolean;
    defaultBranch: string;
    updatedAt: number;
  }[];
};

export type SearchRepoVariables = {
  queryParams?: SearchRepoQueryParams;
} & FetcherExtraProps;

/**
 * Lists git repositories linked to a namespace `id` for a supported provider. A specific namespace `id` can be obtained via the `git-namespaces`  endpoint. Supported providers are `github`, `gitlab` and `bitbucket`. If the provider or namespace is not provided, it will try to obtain it from the user that authenticated the request.
 */
export const searchRepo = (variables: SearchRepoVariables, signal?: AbortSignal) =>
  fetch<SearchRepoResponse, SearchRepoError, undefined, {}, SearchRepoQueryParams, {}>({
    url: '/v1/integrations/search-repo',
    method: 'get',
    ...variables,
    signal
  });

export type GetConfigurableLogDrainPathParams = {
  id: string;
};

export type GetConfigurableLogDrainQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetConfigurableLogDrainError = Fetcher.ErrorWrapper<undefined>;

export type GetConfigurableLogDrainResponse = {
  id: string;
  deliveryFormat: 'json' | 'ndjson' | 'syslog';
  url: string;
  name: string;
  clientId?: string;
  configurationId?: string;
  teamId?: string | null;
  ownerId: string;
  projectIds?: string[];
  createdAt: number;
  deletedAt: number | null;
  updatedAt: number;
  sources?: ('build' | 'edge' | 'lambda' | 'static' | 'external')[];
  headers?: {
    [key: string]: string;
  };
  environments: ('production' | 'preview')[];
  status?: 'enabled' | 'disabled' | 'errored';
  disabledAt?: number;
  disabledReason?: 'disabled-by-owner' | 'feature-not-available' | 'account-plan-downgrade' | 'disabled-by-admin';
  disabledBy?: string;
  firstErrorTimestamp?: number;
  samplingRate?: number;
  compression?: 'gzip' | 'zstd' | 'none';
  secret: string;
  createdFrom?: 'self-served';
};

export type GetConfigurableLogDrainVariables = {
  pathParams: GetConfigurableLogDrainPathParams;
  queryParams?: GetConfigurableLogDrainQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a Configurable Log Drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be accessed.
 */
export const getConfigurableLogDrain = (variables: GetConfigurableLogDrainVariables, signal?: AbortSignal) =>
  fetch<
    GetConfigurableLogDrainResponse,
    GetConfigurableLogDrainError,
    undefined,
    {},
    GetConfigurableLogDrainQueryParams,
    GetConfigurableLogDrainPathParams
  >({ url: '/v1/log-drains/{id}', method: 'get', ...variables, signal });

export type DeleteConfigurableLogDrainPathParams = {
  id: string;
};

export type DeleteConfigurableLogDrainQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type DeleteConfigurableLogDrainError = Fetcher.ErrorWrapper<undefined>;

export type DeleteConfigurableLogDrainVariables = {
  pathParams: DeleteConfigurableLogDrainPathParams;
  queryParams?: DeleteConfigurableLogDrainQueryParams;
} & FetcherExtraProps;

/**
 * Deletes a Configurable Log Drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated team can be deleted.
 */
export const deleteConfigurableLogDrain = (variables: DeleteConfigurableLogDrainVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    DeleteConfigurableLogDrainError,
    undefined,
    {},
    DeleteConfigurableLogDrainQueryParams,
    DeleteConfigurableLogDrainPathParams
  >({ url: '/v1/log-drains/{id}', method: 'delete', ...variables, signal });

export type GetAllLogDrainsQueryParams = {
  /**
   * @pattern ^[a-zA-z0-9_]+$
   */
  projectId?: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetAllLogDrainsError = Fetcher.ErrorWrapper<undefined>;

export type GetAllLogDrainsResponse = {
  id: string;
  deliveryFormat: 'json' | 'ndjson' | 'syslog';
  url: string;
  name: string;
  clientId?: string;
  configurationId?: string;
  teamId?: string | null;
  ownerId: string;
  projectIds?: string[];
  createdAt: number;
  deletedAt: number | null;
  updatedAt: number;
  sources?: ('build' | 'edge' | 'lambda' | 'static' | 'external')[];
  headers?: {
    [key: string]: string;
  };
  environments: ('production' | 'preview')[];
  status?: 'enabled' | 'disabled' | 'errored';
  disabledAt?: number;
  disabledReason?: 'disabled-by-owner' | 'feature-not-available' | 'account-plan-downgrade' | 'disabled-by-admin';
  disabledBy?: string;
  firstErrorTimestamp?: number;
  samplingRate?: number;
  compression?: 'gzip' | 'zstd' | 'none';
  secret: string;
  createdFrom?: 'self-served';
}[];

export type GetAllLogDrainsVariables = {
  queryParams?: GetAllLogDrainsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of all the Log Drains owned by the account. This endpoint must be called with an account AccessToken (integration OAuth2 clients are not allowed). Only log drains owned by the authenticated account can be accessed.
 */
export const getAllLogDrains = (variables: GetAllLogDrainsVariables, signal?: AbortSignal) =>
  fetch<GetAllLogDrainsResponse, GetAllLogDrainsError, undefined, {}, GetAllLogDrainsQueryParams, {}>({
    url: '/v1/log-drains',
    method: 'get',
    ...variables,
    signal
  });

export type CreateConfigurableLogDrainQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type CreateConfigurableLogDrainError = Fetcher.ErrorWrapper<undefined>;

export type CreateConfigurableLogDrainResponse = {
  /**
   * The secret to validate the log-drain payload
   */
  secret?: string;
  id: string;
  deliveryFormat: 'json' | 'ndjson' | 'syslog';
  url: string;
  name: string;
  clientId?: string;
  configurationId?: string;
  teamId?: string | null;
  ownerId: string;
  projectIds?: string[];
  createdAt: number;
  deletedAt: number | null;
  updatedAt: number;
  sources?: ('build' | 'edge' | 'lambda' | 'static' | 'external')[];
  headers?: {
    [key: string]: string;
  };
  environments: ('production' | 'preview')[];
  status?: 'enabled' | 'disabled' | 'errored';
  disabledAt?: number;
  disabledReason?: 'disabled-by-owner' | 'feature-not-available' | 'account-plan-downgrade' | 'disabled-by-admin';
  disabledBy?: string;
  firstErrorTimestamp?: number;
  samplingRate?: number;
  compression?: 'gzip' | 'zstd' | 'none';
  createdFrom?: 'self-served';
};

export type CreateConfigurableLogDrainRequestBody = {
  /**
   * The delivery log format
   *
   * @example json
   */
  deliveryFormat: 'json' | 'ndjson';
  /**
   * The log drain url
   *
   * @format uri
   * @pattern ^(http|https)?://
   */
  url: string;
  /**
   * Headers to be sent together with the request
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * @minItems 1
   * @maxItems 50
   */
  projectIds?: string[];
  /**
   * @uniqueItems true
   * @minItems 1
   */
  sources: ('static' | 'lambda' | 'build' | 'edge' | 'external')[];
  /**
   * @uniqueItems true
   * @minItems 1
   */
  environments?: ('preview' | 'production')[];
  /**
   * Custom secret of log drain
   */
  secret?: string;
  /**
   * The sampling rate for this log drain. It should be a percentage rate between 0 and 100. With max 2 decimal points
   *
   * @minimum 0.01
   * @maximum 1
   */
  samplingRate?: number;
};

export type CreateConfigurableLogDrainVariables = {
  body: CreateConfigurableLogDrainRequestBody;
  queryParams?: CreateConfigurableLogDrainQueryParams;
} & FetcherExtraProps;

/**
 * Creates a configurable log drain. This endpoint must be called with a team AccessToken (integration OAuth2 clients are not allowed)
 */
export const createConfigurableLogDrain = (variables: CreateConfigurableLogDrainVariables, signal?: AbortSignal) =>
  fetch<
    CreateConfigurableLogDrainResponse,
    CreateConfigurableLogDrainError,
    CreateConfigurableLogDrainRequestBody,
    {},
    CreateConfigurableLogDrainQueryParams,
    {}
  >({ url: '/v1/log-drains', method: 'post', ...variables, signal });

export type GetProjectMembersPathParams = {
  /**
   * The ID or name of the Project.
   *
   * @example prj_pavWOn1iLObbXLRiwVvzmPrTWyTf
   */
  idOrName: string;
};

export type GetProjectMembersQueryParams = {
  /**
   * Limit how many project members should be returned
   *
   * @example 20
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
  /**
   * Timestamp in milliseconds to only include members added since then.
   *
   * @example 1540095775951
   */
  since?: number;
  /**
   * Timestamp in milliseconds to only include members added until then.
   *
   * @example 1540095775951
   */
  until?: number;
  /**
   * Search project members by their name, username, and email.
   */
  search?: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetProjectMembersError = Fetcher.ErrorWrapper<undefined>;

export type GetProjectMembersVariables = {
  pathParams: GetProjectMembersPathParams;
  queryParams?: GetProjectMembersQueryParams;
} & FetcherExtraProps;

/**
 * Lists all members of a project.
 */
export const getProjectMembers = (variables: GetProjectMembersVariables, signal?: AbortSignal) =>
  fetch<
    | Record<string, any>
    | {
        members: {
          /**
           * ID of the file for the Avatar of this member.
           *
           * @example 123a6c5209bc3778245d011443644c8d27dc2c50
           */
          avatar?: string;
          /**
           * The email of this member.
           *
           * @example jane.doe@example.com
           */
          email: string;
          /**
           * Role of this user in the project.
           *
           * @example ADMIN
           */
          role: 'ADMIN' | 'PROJECT_DEVELOPER' | 'PROJECT_VIEWER';
          /**
           * Role of this user in the project.
           *
           * @example ADMIN
           */
          computedProjectRole: 'ADMIN' | 'PROJECT_DEVELOPER' | 'PROJECT_VIEWER';
          /**
           * The ID of this user.
           *
           * @example zTuNVUXEAvvnNN3IaqinkyMw
           */
          uid: string;
          /**
           * The unique username of this user.
           *
           * @example jane-doe
           */
          username: string;
          /**
           * The name of this user.
           *
           * @example Jane Doe
           */
          name?: string;
          /**
           * Timestamp in milliseconds when this member was added.
           *
           * @example 1588720733602
           */
          createdAt: number;
          /**
           * The role of this user in the team.
           *
           * @example CONTRIBUTOR
           */
          teamRole: 'OWNER' | 'MEMBER' | 'DEVELOPER' | 'BILLING' | 'VIEWER' | 'CONTRIBUTOR';
        }[];
        pagination: {
          hasNext: boolean;
          /**
           * Amount of items in the current page.
           *
           * @example 20
           */
          count: number;
          /**
           * Timestamp that must be used to request the next page.
           *
           * @example 1540095775951
           */
          next: number | null;
          /**
           * Timestamp that must be used to request the previous page.
           *
           * @example 1540095775951
           */
          prev: number | null;
        };
      },
    GetProjectMembersError,
    undefined,
    {},
    GetProjectMembersQueryParams,
    GetProjectMembersPathParams
  >({ url: '/v1/projects/{idOrName}/members', method: 'get', ...variables, signal });

export type AddProjectMemberPathParams = {
  /**
   * The ID or name of the Project.
   *
   * @example prj_pavWOn1iLObbXLRiwVvzmPrTWyTf
   */
  idOrName: string;
};

export type AddProjectMemberQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type AddProjectMemberError = Fetcher.ErrorWrapper<undefined>;

export type AddProjectMemberResponse = {
  id: string;
};

export type AddProjectMemberVariables = {
  body:
    | {
        /**
         * The ID of the team member that should be added to this project.
         *
         * @maxLength 256
         * @example ndlgr43fadlPyCtREAqxxdyFK
         */
        uid: string;
        /**
         * The username of the team member that should be added to this project.
         *
         * @maxLength 256
         * @example example
         */
        username?: string;
        /**
         * The email of the team member that should be added to this project.
         *
         * @format email
         * @example entity@example.com
         */
        email?: string;
        /**
         * The project role of the member that will be added.
         *
         * @example ADMIN
         */
        role?: 'ADMIN' | 'PROJECT_DEVELOPER' | 'PROJECT_VIEWER';
      }
    | {
        /**
         * The ID of the team member that should be added to this project.
         *
         * @maxLength 256
         * @example ndlgr43fadlPyCtREAqxxdyFK
         */
        uid?: string;
        /**
         * The username of the team member that should be added to this project.
         *
         * @maxLength 256
         * @example example
         */
        username: string;
        /**
         * The email of the team member that should be added to this project.
         *
         * @format email
         * @example entity@example.com
         */
        email?: string;
        /**
         * The project role of the member that will be added.
         *
         * @example ADMIN
         */
        role?: 'ADMIN' | 'PROJECT_DEVELOPER' | 'PROJECT_VIEWER';
      }
    | {
        /**
         * The ID of the team member that should be added to this project.
         *
         * @maxLength 256
         * @example ndlgr43fadlPyCtREAqxxdyFK
         */
        uid?: string;
        /**
         * The username of the team member that should be added to this project.
         *
         * @maxLength 256
         * @example example
         */
        username?: string;
        /**
         * The email of the team member that should be added to this project.
         *
         * @format email
         * @example entity@example.com
         */
        email: string;
        /**
         * The project role of the member that will be added.
         *
         * @example ADMIN
         */
        role?: 'ADMIN' | 'PROJECT_DEVELOPER' | 'PROJECT_VIEWER';
      };
  pathParams: AddProjectMemberPathParams;
  queryParams?: AddProjectMemberQueryParams;
} & FetcherExtraProps;

/**
 * Adds a new member to the project.
 */
export const addProjectMember = (variables: AddProjectMemberVariables, signal?: AbortSignal) =>
  fetch<
    AddProjectMemberResponse,
    AddProjectMemberError,
    | {
        /**
         * The ID of the team member that should be added to this project.
         *
         * @maxLength 256
         * @example ndlgr43fadlPyCtREAqxxdyFK
         */
        uid: string;
        /**
         * The username of the team member that should be added to this project.
         *
         * @maxLength 256
         * @example example
         */
        username?: string;
        /**
         * The email of the team member that should be added to this project.
         *
         * @format email
         * @example entity@example.com
         */
        email?: string;
        /**
         * The project role of the member that will be added.
         *
         * @example ADMIN
         */
        role?: 'ADMIN' | 'PROJECT_DEVELOPER' | 'PROJECT_VIEWER';
      }
    | {
        /**
         * The ID of the team member that should be added to this project.
         *
         * @maxLength 256
         * @example ndlgr43fadlPyCtREAqxxdyFK
         */
        uid?: string;
        /**
         * The username of the team member that should be added to this project.
         *
         * @maxLength 256
         * @example example
         */
        username: string;
        /**
         * The email of the team member that should be added to this project.
         *
         * @format email
         * @example entity@example.com
         */
        email?: string;
        /**
         * The project role of the member that will be added.
         *
         * @example ADMIN
         */
        role?: 'ADMIN' | 'PROJECT_DEVELOPER' | 'PROJECT_VIEWER';
      }
    | {
        /**
         * The ID of the team member that should be added to this project.
         *
         * @maxLength 256
         * @example ndlgr43fadlPyCtREAqxxdyFK
         */
        uid?: string;
        /**
         * The username of the team member that should be added to this project.
         *
         * @maxLength 256
         * @example example
         */
        username?: string;
        /**
         * The email of the team member that should be added to this project.
         *
         * @format email
         * @example entity@example.com
         */
        email: string;
        /**
         * The project role of the member that will be added.
         *
         * @example ADMIN
         */
        role?: 'ADMIN' | 'PROJECT_DEVELOPER' | 'PROJECT_VIEWER';
      },
    {},
    AddProjectMemberQueryParams,
    AddProjectMemberPathParams
  >({ url: '/v1/projects/{idOrName}/members', method: 'post', ...variables, signal });

export type RemoveProjectMemberPathParams = {
  /**
   * The ID or name of the Project.
   *
   * @example prj_pavWOn1iLObbXLRiwVvzmPrTWyTf
   */
  idOrName: string;
  /**
   * The user ID of the member.
   *
   * @example ndlgr43fadlPyCtREAqxxdyFK
   */
  uid: string;
};

export type RemoveProjectMemberQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type RemoveProjectMemberError = Fetcher.ErrorWrapper<undefined>;

export type RemoveProjectMemberResponse = {
  id: string;
};

export type RemoveProjectMemberVariables = {
  pathParams: RemoveProjectMemberPathParams;
  queryParams?: RemoveProjectMemberQueryParams;
} & FetcherExtraProps;

/**
 * Remove a member from a specific project
 */
export const removeProjectMember = (variables: RemoveProjectMemberVariables, signal?: AbortSignal) =>
  fetch<
    RemoveProjectMemberResponse,
    RemoveProjectMemberError,
    undefined,
    {},
    RemoveProjectMemberQueryParams,
    RemoveProjectMemberPathParams
  >({ url: '/v1/projects/{idOrName}/members/{uid}', method: 'delete', ...variables, signal });

export type GetProjectsQueryParams = {
  /**
   * Query only projects updated after the given timestamp
   */
  from?: string;
  /**
   * Specifies whether PRs from Git forks should require a team member's authorization before it can be deployed
   *
   * @example 1
   */
  gitForkProtection?: '1' | '0';
  /**
   * Limit the number of projects returned
   */
  limit?: string;
  /**
   * Search projects by the name field
   */
  search?: string;
  /**
   * Filter results by repo. Also used for project count
   */
  repo?: string;
  /**
   * Filter results by Repository ID.
   */
  repoId?: string;
  /**
   * Filter results by Repository URL.
   *
   * @example https://github.com/vercel/next.js
   */
  repoUrl?: string;
  /**
   * Filter results by excluding those projects that belong to a repo
   */
  excludeRepos?: string;
  /**
   * Filter results by connected Edge Config ID
   */
  edgeConfigId?: string;
  /**
   * Filter results by connected Edge Config Token ID
   */
  edgeConfigTokenId?: string;
  deprecated?: boolean;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetProjectsError = Fetcher.ErrorWrapper<undefined>;

export type GetProjectsResponse = {
  projects: {
    accountId: string;
    analytics?: {
      id: string;
      canceledAt?: number | null;
      disabledAt: number;
      enabledAt: number;
      paidAt?: number;
      sampleRatePercent?: number | null;
      spendLimitInDollars?: number | null;
    };
    speedInsights?: {
      id: string;
      enabledAt?: number;
      disabledAt?: number;
      canceledAt?: number;
      hasData?: boolean;
      paidAt?: number;
    };
    autoExposeSystemEnvs?: boolean;
    autoAssignCustomDomains?: boolean;
    autoAssignCustomDomainsUpdatedBy?: string;
    buildCommand?: string | null;
    commandForIgnoringBuildStep?: string | null;
    connectConfigurationId?: string | null;
    connectBuildsEnabled?: boolean;
    createdAt?: number;
    customerSupportCodeVisibility?: boolean;
    crons?: {
      /**
       * The time the feature was enabled for this project. Note: It enables automatically with the first Deployment that outputs cronjobs.
       */
      enabledAt: number;
      /**
       * The time the feature was disabled for this project.
       */
      disabledAt: number | null;
      updatedAt: number;
      /**
       * The ID of the Deployment from which the definitions originated.
       */
      deploymentId: string | null;
      definitions: {
        /**
         * The hostname that should be used.
         *
         * @example vercel.com
         */
        host: string;
        /**
         * The path that should be called for the cronjob.
         *
         * @example /api/crons/sync-something?hello=world
         */
        path: string;
        /**
         * The cron expression.
         *
         * @example 0 0 * * *
         */
        schedule: string;
      }[];
    };
    dataCache?: {
      userDisabled: boolean;
      storageSizeBytes?: number | null;
      unlimited?: boolean;
    };
    deploymentExpiration?: {
      expirationDays?: number;
      expirationDaysProduction?: number;
      expirationDaysCanceled?: number;
      expirationDaysErrored?: number;
      deploymentsToKeep?: number;
    } | null;
    devCommand?: string | null;
    directoryListing: boolean;
    installCommand?: string | null;
    env?: {
      target?:
        | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
        | ('production' | 'preview' | 'development' | 'preview' | 'development');
      type: 'system' | 'encrypted' | 'plain' | 'sensitive' | 'secret';
      /**
       * This is used to identiy variables that have been migrated from type secret to sensitive.
       */
      sunsetSecretId?: string;
      id?: string;
      key: string;
      value: string;
      configurationId?: string | null;
      createdAt?: number;
      updatedAt?: number;
      createdBy?: string | null;
      updatedBy?: string | null;
      gitBranch?: string;
      edgeConfigId?: string | null;
      edgeConfigTokenId?: string | null;
      contentHint?:
        | {
            type: 'redis-url';
            storeId: string;
          }
        | {
            type: 'redis-rest-api-url';
            storeId: string;
          }
        | {
            type: 'redis-rest-api-token';
            storeId: string;
          }
        | {
            type: 'redis-rest-api-read-only-token';
            storeId: string;
          }
        | {
            type: 'blob-read-write-token';
            storeId: string;
          }
        | {
            type: 'postgres-url';
            storeId: string;
          }
        | {
            type: 'postgres-url-non-pooling';
            storeId: string;
          }
        | {
            type: 'postgres-prisma-url';
            storeId: string;
          }
        | {
            type: 'postgres-user';
            storeId: string;
          }
        | {
            type: 'postgres-host';
            storeId: string;
          }
        | {
            type: 'postgres-password';
            storeId: string;
          }
        | {
            type: 'postgres-database';
            storeId: string;
          }
        | {
            type: 'postgres-url-no-ssl';
            storeId: string;
          }
        | {
            type: 'integration-store-secret';
            storeId: string;
          }
        | null;
      /**
       * Similar to `contentHints`, but should not be exposed to the user.
       */
      internalContentHint?: {
        type: 'flags-secret';
        /**
         * Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
         */
        encryptedValue: string;
      } | null;
      /**
       * Whether `value` is decrypted.
       */
      decrypted?: boolean;
      comment?: string;
      customEnvironmentIds?: string[];
    }[];
    framework?:
      | 'blitzjs'
      | 'nextjs'
      | 'gatsby'
      | 'remix'
      | 'astro'
      | 'hexo'
      | 'eleventy'
      | 'docusaurus-2'
      | 'docusaurus'
      | 'preact'
      | 'solidstart-1'
      | 'solidstart'
      | 'dojo'
      | 'ember'
      | 'vue'
      | 'scully'
      | 'ionic-angular'
      | 'angular'
      | 'polymer'
      | 'svelte'
      | 'sveltekit'
      | 'sveltekit-1'
      | 'ionic-react'
      | 'create-react-app'
      | 'gridsome'
      | 'umijs'
      | 'sapper'
      | 'saber'
      | 'stencil'
      | 'nuxtjs'
      | 'redwoodjs'
      | 'hugo'
      | 'jekyll'
      | 'brunch'
      | 'middleman'
      | 'zola'
      | 'hydrogen'
      | 'vite'
      | 'vitepress'
      | 'vuepress'
      | 'parcel'
      | 'sanity'
      | 'storybook'
      | null;
    gitForkProtection?: boolean;
    gitLFS?: boolean;
    id: string;
    latestDeployments?: {
      alias?: string[];
      aliasAssigned?: number | boolean | null;
      aliasError?: {
        code: string;
        message: string;
      } | null;
      aliasFinal?: string | null;
      automaticAliases?: string[];
      builds?: {
        use: string;
        src?: string;
        dest?: string;
      }[];
      connectBuildsEnabled?: boolean;
      connectConfigurationId?: string;
      createdAt: number;
      createdIn: string;
      creator: {
        email: string;
        githubLogin?: string;
        gitlabLogin?: string;
        uid: string;
        username: string;
      } | null;
      deletedAt?: number;
      deploymentHostname: string;
      name: string;
      forced?: boolean;
      id: string;
      meta?: {
        [key: string]: string;
      };
      monorepoManager?: string | null;
      plan: 'pro' | 'enterprise' | 'hobby';
      private: boolean;
      readyState: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED';
      readySubstate?: 'STAGED' | 'PROMOTED';
      requestedAt?: number;
      target?: string | null;
      teamId?: string | null;
      type: 'LAMBDAS';
      url: string;
      userId: string;
      withCache?: boolean;
      checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
      checksState?: 'registered' | 'running' | 'completed';
      readyAt?: number;
      buildingAt?: number;
      /**
       * Whether or not preview comments are enabled for the deployment
       *
       * @example false
       */
      previewCommentsEnabled?: boolean;
      oidcTokenClaims?: {
        [key: string]: string | string[];
      };
    }[];
    link?:
      | {
          org?: string;
          repo?: string;
          repoId?: number;
          type?: 'github';
          createdAt?: number;
          deployHooks: {
            createdAt?: number;
            id: string;
            name: string;
            ref: string;
            url: string;
          }[];
          gitCredentialId?: string;
          updatedAt?: number;
          sourceless?: boolean;
          productionBranch?: string;
        }
      | {
          projectId?: string;
          projectName?: string;
          projectNameWithNamespace?: string;
          projectNamespace?: string;
          projectUrl?: string;
          type?: 'gitlab';
          createdAt?: number;
          deployHooks: {
            createdAt?: number;
            id: string;
            name: string;
            ref: string;
            url: string;
          }[];
          gitCredentialId?: string;
          updatedAt?: number;
          sourceless?: boolean;
          productionBranch?: string;
        }
      | {
          name?: string;
          slug?: string;
          owner?: string;
          type?: 'bitbucket';
          uuid?: string;
          workspaceUuid?: string;
          createdAt?: number;
          deployHooks: {
            createdAt?: number;
            id: string;
            name: string;
            ref: string;
            url: string;
          }[];
          gitCredentialId?: string;
          updatedAt?: number;
          sourceless?: boolean;
          productionBranch?: string;
        };
    name: string;
    nodeVersion: '20.x' | '18.x' | '16.x' | '14.x' | '12.x' | '10.x' | '8.10.x';
    optionsAllowlist?: {
      paths: {
        value: string;
      }[];
    } | null;
    outputDirectory?: string | null;
    passiveConnectConfigurationId?: string | null;
    passwordProtection?: Record<string, any> | null;
    productionDeploymentsFastLane?: boolean;
    publicSource?: boolean | null;
    rootDirectory?: string | null;
    serverlessFunctionRegion?: string | null;
    serverlessFunctionZeroConfigFailover?: boolean;
    skewProtectionBoundaryAt?: number;
    skewProtectionMaxAge?: number;
    skipGitConnectDuringLink?: boolean;
    sourceFilesOutsideRootDirectory?: boolean;
    ssoProtection?: {
      deploymentType: 'all' | 'preview' | 'prod_deployment_urls_and_all_previews';
    } | null;
    targets?: {
      [key: string]: string | string[];
    };
    transferCompletedAt?: number;
    transferStartedAt?: number;
    transferToAccountId?: string;
    transferredFromAccountId?: string;
    updatedAt?: number;
    live?: boolean;
    enablePreviewFeedback?: boolean | null;
    permissions?: {
      accessGroup?: Schemas.ACLAction[];
      aliasGlobal?: Schemas.ACLAction[];
      analyticsSampling?: Schemas.ACLAction[];
      analyticsUsage?: Schemas.ACLAction[];
      auditLog?: Schemas.ACLAction[];
      billingAddress?: Schemas.ACLAction[];
      billingInformation?: Schemas.ACLAction[];
      billingInvoice?: Schemas.ACLAction[];
      billingInvoiceEmailRecipient?: Schemas.ACLAction[];
      billingInvoiceLanguage?: Schemas.ACLAction[];
      billingPlan?: Schemas.ACLAction[];
      billingPurchaseOrder?: Schemas.ACLAction[];
      billingTaxId?: Schemas.ACLAction[];
      blob?: Schemas.ACLAction[];
      budget?: Schemas.ACLAction[];
      cacheArtifact?: Schemas.ACLAction[];
      cacheArtifactUsageEvent?: Schemas.ACLAction[];
      codeChecks?: Schemas.ACLAction[];
      concurrentBuilds?: Schemas.ACLAction[];
      connect?: Schemas.ACLAction[];
      connectConfiguration?: Schemas.ACLAction[];
      domain?: Schemas.ACLAction[];
      domainAcceptDelegation?: Schemas.ACLAction[];
      domainAuthCodes?: Schemas.ACLAction[];
      domainCertificate?: Schemas.ACLAction[];
      domainCheckConfig?: Schemas.ACLAction[];
      domainMove?: Schemas.ACLAction[];
      domainPurchase?: Schemas.ACLAction[];
      domainRecord?: Schemas.ACLAction[];
      domainTransferIn?: Schemas.ACLAction[];
      event?: Schemas.ACLAction[];
      ownEvent?: Schemas.ACLAction[];
      sensitiveEnvironmentVariablePolicy?: Schemas.ACLAction[];
      fileUpload?: Schemas.ACLAction[];
      gitRepository?: Schemas.ACLAction[];
      ipBlocking?: Schemas.ACLAction[];
      integration?: Schemas.ACLAction[];
      integrationAccount?: Schemas.ACLAction[];
      integrationConfiguration?: Schemas.ACLAction[];
      integrationConfigurationTransfer?: Schemas.ACLAction[];
      integrationConfigurationProjects?: Schemas.ACLAction[];
      integrationVercelConfigurationOverride?: Schemas.ACLAction[];
      integrationResource?: Schemas.ACLAction[];
      integrationEvent?: Schemas.ACLAction[];
      integrationResourceSecrets?: Schemas.ACLAction[];
      marketplaceBillingData?: Schemas.ACLAction[];
      marketplaceInvoice?: Schemas.ACLAction[];
      jobGlobal?: Schemas.ACLAction[];
      logDrain?: Schemas.ACLAction[];
      Monitoring?: Schemas.ACLAction[];
      monitoringSettings?: Schemas.ACLAction[];
      monitoringQuery?: Schemas.ACLAction[];
      monitoringChart?: Schemas.ACLAction[];
      monitoringAlert?: Schemas.ACLAction[];
      notificationDeploymentFailed?: Schemas.ACLAction[];
      notificationDomainConfiguration?: Schemas.ACLAction[];
      notificationDomainExpire?: Schemas.ACLAction[];
      notificationDomainMoved?: Schemas.ACLAction[];
      notificationDomainPurchase?: Schemas.ACLAction[];
      notificationDomainRenewal?: Schemas.ACLAction[];
      notificationDomainTransfer?: Schemas.ACLAction[];
      notificationDomainUnverified?: Schemas.ACLAction[];
      NotificationMonitoringAlert?: Schemas.ACLAction[];
      notificationPaymentFailed?: Schemas.ACLAction[];
      notificationUsageAlert?: Schemas.ACLAction[];
      notificationCustomerBudget?: Schemas.ACLAction[];
      notificationStatementOfReasons?: Schemas.ACLAction[];
      oauth2Connection?: Schemas.ACLAction[];
      openTelemetryEndpoint?: Schemas.ACLAction[];
      paymentMethod?: Schemas.ACLAction[];
      permissions?: Schemas.ACLAction[];
      postgres?: Schemas.ACLAction[];
      previewDeploymentSuffix?: Schemas.ACLAction[];
      proTrialOnboarding?: Schemas.ACLAction[];
      sharedEnvVars?: Schemas.ACLAction[];
      sharedEnvVarsProduction?: Schemas.ACLAction[];
      space?: Schemas.ACLAction[];
      spaceRun?: Schemas.ACLAction[];
      passwordProtectionInvoiceItem?: Schemas.ACLAction[];
      rateLimit?: Schemas.ACLAction[];
      redis?: Schemas.ACLAction[];
      repository?: Schemas.ACLAction[];
      remoteCaching?: Schemas.ACLAction[];
      samlConfig?: Schemas.ACLAction[];
      secret?: Schemas.ACLAction[];
      redisStoreTokenSet?: Schemas.ACLAction[];
      blobStoreTokenSet?: Schemas.ACLAction[];
      postgresStoreTokenSet?: Schemas.ACLAction[];
      integrationStoreTokenSet?: Schemas.ACLAction[];
      supportCase?: Schemas.ACLAction[];
      supportCaseComment?: Schemas.ACLAction[];
      dataCacheBillingSettings?: Schemas.ACLAction[];
      team?: Schemas.ACLAction[];
      teamAccessRequest?: Schemas.ACLAction[];
      teamFellowMembership?: Schemas.ACLAction[];
      teamGitExclusivity?: Schemas.ACLAction[];
      teamInvite?: Schemas.ACLAction[];
      teamInviteCode?: Schemas.ACLAction[];
      teamJoin?: Schemas.ACLAction[];
      teamOwnMembership?: Schemas.ACLAction[];
      teamOwnMembershipDisconnectSAML?: Schemas.ACLAction[];
      token?: Schemas.ACLAction[];
      usage?: Schemas.ACLAction[];
      usageCycle?: Schemas.ACLAction[];
      user?: Schemas.ACLAction[];
      userConnection?: Schemas.ACLAction[];
      webAnalyticsPlan?: Schemas.ACLAction[];
      webAuthn?: Schemas.ACLAction[];
      edgeConfig?: Schemas.ACLAction[];
      edgeConfigItem?: Schemas.ACLAction[];
      edgeConfigSchema?: Schemas.ACLAction[];
      edgeConfigToken?: Schemas.ACLAction[];
      webhook?: Schemas.ACLAction[];
      ['webhook-event']?: Schemas.ACLAction[];
      endpointVerification?: Schemas.ACLAction[];
      projectTransferIn?: Schemas.ACLAction[];
      oauth2Application?: Schemas.ACLAction[];
      aliasProject?: Schemas.ACLAction[];
      aliasProtectionBypass?: Schemas.ACLAction[];
      productionAliasProtectionBypass?: Schemas.ACLAction[];
      connectConfigurationLink?: Schemas.ACLAction[];
      dataCacheNamespace?: Schemas.ACLAction[];
      deployment?: Schemas.ACLAction[];
      deploymentCheck?: Schemas.ACLAction[];
      deploymentCheckPreview?: Schemas.ACLAction[];
      deploymentCheckReRunFromProductionBranch?: Schemas.ACLAction[];
      deploymentProductionGit?: Schemas.ACLAction[];
      deploymentPreview?: Schemas.ACLAction[];
      deploymentPrivate?: Schemas.ACLAction[];
      deploymentPromote?: Schemas.ACLAction[];
      deploymentRollback?: Schemas.ACLAction[];
      environments?: Schemas.ACLAction[];
      logs?: Schemas.ACLAction[];
      logsPreset?: Schemas.ACLAction[];
      passwordProtection?: Schemas.ACLAction[];
      optionsAllowlist?: Schemas.ACLAction[];
      job?: Schemas.ACLAction[];
      project?: Schemas.ACLAction[];
      projectAccessGroup?: Schemas.ACLAction[];
      projectAnalyticsSampling?: Schemas.ACLAction[];
      projectDeploymentHook?: Schemas.ACLAction[];
      projectDomain?: Schemas.ACLAction[];
      projectDomainMove?: Schemas.ACLAction[];
      projectDomainCheckConfig?: Schemas.ACLAction[];
      projectEnvVars?: Schemas.ACLAction[];
      projectEnvVarsProduction?: Schemas.ACLAction[];
      projectEnvVarsUnownedByIntegration?: Schemas.ACLAction[];
      projectId?: Schemas.ACLAction[];
      projectIntegrationConfiguration?: Schemas.ACLAction[];
      projectLink?: Schemas.ACLAction[];
      projectMember?: Schemas.ACLAction[];
      projectMonitoring?: Schemas.ACLAction[];
      projectPermissions?: Schemas.ACLAction[];
      projectProductionBranch?: Schemas.ACLAction[];
      projectTransfer?: Schemas.ACLAction[];
      projectTransferOut?: Schemas.ACLAction[];
      projectProtectionBypass?: Schemas.ACLAction[];
      projectUsage?: Schemas.ACLAction[];
      projectAnalyticsUsage?: Schemas.ACLAction[];
      projectSupportCase?: Schemas.ACLAction[];
      projectSupportCaseComment?: Schemas.ACLAction[];
      projectDeploymentExpiration?: Schemas.ACLAction[];
      seawallConfig?: Schemas.ACLAction[];
      skewProtection?: Schemas.ACLAction[];
      analytics?: Schemas.ACLAction[];
      trustedIps?: Schemas.ACLAction[];
      webAnalytics?: Schemas.ACLAction[];
      sharedEnvVarConnection?: Schemas.ACLAction[];
    };
    lastRollbackTarget?: Record<string, any> | null;
    lastAliasRequest?: {
      fromDeploymentId: string;
      toDeploymentId: string;
      jobStatus: 'succeeded' | 'failed' | 'skipped' | 'pending' | 'in-progress';
      requestedAt: number;
      type: 'promote' | 'rollback';
    } | null;
    hasFloatingAliases?: boolean;
    protectionBypass?: {
      [key: string]: {
        createdAt: number;
        createdBy: string;
        scope: 'automation-bypass';
      };
    };
    hasActiveBranches?: boolean;
    trustedIps?:
      | {
          deploymentType: 'all' | 'preview' | 'prod_deployment_urls_and_all_previews' | 'production';
          addresses: {
            value: string;
            note?: string;
          }[];
          protectionMode: 'additional' | 'exclusive';
        }
      | {
          deploymentType: 'all' | 'preview' | 'prod_deployment_urls_and_all_previews' | 'production';
        }
      | null;
    gitComments?: {
      /**
       * Whether the Vercel bot should comment on PRs
       */
      onPullRequest: boolean;
      /**
       * Whether the Vercel bot should comment on commits
       */
      onCommit: boolean;
    };
    paused?: boolean;
    concurrencyBucketName?: string;
    webAnalytics?: {
      id: string;
      disabledAt?: number;
      canceledAt?: number;
      enabledAt?: number;
      hasData?: boolean;
    };
    security?: {
      attackModeEnabled?: boolean;
      attackModeUpdatedAt?: number;
      firewallEnabled?: boolean;
      firewallUpdatedAt?: number;
      attackModeActiveUntil?: number | null;
      firewallConfigVersion?: number;
      firewallRoutes?: {
        src?:
          | string
          | {
              re?: string;
              eq?: string;
              neq?: string;
              inc?: string[];
              ninc?: string[];
              pre?: string;
              suf?: string;
              gt?: number;
              gte?: number;
              lt?: number;
              lte?: number;
            };
        has?: {
          type:
            | 'host'
            | 'method'
            | 'path'
            | 'header'
            | 'cookie'
            | 'query'
            | 'ip_address'
            | 'protocol'
            | 'scheme'
            | 'region';
          key?: string;
          value?:
            | string
            | {
                re?: string;
                eq?: string;
                neq?: string;
                inc?: string[];
                ninc?: string[];
                pre?: string;
                suf?: string;
                gt?: number;
                gte?: number;
                lt?: number;
                lte?: number;
              };
        }[];
        missing?: {
          type:
            | 'host'
            | 'method'
            | 'path'
            | 'header'
            | 'cookie'
            | 'query'
            | 'ip_address'
            | 'protocol'
            | 'scheme'
            | 'region';
          key?: string;
          value?:
            | string
            | {
                re?: string;
                eq?: string;
                neq?: string;
                inc?: string[];
                ninc?: string[];
                pre?: string;
                suf?: string;
                gt?: number;
                gte?: number;
                lt?: number;
                lte?: number;
              };
        }[];
        dest?: string;
        status?: number;
        handle?: 'init' | 'finalize';
        mitigate?: {
          action: 'deny' | 'challenge' | 'log' | 'bypass' | 'rate_limit';
          rule_id: string;
          erl?: {
            algo: 'fixed_window' | 'token_bucket';
            window: number;
            limit: number;
            keys: string[];
          };
        };
      }[];
      firewallSeawallEnabled?: boolean;
      ja3Enabled?: boolean;
      ja4Enabled?: boolean;
    };
    oidcTokenConfig?: {
      enabled: boolean;
    };
  }[];
  pagination: Schemas.Pagination;
};

export type GetProjectsVariables = {
  queryParams?: GetProjectsQueryParams;
} & FetcherExtraProps;

/**
 * Allows to retrieve the list of projects of the authenticated user or team. The list will be paginated and the provided query parameters allow filtering the returned projects.
 */
export const getProjects = (variables: GetProjectsVariables, signal?: AbortSignal) =>
  fetch<GetProjectsResponse, GetProjectsError, undefined, {}, GetProjectsQueryParams, {}>({
    url: '/v9/projects',
    method: 'get',
    ...variables,
    signal
  });

export type CreateProjectQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type CreateProjectError = Fetcher.ErrorWrapper<undefined>;

export type CreateProjectResponse = {
  accountId: string;
  analytics?: {
    id: string;
    canceledAt?: number | null;
    disabledAt: number;
    enabledAt: number;
    paidAt?: number;
    sampleRatePercent?: number | null;
    spendLimitInDollars?: number | null;
  };
  speedInsights?: {
    id: string;
    enabledAt?: number;
    disabledAt?: number;
    canceledAt?: number;
    hasData?: boolean;
    paidAt?: number;
  };
  autoExposeSystemEnvs?: boolean;
  autoAssignCustomDomains?: boolean;
  autoAssignCustomDomainsUpdatedBy?: string;
  buildCommand?: string | null;
  commandForIgnoringBuildStep?: string | null;
  connectConfigurationId?: string | null;
  connectBuildsEnabled?: boolean;
  createdAt?: number;
  customerSupportCodeVisibility?: boolean;
  crons?: {
    /**
     * The time the feature was enabled for this project. Note: It enables automatically with the first Deployment that outputs cronjobs.
     */
    enabledAt: number;
    /**
     * The time the feature was disabled for this project.
     */
    disabledAt: number | null;
    updatedAt: number;
    /**
     * The ID of the Deployment from which the definitions originated.
     */
    deploymentId: string | null;
    definitions: {
      /**
       * The hostname that should be used.
       *
       * @example vercel.com
       */
      host: string;
      /**
       * The path that should be called for the cronjob.
       *
       * @example /api/crons/sync-something?hello=world
       */
      path: string;
      /**
       * The cron expression.
       *
       * @example 0 0 * * *
       */
      schedule: string;
    }[];
  };
  dataCache?: {
    userDisabled: boolean;
    storageSizeBytes?: number | null;
    unlimited?: boolean;
  };
  deploymentExpiration?: {
    expirationDays?: number;
    expirationDaysProduction?: number;
    expirationDaysCanceled?: number;
    expirationDaysErrored?: number;
    deploymentsToKeep?: number;
  } | null;
  devCommand?: string | null;
  directoryListing: boolean;
  installCommand?: string | null;
  env?: {
    target?:
      | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
      | ('production' | 'preview' | 'development' | 'preview' | 'development');
    type: 'system' | 'secret' | 'encrypted' | 'plain' | 'sensitive';
    /**
     * This is used to identiy variables that have been migrated from type secret to sensitive.
     */
    sunsetSecretId?: string;
    id?: string;
    key: string;
    value: string;
    configurationId?: string | null;
    createdAt?: number;
    updatedAt?: number;
    createdBy?: string | null;
    updatedBy?: string | null;
    gitBranch?: string;
    edgeConfigId?: string | null;
    edgeConfigTokenId?: string | null;
    contentHint?:
      | {
          type: 'redis-url';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-url';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-token';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-read-only-token';
          storeId: string;
        }
      | {
          type: 'blob-read-write-token';
          storeId: string;
        }
      | {
          type: 'postgres-url';
          storeId: string;
        }
      | {
          type: 'postgres-url-non-pooling';
          storeId: string;
        }
      | {
          type: 'postgres-prisma-url';
          storeId: string;
        }
      | {
          type: 'postgres-user';
          storeId: string;
        }
      | {
          type: 'postgres-host';
          storeId: string;
        }
      | {
          type: 'postgres-password';
          storeId: string;
        }
      | {
          type: 'postgres-database';
          storeId: string;
        }
      | {
          type: 'postgres-url-no-ssl';
          storeId: string;
        }
      | {
          type: 'integration-store-secret';
          storeId: string;
        }
      | null;
    /**
     * Similar to `contentHints`, but should not be exposed to the user.
     */
    internalContentHint?: {
      type: 'flags-secret';
      /**
       * Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
       */
      encryptedValue: string;
    } | null;
    /**
     * Whether `value` is decrypted.
     */
    decrypted?: boolean;
    comment?: string;
    customEnvironmentIds?: string[];
  }[];
  framework?:
    | 'blitzjs'
    | 'nextjs'
    | 'gatsby'
    | 'remix'
    | 'astro'
    | 'hexo'
    | 'eleventy'
    | 'docusaurus-2'
    | 'docusaurus'
    | 'preact'
    | 'solidstart-1'
    | 'solidstart'
    | 'dojo'
    | 'ember'
    | 'vue'
    | 'scully'
    | 'ionic-angular'
    | 'angular'
    | 'polymer'
    | 'svelte'
    | 'sveltekit'
    | 'sveltekit-1'
    | 'ionic-react'
    | 'create-react-app'
    | 'gridsome'
    | 'umijs'
    | 'sapper'
    | 'saber'
    | 'stencil'
    | 'nuxtjs'
    | 'redwoodjs'
    | 'hugo'
    | 'jekyll'
    | 'brunch'
    | 'middleman'
    | 'zola'
    | 'hydrogen'
    | 'vite'
    | 'vitepress'
    | 'vuepress'
    | 'parcel'
    | 'sanity'
    | 'storybook'
    | null;
  gitForkProtection?: boolean;
  gitLFS?: boolean;
  id: string;
  latestDeployments?: {
    alias?: string[];
    aliasAssigned?: number | boolean | null;
    aliasError?: {
      code: string;
      message: string;
    } | null;
    aliasFinal?: string | null;
    automaticAliases?: string[];
    builds?: {
      use: string;
      src?: string;
      dest?: string;
    }[];
    connectBuildsEnabled?: boolean;
    connectConfigurationId?: string;
    createdAt: number;
    createdIn: string;
    creator: {
      email: string;
      githubLogin?: string;
      gitlabLogin?: string;
      uid: string;
      username: string;
    } | null;
    deletedAt?: number;
    deploymentHostname: string;
    name: string;
    forced?: boolean;
    id: string;
    meta?: {
      [key: string]: string;
    };
    monorepoManager?: string | null;
    plan: 'pro' | 'enterprise' | 'hobby';
    private: boolean;
    readyState: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED';
    readySubstate?: 'STAGED' | 'PROMOTED';
    requestedAt?: number;
    target?: string | null;
    teamId?: string | null;
    type: 'LAMBDAS';
    url: string;
    userId: string;
    withCache?: boolean;
    checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
    checksState?: 'registered' | 'running' | 'completed';
    readyAt?: number;
    buildingAt?: number;
    /**
     * Whether or not preview comments are enabled for the deployment
     *
     * @example false
     */
    previewCommentsEnabled?: boolean;
    oidcTokenClaims?: {
      [key: string]: string | string[];
    };
  }[];
  link?:
    | {
        org?: string;
        repo?: string;
        repoId?: number;
        type?: 'github';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        projectId?: string;
        projectName?: string;
        projectNameWithNamespace?: string;
        projectNamespace?: string;
        projectUrl?: string;
        type?: 'gitlab';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        name?: string;
        slug?: string;
        owner?: string;
        type?: 'bitbucket';
        uuid?: string;
        workspaceUuid?: string;
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      };
  name: string;
  nodeVersion: '20.x' | '18.x' | '16.x' | '14.x' | '12.x' | '10.x' | '8.10.x';
  optionsAllowlist?: {
    paths: {
      value: string;
    }[];
  } | null;
  outputDirectory?: string | null;
  passiveConnectConfigurationId?: string | null;
  passwordProtection?: Record<string, any> | null;
  productionDeploymentsFastLane?: boolean;
  publicSource?: boolean | null;
  rootDirectory?: string | null;
  serverlessFunctionRegion?: string | null;
  serverlessFunctionZeroConfigFailover?: boolean;
  skewProtectionBoundaryAt?: number;
  skewProtectionMaxAge?: number;
  skipGitConnectDuringLink?: boolean;
  sourceFilesOutsideRootDirectory?: boolean;
  ssoProtection?: {
    deploymentType: 'all' | 'preview' | 'prod_deployment_urls_and_all_previews';
  } | null;
  targets?: {
    [key: string]: string | string[];
  };
  transferCompletedAt?: number;
  transferStartedAt?: number;
  transferToAccountId?: string;
  transferredFromAccountId?: string;
  updatedAt?: number;
  live?: boolean;
  enablePreviewFeedback?: boolean | null;
  permissions?: {
    accessGroup?: Schemas.ACLAction[];
    aliasGlobal?: Schemas.ACLAction[];
    analyticsSampling?: Schemas.ACLAction[];
    analyticsUsage?: Schemas.ACLAction[];
    auditLog?: Schemas.ACLAction[];
    billingAddress?: Schemas.ACLAction[];
    billingInformation?: Schemas.ACLAction[];
    billingInvoice?: Schemas.ACLAction[];
    billingInvoiceEmailRecipient?: Schemas.ACLAction[];
    billingInvoiceLanguage?: Schemas.ACLAction[];
    billingPlan?: Schemas.ACLAction[];
    billingPurchaseOrder?: Schemas.ACLAction[];
    billingTaxId?: Schemas.ACLAction[];
    blob?: Schemas.ACLAction[];
    budget?: Schemas.ACLAction[];
    cacheArtifact?: Schemas.ACLAction[];
    cacheArtifactUsageEvent?: Schemas.ACLAction[];
    codeChecks?: Schemas.ACLAction[];
    concurrentBuilds?: Schemas.ACLAction[];
    connect?: Schemas.ACLAction[];
    connectConfiguration?: Schemas.ACLAction[];
    domain?: Schemas.ACLAction[];
    domainAcceptDelegation?: Schemas.ACLAction[];
    domainAuthCodes?: Schemas.ACLAction[];
    domainCertificate?: Schemas.ACLAction[];
    domainCheckConfig?: Schemas.ACLAction[];
    domainMove?: Schemas.ACLAction[];
    domainPurchase?: Schemas.ACLAction[];
    domainRecord?: Schemas.ACLAction[];
    domainTransferIn?: Schemas.ACLAction[];
    event?: Schemas.ACLAction[];
    ownEvent?: Schemas.ACLAction[];
    sensitiveEnvironmentVariablePolicy?: Schemas.ACLAction[];
    fileUpload?: Schemas.ACLAction[];
    gitRepository?: Schemas.ACLAction[];
    ipBlocking?: Schemas.ACLAction[];
    integration?: Schemas.ACLAction[];
    integrationAccount?: Schemas.ACLAction[];
    integrationConfiguration?: Schemas.ACLAction[];
    integrationConfigurationTransfer?: Schemas.ACLAction[];
    integrationConfigurationProjects?: Schemas.ACLAction[];
    integrationVercelConfigurationOverride?: Schemas.ACLAction[];
    integrationResource?: Schemas.ACLAction[];
    integrationEvent?: Schemas.ACLAction[];
    integrationResourceSecrets?: Schemas.ACLAction[];
    marketplaceBillingData?: Schemas.ACLAction[];
    marketplaceInvoice?: Schemas.ACLAction[];
    jobGlobal?: Schemas.ACLAction[];
    logDrain?: Schemas.ACLAction[];
    Monitoring?: Schemas.ACLAction[];
    monitoringSettings?: Schemas.ACLAction[];
    monitoringQuery?: Schemas.ACLAction[];
    monitoringChart?: Schemas.ACLAction[];
    monitoringAlert?: Schemas.ACLAction[];
    notificationDeploymentFailed?: Schemas.ACLAction[];
    notificationDomainConfiguration?: Schemas.ACLAction[];
    notificationDomainExpire?: Schemas.ACLAction[];
    notificationDomainMoved?: Schemas.ACLAction[];
    notificationDomainPurchase?: Schemas.ACLAction[];
    notificationDomainRenewal?: Schemas.ACLAction[];
    notificationDomainTransfer?: Schemas.ACLAction[];
    notificationDomainUnverified?: Schemas.ACLAction[];
    NotificationMonitoringAlert?: Schemas.ACLAction[];
    notificationPaymentFailed?: Schemas.ACLAction[];
    notificationUsageAlert?: Schemas.ACLAction[];
    notificationCustomerBudget?: Schemas.ACLAction[];
    notificationStatementOfReasons?: Schemas.ACLAction[];
    oauth2Connection?: Schemas.ACLAction[];
    openTelemetryEndpoint?: Schemas.ACLAction[];
    paymentMethod?: Schemas.ACLAction[];
    permissions?: Schemas.ACLAction[];
    postgres?: Schemas.ACLAction[];
    previewDeploymentSuffix?: Schemas.ACLAction[];
    proTrialOnboarding?: Schemas.ACLAction[];
    sharedEnvVars?: Schemas.ACLAction[];
    sharedEnvVarsProduction?: Schemas.ACLAction[];
    space?: Schemas.ACLAction[];
    spaceRun?: Schemas.ACLAction[];
    passwordProtectionInvoiceItem?: Schemas.ACLAction[];
    rateLimit?: Schemas.ACLAction[];
    redis?: Schemas.ACLAction[];
    repository?: Schemas.ACLAction[];
    remoteCaching?: Schemas.ACLAction[];
    samlConfig?: Schemas.ACLAction[];
    secret?: Schemas.ACLAction[];
    redisStoreTokenSet?: Schemas.ACLAction[];
    blobStoreTokenSet?: Schemas.ACLAction[];
    postgresStoreTokenSet?: Schemas.ACLAction[];
    integrationStoreTokenSet?: Schemas.ACLAction[];
    supportCase?: Schemas.ACLAction[];
    supportCaseComment?: Schemas.ACLAction[];
    dataCacheBillingSettings?: Schemas.ACLAction[];
    team?: Schemas.ACLAction[];
    teamAccessRequest?: Schemas.ACLAction[];
    teamFellowMembership?: Schemas.ACLAction[];
    teamGitExclusivity?: Schemas.ACLAction[];
    teamInvite?: Schemas.ACLAction[];
    teamInviteCode?: Schemas.ACLAction[];
    teamJoin?: Schemas.ACLAction[];
    teamOwnMembership?: Schemas.ACLAction[];
    teamOwnMembershipDisconnectSAML?: Schemas.ACLAction[];
    token?: Schemas.ACLAction[];
    usage?: Schemas.ACLAction[];
    usageCycle?: Schemas.ACLAction[];
    user?: Schemas.ACLAction[];
    userConnection?: Schemas.ACLAction[];
    webAnalyticsPlan?: Schemas.ACLAction[];
    webAuthn?: Schemas.ACLAction[];
    edgeConfig?: Schemas.ACLAction[];
    edgeConfigItem?: Schemas.ACLAction[];
    edgeConfigSchema?: Schemas.ACLAction[];
    edgeConfigToken?: Schemas.ACLAction[];
    webhook?: Schemas.ACLAction[];
    ['webhook-event']?: Schemas.ACLAction[];
    endpointVerification?: Schemas.ACLAction[];
    projectTransferIn?: Schemas.ACLAction[];
    oauth2Application?: Schemas.ACLAction[];
    aliasProject?: Schemas.ACLAction[];
    aliasProtectionBypass?: Schemas.ACLAction[];
    productionAliasProtectionBypass?: Schemas.ACLAction[];
    connectConfigurationLink?: Schemas.ACLAction[];
    dataCacheNamespace?: Schemas.ACLAction[];
    deployment?: Schemas.ACLAction[];
    deploymentCheck?: Schemas.ACLAction[];
    deploymentCheckPreview?: Schemas.ACLAction[];
    deploymentCheckReRunFromProductionBranch?: Schemas.ACLAction[];
    deploymentProductionGit?: Schemas.ACLAction[];
    deploymentPreview?: Schemas.ACLAction[];
    deploymentPrivate?: Schemas.ACLAction[];
    deploymentPromote?: Schemas.ACLAction[];
    deploymentRollback?: Schemas.ACLAction[];
    environments?: Schemas.ACLAction[];
    logs?: Schemas.ACLAction[];
    logsPreset?: Schemas.ACLAction[];
    passwordProtection?: Schemas.ACLAction[];
    optionsAllowlist?: Schemas.ACLAction[];
    job?: Schemas.ACLAction[];
    project?: Schemas.ACLAction[];
    projectAccessGroup?: Schemas.ACLAction[];
    projectAnalyticsSampling?: Schemas.ACLAction[];
    projectDeploymentHook?: Schemas.ACLAction[];
    projectDomain?: Schemas.ACLAction[];
    projectDomainMove?: Schemas.ACLAction[];
    projectDomainCheckConfig?: Schemas.ACLAction[];
    projectEnvVars?: Schemas.ACLAction[];
    projectEnvVarsProduction?: Schemas.ACLAction[];
    projectEnvVarsUnownedByIntegration?: Schemas.ACLAction[];
    projectId?: Schemas.ACLAction[];
    projectIntegrationConfiguration?: Schemas.ACLAction[];
    projectLink?: Schemas.ACLAction[];
    projectMember?: Schemas.ACLAction[];
    projectMonitoring?: Schemas.ACLAction[];
    projectPermissions?: Schemas.ACLAction[];
    projectProductionBranch?: Schemas.ACLAction[];
    projectTransfer?: Schemas.ACLAction[];
    projectTransferOut?: Schemas.ACLAction[];
    projectProtectionBypass?: Schemas.ACLAction[];
    projectUsage?: Schemas.ACLAction[];
    projectAnalyticsUsage?: Schemas.ACLAction[];
    projectSupportCase?: Schemas.ACLAction[];
    projectSupportCaseComment?: Schemas.ACLAction[];
    projectDeploymentExpiration?: Schemas.ACLAction[];
    seawallConfig?: Schemas.ACLAction[];
    skewProtection?: Schemas.ACLAction[];
    analytics?: Schemas.ACLAction[];
    trustedIps?: Schemas.ACLAction[];
    webAnalytics?: Schemas.ACLAction[];
    sharedEnvVarConnection?: Schemas.ACLAction[];
  };
  lastRollbackTarget?: Record<string, any> | null;
  lastAliasRequest?: {
    fromDeploymentId: string;
    toDeploymentId: string;
    jobStatus: 'succeeded' | 'failed' | 'skipped' | 'pending' | 'in-progress';
    requestedAt: number;
    type: 'promote' | 'rollback';
  } | null;
  hasFloatingAliases?: boolean;
  protectionBypass?: {
    [key: string]: {
      createdAt: number;
      createdBy: string;
      scope: 'automation-bypass';
    };
  };
  hasActiveBranches?: boolean;
  trustedIps?:
    | {
        deploymentType: 'all' | 'preview' | 'prod_deployment_urls_and_all_previews' | 'production';
        addresses: {
          value: string;
          note?: string;
        }[];
        protectionMode: 'additional' | 'exclusive';
      }
    | {
        deploymentType: 'all' | 'preview' | 'prod_deployment_urls_and_all_previews' | 'production';
      }
    | null;
  gitComments?: {
    /**
     * Whether the Vercel bot should comment on PRs
     */
    onPullRequest: boolean;
    /**
     * Whether the Vercel bot should comment on commits
     */
    onCommit: boolean;
  };
  paused?: boolean;
  concurrencyBucketName?: string;
  webAnalytics?: {
    id: string;
    disabledAt?: number;
    canceledAt?: number;
    enabledAt?: number;
    hasData?: boolean;
  };
  security?: {
    attackModeEnabled?: boolean;
    attackModeUpdatedAt?: number;
    firewallEnabled?: boolean;
    firewallUpdatedAt?: number;
    attackModeActiveUntil?: number | null;
    firewallConfigVersion?: number;
    firewallRoutes?: {
      src?:
        | string
        | {
            re?: string;
            eq?: string;
            neq?: string;
            inc?: string[];
            ninc?: string[];
            pre?: string;
            suf?: string;
            gt?: number;
            gte?: number;
            lt?: number;
            lte?: number;
          };
      has?: {
        type:
          | 'host'
          | 'method'
          | 'path'
          | 'header'
          | 'cookie'
          | 'query'
          | 'ip_address'
          | 'protocol'
          | 'scheme'
          | 'region';
        key?: string;
        value?:
          | string
          | {
              re?: string;
              eq?: string;
              neq?: string;
              inc?: string[];
              ninc?: string[];
              pre?: string;
              suf?: string;
              gt?: number;
              gte?: number;
              lt?: number;
              lte?: number;
            };
      }[];
      missing?: {
        type:
          | 'host'
          | 'method'
          | 'path'
          | 'header'
          | 'cookie'
          | 'query'
          | 'ip_address'
          | 'protocol'
          | 'scheme'
          | 'region';
        key?: string;
        value?:
          | string
          | {
              re?: string;
              eq?: string;
              neq?: string;
              inc?: string[];
              ninc?: string[];
              pre?: string;
              suf?: string;
              gt?: number;
              gte?: number;
              lt?: number;
              lte?: number;
            };
      }[];
      dest?: string;
      status?: number;
      handle?: 'init' | 'finalize';
      mitigate?: {
        action: 'deny' | 'challenge' | 'log' | 'bypass' | 'rate_limit';
        rule_id: string;
        erl?: {
          algo: 'fixed_window' | 'token_bucket';
          window: number;
          limit: number;
          keys: string[];
        };
      };
    }[];
    firewallSeawallEnabled?: boolean;
    ja3Enabled?: boolean;
    ja4Enabled?: boolean;
  };
  oidcTokenConfig?: {
    enabled: boolean;
  };
};

export type CreateProjectRequestBody = {
  /**
   * The build command for this project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  buildCommand?: string | null;
  /**
   * @maxLength 256
   */
  commandForIgnoringBuildStep?: string | null;
  /**
   * The dev command for this project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  devCommand?: string | null;
  /**
   * Collection of ENV Variables the Project will use
   */
  environmentVariables?: {
    /**
     * Name of the ENV variable
     */
    key: string;
    /**
     * Deployment Target or Targets in which the ENV variable will be used
     */
    target: ('production' | 'preview' | 'development') | ('production' | 'preview' | 'development')[];
    /**
     * If defined, the git branch of the environment variable (must have target=preview)
     *
     * @maxLength 250
     */
    gitBranch?: string;
    /**
     * Type of the ENV variable
     */
    type?: 'system' | 'secret' | 'encrypted' | 'plain' | 'sensitive';
    /**
     * Value for the ENV variable
     */
    value: string;
  }[];
  /**
   * The framework that is being used for this project. When `null` is used no framework is selected
   */
  framework?:
    | any
    | 'blitzjs'
    | 'nextjs'
    | 'gatsby'
    | 'remix'
    | 'astro'
    | 'hexo'
    | 'eleventy'
    | 'docusaurus-2'
    | 'docusaurus'
    | 'preact'
    | 'solidstart-1'
    | 'solidstart'
    | 'dojo'
    | 'ember'
    | 'vue'
    | 'scully'
    | 'ionic-angular'
    | 'angular'
    | 'polymer'
    | 'svelte'
    | 'sveltekit'
    | 'sveltekit-1'
    | 'ionic-react'
    | 'create-react-app'
    | 'gridsome'
    | 'umijs'
    | 'sapper'
    | 'saber'
    | 'stencil'
    | 'nuxtjs'
    | 'redwoodjs'
    | 'hugo'
    | 'jekyll'
    | 'brunch'
    | 'middleman'
    | 'zola'
    | 'hydrogen'
    | 'vite'
    | 'vitepress'
    | 'vuepress'
    | 'parcel'
    | 'sanity'
    | 'storybook';
  /**
   * The Git Repository that will be connected to the project. When this is defined, any pushes to the specified connected Git Repository will be automatically deployed
   */
  gitRepository?: {
    /**
     * The name of the git repository. For example: \"vercel/next.js\"
     */
    repo: string;
    /**
     * The Git Provider of the repository
     */
    type: 'github' | 'gitlab' | 'bitbucket';
  };
  /**
   * The install command for this project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  installCommand?: string | null;
  /**
   * The desired name for the project
   *
   * @example a-project-name
   * @maxLength 100
   * @pattern ^(?!.*---)[a-z0-9-_.]+$
   */
  name: string;
  /**
   * Opts-out of the message prompting a CLI user to connect a Git repository in `vercel link`.
   *
   * @deprecated true
   */
  skipGitConnectDuringLink?: boolean;
  /**
   * The output directory of the project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  outputDirectory?: string | null;
  /**
   * Specifies whether the source code and logs of the deployments for this project should be public or not
   */
  publicSource?: boolean | null;
  /**
   * The name of a directory or relative path to the source code of your project. When `null` is used it will default to the project root
   *
   * @maxLength 256
   */
  rootDirectory?: string | null;
  /**
   * The region to deploy Serverless Functions in this project
   *
   * @maxLength 4
   */
  serverlessFunctionRegion?: string | null;
  /**
   * Specifies whether Zero Config Failover is enabled for this project.
   */
  serverlessFunctionZeroConfigFailover?: boolean;
};

export type CreateProjectVariables = {
  body: CreateProjectRequestBody;
  queryParams?: CreateProjectQueryParams;
} & FetcherExtraProps;

/**
 * Allows to create a new project with the provided configuration. It only requires the project `name` but more configuration can be provided to override the defaults.
 */
export const createProject = (variables: CreateProjectVariables, signal?: AbortSignal) =>
  fetch<CreateProjectResponse, CreateProjectError, CreateProjectRequestBody, {}, CreateProjectQueryParams, {}>({
    url: '/v10/projects',
    method: 'post',
    ...variables,
    signal
  });

export type GetProjectPathParams = {
  /**
   * The unique project identifier or the project name
   */
  idOrName: string | boolean;
};

export type GetProjectQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetProjectError = Fetcher.ErrorWrapper<undefined>;

export type GetProjectResponse = {
  accountId: string;
  analytics?: {
    id: string;
    canceledAt?: number | null;
    disabledAt: number;
    enabledAt: number;
    paidAt?: number;
    sampleRatePercent?: number | null;
    spendLimitInDollars?: number | null;
  };
  speedInsights?: {
    id: string;
    enabledAt?: number;
    disabledAt?: number;
    canceledAt?: number;
    hasData?: boolean;
    paidAt?: number;
  };
  autoExposeSystemEnvs?: boolean;
  autoAssignCustomDomains?: boolean;
  autoAssignCustomDomainsUpdatedBy?: string;
  buildCommand?: string | null;
  commandForIgnoringBuildStep?: string | null;
  connectConfigurationId?: string | null;
  connectBuildsEnabled?: boolean;
  createdAt?: number;
  customerSupportCodeVisibility?: boolean;
  crons?: {
    /**
     * The time the feature was enabled for this project. Note: It enables automatically with the first Deployment that outputs cronjobs.
     */
    enabledAt: number;
    /**
     * The time the feature was disabled for this project.
     */
    disabledAt: number | null;
    updatedAt: number;
    /**
     * The ID of the Deployment from which the definitions originated.
     */
    deploymentId: string | null;
    definitions: {
      /**
       * The hostname that should be used.
       *
       * @example vercel.com
       */
      host: string;
      /**
       * The path that should be called for the cronjob.
       *
       * @example /api/crons/sync-something?hello=world
       */
      path: string;
      /**
       * The cron expression.
       *
       * @example 0 0 * * *
       */
      schedule: string;
    }[];
  };
  dataCache?: {
    userDisabled: boolean;
    storageSizeBytes?: number | null;
    unlimited?: boolean;
  };
  deploymentExpiration?: {
    expirationDays?: number;
    expirationDaysProduction?: number;
    expirationDaysCanceled?: number;
    expirationDaysErrored?: number;
    deploymentsToKeep?: number;
  } | null;
  devCommand?: string | null;
  directoryListing: boolean;
  installCommand?: string | null;
  env?: {
    target?:
      | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
      | ('production' | 'preview' | 'development' | 'preview' | 'development');
    type: 'system' | 'encrypted' | 'plain' | 'sensitive' | 'secret';
    /**
     * This is used to identiy variables that have been migrated from type secret to sensitive.
     */
    sunsetSecretId?: string;
    id?: string;
    key: string;
    value: string;
    configurationId?: string | null;
    createdAt?: number;
    updatedAt?: number;
    createdBy?: string | null;
    updatedBy?: string | null;
    gitBranch?: string;
    edgeConfigId?: string | null;
    edgeConfigTokenId?: string | null;
    contentHint?:
      | {
          type: 'redis-url';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-url';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-token';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-read-only-token';
          storeId: string;
        }
      | {
          type: 'blob-read-write-token';
          storeId: string;
        }
      | {
          type: 'postgres-url';
          storeId: string;
        }
      | {
          type: 'postgres-url-non-pooling';
          storeId: string;
        }
      | {
          type: 'postgres-prisma-url';
          storeId: string;
        }
      | {
          type: 'postgres-user';
          storeId: string;
        }
      | {
          type: 'postgres-host';
          storeId: string;
        }
      | {
          type: 'postgres-password';
          storeId: string;
        }
      | {
          type: 'postgres-database';
          storeId: string;
        }
      | {
          type: 'postgres-url-no-ssl';
          storeId: string;
        }
      | {
          type: 'integration-store-secret';
          storeId: string;
        }
      | null;
    /**
     * Similar to `contentHints`, but should not be exposed to the user.
     */
    internalContentHint?: {
      type: 'flags-secret';
      /**
       * Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
       */
      encryptedValue: string;
    } | null;
    /**
     * Whether `value` is decrypted.
     */
    decrypted?: boolean;
    comment?: string;
    customEnvironmentIds?: string[];
  }[];
  framework?:
    | 'blitzjs'
    | 'nextjs'
    | 'gatsby'
    | 'remix'
    | 'astro'
    | 'hexo'
    | 'eleventy'
    | 'docusaurus-2'
    | 'docusaurus'
    | 'preact'
    | 'solidstart-1'
    | 'solidstart'
    | 'dojo'
    | 'ember'
    | 'vue'
    | 'scully'
    | 'ionic-angular'
    | 'angular'
    | 'polymer'
    | 'svelte'
    | 'sveltekit'
    | 'sveltekit-1'
    | 'ionic-react'
    | 'create-react-app'
    | 'gridsome'
    | 'umijs'
    | 'sapper'
    | 'saber'
    | 'stencil'
    | 'nuxtjs'
    | 'redwoodjs'
    | 'hugo'
    | 'jekyll'
    | 'brunch'
    | 'middleman'
    | 'zola'
    | 'hydrogen'
    | 'vite'
    | 'vitepress'
    | 'vuepress'
    | 'parcel'
    | 'sanity'
    | 'storybook'
    | null;
  gitForkProtection?: boolean;
  gitLFS?: boolean;
  id: string;
  latestDeployments?: {
    alias?: string[];
    aliasAssigned?: number | boolean | null;
    aliasError?: {
      code: string;
      message: string;
    } | null;
    aliasFinal?: string | null;
    automaticAliases?: string[];
    builds?: {
      use: string;
      src?: string;
      dest?: string;
    }[];
    connectBuildsEnabled?: boolean;
    connectConfigurationId?: string;
    createdAt: number;
    createdIn: string;
    creator: {
      email: string;
      githubLogin?: string;
      gitlabLogin?: string;
      uid: string;
      username: string;
    } | null;
    deletedAt?: number;
    deploymentHostname: string;
    name: string;
    forced?: boolean;
    id: string;
    meta?: {
      [key: string]: string;
    };
    monorepoManager?: string | null;
    plan: 'pro' | 'enterprise' | 'hobby';
    private: boolean;
    readyState: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED';
    readySubstate?: 'STAGED' | 'PROMOTED';
    requestedAt?: number;
    target?: string | null;
    teamId?: string | null;
    type: 'LAMBDAS';
    url: string;
    userId: string;
    withCache?: boolean;
    checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
    checksState?: 'registered' | 'running' | 'completed';
    readyAt?: number;
    buildingAt?: number;
    /**
     * Whether or not preview comments are enabled for the deployment
     *
     * @example false
     */
    previewCommentsEnabled?: boolean;
    oidcTokenClaims?: {
      [key: string]: string | string[];
    };
  }[];
  link?:
    | {
        org?: string;
        repo?: string;
        repoId?: number;
        type?: 'github';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        projectId?: string;
        projectName?: string;
        projectNameWithNamespace?: string;
        projectNamespace?: string;
        projectUrl?: string;
        type?: 'gitlab';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        name?: string;
        slug?: string;
        owner?: string;
        type?: 'bitbucket';
        uuid?: string;
        workspaceUuid?: string;
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      };
  name: string;
  nodeVersion: '20.x' | '18.x' | '16.x' | '14.x' | '12.x' | '10.x' | '8.10.x';
  optionsAllowlist?: {
    paths: {
      value: string;
    }[];
  } | null;
  outputDirectory?: string | null;
  passiveConnectConfigurationId?: string | null;
  passwordProtection?: Record<string, any> | null;
  productionDeploymentsFastLane?: boolean;
  publicSource?: boolean | null;
  rootDirectory?: string | null;
  serverlessFunctionRegion?: string | null;
  serverlessFunctionZeroConfigFailover?: boolean;
  skewProtectionBoundaryAt?: number;
  skewProtectionMaxAge?: number;
  skipGitConnectDuringLink?: boolean;
  sourceFilesOutsideRootDirectory?: boolean;
  ssoProtection?: {
    deploymentType: 'all' | 'preview' | 'prod_deployment_urls_and_all_previews';
  } | null;
  targets?: {
    [key: string]: string | string[];
  };
  transferCompletedAt?: number;
  transferStartedAt?: number;
  transferToAccountId?: string;
  transferredFromAccountId?: string;
  updatedAt?: number;
  live?: boolean;
  enablePreviewFeedback?: boolean | null;
  permissions?: {
    accessGroup?: Schemas.ACLAction[];
    aliasGlobal?: Schemas.ACLAction[];
    analyticsSampling?: Schemas.ACLAction[];
    analyticsUsage?: Schemas.ACLAction[];
    auditLog?: Schemas.ACLAction[];
    billingAddress?: Schemas.ACLAction[];
    billingInformation?: Schemas.ACLAction[];
    billingInvoice?: Schemas.ACLAction[];
    billingInvoiceEmailRecipient?: Schemas.ACLAction[];
    billingInvoiceLanguage?: Schemas.ACLAction[];
    billingPlan?: Schemas.ACLAction[];
    billingPurchaseOrder?: Schemas.ACLAction[];
    billingTaxId?: Schemas.ACLAction[];
    blob?: Schemas.ACLAction[];
    budget?: Schemas.ACLAction[];
    cacheArtifact?: Schemas.ACLAction[];
    cacheArtifactUsageEvent?: Schemas.ACLAction[];
    codeChecks?: Schemas.ACLAction[];
    concurrentBuilds?: Schemas.ACLAction[];
    connect?: Schemas.ACLAction[];
    connectConfiguration?: Schemas.ACLAction[];
    domain?: Schemas.ACLAction[];
    domainAcceptDelegation?: Schemas.ACLAction[];
    domainAuthCodes?: Schemas.ACLAction[];
    domainCertificate?: Schemas.ACLAction[];
    domainCheckConfig?: Schemas.ACLAction[];
    domainMove?: Schemas.ACLAction[];
    domainPurchase?: Schemas.ACLAction[];
    domainRecord?: Schemas.ACLAction[];
    domainTransferIn?: Schemas.ACLAction[];
    event?: Schemas.ACLAction[];
    ownEvent?: Schemas.ACLAction[];
    sensitiveEnvironmentVariablePolicy?: Schemas.ACLAction[];
    fileUpload?: Schemas.ACLAction[];
    gitRepository?: Schemas.ACLAction[];
    ipBlocking?: Schemas.ACLAction[];
    integration?: Schemas.ACLAction[];
    integrationAccount?: Schemas.ACLAction[];
    integrationConfiguration?: Schemas.ACLAction[];
    integrationConfigurationTransfer?: Schemas.ACLAction[];
    integrationConfigurationProjects?: Schemas.ACLAction[];
    integrationVercelConfigurationOverride?: Schemas.ACLAction[];
    integrationResource?: Schemas.ACLAction[];
    integrationEvent?: Schemas.ACLAction[];
    integrationResourceSecrets?: Schemas.ACLAction[];
    marketplaceBillingData?: Schemas.ACLAction[];
    marketplaceInvoice?: Schemas.ACLAction[];
    jobGlobal?: Schemas.ACLAction[];
    logDrain?: Schemas.ACLAction[];
    Monitoring?: Schemas.ACLAction[];
    monitoringSettings?: Schemas.ACLAction[];
    monitoringQuery?: Schemas.ACLAction[];
    monitoringChart?: Schemas.ACLAction[];
    monitoringAlert?: Schemas.ACLAction[];
    notificationDeploymentFailed?: Schemas.ACLAction[];
    notificationDomainConfiguration?: Schemas.ACLAction[];
    notificationDomainExpire?: Schemas.ACLAction[];
    notificationDomainMoved?: Schemas.ACLAction[];
    notificationDomainPurchase?: Schemas.ACLAction[];
    notificationDomainRenewal?: Schemas.ACLAction[];
    notificationDomainTransfer?: Schemas.ACLAction[];
    notificationDomainUnverified?: Schemas.ACLAction[];
    NotificationMonitoringAlert?: Schemas.ACLAction[];
    notificationPaymentFailed?: Schemas.ACLAction[];
    notificationUsageAlert?: Schemas.ACLAction[];
    notificationCustomerBudget?: Schemas.ACLAction[];
    notificationStatementOfReasons?: Schemas.ACLAction[];
    oauth2Connection?: Schemas.ACLAction[];
    openTelemetryEndpoint?: Schemas.ACLAction[];
    paymentMethod?: Schemas.ACLAction[];
    permissions?: Schemas.ACLAction[];
    postgres?: Schemas.ACLAction[];
    previewDeploymentSuffix?: Schemas.ACLAction[];
    proTrialOnboarding?: Schemas.ACLAction[];
    sharedEnvVars?: Schemas.ACLAction[];
    sharedEnvVarsProduction?: Schemas.ACLAction[];
    space?: Schemas.ACLAction[];
    spaceRun?: Schemas.ACLAction[];
    passwordProtectionInvoiceItem?: Schemas.ACLAction[];
    rateLimit?: Schemas.ACLAction[];
    redis?: Schemas.ACLAction[];
    repository?: Schemas.ACLAction[];
    remoteCaching?: Schemas.ACLAction[];
    samlConfig?: Schemas.ACLAction[];
    secret?: Schemas.ACLAction[];
    redisStoreTokenSet?: Schemas.ACLAction[];
    blobStoreTokenSet?: Schemas.ACLAction[];
    postgresStoreTokenSet?: Schemas.ACLAction[];
    integrationStoreTokenSet?: Schemas.ACLAction[];
    supportCase?: Schemas.ACLAction[];
    supportCaseComment?: Schemas.ACLAction[];
    dataCacheBillingSettings?: Schemas.ACLAction[];
    team?: Schemas.ACLAction[];
    teamAccessRequest?: Schemas.ACLAction[];
    teamFellowMembership?: Schemas.ACLAction[];
    teamGitExclusivity?: Schemas.ACLAction[];
    teamInvite?: Schemas.ACLAction[];
    teamInviteCode?: Schemas.ACLAction[];
    teamJoin?: Schemas.ACLAction[];
    teamOwnMembership?: Schemas.ACLAction[];
    teamOwnMembershipDisconnectSAML?: Schemas.ACLAction[];
    token?: Schemas.ACLAction[];
    usage?: Schemas.ACLAction[];
    usageCycle?: Schemas.ACLAction[];
    user?: Schemas.ACLAction[];
    userConnection?: Schemas.ACLAction[];
    webAnalyticsPlan?: Schemas.ACLAction[];
    webAuthn?: Schemas.ACLAction[];
    edgeConfig?: Schemas.ACLAction[];
    edgeConfigItem?: Schemas.ACLAction[];
    edgeConfigSchema?: Schemas.ACLAction[];
    edgeConfigToken?: Schemas.ACLAction[];
    webhook?: Schemas.ACLAction[];
    ['webhook-event']?: Schemas.ACLAction[];
    endpointVerification?: Schemas.ACLAction[];
    projectTransferIn?: Schemas.ACLAction[];
    oauth2Application?: Schemas.ACLAction[];
    aliasProject?: Schemas.ACLAction[];
    aliasProtectionBypass?: Schemas.ACLAction[];
    productionAliasProtectionBypass?: Schemas.ACLAction[];
    connectConfigurationLink?: Schemas.ACLAction[];
    dataCacheNamespace?: Schemas.ACLAction[];
    deployment?: Schemas.ACLAction[];
    deploymentCheck?: Schemas.ACLAction[];
    deploymentCheckPreview?: Schemas.ACLAction[];
    deploymentCheckReRunFromProductionBranch?: Schemas.ACLAction[];
    deploymentProductionGit?: Schemas.ACLAction[];
    deploymentPreview?: Schemas.ACLAction[];
    deploymentPrivate?: Schemas.ACLAction[];
    deploymentPromote?: Schemas.ACLAction[];
    deploymentRollback?: Schemas.ACLAction[];
    environments?: Schemas.ACLAction[];
    logs?: Schemas.ACLAction[];
    logsPreset?: Schemas.ACLAction[];
    passwordProtection?: Schemas.ACLAction[];
    optionsAllowlist?: Schemas.ACLAction[];
    job?: Schemas.ACLAction[];
    project?: Schemas.ACLAction[];
    projectAccessGroup?: Schemas.ACLAction[];
    projectAnalyticsSampling?: Schemas.ACLAction[];
    projectDeploymentHook?: Schemas.ACLAction[];
    projectDomain?: Schemas.ACLAction[];
    projectDomainMove?: Schemas.ACLAction[];
    projectDomainCheckConfig?: Schemas.ACLAction[];
    projectEnvVars?: Schemas.ACLAction[];
    projectEnvVarsProduction?: Schemas.ACLAction[];
    projectEnvVarsUnownedByIntegration?: Schemas.ACLAction[];
    projectId?: Schemas.ACLAction[];
    projectIntegrationConfiguration?: Schemas.ACLAction[];
    projectLink?: Schemas.ACLAction[];
    projectMember?: Schemas.ACLAction[];
    projectMonitoring?: Schemas.ACLAction[];
    projectPermissions?: Schemas.ACLAction[];
    projectProductionBranch?: Schemas.ACLAction[];
    projectTransfer?: Schemas.ACLAction[];
    projectTransferOut?: Schemas.ACLAction[];
    projectProtectionBypass?: Schemas.ACLAction[];
    projectUsage?: Schemas.ACLAction[];
    projectAnalyticsUsage?: Schemas.ACLAction[];
    projectSupportCase?: Schemas.ACLAction[];
    projectSupportCaseComment?: Schemas.ACLAction[];
    projectDeploymentExpiration?: Schemas.ACLAction[];
    seawallConfig?: Schemas.ACLAction[];
    skewProtection?: Schemas.ACLAction[];
    analytics?: Schemas.ACLAction[];
    trustedIps?: Schemas.ACLAction[];
    webAnalytics?: Schemas.ACLAction[];
    sharedEnvVarConnection?: Schemas.ACLAction[];
  };
  lastRollbackTarget?: Record<string, any> | null;
  lastAliasRequest?: {
    fromDeploymentId: string;
    toDeploymentId: string;
    jobStatus: 'succeeded' | 'failed' | 'skipped' | 'pending' | 'in-progress';
    requestedAt: number;
    type: 'promote' | 'rollback';
  } | null;
  hasFloatingAliases?: boolean;
  protectionBypass?: {
    [key: string]: {
      createdAt: number;
      createdBy: string;
      scope: 'automation-bypass';
    };
  };
  hasActiveBranches?: boolean;
  trustedIps?:
    | {
        deploymentType: 'all' | 'preview' | 'prod_deployment_urls_and_all_previews' | 'production';
        addresses: {
          value: string;
          note?: string;
        }[];
        protectionMode: 'additional' | 'exclusive';
      }
    | {
        deploymentType: 'all' | 'preview' | 'prod_deployment_urls_and_all_previews' | 'production';
      }
    | null;
  gitComments?: {
    /**
     * Whether the Vercel bot should comment on PRs
     */
    onPullRequest: boolean;
    /**
     * Whether the Vercel bot should comment on commits
     */
    onCommit: boolean;
  };
  paused?: boolean;
  concurrencyBucketName?: string;
  webAnalytics?: {
    id: string;
    disabledAt?: number;
    canceledAt?: number;
    enabledAt?: number;
    hasData?: boolean;
  };
  security?: {
    attackModeEnabled?: boolean;
    attackModeUpdatedAt?: number;
    firewallEnabled?: boolean;
    firewallUpdatedAt?: number;
    attackModeActiveUntil?: number | null;
    firewallConfigVersion?: number;
    firewallRoutes?: {
      src?:
        | string
        | {
            re?: string;
            eq?: string;
            neq?: string;
            inc?: string[];
            ninc?: string[];
            pre?: string;
            suf?: string;
            gt?: number;
            gte?: number;
            lt?: number;
            lte?: number;
          };
      has?: {
        type:
          | 'host'
          | 'method'
          | 'path'
          | 'header'
          | 'cookie'
          | 'query'
          | 'ip_address'
          | 'protocol'
          | 'scheme'
          | 'region';
        key?: string;
        value?:
          | string
          | {
              re?: string;
              eq?: string;
              neq?: string;
              inc?: string[];
              ninc?: string[];
              pre?: string;
              suf?: string;
              gt?: number;
              gte?: number;
              lt?: number;
              lte?: number;
            };
      }[];
      missing?: {
        type:
          | 'host'
          | 'method'
          | 'path'
          | 'header'
          | 'cookie'
          | 'query'
          | 'ip_address'
          | 'protocol'
          | 'scheme'
          | 'region';
        key?: string;
        value?:
          | string
          | {
              re?: string;
              eq?: string;
              neq?: string;
              inc?: string[];
              ninc?: string[];
              pre?: string;
              suf?: string;
              gt?: number;
              gte?: number;
              lt?: number;
              lte?: number;
            };
      }[];
      dest?: string;
      status?: number;
      handle?: 'init' | 'finalize';
      mitigate?: {
        action: 'deny' | 'challenge' | 'log' | 'bypass' | 'rate_limit';
        rule_id: string;
        erl?: {
          algo: 'fixed_window' | 'token_bucket';
          window: number;
          limit: number;
          keys: string[];
        };
      };
    }[];
    firewallSeawallEnabled?: boolean;
    ja3Enabled?: boolean;
    ja4Enabled?: boolean;
  };
  oidcTokenConfig?: {
    enabled: boolean;
  };
};

export type GetProjectVariables = {
  pathParams: GetProjectPathParams;
  queryParams?: GetProjectQueryParams;
} & FetcherExtraProps;

/**
 * Get the information for a specific project by passing either the project `id` or `name` in the URL.
 */
export const getProject = (variables: GetProjectVariables, signal?: AbortSignal) =>
  fetch<GetProjectResponse, GetProjectError, undefined, {}, GetProjectQueryParams, GetProjectPathParams>({
    url: '/v9/projects/{idOrName}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateProjectPathParams = {
  /**
   * The unique project identifier or the project name
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  idOrName: string;
};

export type UpdateProjectQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type UpdateProjectError = Fetcher.ErrorWrapper<undefined>;

export type UpdateProjectResponse = {
  accountId: string;
  analytics?: {
    id: string;
    canceledAt?: number | null;
    disabledAt: number;
    enabledAt: number;
    paidAt?: number;
    sampleRatePercent?: number | null;
    spendLimitInDollars?: number | null;
  };
  speedInsights?: {
    id: string;
    enabledAt?: number;
    disabledAt?: number;
    canceledAt?: number;
    hasData?: boolean;
    paidAt?: number;
  };
  autoExposeSystemEnvs?: boolean;
  autoAssignCustomDomains?: boolean;
  autoAssignCustomDomainsUpdatedBy?: string;
  buildCommand?: string | null;
  commandForIgnoringBuildStep?: string | null;
  connectConfigurationId?: string | null;
  connectBuildsEnabled?: boolean;
  createdAt?: number;
  customerSupportCodeVisibility?: boolean;
  crons?: {
    /**
     * The time the feature was enabled for this project. Note: It enables automatically with the first Deployment that outputs cronjobs.
     */
    enabledAt: number;
    /**
     * The time the feature was disabled for this project.
     */
    disabledAt: number | null;
    updatedAt: number;
    /**
     * The ID of the Deployment from which the definitions originated.
     */
    deploymentId: string | null;
    definitions: {
      /**
       * The hostname that should be used.
       *
       * @example vercel.com
       */
      host: string;
      /**
       * The path that should be called for the cronjob.
       *
       * @example /api/crons/sync-something?hello=world
       */
      path: string;
      /**
       * The cron expression.
       *
       * @example 0 0 * * *
       */
      schedule: string;
    }[];
  };
  dataCache?: {
    userDisabled: boolean;
    storageSizeBytes?: number | null;
    unlimited?: boolean;
  };
  deploymentExpiration?: {
    expirationDays?: number;
    expirationDaysProduction?: number;
    expirationDaysCanceled?: number;
    expirationDaysErrored?: number;
    deploymentsToKeep?: number;
  } | null;
  devCommand?: string | null;
  directoryListing: boolean;
  installCommand?: string | null;
  env?: {
    target?:
      | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
      | ('production' | 'preview' | 'development' | 'preview' | 'development');
    type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
    /**
     * This is used to identiy variables that have been migrated from type secret to sensitive.
     */
    sunsetSecretId?: string;
    id?: string;
    key: string;
    value: string;
    configurationId?: string | null;
    createdAt?: number;
    updatedAt?: number;
    createdBy?: string | null;
    updatedBy?: string | null;
    gitBranch?: string;
    edgeConfigId?: string | null;
    edgeConfigTokenId?: string | null;
    contentHint?:
      | {
          type: 'redis-url';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-url';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-token';
          storeId: string;
        }
      | {
          type: 'redis-rest-api-read-only-token';
          storeId: string;
        }
      | {
          type: 'blob-read-write-token';
          storeId: string;
        }
      | {
          type: 'postgres-url';
          storeId: string;
        }
      | {
          type: 'postgres-url-non-pooling';
          storeId: string;
        }
      | {
          type: 'postgres-prisma-url';
          storeId: string;
        }
      | {
          type: 'postgres-user';
          storeId: string;
        }
      | {
          type: 'postgres-host';
          storeId: string;
        }
      | {
          type: 'postgres-password';
          storeId: string;
        }
      | {
          type: 'postgres-database';
          storeId: string;
        }
      | {
          type: 'postgres-url-no-ssl';
          storeId: string;
        }
      | {
          type: 'integration-store-secret';
          storeId: string;
        }
      | null;
    /**
     * Similar to `contentHints`, but should not be exposed to the user.
     */
    internalContentHint?: {
      type: 'flags-secret';
      /**
       * Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
       */
      encryptedValue: string;
    } | null;
    /**
     * Whether `value` is decrypted.
     */
    decrypted?: boolean;
    comment?: string;
    customEnvironmentIds?: string[];
  }[];
  framework?:
    | 'blitzjs'
    | 'nextjs'
    | 'gatsby'
    | 'remix'
    | 'astro'
    | 'hexo'
    | 'eleventy'
    | 'docusaurus-2'
    | 'docusaurus'
    | 'preact'
    | 'solidstart-1'
    | 'solidstart'
    | 'dojo'
    | 'ember'
    | 'vue'
    | 'scully'
    | 'ionic-angular'
    | 'angular'
    | 'polymer'
    | 'svelte'
    | 'sveltekit'
    | 'sveltekit-1'
    | 'ionic-react'
    | 'create-react-app'
    | 'gridsome'
    | 'umijs'
    | 'sapper'
    | 'saber'
    | 'stencil'
    | 'nuxtjs'
    | 'redwoodjs'
    | 'hugo'
    | 'jekyll'
    | 'brunch'
    | 'middleman'
    | 'zola'
    | 'hydrogen'
    | 'vite'
    | 'vitepress'
    | 'vuepress'
    | 'parcel'
    | 'sanity'
    | 'storybook'
    | null;
  gitForkProtection?: boolean;
  gitLFS?: boolean;
  id: string;
  latestDeployments?: {
    alias?: string[];
    aliasAssigned?: number | boolean | null;
    aliasError?: {
      code: string;
      message: string;
    } | null;
    aliasFinal?: string | null;
    automaticAliases?: string[];
    builds?: {
      use: string;
      src?: string;
      dest?: string;
    }[];
    connectBuildsEnabled?: boolean;
    connectConfigurationId?: string;
    createdAt: number;
    createdIn: string;
    creator: {
      email: string;
      githubLogin?: string;
      gitlabLogin?: string;
      uid: string;
      username: string;
    } | null;
    deletedAt?: number;
    deploymentHostname: string;
    name: string;
    forced?: boolean;
    id: string;
    meta?: {
      [key: string]: string;
    };
    monorepoManager?: string | null;
    plan: 'pro' | 'enterprise' | 'hobby';
    private: boolean;
    readyState: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED';
    readySubstate?: 'STAGED' | 'PROMOTED';
    requestedAt?: number;
    target?: string | null;
    teamId?: string | null;
    type: 'LAMBDAS';
    url: string;
    userId: string;
    withCache?: boolean;
    checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
    checksState?: 'registered' | 'running' | 'completed';
    readyAt?: number;
    buildingAt?: number;
    /**
     * Whether or not preview comments are enabled for the deployment
     *
     * @example false
     */
    previewCommentsEnabled?: boolean;
    oidcTokenClaims?: {
      [key: string]: string | string[];
    };
  }[];
  link?:
    | {
        org?: string;
        repo?: string;
        repoId?: number;
        type?: 'github';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        projectId?: string;
        projectName?: string;
        projectNameWithNamespace?: string;
        projectNamespace?: string;
        projectUrl?: string;
        type?: 'gitlab';
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      }
    | {
        name?: string;
        slug?: string;
        owner?: string;
        type?: 'bitbucket';
        uuid?: string;
        workspaceUuid?: string;
        createdAt?: number;
        deployHooks: {
          createdAt?: number;
          id: string;
          name: string;
          ref: string;
          url: string;
        }[];
        gitCredentialId?: string;
        updatedAt?: number;
        sourceless?: boolean;
        productionBranch?: string;
      };
  name: string;
  nodeVersion: '20.x' | '18.x' | '16.x' | '14.x' | '12.x' | '10.x' | '8.10.x';
  optionsAllowlist?: {
    paths: {
      value: string;
    }[];
  } | null;
  outputDirectory?: string | null;
  passiveConnectConfigurationId?: string | null;
  passwordProtection?: Record<string, any> | null;
  productionDeploymentsFastLane?: boolean;
  publicSource?: boolean | null;
  rootDirectory?: string | null;
  serverlessFunctionRegion?: string | null;
  serverlessFunctionZeroConfigFailover?: boolean;
  skewProtectionBoundaryAt?: number;
  skewProtectionMaxAge?: number;
  skipGitConnectDuringLink?: boolean;
  sourceFilesOutsideRootDirectory?: boolean;
  ssoProtection?: {
    deploymentType: 'all' | 'preview' | 'prod_deployment_urls_and_all_previews';
  } | null;
  targets?: {
    [key: string]: string | string[];
  };
  transferCompletedAt?: number;
  transferStartedAt?: number;
  transferToAccountId?: string;
  transferredFromAccountId?: string;
  updatedAt?: number;
  live?: boolean;
  enablePreviewFeedback?: boolean | null;
  permissions?: {
    accessGroup?: Schemas.ACLAction[];
    aliasGlobal?: Schemas.ACLAction[];
    analyticsSampling?: Schemas.ACLAction[];
    analyticsUsage?: Schemas.ACLAction[];
    auditLog?: Schemas.ACLAction[];
    billingAddress?: Schemas.ACLAction[];
    billingInformation?: Schemas.ACLAction[];
    billingInvoice?: Schemas.ACLAction[];
    billingInvoiceEmailRecipient?: Schemas.ACLAction[];
    billingInvoiceLanguage?: Schemas.ACLAction[];
    billingPlan?: Schemas.ACLAction[];
    billingPurchaseOrder?: Schemas.ACLAction[];
    billingTaxId?: Schemas.ACLAction[];
    blob?: Schemas.ACLAction[];
    budget?: Schemas.ACLAction[];
    cacheArtifact?: Schemas.ACLAction[];
    cacheArtifactUsageEvent?: Schemas.ACLAction[];
    codeChecks?: Schemas.ACLAction[];
    concurrentBuilds?: Schemas.ACLAction[];
    connect?: Schemas.ACLAction[];
    connectConfiguration?: Schemas.ACLAction[];
    domain?: Schemas.ACLAction[];
    domainAcceptDelegation?: Schemas.ACLAction[];
    domainAuthCodes?: Schemas.ACLAction[];
    domainCertificate?: Schemas.ACLAction[];
    domainCheckConfig?: Schemas.ACLAction[];
    domainMove?: Schemas.ACLAction[];
    domainPurchase?: Schemas.ACLAction[];
    domainRecord?: Schemas.ACLAction[];
    domainTransferIn?: Schemas.ACLAction[];
    event?: Schemas.ACLAction[];
    ownEvent?: Schemas.ACLAction[];
    sensitiveEnvironmentVariablePolicy?: Schemas.ACLAction[];
    fileUpload?: Schemas.ACLAction[];
    gitRepository?: Schemas.ACLAction[];
    ipBlocking?: Schemas.ACLAction[];
    integration?: Schemas.ACLAction[];
    integrationAccount?: Schemas.ACLAction[];
    integrationConfiguration?: Schemas.ACLAction[];
    integrationConfigurationTransfer?: Schemas.ACLAction[];
    integrationConfigurationProjects?: Schemas.ACLAction[];
    integrationVercelConfigurationOverride?: Schemas.ACLAction[];
    integrationResource?: Schemas.ACLAction[];
    integrationEvent?: Schemas.ACLAction[];
    integrationResourceSecrets?: Schemas.ACLAction[];
    marketplaceBillingData?: Schemas.ACLAction[];
    marketplaceInvoice?: Schemas.ACLAction[];
    jobGlobal?: Schemas.ACLAction[];
    logDrain?: Schemas.ACLAction[];
    Monitoring?: Schemas.ACLAction[];
    monitoringSettings?: Schemas.ACLAction[];
    monitoringQuery?: Schemas.ACLAction[];
    monitoringChart?: Schemas.ACLAction[];
    monitoringAlert?: Schemas.ACLAction[];
    notificationDeploymentFailed?: Schemas.ACLAction[];
    notificationDomainConfiguration?: Schemas.ACLAction[];
    notificationDomainExpire?: Schemas.ACLAction[];
    notificationDomainMoved?: Schemas.ACLAction[];
    notificationDomainPurchase?: Schemas.ACLAction[];
    notificationDomainRenewal?: Schemas.ACLAction[];
    notificationDomainTransfer?: Schemas.ACLAction[];
    notificationDomainUnverified?: Schemas.ACLAction[];
    NotificationMonitoringAlert?: Schemas.ACLAction[];
    notificationPaymentFailed?: Schemas.ACLAction[];
    notificationUsageAlert?: Schemas.ACLAction[];
    notificationCustomerBudget?: Schemas.ACLAction[];
    notificationStatementOfReasons?: Schemas.ACLAction[];
    oauth2Connection?: Schemas.ACLAction[];
    openTelemetryEndpoint?: Schemas.ACLAction[];
    paymentMethod?: Schemas.ACLAction[];
    permissions?: Schemas.ACLAction[];
    postgres?: Schemas.ACLAction[];
    previewDeploymentSuffix?: Schemas.ACLAction[];
    proTrialOnboarding?: Schemas.ACLAction[];
    sharedEnvVars?: Schemas.ACLAction[];
    sharedEnvVarsProduction?: Schemas.ACLAction[];
    space?: Schemas.ACLAction[];
    spaceRun?: Schemas.ACLAction[];
    passwordProtectionInvoiceItem?: Schemas.ACLAction[];
    rateLimit?: Schemas.ACLAction[];
    redis?: Schemas.ACLAction[];
    repository?: Schemas.ACLAction[];
    remoteCaching?: Schemas.ACLAction[];
    samlConfig?: Schemas.ACLAction[];
    secret?: Schemas.ACLAction[];
    redisStoreTokenSet?: Schemas.ACLAction[];
    blobStoreTokenSet?: Schemas.ACLAction[];
    postgresStoreTokenSet?: Schemas.ACLAction[];
    integrationStoreTokenSet?: Schemas.ACLAction[];
    supportCase?: Schemas.ACLAction[];
    supportCaseComment?: Schemas.ACLAction[];
    dataCacheBillingSettings?: Schemas.ACLAction[];
    team?: Schemas.ACLAction[];
    teamAccessRequest?: Schemas.ACLAction[];
    teamFellowMembership?: Schemas.ACLAction[];
    teamGitExclusivity?: Schemas.ACLAction[];
    teamInvite?: Schemas.ACLAction[];
    teamInviteCode?: Schemas.ACLAction[];
    teamJoin?: Schemas.ACLAction[];
    teamOwnMembership?: Schemas.ACLAction[];
    teamOwnMembershipDisconnectSAML?: Schemas.ACLAction[];
    token?: Schemas.ACLAction[];
    usage?: Schemas.ACLAction[];
    usageCycle?: Schemas.ACLAction[];
    user?: Schemas.ACLAction[];
    userConnection?: Schemas.ACLAction[];
    webAnalyticsPlan?: Schemas.ACLAction[];
    webAuthn?: Schemas.ACLAction[];
    edgeConfig?: Schemas.ACLAction[];
    edgeConfigItem?: Schemas.ACLAction[];
    edgeConfigSchema?: Schemas.ACLAction[];
    edgeConfigToken?: Schemas.ACLAction[];
    webhook?: Schemas.ACLAction[];
    ['webhook-event']?: Schemas.ACLAction[];
    endpointVerification?: Schemas.ACLAction[];
    projectTransferIn?: Schemas.ACLAction[];
    oauth2Application?: Schemas.ACLAction[];
    aliasProject?: Schemas.ACLAction[];
    aliasProtectionBypass?: Schemas.ACLAction[];
    productionAliasProtectionBypass?: Schemas.ACLAction[];
    connectConfigurationLink?: Schemas.ACLAction[];
    dataCacheNamespace?: Schemas.ACLAction[];
    deployment?: Schemas.ACLAction[];
    deploymentCheck?: Schemas.ACLAction[];
    deploymentCheckPreview?: Schemas.ACLAction[];
    deploymentCheckReRunFromProductionBranch?: Schemas.ACLAction[];
    deploymentProductionGit?: Schemas.ACLAction[];
    deploymentPreview?: Schemas.ACLAction[];
    deploymentPrivate?: Schemas.ACLAction[];
    deploymentPromote?: Schemas.ACLAction[];
    deploymentRollback?: Schemas.ACLAction[];
    environments?: Schemas.ACLAction[];
    logs?: Schemas.ACLAction[];
    logsPreset?: Schemas.ACLAction[];
    passwordProtection?: Schemas.ACLAction[];
    optionsAllowlist?: Schemas.ACLAction[];
    job?: Schemas.ACLAction[];
    project?: Schemas.ACLAction[];
    projectAccessGroup?: Schemas.ACLAction[];
    projectAnalyticsSampling?: Schemas.ACLAction[];
    projectDeploymentHook?: Schemas.ACLAction[];
    projectDomain?: Schemas.ACLAction[];
    projectDomainMove?: Schemas.ACLAction[];
    projectDomainCheckConfig?: Schemas.ACLAction[];
    projectEnvVars?: Schemas.ACLAction[];
    projectEnvVarsProduction?: Schemas.ACLAction[];
    projectEnvVarsUnownedByIntegration?: Schemas.ACLAction[];
    projectId?: Schemas.ACLAction[];
    projectIntegrationConfiguration?: Schemas.ACLAction[];
    projectLink?: Schemas.ACLAction[];
    projectMember?: Schemas.ACLAction[];
    projectMonitoring?: Schemas.ACLAction[];
    projectPermissions?: Schemas.ACLAction[];
    projectProductionBranch?: Schemas.ACLAction[];
    projectTransfer?: Schemas.ACLAction[];
    projectTransferOut?: Schemas.ACLAction[];
    projectProtectionBypass?: Schemas.ACLAction[];
    projectUsage?: Schemas.ACLAction[];
    projectAnalyticsUsage?: Schemas.ACLAction[];
    projectSupportCase?: Schemas.ACLAction[];
    projectSupportCaseComment?: Schemas.ACLAction[];
    projectDeploymentExpiration?: Schemas.ACLAction[];
    seawallConfig?: Schemas.ACLAction[];
    skewProtection?: Schemas.ACLAction[];
    analytics?: Schemas.ACLAction[];
    trustedIps?: Schemas.ACLAction[];
    webAnalytics?: Schemas.ACLAction[];
    sharedEnvVarConnection?: Schemas.ACLAction[];
  };
  lastRollbackTarget?: Record<string, any> | null;
  lastAliasRequest?: {
    fromDeploymentId: string;
    toDeploymentId: string;
    jobStatus: 'succeeded' | 'failed' | 'skipped' | 'pending' | 'in-progress';
    requestedAt: number;
    type: 'promote' | 'rollback';
  } | null;
  hasFloatingAliases?: boolean;
  protectionBypass?: {
    [key: string]: {
      createdAt: number;
      createdBy: string;
      scope: 'automation-bypass';
    };
  };
  hasActiveBranches?: boolean;
  trustedIps?:
    | {
        deploymentType: 'all' | 'preview' | 'prod_deployment_urls_and_all_previews' | 'production';
        addresses: {
          value: string;
          note?: string;
        }[];
        protectionMode: 'exclusive' | 'additional';
      }
    | {
        deploymentType: 'all' | 'preview' | 'prod_deployment_urls_and_all_previews' | 'production';
      }
    | null;
  gitComments?: {
    /**
     * Whether the Vercel bot should comment on PRs
     */
    onPullRequest: boolean;
    /**
     * Whether the Vercel bot should comment on commits
     */
    onCommit: boolean;
  };
  paused?: boolean;
  concurrencyBucketName?: string;
  webAnalytics?: {
    id: string;
    disabledAt?: number;
    canceledAt?: number;
    enabledAt?: number;
    hasData?: boolean;
  };
  security?: {
    attackModeEnabled?: boolean;
    attackModeUpdatedAt?: number;
    firewallEnabled?: boolean;
    firewallUpdatedAt?: number;
    attackModeActiveUntil?: number | null;
    firewallConfigVersion?: number;
    firewallRoutes?: {
      src?:
        | string
        | {
            re?: string;
            eq?: string;
            neq?: string;
            inc?: string[];
            ninc?: string[];
            pre?: string;
            suf?: string;
            gt?: number;
            gte?: number;
            lt?: number;
            lte?: number;
          };
      has?: {
        type:
          | 'host'
          | 'method'
          | 'path'
          | 'header'
          | 'cookie'
          | 'query'
          | 'ip_address'
          | 'protocol'
          | 'scheme'
          | 'region';
        key?: string;
        value?:
          | string
          | {
              re?: string;
              eq?: string;
              neq?: string;
              inc?: string[];
              ninc?: string[];
              pre?: string;
              suf?: string;
              gt?: number;
              gte?: number;
              lt?: number;
              lte?: number;
            };
      }[];
      missing?: {
        type:
          | 'host'
          | 'method'
          | 'path'
          | 'header'
          | 'cookie'
          | 'query'
          | 'ip_address'
          | 'protocol'
          | 'scheme'
          | 'region';
        key?: string;
        value?:
          | string
          | {
              re?: string;
              eq?: string;
              neq?: string;
              inc?: string[];
              ninc?: string[];
              pre?: string;
              suf?: string;
              gt?: number;
              gte?: number;
              lt?: number;
              lte?: number;
            };
      }[];
      dest?: string;
      status?: number;
      handle?: 'init' | 'finalize';
      mitigate?: {
        action: 'deny' | 'challenge' | 'log' | 'bypass' | 'rate_limit';
        rule_id: string;
        erl?: {
          algo: 'fixed_window' | 'token_bucket';
          window: number;
          limit: number;
          keys: string[];
        };
      };
    }[];
    firewallSeawallEnabled?: boolean;
    ja3Enabled?: boolean;
    ja4Enabled?: boolean;
  };
  oidcTokenConfig?: {
    enabled: boolean;
  };
};

export type UpdateProjectRequestBody = {
  autoExposeSystemEnvs?: boolean;
  autoAssignCustomDomains?: boolean;
  autoAssignCustomDomainsUpdatedBy?: string;
  /**
   * The build command for this project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  buildCommand?: string | null;
  /**
   * @maxLength 256
   */
  commandForIgnoringBuildStep?: string | null;
  /**
   * Specifies whether customer support can see git source for a deployment
   */
  customerSupportCodeVisibility?: boolean;
  /**
   * The dev command for this project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  devCommand?: string | null;
  directoryListing?: boolean;
  /**
   * The framework that is being used for this project. When `null` is used no framework is selected
   */
  framework?:
    | any
    | 'blitzjs'
    | 'nextjs'
    | 'gatsby'
    | 'remix'
    | 'astro'
    | 'hexo'
    | 'eleventy'
    | 'docusaurus-2'
    | 'docusaurus'
    | 'preact'
    | 'solidstart-1'
    | 'solidstart'
    | 'dojo'
    | 'ember'
    | 'vue'
    | 'scully'
    | 'ionic-angular'
    | 'angular'
    | 'polymer'
    | 'svelte'
    | 'sveltekit'
    | 'sveltekit-1'
    | 'ionic-react'
    | 'create-react-app'
    | 'gridsome'
    | 'umijs'
    | 'sapper'
    | 'saber'
    | 'stencil'
    | 'nuxtjs'
    | 'redwoodjs'
    | 'hugo'
    | 'jekyll'
    | 'brunch'
    | 'middleman'
    | 'zola'
    | 'hydrogen'
    | 'vite'
    | 'vitepress'
    | 'vuepress'
    | 'parcel'
    | 'sanity'
    | 'storybook'
    | null;
  /**
   * Specifies whether PRs from Git forks should require a team member's authorization before it can be deployed
   */
  gitForkProtection?: boolean;
  /**
   * Specifies whether Git LFS is enabled for this project.
   */
  gitLFS?: boolean;
  /**
   * The install command for this project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  installCommand?: string | null;
  /**
   * The desired name for the project
   *
   * @example a-project-name
   * @maxLength 100
   * @pattern ^(?!.*---)[a-z0-9-_.]+$
   */
  name?: string;
  nodeVersion?: '20.x' | '18.x' | '16.x' | '14.x' | '12.x' | '10.x';
  /**
   * The output directory of the project. When `null` is used this value will be automatically detected
   *
   * @maxLength 256
   */
  outputDirectory?: string | null;
  /**
   * Specifies whether the source code and logs of the deployments for this project should be public or not
   */
  publicSource?: boolean | null;
  /**
   * The name of a directory or relative path to the source code of your project. When `null` is used it will default to the project root
   *
   * @maxLength 256
   */
  rootDirectory?: string | null;
  /**
   * The region to deploy Serverless Functions in this project
   *
   * @maxLength 4
   */
  serverlessFunctionRegion?: string | null;
  /**
   * Specifies whether Zero Config Failover is enabled for this project.
   */
  serverlessFunctionZeroConfigFailover?: boolean;
  /**
   * Deployments created before this absolute datetime have Skew Protection disabled. Value is in milliseconds since epoch to match \"createdAt\" fields.
   *
   * @minimum 0
   */
  skewProtectionBoundaryAt?: number;
  /**
   * Deployments created before this rolling window have Skew Protection disabled. Value is in seconds to match \"revalidate\" fields.
   *
   * @minimum 0
   */
  skewProtectionMaxAge?: number;
  /**
   * Opts-out of the message prompting a CLI user to connect a Git repository in `vercel link`.
   *
   * @deprecated true
   */
  skipGitConnectDuringLink?: boolean;
  /**
   * Indicates if there are source files outside of the root directory
   */
  sourceFilesOutsideRootDirectory?: boolean;
  /**
   * Opt-in to Preview comments on the project level
   */
  enablePreviewFeedback?: boolean | null;
  /**
   * Allows to protect project deployments with a password
   */
  passwordProtection?: {
    /**
     * Specify if the password will apply to every Deployment Target or just Preview
     */
    deploymentType: 'all' | 'preview' | 'prod_deployment_urls_and_all_previews';
    /**
     * The password that will be used to protect Project Deployments
     *
     * @maxLength 72
     */
    password?: string | null;
  } | null;
  /**
   * Ensures visitors to your Preview Deployments are logged into Vercel and have a minimum of Viewer access on your team
   */
  ssoProtection?: {
    /**
     * Specify if the Vercel Authentication (SSO Protection) will apply to every Deployment Target or just Preview
     *
     * @default preview
     */
    deploymentType: 'all' | 'preview' | 'prod_deployment_urls_and_all_previews';
  } | null;
  /**
   * Restricts access to deployments based on the incoming request IP address
   */
  trustedIps?: {
    /**
     * Specify if the Trusted IPs will apply to every Deployment Target or just Preview
     */
    deploymentType: 'all' | 'preview' | 'production' | 'prod_deployment_urls_and_all_previews';
    /**
     * @minItems 1
     */
    addresses: {
      /**
       * The IP addresses that are allowlisted. Supports IPv4 addresses and CIDR notations. IPv6 is not supported
       */
      value: string;
      /**
       * An optional note explaining what the IP address or subnet is used for
       *
       * @maxLength 20
       */
      note?: string;
    }[];
    /**
     * exclusive: ip match is enough to bypass deployment protection (regardless of other settings). additional: ip must match + any other protection should be also provided (password, vercel auth, shareable link, automation bypass header, automation bypass query param)
     */
    protectionMode: 'exclusive' | 'additional';
  } | null;
  /**
   * Specify a list of paths that should not be protected by Deployment Protection to enable Cors preflight requests
   */
  optionsAllowlist?: {
    /**
     * @minItems 1
     * @maxItems 5
     */
    paths: {
      /**
       * The regex path that should not be protected by Deployment Protection
       *
       * @pattern ^/.*
       */
      value: string;
    }[];
  } | null;
};

export type UpdateProjectVariables = {
  body?: UpdateProjectRequestBody;
  pathParams: UpdateProjectPathParams;
  queryParams?: UpdateProjectQueryParams;
} & FetcherExtraProps;

/**
 * Update the fields of a project using either its `name` or `id`.
 */
export const updateProject = (variables: UpdateProjectVariables, signal?: AbortSignal) =>
  fetch<
    UpdateProjectResponse,
    UpdateProjectError,
    UpdateProjectRequestBody,
    {},
    UpdateProjectQueryParams,
    UpdateProjectPathParams
  >({ url: '/v9/projects/{idOrName}', method: 'patch', ...variables, signal });

export type DeleteProjectPathParams = {
  /**
   * The unique project identifier or the project name
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  idOrName: string;
};

export type DeleteProjectQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type DeleteProjectError = Fetcher.ErrorWrapper<undefined>;

export type DeleteProjectVariables = {
  pathParams: DeleteProjectPathParams;
  queryParams?: DeleteProjectQueryParams;
} & FetcherExtraProps;

/**
 * Delete a specific project by passing either the project `id` or `name` in the URL.
 */
export const deleteProject = (variables: DeleteProjectVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteProjectError, undefined, {}, DeleteProjectQueryParams, DeleteProjectPathParams>({
    url: '/v9/projects/{idOrName}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetProjectDomainsPathParams = {
  /**
   * The unique project identifier or the project name
   */
  idOrName: string | number;
};

export type GetProjectDomainsQueryParams = {
  /**
   * Filters only production domains when set to `true`.
   *
   * @default false
   */
  production?: 'true' | 'false';
  /**
   * Filters domains based on specific branch.
   */
  gitBranch?: string;
  /**
   * Excludes redirect project domains when \"false\". Includes redirect project domains when \"true\" (default).
   *
   * @default true
   */
  redirects?: 'true' | 'false';
  /**
   * Filters domains based on their redirect target.
   *
   * @example example.com
   */
  redirect?: string;
  /**
   * Filters domains based on their verification status.
   */
  verified?: 'true' | 'false';
  /**
   * Maximum number of domains to list from a request (max 100).
   *
   * @example 20
   */
  limit?: number;
  /**
   * Get domains created after this JavaScript timestamp.
   *
   * @example 1609499532000
   */
  since?: number;
  /**
   * Get domains created before this JavaScript timestamp.
   *
   * @example 1612264332000
   */
  until?: number;
  /**
   * Domains sort order by createdAt
   *
   * @default DESC
   */
  order?: 'ASC' | 'DESC';
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetProjectDomainsError = Fetcher.ErrorWrapper<undefined>;

export type GetProjectDomainsResponse = {
  domains: {
    name: string;
    apexName: string;
    projectId: string;
    redirect?: string | null;
    redirectStatusCode?: 307 | 301 | 302 | 308 | null;
    gitBranch?: string | null;
    customEnvironmentId?: string | null;
    updatedAt?: number;
    createdAt?: number;
    /**
     * `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.
     */
    verified: boolean;
    /**
     * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
     */
    verification?: {
      type: string;
      domain: string;
      value: string;
      reason: string;
    }[];
  }[];
  pagination: Schemas.Pagination;
};

export type GetProjectDomainsVariables = {
  pathParams: GetProjectDomainsPathParams;
  queryParams?: GetProjectDomainsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieve the domains associated with a given project by passing either the project `id` or `name` in the URL.
 */
export const getProjectDomains = (variables: GetProjectDomainsVariables, signal?: AbortSignal) =>
  fetch<
    GetProjectDomainsResponse,
    GetProjectDomainsError,
    undefined,
    {},
    GetProjectDomainsQueryParams,
    GetProjectDomainsPathParams
  >({ url: '/v9/projects/{idOrName}/domains', method: 'get', ...variables, signal });

export type GetProjectDomainPathParams = {
  /**
   * The unique project identifier or the project name
   */
  idOrName: string;
  /**
   * The project domain name
   *
   * @example www.example.com
   */
  domain: string;
};

export type GetProjectDomainQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetProjectDomainError = Fetcher.ErrorWrapper<undefined>;

export type GetProjectDomainResponse = {
  name: string;
  apexName: string;
  projectId: string;
  redirect?: string | null;
  redirectStatusCode?: 307 | 301 | 302 | 308 | null;
  gitBranch?: string | null;
  customEnvironmentId?: string | null;
  updatedAt?: number;
  createdAt?: number;
  /**
   * `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.
   */
  verified: boolean;
  /**
   * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
   */
  verification?: {
    type: string;
    domain: string;
    value: string;
    reason: string;
  }[];
};

export type GetProjectDomainVariables = {
  pathParams: GetProjectDomainPathParams;
  queryParams?: GetProjectDomainQueryParams;
} & FetcherExtraProps;

/**
 * Get project domain by project id/name and domain name.
 */
export const getProjectDomain = (variables: GetProjectDomainVariables, signal?: AbortSignal) =>
  fetch<
    GetProjectDomainResponse,
    GetProjectDomainError,
    undefined,
    {},
    GetProjectDomainQueryParams,
    GetProjectDomainPathParams
  >({ url: '/v9/projects/{idOrName}/domains/{domain}', method: 'get', ...variables, signal });

export type UpdateProjectDomainPathParams = {
  /**
   * The unique project identifier or the project name
   */
  idOrName: string;
  /**
   * The project domain name
   *
   * @example www.example.com
   */
  domain: string;
};

export type UpdateProjectDomainQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type UpdateProjectDomainError = Fetcher.ErrorWrapper<undefined>;

export type UpdateProjectDomainResponse = {
  name: string;
  apexName: string;
  projectId: string;
  redirect?: string | null;
  redirectStatusCode?: 307 | 301 | 302 | 308 | null;
  gitBranch?: string | null;
  customEnvironmentId?: string | null;
  updatedAt?: number;
  createdAt?: number;
  /**
   * `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.
   */
  verified: boolean;
  /**
   * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
   */
  verification?: {
    type: string;
    domain: string;
    value: string;
    reason: string;
  }[];
};

export type UpdateProjectDomainRequestBody = {
  /**
   * Git branch to link the project domain
   *
   * @example null
   * @maxLength 250
   */
  gitBranch?: string | null;
  /**
   * The unique custom environment identifier within the project
   */
  customEnvironmentId?: string;
  /**
   * Target destination domain for redirect
   *
   * @example foobar.com
   */
  redirect?: string | null;
  /**
   * Status code for domain redirect
   *
   * @example 307
   */
  redirectStatusCode?: any | 301 | 302 | 307 | 308 | null;
};

export type UpdateProjectDomainVariables = {
  body?: UpdateProjectDomainRequestBody;
  pathParams: UpdateProjectDomainPathParams;
  queryParams?: UpdateProjectDomainQueryParams;
} & FetcherExtraProps;

/**
 * Update a project domain's configuration, including the name, git branch and redirect of the domain.
 */
export const updateProjectDomain = (variables: UpdateProjectDomainVariables, signal?: AbortSignal) =>
  fetch<
    UpdateProjectDomainResponse,
    UpdateProjectDomainError,
    UpdateProjectDomainRequestBody,
    {},
    UpdateProjectDomainQueryParams,
    UpdateProjectDomainPathParams
  >({ url: '/v9/projects/{idOrName}/domains/{domain}', method: 'patch', ...variables, signal });

export type RemoveProjectDomainPathParams = {
  /**
   * The unique project identifier or the project name
   */
  idOrName: string;
  /**
   * The project domain name
   *
   * @example www.example.com
   */
  domain: string;
};

export type RemoveProjectDomainQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type RemoveProjectDomainError = Fetcher.ErrorWrapper<undefined>;

export type RemoveProjectDomainVariables = {
  pathParams: RemoveProjectDomainPathParams;
  queryParams?: RemoveProjectDomainQueryParams;
} & FetcherExtraProps;

/**
 * Remove a domain from a project by passing the domain name and by specifying the project by either passing the project `id` or `name` in the URL.
 */
export const removeProjectDomain = (variables: RemoveProjectDomainVariables, signal?: AbortSignal) =>
  fetch<
    Record<string, any>,
    RemoveProjectDomainError,
    undefined,
    {},
    RemoveProjectDomainQueryParams,
    RemoveProjectDomainPathParams
  >({ url: '/v9/projects/{idOrName}/domains/{domain}', method: 'delete', ...variables, signal });

export type AddProjectDomainPathParams = {
  /**
   * The unique project identifier or the project name
   */
  idOrName: string;
};

export type AddProjectDomainQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type AddProjectDomainError = Fetcher.ErrorWrapper<undefined>;

export type AddProjectDomainResponse = {
  name: string;
  apexName: string;
  projectId: string;
  redirect?: string | null;
  redirectStatusCode?: 307 | 301 | 302 | 308 | null;
  gitBranch?: string | null;
  customEnvironmentId?: string | null;
  updatedAt?: number;
  createdAt?: number;
  /**
   * `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.
   */
  verified: boolean;
  /**
   * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
   */
  verification?: {
    type: string;
    domain: string;
    value: string;
    reason: string;
  }[];
};

export type AddProjectDomainRequestBody = {
  /**
   * The project domain name
   *
   * @example www.example.com
   */
  name: string;
  /**
   * Git branch to link the project domain
   *
   * @example null
   * @maxLength 250
   */
  gitBranch?: string | null;
  /**
   * Target destination domain for redirect
   *
   * @example foobar.com
   */
  redirect?: string | null;
  /**
   * Status code for domain redirect
   *
   * @example 307
   */
  redirectStatusCode?: any | 301 | 302 | 307 | 308 | null;
};

export type AddProjectDomainVariables = {
  body: AddProjectDomainRequestBody;
  pathParams: AddProjectDomainPathParams;
  queryParams?: AddProjectDomainQueryParams;
} & FetcherExtraProps;

/**
 * Add a domain to the project by passing its domain name and by specifying the project by either passing the project `id` or `name` in the URL. If the domain is not yet verified to be used on this project, the request will return `verified = false`, and the domain will need to be verified according to the `verification` challenge via `POST /projects/:idOrName/domains/:domain/verify`. If the domain already exists on the project, the request will fail with a `400` status code.
 */
export const addProjectDomain = (variables: AddProjectDomainVariables, signal?: AbortSignal) =>
  fetch<
    AddProjectDomainResponse,
    AddProjectDomainError,
    AddProjectDomainRequestBody,
    {},
    AddProjectDomainQueryParams,
    AddProjectDomainPathParams
  >({ url: '/v10/projects/{idOrName}/domains', method: 'post', ...variables, signal });

export type VerifyProjectDomainPathParams = {
  /**
   * The unique project identifier or the project name
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  idOrName: string;
  /**
   * The domain name you want to verify
   *
   * @example example.com
   */
  domain: string;
};

export type VerifyProjectDomainQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type VerifyProjectDomainError = Fetcher.ErrorWrapper<undefined>;

export type VerifyProjectDomainResponse = {
  name: string;
  apexName: string;
  projectId: string;
  redirect?: string | null;
  redirectStatusCode?: 307 | 301 | 302 | 308 | null;
  gitBranch?: string | null;
  customEnvironmentId?: string | null;
  updatedAt?: number;
  createdAt?: number;
  /**
   * `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.
   */
  verified: boolean;
  /**
   * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
   */
  verification?: {
    type: string;
    domain: string;
    value: string;
    reason: string;
  }[];
};

export type VerifyProjectDomainVariables = {
  pathParams: VerifyProjectDomainPathParams;
  queryParams?: VerifyProjectDomainQueryParams;
} & FetcherExtraProps;

/**
 * Attempts to verify a project domain with `verified = false` by checking the correctness of the project domain's `verification` challenge.
 */
export const verifyProjectDomain = (variables: VerifyProjectDomainVariables, signal?: AbortSignal) =>
  fetch<
    VerifyProjectDomainResponse,
    VerifyProjectDomainError,
    undefined,
    {},
    VerifyProjectDomainQueryParams,
    VerifyProjectDomainPathParams
  >({ url: '/v9/projects/{idOrName}/domains/{domain}/verify', method: 'post', ...variables, signal });

export type FilterProjectEnvsPathParams = {
  /**
   * The unique project identifier or the project name
   *
   * @example prj_XLKmu1DyR1eY7zq8UgeRKbA7yVLA
   */
  idOrName: string;
};

export type FilterProjectEnvsQueryParams = {
  /**
   * If defined, the git branch of the environment variable to filter the results (must have target=preview)
   *
   * @maxLength 250
   * @example feature-1
   */
  gitBranch?: string;
  /**
   * If true, the environment variable value will be decrypted
   *
   * @example true
   * @deprecated true
   */
  decrypt?: 'true' | 'false';
  /**
   * The source that is calling the endpoint.
   *
   * @example vercel-cli:pull
   */
  source?: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type FilterProjectEnvsError = Fetcher.ErrorWrapper<undefined>;

export type FilterProjectEnvsVariables = {
  pathParams: FilterProjectEnvsPathParams;
  queryParams?: FilterProjectEnvsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieve the environment variables for a given project by passing either the project `id` or `name` in the URL.
 */
export const filterProjectEnvs = (variables: FilterProjectEnvsVariables, signal?: AbortSignal) =>
  fetch<
    | {
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development');
        type?: 'system' | 'encrypted' | 'plain' | 'sensitive' | 'secret';
        /**
         * This is used to identiy variables that have been migrated from type secret to sensitive.
         */
        sunsetSecretId?: string;
        id?: string;
        key?: string;
        value?: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        contentHint?:
          | {
              type: 'redis-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-token';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-read-only-token';
              storeId: string;
            }
          | {
              type: 'blob-read-write-token';
              storeId: string;
            }
          | {
              type: 'postgres-url';
              storeId: string;
            }
          | {
              type: 'postgres-url-non-pooling';
              storeId: string;
            }
          | {
              type: 'postgres-prisma-url';
              storeId: string;
            }
          | {
              type: 'postgres-user';
              storeId: string;
            }
          | {
              type: 'postgres-host';
              storeId: string;
            }
          | {
              type: 'postgres-password';
              storeId: string;
            }
          | {
              type: 'postgres-database';
              storeId: string;
            }
          | {
              type: 'postgres-url-no-ssl';
              storeId: string;
            }
          | {
              type: 'integration-store-secret';
              storeId: string;
            }
          | null;
        /**
         * Similar to `contentHints`, but should not be exposed to the user.
         */
        internalContentHint?: {
          type: 'flags-secret';
          /**
           * Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
           */
          encryptedValue: string;
        } | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
        comment?: string;
        customEnvironmentIds?: string[];
        system?: boolean;
      }
    | {
        envs: {
          target?:
            | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
            | ('production' | 'preview' | 'development' | 'preview' | 'development');
          type?: 'system' | 'encrypted' | 'plain' | 'sensitive' | 'secret';
          /**
           * This is used to identiy variables that have been migrated from type secret to sensitive.
           */
          sunsetSecretId?: string;
          id?: string;
          key?: string;
          value?: string;
          configurationId?: string | null;
          createdAt?: number;
          updatedAt?: number;
          createdBy?: string | null;
          updatedBy?: string | null;
          gitBranch?: string;
          edgeConfigId?: string | null;
          edgeConfigTokenId?: string | null;
          contentHint?:
            | {
                type: 'redis-url';
                storeId: string;
              }
            | {
                type: 'redis-rest-api-url';
                storeId: string;
              }
            | {
                type: 'redis-rest-api-token';
                storeId: string;
              }
            | {
                type: 'redis-rest-api-read-only-token';
                storeId: string;
              }
            | {
                type: 'blob-read-write-token';
                storeId: string;
              }
            | {
                type: 'postgres-url';
                storeId: string;
              }
            | {
                type: 'postgres-url-non-pooling';
                storeId: string;
              }
            | {
                type: 'postgres-prisma-url';
                storeId: string;
              }
            | {
                type: 'postgres-user';
                storeId: string;
              }
            | {
                type: 'postgres-host';
                storeId: string;
              }
            | {
                type: 'postgres-password';
                storeId: string;
              }
            | {
                type: 'postgres-database';
                storeId: string;
              }
            | {
                type: 'postgres-url-no-ssl';
                storeId: string;
              }
            | {
                type: 'integration-store-secret';
                storeId: string;
              }
            | null;
          /**
           * Similar to `contentHints`, but should not be exposed to the user.
           */
          internalContentHint?: {
            type: 'flags-secret';
            /**
             * Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
             */
            encryptedValue: string;
          } | null;
          /**
           * Whether `value` is decrypted.
           */
          decrypted?: boolean;
          comment?: string;
          customEnvironmentIds?: string[];
          system?: boolean;
        }[];
        pagination: Schemas.Pagination;
      }
    | {
        envs: {
          target?:
            | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
            | ('production' | 'preview' | 'development' | 'preview' | 'development');
          type?: 'system' | 'encrypted' | 'plain' | 'sensitive' | 'secret';
          /**
           * This is used to identiy variables that have been migrated from type secret to sensitive.
           */
          sunsetSecretId?: string;
          id?: string;
          key?: string;
          value?: string;
          configurationId?: string | null;
          createdAt?: number;
          updatedAt?: number;
          createdBy?: string | null;
          updatedBy?: string | null;
          gitBranch?: string;
          edgeConfigId?: string | null;
          edgeConfigTokenId?: string | null;
          contentHint?:
            | {
                type: 'redis-url';
                storeId: string;
              }
            | {
                type: 'redis-rest-api-url';
                storeId: string;
              }
            | {
                type: 'redis-rest-api-token';
                storeId: string;
              }
            | {
                type: 'redis-rest-api-read-only-token';
                storeId: string;
              }
            | {
                type: 'blob-read-write-token';
                storeId: string;
              }
            | {
                type: 'postgres-url';
                storeId: string;
              }
            | {
                type: 'postgres-url-non-pooling';
                storeId: string;
              }
            | {
                type: 'postgres-prisma-url';
                storeId: string;
              }
            | {
                type: 'postgres-user';
                storeId: string;
              }
            | {
                type: 'postgres-host';
                storeId: string;
              }
            | {
                type: 'postgres-password';
                storeId: string;
              }
            | {
                type: 'postgres-database';
                storeId: string;
              }
            | {
                type: 'postgres-url-no-ssl';
                storeId: string;
              }
            | {
                type: 'integration-store-secret';
                storeId: string;
              }
            | null;
          /**
           * Similar to `contentHints`, but should not be exposed to the user.
           */
          internalContentHint?: {
            type: 'flags-secret';
            /**
             * Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
             */
            encryptedValue: string;
          } | null;
          /**
           * Whether `value` is decrypted.
           */
          decrypted?: boolean;
          comment?: string;
          customEnvironmentIds?: string[];
          system?: boolean;
        }[];
      },
    FilterProjectEnvsError,
    undefined,
    {},
    FilterProjectEnvsQueryParams,
    FilterProjectEnvsPathParams
  >({ url: '/v9/projects/{idOrName}/env', method: 'get', ...variables, signal });

export type GetProjectEnvPathParams = {
  /**
   * The unique project identifier or the project name
   *
   * @example prj_XLKmu1DyR1eY7zq8UgeRKbA7yVLA
   */
  idOrName: string;
  /**
   * The unique ID for the environment variable to get the decrypted value.
   */
  id: string;
};

export type GetProjectEnvQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetProjectEnvError = Fetcher.ErrorWrapper<undefined>;

export type GetProjectEnvVariables = {
  pathParams: GetProjectEnvPathParams;
  queryParams?: GetProjectEnvQueryParams;
} & FetcherExtraProps;

/**
 * Retrieve the environment variable for a given project.
 */
export const getProjectEnv = (variables: GetProjectEnvVariables, signal?: AbortSignal) =>
  fetch<
    | {
        decrypted: boolean;
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
        type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
        /**
         * This is used to identiy variables that have been migrated from type secret to sensitive.
         */
        sunsetSecretId?: string;
        id?: string;
        key: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        contentHint?:
          | {
              type: 'redis-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-token';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-read-only-token';
              storeId: string;
            }
          | {
              type: 'blob-read-write-token';
              storeId: string;
            }
          | {
              type: 'postgres-url';
              storeId: string;
            }
          | {
              type: 'postgres-url-non-pooling';
              storeId: string;
            }
          | {
              type: 'postgres-prisma-url';
              storeId: string;
            }
          | {
              type: 'postgres-user';
              storeId: string;
            }
          | {
              type: 'postgres-host';
              storeId: string;
            }
          | {
              type: 'postgres-password';
              storeId: string;
            }
          | {
              type: 'postgres-database';
              storeId: string;
            }
          | {
              type: 'postgres-url-no-ssl';
              storeId: string;
            }
          | {
              type: 'integration-store-secret';
              storeId: string;
            }
          | null;
        /**
         * Similar to `contentHints`, but should not be exposed to the user.
         */
        internalContentHint?: {
          type: 'flags-secret';
          /**
           * Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
           */
          encryptedValue: string;
        } | null;
        comment?: string;
        customEnvironmentIds?: string[];
      }
    | {
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
        type: 'secret' | 'system' | 'encrypted' | 'plain' | 'sensitive';
        /**
         * This is used to identiy variables that have been migrated from type secret to sensitive.
         */
        sunsetSecretId?: string;
        id?: string;
        key: string;
        value: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        contentHint?:
          | {
              type: 'redis-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-token';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-read-only-token';
              storeId: string;
            }
          | {
              type: 'blob-read-write-token';
              storeId: string;
            }
          | {
              type: 'postgres-url';
              storeId: string;
            }
          | {
              type: 'postgres-url-non-pooling';
              storeId: string;
            }
          | {
              type: 'postgres-prisma-url';
              storeId: string;
            }
          | {
              type: 'postgres-user';
              storeId: string;
            }
          | {
              type: 'postgres-host';
              storeId: string;
            }
          | {
              type: 'postgres-password';
              storeId: string;
            }
          | {
              type: 'postgres-database';
              storeId: string;
            }
          | {
              type: 'postgres-url-no-ssl';
              storeId: string;
            }
          | {
              type: 'integration-store-secret';
              storeId: string;
            }
          | null;
        /**
         * Similar to `contentHints`, but should not be exposed to the user.
         */
        internalContentHint?: {
          type: 'flags-secret';
          /**
           * Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
           */
          encryptedValue: string;
        } | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
        comment?: string;
        customEnvironmentIds?: string[];
      },
    GetProjectEnvError,
    undefined,
    {},
    GetProjectEnvQueryParams,
    GetProjectEnvPathParams
  >({ url: '/v1/projects/{idOrName}/env/{id}', method: 'get', ...variables, signal });

export type CreateProjectEnvPathParams = {
  /**
   * The unique project identifier or the project name
   *
   * @example prj_XLKmu1DyR1eY7zq8UgeRKbA7yVLA
   */
  idOrName: string;
};

export type CreateProjectEnvQueryParams = {
  /**
   * Allow override of environment variable if it already exists
   *
   * @example true
   */
  upsert?: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type CreateProjectEnvError = Fetcher.ErrorWrapper<undefined>;

export type CreateProjectEnvResponse = {
  created:
    | {
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
        type?: 'system' | 'encrypted' | 'plain' | 'sensitive' | 'secret';
        /**
         * This is used to identiy variables that have been migrated from type secret to sensitive.
         */
        sunsetSecretId?: string;
        id?: string;
        key?: string;
        value?: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        contentHint?:
          | {
              type: 'redis-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-token';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-read-only-token';
              storeId: string;
            }
          | {
              type: 'blob-read-write-token';
              storeId: string;
            }
          | {
              type: 'postgres-url';
              storeId: string;
            }
          | {
              type: 'postgres-url-non-pooling';
              storeId: string;
            }
          | {
              type: 'postgres-prisma-url';
              storeId: string;
            }
          | {
              type: 'postgres-user';
              storeId: string;
            }
          | {
              type: 'postgres-host';
              storeId: string;
            }
          | {
              type: 'postgres-password';
              storeId: string;
            }
          | {
              type: 'postgres-database';
              storeId: string;
            }
          | {
              type: 'postgres-url-no-ssl';
              storeId: string;
            }
          | {
              type: 'integration-store-secret';
              storeId: string;
            }
          | null;
        /**
         * Similar to `contentHints`, but should not be exposed to the user.
         */
        internalContentHint?: {
          type: 'flags-secret';
          /**
           * Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
           */
          encryptedValue: string;
        } | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
        comment?: string;
        customEnvironmentIds?: string[];
        system?: boolean;
      }
    | {
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
        type?: 'system' | 'encrypted' | 'plain' | 'sensitive' | 'secret';
        /**
         * This is used to identiy variables that have been migrated from type secret to sensitive.
         */
        sunsetSecretId?: string;
        id?: string;
        key?: string;
        value?: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        contentHint?:
          | {
              type: 'redis-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-token';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-read-only-token';
              storeId: string;
            }
          | {
              type: 'blob-read-write-token';
              storeId: string;
            }
          | {
              type: 'postgres-url';
              storeId: string;
            }
          | {
              type: 'postgres-url-non-pooling';
              storeId: string;
            }
          | {
              type: 'postgres-prisma-url';
              storeId: string;
            }
          | {
              type: 'postgres-user';
              storeId: string;
            }
          | {
              type: 'postgres-host';
              storeId: string;
            }
          | {
              type: 'postgres-password';
              storeId: string;
            }
          | {
              type: 'postgres-database';
              storeId: string;
            }
          | {
              type: 'postgres-url-no-ssl';
              storeId: string;
            }
          | {
              type: 'integration-store-secret';
              storeId: string;
            }
          | null;
        /**
         * Similar to `contentHints`, but should not be exposed to the user.
         */
        internalContentHint?: {
          type: 'flags-secret';
          /**
           * Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
           */
          encryptedValue: string;
        } | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
        comment?: string;
        customEnvironmentIds?: string[];
        system?: boolean;
      }[];
  failed: {
    error: {
      code: string;
      message: string;
      key?: string;
      envVarId?: string;
      envVarKey?: string;
      action?: string;
      link?: string;
      value?:
        | string
        | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[];
      gitBranch?: string;
      target?:
        | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
        | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
      project?: string;
    };
  }[];
};

export type CreateProjectEnvVariables = {
  body?:
    | (
        | {
            /**
             * The name of the environment variable
             *
             * @example API_URL
             */
            key?: string;
            /**
             * The value of the environment variable
             *
             * @example https://api.vercel.com
             */
            value?: string;
            /**
             * The type of environment variable
             *
             * @example plain
             */
            type?: 'system' | 'secret' | 'encrypted' | 'plain' | 'sensitive';
            /**
             * The target environment of the environment variable
             *
             * @example preview
             */
            target: ('production' | 'preview' | 'development')[];
            /**
             * If defined, the git branch of the environment variable (must have target=preview)
             *
             * @maxLength 250
             * @example feature-1
             */
            gitBranch?: string | null;
            /**
             * A comment to add context on what this environment variable is for
             *
             * @example database connection string for production
             * @maxLength 500
             */
            comment?: string;
          }
        | {
            /**
             * The name of the environment variable
             *
             * @example API_URL
             */
            key?: string;
            /**
             * The value of the environment variable
             *
             * @example https://api.vercel.com
             */
            value?: string;
            /**
             * The type of environment variable
             *
             * @example plain
             */
            type?: 'system' | 'secret' | 'encrypted' | 'plain' | 'sensitive';
            /**
             * The target environment of the environment variable
             *
             * @example preview
             */
            target?: ('production' | 'preview' | 'development')[];
            /**
             * If defined, the git branch of the environment variable (must have target=preview)
             *
             * @maxLength 250
             * @example feature-1
             */
            gitBranch?: string | null;
            /**
             * A comment to add context on what this environment variable is for
             *
             * @example database connection string for production
             * @maxLength 500
             */
            comment?: string;
          }
      )
    | (
        | {
            /**
             * The name of the environment variable
             *
             * @example API_URL
             */
            key?: string;
            /**
             * The value of the environment variable
             *
             * @example https://api.vercel.com
             */
            value?: string;
            /**
             * The type of environment variable
             *
             * @example plain
             */
            type?: 'system' | 'secret' | 'encrypted' | 'plain' | 'sensitive';
            /**
             * The target environment of the environment variable
             *
             * @example preview
             */
            target: ('production' | 'preview' | 'development')[];
            /**
             * If defined, the git branch of the environment variable (must have target=preview)
             *
             * @maxLength 250
             * @example feature-1
             */
            gitBranch?: string | null;
            /**
             * A comment to add context on what this environment variable is for
             *
             * @example database connection string for production
             * @maxLength 500
             */
            comment?: string;
          }
        | {
            /**
             * The name of the environment variable
             *
             * @example API_URL
             */
            key?: string;
            /**
             * The value of the environment variable
             *
             * @example https://api.vercel.com
             */
            value?: string;
            /**
             * The type of environment variable
             *
             * @example plain
             */
            type?: 'system' | 'secret' | 'encrypted' | 'plain' | 'sensitive';
            /**
             * The target environment of the environment variable
             *
             * @example preview
             */
            target?: ('production' | 'preview' | 'development')[];
            /**
             * If defined, the git branch of the environment variable (must have target=preview)
             *
             * @maxLength 250
             * @example feature-1
             */
            gitBranch?: string | null;
            /**
             * A comment to add context on what this environment variable is for
             *
             * @example database connection string for production
             * @maxLength 500
             */
            comment?: string;
          }
      )[];
  pathParams: CreateProjectEnvPathParams;
  queryParams?: CreateProjectEnvQueryParams;
} & FetcherExtraProps;

/**
 * Create one ore more environment variables for a project by passing its `key`, `value`, `type` and `target` and by specifying the project by either passing the project `id` or `name` in the URL.
 */
export const createProjectEnv = (variables: CreateProjectEnvVariables, signal?: AbortSignal) =>
  fetch<
    CreateProjectEnvResponse,
    CreateProjectEnvError,
    | (
        | {
            /**
             * The name of the environment variable
             *
             * @example API_URL
             */
            key?: string;
            /**
             * The value of the environment variable
             *
             * @example https://api.vercel.com
             */
            value?: string;
            /**
             * The type of environment variable
             *
             * @example plain
             */
            type?: 'system' | 'secret' | 'encrypted' | 'plain' | 'sensitive';
            /**
             * The target environment of the environment variable
             *
             * @example preview
             */
            target: ('production' | 'preview' | 'development')[];
            /**
             * If defined, the git branch of the environment variable (must have target=preview)
             *
             * @maxLength 250
             * @example feature-1
             */
            gitBranch?: string | null;
            /**
             * A comment to add context on what this environment variable is for
             *
             * @example database connection string for production
             * @maxLength 500
             */
            comment?: string;
          }
        | {
            /**
             * The name of the environment variable
             *
             * @example API_URL
             */
            key?: string;
            /**
             * The value of the environment variable
             *
             * @example https://api.vercel.com
             */
            value?: string;
            /**
             * The type of environment variable
             *
             * @example plain
             */
            type?: 'system' | 'secret' | 'encrypted' | 'plain' | 'sensitive';
            /**
             * The target environment of the environment variable
             *
             * @example preview
             */
            target?: ('production' | 'preview' | 'development')[];
            /**
             * If defined, the git branch of the environment variable (must have target=preview)
             *
             * @maxLength 250
             * @example feature-1
             */
            gitBranch?: string | null;
            /**
             * A comment to add context on what this environment variable is for
             *
             * @example database connection string for production
             * @maxLength 500
             */
            comment?: string;
          }
      )
    | (
        | {
            /**
             * The name of the environment variable
             *
             * @example API_URL
             */
            key?: string;
            /**
             * The value of the environment variable
             *
             * @example https://api.vercel.com
             */
            value?: string;
            /**
             * The type of environment variable
             *
             * @example plain
             */
            type?: 'system' | 'secret' | 'encrypted' | 'plain' | 'sensitive';
            /**
             * The target environment of the environment variable
             *
             * @example preview
             */
            target: ('production' | 'preview' | 'development')[];
            /**
             * If defined, the git branch of the environment variable (must have target=preview)
             *
             * @maxLength 250
             * @example feature-1
             */
            gitBranch?: string | null;
            /**
             * A comment to add context on what this environment variable is for
             *
             * @example database connection string for production
             * @maxLength 500
             */
            comment?: string;
          }
        | {
            /**
             * The name of the environment variable
             *
             * @example API_URL
             */
            key?: string;
            /**
             * The value of the environment variable
             *
             * @example https://api.vercel.com
             */
            value?: string;
            /**
             * The type of environment variable
             *
             * @example plain
             */
            type?: 'system' | 'secret' | 'encrypted' | 'plain' | 'sensitive';
            /**
             * The target environment of the environment variable
             *
             * @example preview
             */
            target?: ('production' | 'preview' | 'development')[];
            /**
             * If defined, the git branch of the environment variable (must have target=preview)
             *
             * @maxLength 250
             * @example feature-1
             */
            gitBranch?: string | null;
            /**
             * A comment to add context on what this environment variable is for
             *
             * @example database connection string for production
             * @maxLength 500
             */
            comment?: string;
          }
      )[],
    {},
    CreateProjectEnvQueryParams,
    CreateProjectEnvPathParams
  >({ url: '/v10/projects/{idOrName}/env', method: 'post', ...variables, signal });

export type RemoveProjectEnvPathParams = {
  /**
   * The unique project identifier or the project name
   *
   * @example prj_XLKmu1DyR1eY7zq8UgeRKbA7yVLA
   */
  idOrName: string;
  /**
   * The unique environment variable identifier
   *
   * @example XMbOEya1gUUO1ir4
   */
  id: string;
};

export type RemoveProjectEnvQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type RemoveProjectEnvError = Fetcher.ErrorWrapper<undefined>;

export type RemoveProjectEnvVariables = {
  pathParams: RemoveProjectEnvPathParams;
  queryParams?: RemoveProjectEnvQueryParams;
} & FetcherExtraProps;

/**
 * Delete a specific environment variable for a given project by passing the environment variable identifier and either passing the project `id` or `name` in the URL.
 */
export const removeProjectEnv = (variables: RemoveProjectEnvVariables, signal?: AbortSignal) =>
  fetch<
    | {
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
        type: 'system' | 'encrypted' | 'plain' | 'sensitive' | 'secret';
        /**
         * This is used to identiy variables that have been migrated from type secret to sensitive.
         */
        sunsetSecretId?: string;
        id?: string;
        key: string;
        value: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        contentHint?:
          | {
              type: 'redis-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-token';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-read-only-token';
              storeId: string;
            }
          | {
              type: 'blob-read-write-token';
              storeId: string;
            }
          | {
              type: 'postgres-url';
              storeId: string;
            }
          | {
              type: 'postgres-url-non-pooling';
              storeId: string;
            }
          | {
              type: 'postgres-prisma-url';
              storeId: string;
            }
          | {
              type: 'postgres-user';
              storeId: string;
            }
          | {
              type: 'postgres-host';
              storeId: string;
            }
          | {
              type: 'postgres-password';
              storeId: string;
            }
          | {
              type: 'postgres-database';
              storeId: string;
            }
          | {
              type: 'postgres-url-no-ssl';
              storeId: string;
            }
          | {
              type: 'integration-store-secret';
              storeId: string;
            }
          | null;
        /**
         * Similar to `contentHints`, but should not be exposed to the user.
         */
        internalContentHint?: {
          type: 'flags-secret';
          /**
           * Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
           */
          encryptedValue: string;
        } | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
        comment?: string;
        customEnvironmentIds?: string[];
      }[]
    | {
        system?: boolean;
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
        type: 'system' | 'encrypted' | 'plain' | 'sensitive' | 'secret';
        /**
         * This is used to identiy variables that have been migrated from type secret to sensitive.
         */
        sunsetSecretId?: string;
        id?: string;
        key: string;
        value: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        contentHint?:
          | {
              type: 'redis-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-token';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-read-only-token';
              storeId: string;
            }
          | {
              type: 'blob-read-write-token';
              storeId: string;
            }
          | {
              type: 'postgres-url';
              storeId: string;
            }
          | {
              type: 'postgres-url-non-pooling';
              storeId: string;
            }
          | {
              type: 'postgres-prisma-url';
              storeId: string;
            }
          | {
              type: 'postgres-user';
              storeId: string;
            }
          | {
              type: 'postgres-host';
              storeId: string;
            }
          | {
              type: 'postgres-password';
              storeId: string;
            }
          | {
              type: 'postgres-database';
              storeId: string;
            }
          | {
              type: 'postgres-url-no-ssl';
              storeId: string;
            }
          | {
              type: 'integration-store-secret';
              storeId: string;
            }
          | null;
        /**
         * Similar to `contentHints`, but should not be exposed to the user.
         */
        internalContentHint?: {
          type: 'flags-secret';
          /**
           * Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
           */
          encryptedValue: string;
        } | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
        comment?: string;
        customEnvironmentIds?: string[];
      }
    | {
        target?:
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development')[]
          | ('production' | 'preview' | 'development' | 'preview' | 'development' | 'preview' | 'development');
        type: 'system' | 'encrypted' | 'plain' | 'sensitive' | 'secret';
        /**
         * This is used to identiy variables that have been migrated from type secret to sensitive.
         */
        sunsetSecretId?: string;
        id?: string;
        key: string;
        value: string;
        configurationId?: string | null;
        createdAt?: number;
        updatedAt?: number;
        createdBy?: string | null;
        updatedBy?: string | null;
        gitBranch?: string;
        edgeConfigId?: string | null;
        edgeConfigTokenId?: string | null;
        contentHint?:
          | {
              type: 'redis-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-url';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-token';
              storeId: string;
            }
          | {
              type: 'redis-rest-api-read-only-token';
              storeId: string;
            }
          | {
              type: 'blob-read-write-token';
              storeId: string;
            }
          | {
              type: 'postgres-url';
              storeId: string;
            }
          | {
              type: 'postgres-url-non-pooling';
              storeId: string;
            }
          | {
              type: 'postgres-prisma-url';
              storeId: string;
            }
          | {
              type: 'postgres-user';
              storeId: string;
            }
          | {
              type: 'postgres-host';
              storeId: string;
            }
          | {
              type: 'postgres-password';
              storeId: string;
            }
          | {
              type: 'postgres-database';
              storeId: string;
            }
          | {
              type: 'postgres-url-no-ssl';
              storeId: string;
            }
          | {
              type: 'integration-store-secret';
              storeId: string;
            }
          | null;
        /**
         * Similar to `contentHints`, but should not be exposed to the user.
         */
        internalContentHint?: {
          type: 'flags-secret';
          /**
           * Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
           */
          encryptedValue: string;
        } | null;
        /**
         * Whether `value` is decrypted.
         */
        decrypted?: boolean;
        comment?: string;
        customEnvironmentIds?: string[];
      },
    RemoveProjectEnvError,
    undefined,
    {},
    RemoveProjectEnvQueryParams,
    RemoveProjectEnvPathParams
  >({ url: '/v9/projects/{idOrName}/env/{id}', method: 'delete', ...variables, signal });

export type EditProjectEnvPathParams = {
  /**
   * The unique project identifier or the project name
   *
   * @example prj_XLKmu1DyR1eY7zq8UgeRKbA7yVLA
   */
  idOrName: string;
  /**
   * The unique environment variable identifier
   *
   * @example XMbOEya1gUUO1ir4
   */
  id: string;
};

export type EditProjectEnvQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type EditProjectEnvError = Fetcher.ErrorWrapper<undefined>;

export type EditProjectEnvResponse = {
  target?:
    | ('production' | 'preview' | 'development' | 'preview' | 'development')[]
    | ('production' | 'preview' | 'development' | 'preview' | 'development');
  type: 'system' | 'encrypted' | 'plain' | 'sensitive' | 'secret';
  /**
   * This is used to identiy variables that have been migrated from type secret to sensitive.
   */
  sunsetSecretId?: string;
  id?: string;
  key: string;
  value: string;
  configurationId?: string | null;
  createdAt?: number;
  updatedAt?: number;
  createdBy?: string | null;
  updatedBy?: string | null;
  gitBranch?: string;
  edgeConfigId?: string | null;
  edgeConfigTokenId?: string | null;
  contentHint?:
    | {
        type: 'redis-url';
        storeId: string;
      }
    | {
        type: 'redis-rest-api-url';
        storeId: string;
      }
    | {
        type: 'redis-rest-api-token';
        storeId: string;
      }
    | {
        type: 'redis-rest-api-read-only-token';
        storeId: string;
      }
    | {
        type: 'blob-read-write-token';
        storeId: string;
      }
    | {
        type: 'postgres-url';
        storeId: string;
      }
    | {
        type: 'postgres-url-non-pooling';
        storeId: string;
      }
    | {
        type: 'postgres-prisma-url';
        storeId: string;
      }
    | {
        type: 'postgres-user';
        storeId: string;
      }
    | {
        type: 'postgres-host';
        storeId: string;
      }
    | {
        type: 'postgres-password';
        storeId: string;
      }
    | {
        type: 'postgres-database';
        storeId: string;
      }
    | {
        type: 'postgres-url-no-ssl';
        storeId: string;
      }
    | {
        type: 'integration-store-secret';
        storeId: string;
      }
    | null;
  /**
   * Similar to `contentHints`, but should not be exposed to the user.
   */
  internalContentHint?: {
    type: 'flags-secret';
    /**
     * Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
     */
    encryptedValue: string;
  } | null;
  /**
   * Whether `value` is decrypted.
   */
  decrypted?: boolean;
  comment?: string;
  customEnvironmentIds?: string[];
};

export type EditProjectEnvRequestBody = {
  /**
   * The name of the environment variable
   *
   * @example GITHUB_APP_ID
   */
  key?: string;
  /**
   * The target environment of the environment variable
   *
   * @example preview
   */
  target?: ('production' | 'preview' | 'development')[];
  /**
   * If defined, the git branch of the environment variable (must have target=preview)
   *
   * @maxLength 250
   * @example feature-1
   */
  gitBranch?: string | null;
  /**
   * The type of environment variable
   *
   * @example plain
   */
  type?: 'system' | 'secret' | 'encrypted' | 'plain' | 'sensitive';
  /**
   * The value of the environment variable
   *
   * @example bkWIjbnxcvo78
   */
  value?: string;
  customEnvironmentIds?: string[];
  /**
   * A comment to add context on what this env var is for
   *
   * @example database connection string for production
   * @maxLength 500
   */
  comment?: string;
};

export type EditProjectEnvVariables = {
  body?: EditProjectEnvRequestBody;
  pathParams: EditProjectEnvPathParams;
  queryParams?: EditProjectEnvQueryParams;
} & FetcherExtraProps;

/**
 * Edit a specific environment variable for a given project by passing the environment variable identifier and either passing the project `id` or `name` in the URL.
 */
export const editProjectEnv = (variables: EditProjectEnvVariables, signal?: AbortSignal) =>
  fetch<
    EditProjectEnvResponse,
    EditProjectEnvError,
    EditProjectEnvRequestBody,
    {},
    EditProjectEnvQueryParams,
    EditProjectEnvPathParams
  >({ url: '/v9/projects/{idOrName}/env/{id}', method: 'patch', ...variables, signal });

export type UpdateProjectProtectionBypassPathParams = {
  /**
   * The unique project identifier or the project name
   */
  idOrName: string;
};

export type UpdateProjectProtectionBypassQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type UpdateProjectProtectionBypassError = Fetcher.ErrorWrapper<undefined>;

export type UpdateProjectProtectionBypassResponse = {
  protectionBypass?: {
    [key: string]: {
      createdAt: number;
      createdBy: string;
      scope: 'automation-bypass';
    };
  };
};

export type UpdateProjectProtectionBypassRequestBody = {
  /**
   * Optional instructions for revoking and regenerating a automation bypass
   */
  revoke?: {
    /**
     * Automation bypass to revoked
     */
    secret: string;
    /**
     * Whether or not a new automation bypass should be created after the provided secret is revoked
     */
    regenerate: boolean;
  };
};

export type UpdateProjectProtectionBypassVariables = {
  body?: UpdateProjectProtectionBypassRequestBody;
  pathParams: UpdateProjectProtectionBypassPathParams;
  queryParams?: UpdateProjectProtectionBypassQueryParams;
} & FetcherExtraProps;

/**
 * Update the deployment protection automation bypass for a project
 */
export const updateProjectProtectionBypass = (
  variables: UpdateProjectProtectionBypassVariables,
  signal?: AbortSignal
) =>
  fetch<
    UpdateProjectProtectionBypassResponse,
    UpdateProjectProtectionBypassError,
    UpdateProjectProtectionBypassRequestBody,
    {},
    UpdateProjectProtectionBypassQueryParams,
    UpdateProjectProtectionBypassPathParams
  >({ url: '/v1/projects/{idOrName}/protection-bypass', method: 'patch', ...variables, signal });

export type RequestPromotePathParams = {
  projectId: string;
  deploymentId: string;
};

export type RequestPromoteQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type RequestPromoteError = Fetcher.ErrorWrapper<undefined>;

export type RequestPromoteVariables = {
  pathParams: RequestPromotePathParams;
  queryParams?: RequestPromoteQueryParams;
} & FetcherExtraProps;

/**
 * Allows users to promote a deployment to production. Note: This does NOT rebuild the deployment. If you need that, then call create-deployments endpoint.
 */
export const requestPromote = (variables: RequestPromoteVariables, signal?: AbortSignal) =>
  fetch<undefined, RequestPromoteError, undefined, {}, RequestPromoteQueryParams, RequestPromotePathParams>({
    url: '/v10/projects/{projectId}/promote/{deploymentId}',
    method: 'post',
    ...variables,
    signal
  });

export type ListPromoteAliasesPathParams = {
  projectId: string;
};

export type ListPromoteAliasesQueryParams = {
  /**
   * Maximum number of aliases to list from a request (max 100).
   *
   * @example 20
   * @maximum 100
   */
  limit?: number;
  /**
   * Get aliases created after this epoch timestamp.
   *
   * @example 1609499532000
   */
  since?: number;
  /**
   * Get aliases created before this epoch timestamp.
   *
   * @example 1612264332000
   */
  until?: number;
  /**
   * Filter results down to aliases that failed to map to the requested deployment
   */
  failedOnly?: boolean;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type ListPromoteAliasesError = Fetcher.ErrorWrapper<undefined>;

export type ListPromoteAliasesVariables = {
  pathParams: ListPromoteAliasesPathParams;
  queryParams?: ListPromoteAliasesQueryParams;
} & FetcherExtraProps;

/**
 * Get a list of aliases related to the last promote request with their mapping status
 */
export const listPromoteAliases = (variables: ListPromoteAliasesVariables, signal?: AbortSignal) =>
  fetch<
    | Record<string, any>
    | {
        aliases: {
          status: string;
          alias: string;
          id: string;
        }[];
        pagination: Schemas.Pagination;
      },
    ListPromoteAliasesError,
    undefined,
    {},
    ListPromoteAliasesQueryParams,
    ListPromoteAliasesPathParams
  >({ url: '/v1/projects/{projectId}/promote/aliases', method: 'get', ...variables, signal });

export type PauseProjectPathParams = {
  /**
   * The unique project identifier
   */
  projectId: string;
};

export type PauseProjectQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type PauseProjectError = Fetcher.ErrorWrapper<undefined>;

export type PauseProjectVariables = {
  pathParams: PauseProjectPathParams;
  queryParams?: PauseProjectQueryParams;
} & FetcherExtraProps;

/**
 * Pause a project by passing its project `id` in the URL. If the project does not exist given the id then the request will fail with 400 status code. If the project disables auto assigning custom production domains and blocks the active Production Deployment then the request will return with 200 status code.
 */
export const pauseProject = (variables: PauseProjectVariables, signal?: AbortSignal) =>
  fetch<undefined, PauseProjectError, undefined, {}, PauseProjectQueryParams, PauseProjectPathParams>({
    url: '/v1/projects/{projectId}/pause',
    method: 'post',
    ...variables,
    signal
  });

export type UnpauseProjectPathParams = {
  /**
   * The unique project identifier
   */
  projectId: string;
};

export type UnpauseProjectQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type UnpauseProjectError = Fetcher.ErrorWrapper<undefined>;

export type UnpauseProjectVariables = {
  pathParams: UnpauseProjectPathParams;
  queryParams?: UnpauseProjectQueryParams;
} & FetcherExtraProps;

/**
 * Unpause a project by passing its project `id` in the URL. If the project does not exist given the id then the request will fail with 400 status code. If the project enables auto assigning custom production domains and unblocks the active Production Deployment then the request will return with 200 status code.
 */
export const unpauseProject = (variables: UnpauseProjectVariables, signal?: AbortSignal) =>
  fetch<undefined, UnpauseProjectError, undefined, {}, UnpauseProjectQueryParams, UnpauseProjectPathParams>({
    url: '/v1/projects/{projectId}/unpause',
    method: 'post',
    ...variables,
    signal
  });

export type GetTeamMembersQueryParams = {
  /**
   * Limit how many teams should be returned
   *
   * @example 20
   * @minimum 1
   */
  limit?: number;
  /**
   * Timestamp in milliseconds to only include members added since then.
   *
   * @example 1540095775951
   */
  since?: number;
  /**
   * Timestamp in milliseconds to only include members added until then.
   *
   * @example 1540095775951
   */
  until?: number;
  /**
   * Search team members by their name, username, and email.
   */
  search?: string;
  /**
   * Only return members with the specified team role.
   *
   * @example OWNER
   */
  role?: 'OWNER' | 'MEMBER' | 'DEVELOPER' | 'VIEWER' | 'BILLING' | 'CONTRIBUTOR';
  /**
   * Exclude members who belong to the specified project.
   */
  excludeProject?: string;
  /**
   * Include team members who are eligible to be members of the specified project.
   */
  eligibleMembersForProjectId?: string;
};

export type GetTeamMembersError = Fetcher.ErrorWrapper<undefined>;

export type GetTeamMembersResponse = {
  members: {
    /**
     * ID of the file for the Avatar of this member.
     *
     * @example 123a6c5209bc3778245d011443644c8d27dc2c50
     */
    avatar?: string;
    /**
     * Boolean that indicates if this member was confirmed by an owner.
     *
     * @example true
     */
    confirmed: boolean;
    /**
     * The email of this member.
     *
     * @example jane.doe@example.com
     */
    email: string;
    /**
     * Information about the GitHub account for this user.
     */
    github?: {
      login?: string;
    };
    /**
     * Information about the GitLab account of this user.
     */
    gitlab?: {
      login?: string;
    };
    /**
     * Information about the Bitbucket account of this user.
     */
    bitbucket?: {
      login?: string;
    };
    /**
     * Role of this user in the team.
     *
     * @example OWNER
     */
    role: 'OWNER' | 'MEMBER' | 'DEVELOPER' | 'BILLING' | 'VIEWER' | 'CONTRIBUTOR';
    /**
     * The ID of this user.
     *
     * @example zTuNVUXEAvvnNN3IaqinkyMw
     */
    uid: string;
    /**
     * The unique username of this user.
     *
     * @example jane-doe
     */
    username: string;
    /**
     * The name of this user.
     *
     * @example Jane Doe
     */
    name?: string;
    /**
     * Timestamp in milliseconds when this member was added.
     *
     * @example 1588720733602
     */
    createdAt: number;
    /**
     * Timestamp in milliseconds for when this team member was accepted by an owner.
     *
     * @example 1588820733602
     */
    accessRequestedAt?: number;
    /**
     * Map with information about the members origin if they joined by requesting access.
     */
    joinedFrom?: {
      origin:
        | 'teams'
        | 'link'
        | 'mail'
        | 'import'
        | 'github'
        | 'gitlab'
        | 'bitbucket'
        | 'saml'
        | 'dsync'
        | 'feedback'
        | 'organization-teams';
      commitId?: string;
      repoId?: string;
      repoPath?: string;
      gitUserId?: string | number;
      gitUserLogin?: string;
      ssoUserId?: string;
      ssoConnectedAt?: number;
      idpUserId?: string;
      dsyncUserId?: string;
      dsyncConnectedAt?: number;
    };
    /**
     * Array of project memberships
     */
    projects?: {
      name?: string;
      id?: string;
      role?: 'ADMIN' | 'PROJECT_DEVELOPER' | 'PROJECT_VIEWER';
    }[];
  }[];
  emailInviteCodes?: {
    accessGroups?: string[];
    id: string;
    email?: string;
    role?: 'OWNER' | 'MEMBER' | 'DEVELOPER' | 'BILLING' | 'VIEWER' | 'CONTRIBUTOR';
    isDSyncUser: boolean;
    createdAt?: number;
    expired?: boolean;
    projects?: {
      [key: string]: 'ADMIN' | 'PROJECT_DEVELOPER' | 'PROJECT_VIEWER';
    };
  }[];
  pagination: {
    hasNext: boolean;
    /**
     * Amount of items in the current page.
     *
     * @example 20
     */
    count: number;
    /**
     * Timestamp that must be used to request the next page.
     *
     * @example 1540095775951
     */
    next: number | null;
    /**
     * Timestamp that must be used to request the previous page.
     *
     * @example 1540095775951
     */
    prev: number | null;
  };
};

export type GetTeamMembersVariables = {
  queryParams?: GetTeamMembersQueryParams;
} & FetcherExtraProps;

/**
 * Get a paginated list of team members for the provided team.
 */
export const getTeamMembers = (variables: GetTeamMembersVariables, signal?: AbortSignal) =>
  fetch<GetTeamMembersResponse, GetTeamMembersError, undefined, {}, GetTeamMembersQueryParams, {}>({
    url: '/v2/teams/{teamId}/members',
    method: 'get',
    ...variables,
    signal
  });

export type InviteUserToTeamError = Fetcher.ErrorWrapper<undefined>;

export type InviteUserToTeamRequestBody = {
  /**
   * The id of the user to invite
   *
   * @example kr1PsOIzqEL5Xg6M4VZcZosf
   */
  uid?: string;
  /**
   * The email address of the user to invite
   *
   * @format email
   * @example john@example.com
   */
  email?: string;
  /**
   * The role of the user to invite
   *
   * @default MEMBER
   * @default VIEWER
   * @example MEMBER
   * @example VIEWER
   */
  role?: 'OWNER' | 'MEMBER' | 'DEVELOPER' | 'BILLING' | 'VIEWER' | 'CONTRIBUTOR';
  projects?: {
    /**
     * The ID of the project.
     *
     * @maxLength 64
     * @example prj_ndlgr43fadlPyCtREAqxxdyFK
     */
    projectId: string;
    /**
     * Sets the project roles for the invited user
     *
     * @example ADMIN
     */
    role: 'ADMIN' | 'PROJECT_VIEWER' | 'PROJECT_DEVELOPER';
  }[];
};

export type InviteUserToTeamVariables = {
  body?: InviteUserToTeamRequestBody;
} & FetcherExtraProps;

/**
 * Invite a user to join the team specified in the URL. The authenticated user needs to be an `OWNER` in order to successfully invoke this endpoint. The user can be specified with an email or an ID. If both email and ID are provided, ID will take priority.
 */
export const inviteUserToTeam = (variables: InviteUserToTeamVariables, signal?: AbortSignal) =>
  fetch<
    | {
        /**
         * The ID of the invited user
         *
         * @example kr1PsOIzqEL5Xg6M4VZcZosf
         */
        uid: string;
        /**
         * The username of the invited user
         *
         * @example john-doe
         */
        username: string;
        /**
         * The email of the invited user. Not included if the user was invited via their UID.
         *
         * @example john@user.co
         */
        email?: string;
        /**
         * The role used for the invitation
         *
         * @example MEMBER
         */
        role: 'OWNER' | 'MEMBER' | 'DEVELOPER' | 'BILLING' | 'VIEWER' | 'CONTRIBUTOR';
      }
    | {
        uid: string;
        username: string;
        role: 'OWNER' | 'MEMBER' | 'DEVELOPER' | 'BILLING' | 'VIEWER' | 'CONTRIBUTOR';
      },
    InviteUserToTeamError,
    InviteUserToTeamRequestBody,
    {},
    {},
    {}
  >({ url: '/v1/teams/{teamId}/members', method: 'post', ...variables, signal });

export type RequestAccessToTeamError = Fetcher.ErrorWrapper<undefined>;

export type RequestAccessToTeamResponse = {
  teamSlug: string;
  teamName: string;
  confirmed?: boolean;
  joinedFrom?: {
    origin:
      | 'import'
      | 'teams'
      | 'github'
      | 'gitlab'
      | 'bitbucket'
      | 'feedback'
      | 'organization-teams'
      | 'mail'
      | 'link'
      | 'saml'
      | 'dsync';
    commitId?: string;
    repoId?: string;
    repoPath?: string;
    gitUserId?: string | number;
    gitUserLogin?: string;
    ssoUserId?: string;
    ssoConnectedAt?: number;
    idpUserId?: string;
    dsyncUserId?: string;
    dsyncConnectedAt?: number;
  };
  accessRequestedAt?: number;
  github: {
    login?: string;
  } | null;
  gitlab: {
    login?: string;
  } | null;
  bitbucket: {
    login?: string;
  } | null;
};

export type RequestAccessToTeamRequestBody = {
  joinedFrom: {
    /**
     * The origin of the request.
     *
     * @example github
     */
    origin: 'import' | 'teams' | 'github' | 'gitlab' | 'bitbucket' | 'feedback' | 'organization-teams';
    /**
     * The commit sha if the origin is a git provider.
     *
     * @example f498d25d8bd654b578716203be73084b31130cd7
     */
    commitId?: string;
    /**
     * The ID of the repository for the given Git provider.
     *
     * @example 67753070
     */
    repoId?: string;
    /**
     * The path to the repository for the given Git provider.
     *
     * @example jane-doe/example
     */
    repoPath?: string;
    /**
     * The ID of the Git account of the user who requests access.
     *
     * @example 103053343
     */
    gitUserId?: string | number;
    /**
     * The login name for the Git account of the user who requests access.
     *
     * @example jane-doe
     */
    gitUserLogin?: string;
  };
};

export type RequestAccessToTeamVariables = {
  body: RequestAccessToTeamRequestBody;
} & FetcherExtraProps;

/**
 * Request access to a team as a member. An owner has to approve the request. Only 10 users can request access to a team at the same time.
 */
export const requestAccessToTeam = (variables: RequestAccessToTeamVariables, signal?: AbortSignal) =>
  fetch<RequestAccessToTeamResponse, RequestAccessToTeamError, RequestAccessToTeamRequestBody, {}, {}, {}>({
    url: '/v1/teams/{teamId}/request',
    method: 'post',
    ...variables,
    signal
  });

export type GetTeamAccessRequestPathParams = {
  userId?: string;
};

export type GetTeamAccessRequestError = Fetcher.ErrorWrapper<undefined>;

export type GetTeamAccessRequestResponse = {
  /**
   * The slug of the team.
   *
   * @example my-team
   */
  teamSlug: string;
  /**
   * The name of the team.
   *
   * @example My Team
   */
  teamName: string;
  /**
   * Current status of the membership. Will be `true` if confirmed, if pending it'll be `false`.
   *
   * @example false
   */
  confirmed: boolean;
  /**
   * A map that describes the origin from where the user joined.
   */
  joinedFrom: {
    origin:
      | 'mail'
      | 'link'
      | 'import'
      | 'teams'
      | 'github'
      | 'gitlab'
      | 'bitbucket'
      | 'saml'
      | 'dsync'
      | 'feedback'
      | 'organization-teams';
    commitId?: string;
    repoId?: string;
    repoPath?: string;
    gitUserId?: string | number;
    gitUserLogin?: string;
    ssoUserId?: string;
    ssoConnectedAt?: number;
    idpUserId?: string;
    dsyncUserId?: string;
    dsyncConnectedAt?: number;
  };
  /**
   * Timestamp in milliseconds when the user requested access to the team.
   *
   * @example 1588720733602
   */
  accessRequestedAt: number;
  /**
   * Map of the connected GitHub account.
   */
  github: {
    login?: string;
  } | null;
  /**
   * Map of the connected GitLab account.
   */
  gitlab: {
    login?: string;
  } | null;
  /**
   * Map of the connected Bitbucket account.
   */
  bitbucket: {
    login?: string;
  } | null;
};

export type GetTeamAccessRequestVariables = {
  pathParams?: GetTeamAccessRequestPathParams;
} & FetcherExtraProps;

/**
 * Check the status of a join request. It'll respond with a 404 if the request has been declined. If no `userId` path segment was provided, this endpoint will instead return the status of the authenticated user.
 */
export const getTeamAccessRequest = (variables: GetTeamAccessRequestVariables, signal?: AbortSignal) =>
  fetch<GetTeamAccessRequestResponse, GetTeamAccessRequestError, undefined, {}, {}, GetTeamAccessRequestPathParams>({
    url: '/v1/teams/{teamId}/request/{userId}',
    method: 'get',
    ...variables,
    signal
  });

export type JoinTeamError = Fetcher.ErrorWrapper<undefined>;

export type JoinTeamResponse = {
  /**
   * The ID of the team the user joined.
   *
   * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
   */
  teamId: string;
  /**
   * The slug of the team the user joined.
   *
   * @example my-team
   */
  slug: string;
  /**
   * The name of the team the user joined.
   *
   * @example My Team
   */
  name: string;
  /**
   * The origin of how the user joined.
   *
   * @example email
   */
  from: string;
};

export type JoinTeamRequestBody = {
  /**
   * The invite code to join the team.
   *
   * @example fisdh38aejkeivn34nslfore9vjtn4ls
   */
  inviteCode?: string;
};

export type JoinTeamVariables = {
  body?: JoinTeamRequestBody;
} & FetcherExtraProps;

/**
 * Join a team with a provided invite code or team ID.
 */
export const joinTeam = (variables: JoinTeamVariables, signal?: AbortSignal) =>
  fetch<JoinTeamResponse, JoinTeamError, JoinTeamRequestBody, {}, {}, {}>({
    url: '/v1/teams/{teamId}/members/teams/join',
    method: 'post',
    ...variables,
    signal
  });

export type UpdateTeamMemberPathParams = {
  /**
   * The ID of the member.
   *
   * @example ndfasllgPyCtREAqxxdyFKb
   */
  uid: string;
};

export type UpdateTeamMemberError = Fetcher.ErrorWrapper<undefined>;

export type UpdateTeamMemberResponse = {
  /**
   * ID of the team.
   */
  id: string;
};

export type UpdateTeamMemberRequestBody = {
  /**
   * Accept a user who requested access to the team.
   *
   * @example true
   */
  confirmed?: true;
  /**
   * The role in the team of the member.
   *
   * @default MEMBER
   * @default VIEWER
   * @example MEMBER
   * @example VIEWER
   */
  role?: string;
  projects?: {
    /**
     * The ID of the project.
     *
     * @maxLength 256
     * @example prj_ndlgr43fadlPyCtREAqxxdyFK
     */
    projectId: string;
    /**
     * The project role of the member that will be added. \"null\" will remove this project level role.
     *
     * @example ADMIN
     */
    role: 'ADMIN' | 'PROJECT_VIEWER' | 'PROJECT_DEVELOPER' | any | null;
  }[];
  joinedFrom?: {
    ssoUserId?: null;
  };
};

export type UpdateTeamMemberVariables = {
  body?: UpdateTeamMemberRequestBody;
  pathParams: UpdateTeamMemberPathParams;
} & FetcherExtraProps;

/**
 * Update the membership of a Team Member on the Team specified by `teamId`, such as changing the _role_ of the member, or confirming a request to join the Team for an unconfirmed member. The authenticated user must be an `OWNER` of the Team.
 */
export const updateTeamMember = (variables: UpdateTeamMemberVariables, signal?: AbortSignal) =>
  fetch<
    UpdateTeamMemberResponse,
    UpdateTeamMemberError,
    UpdateTeamMemberRequestBody,
    {},
    {},
    UpdateTeamMemberPathParams
  >({ url: '/v1/teams/{teamId}/members/{uid}', method: 'patch', ...variables, signal });

export type RemoveTeamMemberPathParams = {
  /**
   * The user ID of the member.
   *
   * @example ndlgr43fadlPyCtREAqxxdyFK
   */
  uid: string;
};

export type RemoveTeamMemberQueryParams = {
  /**
   * The ID of the team to set as the new default team for the Northstar user.
   *
   * @example team_nllPyCtREAqxxdyFKbbMDlxd
   */
  newDefaultTeamId?: string;
};

export type RemoveTeamMemberError = Fetcher.ErrorWrapper<undefined>;

export type RemoveTeamMemberResponse = {
  /**
   * ID of the team.
   */
  id: string;
};

export type RemoveTeamMemberVariables = {
  pathParams: RemoveTeamMemberPathParams;
  queryParams?: RemoveTeamMemberQueryParams;
} & FetcherExtraProps;

/**
 * Remove a Team Member from the Team, or dismiss a user that requested access, or leave a team.
 */
export const removeTeamMember = (variables: RemoveTeamMemberVariables, signal?: AbortSignal) =>
  fetch<
    RemoveTeamMemberResponse,
    RemoveTeamMemberError,
    undefined,
    {},
    RemoveTeamMemberQueryParams,
    RemoveTeamMemberPathParams
  >({ url: '/v1/teams/{teamId}/members/{uid}', method: 'delete', ...variables, signal });

export type GetTeamPathParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
};

export type GetTeamQueryParams = {
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetTeamError = Fetcher.ErrorWrapper<undefined>;

export type GetTeamVariables = {
  pathParams?: GetTeamPathParams;
  queryParams?: GetTeamQueryParams;
} & FetcherExtraProps;

/**
 * Get information for the Team specified by the `teamId` parameter.
 */
export const getTeam = (variables: GetTeamVariables, signal?: AbortSignal) =>
  fetch<Schemas.Team, GetTeamError, undefined, {}, GetTeamQueryParams, GetTeamPathParams>({
    url: '/v2/teams/{teamId}',
    method: 'get',
    ...variables,
    signal
  });

export type PatchTeamPathParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId: string;
};

export type PatchTeamQueryParams = {
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type PatchTeamError = Fetcher.ErrorWrapper<undefined>;

export type PatchTeamRequestBody = {
  /**
   * The hash value of an uploaded image.
   *
   * @format regex
   */
  avatar?: string;
  /**
   * A short text that describes the team.
   *
   * @maxLength 140
   * @example Our mission is to make cloud computing accessible to everyone
   */
  description?: string;
  /**
   * @format regex
   * @example example.com
   */
  emailDomain?: string | null;
  /**
   * The name of the team.
   *
   * @maxLength 256
   * @example My Team
   */
  name?: string;
  /**
   * Suffix that will be used for all preview deployments.
   *
   * @format hostname
   * @example example.dev
   */
  previewDeploymentSuffix?: string | null;
  /**
   * Create a new invite code and replace the current one.
   *
   * @example true
   */
  regenerateInviteCode?: boolean;
  saml?: {
    /**
     * Require that members of the team use SAML Single Sign-On.
     *
     * @example true
     */
    enforced?: boolean;
    /**
     * Directory groups to role or access group mappings.
     */
    roles?: {
      [key: string]:
        | ('OWNER' | 'MEMBER' | 'DEVELOPER' | 'BILLING' | 'VIEWER' | 'CONTRIBUTOR')
        | {
            /**
             * @pattern ^ag_[A-z0-9_ -]+$
             */
            accessGroupId: string;
          };
    };
  };
  /**
   * A new slug for the team.
   *
   * @example my-team
   */
  slug?: string;
  /**
   * Enable preview comments: one of on, off or default.
   *
   * @example on
   */
  enablePreviewFeedback?: string;
  /**
   * Sensitive environment variable policy: one of on, off or default.
   *
   * @example on
   */
  sensitiveEnvironmentVariablePolicy?: string;
  /**
   * Whether or not remote caching is enabled for the team
   */
  remoteCaching?: {
    /**
     * Enable or disable remote caching for the team.
     *
     * @example true
     */
    enabled?: boolean;
  };
  /**
   * Display or hide IP addresses in Monitoring queries.
   *
   * @example false
   */
  hideIpAddresses?: boolean;
};

export type PatchTeamVariables = {
  body?: PatchTeamRequestBody;
  pathParams: PatchTeamPathParams;
  queryParams?: PatchTeamQueryParams;
} & FetcherExtraProps;

/**
 * Update the information of a Team specified by the `teamId` parameter. The request body should contain the information that will be updated on the Team.
 */
export const patchTeam = (variables: PatchTeamVariables, signal?: AbortSignal) =>
  fetch<Schemas.Team, PatchTeamError, PatchTeamRequestBody, {}, PatchTeamQueryParams, PatchTeamPathParams>({
    url: '/v2/teams/{teamId}',
    method: 'patch',
    ...variables,
    signal
  });

export type GetTeamsQueryParams = {
  /**
   * Maximum number of Teams which may be returned.
   *
   * @example 20
   */
  limit?: number;
  /**
   * Timestamp (in milliseconds) to only include Teams created since then.
   *
   * @example 1540095775951
   */
  since?: number;
  /**
   * Timestamp (in milliseconds) to only include Teams created until then.
   *
   * @example 1540095775951
   */
  until?: number;
};

export type GetTeamsError = Fetcher.ErrorWrapper<undefined>;

export type GetTeamsResponse = {
  teams: (Schemas.Team | Schemas.TeamLimited)[];
  pagination: Schemas.Pagination;
};

export type GetTeamsVariables = {
  queryParams?: GetTeamsQueryParams;
} & FetcherExtraProps;

/**
 * Get a paginated list of all the Teams the authenticated User is a member of.
 */
export const getTeams = (variables: GetTeamsVariables, signal?: AbortSignal) =>
  fetch<GetTeamsResponse, GetTeamsError, undefined, {}, GetTeamsQueryParams, {}>({
    url: '/v2/teams',
    method: 'get',
    ...variables,
    signal
  });

export type CreateTeamError = Fetcher.ErrorWrapper<undefined>;

export type CreateTeamResponse = {
  /**
   * Id of the created team
   *
   * @example team_nLlpyC6RE1qxqglFKbrMxlud
   */
  id: string;
  slug: string;
  billing: {
    currency?: 'usd' | 'eur';
    cancelation?: number | null;
    period: {
      start: number;
      end: number;
    } | null;
    contract?: {
      start: number;
      end: number;
    } | null;
    plan: 'pro' | 'enterprise' | 'hobby';
    planIteration?: string;
    platform?: 'stripe' | 'stripeTestMode';
    orbCustomerId?: string;
    syncedAt?: number;
    programType?: 'startup' | 'agency';
    trial?: {
      start: number;
      end: number;
    } | null;
    email?: string | null;
    tax?: {
      type: string;
      id: string;
    } | null;
    language?: string | null;
    address?: {
      line1?: string;
      line2?: string;
      postalCode?: string;
      city?: string;
      country?: string;
      state?: string;
    } | null;
    name?: string | null;
    invoiceItems?: {
      /**
       * Will be used to create an invoice item. The price must be in cents: 2000 for $20.
       */
      pro?: {
        tier?: number;
        price: number;
        quantity: number;
        /**
         * The highest quantity in the current period. Used to render the correct enable/disable UI for add-ons.
         */
        highestQuantity?: number;
        name?: string;
        hidden: boolean;
        createdAt?: number;
        disabledAt?: number | null;
        frequency?: {
          interval: 'month';
          intervalCount: 2 | 1 | 3 | 6 | 12;
        };
        maxQuantity?: number;
      };
      /**
       * Will be used to create an invoice item. The price must be in cents: 2000 for $20.
       */
      enterprise?: {
        tier?: number;
        price: number;
        quantity: number;
        /**
         * The highest quantity in the current period. Used to render the correct enable/disable UI for add-ons.
         */
        highestQuantity?: number;
        name?: string;
        hidden: boolean;
        createdAt?: number;
        disabledAt?: number | null;
        frequency?: {
          interval: 'month';
          intervalCount: 2 | 1 | 3 | 6 | 12;
        };
        maxQuantity?: number;
      };
      /**
       * Will be used to create an invoice item. The price must be in cents: 2000 for $20.
       */
      analytics?: {
        tier?: number;
        price: number;
        quantity: number;
        /**
         * The highest quantity in the current period. Used to render the correct enable/disable UI for add-ons.
         */
        highestQuantity?: number;
        name?: string;
        hidden: boolean;
        createdAt?: number;
        disabledAt?: number | null;
        frequency?: {
          interval: 'month';
          intervalCount: 2 | 1 | 3 | 6 | 12;
        };
        maxQuantity?: number;
      };
      /**
       * Will be used to create an invoice item. The price must be in cents: 2000 for $20.
       */
      concurrentBuilds?: {
        tier?: number;
        price: number;
        quantity: number;
        /**
         * The highest quantity in the current period. Used to render the correct enable/disable UI for add-ons.
         */
        highestQuantity?: number;
        name?: string;
        hidden: boolean;
        createdAt?: number;
        disabledAt?: number | null;
        frequency?: {
          interval: 'month';
          intervalCount: 2 | 1 | 3 | 6 | 12;
        };
        maxQuantity?: number;
      };
      /**
       * Will be used to create an invoice item. The price must be in cents: 2000 for $20.
       */
      developerExperiencePlatform?: {
        tier?: number;
        price: number;
        quantity: number;
        /**
         * The highest quantity in the current period. Used to render the correct enable/disable UI for add-ons.
         */
        highestQuantity?: number;
        name?: string;
        hidden: boolean;
        createdAt?: number;
        disabledAt?: number | null;
        frequency?: {
          interval: 'month';
          intervalCount: 2 | 1 | 3 | 6 | 12;
        };
        maxQuantity?: number;
      };
      /**
       * Will be used to create an invoice item. The price must be in cents: 2000 for $20.
       */
      managedInfrastructureCommitment?: {
        tier?: number;
        price: number;
        quantity: number;
        /**
         * The highest quantity in the current period. Used to render the correct enable/disable UI for add-ons.
         */
        highestQuantity?: number;
        name?: string;
        hidden: boolean;
        createdAt?: number;
        disabledAt?: number | null;
        frequency?: {
          interval: 'month';
          intervalCount: 2 | 1 | 3 | 6 | 12;
        };
        maxQuantity?: number;
      };
      /**
       * Will be used to create an invoice item. The price must be in cents: 2000 for $20.
       */
      monitoring?: {
        tier?: number;
        price: number;
        quantity: number;
        /**
         * The highest quantity in the current period. Used to render the correct enable/disable UI for add-ons.
         */
        highestQuantity?: number;
        name?: string;
        hidden: boolean;
        createdAt?: number;
        disabledAt?: number | null;
        frequency?: {
          interval: 'month';
          intervalCount: 2 | 1 | 3 | 6 | 12;
        };
        maxQuantity?: number;
      };
      /**
       * Will be used to create an invoice item. The price must be in cents: 2000 for $20.
       */
      passwordProtection?: {
        tier?: number;
        price: number;
        quantity: number;
        /**
         * The highest quantity in the current period. Used to render the correct enable/disable UI for add-ons.
         */
        highestQuantity?: number;
        name?: string;
        hidden: boolean;
        createdAt?: number;
        disabledAt?: number | null;
        frequency?: {
          interval: 'month';
          intervalCount: 2 | 1 | 3 | 6 | 12;
        };
        maxQuantity?: number;
      };
      /**
       * Will be used to create an invoice item. The price must be in cents: 2000 for $20.
       */
      previewDeploymentSuffix?: {
        tier?: number;
        price: number;
        quantity: number;
        /**
         * The highest quantity in the current period. Used to render the correct enable/disable UI for add-ons.
         */
        highestQuantity?: number;
        name?: string;
        hidden: boolean;
        createdAt?: number;
        disabledAt?: number | null;
        frequency?: {
          interval: 'month';
          intervalCount: 2 | 1 | 3 | 6 | 12;
        };
        maxQuantity?: number;
      };
      /**
       * Will be used to create an invoice item. The price must be in cents: 2000 for $20.
       */
      saml?: {
        tier?: number;
        price: number;
        quantity: number;
        /**
         * The highest quantity in the current period. Used to render the correct enable/disable UI for add-ons.
         */
        highestQuantity?: number;
        name?: string;
        hidden: boolean;
        createdAt?: number;
        disabledAt?: number | null;
        frequency?: {
          interval: 'month';
          intervalCount: 2 | 1 | 3 | 6 | 12;
        };
        maxQuantity?: number;
      };
      /**
       * Will be used to create an invoice item. The price must be in cents: 2000 for $20.
       */
      teamSeats?: {
        tier?: number;
        price: number;
        quantity: number;
        /**
         * The highest quantity in the current period. Used to render the correct enable/disable UI for add-ons.
         */
        highestQuantity?: number;
        name?: string;
        hidden: boolean;
        createdAt?: number;
        disabledAt?: number | null;
        frequency?: {
          interval: 'month';
          intervalCount: 2 | 1 | 3 | 6 | 12;
        };
        maxQuantity?: number;
      };
      /**
       * Will be used to create an invoice item. The price must be in cents: 2000 for $20.
       */
      webAnalytics?: {
        tier?: number;
        price: number;
        quantity: number;
        /**
         * The highest quantity in the current period. Used to render the correct enable/disable UI for add-ons.
         */
        highestQuantity?: number;
        name?: string;
        hidden: boolean;
        createdAt?: number;
        disabledAt?: number | null;
        frequency?: {
          interval: 'month';
          intervalCount: 2 | 1 | 3 | 6 | 12;
        };
        maxQuantity?: number;
      };
      analyticsUsage?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      artifacts?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      bandwidth?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      blobStores?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      blobTotalAdvancedRequests?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      blobTotalAvgSizeInBytes?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      blobTotalGetResponseObjectSizeInBytes?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      blobTotalSimpleRequests?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      buildMinute?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      dataCacheRead?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      dataCacheRevalidation?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      dataCacheWrite?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      edgeConfigRead?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      edgeConfigWrite?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      edgeFunctionExecutionUnits?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      edgeMiddlewareInvocations?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      edgeRequest?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      edgeRequestAdditionalCpuDuration?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      fastDataTransfer?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      fastOriginTransfer?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      functionDuration?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      functionInvocation?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      logDrainsVolume?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      monitoringMetric?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      postgresComputeTime?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      postgresDataStorage?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      postgresDataTransfer?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      postgresDatabase?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      postgresWrittenData?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      serverlessFunctionExecution?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      sourceImages?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      storageRedisTotalBandwidthInBytes?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      storageRedisTotalCommands?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      storageRedisTotalDailyAvgStorageInBytes?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      storageRedisTotalDatabases?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      wafOwaspExcessBytes?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      wafOwaspRequests?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
      webAnalyticsEvent?: {
        matrix?: {
          defaultUnitPrice: string;
          dimensionPrices: {
            [key: string]: string;
          };
        };
        tier?: number;
        price: number;
        batch: number;
        threshold: number;
        name?: string;
        hidden: boolean;
        disabledAt?: number | null;
        enabledAt?: number | null;
      };
    } | null;
    invoiceSettings?: {
      footer?: string;
    };
    subscriptions?:
      | {
          id: string;
          trial: {
            start: number;
            end: number;
          } | null;
          period: {
            start: number;
            end: number;
          };
          frequency: {
            interval: 'month' | 'day' | 'week' | 'year';
            intervalCount: number;
          };
          discount: {
            id: string;
            coupon: {
              id: string;
              name: string | null;
              amountOff: number | null;
              percentageOff: number | null;
              durationInMonths: number | null;
              duration: 'forever' | 'repeating' | 'once';
            };
          } | null;
          items: {
            id: string;
            priceId: string;
            productId: string;
            amount: number;
            quantity: number;
          }[];
        }[]
      | null;
    controls?: {
      analyticsSampleRateInPercent?: number | null;
      analyticsSpendLimitInDollars?: number | null;
    } | null;
    purchaseOrder?: string | null;
    status?: 'active' | 'trialing' | 'overdue' | 'expired' | 'canceled';
    pricingExperiment?: 'august-2022';
    orbMigrationScheduledAt?: number | null;
    forceOrbMigration?: boolean | null;
  };
};

export type CreateTeamRequestBody = {
  /**
   * The desired slug for the Team
   *
   * @example a-random-team
   * @maxLength 48
   */
  slug: string;
  /**
   * The desired name for the Team. It will be generated from the provided slug if nothing is provided
   *
   * @example A Random Team
   * @maxLength 256
   */
  name?: string;
  /**
   * Attribution information for the session or current page
   */
  attribution?: {
    /**
     * Session referrer
     */
    sessionReferrer?: string;
    /**
     * Session landing page
     */
    landingPage?: string;
    /**
     * Referrer to the signup page
     */
    pageBeforeConversionPage?: string;
    utm?: {
      /**
       * UTM source
       */
      utmSource?: string;
      /**
       * UTM medium
       */
      utmMedium?: string;
      /**
       * UTM campaign
       */
      utmCampaign?: string;
      /**
       * UTM term
       */
      utmTerm?: string;
    };
  };
};

export type CreateTeamVariables = {
  body: CreateTeamRequestBody;
} & FetcherExtraProps;

/**
 * Create a new Team under your account. You need to send a POST request with the desired Team slug, and optionally the Team name.
 */
export const createTeam = (variables: CreateTeamVariables, signal?: AbortSignal) =>
  fetch<CreateTeamResponse, CreateTeamError, CreateTeamRequestBody, {}, {}, {}>({
    url: '/v1/teams',
    method: 'post',
    ...variables,
    signal
  });

export type DeleteTeamPathParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId: string;
};

export type DeleteTeamQueryParams = {
  /**
   * Id of the team to be set as the new default team
   *
   * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
   */
  newDefaultTeamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type DeleteTeamError = Fetcher.ErrorWrapper<undefined>;

export type DeleteTeamResponse = {
  /**
   * The ID of the deleted Team
   *
   * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
   */
  id: string;
  /**
   * Signifies whether the default team update has failed, when newDefaultTeamId is provided in request query.
   *
   * @example true
   */
  newDefaultTeamIdError?: boolean;
};

export type DeleteTeamRequestBody = {
  /**
   * Optional array of objects that describe the reason why the team is being deleted.
   */
  reasons?: {
    /**
     * Idenitifier slug of the reason why the team is being deleted.
     */
    slug: string;
    /**
     * Description of the reason why the team is being deleted.
     */
    description: string;
  }[];
};

export type DeleteTeamVariables = {
  body?: DeleteTeamRequestBody;
  pathParams: DeleteTeamPathParams;
  queryParams?: DeleteTeamQueryParams;
} & FetcherExtraProps;

/**
 * Delete a team under your account. You need to send a `DELETE` request with the desired team `id`. An optional array of reasons for deletion may also be sent.
 */
export const deleteTeam = (variables: DeleteTeamVariables, signal?: AbortSignal) =>
  fetch<DeleteTeamResponse, DeleteTeamError, DeleteTeamRequestBody, {}, DeleteTeamQueryParams, DeleteTeamPathParams>({
    url: '/v1/teams/{teamId}',
    method: 'delete',
    ...variables,
    signal
  });

export type DeleteTeamInviteCodePathParams = {
  /**
   * The Team invite code ID.
   *
   * @example 2wn2hudbr4chb1ecywo9dvzo7g9sscs6mzcz8htdde0txyom4l
   */
  inviteId: string;
};

export type DeleteTeamInviteCodeError = Fetcher.ErrorWrapper<undefined>;

export type DeleteTeamInviteCodeResponse = {
  /**
   * ID of the team.
   */
  id: string;
};

export type DeleteTeamInviteCodeVariables = {
  pathParams: DeleteTeamInviteCodePathParams;
} & FetcherExtraProps;

/**
 * Delete an active Team invite code.
 */
export const deleteTeamInviteCode = (variables: DeleteTeamInviteCodeVariables, signal?: AbortSignal) =>
  fetch<DeleteTeamInviteCodeResponse, DeleteTeamInviteCodeError, undefined, {}, {}, DeleteTeamInviteCodePathParams>({
    url: '/v1/teams/{teamId}/invites/{inviteId}',
    method: 'delete',
    ...variables,
    signal
  });

export type UploadFileQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type UploadFileHeaders = {
  /**
   * The file size in bytes
   */
  ['Content-Length']?: number;
  /**
   * The file SHA1 used to check the integrity
   *
   * @maxLength 40
   */
  ['x-vercel-digest']?: string;
  /**
   * The file SHA1 used to check the integrity
   *
   * @deprecated true
   * @maxLength 40
   */
  ['x-now-digest']?: string;
  /**
   * The file size as an alternative to `Content-Length`
   *
   * @deprecated true
   */
  ['x-now-size']?: number;
};

export type UploadFileError = Fetcher.ErrorWrapper<undefined>;

export type UploadFileVariables = {
  headers?: UploadFileHeaders;
  queryParams?: UploadFileQueryParams;
} & FetcherExtraProps;

/**
 * Before you create a deployment you need to upload the required files for that deployment. To do it, you need to first upload each file to this endpoint. Once that's completed, you can create a new deployment with the uploaded files. The file content must be placed inside the body of the request. In the case of a successful response you'll receive a status code 200 with an empty body.
 */
export const uploadFile = (variables: UploadFileVariables, signal?: AbortSignal) =>
  fetch<
    | {
        /**
         * Array of URLs where the file was updated
         *
         * @example example-upload.aws.com
         */
        urls: string[];
      }
    | Record<string, any>,
    UploadFileError,
    undefined,
    UploadFileHeaders,
    UploadFileQueryParams,
    {}
  >({ url: '/v2/files', method: 'post', ...variables, signal });

export type GetAuthUserError = Fetcher.ErrorWrapper<undefined>;

export type GetAuthUserResponse = {
  user: Schemas.AuthUser | Schemas.AuthUserLimited;
};

export type GetAuthUserVariables = FetcherExtraProps;

/**
 * Retrieves information related to the currently authenticated User.
 */
export const getAuthUser = (variables: GetAuthUserVariables, signal?: AbortSignal) =>
  fetch<GetAuthUserResponse, GetAuthUserError, undefined, {}, {}, {}>({
    url: '/v2/user',
    method: 'get',
    ...variables,
    signal
  });

export type RequestDeleteError = Fetcher.ErrorWrapper<undefined>;

export type RequestDeleteResponse = {
  /**
   * Unique identifier of the User who has initiated deletion.
   */
  id: string;
  /**
   * Email address of the User who has initiated deletion.
   */
  email: string;
  /**
   * User deletion progress status.
   *
   * @example Verification email sent
   */
  message: string;
};

export type RequestDeleteRequestBody = {
  /**
   * Optional array of objects that describe the reason why the User account is being deleted.
   */
  reasons?: {
    /**
     * Idenitifier slug of the reason why the User account is being deleted.
     */
    slug: string;
    /**
     * Description of the reason why the User account is being deleted.
     */
    description: string;
  }[];
};

export type RequestDeleteVariables = {
  body?: RequestDeleteRequestBody;
} & FetcherExtraProps;

/**
 * Initiates the deletion process for the currently authenticated User, by sending a deletion confirmation email. The email contains a link that the user needs to visit in order to proceed with the deletion process.
 */
export const requestDelete = (variables: RequestDeleteVariables, signal?: AbortSignal) =>
  fetch<RequestDeleteResponse, RequestDeleteError, RequestDeleteRequestBody, {}, {}, {}>({
    url: '/v1/user',
    method: 'delete',
    ...variables,
    signal
  });

export type ListAuthTokensError = Fetcher.ErrorWrapper<undefined>;

export type ListAuthTokensResponse = {
  tokens: Schemas.AuthToken[];
  testingToken?: Schemas.AuthToken;
  pagination: Schemas.Pagination;
};

export type ListAuthTokensVariables = FetcherExtraProps;

/**
 * Retrieve a list of the current User's authentication tokens.
 */
export const listAuthTokens = (variables: ListAuthTokensVariables, signal?: AbortSignal) =>
  fetch<ListAuthTokensResponse, ListAuthTokensError, undefined, {}, {}, {}>({
    url: '/v5/user/tokens',
    method: 'get',
    ...variables,
    signal
  });

export type CreateAuthTokenQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type CreateAuthTokenError = Fetcher.ErrorWrapper<undefined>;

export type CreateAuthTokenResponse = {
  token: Schemas.AuthToken;
  /**
   * The authentication token's actual value. This token is only provided in this response, and can never be retrieved again in the future. Be sure to save it somewhere safe!
   *
   * @example uRKJSTt0L4RaSkiMj41QTkxM
   */
  bearerToken: string;
};

export type CreateAuthTokenVariables = {
  body?:
    | {
        name: string;
        expiresAt?: number;
      }
    | {
        type: 'oauth2-token';
        name: string;
        clientId?: string;
        installationId?: string;
        expiresAt?: number;
      };
  queryParams?: CreateAuthTokenQueryParams;
} & FetcherExtraProps;

/**
 * Creates and returns a new authentication token for the currently authenticated User. The `bearerToken` property is only provided once, in the response body, so be sure to save it on the client for use with API requests.
 */
export const createAuthToken = (variables: CreateAuthTokenVariables, signal?: AbortSignal) =>
  fetch<
    CreateAuthTokenResponse,
    CreateAuthTokenError,
    | {
        name: string;
        expiresAt?: number;
      }
    | {
        type: 'oauth2-token';
        name: string;
        clientId?: string;
        installationId?: string;
        expiresAt?: number;
      },
    {},
    CreateAuthTokenQueryParams,
    {}
  >({ url: '/v3/user/tokens', method: 'post', ...variables, signal });

export type GetAuthTokenPathParams = {
  /**
   * The identifier of the token to retrieve. The special value \"current\" may be supplied, which returns the metadata for the token that the current HTTP request is authenticated with.
   *
   * @example 5d9f2ebd38ddca62e5d51e9c1704c72530bdc8bfdd41e782a6687c48399e8391
   */
  tokenId: string;
};

export type GetAuthTokenError = Fetcher.ErrorWrapper<undefined>;

export type GetAuthTokenResponse = {
  token: Schemas.AuthToken;
};

export type GetAuthTokenVariables = {
  pathParams: GetAuthTokenPathParams;
} & FetcherExtraProps;

/**
 * Retrieve metadata about an authentication token belonging to the currently authenticated User.
 */
export const getAuthToken = (variables: GetAuthTokenVariables, signal?: AbortSignal) =>
  fetch<GetAuthTokenResponse, GetAuthTokenError, undefined, {}, {}, GetAuthTokenPathParams>({
    url: '/v5/user/tokens/{tokenId}',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteAuthTokenPathParams = {
  /**
   * The identifier of the token to invalidate. The special value \"current\" may be supplied, which invalidates the token that the HTTP request was authenticated with.
   *
   * @example 5d9f2ebd38ddca62e5d51e9c1704c72530bdc8bfdd41e782a6687c48399e8391
   */
  tokenId: string;
};

export type DeleteAuthTokenError = Fetcher.ErrorWrapper<undefined>;

export type DeleteAuthTokenResponse = {
  /**
   * The unique identifier of the token that was deleted.
   *
   * @example 5d9f2ebd38ddca62e5d51e9c1704c72530bdc8bfdd41e782a6687c48399e8391
   */
  tokenId: string;
};

export type DeleteAuthTokenVariables = {
  pathParams: DeleteAuthTokenPathParams;
} & FetcherExtraProps;

/**
 * Invalidate an authentication token, such that it will no longer be valid for future HTTP requests.
 */
export const deleteAuthToken = (variables: DeleteAuthTokenVariables, signal?: AbortSignal) =>
  fetch<DeleteAuthTokenResponse, DeleteAuthTokenError, undefined, {}, {}, DeleteAuthTokenPathParams>({
    url: '/v3/user/tokens/{tokenId}',
    method: 'delete',
    ...variables,
    signal
  });

export type CreateWebhookQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type CreateWebhookError = Fetcher.ErrorWrapper<undefined>;

export type CreateWebhookResponse = {
  /**
   * The webhook secret used to sign the payload
   */
  secret: string;
  /**
   * The webhooks events
   *
   * @example deployment.created
   */
  events: (
    | 'budget.reached'
    | 'budget.reset'
    | 'domain.created'
    | 'deployment.created'
    | 'deployment.error'
    | 'deployment.canceled'
    | 'deployment.succeeded'
    | 'deployment.ready'
    | 'deployment.check-rerequested'
    | 'integration-configuration.permission-upgraded'
    | 'integration-configuration.removed'
    | 'integration-configuration.scope-change-confirmed'
    | 'project.created'
    | 'project.removed'
    | 'deployment-checks-completed'
    | 'deployment-ready'
    | 'deployment-prepared'
    | 'deployment-error'
    | 'deployment-check-rerequested'
    | 'deployment-canceled'
    | 'project-created'
    | 'project-removed'
    | 'domain-created'
    | 'deployment'
    | 'integration-configuration-permission-updated'
    | 'integration-configuration-removed'
    | 'integration-configuration-scope-change-confirmed'
    | 'marketplace.invoice.created'
    | 'marketplace.invoice.paid'
    | 'marketplace.invoice.notpaid'
    | 'test-webhook'
  )[];
  /**
   * The webhook id
   *
   * @example account_hook_GflD6EYyo7F4ViYS
   */
  id: string;
  /**
   * A string with the URL of the webhook
   *
   * @example https://my-webhook.com
   */
  url: string;
  /**
   * The unique ID of the team the webhook belongs to
   *
   * @example ZspSRT4ljIEEmMHgoDwKWDei
   */
  ownerId: string;
  /**
   * A number containing the date when the webhook was created in in milliseconds
   *
   * @example 1567024758130
   */
  createdAt: number;
  /**
   * A number containing the date when the webhook was updated in in milliseconds
   *
   * @example 1567024758130
   */
  updatedAt: number;
  /**
   * The ID of the projects the webhook is associated with
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectIds?: string[];
};

export type CreateWebhookRequestBody = {
  /**
   * @format uri
   * @pattern ^https?://
   */
  url: string;
  /**
   * @minItems 1
   */
  events: (
    | 'budget.reached'
    | 'budget.reset'
    | 'domain.created'
    | 'deployment.created'
    | 'deployment.error'
    | 'deployment.canceled'
    | 'deployment.succeeded'
    | 'deployment.ready'
    | 'deployment.check-rerequested'
    | 'integration-configuration.permission-upgraded'
    | 'integration-configuration.removed'
    | 'integration-configuration.scope-change-confirmed'
    | 'project.created'
    | 'project.removed'
    | 'deployment-checks-completed'
    | 'deployment-ready'
    | 'deployment-prepared'
    | 'deployment-error'
    | 'deployment-check-rerequested'
    | 'deployment-canceled'
    | 'project-created'
    | 'project-removed'
    | 'domain-created'
    | 'deployment'
    | 'integration-configuration-permission-updated'
    | 'integration-configuration-removed'
    | 'integration-configuration-scope-change-confirmed'
    | 'marketplace.invoice.created'
    | 'marketplace.invoice.paid'
    | 'marketplace.invoice.notpaid'
    | 'test-webhook'
  )[];
  /**
   * @minItems 1
   * @maxItems 50
   */
  projectIds?: string[];
};

export type CreateWebhookVariables = {
  body: CreateWebhookRequestBody;
  queryParams?: CreateWebhookQueryParams;
} & FetcherExtraProps;

/**
 * Creates a webhook
 */
export const createWebhook = (variables: CreateWebhookVariables, signal?: AbortSignal) =>
  fetch<CreateWebhookResponse, CreateWebhookError, CreateWebhookRequestBody, {}, CreateWebhookQueryParams, {}>({
    url: '/v1/webhooks',
    method: 'post',
    ...variables,
    signal
  });

export type GetWebhooksQueryParams = {
  /**
   * @pattern ^[a-zA-z0-9_]+$
   */
  projectId?: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetWebhooksError = Fetcher.ErrorWrapper<undefined>;

export type GetWebhooksVariables = {
  queryParams?: GetWebhooksQueryParams;
} & FetcherExtraProps;

/**
 * Get a list of webhooks
 */
export const getWebhooks = (variables: GetWebhooksVariables, signal?: AbortSignal) =>
  fetch<
    | {
        projectsMetadata:
          | {
              id: string;
              name: string;
              framework?:
                | 'blitzjs'
                | 'nextjs'
                | 'gatsby'
                | 'remix'
                | 'astro'
                | 'hexo'
                | 'eleventy'
                | 'docusaurus-2'
                | 'docusaurus'
                | 'preact'
                | 'solidstart-1'
                | 'solidstart'
                | 'dojo'
                | 'ember'
                | 'vue'
                | 'scully'
                | 'ionic-angular'
                | 'angular'
                | 'polymer'
                | 'svelte'
                | 'sveltekit'
                | 'sveltekit-1'
                | 'ionic-react'
                | 'create-react-app'
                | 'gridsome'
                | 'umijs'
                | 'sapper'
                | 'saber'
                | 'stencil'
                | 'nuxtjs'
                | 'redwoodjs'
                | 'hugo'
                | 'jekyll'
                | 'brunch'
                | 'middleman'
                | 'zola'
                | 'hydrogen'
                | 'vite'
                | 'vitepress'
                | 'vuepress'
                | 'parcel'
                | 'sanity'
                | 'storybook'
                | null;
              latestDeployment?: string;
            }[]
          | null;
        /**
         * The webhooks events
         *
         * @example deployment.created
         */
        events: (
          | 'budget.reached'
          | 'budget.reset'
          | 'domain.created'
          | 'deployment.created'
          | 'deployment.error'
          | 'deployment.canceled'
          | 'deployment.succeeded'
          | 'deployment.ready'
          | 'deployment.check-rerequested'
          | 'integration-configuration.permission-upgraded'
          | 'integration-configuration.removed'
          | 'integration-configuration.scope-change-confirmed'
          | 'project.created'
          | 'project.removed'
          | 'deployment-checks-completed'
          | 'deployment-ready'
          | 'deployment-prepared'
          | 'deployment-error'
          | 'deployment-check-rerequested'
          | 'deployment-canceled'
          | 'project-created'
          | 'project-removed'
          | 'domain-created'
          | 'deployment'
          | 'integration-configuration-permission-updated'
          | 'integration-configuration-removed'
          | 'integration-configuration-scope-change-confirmed'
          | 'marketplace.invoice.created'
          | 'marketplace.invoice.paid'
          | 'marketplace.invoice.notpaid'
          | 'test-webhook'
        )[];
        /**
         * The webhook id
         *
         * @example account_hook_GflD6EYyo7F4ViYS
         */
        id: string;
        /**
         * A string with the URL of the webhook
         *
         * @example https://my-webhook.com
         */
        url: string;
        /**
         * The unique ID of the team the webhook belongs to
         *
         * @example ZspSRT4ljIEEmMHgoDwKWDei
         */
        ownerId: string;
        /**
         * A number containing the date when the webhook was created in in milliseconds
         *
         * @example 1567024758130
         */
        createdAt: number;
        /**
         * A number containing the date when the webhook was updated in in milliseconds
         *
         * @example 1567024758130
         */
        updatedAt: number;
        /**
         * The ID of the projects the webhook is associated with
         *
         * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
         */
        projectIds?: string[];
      }[]
    | {
        /**
         * The webhooks events
         *
         * @example deployment.created
         */
        events: (
          | 'budget.reached'
          | 'budget.reset'
          | 'domain.created'
          | 'deployment.created'
          | 'deployment.error'
          | 'deployment.canceled'
          | 'deployment.succeeded'
          | 'deployment.ready'
          | 'deployment.check-rerequested'
          | 'integration-configuration.permission-upgraded'
          | 'integration-configuration.removed'
          | 'integration-configuration.scope-change-confirmed'
          | 'project.created'
          | 'project.removed'
          | 'deployment-checks-completed'
          | 'deployment-ready'
          | 'deployment-prepared'
          | 'deployment-error'
          | 'deployment-check-rerequested'
          | 'deployment-canceled'
          | 'project-created'
          | 'project-removed'
          | 'domain-created'
          | 'deployment'
          | 'integration-configuration-permission-updated'
          | 'integration-configuration-removed'
          | 'integration-configuration-scope-change-confirmed'
          | 'marketplace.invoice.created'
          | 'marketplace.invoice.paid'
          | 'marketplace.invoice.notpaid'
          | 'test-webhook'
        )[];
        /**
         * The webhook id
         *
         * @example account_hook_GflD6EYyo7F4ViYS
         */
        id: string;
        /**
         * A string with the URL of the webhook
         *
         * @example https://my-webhook.com
         */
        url: string;
        /**
         * The unique ID of the team the webhook belongs to
         *
         * @example ZspSRT4ljIEEmMHgoDwKWDei
         */
        ownerId: string;
        /**
         * A number containing the date when the webhook was created in in milliseconds
         *
         * @example 1567024758130
         */
        createdAt: number;
        /**
         * A number containing the date when the webhook was updated in in milliseconds
         *
         * @example 1567024758130
         */
        updatedAt: number;
        /**
         * The ID of the projects the webhook is associated with
         *
         * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
         */
        projectIds?: string[];
      }[],
    GetWebhooksError,
    undefined,
    {},
    GetWebhooksQueryParams,
    {}
  >({ url: '/v1/webhooks', method: 'get', ...variables, signal });

export type GetWebhookPathParams = {
  id: string;
};

export type GetWebhookQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetWebhookError = Fetcher.ErrorWrapper<undefined>;

export type GetWebhookResponse = {
  /**
   * The webhooks events
   *
   * @example deployment.created
   */
  events: (
    | 'budget.reached'
    | 'budget.reset'
    | 'domain.created'
    | 'deployment.created'
    | 'deployment.error'
    | 'deployment.canceled'
    | 'deployment.succeeded'
    | 'deployment.ready'
    | 'deployment.check-rerequested'
    | 'integration-configuration.permission-upgraded'
    | 'integration-configuration.removed'
    | 'integration-configuration.scope-change-confirmed'
    | 'project.created'
    | 'project.removed'
    | 'deployment-checks-completed'
    | 'deployment-ready'
    | 'deployment-prepared'
    | 'deployment-error'
    | 'deployment-check-rerequested'
    | 'deployment-canceled'
    | 'project-created'
    | 'project-removed'
    | 'domain-created'
    | 'deployment'
    | 'integration-configuration-permission-updated'
    | 'integration-configuration-removed'
    | 'integration-configuration-scope-change-confirmed'
    | 'marketplace.invoice.created'
    | 'marketplace.invoice.paid'
    | 'marketplace.invoice.notpaid'
    | 'test-webhook'
  )[];
  /**
   * The webhook id
   *
   * @example account_hook_GflD6EYyo7F4ViYS
   */
  id: string;
  /**
   * A string with the URL of the webhook
   *
   * @example https://my-webhook.com
   */
  url: string;
  /**
   * The unique ID of the team the webhook belongs to
   *
   * @example ZspSRT4ljIEEmMHgoDwKWDei
   */
  ownerId: string;
  /**
   * A number containing the date when the webhook was created in in milliseconds
   *
   * @example 1567024758130
   */
  createdAt: number;
  /**
   * A number containing the date when the webhook was updated in in milliseconds
   *
   * @example 1567024758130
   */
  updatedAt: number;
  /**
   * The ID of the projects the webhook is associated with
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectIds?: string[];
};

export type GetWebhookVariables = {
  pathParams: GetWebhookPathParams;
  queryParams?: GetWebhookQueryParams;
} & FetcherExtraProps;

/**
 * Get a webhook
 */
export const getWebhook = (variables: GetWebhookVariables, signal?: AbortSignal) =>
  fetch<GetWebhookResponse, GetWebhookError, undefined, {}, GetWebhookQueryParams, GetWebhookPathParams>({
    url: '/v1/webhooks/{id}',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteWebhookPathParams = {
  id: string;
};

export type DeleteWebhookQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type DeleteWebhookError = Fetcher.ErrorWrapper<undefined>;

export type DeleteWebhookVariables = {
  pathParams: DeleteWebhookPathParams;
  queryParams?: DeleteWebhookQueryParams;
} & FetcherExtraProps;

/**
 * Deletes a webhook
 */
export const deleteWebhook = (variables: DeleteWebhookVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteWebhookError, undefined, {}, DeleteWebhookQueryParams, DeleteWebhookPathParams>({
    url: '/v1/webhooks/{id}',
    method: 'delete',
    ...variables,
    signal
  });

export type ListAliasesQueryParams = {
  /**
   * Get only aliases of the given domain name
   *
   * @example my-test-domain.com
   * @maxItems 20
   */
  domain?: string[] | string;
  /**
   * Get only aliases created after the provided timestamp
   *
   * @deprecated true
   * @example 1540095775951
   */
  from?: number;
  /**
   * Maximum number of aliases to list from a request
   *
   * @example 10
   */
  limit?: number;
  /**
   * Filter aliases from the given `projectId`
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectId?: string;
  /**
   * Get aliases created after this JavaScript timestamp
   *
   * @example 1540095775941
   */
  since?: number;
  /**
   * Get aliases created before this JavaScript timestamp
   *
   * @example 1540095775951
   */
  until?: number;
  /**
   * Get aliases that would be rolled back for the given deployment
   *
   * @example dpl_XXX
   */
  rollbackDeploymentId?: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type ListAliasesError = Fetcher.ErrorWrapper<undefined>;

export type ListAliasesResponse = {
  aliases: {
    /**
     * The alias name, it could be a `.vercel.app` subdomain or a custom domain
     *
     * @example my-alias.vercel.app
     */
    alias: string;
    /**
     * The date when the alias was created
     *
     * @format date-time
     * @example 2017-04-26T23:00:34.232Z
     */
    created: string;
    /**
     * The date when the alias was created in milliseconds since the UNIX epoch
     *
     * @example 1540095775941
     */
    createdAt?: number;
    /**
     * Information of the user who created the alias
     */
    creator?: {
      /**
       * ID of the user who created the alias
       *
       * @example 96SnxkFiMyVKsK3pnoHfx3Hz
       */
      uid: string;
      /**
       * Email of the user who created the alias
       *
       * @example john-doe@gmail.com
       */
      email: string;
      /**
       * Username of the user who created the alias
       *
       * @example john-doe
       */
      username: string;
    };
    /**
     * The date when the alias was deleted in milliseconds since the UNIX epoch
     *
     * @example 1540095775941
     */
    deletedAt?: number;
    /**
     * A map with the deployment ID, URL and metadata
     */
    deployment?: {
      /**
       * The deployment unique identifier
       *
       * @example dpl_5m8CQaRBm3FnWRW1od3wKTpaECPx
       */
      id: string;
      /**
       * The deployment unique URL
       *
       * @example my-instant-deployment-3ij3cxz9qr.now.sh
       */
      url: string;
      /**
       * The deployment metadata
       *
       * @example {}
       */
      meta?: string;
    };
    /**
     * The deployment ID
     *
     * @example dpl_5m8CQaRBm3FnWRW1od3wKTpaECPx
     */
    deploymentId: string | null;
    /**
     * The unique identifier of the project
     *
     * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
     */
    projectId: string | null;
    /**
     * Target destination domain for redirect when the alias is a redirect
     */
    redirect?: string | null;
    /**
     * Status code to be used on redirect
     */
    redirectStatusCode?: 301 | 302 | 307 | 308 | null;
    /**
     * The unique identifier of the alias
     */
    uid: string;
    /**
     * The date when the alias was updated in milliseconds since the UNIX epoch
     *
     * @example 1540095775941
     */
    updatedAt?: number;
    /**
     * The protection bypass for the alias
     */
    protectionBypass?: {
      [key: string]:
        | {
            createdAt: number;
            createdBy: string;
            scope: 'shareable-link';
          }
        | {
            createdAt: number;
            lastUpdatedAt: number;
            lastUpdatedBy: string;
            access: 'requested' | 'granted';
            scope: 'user';
          }
        | {
            createdAt: number;
            createdBy: string;
            scope: 'alias-protection-override';
          }
        | {
            createdAt: number;
            lastUpdatedAt: number;
            lastUpdatedBy: string;
            scope: 'email_invite';
          };
    };
  }[];
  pagination: Schemas.Pagination;
};

export type ListAliasesVariables = {
  queryParams?: ListAliasesQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of aliases for the authenticated User or Team. When `domain` is provided, only aliases for that domain will be returned. When `projectId` is provided, it will only return the given project aliases.
 */
export const listAliases = (variables: ListAliasesVariables, signal?: AbortSignal) =>
  fetch<ListAliasesResponse, ListAliasesError, undefined, {}, ListAliasesQueryParams, {}>({
    url: '/v4/aliases',
    method: 'get',
    ...variables,
    signal
  });

export type GetAliasPathParams = {
  /**
   * The alias or alias ID to be retrieved
   *
   * @example example.vercel.app
   */
  idOrAlias: string;
};

export type GetAliasQueryParams = {
  /**
   * Get the alias only if it was created after the provided timestamp
   *
   * @deprecated true
   * @example 1540095775951
   */
  from?: number;
  /**
   * Get the alias only if it is assigned to the provided project ID
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectId?: string;
  /**
   * Get the alias only if it was created after this JavaScript timestamp
   *
   * @example 1540095775941
   */
  since?: number;
  /**
   * Get the alias only if it was created before this JavaScript timestamp
   *
   * @example 1540095775951
   */
  until?: number;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetAliasError = Fetcher.ErrorWrapper<undefined>;

export type GetAliasResponse = {
  /**
   * The alias name, it could be a `.vercel.app` subdomain or a custom domain
   *
   * @example my-alias.vercel.app
   */
  alias: string;
  /**
   * The date when the alias was created
   *
   * @format date-time
   * @example 2017-04-26T23:00:34.232Z
   */
  created: string;
  /**
   * The date when the alias was created in milliseconds since the UNIX epoch
   *
   * @example 1540095775941
   */
  createdAt?: number;
  /**
   * Information of the user who created the alias
   */
  creator?: {
    /**
     * ID of the user who created the alias
     *
     * @example 96SnxkFiMyVKsK3pnoHfx3Hz
     */
    uid: string;
    /**
     * Email of the user who created the alias
     *
     * @example john-doe@gmail.com
     */
    email: string;
    /**
     * Username of the user who created the alias
     *
     * @example john-doe
     */
    username: string;
  };
  /**
   * The date when the alias was deleted in milliseconds since the UNIX epoch
   *
   * @example 1540095775941
   */
  deletedAt?: number;
  /**
   * A map with the deployment ID, URL and metadata
   */
  deployment?: {
    /**
     * The deployment unique identifier
     *
     * @example dpl_5m8CQaRBm3FnWRW1od3wKTpaECPx
     */
    id: string;
    /**
     * The deployment unique URL
     *
     * @example my-instant-deployment-3ij3cxz9qr.now.sh
     */
    url: string;
    /**
     * The deployment metadata
     *
     * @example {}
     */
    meta?: string;
  };
  /**
   * The deployment ID
   *
   * @example dpl_5m8CQaRBm3FnWRW1od3wKTpaECPx
   */
  deploymentId: string | null;
  /**
   * The unique identifier of the project
   *
   * @example prj_12HKQaOmR5t5Uy6vdcQsNIiZgHGB
   */
  projectId: string | null;
  /**
   * Target destination domain for redirect when the alias is a redirect
   */
  redirect?: string | null;
  /**
   * Status code to be used on redirect
   */
  redirectStatusCode?: 301 | 302 | 307 | 308 | null;
  /**
   * The unique identifier of the alias
   */
  uid: string;
  /**
   * The date when the alias was updated in milliseconds since the UNIX epoch
   *
   * @example 1540095775941
   */
  updatedAt?: number;
  /**
   * The protection bypass for the alias
   */
  protectionBypass?: {
    [key: string]:
      | {
          createdAt: number;
          createdBy: string;
          scope: 'shareable-link';
        }
      | {
          createdAt: number;
          lastUpdatedAt: number;
          lastUpdatedBy: string;
          access: 'requested' | 'granted';
          scope: 'user';
        }
      | {
          createdAt: number;
          createdBy: string;
          scope: 'alias-protection-override';
        }
      | {
          createdAt: number;
          lastUpdatedAt: number;
          lastUpdatedBy: string;
          scope: 'email_invite';
        };
  };
};

export type GetAliasVariables = {
  pathParams: GetAliasPathParams;
  queryParams?: GetAliasQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves an Alias for the given host name or alias ID.
 */
export const getAlias = (variables: GetAliasVariables, signal?: AbortSignal) =>
  fetch<GetAliasResponse, GetAliasError, undefined, {}, GetAliasQueryParams, GetAliasPathParams>({
    url: '/v4/aliases/{idOrAlias}',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteAliasPathParams = {
  /**
   * The ID or alias that will be removed
   *
   * @example 2WjyKQmM8ZnGcJsPWMrHRHrE
   */
  aliasId: string;
};

export type DeleteAliasQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type DeleteAliasError = Fetcher.ErrorWrapper<undefined>;

export type DeleteAliasResponse = {
  status: 'SUCCESS';
};

export type DeleteAliasVariables = {
  pathParams: DeleteAliasPathParams;
  queryParams?: DeleteAliasQueryParams;
} & FetcherExtraProps;

/**
 * Delete an Alias with the specified ID.
 */
export const deleteAlias = (variables: DeleteAliasVariables, signal?: AbortSignal) =>
  fetch<DeleteAliasResponse, DeleteAliasError, undefined, {}, DeleteAliasQueryParams, DeleteAliasPathParams>({
    url: '/v2/aliases/{aliasId}',
    method: 'delete',
    ...variables,
    signal
  });

export type ListDeploymentAliasesPathParams = {
  /**
   * The ID of the deployment the aliases should be listed for
   *
   * @example dpl_FjvFJncQHQcZMznrUm9EoB8sFuPa
   */
  id: string;
};

export type ListDeploymentAliasesQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type ListDeploymentAliasesError = Fetcher.ErrorWrapper<undefined>;

export type ListDeploymentAliasesResponse = {
  /**
   * A list of the aliases assigned to the deployment
   */
  aliases: {
    /**
     * The unique identifier of the alias
     *
     * @example 2WjyKQmM8ZnGcJsPWMrHRHrE
     */
    uid: string;
    /**
     * The alias name, it could be a `.vercel.app` subdomain or a custom domain
     *
     * @example my-alias.vercel.app
     */
    alias: string;
    /**
     * The date when the alias was created
     *
     * @format date-time
     * @example 2017-04-26T23:00:34.232Z
     */
    created: string;
    /**
     * Target destination domain for redirect when the alias is a redirect
     */
    redirect?: string | null;
    /**
     * The protection bypass for the alias
     */
    protectionBypass?: {
      [key: string]:
        | {
            createdAt: number;
            createdBy: string;
            scope: 'shareable-link';
          }
        | {
            createdAt: number;
            lastUpdatedAt: number;
            lastUpdatedBy: string;
            access: 'requested' | 'granted';
            scope: 'user';
          }
        | {
            createdAt: number;
            createdBy: string;
            scope: 'alias-protection-override';
          }
        | {
            createdAt: number;
            lastUpdatedAt: number;
            lastUpdatedBy: string;
            scope: 'email_invite';
          };
    };
  }[];
};

export type ListDeploymentAliasesVariables = {
  pathParams: ListDeploymentAliasesPathParams;
  queryParams?: ListDeploymentAliasesQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves all Aliases for the Deployment with the given ID. The authenticated user or team must own the deployment.
 */
export const listDeploymentAliases = (variables: ListDeploymentAliasesVariables, signal?: AbortSignal) =>
  fetch<
    ListDeploymentAliasesResponse,
    ListDeploymentAliasesError,
    undefined,
    {},
    ListDeploymentAliasesQueryParams,
    ListDeploymentAliasesPathParams
  >({ url: '/v2/deployments/{id}/aliases', method: 'get', ...variables, signal });

export type AssignAliasPathParams = {
  /**
   * The ID of the deployment the aliases should be listed for
   *
   * @example dpl_FjvFJncQHQcZMznrUm9EoB8sFuPa
   */
  id: string;
};

export type AssignAliasQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type AssignAliasError = Fetcher.ErrorWrapper<undefined>;

export type AssignAliasResponse = {
  /**
   * The unique identifier of the alias
   *
   * @example 2WjyKQmM8ZnGcJsPWMrHRHrE
   */
  uid: string;
  /**
   * The assigned alias name
   *
   * @example my-alias.vercel.app
   */
  alias: string;
  /**
   * The date when the alias was created
   *
   * @format date-time
   * @example 2017-04-26T23:00:34.232Z
   */
  created: string;
  /**
   * The unique identifier of the previously aliased deployment, only received when the alias was used before
   *
   * @example dpl_FjvFJncQHQcZMznrUm9EoB8sFuPa
   */
  oldDeploymentId?: string | null;
};

export type AssignAliasRequestBody = {
  /**
   * The alias we want to assign to the deployment defined in the URL
   *
   * @example my-alias.vercel.app
   */
  alias?: string;
  /**
   * The redirect property will take precedence over the deployment id from the URL and consists of a hostname (like test.com) to which the alias should redirect using status code 307
   *
   * @example null
   */
  redirect?: string | null;
};

export type AssignAliasVariables = {
  body?: AssignAliasRequestBody;
  pathParams: AssignAliasPathParams;
  queryParams?: AssignAliasQueryParams;
} & FetcherExtraProps;

/**
 * Creates a new alias for the deployment with the given deployment ID. The authenticated user or team must own this deployment. If the desired alias is already assigned to another deployment, then it will be removed from the old deployment and assigned to the new one.
 */
export const assignAlias = (variables: AssignAliasVariables, signal?: AbortSignal) =>
  fetch<
    AssignAliasResponse,
    AssignAliasError,
    AssignAliasRequestBody,
    {},
    AssignAliasQueryParams,
    AssignAliasPathParams
  >({ url: '/v2/deployments/{id}/aliases', method: 'post', ...variables, signal });

export type GetCertByIdPathParams = {
  /**
   * The cert id
   */
  id: string;
};

export type GetCertByIdQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetCertByIdError = Fetcher.ErrorWrapper<undefined>;

export type GetCertByIdResponse = {
  id: string;
  createdAt: number;
  expiresAt: number;
  autoRenew: boolean;
  cns: string[];
};

export type GetCertByIdVariables = {
  pathParams: GetCertByIdPathParams;
  queryParams?: GetCertByIdQueryParams;
} & FetcherExtraProps;

/**
 * Get cert by id
 */
export const getCertById = (variables: GetCertByIdVariables, signal?: AbortSignal) =>
  fetch<GetCertByIdResponse, GetCertByIdError, undefined, {}, GetCertByIdQueryParams, GetCertByIdPathParams>({
    url: '/v7/certs/{id}',
    method: 'get',
    ...variables,
    signal
  });

export type RemoveCertPathParams = {
  /**
   * The cert id to remove
   */
  id: string;
};

export type RemoveCertQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type RemoveCertError = Fetcher.ErrorWrapper<undefined>;

export type RemoveCertVariables = {
  pathParams: RemoveCertPathParams;
  queryParams?: RemoveCertQueryParams;
} & FetcherExtraProps;

/**
 * Remove cert
 */
export const removeCert = (variables: RemoveCertVariables, signal?: AbortSignal) =>
  fetch<Record<string, any>, RemoveCertError, undefined, {}, RemoveCertQueryParams, RemoveCertPathParams>({
    url: '/v7/certs/{id}',
    method: 'delete',
    ...variables,
    signal
  });

export type IssueCertQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type IssueCertError = Fetcher.ErrorWrapper<undefined>;

export type IssueCertResponse = {
  id: string;
  createdAt: number;
  expiresAt: number;
  autoRenew: boolean;
  cns: string[];
};

export type IssueCertRequestBody = {
  /**
   * The common names the cert should be issued for
   */
  cns?: string[];
};

export type IssueCertVariables = {
  body?: IssueCertRequestBody;
  queryParams?: IssueCertQueryParams;
} & FetcherExtraProps;

/**
 * Issue a new cert
 */
export const issueCert = (variables: IssueCertVariables, signal?: AbortSignal) =>
  fetch<IssueCertResponse, IssueCertError, IssueCertRequestBody, {}, IssueCertQueryParams, {}>({
    url: '/v7/certs',
    method: 'post',
    ...variables,
    signal
  });

export type UploadCertQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type UploadCertError = Fetcher.ErrorWrapper<undefined>;

export type UploadCertResponse = {
  id: string;
  createdAt: number;
  expiresAt: number;
  autoRenew: boolean;
  cns: string[];
};

export type UploadCertRequestBody = {
  /**
   * The certificate authority
   */
  ca: string;
  /**
   * The certificate key
   */
  key: string;
  /**
   * The certificate
   */
  cert: string;
  /**
   * Skip validation of the certificate
   */
  skipValidation?: boolean;
};

export type UploadCertVariables = {
  body: UploadCertRequestBody;
  queryParams?: UploadCertQueryParams;
} & FetcherExtraProps;

/**
 * Upload a cert
 */
export const uploadCert = (variables: UploadCertVariables, signal?: AbortSignal) =>
  fetch<UploadCertResponse, UploadCertError, UploadCertRequestBody, {}, UploadCertQueryParams, {}>({
    url: '/v7/certs',
    method: 'put',
    ...variables,
    signal
  });

export type ListDeploymentFilesPathParams = {
  /**
   * The unique deployment identifier
   */
  id: string;
};

export type ListDeploymentFilesQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type ListDeploymentFilesError = Fetcher.ErrorWrapper<undefined>;

export type ListDeploymentFilesResponse = Schemas.FileTree[];

export type ListDeploymentFilesVariables = {
  pathParams: ListDeploymentFilesPathParams;
  queryParams?: ListDeploymentFilesQueryParams;
} & FetcherExtraProps;

/**
 * Allows to retrieve the file structure of a deployment by supplying the deployment unique identifier.
 */
export const listDeploymentFiles = (variables: ListDeploymentFilesVariables, signal?: AbortSignal) =>
  fetch<
    ListDeploymentFilesResponse,
    ListDeploymentFilesError,
    undefined,
    {},
    ListDeploymentFilesQueryParams,
    ListDeploymentFilesPathParams
  >({ url: '/v6/deployments/{id}/files', method: 'get', ...variables, signal });

export type GetDeploymentFileContentsPathParams = {
  /**
   * The unique deployment identifier
   */
  id: string;
  /**
   * The unique file identifier
   */
  fileId: string;
};

export type GetDeploymentFileContentsQueryParams = {
  /**
   * Path to the file to fetch (only for Git deployments)
   */
  path?: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetDeploymentFileContentsError = Fetcher.ErrorWrapper<undefined>;

export type GetDeploymentFileContentsVariables = {
  pathParams: GetDeploymentFileContentsPathParams;
  queryParams?: GetDeploymentFileContentsQueryParams;
} & FetcherExtraProps;

/**
 * Allows to retrieve the content of a file by supplying the file identifier and the deployment unique identifier. The response body will contain a JSON response containing the contents of the file encoded as base64.
 */
export const getDeploymentFileContents = (variables: GetDeploymentFileContentsVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    GetDeploymentFileContentsError,
    undefined,
    {},
    GetDeploymentFileContentsQueryParams,
    GetDeploymentFileContentsPathParams
  >({ url: '/v7/deployments/{id}/files/{fileId}', method: 'get', ...variables, signal });

export type GetDeploymentsQueryParams = {
  /**
   * Name of the deployment.
   *
   * @example docs
   */
  app?: string;
  /**
   * Gets the deployment created after this Date timestamp. (default: current time)
   *
   * @example 1612948664566
   * @deprecated true
   */
  from?: number;
  /**
   * Maximum number of deployments to list from a request.
   *
   * @example 10
   */
  limit?: number;
  /**
   * Filter deployments from the given `projectId`.
   *
   * @example QmXGTs7mvAMMC7WW5ebrM33qKG32QK3h4vmQMjmY
   */
  projectId?: string;
  /**
   * Filter deployments based on the environment.
   *
   * @example production
   */
  target?: 'production' | 'preview';
  /**
   * Gets the deployment created before this Date timestamp. (default: current time)
   *
   * @example 1612948664566
   * @deprecated true
   */
  to?: number;
  /**
   * Filter out deployments based on users who have created the deployment.
   *
   * @example kr1PsOIzqEL5Xg6M4VZcZosf,K4amb7K9dAt5R2vBJWF32bmY
   */
  users?: string;
  /**
   * Get Deployments created after this JavaScript timestamp.
   *
   * @example 1540095775941
   */
  since?: number;
  /**
   * Get Deployments created before this JavaScript timestamp.
   *
   * @example 1540095775951
   */
  until?: number;
  /**
   * Filter deployments based on their state (`BUILDING`, `ERROR`, `INITIALIZING`, `QUEUED`, `READY`, `CANCELED`)
   *
   * @example BUILDING,READY
   */
  state?: string;
  /**
   * Filter deployments based on their rollback candidacy
   */
  rollbackCandidate?: boolean;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetDeploymentsError = Fetcher.ErrorWrapper<undefined>;

export type GetDeploymentsResponse = {
  pagination: Schemas.Pagination;
  deployments: {
    /**
     * The unique identifier of the deployment.
     *
     * @example dpl_2euZBFqxYdDMDG1jTrHFnNZ2eUVa
     */
    uid: string;
    /**
     * The name of the deployment.
     *
     * @example docs
     */
    name: string;
    /**
     * The URL of the deployment.
     *
     * @example docs-9jaeg38me.vercel.app
     */
    url: string;
    /**
     * Timestamp of when the deployment got created.
     *
     * @example 1609492210000
     */
    created: number;
    /**
     * Timestamp of when the deployment got deleted.
     *
     * @example 1609492210000
     */
    deleted?: number;
    /**
     * Timestamp of when the deployment was undeleted.
     *
     * @example 1609492210000
     */
    undeleted?: number;
    /**
     * The source of the deployment.
     *
     * @example cli
     */
    source?: 'api-trigger-git-deploy' | 'cli' | 'clone/repo' | 'git' | 'import' | 'import/repo';
    /**
     * In which state is the deployment.
     *
     * @example READY
     */
    state?: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED' | 'DELETED';
    /**
     * In which state is the deployment.
     *
     * @example READY
     */
    readyState?: 'BUILDING' | 'ERROR' | 'INITIALIZING' | 'QUEUED' | 'READY' | 'CANCELED' | 'DELETED';
    /**
     * The type of the deployment.
     *
     * @example LAMBDAS
     */
    type: 'LAMBDAS';
    /**
     * Metadata information of the user who created the deployment.
     */
    creator: {
      /**
       * The unique identifier of the user.
       *
       * @example eLrCnEgbKhsHyfbiNR7E8496
       */
      uid: string;
      /**
       * The email address of the user.
       *
       * @example example@example.com
       */
      email?: string;
      /**
       * The username of the user.
       *
       * @example johndoe
       */
      username?: string;
      /**
       * The GitHub login of the user.
       *
       * @example johndoe
       */
      githubLogin?: string;
      /**
       * The GitLab login of the user.
       *
       * @example johndoe
       */
      gitlabLogin?: string;
    };
    /**
     * Metadata information from the Git provider.
     */
    meta?: {
      [key: string]: string;
    };
    /**
     * On which environment has the deployment been deployed to.
     *
     * @example production
     */
    target?: 'production' | 'staging' | null;
    /**
     * An error object in case aliasing of the deployment failed.
     */
    aliasError?: {
      code: string;
      message: string;
    } | null;
    aliasAssigned?: number | boolean | null;
    /**
     * Timestamp of when the deployment got created.
     *
     * @example 1609492210000
     */
    createdAt?: number;
    /**
     * Timestamp of when the deployment started building at.
     *
     * @example 1609492210000
     */
    buildingAt?: number;
    /**
     * Timestamp of when the deployment got ready.
     *
     * @example 1609492210000
     */
    ready?: number;
    /**
     * Since June 2023 Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - PROMOTED: has seen production traffic
     */
    readySubstate?: 'STAGED' | 'PROMOTED';
    /**
     * State of all registered checks
     */
    checksState?: 'registered' | 'running' | 'completed';
    /**
     * Conclusion for checks
     */
    checksConclusion?: 'succeeded' | 'failed' | 'skipped' | 'canceled';
    /**
     * Vercel URL to inspect the deployment.
     *
     * @example https://vercel.com/acme/nextjs/J1hXN00qjUeoYfpEEf7dnDtpSiVq
     */
    inspectorUrl: string | null;
    /**
     * Deployment can be used for instant rollback
     */
    isRollbackCandidate?: boolean | null;
    /**
     * The project settings which was used for this deployment
     */
    projectSettings?: {
      framework?:
        | 'blitzjs'
        | 'nextjs'
        | 'gatsby'
        | 'remix'
        | 'astro'
        | 'hexo'
        | 'eleventy'
        | 'docusaurus-2'
        | 'docusaurus'
        | 'preact'
        | 'solidstart-1'
        | 'solidstart'
        | 'dojo'
        | 'ember'
        | 'vue'
        | 'scully'
        | 'ionic-angular'
        | 'angular'
        | 'polymer'
        | 'svelte'
        | 'sveltekit'
        | 'sveltekit-1'
        | 'ionic-react'
        | 'create-react-app'
        | 'gridsome'
        | 'umijs'
        | 'sapper'
        | 'saber'
        | 'stencil'
        | 'nuxtjs'
        | 'redwoodjs'
        | 'hugo'
        | 'jekyll'
        | 'brunch'
        | 'middleman'
        | 'zola'
        | 'hydrogen'
        | 'vite'
        | 'vitepress'
        | 'vuepress'
        | 'parcel'
        | 'sanity'
        | 'storybook'
        | null;
      gitForkProtection?: boolean;
      customerSupportCodeVisibility?: boolean;
      gitLFS?: boolean;
      devCommand?: string | null;
      installCommand?: string | null;
      buildCommand?: string | null;
      nodeVersion?: '20.x' | '18.x' | '16.x' | '14.x' | '12.x' | '10.x' | '8.10.x';
      outputDirectory?: string | null;
      publicSource?: boolean | null;
      rootDirectory?: string | null;
      serverlessFunctionRegion?: string | null;
      sourceFilesOutsideRootDirectory?: boolean;
      commandForIgnoringBuildStep?: string | null;
      createdAt?: number;
      speedInsights?: {
        id: string;
        enabledAt?: number;
        disabledAt?: number;
        canceledAt?: number;
        hasData?: boolean;
        paidAt?: number;
      };
      webAnalytics?: {
        id: string;
        disabledAt?: number;
        canceledAt?: number;
        enabledAt?: number;
        hasData?: boolean;
      };
      skipGitConnectDuringLink?: boolean;
      /**
       * Since June '23
       */
      gitComments?: {
        /**
         * Whether the Vercel bot should comment on PRs
         */
        onPullRequest: boolean;
        /**
         * Whether the Vercel bot should comment on commits
         */
        onCommit: boolean;
      };
    };
    /**
     * The flag saying if Vercel Connect configuration is used for builds
     */
    connectBuildsEnabled?: boolean;
    /**
     * The ID of Vercel Connect configuration used for this deployment
     */
    connectConfigurationId?: string;
    /**
     * The ID of Vercel Connect configuration used for this deployment's passive functions
     */
    passiveConnectConfigurationId?: string;
    /**
     * The expiration configured by the project retention policy
     */
    expiration?: number;
    /**
     * The expiration proposed to replace the existing expiration
     */
    proposedExpiration?: number;
  }[];
};

export type GetDeploymentsVariables = {
  queryParams?: GetDeploymentsQueryParams;
} & FetcherExtraProps;

/**
 * List deployments under the authenticated user or team. If a deployment hasn't finished uploading (is incomplete), the `url` property will have a value of `null`.
 */
export const getDeployments = (variables: GetDeploymentsVariables, signal?: AbortSignal) =>
  fetch<GetDeploymentsResponse, GetDeploymentsError, undefined, {}, GetDeploymentsQueryParams, {}>({
    url: '/v6/deployments',
    method: 'get',
    ...variables,
    signal
  });

export type VerifyTokenQueryParams = {
  /**
   * Email to verify the login.
   */
  email?: string;
  /**
   * The token returned when the login was requested.
   */
  token: string;
  /**
   * The desired name for the token. It will be displayed on the user account details.
   *
   * @example Your Client App Name
   */
  tokenName?: string;
  /**
   * The SAML Profile ID, when connecting a SAML Profile to a Team member for the first time.
   */
  ssoUserId?: string;
  /**
   * The name of this user's team.
   */
  teamName?: string;
  /**
   * The slug for this user's team.
   */
  teamSlug?: string;
  /**
   * The plan for this user's team (pro or hobby).
   */
  teamPlan?: 'pro' | 'hobby';
  /**
   * Referrer to the session.
   */
  sessionReferrer?: string;
  /**
   * The page on which the user started their session.
   */
  landingPage?: string;
  /**
   * The page that sent the user to the signup page.
   */
  pageBeforeConversionPage?: string;
  utmSource?: string;
  utmMedium?: string;
  utmCampaign?: string;
  utmTerm?: string;
  oppId?: string;
};

export type VerifyTokenError = Fetcher.ErrorWrapper<undefined>;

export type VerifyTokenResponse = {
  /**
   * The user authentication token that can be used to perform API requests.
   *
   * @example 1ioXyz9Ue4xdCYGROet1dlKd
   */
  token: string;
  /**
   * Email address of the authenticated user.
   *
   * @example amy@example.com
   */
  email: string;
  /**
   * When completing SAML Single Sign-On authentication, this will be the ID of the Team that was authenticated for.
   *
   * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
   */
  teamId?: string;
};

export type VerifyTokenVariables = {
  queryParams: VerifyTokenQueryParams;
} & FetcherExtraProps;

/**
 * Verify the user accepted the login request and get a authentication token. The user email address and the token received after requesting the login must be added to the URL as a query string with the names `email` and `token`.
 */
export const verifyToken = (variables: VerifyTokenVariables, signal?: AbortSignal) =>
  fetch<VerifyTokenResponse, VerifyTokenError, undefined, {}, VerifyTokenQueryParams, {}>({
    url: '/registration/verify',
    method: 'get',
    ...variables,
    signal
  });

export type EmailLoginError = Fetcher.ErrorWrapper<undefined>;

export type EmailLoginRequestBody = {
  /**
   * The user email.
   *
   * @example user@mail.com
   */
  email: string;
  /**
   * The desired name for the token. It will be displayed on the user account details.
   *
   * @example Your Client App Name
   */
  tokenName?: string;
};

export type EmailLoginVariables = {
  body: EmailLoginRequestBody;
} & FetcherExtraProps;

/**
 * Request a new login for a user to get a token. This will respond with a verification token and send an email to confirm the request. Once confirmed you can use the verification token to get an authentication token.
 */
export const emailLogin = (variables: EmailLoginVariables, signal?: AbortSignal) =>
  fetch<
    | {
        token: string;
        securityCode: string;
      }
    | {
        /**
         * The token used to verify the user accepted the login request
         *
         * @example T1dmvPu36nmyYisXAs7IRzcR
         */
        token: string;
        /**
         * The code the user is going to receive on the email. **Must** be displayed to the user so they can verify the request is the correct.
         *
         * @example Practical Saola
         */
        securityCode: string;
      },
    EmailLoginError,
    EmailLoginRequestBody,
    {},
    {},
    {}
  >({ url: '/registration', method: 'post', ...variables, signal });

export type DeleteDeploymentPathParams = {
  /**
   * The ID of the deployment to be deleted
   *
   * @example dpl_5WJWYSyB7BpgTj3EuwF37WMRBXBtPQ2iTMJHJBJyRfd
   */
  id: string;
};

export type DeleteDeploymentQueryParams = {
  /**
   * A Deployment or Alias URL. In case it is passed, the ID will be ignored
   *
   * @example https://files-orcin-xi.vercel.app/
   */
  url?: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type DeleteDeploymentError = Fetcher.ErrorWrapper<undefined>;

export type DeleteDeploymentResponse = {
  /**
   * The removed deployment ID.
   *
   * @example dpl_5WJWYSyB7BpgTj3EuwF37WMRBXBtPQ2iTMJHJBJyRfd
   */
  uid: string;
  /**
   * A constant with the final state of the deployment.
   */
  state: 'DELETED';
};

export type DeleteDeploymentVariables = {
  pathParams: DeleteDeploymentPathParams;
  queryParams?: DeleteDeploymentQueryParams;
} & FetcherExtraProps;

/**
 * This API allows you to delete a deployment, either by supplying its `id` in the URL or the `url` of the deployment as a query parameter. You can obtain the ID, for example, by listing all deployments.
 */
export const deleteDeployment = (variables: DeleteDeploymentVariables, signal?: AbortSignal) =>
  fetch<
    DeleteDeploymentResponse,
    DeleteDeploymentError,
    undefined,
    {},
    DeleteDeploymentQueryParams,
    DeleteDeploymentPathParams
  >({ url: '/v13/deployments/{id}', method: 'delete', ...variables, signal });

export type GetSecretsQueryParams = {
  /**
   * Filter out secrets based on comma separated secret ids.
   *
   * @example sec_RKc5iV0rV3ZSrFrHiruRno7k,sec_fGc5iV0rV3ZSrFrHiruRnouQ
   * @deprecated true
   */
  id?: string;
  /**
   * Filter out secrets that belong to a project.
   *
   * @example prj_2WjyKQmM8ZnGcJsPWMrHRHrE
   * @deprecated true
   */
  projectId?: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetSecretsError = Fetcher.ErrorWrapper<undefined>;

export type GetSecretsResponse = {
  secrets: {
    /**
     * The date when the secret was created.
     *
     * @format date-time
     * @example 2021-02-10T13:11:49.180Z
     */
    created: string;
    /**
     * The name of the secret.
     *
     * @example my-api-key
     */
    name: string;
    /**
     * The unique identifier of the team the secret was created for.
     *
     * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
     */
    teamId?: string | null;
    /**
     * The unique identifier of the secret.
     *
     * @example sec_XCG7t7AIHuO2SBA8667zNUiM
     */
    uid: string;
    /**
     * The unique identifier of the user who created the secret.
     *
     * @example 2qDDuGFTWXBLDNnqZfWPDp1A
     */
    userId?: string;
    /**
     * The value of the secret.
     */
    value?: string;
    /**
     * Timestamp for when the secret was created.
     *
     * @example 1609492210000
     */
    createdAt?: number;
    /**
     * The unique identifier of the project which the secret belongs to.
     *
     * @example prj_2WjyKQmM8ZnGcJsPWMrHRHrE
     */
    projectId?: string;
    /**
     * Indicates whether the secret value can be decrypted after it has been created.
     *
     * @example true
     */
    decryptable?: boolean;
  }[];
  pagination: Schemas.Pagination;
};

export type GetSecretsVariables = {
  queryParams?: GetSecretsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves the active Vercel secrets for the authenticated user or team. By default it returns 20 secrets. The rest can be retrieved using the pagination options. The body will contain an entry for each secret.
 */
export const getSecrets = (variables: GetSecretsVariables, signal?: AbortSignal) =>
  fetch<GetSecretsResponse, GetSecretsError, undefined, {}, GetSecretsQueryParams, {}>({
    url: '/v3/secrets',
    method: 'get',
    ...variables,
    signal
  });

export type CreateSecretQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type CreateSecretError = Fetcher.ErrorWrapper<undefined>;

export type CreateSecretResponse = {
  value: {
    type?: 'Buffer';
    data?: number[];
  };
  /**
   * The date when the secret was created.
   *
   * @format date-time
   * @example 2021-02-10T13:11:49.180Z
   */
  created: string;
  /**
   * The name of the secret.
   *
   * @example my-api-key
   */
  name: string;
  /**
   * The unique identifier of the team the secret was created for.
   *
   * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
   */
  teamId?: string | null;
  /**
   * The unique identifier of the secret.
   *
   * @example sec_XCG7t7AIHuO2SBA8667zNUiM
   */
  uid: string;
  /**
   * The unique identifier of the user who created the secret.
   *
   * @example 2qDDuGFTWXBLDNnqZfWPDp1A
   */
  userId?: string;
  /**
   * Timestamp for when the secret was created.
   *
   * @example 1609492210000
   */
  createdAt?: number;
  /**
   * The unique identifier of the project which the secret belongs to.
   *
   * @example prj_2WjyKQmM8ZnGcJsPWMrHRHrE
   */
  projectId?: string;
  /**
   * Indicates whether the secret value can be decrypted after it has been created.
   *
   * @example true
   */
  decryptable?: boolean;
};

export type CreateSecretRequestBody = {
  /**
   * The name of the secret (max 100 characters).
   *
   * @example my-api-key
   * @maximum 100
   */
  name: string;
  /**
   * The value of the new secret.
   *
   * @example some secret value
   */
  value: string;
  /**
   * Whether the secret value can be decrypted after it has been created.
   *
   * @example true
   */
  decryptable?: boolean;
  /**
   * Associate a secret to a project.
   *
   * @example prj_2WjyKQmM8ZnGcJsPWMrHRHrE
   * @deprecated true
   */
  projectId?: string;
};

export type CreateSecretVariables = {
  body: CreateSecretRequestBody;
  queryParams?: CreateSecretQueryParams;
} & FetcherExtraProps;

/**
 * Allows to create a new secret.
 */
export const createSecret = (variables: CreateSecretVariables, signal?: AbortSignal) =>
  fetch<CreateSecretResponse, CreateSecretError, CreateSecretRequestBody, {}, CreateSecretQueryParams, {}>({
    url: '/v2/secrets/{name}',
    method: 'post',
    ...variables,
    signal
  });

export type RenameSecretPathParams = {
  /**
   * The name of the secret.
   *
   * @example my-api-key
   */
  name: string;
};

export type RenameSecretQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type RenameSecretError = Fetcher.ErrorWrapper<undefined>;

export type RenameSecretResponse = {
  uid: string;
  name: string;
  /**
   * @format date-time
   */
  created: string;
  oldName: string;
};

export type RenameSecretRequestBody = {
  /**
   * The name of the new secret.
   *
   * @example my-api-key
   * @maximum 100
   */
  name: string;
};

export type RenameSecretVariables = {
  body: RenameSecretRequestBody;
  pathParams: RenameSecretPathParams;
  queryParams?: RenameSecretQueryParams;
} & FetcherExtraProps;

/**
 * Enables to edit the name of a secret. The name has to be unique to the user or team’s secrets.
 */
export const renameSecret = (variables: RenameSecretVariables, signal?: AbortSignal) =>
  fetch<
    RenameSecretResponse,
    RenameSecretError,
    RenameSecretRequestBody,
    {},
    RenameSecretQueryParams,
    RenameSecretPathParams
  >({ url: '/v2/secrets/{name}', method: 'patch', ...variables, signal });

export type GetSecretPathParams = {
  /**
   * The name or the unique identifier to which the secret belongs to.
   *
   * @example sec_RKc5iV0rV3ZSrFrHiruRno7k
   */
  idOrName: string;
};

export type GetSecretQueryParams = {
  /**
   * Whether to try to decrypt the value of the secret. Only works if `decryptable` has been set to `true` when the secret was created.
   *
   * @example true
   */
  decrypt?: 'true' | 'false';
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type GetSecretError = Fetcher.ErrorWrapper<undefined>;

export type GetSecretResponse = {
  /**
   * The date when the secret was created.
   *
   * @format date-time
   * @example 2021-02-10T13:11:49.180Z
   */
  created: string;
  /**
   * The name of the secret.
   *
   * @example my-api-key
   */
  name: string;
  /**
   * The unique identifier of the team the secret was created for.
   *
   * @example team_LLHUOMOoDlqOp8wPE4kFo9pE
   */
  teamId?: string | null;
  /**
   * The unique identifier of the secret.
   *
   * @example sec_XCG7t7AIHuO2SBA8667zNUiM
   */
  uid: string;
  /**
   * The unique identifier of the user who created the secret.
   *
   * @example 2qDDuGFTWXBLDNnqZfWPDp1A
   */
  userId?: string;
  /**
   * The value of the secret.
   */
  value?: string;
  /**
   * Timestamp for when the secret was created.
   *
   * @example 1609492210000
   */
  createdAt?: number;
  /**
   * The unique identifier of the project which the secret belongs to.
   *
   * @example prj_2WjyKQmM8ZnGcJsPWMrHRHrE
   */
  projectId?: string;
  /**
   * Indicates whether the secret value can be decrypted after it has been created.
   *
   * @example true
   */
  decryptable?: boolean;
};

export type GetSecretVariables = {
  pathParams: GetSecretPathParams;
  queryParams?: GetSecretQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves the information for a specific secret by passing either the secret id or name in the URL.
 */
export const getSecret = (variables: GetSecretVariables, signal?: AbortSignal) =>
  fetch<GetSecretResponse, GetSecretError, undefined, {}, GetSecretQueryParams, GetSecretPathParams>({
    url: '/v3/secrets/{idOrName}',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteSecretPathParams = {
  /**
   * The name or the unique identifier to which the secret belongs to.
   *
   * @example sec_RKc5iV0rV3ZSrFrHiruRno7k
   */
  idOrName: string;
};

export type DeleteSecretQueryParams = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string;
};

export type DeleteSecretError = Fetcher.ErrorWrapper<undefined>;

export type DeleteSecretResponse = {
  /**
   * The unique identifier of the deleted secret.
   *
   * @example sec_XCG7t7AIHuO2SBA8667zNUiM
   */
  uid: string;
  /**
   * The name of the deleted secret.
   *
   * @example my-api-key
   */
  name: string;
  /**
   * The date when the secret was created.
   *
   * @example 2021-02-10T13:11:49.180Z
   */
  created: number;
};

export type DeleteSecretVariables = {
  pathParams: DeleteSecretPathParams;
  queryParams?: DeleteSecretQueryParams;
} & FetcherExtraProps;

/**
 * This deletes the user or team’s secret defined in the URL.
 */
export const deleteSecret = (variables: DeleteSecretVariables, signal?: AbortSignal) =>
  fetch<DeleteSecretResponse, DeleteSecretError, undefined, {}, DeleteSecretQueryParams, DeleteSecretPathParams>({
    url: '/v2/secrets/{idOrName}',
    method: 'delete',
    ...variables,
    signal
  });

export const operationsByTag = {
  accessGroups: {
    readAccessGroup,
    updateAccessGroup,
    deleteAccessGroup,
    listAccessGroupMembers,
    listAccessGroups,
    createAccessGroup,
    listAccessGroupProjects
  },
  artifacts: { recordEvents, status, uploadArtifact, downloadArtifact, artifactQuery },
  checks: { createCheck, getAllChecks, getCheck, updateCheck, rerequestCheck },
  projects: {
    updateProjectDataCache,
    getProjects,
    createProject,
    getProject,
    updateProject,
    deleteProject,
    getProjectDomains,
    getProjectDomain,
    updateProjectDomain,
    removeProjectDomain,
    addProjectDomain,
    verifyProjectDomain,
    filterProjectEnvs,
    getProjectEnv,
    createProjectEnv,
    removeProjectEnv,
    editProjectEnv,
    updateProjectProtectionBypass,
    requestPromote,
    listPromoteAliases,
    pauseProject,
    unpauseProject
  },
  deployments: {
    getDeploymentEvents,
    getDeployment,
    createDeployment,
    cancelDeployment,
    uploadFile,
    listDeploymentFiles,
    getDeploymentFileContents,
    getDeployments,
    deleteDeployment
  },
  domains: {
    buyDomain,
    checkDomainPrice,
    checkDomainStatus,
    getDomainTransfer,
    getDomainConfig,
    getDomain,
    getDomains,
    createOrTransferDomain,
    patchDomain,
    deleteDomain
  },
  dns: { getRecords, createRecord, updateRecord, removeRecord },
  edgeConfig: {
    getEdgeConfigs,
    createEdgeConfig,
    getEdgeConfig,
    updateEdgeConfig,
    deleteEdgeConfig,
    getEdgeConfigItems,
    patchEdgeConfigItems,
    getEdgeConfigSchema,
    patchEdgeConfigSchema,
    deleteEdgeConfigSchema,
    getEdgeConfigItem,
    getEdgeConfigTokens,
    deleteEdgeConfigTokens,
    getEdgeConfigToken,
    createEdgeConfigToken
  },
  user: { listUserEvents, getAuthUser, requestDelete },
  integrations: { getConfigurations, getConfiguration, deleteConfiguration, gitNamespaces, searchRepo },
  logDrains: {
    getIntegrationLogDrains,
    createLogDrain,
    deleteIntegrationLogDrain,
    getConfigurableLogDrain,
    deleteConfigurableLogDrain,
    getAllLogDrains,
    createConfigurableLogDrain
  },
  projectMembers: { getProjectMembers, addProjectMember, removeProjectMember },
  teams: {
    getTeamMembers,
    inviteUserToTeam,
    requestAccessToTeam,
    getTeamAccessRequest,
    joinTeam,
    updateTeamMember,
    removeTeamMember,
    getTeam,
    patchTeam,
    getTeams,
    createTeam,
    deleteTeam,
    deleteTeamInviteCode
  },
  authentication: { listAuthTokens, createAuthToken, getAuthToken, deleteAuthToken, verifyToken, emailLogin },
  webhooks: { createWebhook, getWebhooks, getWebhook, deleteWebhook },
  aliases: { listAliases, getAlias, deleteAlias, listDeploymentAliases, assignAlias },
  certs: { getCertById, removeCert, issueCert, uploadCert },
  secrets: { getSecrets, createSecret, renameSecret, getSecret, deleteSecret }
};
