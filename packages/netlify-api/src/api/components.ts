/**
 * Generated by @openapi-codegen
 *
 * @version 2.33.0
 */
import type * as Fetcher from './fetcher';
import { fetch, FetcherExtraProps } from './fetcher';
import type * as RequestBodies from './requestBodies';
import type { ClientErrorStatus, ServerErrorStatus } from './utils';

export type ListSitesQueryParams = {
  name?: string;
  filter?: 'all' | 'owner' | 'guest';
  /**
   * @format int32
   */
  page?: number;
  /**
   * @format int32
   */
  per_page?: number;
};

export type ListSitesError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListSitesResponse = {
  id?: string;
  state?: string;
  plan?: string;
  name?: string;
  custom_domain?: string;
  domain_aliases?: string[];
  branch_deploy_custom_domain?: string;
  deploy_preview_custom_domain?: string;
  password?: string;
  notification_email?: string;
  url?: string;
  ssl_url?: string;
  admin_url?: string;
  screenshot_url?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  user_id?: string;
  session_id?: string;
  ssl?: boolean;
  force_ssl?: boolean;
  managed_dns?: boolean;
  deploy_url?: string;
  published_deploy?: {
    id?: string;
    site_id?: string;
    user_id?: string;
    build_id?: string;
    state?: string;
    name?: string;
    url?: string;
    ssl_url?: string;
    admin_url?: string;
    deploy_url?: string;
    deploy_ssl_url?: string;
    screenshot_url?: string;
    review_id?: number;
    draft?: boolean;
    required?: string[];
    required_functions?: string[];
    error_message?: string;
    branch?: string;
    commit_ref?: string;
    commit_url?: string;
    skipped?: boolean;
    /**
     * @format dateTime
     */
    created_at?: string;
    /**
     * @format dateTime
     */
    updated_at?: string;
    /**
     * @format dateTime
     */
    published_at?: string;
    title?: string;
    context?: string;
    locked?: boolean;
    review_url?: string;
    framework?: string;
    function_schedules?: {
      name?: string;
      cron?: string;
    }[];
  };
  account_name?: string;
  account_slug?: string;
  git_provider?: string;
  deploy_hook?: string;
  capabilities?: {
    [key: string]: Record<string, any>;
  };
  processing_settings?: {
    html?: {
      pretty_urls?: boolean;
    };
  };
  build_settings?: {
    id?: number;
    provider?: string;
    deploy_key_id?: string;
    repo_path?: string;
    repo_branch?: string;
    dir?: string;
    functions_dir?: string;
    cmd?: string;
    allowed_branches?: string[];
    public_repo?: boolean;
    private_logs?: boolean;
    repo_url?: string;
    env?: {
      [key: string]: string;
    };
    installation_id?: number;
    stop_builds?: boolean;
  };
  id_domain?: string;
  default_hooks_data?: {
    access_token?: string;
  };
  build_image?: string;
  prerender?: string;
  functions_region?: string;
}[];

export type ListSitesVariables = {
  queryParams?: ListSitesQueryParams;
} & FetcherExtraProps;

/**
 * **Note:** Environment variable keys and values have moved from `build_settings.env` and `repo.env` to a new endpoint. Please use [getEnvVars](#tag/environmentVariables/operation/getEnvVars) to retrieve site environment variables.
 */
export const listSites = (variables: ListSitesVariables, signal?: AbortSignal) =>
  fetch<ListSitesResponse, ListSitesError, undefined, {}, ListSitesQueryParams, {}>({
    url: '/sites',
    method: 'get',
    ...variables,
    signal
  });

export type CreateSiteQueryParams = {
  configure_dns?: boolean;
};

export type CreateSiteError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreateSiteResponse = {
  id?: string;
  state?: string;
  plan?: string;
  name?: string;
  custom_domain?: string;
  domain_aliases?: string[];
  branch_deploy_custom_domain?: string;
  deploy_preview_custom_domain?: string;
  password?: string;
  notification_email?: string;
  url?: string;
  ssl_url?: string;
  admin_url?: string;
  screenshot_url?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  user_id?: string;
  session_id?: string;
  ssl?: boolean;
  force_ssl?: boolean;
  managed_dns?: boolean;
  deploy_url?: string;
  published_deploy?: {
    id?: string;
    site_id?: string;
    user_id?: string;
    build_id?: string;
    state?: string;
    name?: string;
    url?: string;
    ssl_url?: string;
    admin_url?: string;
    deploy_url?: string;
    deploy_ssl_url?: string;
    screenshot_url?: string;
    review_id?: number;
    draft?: boolean;
    required?: string[];
    required_functions?: string[];
    error_message?: string;
    branch?: string;
    commit_ref?: string;
    commit_url?: string;
    skipped?: boolean;
    /**
     * @format dateTime
     */
    created_at?: string;
    /**
     * @format dateTime
     */
    updated_at?: string;
    /**
     * @format dateTime
     */
    published_at?: string;
    title?: string;
    context?: string;
    locked?: boolean;
    review_url?: string;
    framework?: string;
    function_schedules?: {
      name?: string;
      cron?: string;
    }[];
  };
  account_name?: string;
  account_slug?: string;
  git_provider?: string;
  deploy_hook?: string;
  capabilities?: {
    [key: string]: Record<string, any>;
  };
  processing_settings?: {
    html?: {
      pretty_urls?: boolean;
    };
  };
  build_settings?: {
    id?: number;
    provider?: string;
    deploy_key_id?: string;
    repo_path?: string;
    repo_branch?: string;
    dir?: string;
    functions_dir?: string;
    cmd?: string;
    allowed_branches?: string[];
    public_repo?: boolean;
    private_logs?: boolean;
    repo_url?: string;
    env?: {
      [key: string]: string;
    };
    installation_id?: number;
    stop_builds?: boolean;
  };
  id_domain?: string;
  default_hooks_data?: {
    access_token?: string;
  };
  build_image?: string;
  prerender?: string;
  functions_region?: string;
};

export type CreateSiteVariables = {
  body?: RequestBodies.CreateSiteSite;
  queryParams?: CreateSiteQueryParams;
} & FetcherExtraProps;

/**
 * **Note:** Environment variable keys and values have moved from `build_settings.env` and `repo.env` to a new endpoint. Please use [createEnvVars](#tag/environmentVariables/operation/createEnvVars) to create environment variables for a site.
 */
export const createSite = (variables: CreateSiteVariables, signal?: AbortSignal) =>
  fetch<CreateSiteResponse, CreateSiteError, RequestBodies.CreateSiteSite, {}, CreateSiteQueryParams, {}>({
    url: '/sites',
    method: 'post',
    ...variables,
    signal
  });

export type GetSitePathParams = {
  siteId: string;
};

export type GetSiteQueryParams = {
  feature_flags?: string;
};

export type GetSiteError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetSiteResponse = {
  id?: string;
  state?: string;
  plan?: string;
  name?: string;
  custom_domain?: string;
  domain_aliases?: string[];
  branch_deploy_custom_domain?: string;
  deploy_preview_custom_domain?: string;
  password?: string;
  notification_email?: string;
  url?: string;
  ssl_url?: string;
  admin_url?: string;
  screenshot_url?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  user_id?: string;
  session_id?: string;
  ssl?: boolean;
  force_ssl?: boolean;
  managed_dns?: boolean;
  deploy_url?: string;
  published_deploy?: {
    id?: string;
    site_id?: string;
    user_id?: string;
    build_id?: string;
    state?: string;
    name?: string;
    url?: string;
    ssl_url?: string;
    admin_url?: string;
    deploy_url?: string;
    deploy_ssl_url?: string;
    screenshot_url?: string;
    review_id?: number;
    draft?: boolean;
    required?: string[];
    required_functions?: string[];
    error_message?: string;
    branch?: string;
    commit_ref?: string;
    commit_url?: string;
    skipped?: boolean;
    /**
     * @format dateTime
     */
    created_at?: string;
    /**
     * @format dateTime
     */
    updated_at?: string;
    /**
     * @format dateTime
     */
    published_at?: string;
    title?: string;
    context?: string;
    locked?: boolean;
    review_url?: string;
    framework?: string;
    function_schedules?: {
      name?: string;
      cron?: string;
    }[];
  };
  account_name?: string;
  account_slug?: string;
  git_provider?: string;
  deploy_hook?: string;
  capabilities?: {
    [key: string]: Record<string, any>;
  };
  processing_settings?: {
    html?: {
      pretty_urls?: boolean;
    };
  };
  build_settings?: {
    id?: number;
    provider?: string;
    deploy_key_id?: string;
    repo_path?: string;
    repo_branch?: string;
    dir?: string;
    functions_dir?: string;
    cmd?: string;
    allowed_branches?: string[];
    public_repo?: boolean;
    private_logs?: boolean;
    repo_url?: string;
    env?: {
      [key: string]: string;
    };
    installation_id?: number;
    stop_builds?: boolean;
  };
  id_domain?: string;
  default_hooks_data?: {
    access_token?: string;
  };
  build_image?: string;
  prerender?: string;
  functions_region?: string;
};

export type GetSiteVariables = {
  pathParams: GetSitePathParams;
  queryParams?: GetSiteQueryParams;
} & FetcherExtraProps;

/**
 * **Note:** Environment variable keys and values have moved from `build_settings.env` and `repo.env` to a new endpoint. Please use [getEnvVars](#tag/environmentVariables/operation/getEnvVars) to retrieve site environment variables.
 */
export const getSite = (variables: GetSiteVariables, signal?: AbortSignal) =>
  fetch<GetSiteResponse, GetSiteError, undefined, {}, GetSiteQueryParams, GetSitePathParams>({
    url: '/sites/{siteId}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateSitePathParams = {
  siteId: string;
};

export type UpdateSiteError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type UpdateSiteResponse = {
  id?: string;
  state?: string;
  plan?: string;
  name?: string;
  custom_domain?: string;
  domain_aliases?: string[];
  branch_deploy_custom_domain?: string;
  deploy_preview_custom_domain?: string;
  password?: string;
  notification_email?: string;
  url?: string;
  ssl_url?: string;
  admin_url?: string;
  screenshot_url?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  user_id?: string;
  session_id?: string;
  ssl?: boolean;
  force_ssl?: boolean;
  managed_dns?: boolean;
  deploy_url?: string;
  published_deploy?: {
    id?: string;
    site_id?: string;
    user_id?: string;
    build_id?: string;
    state?: string;
    name?: string;
    url?: string;
    ssl_url?: string;
    admin_url?: string;
    deploy_url?: string;
    deploy_ssl_url?: string;
    screenshot_url?: string;
    review_id?: number;
    draft?: boolean;
    required?: string[];
    required_functions?: string[];
    error_message?: string;
    branch?: string;
    commit_ref?: string;
    commit_url?: string;
    skipped?: boolean;
    /**
     * @format dateTime
     */
    created_at?: string;
    /**
     * @format dateTime
     */
    updated_at?: string;
    /**
     * @format dateTime
     */
    published_at?: string;
    title?: string;
    context?: string;
    locked?: boolean;
    review_url?: string;
    framework?: string;
    function_schedules?: {
      name?: string;
      cron?: string;
    }[];
  };
  account_name?: string;
  account_slug?: string;
  git_provider?: string;
  deploy_hook?: string;
  capabilities?: {
    [key: string]: Record<string, any>;
  };
  processing_settings?: {
    html?: {
      pretty_urls?: boolean;
    };
  };
  build_settings?: {
    id?: number;
    provider?: string;
    deploy_key_id?: string;
    repo_path?: string;
    repo_branch?: string;
    dir?: string;
    functions_dir?: string;
    cmd?: string;
    allowed_branches?: string[];
    public_repo?: boolean;
    private_logs?: boolean;
    repo_url?: string;
    env?: {
      [key: string]: string;
    };
    installation_id?: number;
    stop_builds?: boolean;
  };
  id_domain?: string;
  default_hooks_data?: {
    access_token?: string;
  };
  build_image?: string;
  prerender?: string;
  functions_region?: string;
};

export type UpdateSiteVariables = {
  body?: RequestBodies.CreateSiteSite;
  pathParams: UpdateSitePathParams;
} & FetcherExtraProps;

/**
 * **Note:** Environment variable keys and values have moved from `build_settings.env` and `repo.env` to a new endpoint. Please use [updateEnvVar](#tag/environmentVariables/operation/updateEnvVar) to update a site's environment variables.
 */
export const updateSite = (variables: UpdateSiteVariables, signal?: AbortSignal) =>
  fetch<UpdateSiteResponse, UpdateSiteError, RequestBodies.CreateSiteSite, {}, {}, UpdateSitePathParams>({
    url: '/sites/{siteId}',
    method: 'patch',
    ...variables,
    signal
  });

export type DeleteSitePathParams = {
  siteId: string;
};

export type DeleteSiteError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type DeleteSiteVariables = {
  pathParams: DeleteSitePathParams;
} & FetcherExtraProps;

export const deleteSite = (variables: DeleteSiteVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteSiteError, undefined, {}, {}, DeleteSitePathParams>({
    url: '/sites/{siteId}',
    method: 'delete',
    ...variables,
    signal
  });

export type ProvisionSiteTLSCertificatePathParams = {
  siteId: string;
};

export type ProvisionSiteTLSCertificateQueryParams = {
  certificate?: string;
  key?: string;
  ca_certificates?: string;
};

export type ProvisionSiteTLSCertificateError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ProvisionSiteTLSCertificateResponse = {
  state?: string;
  domains?: string[];
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  /**
   * @format dateTime
   */
  expires_at?: string;
};

export type ProvisionSiteTLSCertificateVariables = {
  pathParams: ProvisionSiteTLSCertificatePathParams;
  queryParams?: ProvisionSiteTLSCertificateQueryParams;
} & FetcherExtraProps;

export const provisionSiteTLSCertificate = (variables: ProvisionSiteTLSCertificateVariables, signal?: AbortSignal) =>
  fetch<
    ProvisionSiteTLSCertificateResponse,
    ProvisionSiteTLSCertificateError,
    undefined,
    {},
    ProvisionSiteTLSCertificateQueryParams,
    ProvisionSiteTLSCertificatePathParams
  >({ url: '/sites/{siteId}/ssl', method: 'post', ...variables, signal });

export type ShowSiteTLSCertificatePathParams = {
  siteId: string;
};

export type ShowSiteTLSCertificateError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ShowSiteTLSCertificateResponse = {
  state?: string;
  domains?: string[];
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  /**
   * @format dateTime
   */
  expires_at?: string;
};

export type ShowSiteTLSCertificateVariables = {
  pathParams: ShowSiteTLSCertificatePathParams;
} & FetcherExtraProps;

export const showSiteTLSCertificate = (variables: ShowSiteTLSCertificateVariables, signal?: AbortSignal) =>
  fetch<
    ShowSiteTLSCertificateResponse,
    ShowSiteTLSCertificateError,
    undefined,
    {},
    {},
    ShowSiteTLSCertificatePathParams
  >({ url: '/sites/{siteId}/ssl', method: 'get', ...variables, signal });

export type GetEnvVarsPathParams = {
  /**
   * Scope response to account_id
   */
  accountId: string;
};

export type GetEnvVarsQueryParams = {
  /**
   * Filter by deploy context
   */
  context_name?: 'all' | 'dev' | 'branch-deploy' | 'deploy-preview' | 'production';
  /**
   * Filter by scope
   */
  scope?: 'builds' | 'functions' | 'runtime' | 'post-processing';
  /**
   * If specified, only return environment variables set on this site
   */
  site_id?: string;
};

export type GetEnvVarsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetEnvVarsResponse = {
  /**
   * The environment variable key, like ALGOLIA_ID (case-sensitive)
   *
   * @x-faker commerce.productName
   */
  key?: string;
  /**
   * The scopes that this environment variable is set to
   */
  scopes?: ('builds' | 'functions' | 'runtime' | 'post-processing')[];
  /**
   * An array of Value objects containing values and metadata
   *
   * @x-faker internet.password
   */
  values?: {
    /**
     * The environment variable value's universally unique ID
     *
     * @x-faker datatype.uuid
     */
    id?: string;
    /**
     * The environment variable's unencrypted value
     *
     * @x-faker internet.password
     */
    value?: string;
    /**
     * The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`.
     */
    context?: 'all' | 'dev' | 'branch-deploy' | 'deploy-preview' | 'production' | 'branch';
    /**
     * An additional parameter for custom branches. Currently, this is used for specifying a branch name when `context=branch`.
     */
    context_parameter?: string;
  }[];
  /**
   * Secret values are only readable by code running on Netlify’s systems. With secrets, only the local development context values are readable from the UI, API, and CLI. By default, environment variable values are not secret. (Enterprise plans only)
   */
  is_secret?: boolean;
  /**
   * The timestamp of when the value was last updated
   *
   * @format date-time
   * @x-faker date.past
   */
  updated_at?: string;
  updated_by?: {
    /**
     * The user's unique identifier
     *
     * @x-faker datatype.number
     */
    id?: string;
    /**
     * The user's full name (first and last)
     *
     * @x-faker name.findName
     */
    full_name?: string;
    /**
     * The user's email address
     *
     * @x-faker internet.email
     */
    email?: string;
    /**
     * A URL pointing to the user's avatar
     *
     * @x-faker internet.avatar
     */
    avatar_url?: string;
  };
}[];

export type GetEnvVarsVariables = {
  pathParams: GetEnvVarsPathParams;
  queryParams?: GetEnvVarsQueryParams;
} & FetcherExtraProps;

/**
 * Returns all environment variables for an account or site. An account corresponds to a team in the Netlify UI. To use this endpoint, your site must no longer be using the <a href="https://docs.netlify.com/environment-variables/classic-experience/">classic environment variables experience</a>.  Migrate now with the Netlify UI.
 */
export const getEnvVars = (variables: GetEnvVarsVariables, signal?: AbortSignal) =>
  fetch<GetEnvVarsResponse, GetEnvVarsError, undefined, {}, GetEnvVarsQueryParams, GetEnvVarsPathParams>({
    url: '/accounts/{accountId}/env',
    method: 'get',
    ...variables,
    signal
  });

export type CreateEnvVarsPathParams = {
  /**
   * Scope response to account_id
   */
  accountId: string;
};

export type CreateEnvVarsQueryParams = {
  /**
   * If provided, create an environment variable on the site level, not the account level
   */
  site_id?: string;
};

export type CreateEnvVarsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreateEnvVarsResponse = {
  /**
   * The environment variable key, like ALGOLIA_ID (case-sensitive)
   *
   * @x-faker commerce.productName
   */
  key?: string;
  /**
   * The scopes that this environment variable is set to
   */
  scopes?: ('builds' | 'functions' | 'runtime' | 'post-processing')[];
  /**
   * An array of Value objects containing values and metadata
   *
   * @x-faker internet.password
   */
  values?: {
    /**
     * The environment variable value's universally unique ID
     *
     * @x-faker datatype.uuid
     */
    id?: string;
    /**
     * The environment variable's unencrypted value
     *
     * @x-faker internet.password
     */
    value?: string;
    /**
     * The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`.
     */
    context?: 'all' | 'dev' | 'branch-deploy' | 'deploy-preview' | 'production' | 'branch';
    /**
     * An additional parameter for custom branches. Currently, this is used for specifying a branch name when `context=branch`.
     */
    context_parameter?: string;
  }[];
  /**
   * Secret values are only readable by code running on Netlify’s systems. With secrets, only the local development context values are readable from the UI, API, and CLI. By default, environment variable values are not secret. (Enterprise plans only)
   */
  is_secret?: boolean;
  /**
   * The timestamp of when the value was last updated
   *
   * @format date-time
   * @x-faker date.past
   */
  updated_at?: string;
  updated_by?: {
    /**
     * The user's unique identifier
     *
     * @x-faker datatype.number
     */
    id?: string;
    /**
     * The user's full name (first and last)
     *
     * @x-faker name.findName
     */
    full_name?: string;
    /**
     * The user's email address
     *
     * @x-faker internet.email
     */
    email?: string;
    /**
     * A URL pointing to the user's avatar
     *
     * @x-faker internet.avatar
     */
    avatar_url?: string;
  };
}[];

export type CreateEnvVarsRequestBody = {
  /**
   * The existing or new name of the key, if you wish to rename it (case-sensitive)
   */
  key?: string;
  /**
   * The scopes that this environment variable is set to (Pro plans and above)
   */
  scopes?: ('builds' | 'functions' | 'runtime' | 'post-processing')[];
  values?: {
    /**
     * The environment variable value's universally unique ID
     *
     * @x-faker datatype.uuid
     */
    id?: string;
    /**
     * The environment variable's unencrypted value
     *
     * @x-faker internet.password
     */
    value?: string;
    /**
     * The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`.
     */
    context?: 'all' | 'dev' | 'branch-deploy' | 'deploy-preview' | 'production' | 'branch';
    /**
     * An additional parameter for custom branches. Currently, this is used for specifying a branch name when `context=branch`.
     */
    context_parameter?: string;
  }[];
  /**
   * Secret values are only readable by code running on Netlify’s systems. With secrets, only the local development context values are readable from the UI, API, and CLI. By default, environment variable values are not secret. (Enterprise plans only)
   */
  is_secret?: boolean;
}[];

export type CreateEnvVarsVariables = {
  body?: CreateEnvVarsRequestBody;
  pathParams: CreateEnvVarsPathParams;
  queryParams?: CreateEnvVarsQueryParams;
} & FetcherExtraProps;

/**
 * Creates new environment variables. Granular scopes are available on Pro plans and above.  To use this endpoint, your site must no longer be using the <a href="https://docs.netlify.com/environment-variables/classic-experience/">classic environment variables experience</a>.  Migrate now with the Netlify UI.
 */
export const createEnvVars = (variables: CreateEnvVarsVariables, signal?: AbortSignal) =>
  fetch<
    CreateEnvVarsResponse,
    CreateEnvVarsError,
    CreateEnvVarsRequestBody,
    {},
    CreateEnvVarsQueryParams,
    CreateEnvVarsPathParams
  >({ url: '/accounts/{accountId}/env', method: 'post', ...variables, signal });

export type GetSiteEnvVarsPathParams = {
  /**
   * Scope response to site_id
   */
  siteId: string;
};

export type GetSiteEnvVarsQueryParams = {
  /**
   * Filter by deploy context
   */
  context_name?: 'all' | 'dev' | 'branch-deploy' | 'deploy-preview' | 'production';
  /**
   * Filter by scope
   */
  scope?: 'builds' | 'functions' | 'runtime' | 'post_processing';
};

export type GetSiteEnvVarsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetSiteEnvVarsResponse = {
  /**
   * The environment variable key, like ALGOLIA_ID (case-sensitive)
   *
   * @x-faker commerce.productName
   */
  key?: string;
  /**
   * The scopes that this environment variable is set to
   */
  scopes?: ('builds' | 'functions' | 'runtime' | 'post-processing')[];
  /**
   * An array of Value objects containing values and metadata
   *
   * @x-faker internet.password
   */
  values?: {
    /**
     * The environment variable value's universally unique ID
     *
     * @x-faker datatype.uuid
     */
    id?: string;
    /**
     * The environment variable's unencrypted value
     *
     * @x-faker internet.password
     */
    value?: string;
    /**
     * The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`.
     */
    context?: 'all' | 'dev' | 'branch-deploy' | 'deploy-preview' | 'production' | 'branch';
    /**
     * An additional parameter for custom branches. Currently, this is used for specifying a branch name when `context=branch`.
     */
    context_parameter?: string;
  }[];
  /**
   * Secret values are only readable by code running on Netlify’s systems. With secrets, only the local development context values are readable from the UI, API, and CLI. By default, environment variable values are not secret. (Enterprise plans only)
   */
  is_secret?: boolean;
  /**
   * The timestamp of when the value was last updated
   *
   * @format date-time
   * @x-faker date.past
   */
  updated_at?: string;
  updated_by?: {
    /**
     * The user's unique identifier
     *
     * @x-faker datatype.number
     */
    id?: string;
    /**
     * The user's full name (first and last)
     *
     * @x-faker name.findName
     */
    full_name?: string;
    /**
     * The user's email address
     *
     * @x-faker internet.email
     */
    email?: string;
    /**
     * A URL pointing to the user's avatar
     *
     * @x-faker internet.avatar
     */
    avatar_url?: string;
  };
}[];

export type GetSiteEnvVarsVariables = {
  pathParams: GetSiteEnvVarsPathParams;
  queryParams?: GetSiteEnvVarsQueryParams;
} & FetcherExtraProps;

/**
 * Returns all environment variables for a site. This convenience method behaves the same as `getEnvVars` but doesn't require an `account_id` as input.
 */
export const getSiteEnvVars = (variables: GetSiteEnvVarsVariables, signal?: AbortSignal) =>
  fetch<
    GetSiteEnvVarsResponse,
    GetSiteEnvVarsError,
    undefined,
    {},
    GetSiteEnvVarsQueryParams,
    GetSiteEnvVarsPathParams
  >({ url: '/api/v1/sites/{siteId}/env', method: 'get', ...variables, signal });

export type GetEnvVarPathParams = {
  /**
   * Scope response to account_id
   */
  accountId: string;
  /**
   * The environment variable key (case-sensitive)
   */
  key: string;
};

export type GetEnvVarQueryParams = {
  /**
   * If provided, return the environment variable for a specific site (no merging is performed)
   */
  site_id?: string;
};

export type GetEnvVarError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetEnvVarResponse = {
  /**
   * The environment variable key, like ALGOLIA_ID (case-sensitive)
   *
   * @x-faker commerce.productName
   */
  key?: string;
  /**
   * The scopes that this environment variable is set to
   */
  scopes?: ('builds' | 'functions' | 'runtime' | 'post-processing')[];
  /**
   * An array of Value objects containing values and metadata
   *
   * @x-faker internet.password
   */
  values?: {
    /**
     * The environment variable value's universally unique ID
     *
     * @x-faker datatype.uuid
     */
    id?: string;
    /**
     * The environment variable's unencrypted value
     *
     * @x-faker internet.password
     */
    value?: string;
    /**
     * The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`.
     */
    context?: 'all' | 'dev' | 'branch-deploy' | 'deploy-preview' | 'production' | 'branch';
    /**
     * An additional parameter for custom branches. Currently, this is used for specifying a branch name when `context=branch`.
     */
    context_parameter?: string;
  }[];
  /**
   * Secret values are only readable by code running on Netlify’s systems. With secrets, only the local development context values are readable from the UI, API, and CLI. By default, environment variable values are not secret. (Enterprise plans only)
   */
  is_secret?: boolean;
  /**
   * The timestamp of when the value was last updated
   *
   * @format date-time
   * @x-faker date.past
   */
  updated_at?: string;
  updated_by?: {
    /**
     * The user's unique identifier
     *
     * @x-faker datatype.number
     */
    id?: string;
    /**
     * The user's full name (first and last)
     *
     * @x-faker name.findName
     */
    full_name?: string;
    /**
     * The user's email address
     *
     * @x-faker internet.email
     */
    email?: string;
    /**
     * A URL pointing to the user's avatar
     *
     * @x-faker internet.avatar
     */
    avatar_url?: string;
  };
};

export type GetEnvVarVariables = {
  pathParams: GetEnvVarPathParams;
  queryParams?: GetEnvVarQueryParams;
} & FetcherExtraProps;

/**
 * Returns an individual environment variable. To use this endpoint, your site must no longer be using the <a href="https://docs.netlify.com/environment-variables/classic-experience/">classic environment variables experience</a>.  Migrate now with the Netlify UI.
 */
export const getEnvVar = (variables: GetEnvVarVariables, signal?: AbortSignal) =>
  fetch<GetEnvVarResponse, GetEnvVarError, undefined, {}, GetEnvVarQueryParams, GetEnvVarPathParams>({
    url: '/accounts/{accountId}/env/{key}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateEnvVarPathParams = {
  /**
   * Scope response to account_id
   */
  accountId: string;
  /**
   * The existing environment variable key name (case-sensitive)
   */
  key: string;
};

export type UpdateEnvVarQueryParams = {
  /**
   * If provided, update an environment variable set on this site
   */
  site_id?: string;
};

export type UpdateEnvVarError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type UpdateEnvVarResponse = {
  /**
   * The environment variable key, like ALGOLIA_ID (case-sensitive)
   *
   * @x-faker commerce.productName
   */
  key?: string;
  /**
   * The scopes that this environment variable is set to
   */
  scopes?: ('builds' | 'functions' | 'runtime' | 'post-processing')[];
  /**
   * An array of Value objects containing values and metadata
   *
   * @x-faker internet.password
   */
  values?: {
    /**
     * The environment variable value's universally unique ID
     *
     * @x-faker datatype.uuid
     */
    id?: string;
    /**
     * The environment variable's unencrypted value
     *
     * @x-faker internet.password
     */
    value?: string;
    /**
     * The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`.
     */
    context?: 'all' | 'dev' | 'branch-deploy' | 'deploy-preview' | 'production' | 'branch';
    /**
     * An additional parameter for custom branches. Currently, this is used for specifying a branch name when `context=branch`.
     */
    context_parameter?: string;
  }[];
  /**
   * Secret values are only readable by code running on Netlify’s systems. With secrets, only the local development context values are readable from the UI, API, and CLI. By default, environment variable values are not secret. (Enterprise plans only)
   */
  is_secret?: boolean;
  /**
   * The timestamp of when the value was last updated
   *
   * @format date-time
   * @x-faker date.past
   */
  updated_at?: string;
  updated_by?: {
    /**
     * The user's unique identifier
     *
     * @x-faker datatype.number
     */
    id?: string;
    /**
     * The user's full name (first and last)
     *
     * @x-faker name.findName
     */
    full_name?: string;
    /**
     * The user's email address
     *
     * @x-faker internet.email
     */
    email?: string;
    /**
     * A URL pointing to the user's avatar
     *
     * @x-faker internet.avatar
     */
    avatar_url?: string;
  };
};

export type UpdateEnvVarRequestBody = {
  /**
   * The existing or new name of the key, if you wish to rename it (case-sensitive)
   */
  key?: string;
  /**
   * The scopes that this environment variable is set to (Pro plans and above)
   */
  scopes?: ('builds' | 'functions' | 'runtime' | 'post-processing')[];
  values?: {
    /**
     * The environment variable value's universally unique ID
     *
     * @x-faker datatype.uuid
     */
    id?: string;
    /**
     * The environment variable's unencrypted value
     *
     * @x-faker internet.password
     */
    value?: string;
    /**
     * The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`.
     */
    context?: 'all' | 'dev' | 'branch-deploy' | 'deploy-preview' | 'production' | 'branch';
    /**
     * An additional parameter for custom branches. Currently, this is used for specifying a branch name when `context=branch`.
     */
    context_parameter?: string;
  }[];
  /**
   * Secret values are only readable by code running on Netlify’s systems. With secrets, only the local development context values are readable from the UI, API, and CLI. By default, environment variable values are not secret. (Enterprise plans only)
   */
  is_secret?: boolean;
};

export type UpdateEnvVarVariables = {
  body?: UpdateEnvVarRequestBody;
  pathParams: UpdateEnvVarPathParams;
  queryParams?: UpdateEnvVarQueryParams;
} & FetcherExtraProps;

/**
 * Updates an existing environment variable and all of its values. Existing values will be replaced by values provided. To use this endpoint, your site must no longer be using the <a href="https://docs.netlify.com/environment-variables/classic-experience/">classic environment variables experience</a>.  Migrate now with the Netlify UI.
 */
export const updateEnvVar = (variables: UpdateEnvVarVariables, signal?: AbortSignal) =>
  fetch<
    UpdateEnvVarResponse,
    UpdateEnvVarError,
    UpdateEnvVarRequestBody,
    {},
    UpdateEnvVarQueryParams,
    UpdateEnvVarPathParams
  >({ url: '/accounts/{accountId}/env/{key}', method: 'put', ...variables, signal });

export type SetEnvVarValuePathParams = {
  /**
   * Scope response to account_id
   */
  accountId: string;
  /**
   * The existing environment variable key name (case-sensitive)
   */
  key: string;
};

export type SetEnvVarValueQueryParams = {
  /**
   * If provided, update an environment variable set on this site
   */
  site_id?: string;
};

export type SetEnvVarValueError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type SetEnvVarValueResponse = {
  /**
   * The environment variable key, like ALGOLIA_ID (case-sensitive)
   *
   * @x-faker commerce.productName
   */
  key?: string;
  /**
   * The scopes that this environment variable is set to
   */
  scopes?: ('builds' | 'functions' | 'runtime' | 'post-processing')[];
  /**
   * An array of Value objects containing values and metadata
   *
   * @x-faker internet.password
   */
  values?: {
    /**
     * The environment variable value's universally unique ID
     *
     * @x-faker datatype.uuid
     */
    id?: string;
    /**
     * The environment variable's unencrypted value
     *
     * @x-faker internet.password
     */
    value?: string;
    /**
     * The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`.
     */
    context?: 'all' | 'dev' | 'branch-deploy' | 'deploy-preview' | 'production' | 'branch';
    /**
     * An additional parameter for custom branches. Currently, this is used for specifying a branch name when `context=branch`.
     */
    context_parameter?: string;
  }[];
  /**
   * Secret values are only readable by code running on Netlify’s systems. With secrets, only the local development context values are readable from the UI, API, and CLI. By default, environment variable values are not secret. (Enterprise plans only)
   */
  is_secret?: boolean;
  /**
   * The timestamp of when the value was last updated
   *
   * @format date-time
   * @x-faker date.past
   */
  updated_at?: string;
  updated_by?: {
    /**
     * The user's unique identifier
     *
     * @x-faker datatype.number
     */
    id?: string;
    /**
     * The user's full name (first and last)
     *
     * @x-faker name.findName
     */
    full_name?: string;
    /**
     * The user's email address
     *
     * @x-faker internet.email
     */
    email?: string;
    /**
     * A URL pointing to the user's avatar
     *
     * @x-faker internet.avatar
     */
    avatar_url?: string;
  };
};

export type SetEnvVarValueRequestBody = {
  /**
   * The deploy context in which this value will be used. `dev` refers to local development when running `netlify dev`. `branch` must be provided with a value in `context_parameter`.
   */
  context?: 'all' | 'dev' | 'branch-deploy' | 'deploy-preview' | 'production' | 'branch';
  /**
   * An additional parameter for custom branches. Currently, this is used for providing a branch name when `context=branch`.
   */
  context_parameter?: string;
  /**
   * The environment variable's unencrypted value
   */
  value?: string;
};

export type SetEnvVarValueVariables = {
  body?: SetEnvVarValueRequestBody;
  pathParams: SetEnvVarValuePathParams;
  queryParams?: SetEnvVarValueQueryParams;
} & FetcherExtraProps;

/**
 * Updates or creates a new value for an existing environment variable. To use this endpoint, your site must no longer be using the <a href="https://docs.netlify.com/environment-variables/classic-experience/">classic environment variables experience</a>.  Migrate now with the Netlify UI.
 */
export const setEnvVarValue = (variables: SetEnvVarValueVariables, signal?: AbortSignal) =>
  fetch<
    SetEnvVarValueResponse,
    SetEnvVarValueError,
    SetEnvVarValueRequestBody,
    {},
    SetEnvVarValueQueryParams,
    SetEnvVarValuePathParams
  >({ url: '/accounts/{accountId}/env/{key}', method: 'patch', ...variables, signal });

export type DeleteEnvVarPathParams = {
  /**
   * Scope response to account_id
   */
  accountId: string;
  /**
   * The environment variable key (case-sensitive)
   */
  key: string;
};

export type DeleteEnvVarQueryParams = {
  /**
   * If provided, delete the environment variable from this site
   */
  site_id?: string;
};

export type DeleteEnvVarError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type DeleteEnvVarVariables = {
  pathParams: DeleteEnvVarPathParams;
  queryParams?: DeleteEnvVarQueryParams;
} & FetcherExtraProps;

/**
 * Deletes an environment variable. To use this endpoint, your site must no longer be using the <a href="https://docs.netlify.com/environment-variables/classic-experience/">classic environment variables experience</a>.  Migrate now with the Netlify UI.
 */
export const deleteEnvVar = (variables: DeleteEnvVarVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteEnvVarError, undefined, {}, DeleteEnvVarQueryParams, DeleteEnvVarPathParams>({
    url: '/accounts/{accountId}/env/{key}',
    method: 'delete',
    ...variables,
    signal
  });

export type DeleteEnvVarValuePathParams = {
  /**
   * Scope response to account_id
   */
  accountId: string;
  /**
   * The environment variable value's ID
   */
  id: string;
  /**
   * The environment variable key name (case-sensitive)
   */
  key: string;
};

export type DeleteEnvVarValueQueryParams = {
  /**
   * If provided, delete the value from an environment variable on this site
   */
  site_id?: string;
};

export type DeleteEnvVarValueError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type DeleteEnvVarValueVariables = {
  pathParams: DeleteEnvVarValuePathParams;
  queryParams?: DeleteEnvVarValueQueryParams;
} & FetcherExtraProps;

/**
 * Deletes a specific environment variable value. To use this endpoint, your site must no longer be using the <a href="https://docs.netlify.com/environment-variables/classic-experience/">classic environment variables experience</a>.  Migrate now with the Netlify UI.
 */
export const deleteEnvVarValue = (variables: DeleteEnvVarValueVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteEnvVarValueError, undefined, {}, DeleteEnvVarValueQueryParams, DeleteEnvVarValuePathParams>({
    url: '/accounts/{accountId}/env/{key}/value/{id}',
    method: 'delete',
    ...variables,
    signal
  });

export type SearchSiteFunctionsPathParams = {
  siteId: string;
};

export type SearchSiteFunctionsQueryParams = {
  filter?: string;
};

export type SearchSiteFunctionsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type SearchSiteFunctionsResponse = {
  branch?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  functions?: Record<string, any>[];
  id?: string;
  log_type?: string;
  provider?: string;
}[];

export type SearchSiteFunctionsVariables = {
  pathParams: SearchSiteFunctionsPathParams;
  queryParams?: SearchSiteFunctionsQueryParams;
} & FetcherExtraProps;

export const searchSiteFunctions = (variables: SearchSiteFunctionsVariables, signal?: AbortSignal) =>
  fetch<
    SearchSiteFunctionsResponse,
    SearchSiteFunctionsError,
    undefined,
    {},
    SearchSiteFunctionsQueryParams,
    SearchSiteFunctionsPathParams
  >({ url: '/sites/{siteId}/functions', method: 'get', ...variables, signal });

export type ListSiteFormsPathParams = {
  siteId: string;
};

export type ListSiteFormsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListSiteFormsResponse = {
  id?: string;
  site_id?: string;
  name?: string;
  paths?: string[];
  /**
   * @format int32
   */
  submission_count?: number;
  fields?: Record<string, any>[];
  /**
   * @format dateTime
   */
  created_at?: string;
}[];

export type ListSiteFormsVariables = {
  pathParams: ListSiteFormsPathParams;
} & FetcherExtraProps;

export const listSiteForms = (variables: ListSiteFormsVariables, signal?: AbortSignal) =>
  fetch<ListSiteFormsResponse, ListSiteFormsError, undefined, {}, {}, ListSiteFormsPathParams>({
    url: '/sites/{siteId}/forms',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteSiteFormPathParams = {
  siteId: string;
  formId: string;
};

export type DeleteSiteFormError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type DeleteSiteFormVariables = {
  pathParams: DeleteSiteFormPathParams;
} & FetcherExtraProps;

export const deleteSiteForm = (variables: DeleteSiteFormVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteSiteFormError, undefined, {}, {}, DeleteSiteFormPathParams>({
    url: '/sites/{siteId}/forms/{formId}',
    method: 'delete',
    ...variables,
    signal
  });

export type ListSiteSubmissionsPathParams = {
  siteId: string;
};

export type ListSiteSubmissionsQueryParams = {
  /**
   * @format int32
   */
  page?: number;
  /**
   * @format int32
   */
  per_page?: number;
};

export type ListSiteSubmissionsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListSiteSubmissionsResponse = {
  id?: string;
  /**
   * @format int32
   */
  number?: number;
  email?: string;
  name?: string;
  first_name?: string;
  last_name?: string;
  company?: string;
  summary?: string;
  body?: string;
  data?: Record<string, any>;
  /**
   * @format dateTime
   */
  created_at?: string;
  site_url?: string;
}[];

export type ListSiteSubmissionsVariables = {
  pathParams: ListSiteSubmissionsPathParams;
  queryParams?: ListSiteSubmissionsQueryParams;
} & FetcherExtraProps;

export const listSiteSubmissions = (variables: ListSiteSubmissionsVariables, signal?: AbortSignal) =>
  fetch<
    ListSiteSubmissionsResponse,
    ListSiteSubmissionsError,
    undefined,
    {},
    ListSiteSubmissionsQueryParams,
    ListSiteSubmissionsPathParams
  >({ url: '/sites/{siteId}/submissions', method: 'get', ...variables, signal });

export type ListSiteFilesPathParams = {
  siteId: string;
};

export type ListSiteFilesError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListSiteFilesResponse = {
  id?: string;
  path?: string;
  sha?: string;
  mime_type?: string;
  /**
   * @format int64
   */
  size?: number;
}[];

export type ListSiteFilesVariables = {
  pathParams: ListSiteFilesPathParams;
} & FetcherExtraProps;

export const listSiteFiles = (variables: ListSiteFilesVariables, signal?: AbortSignal) =>
  fetch<ListSiteFilesResponse, ListSiteFilesError, undefined, {}, {}, ListSiteFilesPathParams>({
    url: '/sites/{siteId}/files',
    method: 'get',
    ...variables,
    signal
  });

export type ListSiteAssetsPathParams = {
  siteId: string;
};

export type ListSiteAssetsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListSiteAssetsResponse = {
  id?: string;
  site_id?: string;
  creator_id?: string;
  name?: string;
  state?: string;
  content_type?: string;
  url?: string;
  key?: string;
  visibility?: string;
  /**
   * @format int64
   */
  size?: number;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
}[];

export type ListSiteAssetsVariables = {
  pathParams: ListSiteAssetsPathParams;
} & FetcherExtraProps;

export const listSiteAssets = (variables: ListSiteAssetsVariables, signal?: AbortSignal) =>
  fetch<ListSiteAssetsResponse, ListSiteAssetsError, undefined, {}, {}, ListSiteAssetsPathParams>({
    url: '/sites/{siteId}/assets',
    method: 'get',
    ...variables,
    signal
  });

export type CreateSiteAssetPathParams = {
  siteId: string;
};

export type CreateSiteAssetQueryParams = {
  name: string;
  /**
   * @format int64
   */
  size: number;
  content_type: string;
  visibility?: string;
};

export type CreateSiteAssetError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreateSiteAssetResponse = {
  form?: {
    url?: string;
    fields?: {
      [key: string]: string;
    };
  };
  asset?: {
    id?: string;
    site_id?: string;
    creator_id?: string;
    name?: string;
    state?: string;
    content_type?: string;
    url?: string;
    key?: string;
    visibility?: string;
    /**
     * @format int64
     */
    size?: number;
    /**
     * @format dateTime
     */
    created_at?: string;
    /**
     * @format dateTime
     */
    updated_at?: string;
  };
};

export type CreateSiteAssetVariables = {
  pathParams: CreateSiteAssetPathParams;
  queryParams: CreateSiteAssetQueryParams;
} & FetcherExtraProps;

export const createSiteAsset = (variables: CreateSiteAssetVariables, signal?: AbortSignal) =>
  fetch<
    CreateSiteAssetResponse,
    CreateSiteAssetError,
    undefined,
    {},
    CreateSiteAssetQueryParams,
    CreateSiteAssetPathParams
  >({ url: '/sites/{siteId}/assets', method: 'post', ...variables, signal });

export type GetSiteAssetInfoPathParams = {
  siteId: string;
  assetId: string;
};

export type GetSiteAssetInfoError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetSiteAssetInfoResponse = {
  id?: string;
  site_id?: string;
  creator_id?: string;
  name?: string;
  state?: string;
  content_type?: string;
  url?: string;
  key?: string;
  visibility?: string;
  /**
   * @format int64
   */
  size?: number;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
};

export type GetSiteAssetInfoVariables = {
  pathParams: GetSiteAssetInfoPathParams;
} & FetcherExtraProps;

export const getSiteAssetInfo = (variables: GetSiteAssetInfoVariables, signal?: AbortSignal) =>
  fetch<GetSiteAssetInfoResponse, GetSiteAssetInfoError, undefined, {}, {}, GetSiteAssetInfoPathParams>({
    url: '/sites/{siteId}/assets/{assetId}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateSiteAssetPathParams = {
  siteId: string;
  assetId: string;
};

export type UpdateSiteAssetQueryParams = {
  state: string;
};

export type UpdateSiteAssetError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type UpdateSiteAssetResponse = {
  id?: string;
  site_id?: string;
  creator_id?: string;
  name?: string;
  state?: string;
  content_type?: string;
  url?: string;
  key?: string;
  visibility?: string;
  /**
   * @format int64
   */
  size?: number;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
};

export type UpdateSiteAssetVariables = {
  pathParams: UpdateSiteAssetPathParams;
  queryParams: UpdateSiteAssetQueryParams;
} & FetcherExtraProps;

export const updateSiteAsset = (variables: UpdateSiteAssetVariables, signal?: AbortSignal) =>
  fetch<
    UpdateSiteAssetResponse,
    UpdateSiteAssetError,
    undefined,
    {},
    UpdateSiteAssetQueryParams,
    UpdateSiteAssetPathParams
  >({ url: '/sites/{siteId}/assets/{assetId}', method: 'put', ...variables, signal });

export type DeleteSiteAssetPathParams = {
  siteId: string;
  assetId: string;
};

export type DeleteSiteAssetError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type DeleteSiteAssetVariables = {
  pathParams: DeleteSiteAssetPathParams;
} & FetcherExtraProps;

export const deleteSiteAsset = (variables: DeleteSiteAssetVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteSiteAssetError, undefined, {}, {}, DeleteSiteAssetPathParams>({
    url: '/sites/{siteId}/assets/{assetId}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetSiteAssetPublicSignaturePathParams = {
  siteId: string;
  assetId: string;
};

export type GetSiteAssetPublicSignatureError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetSiteAssetPublicSignatureResponse = {
  url?: string;
};

export type GetSiteAssetPublicSignatureVariables = {
  pathParams: GetSiteAssetPublicSignaturePathParams;
} & FetcherExtraProps;

export const getSiteAssetPublicSignature = (variables: GetSiteAssetPublicSignatureVariables, signal?: AbortSignal) =>
  fetch<
    GetSiteAssetPublicSignatureResponse,
    GetSiteAssetPublicSignatureError,
    undefined,
    {},
    {},
    GetSiteAssetPublicSignaturePathParams
  >({ url: '/sites/{siteId}/assets/{assetId}/public_signature', method: 'get', ...variables, signal });

export type GetSiteFileByPathNamePathParams = {
  siteId: string;
  filePath: string;
};

export type GetSiteFileByPathNameError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetSiteFileByPathNameResponse = {
  id?: string;
  path?: string;
  sha?: string;
  mime_type?: string;
  /**
   * @format int64
   */
  size?: number;
};

export type GetSiteFileByPathNameVariables = {
  pathParams: GetSiteFileByPathNamePathParams;
} & FetcherExtraProps;

export const getSiteFileByPathName = (variables: GetSiteFileByPathNameVariables, signal?: AbortSignal) =>
  fetch<GetSiteFileByPathNameResponse, GetSiteFileByPathNameError, undefined, {}, {}, GetSiteFileByPathNamePathParams>({
    url: '/sites/{siteId}/files/{filePath}',
    method: 'get',
    ...variables,
    signal
  });

export type PurgeCacheError = Fetcher.ErrorWrapper<undefined>;

export type PurgeCacheRequestBody = {
  site_id?: string;
  site_slug?: string;
  cache_tags?: string[];
};

export type PurgeCacheVariables = {
  body?: PurgeCacheRequestBody;
} & FetcherExtraProps;

/**
 * Purges cached content from Netlify's CDN. Supports purging by Cache-Tag.
 */
export const purgeCache = (variables: PurgeCacheVariables, signal?: AbortSignal) =>
  fetch<undefined, PurgeCacheError, PurgeCacheRequestBody, {}, {}, {}>({
    url: '/purge',
    method: 'post',
    ...variables,
    signal
  });

export type ListSiteSnippetsPathParams = {
  siteId: string;
};

export type ListSiteSnippetsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListSiteSnippetsResponse = {
  /**
   * @format int32
   */
  id?: number;
  site_id?: string;
  title?: string;
  general?: string;
  general_position?: string;
  goal?: string;
  goal_position?: string;
}[];

export type ListSiteSnippetsVariables = {
  pathParams: ListSiteSnippetsPathParams;
} & FetcherExtraProps;

export const listSiteSnippets = (variables: ListSiteSnippetsVariables, signal?: AbortSignal) =>
  fetch<ListSiteSnippetsResponse, ListSiteSnippetsError, undefined, {}, {}, ListSiteSnippetsPathParams>({
    url: '/sites/{siteId}/snippets',
    method: 'get',
    ...variables,
    signal
  });

export type CreateSiteSnippetPathParams = {
  siteId: string;
};

export type CreateSiteSnippetError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreateSiteSnippetResponse = {
  /**
   * @format int32
   */
  id?: number;
  site_id?: string;
  title?: string;
  general?: string;
  general_position?: string;
  goal?: string;
  goal_position?: string;
};

export type CreateSiteSnippetVariables = {
  body?: RequestBodies.CreateSiteSnippetSnippet;
  pathParams: CreateSiteSnippetPathParams;
} & FetcherExtraProps;

export const createSiteSnippet = (variables: CreateSiteSnippetVariables, signal?: AbortSignal) =>
  fetch<
    CreateSiteSnippetResponse,
    CreateSiteSnippetError,
    RequestBodies.CreateSiteSnippetSnippet,
    {},
    {},
    CreateSiteSnippetPathParams
  >({ url: '/sites/{siteId}/snippets', method: 'post', ...variables, signal });

export type GetSiteSnippetPathParams = {
  siteId: string;
  snippetId: string;
};

export type GetSiteSnippetError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetSiteSnippetResponse = {
  /**
   * @format int32
   */
  id?: number;
  site_id?: string;
  title?: string;
  general?: string;
  general_position?: string;
  goal?: string;
  goal_position?: string;
};

export type GetSiteSnippetVariables = {
  pathParams: GetSiteSnippetPathParams;
} & FetcherExtraProps;

export const getSiteSnippet = (variables: GetSiteSnippetVariables, signal?: AbortSignal) =>
  fetch<GetSiteSnippetResponse, GetSiteSnippetError, undefined, {}, {}, GetSiteSnippetPathParams>({
    url: '/sites/{siteId}/snippets/{snippetId}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateSiteSnippetPathParams = {
  siteId: string;
  snippetId: string;
};

export type UpdateSiteSnippetError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type UpdateSiteSnippetVariables = {
  body?: RequestBodies.CreateSiteSnippetSnippet;
  pathParams: UpdateSiteSnippetPathParams;
} & FetcherExtraProps;

export const updateSiteSnippet = (variables: UpdateSiteSnippetVariables, signal?: AbortSignal) =>
  fetch<undefined, UpdateSiteSnippetError, RequestBodies.CreateSiteSnippetSnippet, {}, {}, UpdateSiteSnippetPathParams>(
    { url: '/sites/{siteId}/snippets/{snippetId}', method: 'put', ...variables, signal }
  );

export type DeleteSiteSnippetPathParams = {
  siteId: string;
  snippetId: string;
};

export type DeleteSiteSnippetError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type DeleteSiteSnippetVariables = {
  pathParams: DeleteSiteSnippetPathParams;
} & FetcherExtraProps;

export const deleteSiteSnippet = (variables: DeleteSiteSnippetVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteSiteSnippetError, undefined, {}, {}, DeleteSiteSnippetPathParams>({
    url: '/sites/{siteId}/snippets/{snippetId}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetSiteMetadataPathParams = {
  siteId: string;
};

export type GetSiteMetadataError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetSiteMetadataVariables = {
  pathParams: GetSiteMetadataPathParams;
} & FetcherExtraProps;

export const getSiteMetadata = (variables: GetSiteMetadataVariables, signal?: AbortSignal) =>
  fetch<Record<string, any>, GetSiteMetadataError, undefined, {}, {}, GetSiteMetadataPathParams>({
    url: '/sites/{siteId}/metadata',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateSiteMetadataPathParams = {
  siteId: string;
};

export type UpdateSiteMetadataError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type UpdateSiteMetadataVariables = {
  body?: RequestBodies.UpdateSiteMetadataMetadata;
  pathParams: UpdateSiteMetadataPathParams;
} & FetcherExtraProps;

export const updateSiteMetadata = (variables: UpdateSiteMetadataVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    UpdateSiteMetadataError,
    RequestBodies.UpdateSiteMetadataMetadata,
    {},
    {},
    UpdateSiteMetadataPathParams
  >({ url: '/sites/{siteId}/metadata', method: 'put', ...variables, signal });

export type ListSiteBuildHooksPathParams = {
  siteId: string;
};

export type ListSiteBuildHooksError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListSiteBuildHooksResponse = {
  id?: string;
  title?: string;
  branch?: string;
  url?: string;
  site_id?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
}[];

export type ListSiteBuildHooksVariables = {
  pathParams: ListSiteBuildHooksPathParams;
} & FetcherExtraProps;

export const listSiteBuildHooks = (variables: ListSiteBuildHooksVariables, signal?: AbortSignal) =>
  fetch<ListSiteBuildHooksResponse, ListSiteBuildHooksError, undefined, {}, {}, ListSiteBuildHooksPathParams>({
    url: '/sites/{siteId}/build_hooks',
    method: 'get',
    ...variables,
    signal
  });

export type CreateSiteBuildHookPathParams = {
  siteId: string;
};

export type CreateSiteBuildHookError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreateSiteBuildHookResponse = {
  id?: string;
  title?: string;
  branch?: string;
  url?: string;
  site_id?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
};

export type CreateSiteBuildHookVariables = {
  body?: RequestBodies.CreateSiteBuildHookBuildhook;
  pathParams: CreateSiteBuildHookPathParams;
} & FetcherExtraProps;

export const createSiteBuildHook = (variables: CreateSiteBuildHookVariables, signal?: AbortSignal) =>
  fetch<
    CreateSiteBuildHookResponse,
    CreateSiteBuildHookError,
    RequestBodies.CreateSiteBuildHookBuildhook,
    {},
    {},
    CreateSiteBuildHookPathParams
  >({ url: '/sites/{siteId}/build_hooks', method: 'post', ...variables, signal });

export type GetSiteBuildHookPathParams = {
  siteId: string;
  id: string;
};

export type GetSiteBuildHookError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetSiteBuildHookResponse = {
  id?: string;
  title?: string;
  branch?: string;
  url?: string;
  site_id?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
};

export type GetSiteBuildHookVariables = {
  pathParams: GetSiteBuildHookPathParams;
} & FetcherExtraProps;

export const getSiteBuildHook = (variables: GetSiteBuildHookVariables, signal?: AbortSignal) =>
  fetch<GetSiteBuildHookResponse, GetSiteBuildHookError, undefined, {}, {}, GetSiteBuildHookPathParams>({
    url: '/sites/{siteId}/build_hooks/{id}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateSiteBuildHookPathParams = {
  siteId: string;
  id: string;
};

export type UpdateSiteBuildHookError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type UpdateSiteBuildHookVariables = {
  body?: RequestBodies.CreateSiteBuildHookBuildhook;
  pathParams: UpdateSiteBuildHookPathParams;
} & FetcherExtraProps;

export const updateSiteBuildHook = (variables: UpdateSiteBuildHookVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    UpdateSiteBuildHookError,
    RequestBodies.CreateSiteBuildHookBuildhook,
    {},
    {},
    UpdateSiteBuildHookPathParams
  >({ url: '/sites/{siteId}/build_hooks/{id}', method: 'put', ...variables, signal });

export type DeleteSiteBuildHookPathParams = {
  siteId: string;
  id: string;
};

export type DeleteSiteBuildHookError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type DeleteSiteBuildHookVariables = {
  pathParams: DeleteSiteBuildHookPathParams;
} & FetcherExtraProps;

export const deleteSiteBuildHook = (variables: DeleteSiteBuildHookVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteSiteBuildHookError, undefined, {}, {}, DeleteSiteBuildHookPathParams>({
    url: '/sites/{siteId}/build_hooks/{id}',
    method: 'delete',
    ...variables,
    signal
  });

export type ListSiteDeploysPathParams = {
  siteId: string;
};

export type ListSiteDeploysQueryParams = {
  ['deploy-previews']?: boolean;
  production?: boolean;
  state?:
    | 'new'
    | 'pending_review'
    | 'accepted'
    | 'rejected'
    | 'enqueued'
    | 'building'
    | 'uploading'
    | 'uploaded'
    | 'preparing'
    | 'prepared'
    | 'processing'
    | 'processed'
    | 'ready'
    | 'error'
    | 'retrying';
  branch?: string;
  ['latest-published']?: boolean;
  /**
   * @format int32
   */
  page?: number;
  /**
   * @format int32
   */
  per_page?: number;
};

export type ListSiteDeploysError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListSiteDeploysResponse = {
  id?: string;
  site_id?: string;
  user_id?: string;
  build_id?: string;
  state?: string;
  name?: string;
  url?: string;
  ssl_url?: string;
  admin_url?: string;
  deploy_url?: string;
  deploy_ssl_url?: string;
  screenshot_url?: string;
  review_id?: number;
  draft?: boolean;
  required?: string[];
  required_functions?: string[];
  error_message?: string;
  branch?: string;
  commit_ref?: string;
  commit_url?: string;
  skipped?: boolean;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  /**
   * @format dateTime
   */
  published_at?: string;
  title?: string;
  context?: string;
  locked?: boolean;
  review_url?: string;
  framework?: string;
  function_schedules?: {
    name?: string;
    cron?: string;
  }[];
}[];

export type ListSiteDeploysVariables = {
  pathParams: ListSiteDeploysPathParams;
  queryParams?: ListSiteDeploysQueryParams;
} & FetcherExtraProps;

export const listSiteDeploys = (variables: ListSiteDeploysVariables, signal?: AbortSignal) =>
  fetch<
    ListSiteDeploysResponse,
    ListSiteDeploysError,
    undefined,
    {},
    ListSiteDeploysQueryParams,
    ListSiteDeploysPathParams
  >({ url: '/sites/{siteId}/deploys', method: 'get', ...variables, signal });

export type CreateSiteDeployPathParams = {
  siteId: string;
};

export type CreateSiteDeployQueryParams = {
  ['deploy-previews']?: boolean;
  production?: boolean;
  state?:
    | 'new'
    | 'pending_review'
    | 'accepted'
    | 'rejected'
    | 'enqueued'
    | 'building'
    | 'uploading'
    | 'uploaded'
    | 'preparing'
    | 'prepared'
    | 'processing'
    | 'processed'
    | 'ready'
    | 'error'
    | 'retrying';
  branch?: string;
  ['latest-published']?: boolean;
  title?: string;
};

export type CreateSiteDeployError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreateSiteDeployResponse = {
  id?: string;
  site_id?: string;
  user_id?: string;
  build_id?: string;
  state?: string;
  name?: string;
  url?: string;
  ssl_url?: string;
  admin_url?: string;
  deploy_url?: string;
  deploy_ssl_url?: string;
  screenshot_url?: string;
  review_id?: number;
  draft?: boolean;
  required?: string[];
  required_functions?: string[];
  error_message?: string;
  branch?: string;
  commit_ref?: string;
  commit_url?: string;
  skipped?: boolean;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  /**
   * @format dateTime
   */
  published_at?: string;
  title?: string;
  context?: string;
  locked?: boolean;
  review_url?: string;
  framework?: string;
  function_schedules?: {
    name?: string;
    cron?: string;
  }[];
};

export type CreateSiteDeployVariables = {
  body?: RequestBodies.CreateSiteDeployDeploy;
  pathParams: CreateSiteDeployPathParams;
  queryParams?: CreateSiteDeployQueryParams;
} & FetcherExtraProps;

export const createSiteDeploy = (variables: CreateSiteDeployVariables, signal?: AbortSignal) =>
  fetch<
    CreateSiteDeployResponse,
    CreateSiteDeployError,
    RequestBodies.CreateSiteDeployDeploy,
    {},
    CreateSiteDeployQueryParams,
    CreateSiteDeployPathParams
  >({ url: '/sites/{siteId}/deploys', method: 'post', ...variables, signal });

export type GetSiteDeployPathParams = {
  siteId: string;
  deployId: string;
};

export type GetSiteDeployError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetSiteDeployResponse = {
  id?: string;
  site_id?: string;
  user_id?: string;
  build_id?: string;
  state?: string;
  name?: string;
  url?: string;
  ssl_url?: string;
  admin_url?: string;
  deploy_url?: string;
  deploy_ssl_url?: string;
  screenshot_url?: string;
  review_id?: number;
  draft?: boolean;
  required?: string[];
  required_functions?: string[];
  error_message?: string;
  branch?: string;
  commit_ref?: string;
  commit_url?: string;
  skipped?: boolean;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  /**
   * @format dateTime
   */
  published_at?: string;
  title?: string;
  context?: string;
  locked?: boolean;
  review_url?: string;
  framework?: string;
  function_schedules?: {
    name?: string;
    cron?: string;
  }[];
};

export type GetSiteDeployVariables = {
  pathParams: GetSiteDeployPathParams;
} & FetcherExtraProps;

export const getSiteDeploy = (variables: GetSiteDeployVariables, signal?: AbortSignal) =>
  fetch<GetSiteDeployResponse, GetSiteDeployError, undefined, {}, {}, GetSiteDeployPathParams>({
    url: '/sites/{siteId}/deploys/{deployId}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateSiteDeployPathParams = {
  siteId: string;
  deployId: string;
};

export type UpdateSiteDeployError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type UpdateSiteDeployResponse = {
  id?: string;
  site_id?: string;
  user_id?: string;
  build_id?: string;
  state?: string;
  name?: string;
  url?: string;
  ssl_url?: string;
  admin_url?: string;
  deploy_url?: string;
  deploy_ssl_url?: string;
  screenshot_url?: string;
  review_id?: number;
  draft?: boolean;
  required?: string[];
  required_functions?: string[];
  error_message?: string;
  branch?: string;
  commit_ref?: string;
  commit_url?: string;
  skipped?: boolean;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  /**
   * @format dateTime
   */
  published_at?: string;
  title?: string;
  context?: string;
  locked?: boolean;
  review_url?: string;
  framework?: string;
  function_schedules?: {
    name?: string;
    cron?: string;
  }[];
};

export type UpdateSiteDeployVariables = {
  body?: RequestBodies.CreateSiteDeployDeploy;
  pathParams: UpdateSiteDeployPathParams;
} & FetcherExtraProps;

export const updateSiteDeploy = (variables: UpdateSiteDeployVariables, signal?: AbortSignal) =>
  fetch<
    UpdateSiteDeployResponse,
    UpdateSiteDeployError,
    RequestBodies.CreateSiteDeployDeploy,
    {},
    {},
    UpdateSiteDeployPathParams
  >({ url: '/sites/{siteId}/deploys/{deployId}', method: 'put', ...variables, signal });

export type DeleteSiteDeployPathParams = {
  deployId: string;
  siteId: string;
};

export type DeleteSiteDeployError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type DeleteSiteDeployVariables = {
  pathParams: DeleteSiteDeployPathParams;
} & FetcherExtraProps;

export const deleteSiteDeploy = (variables: DeleteSiteDeployVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteSiteDeployError, undefined, {}, {}, DeleteSiteDeployPathParams>({
    url: '/sites/{siteId}/deploys/{deployId}',
    method: 'delete',
    ...variables,
    signal
  });

export type CancelSiteDeployPathParams = {
  deployId: string;
};

export type CancelSiteDeployError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CancelSiteDeployResponse = {
  id?: string;
  site_id?: string;
  user_id?: string;
  build_id?: string;
  state?: string;
  name?: string;
  url?: string;
  ssl_url?: string;
  admin_url?: string;
  deploy_url?: string;
  deploy_ssl_url?: string;
  screenshot_url?: string;
  review_id?: number;
  draft?: boolean;
  required?: string[];
  required_functions?: string[];
  error_message?: string;
  branch?: string;
  commit_ref?: string;
  commit_url?: string;
  skipped?: boolean;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  /**
   * @format dateTime
   */
  published_at?: string;
  title?: string;
  context?: string;
  locked?: boolean;
  review_url?: string;
  framework?: string;
  function_schedules?: {
    name?: string;
    cron?: string;
  }[];
};

export type CancelSiteDeployVariables = {
  pathParams: CancelSiteDeployPathParams;
} & FetcherExtraProps;

export const cancelSiteDeploy = (variables: CancelSiteDeployVariables, signal?: AbortSignal) =>
  fetch<CancelSiteDeployResponse, CancelSiteDeployError, undefined, {}, {}, CancelSiteDeployPathParams>({
    url: '/deploys/{deployId}/cancel',
    method: 'post',
    ...variables,
    signal
  });

export type RestoreSiteDeployPathParams = {
  siteId: string;
  deployId: string;
};

export type RestoreSiteDeployError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type RestoreSiteDeployResponse = {
  id?: string;
  site_id?: string;
  user_id?: string;
  build_id?: string;
  state?: string;
  name?: string;
  url?: string;
  ssl_url?: string;
  admin_url?: string;
  deploy_url?: string;
  deploy_ssl_url?: string;
  screenshot_url?: string;
  review_id?: number;
  draft?: boolean;
  required?: string[];
  required_functions?: string[];
  error_message?: string;
  branch?: string;
  commit_ref?: string;
  commit_url?: string;
  skipped?: boolean;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  /**
   * @format dateTime
   */
  published_at?: string;
  title?: string;
  context?: string;
  locked?: boolean;
  review_url?: string;
  framework?: string;
  function_schedules?: {
    name?: string;
    cron?: string;
  }[];
};

export type RestoreSiteDeployVariables = {
  pathParams: RestoreSiteDeployPathParams;
} & FetcherExtraProps;

export const restoreSiteDeploy = (variables: RestoreSiteDeployVariables, signal?: AbortSignal) =>
  fetch<RestoreSiteDeployResponse, RestoreSiteDeployError, undefined, {}, {}, RestoreSiteDeployPathParams>({
    url: '/sites/{siteId}/deploys/{deployId}/restore',
    method: 'post',
    ...variables,
    signal
  });

export type ListSiteBuildsPathParams = {
  siteId: string;
};

export type ListSiteBuildsQueryParams = {
  /**
   * @format int32
   */
  page?: number;
  /**
   * @format int32
   */
  per_page?: number;
};

export type ListSiteBuildsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListSiteBuildsResponse = {
  id?: string;
  deploy_id?: string;
  sha?: string;
  done?: boolean;
  error?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
}[];

export type ListSiteBuildsVariables = {
  pathParams: ListSiteBuildsPathParams;
  queryParams?: ListSiteBuildsQueryParams;
} & FetcherExtraProps;

export const listSiteBuilds = (variables: ListSiteBuildsVariables, signal?: AbortSignal) =>
  fetch<
    ListSiteBuildsResponse,
    ListSiteBuildsError,
    undefined,
    {},
    ListSiteBuildsQueryParams,
    ListSiteBuildsPathParams
  >({ url: '/sites/{siteId}/builds', method: 'get', ...variables, signal });

export type CreateSiteBuildPathParams = {
  siteId: string;
};

export type CreateSiteBuildError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreateSiteBuildResponse = {
  id?: string;
  deploy_id?: string;
  sha?: string;
  done?: boolean;
  error?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
};

export type CreateSiteBuildRequestBody = {
  image?: string;
  clear_cache?: boolean;
};

export type CreateSiteBuildVariables = {
  body?: CreateSiteBuildRequestBody;
  pathParams: CreateSiteBuildPathParams;
} & FetcherExtraProps;

export const createSiteBuild = (variables: CreateSiteBuildVariables, signal?: AbortSignal) =>
  fetch<CreateSiteBuildResponse, CreateSiteBuildError, CreateSiteBuildRequestBody, {}, {}, CreateSiteBuildPathParams>({
    url: '/sites/{siteId}/builds',
    method: 'post',
    ...variables,
    signal
  });

export type ListSiteDeployedBranchesPathParams = {
  siteId: string;
};

export type ListSiteDeployedBranchesError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListSiteDeployedBranchesResponse = {
  id?: string;
  deploy_id?: string;
  name?: string;
  slug?: string;
  url?: string;
  ssl_url?: string;
}[];

export type ListSiteDeployedBranchesVariables = {
  pathParams: ListSiteDeployedBranchesPathParams;
} & FetcherExtraProps;

export const listSiteDeployedBranches = (variables: ListSiteDeployedBranchesVariables, signal?: AbortSignal) =>
  fetch<
    ListSiteDeployedBranchesResponse,
    ListSiteDeployedBranchesError,
    undefined,
    {},
    {},
    ListSiteDeployedBranchesPathParams
  >({ url: '/sites/{siteId}/deployed-branches', method: 'get', ...variables, signal });

export type UnlinkSiteRepoPathParams = {
  siteId: string;
};

export type UnlinkSiteRepoError = Fetcher.ErrorWrapper<undefined>;

export type UnlinkSiteRepoResponse = {
  id?: string;
  state?: string;
  plan?: string;
  name?: string;
  custom_domain?: string;
  domain_aliases?: string[];
  branch_deploy_custom_domain?: string;
  deploy_preview_custom_domain?: string;
  password?: string;
  notification_email?: string;
  url?: string;
  ssl_url?: string;
  admin_url?: string;
  screenshot_url?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  user_id?: string;
  session_id?: string;
  ssl?: boolean;
  force_ssl?: boolean;
  managed_dns?: boolean;
  deploy_url?: string;
  published_deploy?: {
    id?: string;
    site_id?: string;
    user_id?: string;
    build_id?: string;
    state?: string;
    name?: string;
    url?: string;
    ssl_url?: string;
    admin_url?: string;
    deploy_url?: string;
    deploy_ssl_url?: string;
    screenshot_url?: string;
    review_id?: number;
    draft?: boolean;
    required?: string[];
    required_functions?: string[];
    error_message?: string;
    branch?: string;
    commit_ref?: string;
    commit_url?: string;
    skipped?: boolean;
    /**
     * @format dateTime
     */
    created_at?: string;
    /**
     * @format dateTime
     */
    updated_at?: string;
    /**
     * @format dateTime
     */
    published_at?: string;
    title?: string;
    context?: string;
    locked?: boolean;
    review_url?: string;
    framework?: string;
    function_schedules?: {
      name?: string;
      cron?: string;
    }[];
  };
  account_name?: string;
  account_slug?: string;
  git_provider?: string;
  deploy_hook?: string;
  capabilities?: {
    [key: string]: Record<string, any>;
  };
  processing_settings?: {
    html?: {
      pretty_urls?: boolean;
    };
  };
  build_settings?: {
    id?: number;
    provider?: string;
    deploy_key_id?: string;
    repo_path?: string;
    repo_branch?: string;
    dir?: string;
    functions_dir?: string;
    cmd?: string;
    allowed_branches?: string[];
    public_repo?: boolean;
    private_logs?: boolean;
    repo_url?: string;
    env?: {
      [key: string]: string;
    };
    installation_id?: number;
    stop_builds?: boolean;
  };
  id_domain?: string;
  default_hooks_data?: {
    access_token?: string;
  };
  build_image?: string;
  prerender?: string;
  functions_region?: string;
};

export type UnlinkSiteRepoVariables = {
  pathParams: UnlinkSiteRepoPathParams;
} & FetcherExtraProps;

/**
 * [Beta] Unlinks the repo from the site.
 *
 * This action will also:
 * - Delete associated deploy keys
 * - Delete outgoing webhooks for the repo
 * - Delete the site's build hooks
 */
export const unlinkSiteRepo = (variables: UnlinkSiteRepoVariables, signal?: AbortSignal) =>
  fetch<UnlinkSiteRepoResponse, UnlinkSiteRepoError, undefined, {}, {}, UnlinkSiteRepoPathParams>({
    url: '/sites/{siteId}/unlink_repo',
    method: 'put',
    ...variables,
    signal
  });

export type GetSiteBuildPathParams = {
  buildId: string;
};

export type GetSiteBuildError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetSiteBuildResponse = {
  id?: string;
  deploy_id?: string;
  sha?: string;
  done?: boolean;
  error?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
};

export type GetSiteBuildVariables = {
  pathParams: GetSiteBuildPathParams;
} & FetcherExtraProps;

export const getSiteBuild = (variables: GetSiteBuildVariables, signal?: AbortSignal) =>
  fetch<GetSiteBuildResponse, GetSiteBuildError, undefined, {}, {}, GetSiteBuildPathParams>({
    url: '/builds/{buildId}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateSiteBuildLogPathParams = {
  buildId: string;
};

export type UpdateSiteBuildLogError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type UpdateSiteBuildLogVariables = {
  pathParams: UpdateSiteBuildLogPathParams;
} & FetcherExtraProps;

export const updateSiteBuildLog = (variables: UpdateSiteBuildLogVariables, signal?: AbortSignal) =>
  fetch<undefined, UpdateSiteBuildLogError, undefined, {}, {}, UpdateSiteBuildLogPathParams>({
    url: '/builds/{buildId}/log',
    method: 'post',
    ...variables,
    signal
  });

export type NotifyBuildStartPathParams = {
  buildId: string;
};

export type NotifyBuildStartQueryParams = {
  buildbot_version?: string;
  build_version?: string;
};

export type NotifyBuildStartError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type NotifyBuildStartVariables = {
  pathParams: NotifyBuildStartPathParams;
  queryParams?: NotifyBuildStartQueryParams;
} & FetcherExtraProps;

export const notifyBuildStart = (variables: NotifyBuildStartVariables, signal?: AbortSignal) =>
  fetch<undefined, NotifyBuildStartError, undefined, {}, NotifyBuildStartQueryParams, NotifyBuildStartPathParams>({
    url: '/builds/{buildId}/start',
    method: 'post',
    ...variables,
    signal
  });

export type GetAccountBuildStatusPathParams = {
  accountId: string;
};

export type GetAccountBuildStatusError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetAccountBuildStatusResponse = {
  active?: number;
  pending_concurrency?: number;
  enqueued?: number;
  build_count?: number;
  minutes?: {
    current?: number;
    current_average_sec?: number;
    previous?: number;
    /**
     * @format dateTime
     */
    period_start_date?: string;
    /**
     * @format dateTime
     */
    period_end_date?: string;
    /**
     * @format dateTime
     */
    last_updated_at?: string;
    included_minutes?: string;
    included_minutes_with_packs?: string;
  };
}[];

export type GetAccountBuildStatusVariables = {
  pathParams: GetAccountBuildStatusPathParams;
} & FetcherExtraProps;

export const getAccountBuildStatus = (variables: GetAccountBuildStatusVariables, signal?: AbortSignal) =>
  fetch<GetAccountBuildStatusResponse, GetAccountBuildStatusError, undefined, {}, {}, GetAccountBuildStatusPathParams>({
    url: '/{accountId}/builds/status',
    method: 'get',
    ...variables,
    signal
  });

export type GetDNSForSitePathParams = {
  siteId: string;
};

export type GetDNSForSiteError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetDNSForSiteResponse = {
  id?: string;
  name?: string;
  errors?: string[];
  supported_record_types?: string[];
  user_id?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  records?: {
    id?: string;
    hostname?: string;
    type?: string;
    value?: string;
    /**
     * @format int64
     */
    ttl?: number;
    /**
     * @format int64
     */
    priority?: number;
    dns_zone_id?: string;
    site_id?: string;
    flag?: number;
    tag?: string;
    managed?: boolean;
  }[];
  dns_servers?: string[];
  account_id?: string;
  site_id?: string;
  account_slug?: string;
  account_name?: string;
  domain?: string;
  ipv6_enabled?: boolean;
  dedicated?: boolean;
}[];

export type GetDNSForSiteVariables = {
  pathParams: GetDNSForSitePathParams;
} & FetcherExtraProps;

export const getDNSForSite = (variables: GetDNSForSiteVariables, signal?: AbortSignal) =>
  fetch<GetDNSForSiteResponse, GetDNSForSiteError, undefined, {}, {}, GetDNSForSitePathParams>({
    url: '/sites/{siteId}/dns',
    method: 'get',
    ...variables,
    signal
  });

export type ConfigureDNSForSitePathParams = {
  siteId: string;
};

export type ConfigureDNSForSiteError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ConfigureDNSForSiteResponse = {
  id?: string;
  name?: string;
  errors?: string[];
  supported_record_types?: string[];
  user_id?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  records?: {
    id?: string;
    hostname?: string;
    type?: string;
    value?: string;
    /**
     * @format int64
     */
    ttl?: number;
    /**
     * @format int64
     */
    priority?: number;
    dns_zone_id?: string;
    site_id?: string;
    flag?: number;
    tag?: string;
    managed?: boolean;
  }[];
  dns_servers?: string[];
  account_id?: string;
  site_id?: string;
  account_slug?: string;
  account_name?: string;
  domain?: string;
  ipv6_enabled?: boolean;
  dedicated?: boolean;
}[];

export type ConfigureDNSForSiteVariables = {
  pathParams: ConfigureDNSForSitePathParams;
} & FetcherExtraProps;

export const configureDNSForSite = (variables: ConfigureDNSForSiteVariables, signal?: AbortSignal) =>
  fetch<ConfigureDNSForSiteResponse, ConfigureDNSForSiteError, undefined, {}, {}, ConfigureDNSForSitePathParams>({
    url: '/sites/{siteId}/dns',
    method: 'put',
    ...variables,
    signal
  });

export type RollbackSiteDeployPathParams = {
  siteId: string;
};

export type RollbackSiteDeployError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type RollbackSiteDeployVariables = {
  pathParams: RollbackSiteDeployPathParams;
} & FetcherExtraProps;

export const rollbackSiteDeploy = (variables: RollbackSiteDeployVariables, signal?: AbortSignal) =>
  fetch<undefined, RollbackSiteDeployError, undefined, {}, {}, RollbackSiteDeployPathParams>({
    url: '/sites/{siteId}/rollback',
    method: 'put',
    ...variables,
    signal
  });

export type GetDeployPathParams = {
  deployId: string;
};

export type GetDeployError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetDeployResponse = {
  id?: string;
  site_id?: string;
  user_id?: string;
  build_id?: string;
  state?: string;
  name?: string;
  url?: string;
  ssl_url?: string;
  admin_url?: string;
  deploy_url?: string;
  deploy_ssl_url?: string;
  screenshot_url?: string;
  review_id?: number;
  draft?: boolean;
  required?: string[];
  required_functions?: string[];
  error_message?: string;
  branch?: string;
  commit_ref?: string;
  commit_url?: string;
  skipped?: boolean;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  /**
   * @format dateTime
   */
  published_at?: string;
  title?: string;
  context?: string;
  locked?: boolean;
  review_url?: string;
  framework?: string;
  function_schedules?: {
    name?: string;
    cron?: string;
  }[];
};

export type GetDeployVariables = {
  pathParams: GetDeployPathParams;
} & FetcherExtraProps;

export const getDeploy = (variables: GetDeployVariables, signal?: AbortSignal) =>
  fetch<GetDeployResponse, GetDeployError, undefined, {}, {}, GetDeployPathParams>({
    url: '/deploys/{deployId}',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteDeployPathParams = {
  deployId: string;
};

export type DeleteDeployError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type DeleteDeployVariables = {
  pathParams: DeleteDeployPathParams;
} & FetcherExtraProps;

export const deleteDeploy = (variables: DeleteDeployVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteDeployError, undefined, {}, {}, DeleteDeployPathParams>({
    url: '/deploys/{deployId}',
    method: 'delete',
    ...variables,
    signal
  });

export type LockDeployPathParams = {
  deployId: string;
};

export type LockDeployError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type LockDeployResponse = {
  id?: string;
  site_id?: string;
  user_id?: string;
  build_id?: string;
  state?: string;
  name?: string;
  url?: string;
  ssl_url?: string;
  admin_url?: string;
  deploy_url?: string;
  deploy_ssl_url?: string;
  screenshot_url?: string;
  review_id?: number;
  draft?: boolean;
  required?: string[];
  required_functions?: string[];
  error_message?: string;
  branch?: string;
  commit_ref?: string;
  commit_url?: string;
  skipped?: boolean;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  /**
   * @format dateTime
   */
  published_at?: string;
  title?: string;
  context?: string;
  locked?: boolean;
  review_url?: string;
  framework?: string;
  function_schedules?: {
    name?: string;
    cron?: string;
  }[];
};

export type LockDeployVariables = {
  pathParams: LockDeployPathParams;
} & FetcherExtraProps;

export const lockDeploy = (variables: LockDeployVariables, signal?: AbortSignal) =>
  fetch<LockDeployResponse, LockDeployError, undefined, {}, {}, LockDeployPathParams>({
    url: '/deploys/{deployId}/lock',
    method: 'post',
    ...variables,
    signal
  });

export type UnlockDeployPathParams = {
  deployId: string;
};

export type UnlockDeployError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type UnlockDeployResponse = {
  id?: string;
  site_id?: string;
  user_id?: string;
  build_id?: string;
  state?: string;
  name?: string;
  url?: string;
  ssl_url?: string;
  admin_url?: string;
  deploy_url?: string;
  deploy_ssl_url?: string;
  screenshot_url?: string;
  review_id?: number;
  draft?: boolean;
  required?: string[];
  required_functions?: string[];
  error_message?: string;
  branch?: string;
  commit_ref?: string;
  commit_url?: string;
  skipped?: boolean;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  /**
   * @format dateTime
   */
  published_at?: string;
  title?: string;
  context?: string;
  locked?: boolean;
  review_url?: string;
  framework?: string;
  function_schedules?: {
    name?: string;
    cron?: string;
  }[];
};

export type UnlockDeployVariables = {
  pathParams: UnlockDeployPathParams;
} & FetcherExtraProps;

export const unlockDeploy = (variables: UnlockDeployVariables, signal?: AbortSignal) =>
  fetch<UnlockDeployResponse, UnlockDeployError, undefined, {}, {}, UnlockDeployPathParams>({
    url: '/deploys/{deployId}/unlock',
    method: 'post',
    ...variables,
    signal
  });

export type UploadDeployFilePathParams = {
  deployId: string;
  path: string;
};

export type UploadDeployFileQueryParams = {
  size?: number;
};

export type UploadDeployFileError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type UploadDeployFileResponse = {
  id?: string;
  path?: string;
  sha?: string;
  mime_type?: string;
  /**
   * @format int64
   */
  size?: number;
};

export type UploadDeployFileVariables = {
  body?: RequestBodies.UploadDeployFileFileBody;
  pathParams: UploadDeployFilePathParams;
  queryParams?: UploadDeployFileQueryParams;
} & FetcherExtraProps;

export const uploadDeployFile = (variables: UploadDeployFileVariables, signal?: AbortSignal) =>
  fetch<
    UploadDeployFileResponse,
    UploadDeployFileError,
    RequestBodies.UploadDeployFileFileBody,
    {},
    UploadDeployFileQueryParams,
    UploadDeployFilePathParams
  >({ url: '/deploys/{deployId}/files/{path}', method: 'put', ...variables, signal });

export type UploadDeployFunctionPathParams = {
  deployId: string;
  name: string;
};

export type UploadDeployFunctionQueryParams = {
  runtime?: string;
  invocation_mode?: string;
  timeout?: number;
  size?: number;
};

export type UploadDeployFunctionHeaders = {
  ['X-Nf-Retry-Count']?: number;
};

export type UploadDeployFunctionError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type UploadDeployFunctionResponse = {
  id?: string;
  name?: string;
  sha?: string;
};

export type UploadDeployFunctionVariables = {
  body?: RequestBodies.UploadDeployFileFileBody;
  headers?: UploadDeployFunctionHeaders;
  pathParams: UploadDeployFunctionPathParams;
  queryParams?: UploadDeployFunctionQueryParams;
} & FetcherExtraProps;

export const uploadDeployFunction = (variables: UploadDeployFunctionVariables, signal?: AbortSignal) =>
  fetch<
    UploadDeployFunctionResponse,
    UploadDeployFunctionError,
    RequestBodies.UploadDeployFileFileBody,
    UploadDeployFunctionHeaders,
    UploadDeployFunctionQueryParams,
    UploadDeployFunctionPathParams
  >({ url: '/deploys/{deployId}/functions/{name}', method: 'put', ...variables, signal });

export type UpdatePluginPathParams = {
  siteId: string;
  package: string;
};

export type UpdatePluginError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type UpdatePluginResponse = {
  package?: string;
  pinned_version?: string;
};

export type UpdatePluginRequestBody = {
  pinned_version?: string;
};

export type UpdatePluginVariables = {
  body?: UpdatePluginRequestBody;
  pathParams: UpdatePluginPathParams;
} & FetcherExtraProps;

/**
 * This is an internal-only endpoint.
 */
export const updatePlugin = (variables: UpdatePluginVariables, signal?: AbortSignal) =>
  fetch<UpdatePluginResponse, UpdatePluginError, UpdatePluginRequestBody, {}, {}, UpdatePluginPathParams>({
    url: '/sites/{siteId}/plugins/{package}',
    method: 'put',
    ...variables,
    signal
  });

export type GetLatestPluginRunsPathParams = {
  siteId: string;
};

export type GetLatestPluginRunsQueryParams = {
  packages: string[];
  state?: string;
};

export type GetLatestPluginRunsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetLatestPluginRunsResponse = {
  package?: string;
  version?: string;
  state?: string;
  reporting_event?: string;
  title?: string;
  summary?: string;
  text?: string;
  deploy_id?: string;
}[];

export type GetLatestPluginRunsVariables = {
  pathParams: GetLatestPluginRunsPathParams;
  queryParams: GetLatestPluginRunsQueryParams;
} & FetcherExtraProps;

/**
 * This is an internal-only endpoint.
 */
export const getLatestPluginRuns = (variables: GetLatestPluginRunsVariables, signal?: AbortSignal) =>
  fetch<
    GetLatestPluginRunsResponse,
    GetLatestPluginRunsError,
    undefined,
    {},
    GetLatestPluginRunsQueryParams,
    GetLatestPluginRunsPathParams
  >({ url: '/sites/{siteId}/plugin_runs/latest', method: 'get', ...variables, signal });

export type CreatePluginRunPathParams = {
  deployId: string;
};

export type CreatePluginRunError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreatePluginRunResponse = {
  package?: string;
  version?: string;
  state?: string;
  reporting_event?: string;
  title?: string;
  summary?: string;
  text?: string;
  deploy_id?: string;
};

export type CreatePluginRunRequestBody = {
  package?: string;
  version?: string;
  state?: string;
  reporting_event?: string;
  title?: string;
  summary?: string;
  text?: string;
};

export type CreatePluginRunVariables = {
  body?: CreatePluginRunRequestBody;
  pathParams: CreatePluginRunPathParams;
} & FetcherExtraProps;

/**
 * This is an internal-only endpoint.
 */
export const createPluginRun = (variables: CreatePluginRunVariables, signal?: AbortSignal) =>
  fetch<CreatePluginRunResponse, CreatePluginRunError, CreatePluginRunRequestBody, {}, {}, CreatePluginRunPathParams>({
    url: '/deploys/{deployId}/plugin_runs',
    method: 'post',
    ...variables,
    signal
  });

export type ListFormSubmissionsPathParams = {
  formId: string;
};

export type ListFormSubmissionsQueryParams = {
  /**
   * @format int32
   */
  page?: number;
  /**
   * @format int32
   */
  per_page?: number;
};

export type ListFormSubmissionsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListFormSubmissionsResponse = {
  id?: string;
  /**
   * @format int32
   */
  number?: number;
  email?: string;
  name?: string;
  first_name?: string;
  last_name?: string;
  company?: string;
  summary?: string;
  body?: string;
  data?: Record<string, any>;
  /**
   * @format dateTime
   */
  created_at?: string;
  site_url?: string;
}[];

export type ListFormSubmissionsVariables = {
  pathParams: ListFormSubmissionsPathParams;
  queryParams?: ListFormSubmissionsQueryParams;
} & FetcherExtraProps;

export const listFormSubmissions = (variables: ListFormSubmissionsVariables, signal?: AbortSignal) =>
  fetch<
    ListFormSubmissionsResponse,
    ListFormSubmissionsError,
    undefined,
    {},
    ListFormSubmissionsQueryParams,
    ListFormSubmissionsPathParams
  >({ url: '/forms/{formId}/submissions', method: 'get', ...variables, signal });

export type ListHooksBySiteIdQueryParams = {
  site_id: string;
};

export type ListHooksBySiteIdError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListHooksBySiteIdResponse = {
  id?: string;
  site_id?: string;
  type?: string;
  event?: string;
  data?: Record<string, any>;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  disabled?: boolean;
}[];

export type ListHooksBySiteIdVariables = {
  queryParams: ListHooksBySiteIdQueryParams;
} & FetcherExtraProps;

export const listHooksBySiteId = (variables: ListHooksBySiteIdVariables, signal?: AbortSignal) =>
  fetch<ListHooksBySiteIdResponse, ListHooksBySiteIdError, undefined, {}, ListHooksBySiteIdQueryParams, {}>({
    url: '/hooks',
    method: 'get',
    ...variables,
    signal
  });

export type CreateHookBySiteIdQueryParams = {
  site_id: string;
};

export type CreateHookBySiteIdError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreateHookBySiteIdResponse = {
  id?: string;
  site_id?: string;
  type?: string;
  event?: string;
  data?: Record<string, any>;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  disabled?: boolean;
};

export type CreateHookBySiteIdVariables = {
  body?: RequestBodies.CreateHookBySiteIdHook;
  queryParams: CreateHookBySiteIdQueryParams;
} & FetcherExtraProps;

export const createHookBySiteId = (variables: CreateHookBySiteIdVariables, signal?: AbortSignal) =>
  fetch<
    CreateHookBySiteIdResponse,
    CreateHookBySiteIdError,
    RequestBodies.CreateHookBySiteIdHook,
    {},
    CreateHookBySiteIdQueryParams,
    {}
  >({ url: '/hooks', method: 'post', ...variables, signal });

export type GetHookPathParams = {
  hookId: string;
};

export type GetHookError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetHookResponse = {
  id?: string;
  site_id?: string;
  type?: string;
  event?: string;
  data?: Record<string, any>;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  disabled?: boolean;
};

export type GetHookVariables = {
  pathParams: GetHookPathParams;
} & FetcherExtraProps;

export const getHook = (variables: GetHookVariables, signal?: AbortSignal) =>
  fetch<GetHookResponse, GetHookError, undefined, {}, {}, GetHookPathParams>({
    url: '/hooks/{hookId}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateHookPathParams = {
  hookId: string;
};

export type UpdateHookError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type UpdateHookResponse = {
  id?: string;
  site_id?: string;
  type?: string;
  event?: string;
  data?: Record<string, any>;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  disabled?: boolean;
};

export type UpdateHookVariables = {
  body?: RequestBodies.CreateHookBySiteIdHook;
  pathParams: UpdateHookPathParams;
} & FetcherExtraProps;

export const updateHook = (variables: UpdateHookVariables, signal?: AbortSignal) =>
  fetch<UpdateHookResponse, UpdateHookError, RequestBodies.CreateHookBySiteIdHook, {}, {}, UpdateHookPathParams>({
    url: '/hooks/{hookId}',
    method: 'put',
    ...variables,
    signal
  });

export type DeleteHookPathParams = {
  hookId: string;
};

export type DeleteHookError = Fetcher.ErrorWrapper<undefined>;

export type DeleteHookVariables = {
  pathParams: DeleteHookPathParams;
} & FetcherExtraProps;

export const deleteHook = (variables: DeleteHookVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteHookError, undefined, {}, {}, DeleteHookPathParams>({
    url: '/hooks/{hookId}',
    method: 'delete',
    ...variables,
    signal
  });

export type EnableHookPathParams = {
  hookId: string;
};

export type EnableHookError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type EnableHookResponse = {
  id?: string;
  site_id?: string;
  type?: string;
  event?: string;
  data?: Record<string, any>;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  disabled?: boolean;
};

export type EnableHookVariables = {
  pathParams: EnableHookPathParams;
} & FetcherExtraProps;

export const enableHook = (variables: EnableHookVariables, signal?: AbortSignal) =>
  fetch<EnableHookResponse, EnableHookError, undefined, {}, {}, EnableHookPathParams>({
    url: '/hooks/{hookId}/enable',
    method: 'post',
    ...variables,
    signal
  });

export type ListHookTypesError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListHookTypesResponse = {
  name?: string;
  events?: string[];
  fields?: Record<string, any>[];
}[];

export type ListHookTypesVariables = FetcherExtraProps;

export const listHookTypes = (variables: ListHookTypesVariables, signal?: AbortSignal) =>
  fetch<ListHookTypesResponse, ListHookTypesError, undefined, {}, {}, {}>({
    url: '/hooks/types',
    method: 'get',
    ...variables,
    signal
  });

export type CreateTicketQueryParams = {
  client_id: string;
};

export type CreateTicketError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreateTicketResponse = {
  id?: string;
  client_id?: string;
  authorized?: boolean;
  /**
   * @format dateTime
   */
  created_at?: string;
};

export type CreateTicketVariables = {
  queryParams: CreateTicketQueryParams;
} & FetcherExtraProps;

export const createTicket = (variables: CreateTicketVariables, signal?: AbortSignal) =>
  fetch<CreateTicketResponse, CreateTicketError, undefined, {}, CreateTicketQueryParams, {}>({
    url: '/oauth/tickets',
    method: 'post',
    ...variables,
    signal
  });

export type ShowTicketPathParams = {
  ticketId: string;
};

export type ShowTicketError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ShowTicketResponse = {
  id?: string;
  client_id?: string;
  authorized?: boolean;
  /**
   * @format dateTime
   */
  created_at?: string;
};

export type ShowTicketVariables = {
  pathParams: ShowTicketPathParams;
} & FetcherExtraProps;

export const showTicket = (variables: ShowTicketVariables, signal?: AbortSignal) =>
  fetch<ShowTicketResponse, ShowTicketError, undefined, {}, {}, ShowTicketPathParams>({
    url: '/oauth/tickets/{ticketId}',
    method: 'get',
    ...variables,
    signal
  });

export type ExchangeTicketPathParams = {
  ticketId: string;
};

export type ExchangeTicketError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ExchangeTicketResponse = {
  id?: string;
  access_token?: string;
  user_id?: string;
  user_email?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
};

export type ExchangeTicketVariables = {
  pathParams: ExchangeTicketPathParams;
} & FetcherExtraProps;

export const exchangeTicket = (variables: ExchangeTicketVariables, signal?: AbortSignal) =>
  fetch<ExchangeTicketResponse, ExchangeTicketError, undefined, {}, {}, ExchangeTicketPathParams>({
    url: '/oauth/tickets/{ticketId}/exchange',
    method: 'post',
    ...variables,
    signal
  });

export type ListDeployKeysError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListDeployKeysResponse = {
  id?: string;
  public_key?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
}[];

export type ListDeployKeysVariables = FetcherExtraProps;

export const listDeployKeys = (variables: ListDeployKeysVariables, signal?: AbortSignal) =>
  fetch<ListDeployKeysResponse, ListDeployKeysError, undefined, {}, {}, {}>({
    url: '/deploy_keys',
    method: 'get',
    ...variables,
    signal
  });

export type CreateDeployKeyError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreateDeployKeyResponse = {
  id?: string;
  public_key?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
};

export type CreateDeployKeyVariables = FetcherExtraProps;

export const createDeployKey = (variables: CreateDeployKeyVariables, signal?: AbortSignal) =>
  fetch<CreateDeployKeyResponse, CreateDeployKeyError, undefined, {}, {}, {}>({
    url: '/deploy_keys',
    method: 'post',
    ...variables,
    signal
  });

export type GetDeployKeyPathParams = {
  keyId: string;
};

export type GetDeployKeyError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetDeployKeyResponse = {
  id?: string;
  public_key?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
};

export type GetDeployKeyVariables = {
  pathParams: GetDeployKeyPathParams;
} & FetcherExtraProps;

export const getDeployKey = (variables: GetDeployKeyVariables, signal?: AbortSignal) =>
  fetch<GetDeployKeyResponse, GetDeployKeyError, undefined, {}, {}, GetDeployKeyPathParams>({
    url: '/deploy_keys/{keyId}',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteDeployKeyPathParams = {
  keyId: string;
};

export type DeleteDeployKeyError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type DeleteDeployKeyVariables = {
  pathParams: DeleteDeployKeyPathParams;
} & FetcherExtraProps;

export const deleteDeployKey = (variables: DeleteDeployKeyVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteDeployKeyError, undefined, {}, {}, DeleteDeployKeyPathParams>({
    url: '/deploy_keys/{keyId}',
    method: 'delete',
    ...variables,
    signal
  });

export type CreateSiteInTeamPathParams = {
  accountSlug: string;
};

export type CreateSiteInTeamQueryParams = {
  configure_dns?: boolean;
};

export type CreateSiteInTeamError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreateSiteInTeamResponse = {
  id?: string;
  state?: string;
  plan?: string;
  name?: string;
  custom_domain?: string;
  domain_aliases?: string[];
  branch_deploy_custom_domain?: string;
  deploy_preview_custom_domain?: string;
  password?: string;
  notification_email?: string;
  url?: string;
  ssl_url?: string;
  admin_url?: string;
  screenshot_url?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  user_id?: string;
  session_id?: string;
  ssl?: boolean;
  force_ssl?: boolean;
  managed_dns?: boolean;
  deploy_url?: string;
  published_deploy?: {
    id?: string;
    site_id?: string;
    user_id?: string;
    build_id?: string;
    state?: string;
    name?: string;
    url?: string;
    ssl_url?: string;
    admin_url?: string;
    deploy_url?: string;
    deploy_ssl_url?: string;
    screenshot_url?: string;
    review_id?: number;
    draft?: boolean;
    required?: string[];
    required_functions?: string[];
    error_message?: string;
    branch?: string;
    commit_ref?: string;
    commit_url?: string;
    skipped?: boolean;
    /**
     * @format dateTime
     */
    created_at?: string;
    /**
     * @format dateTime
     */
    updated_at?: string;
    /**
     * @format dateTime
     */
    published_at?: string;
    title?: string;
    context?: string;
    locked?: boolean;
    review_url?: string;
    framework?: string;
    function_schedules?: {
      name?: string;
      cron?: string;
    }[];
  };
  account_name?: string;
  account_slug?: string;
  git_provider?: string;
  deploy_hook?: string;
  capabilities?: {
    [key: string]: Record<string, any>;
  };
  processing_settings?: {
    html?: {
      pretty_urls?: boolean;
    };
  };
  build_settings?: {
    id?: number;
    provider?: string;
    deploy_key_id?: string;
    repo_path?: string;
    repo_branch?: string;
    dir?: string;
    functions_dir?: string;
    cmd?: string;
    allowed_branches?: string[];
    public_repo?: boolean;
    private_logs?: boolean;
    repo_url?: string;
    env?: {
      [key: string]: string;
    };
    installation_id?: number;
    stop_builds?: boolean;
  };
  id_domain?: string;
  default_hooks_data?: {
    access_token?: string;
  };
  build_image?: string;
  prerender?: string;
  functions_region?: string;
};

export type CreateSiteInTeamRequestBody = {
  id?: string;
  state?: string;
  plan?: string;
  name?: string;
  custom_domain?: string;
  domain_aliases?: string[];
  branch_deploy_custom_domain?: string;
  deploy_preview_custom_domain?: string;
  password?: string;
  notification_email?: string;
  url?: string;
  ssl_url?: string;
  admin_url?: string;
  screenshot_url?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  user_id?: string;
  session_id?: string;
  ssl?: boolean;
  force_ssl?: boolean;
  managed_dns?: boolean;
  deploy_url?: string;
  published_deploy?: {
    id?: string;
    site_id?: string;
    user_id?: string;
    build_id?: string;
    state?: string;
    name?: string;
    url?: string;
    ssl_url?: string;
    admin_url?: string;
    deploy_url?: string;
    deploy_ssl_url?: string;
    screenshot_url?: string;
    review_id?: number;
    draft?: boolean;
    required?: string[];
    required_functions?: string[];
    error_message?: string;
    branch?: string;
    commit_ref?: string;
    commit_url?: string;
    skipped?: boolean;
    /**
     * @format dateTime
     */
    created_at?: string;
    /**
     * @format dateTime
     */
    updated_at?: string;
    /**
     * @format dateTime
     */
    published_at?: string;
    title?: string;
    context?: string;
    locked?: boolean;
    review_url?: string;
    framework?: string;
    function_schedules?: {
      name?: string;
      cron?: string;
    }[];
  };
  account_name?: string;
  account_slug?: string;
  git_provider?: string;
  deploy_hook?: string;
  capabilities?: {
    [key: string]: Record<string, any>;
  };
  processing_settings?: {
    html?: {
      pretty_urls?: boolean;
    };
  };
  build_settings?: {
    id?: number;
    provider?: string;
    deploy_key_id?: string;
    repo_path?: string;
    repo_branch?: string;
    dir?: string;
    functions_dir?: string;
    cmd?: string;
    allowed_branches?: string[];
    public_repo?: boolean;
    private_logs?: boolean;
    repo_url?: string;
    env?: {
      [key: string]: string;
    };
    installation_id?: number;
    stop_builds?: boolean;
  };
  id_domain?: string;
  default_hooks_data?: {
    access_token?: string;
  };
  build_image?: string;
  prerender?: string;
  functions_region?: string;
  repo?: {
    id?: number;
    provider?: string;
    deploy_key_id?: string;
    repo_path?: string;
    repo_branch?: string;
    dir?: string;
    functions_dir?: string;
    cmd?: string;
    allowed_branches?: string[];
    public_repo?: boolean;
    private_logs?: boolean;
    repo_url?: string;
    env?: {
      [key: string]: string;
    };
    installation_id?: number;
    stop_builds?: boolean;
  };
};

export type CreateSiteInTeamVariables = {
  body?: CreateSiteInTeamRequestBody;
  pathParams: CreateSiteInTeamPathParams;
  queryParams?: CreateSiteInTeamQueryParams;
} & FetcherExtraProps;

/**
 * **Note:** Environment variable keys and values have moved from `build_settings.env` and `repo.env` to a new endpoint. Please use [createEnvVars](#tag/environmentVariables/operation/createEnvVars) to create environment variables for a site.
 */
export const createSiteInTeam = (variables: CreateSiteInTeamVariables, signal?: AbortSignal) =>
  fetch<
    CreateSiteInTeamResponse,
    CreateSiteInTeamError,
    CreateSiteInTeamRequestBody,
    {},
    CreateSiteInTeamQueryParams,
    CreateSiteInTeamPathParams
  >({ url: '/{accountSlug}/sites', method: 'post', ...variables, signal });

export type ListSitesForAccountPathParams = {
  accountSlug: string;
};

export type ListSitesForAccountQueryParams = {
  name?: string;
  /**
   * @format int32
   */
  page?: number;
  /**
   * @format int32
   */
  per_page?: number;
};

export type ListSitesForAccountError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListSitesForAccountResponse = {
  id?: string;
  state?: string;
  plan?: string;
  name?: string;
  custom_domain?: string;
  domain_aliases?: string[];
  branch_deploy_custom_domain?: string;
  deploy_preview_custom_domain?: string;
  password?: string;
  notification_email?: string;
  url?: string;
  ssl_url?: string;
  admin_url?: string;
  screenshot_url?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  user_id?: string;
  session_id?: string;
  ssl?: boolean;
  force_ssl?: boolean;
  managed_dns?: boolean;
  deploy_url?: string;
  published_deploy?: {
    id?: string;
    site_id?: string;
    user_id?: string;
    build_id?: string;
    state?: string;
    name?: string;
    url?: string;
    ssl_url?: string;
    admin_url?: string;
    deploy_url?: string;
    deploy_ssl_url?: string;
    screenshot_url?: string;
    review_id?: number;
    draft?: boolean;
    required?: string[];
    required_functions?: string[];
    error_message?: string;
    branch?: string;
    commit_ref?: string;
    commit_url?: string;
    skipped?: boolean;
    /**
     * @format dateTime
     */
    created_at?: string;
    /**
     * @format dateTime
     */
    updated_at?: string;
    /**
     * @format dateTime
     */
    published_at?: string;
    title?: string;
    context?: string;
    locked?: boolean;
    review_url?: string;
    framework?: string;
    function_schedules?: {
      name?: string;
      cron?: string;
    }[];
  };
  account_name?: string;
  account_slug?: string;
  git_provider?: string;
  deploy_hook?: string;
  capabilities?: {
    [key: string]: Record<string, any>;
  };
  processing_settings?: {
    html?: {
      pretty_urls?: boolean;
    };
  };
  build_settings?: {
    id?: number;
    provider?: string;
    deploy_key_id?: string;
    repo_path?: string;
    repo_branch?: string;
    dir?: string;
    functions_dir?: string;
    cmd?: string;
    allowed_branches?: string[];
    public_repo?: boolean;
    private_logs?: boolean;
    repo_url?: string;
    env?: {
      [key: string]: string;
    };
    installation_id?: number;
    stop_builds?: boolean;
  };
  id_domain?: string;
  default_hooks_data?: {
    access_token?: string;
  };
  build_image?: string;
  prerender?: string;
  functions_region?: string;
}[];

export type ListSitesForAccountVariables = {
  pathParams: ListSitesForAccountPathParams;
  queryParams?: ListSitesForAccountQueryParams;
} & FetcherExtraProps;

/**
 * **Note:** Environment variable keys and values have moved from `build_settings.env` and `repo.env` to a new endpoint. Please use [getEnvVars](#tag/environmentVariables/operation/getEnvVars) to retrieve site environment variables.
 */
export const listSitesForAccount = (variables: ListSitesForAccountVariables, signal?: AbortSignal) =>
  fetch<
    ListSitesForAccountResponse,
    ListSitesForAccountError,
    undefined,
    {},
    ListSitesForAccountQueryParams,
    ListSitesForAccountPathParams
  >({ url: '/{accountSlug}/sites', method: 'get', ...variables, signal });

export type ListMembersForAccountPathParams = {
  accountSlug: string;
};

export type ListMembersForAccountError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListMembersForAccountResponse = {
  id?: string;
  full_name?: string;
  email?: string;
  avatar?: string;
  role?: string;
}[];

export type ListMembersForAccountVariables = {
  pathParams: ListMembersForAccountPathParams;
} & FetcherExtraProps;

export const listMembersForAccount = (variables: ListMembersForAccountVariables, signal?: AbortSignal) =>
  fetch<ListMembersForAccountResponse, ListMembersForAccountError, undefined, {}, {}, ListMembersForAccountPathParams>({
    url: '/{accountSlug}/members',
    method: 'get',
    ...variables,
    signal
  });

export type AddMemberToAccountPathParams = {
  accountSlug: string;
};

export type AddMemberToAccountError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type AddMemberToAccountResponse = {
  id?: string;
  full_name?: string;
  email?: string;
  avatar?: string;
  role?: string;
}[];

export type AddMemberToAccountRequestBody = {
  role?: 'Owner' | 'Developer' | 'Billing Admin' | 'Reviewer';
  email?: string;
};

export type AddMemberToAccountVariables = {
  body?: AddMemberToAccountRequestBody;
  pathParams: AddMemberToAccountPathParams;
} & FetcherExtraProps;

export const addMemberToAccount = (variables: AddMemberToAccountVariables, signal?: AbortSignal) =>
  fetch<
    AddMemberToAccountResponse,
    AddMemberToAccountError,
    AddMemberToAccountRequestBody,
    {},
    {},
    AddMemberToAccountPathParams
  >({ url: '/{accountSlug}/members', method: 'post', ...variables, signal });

export type GetAccountMemberPathParams = {
  accountSlug: string;
  memberId: string;
};

export type GetAccountMemberError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetAccountMemberResponse = {
  id?: string;
  full_name?: string;
  email?: string;
  avatar?: string;
  role?: string;
};

export type GetAccountMemberVariables = {
  pathParams: GetAccountMemberPathParams;
} & FetcherExtraProps;

export const getAccountMember = (variables: GetAccountMemberVariables, signal?: AbortSignal) =>
  fetch<GetAccountMemberResponse, GetAccountMemberError, undefined, {}, {}, GetAccountMemberPathParams>({
    url: '/{accountSlug}/members/{memberId}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateAccountMemberPathParams = {
  accountSlug: string;
  memberId: string;
};

export type UpdateAccountMemberError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type UpdateAccountMemberResponse = {
  id?: string;
  full_name?: string;
  email?: string;
  avatar?: string;
  role?: string;
};

export type UpdateAccountMemberRequestBody = {
  role?: 'Owner' | 'Developer' | 'Billing Admin' | 'Reviewer';
  site_access?: 'all' | 'none' | 'selected';
  site_ids?: string[];
};

export type UpdateAccountMemberVariables = {
  body?: UpdateAccountMemberRequestBody;
  pathParams: UpdateAccountMemberPathParams;
} & FetcherExtraProps;

export const updateAccountMember = (variables: UpdateAccountMemberVariables, signal?: AbortSignal) =>
  fetch<
    UpdateAccountMemberResponse,
    UpdateAccountMemberError,
    UpdateAccountMemberRequestBody,
    {},
    {},
    UpdateAccountMemberPathParams
  >({ url: '/{accountSlug}/members/{memberId}', method: 'put', ...variables, signal });

export type RemoveAccountMemberPathParams = {
  accountSlug: string;
  memberId: string;
};

export type RemoveAccountMemberError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type RemoveAccountMemberVariables = {
  pathParams: RemoveAccountMemberPathParams;
} & FetcherExtraProps;

export const removeAccountMember = (variables: RemoveAccountMemberVariables, signal?: AbortSignal) =>
  fetch<undefined, RemoveAccountMemberError, undefined, {}, {}, RemoveAccountMemberPathParams>({
    url: '/{accountSlug}/members/{memberId}',
    method: 'delete',
    ...variables,
    signal
  });

export type ListPaymentMethodsForUserError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListPaymentMethodsForUserResponse = {
  id?: string;
  method_name?: string;
  type?: string;
  state?: string;
  data?: {
    card_type?: string;
    last4?: string;
    email?: string;
  };
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
}[];

export type ListPaymentMethodsForUserVariables = FetcherExtraProps;

export const listPaymentMethodsForUser = (variables: ListPaymentMethodsForUserVariables, signal?: AbortSignal) =>
  fetch<ListPaymentMethodsForUserResponse, ListPaymentMethodsForUserError, undefined, {}, {}, {}>({
    url: '/billing/payment_methods',
    method: 'get',
    ...variables,
    signal
  });

export type ListAccountTypesForUserError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListAccountTypesForUserResponse = {
  id?: string;
  name?: string;
  description?: string;
  capabilities?: Record<string, any>;
  monthly_dollar_price?: number;
  yearly_dollar_price?: number;
  monthly_seats_addon_dollar_price?: number;
  yearly_seats_addon_dollar_price?: number;
}[];

export type ListAccountTypesForUserVariables = FetcherExtraProps;

export const listAccountTypesForUser = (variables: ListAccountTypesForUserVariables, signal?: AbortSignal) =>
  fetch<ListAccountTypesForUserResponse, ListAccountTypesForUserError, undefined, {}, {}, {}>({
    url: '/accounts/types',
    method: 'get',
    ...variables,
    signal
  });

export type ListAccountsForUserError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListAccountsForUserResponse = {
  id?: string;
  name?: string;
  slug?: string;
  type?: string;
  capabilities?: {
    sites?: {
      included?: number;
      used?: number;
    };
    collaborators?: {
      included?: number;
      used?: number;
    };
  };
  billing_name?: string;
  billing_email?: string;
  billing_details?: string;
  billing_period?: string;
  payment_method_id?: string;
  type_name?: string;
  type_id?: string;
  owner_ids?: string[];
  roles_allowed?: string[];
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
}[];

export type ListAccountsForUserVariables = FetcherExtraProps;

export const listAccountsForUser = (variables: ListAccountsForUserVariables, signal?: AbortSignal) =>
  fetch<ListAccountsForUserResponse, ListAccountsForUserError, undefined, {}, {}, {}>({
    url: '/accounts',
    method: 'get',
    ...variables,
    signal
  });

export type CreateAccountError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreateAccountResponse = {
  id?: string;
  name?: string;
  slug?: string;
  type?: string;
  capabilities?: {
    sites?: {
      included?: number;
      used?: number;
    };
    collaborators?: {
      included?: number;
      used?: number;
    };
  };
  billing_name?: string;
  billing_email?: string;
  billing_details?: string;
  billing_period?: string;
  payment_method_id?: string;
  type_name?: string;
  type_id?: string;
  owner_ids?: string[];
  roles_allowed?: string[];
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
};

export type CreateAccountRequestBody = {
  name: string;
  type_id: string;
  payment_method_id?: string;
  period?: 'monthly' | 'yearly';
  extra_seats_block?: number;
};

export type CreateAccountVariables = {
  body: CreateAccountRequestBody;
} & FetcherExtraProps;

export const createAccount = (variables: CreateAccountVariables, signal?: AbortSignal) =>
  fetch<CreateAccountResponse, CreateAccountError, CreateAccountRequestBody, {}, {}, {}>({
    url: '/accounts',
    method: 'post',
    ...variables,
    signal
  });

export type GetAccountPathParams = {
  accountId: string;
};

export type GetAccountError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetAccountResponse = {
  id?: string;
  name?: string;
  slug?: string;
  type?: string;
  capabilities?: {
    sites?: {
      included?: number;
      used?: number;
    };
    collaborators?: {
      included?: number;
      used?: number;
    };
  };
  billing_name?: string;
  billing_email?: string;
  billing_details?: string;
  billing_period?: string;
  payment_method_id?: string;
  type_name?: string;
  type_id?: string;
  owner_ids?: string[];
  roles_allowed?: string[];
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
}[];

export type GetAccountVariables = {
  pathParams: GetAccountPathParams;
} & FetcherExtraProps;

export const getAccount = (variables: GetAccountVariables, signal?: AbortSignal) =>
  fetch<GetAccountResponse, GetAccountError, undefined, {}, {}, GetAccountPathParams>({
    url: '/accounts/{accountId}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateAccountPathParams = {
  accountId: string;
};

export type UpdateAccountError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type UpdateAccountResponse = {
  id?: string;
  name?: string;
  slug?: string;
  type?: string;
  capabilities?: {
    sites?: {
      included?: number;
      used?: number;
    };
    collaborators?: {
      included?: number;
      used?: number;
    };
  };
  billing_name?: string;
  billing_email?: string;
  billing_details?: string;
  billing_period?: string;
  payment_method_id?: string;
  type_name?: string;
  type_id?: string;
  owner_ids?: string[];
  roles_allowed?: string[];
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
};

export type UpdateAccountRequestBody = {
  name?: string;
  slug?: string;
  type_id?: string;
  extra_seats_block?: number;
  billing_name?: string;
  billing_email?: string;
  billing_details?: string;
};

export type UpdateAccountVariables = {
  body?: UpdateAccountRequestBody;
  pathParams: UpdateAccountPathParams;
} & FetcherExtraProps;

export const updateAccount = (variables: UpdateAccountVariables, signal?: AbortSignal) =>
  fetch<UpdateAccountResponse, UpdateAccountError, UpdateAccountRequestBody, {}, {}, UpdateAccountPathParams>({
    url: '/accounts/{accountId}',
    method: 'put',
    ...variables,
    signal
  });

export type CancelAccountPathParams = {
  accountId: string;
};

export type CancelAccountError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CancelAccountVariables = {
  pathParams: CancelAccountPathParams;
} & FetcherExtraProps;

export const cancelAccount = (variables: CancelAccountVariables, signal?: AbortSignal) =>
  fetch<undefined, CancelAccountError, undefined, {}, {}, CancelAccountPathParams>({
    url: '/accounts/{accountId}',
    method: 'delete',
    ...variables,
    signal
  });

export type ListAccountAuditEventsPathParams = {
  accountId: string;
};

export type ListAccountAuditEventsQueryParams = {
  query?: string;
  log_type?: string;
  /**
   * @format int32
   */
  page?: number;
  /**
   * @format int32
   */
  per_page?: number;
};

export type ListAccountAuditEventsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListAccountAuditEventsResponse = {
  id?: string;
  account_id?: string;
  payload?: {
    actor_id?: string;
    actor_name?: string;
    actor_email?: string;
    action?: string;
    /**
     * @format dateTime
     */
    timestamp?: string;
    log_type?: string;
  } & {
    [key: string]: Record<string, any>;
  };
}[];

export type ListAccountAuditEventsVariables = {
  pathParams: ListAccountAuditEventsPathParams;
  queryParams?: ListAccountAuditEventsQueryParams;
} & FetcherExtraProps;

export const listAccountAuditEvents = (variables: ListAccountAuditEventsVariables, signal?: AbortSignal) =>
  fetch<
    ListAccountAuditEventsResponse,
    ListAccountAuditEventsError,
    undefined,
    {},
    ListAccountAuditEventsQueryParams,
    ListAccountAuditEventsPathParams
  >({ url: '/accounts/{accountId}/audit', method: 'get', ...variables, signal });

export type ListFormSubmissionPathParams = {
  submissionId: string;
};

export type ListFormSubmissionQueryParams = {
  query?: string;
  /**
   * @format int32
   */
  page?: number;
  /**
   * @format int32
   */
  per_page?: number;
};

export type ListFormSubmissionError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListFormSubmissionResponse = {
  id?: string;
  /**
   * @format int32
   */
  number?: number;
  email?: string;
  name?: string;
  first_name?: string;
  last_name?: string;
  company?: string;
  summary?: string;
  body?: string;
  data?: Record<string, any>;
  /**
   * @format dateTime
   */
  created_at?: string;
  site_url?: string;
}[];

export type ListFormSubmissionVariables = {
  pathParams: ListFormSubmissionPathParams;
  queryParams?: ListFormSubmissionQueryParams;
} & FetcherExtraProps;

export const listFormSubmission = (variables: ListFormSubmissionVariables, signal?: AbortSignal) =>
  fetch<
    ListFormSubmissionResponse,
    ListFormSubmissionError,
    undefined,
    {},
    ListFormSubmissionQueryParams,
    ListFormSubmissionPathParams
  >({ url: '/submissions/{submissionId}', method: 'get', ...variables, signal });

export type DeleteSubmissionPathParams = {
  submissionId: string;
};

export type DeleteSubmissionError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type DeleteSubmissionVariables = {
  pathParams: DeleteSubmissionPathParams;
} & FetcherExtraProps;

export const deleteSubmission = (variables: DeleteSubmissionVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteSubmissionError, undefined, {}, {}, DeleteSubmissionPathParams>({
    url: '/submissions/{submissionId}',
    method: 'delete',
    ...variables,
    signal
  });

export type ListServiceInstancesForSitePathParams = {
  siteId: string;
};

export type ListServiceInstancesForSiteError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListServiceInstancesForSiteResponse = {
  id?: string;
  url?: string;
  config?: Record<string, any>;
  external_attributes?: Record<string, any>;
  service_slug?: string;
  service_path?: string;
  service_name?: string;
  env?: Record<string, any>;
  snippets?: Record<string, any>[];
  auth_url?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
}[];

export type ListServiceInstancesForSiteVariables = {
  pathParams: ListServiceInstancesForSitePathParams;
} & FetcherExtraProps;

export const listServiceInstancesForSite = (variables: ListServiceInstancesForSiteVariables, signal?: AbortSignal) =>
  fetch<
    ListServiceInstancesForSiteResponse,
    ListServiceInstancesForSiteError,
    undefined,
    {},
    {},
    ListServiceInstancesForSitePathParams
  >({ url: '/sites/{siteId}/service-instances', method: 'get', ...variables, signal });

export type CreateServiceInstancePathParams = {
  siteId: string;
  addon: string;
};

export type CreateServiceInstanceError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreateServiceInstanceResponse = {
  id?: string;
  url?: string;
  config?: Record<string, any>;
  external_attributes?: Record<string, any>;
  service_slug?: string;
  service_path?: string;
  service_name?: string;
  env?: Record<string, any>;
  snippets?: Record<string, any>[];
  auth_url?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
};

export type CreateServiceInstanceVariables = {
  body?: RequestBodies.UpdateSiteMetadataMetadata;
  pathParams: CreateServiceInstancePathParams;
} & FetcherExtraProps;

export const createServiceInstance = (variables: CreateServiceInstanceVariables, signal?: AbortSignal) =>
  fetch<
    CreateServiceInstanceResponse,
    CreateServiceInstanceError,
    RequestBodies.UpdateSiteMetadataMetadata,
    {},
    {},
    CreateServiceInstancePathParams
  >({ url: '/sites/{siteId}/services/{addon}/instances', method: 'post', ...variables, signal });

export type ShowServiceInstancePathParams = {
  siteId: string;
  addon: string;
  instanceId: string;
};

export type ShowServiceInstanceError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ShowServiceInstanceResponse = {
  id?: string;
  url?: string;
  config?: Record<string, any>;
  external_attributes?: Record<string, any>;
  service_slug?: string;
  service_path?: string;
  service_name?: string;
  env?: Record<string, any>;
  snippets?: Record<string, any>[];
  auth_url?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
};

export type ShowServiceInstanceVariables = {
  pathParams: ShowServiceInstancePathParams;
} & FetcherExtraProps;

export const showServiceInstance = (variables: ShowServiceInstanceVariables, signal?: AbortSignal) =>
  fetch<ShowServiceInstanceResponse, ShowServiceInstanceError, undefined, {}, {}, ShowServiceInstancePathParams>({
    url: '/sites/{siteId}/services/{addon}/instances/{instanceId}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateServiceInstancePathParams = {
  siteId: string;
  addon: string;
  instanceId: string;
};

export type UpdateServiceInstanceError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type UpdateServiceInstanceVariables = {
  body?: RequestBodies.UpdateSiteMetadataMetadata;
  pathParams: UpdateServiceInstancePathParams;
} & FetcherExtraProps;

export const updateServiceInstance = (variables: UpdateServiceInstanceVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    UpdateServiceInstanceError,
    RequestBodies.UpdateSiteMetadataMetadata,
    {},
    {},
    UpdateServiceInstancePathParams
  >({ url: '/sites/{siteId}/services/{addon}/instances/{instanceId}', method: 'put', ...variables, signal });

export type DeleteServiceInstancePathParams = {
  siteId: string;
  addon: string;
  instanceId: string;
};

export type DeleteServiceInstanceError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type DeleteServiceInstanceVariables = {
  pathParams: DeleteServiceInstancePathParams;
} & FetcherExtraProps;

export const deleteServiceInstance = (variables: DeleteServiceInstanceVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteServiceInstanceError, undefined, {}, {}, DeleteServiceInstancePathParams>({
    url: '/sites/{siteId}/services/{addon}/instances/{instanceId}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetServicesQueryParams = {
  search?: string;
};

export type GetServicesError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetServicesResponse = {
  id?: string;
  name?: string;
  slug?: string;
  service_path?: string;
  long_description?: string;
  description?: string;
  events?: Record<string, any>[];
  tags?: string[];
  icon?: string;
  manifest_url?: string;
  environments?: string[];
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
}[];

export type GetServicesVariables = {
  queryParams?: GetServicesQueryParams;
} & FetcherExtraProps;

export const getServices = (variables: GetServicesVariables, signal?: AbortSignal) =>
  fetch<GetServicesResponse, GetServicesError, undefined, {}, GetServicesQueryParams, {}>({
    url: '/services/',
    method: 'get',
    ...variables,
    signal
  });

export type ShowServicePathParams = {
  addonName: string;
};

export type ShowServiceError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ShowServiceResponse = {
  id?: string;
  name?: string;
  slug?: string;
  service_path?: string;
  long_description?: string;
  description?: string;
  events?: Record<string, any>[];
  tags?: string[];
  icon?: string;
  manifest_url?: string;
  environments?: string[];
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
};

export type ShowServiceVariables = {
  pathParams: ShowServicePathParams;
} & FetcherExtraProps;

export const showService = (variables: ShowServiceVariables, signal?: AbortSignal) =>
  fetch<ShowServiceResponse, ShowServiceError, undefined, {}, {}, ShowServicePathParams>({
    url: '/services/{addonName}',
    method: 'get',
    ...variables,
    signal
  });

export type ShowServiceManifestPathParams = {
  addonName: string;
};

export type ShowServiceManifestError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ShowServiceManifestVariables = {
  pathParams: ShowServiceManifestPathParams;
} & FetcherExtraProps;

export const showServiceManifest = (variables: ShowServiceManifestVariables, signal?: AbortSignal) =>
  fetch<Record<string, any>, ShowServiceManifestError, undefined, {}, {}, ShowServiceManifestPathParams>({
    url: '/services/{addonName}/manifest',
    method: 'get',
    ...variables,
    signal
  });

export type GetCurrentUserError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetCurrentUserResponse = {
  id?: string;
  uid?: string;
  full_name?: string;
  avatar_url?: string;
  email?: string;
  affiliate_id?: string;
  /**
   * @format int64
   */
  site_count?: number;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  last_login?: string;
  login_providers?: string[];
  onboarding_progress?: {
    slides?: string;
  };
}[];

export type GetCurrentUserVariables = FetcherExtraProps;

export const getCurrentUser = (variables: GetCurrentUserVariables, signal?: AbortSignal) =>
  fetch<GetCurrentUserResponse, GetCurrentUserError, undefined, {}, {}, {}>({
    url: '/user',
    method: 'get',
    ...variables,
    signal
  });

export type CreateSplitTestPathParams = {
  siteId: string;
};

export type CreateSplitTestError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreateSplitTestResponse = {
  id?: string;
  site_id?: string;
  name?: string;
  path?: string;
  branches?: Record<string, any>[];
  active?: boolean;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  /**
   * @format dateTime
   */
  unpublished_at?: string;
};

export type CreateSplitTestVariables = {
  body?: RequestBodies.CreateSplitTestBranchTests;
  pathParams: CreateSplitTestPathParams;
} & FetcherExtraProps;

export const createSplitTest = (variables: CreateSplitTestVariables, signal?: AbortSignal) =>
  fetch<
    CreateSplitTestResponse,
    CreateSplitTestError,
    RequestBodies.CreateSplitTestBranchTests,
    {},
    {},
    CreateSplitTestPathParams
  >({ url: '/sites/{siteId}/traffic_splits', method: 'post', ...variables, signal });

export type GetSplitTestsPathParams = {
  siteId: string;
};

export type GetSplitTestsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetSplitTestsResponse = {
  id?: string;
  site_id?: string;
  name?: string;
  path?: string;
  branches?: Record<string, any>[];
  active?: boolean;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  /**
   * @format dateTime
   */
  unpublished_at?: string;
}[];

export type GetSplitTestsVariables = {
  pathParams: GetSplitTestsPathParams;
} & FetcherExtraProps;

export const getSplitTests = (variables: GetSplitTestsVariables, signal?: AbortSignal) =>
  fetch<GetSplitTestsResponse, GetSplitTestsError, undefined, {}, {}, GetSplitTestsPathParams>({
    url: '/sites/{siteId}/traffic_splits',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateSplitTestPathParams = {
  siteId: string;
  splitTestId: string;
};

export type UpdateSplitTestError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type UpdateSplitTestResponse = {
  id?: string;
  site_id?: string;
  name?: string;
  path?: string;
  branches?: Record<string, any>[];
  active?: boolean;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  /**
   * @format dateTime
   */
  unpublished_at?: string;
};

export type UpdateSplitTestVariables = {
  body?: RequestBodies.CreateSplitTestBranchTests;
  pathParams: UpdateSplitTestPathParams;
} & FetcherExtraProps;

export const updateSplitTest = (variables: UpdateSplitTestVariables, signal?: AbortSignal) =>
  fetch<
    UpdateSplitTestResponse,
    UpdateSplitTestError,
    RequestBodies.CreateSplitTestBranchTests,
    {},
    {},
    UpdateSplitTestPathParams
  >({ url: '/sites/{siteId}/traffic_splits/{splitTestId}', method: 'put', ...variables, signal });

export type GetSplitTestPathParams = {
  siteId: string;
  splitTestId: string;
};

export type GetSplitTestError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetSplitTestResponse = {
  id?: string;
  site_id?: string;
  name?: string;
  path?: string;
  branches?: Record<string, any>[];
  active?: boolean;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  /**
   * @format dateTime
   */
  unpublished_at?: string;
};

export type GetSplitTestVariables = {
  pathParams: GetSplitTestPathParams;
} & FetcherExtraProps;

export const getSplitTest = (variables: GetSplitTestVariables, signal?: AbortSignal) =>
  fetch<GetSplitTestResponse, GetSplitTestError, undefined, {}, {}, GetSplitTestPathParams>({
    url: '/sites/{siteId}/traffic_splits/{splitTestId}',
    method: 'get',
    ...variables,
    signal
  });

export type EnableSplitTestPathParams = {
  siteId: string;
  splitTestId: string;
};

export type EnableSplitTestError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type EnableSplitTestVariables = {
  pathParams: EnableSplitTestPathParams;
} & FetcherExtraProps;

export const enableSplitTest = (variables: EnableSplitTestVariables, signal?: AbortSignal) =>
  fetch<undefined, EnableSplitTestError, undefined, {}, {}, EnableSplitTestPathParams>({
    url: '/sites/{siteId}/traffic_splits/{splitTestId}/publish',
    method: 'post',
    ...variables,
    signal
  });

export type DisableSplitTestPathParams = {
  siteId: string;
  splitTestId: string;
};

export type DisableSplitTestError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type DisableSplitTestVariables = {
  pathParams: DisableSplitTestPathParams;
} & FetcherExtraProps;

export const disableSplitTest = (variables: DisableSplitTestVariables, signal?: AbortSignal) =>
  fetch<undefined, DisableSplitTestError, undefined, {}, {}, DisableSplitTestPathParams>({
    url: '/sites/{siteId}/traffic_splits/{splitTestId}/unpublish',
    method: 'post',
    ...variables,
    signal
  });

export type CreateDnsZoneError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreateDnsZoneResponse = {
  id?: string;
  name?: string;
  errors?: string[];
  supported_record_types?: string[];
  user_id?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  records?: {
    id?: string;
    hostname?: string;
    type?: string;
    value?: string;
    /**
     * @format int64
     */
    ttl?: number;
    /**
     * @format int64
     */
    priority?: number;
    dns_zone_id?: string;
    site_id?: string;
    flag?: number;
    tag?: string;
    managed?: boolean;
  }[];
  dns_servers?: string[];
  account_id?: string;
  site_id?: string;
  account_slug?: string;
  account_name?: string;
  domain?: string;
  ipv6_enabled?: boolean;
  dedicated?: boolean;
};

export type CreateDnsZoneRequestBody = {
  account_slug?: string;
  site_id?: string;
  name?: string;
};

export type CreateDnsZoneVariables = {
  body?: CreateDnsZoneRequestBody;
} & FetcherExtraProps;

export const createDnsZone = (variables: CreateDnsZoneVariables, signal?: AbortSignal) =>
  fetch<CreateDnsZoneResponse, CreateDnsZoneError, CreateDnsZoneRequestBody, {}, {}, {}>({
    url: '/dns_zones',
    method: 'post',
    ...variables,
    signal
  });

export type GetDnsZonesQueryParams = {
  account_slug?: string;
};

export type GetDnsZonesError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetDnsZonesResponse = {
  id?: string;
  name?: string;
  errors?: string[];
  supported_record_types?: string[];
  user_id?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  records?: {
    id?: string;
    hostname?: string;
    type?: string;
    value?: string;
    /**
     * @format int64
     */
    ttl?: number;
    /**
     * @format int64
     */
    priority?: number;
    dns_zone_id?: string;
    site_id?: string;
    flag?: number;
    tag?: string;
    managed?: boolean;
  }[];
  dns_servers?: string[];
  account_id?: string;
  site_id?: string;
  account_slug?: string;
  account_name?: string;
  domain?: string;
  ipv6_enabled?: boolean;
  dedicated?: boolean;
}[];

export type GetDnsZonesVariables = {
  queryParams?: GetDnsZonesQueryParams;
} & FetcherExtraProps;

export const getDnsZones = (variables: GetDnsZonesVariables, signal?: AbortSignal) =>
  fetch<GetDnsZonesResponse, GetDnsZonesError, undefined, {}, GetDnsZonesQueryParams, {}>({
    url: '/dns_zones',
    method: 'get',
    ...variables,
    signal
  });

export type GetDnsZonePathParams = {
  zoneId: string;
};

export type GetDnsZoneError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetDnsZoneResponse = {
  id?: string;
  name?: string;
  errors?: string[];
  supported_record_types?: string[];
  user_id?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  records?: {
    id?: string;
    hostname?: string;
    type?: string;
    value?: string;
    /**
     * @format int64
     */
    ttl?: number;
    /**
     * @format int64
     */
    priority?: number;
    dns_zone_id?: string;
    site_id?: string;
    flag?: number;
    tag?: string;
    managed?: boolean;
  }[];
  dns_servers?: string[];
  account_id?: string;
  site_id?: string;
  account_slug?: string;
  account_name?: string;
  domain?: string;
  ipv6_enabled?: boolean;
  dedicated?: boolean;
};

export type GetDnsZoneVariables = {
  pathParams: GetDnsZonePathParams;
} & FetcherExtraProps;

export const getDnsZone = (variables: GetDnsZoneVariables, signal?: AbortSignal) =>
  fetch<GetDnsZoneResponse, GetDnsZoneError, undefined, {}, {}, GetDnsZonePathParams>({
    url: '/dns_zones/{zoneId}',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteDnsZonePathParams = {
  zoneId: string;
};

export type DeleteDnsZoneError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type DeleteDnsZoneVariables = {
  pathParams: DeleteDnsZonePathParams;
} & FetcherExtraProps;

export const deleteDnsZone = (variables: DeleteDnsZoneVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteDnsZoneError, undefined, {}, {}, DeleteDnsZonePathParams>({
    url: '/dns_zones/{zoneId}',
    method: 'delete',
    ...variables,
    signal
  });

export type TransferDnsZonePathParams = {
  zoneId: string;
};

export type TransferDnsZoneQueryParams = {
  /**
   * the account of the dns zone
   */
  account_id: string;
  /**
   * the account you want to transfer the dns zone to
   */
  transfer_account_id: string;
  /**
   * the user you want to transfer the dns zone to
   */
  transfer_user_id: string;
};

export type TransferDnsZoneError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type TransferDnsZoneResponse = {
  id?: string;
  name?: string;
  errors?: string[];
  supported_record_types?: string[];
  user_id?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  records?: {
    id?: string;
    hostname?: string;
    type?: string;
    value?: string;
    /**
     * @format int64
     */
    ttl?: number;
    /**
     * @format int64
     */
    priority?: number;
    dns_zone_id?: string;
    site_id?: string;
    flag?: number;
    tag?: string;
    managed?: boolean;
  }[];
  dns_servers?: string[];
  account_id?: string;
  site_id?: string;
  account_slug?: string;
  account_name?: string;
  domain?: string;
  ipv6_enabled?: boolean;
  dedicated?: boolean;
};

export type TransferDnsZoneVariables = {
  pathParams: TransferDnsZonePathParams;
  queryParams: TransferDnsZoneQueryParams;
} & FetcherExtraProps;

export const transferDnsZone = (variables: TransferDnsZoneVariables, signal?: AbortSignal) =>
  fetch<
    TransferDnsZoneResponse,
    TransferDnsZoneError,
    undefined,
    {},
    TransferDnsZoneQueryParams,
    TransferDnsZonePathParams
  >({ url: '/dns_zones/{zoneId}/transfer', method: 'put', ...variables, signal });

export type GetDnsRecordsPathParams = {
  zoneId: string;
};

export type GetDnsRecordsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetDnsRecordsResponse = {
  id?: string;
  hostname?: string;
  type?: string;
  value?: string;
  /**
   * @format int64
   */
  ttl?: number;
  /**
   * @format int64
   */
  priority?: number;
  dns_zone_id?: string;
  site_id?: string;
  flag?: number;
  tag?: string;
  managed?: boolean;
}[];

export type GetDnsRecordsVariables = {
  pathParams: GetDnsRecordsPathParams;
} & FetcherExtraProps;

export const getDnsRecords = (variables: GetDnsRecordsVariables, signal?: AbortSignal) =>
  fetch<GetDnsRecordsResponse, GetDnsRecordsError, undefined, {}, {}, GetDnsRecordsPathParams>({
    url: '/dns_zones/{zoneId}/dns_records',
    method: 'get',
    ...variables,
    signal
  });

export type CreateDnsRecordPathParams = {
  zoneId: string;
};

export type CreateDnsRecordError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreateDnsRecordResponse = {
  id?: string;
  hostname?: string;
  type?: string;
  value?: string;
  /**
   * @format int64
   */
  ttl?: number;
  /**
   * @format int64
   */
  priority?: number;
  dns_zone_id?: string;
  site_id?: string;
  flag?: number;
  tag?: string;
  managed?: boolean;
};

export type CreateDnsRecordRequestBody = {
  type?: string;
  hostname?: string;
  value?: string;
  /**
   * @format int64
   */
  ttl?: number;
  /**
   * @format int64
   */
  priority?: number;
  /**
   * @format int64
   */
  weight?: number;
  /**
   * @format int64
   */
  port?: number;
  /**
   * @format int64
   */
  flag?: number;
  tag?: string;
};

export type CreateDnsRecordVariables = {
  body?: CreateDnsRecordRequestBody;
  pathParams: CreateDnsRecordPathParams;
} & FetcherExtraProps;

export const createDnsRecord = (variables: CreateDnsRecordVariables, signal?: AbortSignal) =>
  fetch<CreateDnsRecordResponse, CreateDnsRecordError, CreateDnsRecordRequestBody, {}, {}, CreateDnsRecordPathParams>({
    url: '/dns_zones/{zoneId}/dns_records',
    method: 'post',
    ...variables,
    signal
  });

export type GetIndividualDnsRecordPathParams = {
  zoneId: string;
  dnsRecordId: string;
};

export type GetIndividualDnsRecordError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetIndividualDnsRecordResponse = {
  id?: string;
  hostname?: string;
  type?: string;
  value?: string;
  /**
   * @format int64
   */
  ttl?: number;
  /**
   * @format int64
   */
  priority?: number;
  dns_zone_id?: string;
  site_id?: string;
  flag?: number;
  tag?: string;
  managed?: boolean;
};

export type GetIndividualDnsRecordVariables = {
  pathParams: GetIndividualDnsRecordPathParams;
} & FetcherExtraProps;

export const getIndividualDnsRecord = (variables: GetIndividualDnsRecordVariables, signal?: AbortSignal) =>
  fetch<
    GetIndividualDnsRecordResponse,
    GetIndividualDnsRecordError,
    undefined,
    {},
    {},
    GetIndividualDnsRecordPathParams
  >({ url: '/dns_zones/{zoneId}/dns_records/{dnsRecordId}', method: 'get', ...variables, signal });

export type DeleteDnsRecordPathParams = {
  zoneId: string;
  dnsRecordId: string;
};

export type DeleteDnsRecordError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type DeleteDnsRecordVariables = {
  pathParams: DeleteDnsRecordPathParams;
} & FetcherExtraProps;

export const deleteDnsRecord = (variables: DeleteDnsRecordVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteDnsRecordError, undefined, {}, {}, DeleteDnsRecordPathParams>({
    url: '/dns_zones/{zoneId}/dns_records/{dnsRecordId}',
    method: 'delete',
    ...variables,
    signal
  });

export type ListSiteDevServersPathParams = {
  siteId: string;
};

export type ListSiteDevServersQueryParams = {
  /**
   * @format int32
   */
  page?: number;
  /**
   * @format int32
   */
  per_page?: number;
};

export type ListSiteDevServersError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListSiteDevServersResponse = {
  id?: string;
  site_id?: string;
  branch?: string;
  url?: string;
  state?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  /**
   * @format dateTime
   */
  starting_at?: string;
  /**
   * @format dateTime
   */
  error_at?: string;
  /**
   * @format dateTime
   */
  live_at?: string;
  /**
   * @format dateTime
   */
  done_at?: string;
  title?: string;
}[];

export type ListSiteDevServersVariables = {
  pathParams: ListSiteDevServersPathParams;
  queryParams?: ListSiteDevServersQueryParams;
} & FetcherExtraProps;

export const listSiteDevServers = (variables: ListSiteDevServersVariables, signal?: AbortSignal) =>
  fetch<
    ListSiteDevServersResponse,
    ListSiteDevServersError,
    undefined,
    {},
    ListSiteDevServersQueryParams,
    ListSiteDevServersPathParams
  >({ url: '/sites/{siteId}/dev_servers', method: 'get', ...variables, signal });

export type CreateSiteDevServerPathParams = {
  siteId: string;
};

export type CreateSiteDevServerQueryParams = {
  branch?: string;
};

export type CreateSiteDevServerError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreateSiteDevServerResponse = {
  id?: string;
  site_id?: string;
  branch?: string;
  url?: string;
  state?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  /**
   * @format dateTime
   */
  starting_at?: string;
  /**
   * @format dateTime
   */
  error_at?: string;
  /**
   * @format dateTime
   */
  live_at?: string;
  /**
   * @format dateTime
   */
  done_at?: string;
  title?: string;
}[];

export type CreateSiteDevServerVariables = {
  pathParams: CreateSiteDevServerPathParams;
  queryParams?: CreateSiteDevServerQueryParams;
} & FetcherExtraProps;

export const createSiteDevServer = (variables: CreateSiteDevServerVariables, signal?: AbortSignal) =>
  fetch<
    CreateSiteDevServerResponse,
    CreateSiteDevServerError,
    undefined,
    {},
    CreateSiteDevServerQueryParams,
    CreateSiteDevServerPathParams
  >({ url: '/sites/{siteId}/dev_servers', method: 'post', ...variables, signal });

export type DeleteSiteDevServersPathParams = {
  siteId: string;
};

export type DeleteSiteDevServersQueryParams = {
  branch?: string;
};

export type DeleteSiteDevServersError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 202>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type DeleteSiteDevServersVariables = {
  pathParams: DeleteSiteDevServersPathParams;
  queryParams?: DeleteSiteDevServersQueryParams;
} & FetcherExtraProps;

export const deleteSiteDevServers = (variables: DeleteSiteDevServersVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    DeleteSiteDevServersError,
    undefined,
    {},
    DeleteSiteDevServersQueryParams,
    DeleteSiteDevServersPathParams
  >({ url: '/sites/{siteId}/dev_servers', method: 'delete', ...variables, signal });

export type GetSiteDevServerPathParams = {
  siteId: string;
  devServerId: string;
};

export type GetSiteDevServerError = Fetcher.ErrorWrapper<undefined>;

export type GetSiteDevServerResponse = {
  id?: string;
  site_id?: string;
  branch?: string;
  url?: string;
  state?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  /**
   * @format dateTime
   */
  updated_at?: string;
  /**
   * @format dateTime
   */
  starting_at?: string;
  /**
   * @format dateTime
   */
  error_at?: string;
  /**
   * @format dateTime
   */
  live_at?: string;
  /**
   * @format dateTime
   */
  done_at?: string;
  title?: string;
};

export type GetSiteDevServerVariables = {
  pathParams: GetSiteDevServerPathParams;
} & FetcherExtraProps;

export const getSiteDevServer = (variables: GetSiteDevServerVariables, signal?: AbortSignal) =>
  fetch<GetSiteDevServerResponse, GetSiteDevServerError, undefined, {}, {}, GetSiteDevServerPathParams>({
    url: '/sites/{siteId}/dev_servers/{devServerId}',
    method: 'get',
    ...variables,
    signal
  });

export type MarkDevServerActivityPathParams = {
  siteId: string;
  devServerId: string;
};

export type MarkDevServerActivityError = Fetcher.ErrorWrapper<undefined>;

export type MarkDevServerActivityVariables = {
  pathParams: MarkDevServerActivityPathParams;
} & FetcherExtraProps;

export const markDevServerActivity = (variables: MarkDevServerActivityVariables, signal?: AbortSignal) =>
  fetch<undefined, MarkDevServerActivityError, undefined, {}, {}, MarkDevServerActivityPathParams>({
    url: '/sites/{siteId}/dev_servers/{devServerId}/activity',
    method: 'post',
    ...variables,
    signal
  });

export type ListSiteDevServerHooksPathParams = {
  siteId: string;
};

export type ListSiteDevServerHooksError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type ListSiteDevServerHooksResponse = {
  id?: string;
  title?: string;
  branch?: string;
  url?: string;
  site_id?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  type?: 'new_dev_server' | 'content_refresh';
}[];

export type ListSiteDevServerHooksVariables = {
  pathParams: ListSiteDevServerHooksPathParams;
} & FetcherExtraProps;

export const listSiteDevServerHooks = (variables: ListSiteDevServerHooksVariables, signal?: AbortSignal) =>
  fetch<
    ListSiteDevServerHooksResponse,
    ListSiteDevServerHooksError,
    undefined,
    {},
    {},
    ListSiteDevServerHooksPathParams
  >({ url: '/sites/{siteId}/dev_server_hooks', method: 'get', ...variables, signal });

export type CreateSiteDevServerHookPathParams = {
  siteId: string;
};

export type CreateSiteDevServerHookError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type CreateSiteDevServerHookResponse = {
  id?: string;
  title?: string;
  branch?: string;
  url?: string;
  site_id?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  type?: 'new_dev_server' | 'content_refresh';
};

export type CreateSiteDevServerHookVariables = {
  body?: RequestBodies.CreateSiteDevServerHookDevserverhook;
  pathParams: CreateSiteDevServerHookPathParams;
} & FetcherExtraProps;

export const createSiteDevServerHook = (variables: CreateSiteDevServerHookVariables, signal?: AbortSignal) =>
  fetch<
    CreateSiteDevServerHookResponse,
    CreateSiteDevServerHookError,
    RequestBodies.CreateSiteDevServerHookDevserverhook,
    {},
    {},
    CreateSiteDevServerHookPathParams
  >({ url: '/sites/{siteId}/dev_server_hooks', method: 'post', ...variables, signal });

export type GetSiteDevServerHookPathParams = {
  siteId: string;
  id: string;
};

export type GetSiteDevServerHookError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type GetSiteDevServerHookResponse = {
  id?: string;
  title?: string;
  branch?: string;
  url?: string;
  site_id?: string;
  /**
   * @format dateTime
   */
  created_at?: string;
  type?: 'new_dev_server' | 'content_refresh';
};

export type GetSiteDevServerHookVariables = {
  pathParams: GetSiteDevServerHookPathParams;
} & FetcherExtraProps;

export const getSiteDevServerHook = (variables: GetSiteDevServerHookVariables, signal?: AbortSignal) =>
  fetch<GetSiteDevServerHookResponse, GetSiteDevServerHookError, undefined, {}, {}, GetSiteDevServerHookPathParams>({
    url: '/sites/{siteId}/dev_server_hooks/{id}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateSiteDevServerHookPathParams = {
  siteId: string;
  id: string;
};

export type UpdateSiteDevServerHookError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type UpdateSiteDevServerHookVariables = {
  body?: RequestBodies.CreateSiteDevServerHookDevserverhook;
  pathParams: UpdateSiteDevServerHookPathParams;
} & FetcherExtraProps;

export const updateSiteDevServerHook = (variables: UpdateSiteDevServerHookVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    UpdateSiteDevServerHookError,
    RequestBodies.CreateSiteDevServerHookDevserverhook,
    {},
    {},
    UpdateSiteDevServerHookPathParams
  >({ url: '/sites/{siteId}/dev_server_hooks/{id}', method: 'put', ...variables, signal });

export type DeleteSiteDevServerHookPathParams = {
  siteId: string;
  id: string;
};

export type DeleteSiteDevServerHookError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 204>;
  payload: {
    /**
     * @format int64
     */
    code?: number;
    message: string;
  };
}>;

export type DeleteSiteDevServerHookVariables = {
  pathParams: DeleteSiteDevServerHookPathParams;
} & FetcherExtraProps;

export const deleteSiteDevServerHook = (variables: DeleteSiteDevServerHookVariables, signal?: AbortSignal) =>
  fetch<undefined, DeleteSiteDevServerHookError, undefined, {}, {}, DeleteSiteDevServerHookPathParams>({
    url: '/sites/{siteId}/dev_server_hooks/{id}',
    method: 'delete',
    ...variables,
    signal
  });

export const operationsByTag = {
  site: {
    listSites,
    createSite,
    getSite,
    updateSite,
    deleteSite,
    unlinkSiteRepo,
    createSiteInTeam,
    listSitesForAccount
  },
  sniCertificate: { provisionSiteTLSCertificate, showSiteTLSCertificate },
  environmentVariables: {
    getEnvVars,
    createEnvVars,
    getSiteEnvVars,
    getEnvVar,
    updateEnvVar,
    setEnvVarValue,
    deleteEnvVar,
    deleteEnvVarValue
  },
  function: { searchSiteFunctions, uploadDeployFunction },
  form: { listSiteForms, deleteSiteForm },
  submission: { listSiteSubmissions, listFormSubmissions, listFormSubmission, deleteSubmission },
  file: { listSiteFiles, getSiteFileByPathName, uploadDeployFile },
  asset: { listSiteAssets, createSiteAsset, getSiteAssetInfo, updateSiteAsset, deleteSiteAsset },
  assetPublicSignature: { getSiteAssetPublicSignature },
  purge: { purgeCache },
  snippet: { listSiteSnippets, createSiteSnippet, getSiteSnippet, updateSiteSnippet, deleteSiteSnippet },
  metadata: { getSiteMetadata, updateSiteMetadata },
  buildHook: { listSiteBuildHooks, createSiteBuildHook, getSiteBuildHook, updateSiteBuildHook, deleteSiteBuildHook },
  deploy: {
    listSiteDeploys,
    createSiteDeploy,
    getSiteDeploy,
    updateSiteDeploy,
    deleteSiteDeploy,
    cancelSiteDeploy,
    restoreSiteDeploy,
    rollbackSiteDeploy,
    getDeploy,
    deleteDeploy,
    lockDeploy,
    unlockDeploy
  },
  build: { listSiteBuilds, createSiteBuild, getSiteBuild, notifyBuildStart, getAccountBuildStatus },
  deployedBranch: { listSiteDeployedBranches },
  buildLogMsg: { updateSiteBuildLog },
  dnsZone: {
    getDNSForSite,
    configureDNSForSite,
    createDnsZone,
    getDnsZones,
    getDnsZone,
    deleteDnsZone,
    transferDnsZone,
    getDnsRecords,
    createDnsRecord,
    getIndividualDnsRecord,
    deleteDnsRecord
  },
  xInternal: { updatePlugin, getLatestPluginRuns, createPluginRun },
  hook: { listHooksBySiteId, createHookBySiteId, getHook, updateHook, deleteHook, enableHook },
  hookType: { listHookTypes },
  ticket: { createTicket, showTicket },
  accessToken: { exchangeTicket },
  deployKey: { listDeployKeys, createDeployKey, getDeployKey, deleteDeployKey },
  member: { listMembersForAccount, addMemberToAccount, getAccountMember, updateAccountMember, removeAccountMember },
  paymentMethod: { listPaymentMethodsForUser },
  accountType: { listAccountTypesForUser },
  accountMembership: { listAccountsForUser, createAccount, getAccount, updateAccount, cancelAccount },
  auditLog: { listAccountAuditEvents },
  serviceInstance: {
    listServiceInstancesForSite,
    createServiceInstance,
    showServiceInstance,
    updateServiceInstance,
    deleteServiceInstance
  },
  service: { getServices, showService, showServiceManifest },
  user: { getCurrentUser },
  splitTest: { createSplitTest, getSplitTests, updateSplitTest, getSplitTest, enableSplitTest, disableSplitTest },
  devServer: { listSiteDevServers, createSiteDevServer, deleteSiteDevServers, getSiteDevServer, markDevServerActivity },
  devServerHook: {
    listSiteDevServerHooks,
    createSiteDevServerHook,
    getSiteDevServerHook,
    updateSiteDevServerHook,
    deleteSiteDevServerHook
  }
};
