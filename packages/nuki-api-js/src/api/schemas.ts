/**
 * Generated by @openapi-codegen
 *
 * @version 4.0.0
 */
export type Account = {
  /**
   * The account id
   *
   * @format int32
   */
  accountId: number;
  /**
   * The type: 0 .. user, 1 .. company, 2 .. caretaker
   *
   * @format int32
   * @minimum 0
   * @maximum 2
   */
  type: number;
  /**
   * The email address
   */
  email: string;
  /**
   * true, if the email is verified
   */
  emailVerified?: boolean;
  /**
   * The name
   */
  name: string;
  /**
   * The master account id if it's a sub account
   *
   * @format int32
   */
  masterAccountId?: number;
  /**
   * The rights bitmask if it's a sub account: 1 .. manage smartlock, 2 .. operate smartlock, 4 .. manage smartlock config, 8 .. manage smartlock authorizations, 16 .. view smartlock logs, 32 .. manage sub accounts, 64 .. create smartlocks
   *
   * @format int32
   * @minimum 0
   * @maximum 127
   */
  rights?: number;
  /**
   * The language code
   *
   * @example de
   */
  language?: string;
  config?: AccountConfig;
  profile?: AccountProfile;
  /**
   * The creation date
   *
   * @format date-time
   */
  creationDate: string;
  /**
   * The update date
   *
   * @format date-time
   */
  updateDate: string;
  descent?: AccountDescent;
  /**
   * subscription type of the account (b2b)
   */
  shsSubscriptionType?: "BUSINESS" | "STANDARD" | "BUSINESS_PLUS" | "API_ONLY";
  b2bActive?: boolean;
  apiTermsOfUse?: TermsOfUse;
};

export type AccountConfig = {
  /**
   * The alexa pin - used by alexa for unlock actions
   */
  alexaPin: string;
  /**
   * The google smart home pin - used for unlock actions
   */
  gactionsHomePin: string;
  /**
   * The opt enabled date
   *
   * @format date-time
   */
  otpEnabledDate?: string;
};

export type AccountDescent = {
  /**
   * The account origin source
   */
  origin: "GOOGLE" | "APPLE";
};

export type AccountProfile = {
  /**
   * The first name
   */
  firstName: string;
  /**
   * The last name
   */
  lastName: string;
  /**
   * The address
   */
  address: string;
  /**
   * The postal code
   */
  zip: string;
  /**
   * The city
   */
  city: string;
  /**
   * The 2-letter country code
   */
  country: string;
};

export type AccountEmailChange = {
  /**
   * The new email for the account
   */
  email: string;
};

export type AccountIntegration = {
  /**
   * If the integration/device is an legacy or from the new oauth implementation
   */
  version: "LEGACY" | "HYDRA";
  /**
   * Enum key identifying the integration/device, values are e.g. ALEXA, IOS, NUKI_WEB, API_TOKEN etc
   */
  vendorKey: string;
  /**
   * Name of the sub-account or null if there is none, which is associated with this token
   */
  subAccountName?: string;
  /**
   * Id of the sub-account or null if there is none, which is associated with this token
   *
   * @format int32
   */
  subAccountId?: number;
  /**
   * True if the integration is done via a sub-account
   */
  subAccount?: boolean;
  /**
   * Name of the token
   */
  name: string;
  /**
   * Description given by the user, usually only set for api tokens
   */
  description?: string;
  /**
   * First creation date of the token
   *
   * @format date-time
   */
  createdAt?: string;
  /**
   * Last refresh date of the token
   *
   * @format date-time
   */
  lastActiveAt?: string;
  /**
   * The scopes which have been granted to the token
   */
  scopes?: string[];
  /**
   * If this is from a legacy integration this is set to true
   */
  warning?: boolean;
  /**
   * The tokenId if this a manual generated api token
   */
  tokenId?: string;
  /**
   * The enum advanced type (HEALTHCARE e.g.) if this integration is a advanced one
   */
  advancedType?: string;
  /**
   * The enum advanced state (TESTING e.g.) if this integration is a advanced one
   */
  advancedState?: string;
  /**
   * The clientId of this integration/device used for deleting the integration
   */
  clientId: string;
  /**
   * Sort order by which the entry should be sorted, is being set by the vendor key enum
   *
   * @format int32
   */
  sortOrder?: number;
  /**
   * True this is a device and false this is an integration
   */
  device?: boolean;
};

export type AccountOtpEnable = {
  /**
   * The one time password (otp)
   */
  otp: string;
};

export type AccountPasswordReset = {
  email: string;
  deleteApiTokens?: boolean;
};

export type AccountSetting = {
  web?: AccountSettingWeb;
};

export type AccountSettingWeb = {
  /**
   * The initial view type of the device page
   */
  deviceViewType?: "LIST" | "TILE";
  /**
   * The initial sort type of the device page
   */
  deviceSortType?:
    | "FAVOURITES_FIRST"
    | "NAME_ASC"
    | "NAME_DESC"
    | "LAST_ADDED_DESC";
  /**
   * If true, Nuki Club info is dismissed and no banner is shown
   */
  nukiClubDismissed?: boolean;
  /**
   * List of removed staled devices
   */
  removedStaledDevices?: StaleDevice[];
  /**
   * List of marked staled devices
   */
  markedStaledDevices?: StaleDevice[];
};

export type AccountSubCreate = {
  /**
   * The email address
   *
   * @example test@test.at
   */
  email: string;
  /**
   * The password (must be at least 7 chars long)
   */
  password: string;
  /**
   * The name of the sub account
   */
  name: string;
  /**
   * The right bitmask of the sub account: 1 .. operate smartlock, 2 .. change smartlock config, 4 .. manage smartlock users, 8 .. view smartlock logs, 16 .. manage sub accounts
   *
   * @format int32
   * @minimum 0
   * @maximum 31
   */
  rights: number;
  /**
   * The language code
   *
   * @example de
   */
  language: string;
  profile?: AccountProfile;
};

export type AccountSubUpdate = {
  /**
   * The new email address
   *
   * @example test@test.at
   */
  email?: string;
  /**
   * The new password (must be at least 7 chars long)
   */
  password?: string;
  /**
   * The new name of the sub account
   */
  name?: string;
  /**
   * The new right bitmask of the sub account: 1 .. operate smartlock, 2 .. change smartlock config, 4 .. manage smartlock users, 8 .. view smartlock logs, 16 .. manage sub accounts, 32 .. manage sub accounts, 64 .. create smartlocks
   *
   * @format int32
   * @minimum 0
   * @maximum 127
   */
  rights?: number;
  /**
   * The language code
   *
   * @example de
   */
  language: string;
  config?: AccountConfig;
  profile?: AccountProfile;
};

export type AccountUpdate = {
  /**
   * The new email address
   *
   * @example test@test.at
   */
  email?: string;
  /**
   * The password (must be at least 7 chars long)
   */
  password?: string;
  /**
   * The name of the account
   */
  name?: string;
  /**
   * The language code
   *
   * @example de
   */
  language: string;
  config?: AccountConfig;
  profile?: AccountProfile;
};

export type AccountUser = {
  /**
   * The account user id
   *
   * @format int32
   */
  accountUserId: number;
  /**
   * The account id
   *
   * @format int32
   */
  accountId: number;
  /**
   * The optional type: 0 .. user, 1 .. company
   *
   * @format int32
   * @minimum 0
   * @maximum 1
   */
  type?: number;
  /**
   * The email address
   */
  email: string;
  /**
   * The name
   */
  name: string;
  /**
   * The language code
   *
   * @example de
   */
  language?: string;
  /**
   * The operation id - if set it's locked for another operation
   */
  operationId?: string;
  /**
   * The creation date
   *
   * @format date-time
   */
  creationDate: string;
  /**
   * The update date
   *
   * @format date-time
   */
  updateDate: string;
};

export type AccountUserCreate = {
  /**
   * The optional type - only allowed for caretakers: 0 .. user, 1 .. company
   *
   * @format int32
   * @minimum 0
   * @maximum 1
   */
  type?: number;
  /**
   * The email address
   */
  email: string;
  /**
   * The name
   */
  name: string;
  /**
   * The language code
   */
  language?: "en" | "de" | "es" | "fr" | "it" | "nl" | "cs" | "sk";
};

export type AccountUserUpdate = {
  /**
   * The new email address
   *
   * @example test@test.at
   */
  email?: string;
  /**
   * The new name of the sub account
   */
  name?: string;
  /**
   * The new language code
   */
  language?: "en" | "de" | "es" | "fr" | "it" | "nl" | "cs" | "sk";
};

export type Address = {
  /**
   * The address id
   *
   * @format int32
   */
  addressId: number;
  /**
   * The account id
   *
   * @format int32
   */
  accountId: number;
  /**
   * The name of the address
   */
  name: string;
  /**
   * The smartlocks for this address
   */
  smartlockIds: number[];
  /**
   * The optional service id if the address is from an partner service
   */
  serviceId?: "airbnb" | "bookingsync";
  /**
   * The timezone
   */
  timeZone?: string;
  /**
   * The optional check in time (minutes of the day)
   *
   * @format int32
   */
  checkInTime?: number;
  /**
   * The optional check out time (minutes of the day)
   *
   * @format int32
   */
  checkOutTime?: number;
  /**
   * The optional settings object
   */
  settings?: {
    [key: string]: Record<string, any>;
  };
  /**
   * The creation date
   *
   * @format date-time
   */
  creationDate: string;
  /**
   * The update date
   *
   * @format date-time
   */
  updateDate: string;
};

export type AddressCreate = {
  /**
   * The name of the address
   */
  name: string;
  /**
   * The smartlocks for this address
   */
  smartlockIds: number[];
};

export type AddressReservation = {
  /**
   * The id
   */
  id: string;
  /**
   * The address id
   *
   * @format int32
   */
  addressId: number;
  /**
   * The account id
   *
   * @format int32
   */
  accountId: number;
  /**
   * The email of the guest
   */
  email: string;
  /**
   * The name of the guest
   */
  name: string;
  /**
   * The number of guests
   *
   * @format int32
   */
  guests: number;
  /**
   * The number of guests issued
   *
   * @format int32
   */
  guestsIssued: number;
  /**
   * True if a keypad authorization was issued
   */
  keypadIssued: boolean;
  /**
   * The state
   */
  state: "canceled" | "accepted";
  /**
   * The optional service id if the address is from an partner service
   */
  serviceId?: "airbnb" | "bookingsync";
  /**
   * The reference (booking code)
   */
  reference?: string;
  /**
   * The automation state
   *
   * @format int32
   */
  automation: number;
  /**
   * True if the user has checked in, false if the check in is pending, null if it isn't monitored
   */
  checkedIn?: boolean;
  /**
   * The start date
   *
   * @format date-time
   */
  startDate: string;
  /**
   * The end date
   *
   * @format date-time
   */
  endDate: string;
  /**
   * The update date
   *
   * @format date-time
   */
  updateDate: string;
  isCurrentlyIssuingAuth: boolean;
  isCurrentlyRevokingAuth: boolean;
  hasCustomAccessTimes: boolean;
  currentlyIssuingAuth?: boolean;
  currentlyRevokingAuth?: boolean;
};

export type AddressToken = {
  /**
   * The id
   */
  id: string;
  /**
   * The address id
   *
   * @format int32
   */
  addressId: number;
  /**
   * The creation date
   *
   * @format date-time
   */
  creationDate: string;
  /**
   * The redeem date
   *
   * @format date-time
   */
  redeemDate: string;
  /**
   * The redeem account id
   *
   * @format int32
   */
  redeemAccountId: number;
  /**
   * The list of invite keys
   */
  inviteKeys?: string[];
  /**
   * The redeem result
   */
  redeemResult?: "ok" | "failed";
};

export type AddressTokenInfo = {
  /**
   * The id
   */
  id: string;
  /**
   * The address name
   */
  addressName: string;
  /**
   * The associated smartlock names
   */
  smartlockNames: string[];
};

export type AddressUnit = {
  /**
   * The id
   */
  id?: string;
  /**
   * The name of the address unit
   */
  name: string;
  /**
   * The address id
   *
   * @format int32
   */
  addressId?: number;
  /**
   * The address token id
   */
  addressTokenId?: string;
  /**
   * The operation id - if set it's locked for another operation
   */
  operationId?: string;
};

export type AddressUnitResponse = {
  /**
   * The id
   */
  id?: string;
  /**
   * The name of the address unit
   */
  name: string;
  /**
   * The address id
   *
   * @format int32
   */
  addressId?: number;
  /**
   * The address token id
   */
  addressTokenId?: string;
  /**
   * The operation id - if set it's locked for another operation
   */
  operationId?: string;
  /**
   * The creation date
   *
   * @format date-time
   */
  creationDate: string;
  /**
   * The redeem date
   *
   * @format date-time
   */
  redeemDate: string;
  /**
   * The redeem result
   */
  redeemResult?: "ok" | "failed";
};

export type AddressUpdate = {
  /**
   * The name of the address
   */
  name?: string;
  /**
   * The smartlocks for this address
   */
  smartlockIds?: number[];
  /**
   * The optional settings
   */
  settings?: {
    [key: string]: Record<string, any>;
  };
};

export type AdvancedApiKey = {
  /**
   * The name of the company for which you apply for access
   */
  name: string;
  /**
   * The country of the headquarter or the country where you are mainly doing business in
   */
  country: string;
  /**
   * Describe the services and/or products you offer to your customers and how your customers would use Nuki devices in their processes
   */
  description: string;
  /**
   * The application type
   */
  type: "ONLY_SECRET" | "SHORT_RENTAL" | "HEALTHCARE" | "SMART_HOME" | "OTHER";
  /**
   * The status of the webhook posting automation
   */
  webhookStatus?: "ACTIVE" | "DEACTIVATED";
  /**
   * A website where we can find more information on the company and its business model
   */
  url: string;
  /**
   * An email address where we can contact you for checks on your application
   */
  email: string;
  /**
   * The URL where our webhooks should point to
   */
  webhookUrl: string;
  /**
   * The features to trigger webhooks, for all types except 'ONLY_SECRET'
   *
   * @uniqueItems true
   */
  webhookFeatures: (
    | "DEVICE_STATUS"
    | "DEVICE_MASTERDATA"
    | "DEVICE_CONFIG"
    | "DEVICE_LOGS"
    | "DEVICE_AUTHS"
    | "ACCOUNT_USER"
  )[];
  /**
   * Whether the advanced API key is restricted
   */
  restricted: boolean;
  /**
   * The client secret, visible if application is approved (status >= 'TESTING')
   */
  secret: string;
  /**
   * The application status
   */
  status: "INACTIVE" | "APPLIED" | "TESTING" | "ACTIVE";
  /**
   * The creation date
   *
   * @format date-time
   */
  creationDate: string;
  /**
   * The update date
   *
   * @format date-time
   */
  updateDate: string;
};

export type AdvancedApiKeyCreate = {
  /**
   * The name of the company for which you apply for access
   */
  name: string;
  /**
   * The country of the headquarter or the country where you are mainly doing business in
   */
  country: string;
  /**
   * Describe the services and/or products you offer to your customers and how your customers would use Nuki devices in their processes
   */
  description: string;
  /**
   * The application type
   */
  type: "ONLY_SECRET" | "SHORT_RENTAL" | "HEALTHCARE" | "SMART_HOME" | "OTHER";
  /**
   * The status of the webhook posting automation
   */
  webhookStatus?: "ACTIVE" | "DEACTIVATED";
  /**
   * A website where we can find more information on the company and its business model
   */
  url: string;
  /**
   * An email address where we can contact you for checks on your application
   */
  email: string;
  /**
   * The URL where our webhooks should point to
   */
  webhookUrl: string;
  /**
   * The features to trigger webhooks, for all types except 'ONLY_SECRET'
   *
   * @uniqueItems true
   */
  webhookFeatures: (
    | "DEVICE_STATUS"
    | "DEVICE_MASTERDATA"
    | "DEVICE_CONFIG"
    | "DEVICE_LOGS"
    | "DEVICE_AUTHS"
    | "ACCOUNT_USER"
  )[];
  /**
   * Whether the advanced API key is restricted
   */
  restricted: boolean;
};

export type AdvancedApiKeyUpdate = {
  /**
   * The URL where our webhooks should point to
   */
  webhookUrl: string;
  /**
   * The features to trigger webhooks, for all types except 'ONLY_SECRET'
   *
   * @uniqueItems true
   */
  webhookFeatures: (
    | "DEVICE_STATUS"
    | "DEVICE_MASTERDATA"
    | "DEVICE_CONFIG"
    | "DEVICE_LOGS"
    | "DEVICE_AUTHS"
    | "ACCOUNT_USER"
  )[];
};

export type AdvancedConfirmationResponse = {
  /**
   * A UUID to identify the upcoming asynchronously web hook response
   */
  requestId: string;
  /**
   * Contains error message and smartlock IDs, if auths can not be created because they need subscription.
   */
  error?: string;
};

export type ApiKey = {
  /**
   * The id
   *
   * @format int32
   */
  apiKeyId: number;
  /**
   * The account id
   *
   * @format int32
   */
  accountId: number;
  /**
   * The description
   */
  description?: string;
  /**
   * The redirect uris
   */
  redirectUris?: string[];
  /**
   * The creation date
   *
   * @format date-time
   */
  creationDate: string;
  /**
   * The api key
   */
  apiKey?: string;
};

export type ApiKeyAdvanced = {
  name?: string;
  country?: string;
  description?: string;
  type?: "ONLY_SECRET" | "SHORT_RENTAL" | "HEALTHCARE" | "SMART_HOME" | "OTHER";
  url?: string;
  email?: string;
  /**
   * @uniqueItems true
   */
  webhookFeatures?: (
    | "DEVICE_STATUS"
    | "DEVICE_MASTERDATA"
    | "DEVICE_CONFIG"
    | "DEVICE_LOGS"
    | "DEVICE_AUTHS"
    | "ACCOUNT_USER"
  )[];
  webhookUrl?: string;
  /**
   * @format int32
   */
  webhookSentSuccessfully?: number;
  /**
   * @format int32
   */
  webhookSentErroneous?: number;
  /**
   * @format date-time
   */
  lastSuccessfulPost?: string;
  /**
   * @format int64
   */
  lastPostDuration?: number;
  lastPostSuccesful?: boolean;
  status?: "INACTIVE" | "APPLIED" | "TESTING" | "ACTIVE";
  webhookStatus?: "ACTIVE" | "DEACTIVATED";
  /**
   * @format date-time
   */
  creationDate?: string;
  /**
   * @format date-time
   */
  updateDate?: string;
  restricted?: boolean;
};

export type ApiKeyCreate = {
  /**
   * The description
   */
  description?: string;
  /**
   * The list of redirect uris
   */
  redirectUris?: string[];
};

export type ApiKeyService = {
  byActiveWebhook?: CompletableFutureListApiKey;
};

export type ApiKeyToken = {
  /**
   * The id
   */
  id: string;
  /**
   * The account id
   *
   * @format int32
   */
  accountId: number;
  /**
   * The description
   */
  description?: string;
  /**
   * The access token
   */
  accessToken?: string;
  /**
   * The list of scopes
   */
  scopes: string[];
  /**
   * The creation date
   *
   * @format date-time
   */
  creationDate: string;
};

export type ApiKeyTokenCreate = {
  /**
   * The description
   */
  description?: string;
  /**
   * The list of scopes
   */
  scopes?: string[];
};

export type ApiKeyTokenUpdate = {
  /**
   * The description
   */
  description?: string;
  /**
   * The list of scopes
   */
  scopes?: string[];
};

export type ApiKeyUpdate = {
  /**
   * The description
   */
  description?: string;
  /**
   * The list of redirect uris
   */
  redirectUris?: string[];
};

export type Application = {
  author?: string;
  context?: Context;
  description?: string;
  name?: string;
  owner?: string;
  started?: boolean;
  debugging?: boolean;
  inboundRoot?: Restlet;
  outboundRoot?: Restlet;
  roles?: Role[];
  services?: Service[];
  statusService?: StatusService;
  connegService?: ConnegService;
  metadataService?: MetadataService;
  converterService?: ConverterService;
  rangeService?: RangeService;
  taskService?: TaskService;
  tunnelService?: TunnelService;
  connectorService?: ConnectorService;
  decoderService?: DecoderService;
  encoderService?: EncoderService;
  logger?: Logger;
  application?: Application;
  stopped?: boolean;
};

export type AuthenticationInfo = {
  nextServerNonce?: string;
  /**
   * @format int32
   */
  nonceCount?: number;
  clientNonce?: string;
  quality?: string;
  responseDigest?: string;
};

export type BulkWebConfigRequest = {
  webConfigRequests?: WebConfigRequest[];
};

export type CacheDirective = {
  digit?: boolean;
  name?: string;
  value?: string;
};

export type Certificate = {
  type?: string;
  encoded?: string[];
  publicKey?: PublicKey;
};

export type ChallengeRequest = {
  rawValue?: string;
  parameters?: Parameter[];
  scheme?: ChallengeScheme;
  serverNonce?: string;
  realm?: string;
  opaque?: string;
  digestAlgorithm?: string;
  qualityOptions?: string[];
  domainRefs?: Reference[];
  stale?: boolean;
};

export type ChallengeResponse = {
  rawValue?: string;
  parameters?: Parameter[];
  scheme?: ChallengeScheme;
  serverNonce?: string;
  realm?: string;
  opaque?: string;
  digestAlgorithm?: string;
  clientNonce?: string;
  digestRef?: Reference;
  identifier?: string;
  quality?: string;
  secret?: string[];
  secretAlgorithm?: string;
  /**
   * @format int32
   */
  serverNounceCount?: number;
  /**
   * @format int64
   */
  timeIssued?: number;
  principal?: Principal;
  serverNounceCountAsHex?: string;
};

export type ChallengeScheme = {
  description?: string;
  name?: string;
  technicalName?: string;
};

export type CharacterSet = {
  description?: string;
  name?: string;
  parent?: Metadata;
};

export type ClientInfo = {
  acceptedCharacterSets?: PreferenceCharacterSet[];
  acceptedEncodings?: PreferenceEncoding[];
  acceptedLanguages?: PreferenceLanguage[];
  acceptedMediaTypes?: PreferenceMediaType[];
  acceptedPatches?: PreferenceMediaType[];
  address?: string;
  agent?: string;
  agentAttributes?: {
    [key: string]: string;
  };
  agentProducts?: Product[];
  authenticated?: boolean;
  certificates?: Certificate[];
  cipherSuite?: string;
  expectations?: Expectation[];
  forwardedAddresses?: string[];
  from?: string;
  /**
   * @format int32
   */
  port?: number;
  principals?: Principal[];
  roles?: Role[];
  user?: User;
  upstreamAddress?: string;
  agentName?: string;
  agentVersion?: string;
  mainAgentProduct?: Product;
};

export type Company = {
  name?: string;
  email?: string;
};

export type CompletableFuture = {
  completedExceptionally?: boolean;
  /**
   * @format int32
   */
  numberOfDependents?: number;
  done?: boolean;
  cancelled?: boolean;
};

export type CompletableFutureListApiKey = {
  completedExceptionally?: boolean;
  /**
   * @format int32
   */
  numberOfDependents?: number;
  done?: boolean;
  cancelled?: boolean;
};

export type Conditions = {
  match?: Tag[];
  /**
   * @format date-time
   */
  modifiedSince?: string;
  noneMatch?: Tag[];
  /**
   * @format date-time
   */
  rangeDate?: string;
  rangeTag?: Tag;
  /**
   * @format date-time
   */
  unmodifiedSince?: string;
};

export type ConnectorService = {
  context?: Context;
  enabled?: boolean;
  started?: boolean;
  clientProtocols?: Protocol[];
  serverProtocols?: Protocol[];
  stopped?: boolean;
};

export type ConnegService = {
  context?: Context;
  enabled?: boolean;
  started?: boolean;
  strict?: boolean;
  stopped?: boolean;
};

export type Context = {
  clientDispatcher?: Restlet;
  serverDispatcher?: Restlet;
  attributes?: {
    [key: string]: Record<string, any>;
  };
  logger?: Logger;
  parameters?: Parameter[];
  defaultEnroler?: Enroler;
  defaultVerifier?: Verifier;
  executorService?: ScheduledExecutorService;
};

export type ConverterService = {
  context?: Context;
  enabled?: boolean;
  started?: boolean;
  stopped?: boolean;
};

export type Cookie = {
  domain?: string;
  name?: string;
  path?: string;
  value?: string;
  /**
   * @format int32
   */
  version?: number;
};

export type CookieSetting = {
  domain?: string;
  name?: string;
  path?: string;
  value?: string;
  /**
   * @format int32
   */
  version?: number;
  accessRestricted?: boolean;
  comment?: string;
  /**
   * @format int32
   */
  maxAge?: number;
  secure?: boolean;
  description?: string;
};

export type DecentralWebhook = {
  /**
   * The identifier
   *
   * @format int32
   */
  id?: number;
  /**
   * The secret to sign the webhook's payload
   */
  secret?: string;
  /**
   * The URL where our webhooks (POST requests) should point to (needs to be https)
   */
  webhookUrl: string;
  /**
   * The features to trigger webhooks, set values: DEVICE_STATUS, DEVICE_MASTERDATA, DEVICE_CONFIG, DEVICE_LOGS, DEVICE_AUTHS, ACCOUNT_USER
   *
   * @uniqueItems true
   */
  webhookFeatures: (
    | "DEVICE_STATUS"
    | "DEVICE_MASTERDATA"
    | "DEVICE_CONFIG"
    | "DEVICE_LOGS"
    | "DEVICE_AUTHS"
    | "ACCOUNT_USER"
  )[];
};

export type DecoderService = {
  context?: Context;
  enabled?: boolean;
  started?: boolean;
  stopped?: boolean;
};

export type Digest = {
  algorithm?: string;
  value?: string[];
};

export type Disposition = {
  parameters?: Parameter[];
  type?: string;
  filename?: string;
};

export type EncoderService = {
  context?: Context;
  enabled?: boolean;
  started?: boolean;
  acceptedMediaTypes?: MediaType[];
  ignoredMediaTypes?: MediaType[];
  /**
   * @format int64
   */
  minimumSize?: number;
  stopped?: boolean;
};

export type Encoding = {
  description?: string;
  name?: string;
  parent?: Metadata;
};

export type Enroler = Record<string, any>;

export type Enumeration = Record<string, any>;

export type EnumerationString = Record<string, any>;

export type ErrorManager = Record<string, any>;

export type Expectation = {
  name?: string;
  parameters?: Parameter[];
  value?: string;
};

export type Filter = Record<string, any>;

export type Formatter = Record<string, any>;

export type Handler = {
  filter?: Filter;
  formatter?: Formatter;
  errorManager?: ErrorManager;
  encoding?: string;
  level?: Level;
};

export type Header = {
  name?: string;
  value?: string;
};

export type InputStream = Record<string, any>;

export type Language = {
  description?: string;
  name?: string;
  subTags?: string[];
  parent?: Language;
  primaryTag?: string;
};

export type Level = {
  name?: string;
  resourceBundleName?: string;
  localizedName?: string;
};

export type Locale = {
  language?: string;
  displayName?: string;
  country?: string;
  variant?: string;
  script?: string;
  /**
   * @uniqueItems true
   */
  unicodeLocaleAttributes?: string[];
  /**
   * @uniqueItems true
   */
  unicodeLocaleKeys?: string[];
  displayLanguage?: string;
  displayScript?: string;
  displayCountry?: string;
  displayVariant?: string;
  /**
   * @uniqueItems true
   */
  extensionKeys?: string[];
  iso3Language?: string;
  iso3Country?: string;
};

export type Logger = {
  name?: string;
  parent?: Logger;
  filter?: Filter;
  level?: Level;
  resourceBundleName?: string;
  handlers?: Handler[];
  useParentHandlers?: boolean;
  resourceBundle?: ResourceBundle;
};

export type MediaType = {
  description?: string;
  name?: string;
  parameters?: Parameter[];
  parent?: MediaType;
  mainType?: string;
  concrete?: boolean;
  subType?: string;
};

export type Metadata = {
  description?: string;
  name?: string;
  parent?: Metadata;
};

export type MetadataService = {
  context?: Context;
  enabled?: boolean;
  started?: boolean;
  defaultCharacterSet?: CharacterSet;
  defaultEncoding?: Encoding;
  defaultLanguage?: Language;
  defaultMediaType?: MediaType;
  allEncodingExtensionNames?: string[];
  allExtensionNames?: string[];
  allLanguageExtensionNames?: string[];
  allMediaTypeExtensionNames?: string[];
  allCharacterSetExtensionNames?: string[];
  stopped?: boolean;
};

export type Method = {
  description?: string;
  idempotent?: boolean;
  name?: string;
  replying?: boolean;
  safe?: boolean;
  uri?: string;
};

export type MyAccount = {
  /**
   * The account id
   *
   * @format int32
   */
  accountId: number;
  /**
   * The type: 0 .. user, 1 .. company, 2 .. caretaker
   *
   * @format int32
   * @minimum 0
   * @maximum 2
   */
  type: number;
  /**
   * The email address
   */
  email: string;
  /**
   * true, if the email is verified
   */
  emailVerified?: boolean;
  /**
   * The name
   */
  name: string;
  /**
   * The master account id if it's a sub account
   *
   * @format int32
   */
  masterAccountId?: number;
  /**
   * The rights bitmask if it's a sub account: 1 .. manage smartlock, 2 .. operate smartlock, 4 .. manage smartlock config, 8 .. manage smartlock authorizations, 16 .. view smartlock logs, 32 .. manage sub accounts, 64 .. create smartlocks
   *
   * @format int32
   * @minimum 0
   * @maximum 127
   */
  rights?: number;
  /**
   * The language code
   *
   * @example de
   */
  language?: string;
  config?: AccountConfig;
  profile?: AccountProfile;
  /**
   * The secret base64 encoded
   */
  secret?: string[];
  /**
   * The creation date
   *
   * @format date-time
   */
  creationDate: string;
  /**
   * The update date
   *
   * @format date-time
   */
  updateDate: string;
  descent?: AccountDescent;
  /**
   * subscription type of the account (b2b)
   */
  shsSubscriptionType?: "BUSINESS" | "STANDARD" | "BUSINESS_PLUS" | "API_ONLY";
  b2bActive?: boolean;
  apiTermsOfUse?: TermsOfUse;
};

export type NamedValue = {
  name?: string;
  value?: Record<string, any>;
};

export type NamedValueString = {
  name?: string;
  value?: string;
};

export type Notification = {
  /**
   * The unique notificationId for the notification
   */
  notificationId?: string;
  /**
   * The reference ID, an ID to identify a foreign system
   */
  referenceId?: string;
  /**
   * The push ID or the POST URL for a webhook
   */
  pushId: string;
  /**
   * The 40 byte hex string to sign the checksumof the POST payload if the notification is webhook (os=2)
   *
   * @example 8d41a187c3954f886f9de3a88c2ef22df0eac190
   */
  secret?: string;
  /**
   * The operating system: 0 .. Android, 1 .. iOS, 2 .. web hook
   *
   * @format int32
   */
  os: number;
  /**
   * The language of push messages: cs, de, en (default), es, fr, it, nl, sk
   */
  language?: string;
  /**
   * Current state: 0 .. init, 1 .. active, 2 .. failed
   *
   * @format int32
   */
  status?: number;
  /**
   * The last active date
   *
   * @format date-time
   */
  lastActiveDate?: string;
  /**
   * Settings per Smart Lock
   */
  settings: NotificationSetting[];
};

export type NotificationSetting = {
  /**
   * The smartlock ID, if not set all Smart Locks of the account  are enabled for push notifications
   *
   * @format int64
   */
  smartlockId?: number;
  /**
   * A set on which push notifications should be triggered: lock, unlock, unlatch, lockngo, open, ring, doorsensor, warnings, smartlock
   *
   * @uniqueItems true
   */
  triggerEvents: string[];
  /**
   * A set of auth IDs to filter push notifications to certain  users or keypads. If no entry push notifications are triggered for all users and keypads
   *
   * @uniqueItems true
   */
  authIds?: string[];
};

export type ObjectId = {
  /**
   * @format int32
   */
  timestamp?: number;
  /**
   * @format int32
   */
  counter?: number;
  /**
   * @format int64
   */
  time?: number;
  /**
   * @format date-time
   */
  date?: string;
  /**
   * @format int32
   */
  machineIdentifier?: number;
  /**
   * @format int32
   */
  processIdentifier?: number;
  /**
   * @format int32
   */
  timeSecond?: number;
};

export type OpenerIntercomBrand = {
  /**
   * The brand ID
   *
   * @format int32
   */
  brandId: number;
  /**
   * The brand name
   */
  brand: string;
};

export type OpenerIntercomModel = {
  /**
   * The intercom ID
   *
   * @format int32
   */
  intercomId: number;
  /**
   * The related brand ID
   *
   * @format int32
   */
  brandId: number;
  /**
   * The type of the model
   *
   * @format int32
   */
  type: number;
  /**
   * The model name
   */
  model: string;
  /**
   * Verified Nuki intercom: 1 .. verified to work, 2 .. may be compatible, but not verified, 3 .. not compatible
   *
   * @format int32
   */
  verified: number;
  /**
   * Connection for ground BUS
   */
  conGndBus: string;
  /**
   * Connection for audio BUS
   */
  conBusAudio: string;
  /**
   * Connection for audio out
   */
  conAudioout: string;
  /**
   * Connection for doorbell plus
   */
  conDoorbellPlus: string;
  /**
   * Connection for doorbell minus
   */
  conDoorbellMinus: string;
  /**
   * Connection for open the door
   */
  conOpendoor: string;
  /**
   * Connection for ground analogue
   */
  conGndAnalogue: string;
  /**
   * Settings value for BUS mode switch
   *
   * @format int32
   */
  busModeSwitch: number;
  /**
   * Settings value for BUS mode switch short cicuit duration
   *
   * @format int32
   */
  busModeSwitchShortCircuitDuration: number;
  /**
   * The creation date
   *
   * @format date-time
   */
  creationDate?: string;
  /**
   * The update date
   *
   * @format date-time
   */
  updateDate?: string;
};

export type PaginatedResponse = {
  results?: Record<string, any>[];
  pagination?: Pagination;
};

export type Pagination = {
  /**
   * @format int64
   */
  totalItems?: number;
  /**
   * @format int32
   */
  totalPages?: number;
  /**
   * @format int32
   */
  currentPage?: number;
  nextPage?: string;
  prevPage?: string;
  /**
   * @format int32
   */
  pageSize?: number;
};

export type Parameter = {
  name?: string;
  value?: string;
};

export type Preference = {
  metadata?: Metadata;
  parameters?: Parameter[];
  /**
   * @format float
   */
  quality?: number;
};

export type PreferenceCharacterSet = {
  metadata?: CharacterSet;
  parameters?: Parameter[];
  /**
   * @format float
   */
  quality?: number;
};

export type PreferenceEncoding = {
  metadata?: Encoding;
  parameters?: Parameter[];
  /**
   * @format float
   */
  quality?: number;
};

export type PreferenceLanguage = {
  metadata?: Language;
  parameters?: Parameter[];
  /**
   * @format float
   */
  quality?: number;
};

export type PreferenceMediaType = {
  metadata?: MediaType;
  parameters?: Parameter[];
  /**
   * @format float
   */
  quality?: number;
};

export type Principal = {
  name?: string;
};

export type Product = {
  comment?: string;
  name?: string;
  version?: string;
};

export type Protocol = {
  confidential?: boolean;
  /**
   * @format int32
   */
  defaultPort?: number;
  description?: string;
  name?: string;
  schemeName?: string;
  technicalName?: string;
  version?: string;
};

export type PublicKey = {
  encoded?: string[];
  format?: string;
  algorithm?: string;
};

export type Range = {
  /**
   * @format int64
   */
  index?: number;
  /**
   * @format int64
   */
  instanceSize?: number;
  /**
   * @format int64
   */
  size?: number;
  unitName?: string;
};

export type RangeService = {
  context?: Context;
  enabled?: boolean;
  started?: boolean;
  stopped?: boolean;
};

export type ReadableByteChannel = {
  open?: boolean;
};

export type Reader = Record<string, any>;

export type RecipientInfo = {
  protocol?: Protocol;
  comment?: string;
  name?: string;
};

export type Reference = {
  baseRef?: Reference;
  scheme?: string;
  fragment?: string;
  userInfo?: string;
  path?: string;
  query?: string;
  absolute?: boolean;
  opaque?: boolean;
  authority?: string;
  relative?: boolean;
  schemeSpecificPart?: string;
  extensions?: string;
  matrix?: string;
  matrixAsForm?: Parameter[];
  queryAsForm?: Parameter[];
  extensionsAsArray?: string[];
  hierarchicalPart?: string;
  hostDomain?: string;
  hostIdentifier?: string;
  /**
   * @format int32
   */
  hostPort?: number;
  lastSegment?: string;
  parentRef?: Reference;
  relativePart?: string;
  relativeRef?: Reference;
  remainingPart?: string;
  schemeProtocol?: Protocol;
  segments?: string[];
  targetRef?: Reference;
  hierarchical?: boolean;
  identifier?: string;
};

export type Representation = {
  characterSet?: CharacterSet;
  encodings?: Encoding[];
  locationRef?: Reference;
  languages?: Language[];
  mediaType?: MediaType;
  /**
   * @format date-time
   */
  modificationDate?: string;
  tag?: Tag;
  available?: boolean;
  digest?: Digest;
  disposition?: Disposition;
  /**
   * @format date-time
   */
  expirationDate?: string;
  range?: Range;
  /**
   * @format int64
   */
  size?: number;
  empty?: boolean;
  channel?: ReadableByteChannel;
  transient?: boolean;
  text?: string;
  reader?: Reader;
  /**
   * @format int64
   */
  availableSize?: number;
  registration?: SelectionRegistration;
  stream?: InputStream;
  selectable?: boolean;
};

export type Request = {
  attributes?: {
    [key: string]: Record<string, any>;
  };
  cacheDirectives?: CacheDirective[];
  /**
   * @format date-time
   */
  date?: string;
  entity?: Representation;
  onError?: Uniform;
  onSent?: Uniform;
  recipientsInfo?: RecipientInfo[];
  warnings?: Warning[];
  /**
   * @uniqueItems true
   */
  accessControlRequestHeaders?: string[];
  accessControlRequestMethod?: Method;
  challengeResponse?: ChallengeResponse;
  clientInfo?: ClientInfo;
  conditions?: Conditions;
  cookies?: Cookie[];
  hostRef?: Reference;
  loggable?: boolean;
  /**
   * @format int32
   */
  maxForwards?: number;
  method?: Method;
  onResponse?: Uniform;
  originalRef?: Reference;
  protocol?: Protocol;
  proxyChallengeResponse?: ChallengeResponse;
  ranges?: Range[];
  referrerRef?: Reference;
  resourceRef?: Reference;
  rootRef?: Reference;
  confidential?: boolean;
  entityAvailable?: boolean;
  asynchronous?: boolean;
  expectingResponse?: boolean;
  synchronous?: boolean;
  entityAsText?: string;
  headers?: Header[];
};

export type ReservationAccessTimesUpdate = {
  /**
   * Custom check in time in minutes from midnight
   *
   * @format int32
   */
  checkInTime?: number;
  /**
   * Custom check out time in minutes from midnight
   *
   * @format int32
   */
  checkOutTime?: number;
};

export type ResourceBundle = {
  locale?: Locale;
  keys?: EnumerationString;
  baseBundleName?: string;
};

export type Response = {
  attributes?: {
    [key: string]: Record<string, any>;
  };
  cacheDirectives?: CacheDirective[];
  /**
   * @format date-time
   */
  date?: string;
  entity?: Representation;
  onError?: Uniform;
  onSent?: Uniform;
  recipientsInfo?: RecipientInfo[];
  warnings?: Warning[];
  accessControlAllowCredentials?: boolean;
  /**
   * @uniqueItems true
   */
  accessControlAllowHeaders?: string[];
  /**
   * @uniqueItems true
   */
  accessControlAllowMethods?: Method[];
  accessControlAllowOrigin?: string;
  /**
   * @uniqueItems true
   */
  accessControlExposeHeaders?: string[];
  /**
   * @format int32
   */
  accessControlMaxAge?: number;
  /**
   * @format int32
   */
  age?: number;
  /**
   * @uniqueItems true
   */
  allowedMethods?: Method[];
  authenticationInfo?: AuthenticationInfo;
  autoCommitting?: boolean;
  challengeRequests?: ChallengeRequest[];
  committed?: boolean;
  cookieSettings?: CookieSetting[];
  /**
   * @uniqueItems true
   */
  dimensions?: (
    | "AUTHORIZATION"
    | "CHARACTER_SET"
    | "CLIENT_ADDRESS"
    | "CLIENT_AGENT"
    | "UNSPECIFIED"
    | "ENCODING"
    | "LANGUAGE"
    | "MEDIA_TYPE"
    | "TIME"
    | "ORIGIN"
  )[];
  locationRef?: Reference;
  proxyChallengeRequests?: ChallengeRequest[];
  request?: Request;
  /**
   * @format date-time
   */
  retryAfter?: string;
  serverInfo?: ServerInfo;
  status?: Status;
  final?: boolean;
  confidential?: boolean;
  provisional?: boolean;
  entityAvailable?: boolean;
  entityAsText?: string;
  headers?: Header[];
};

export type Restlet = {
  author?: string;
  context?: Context;
  description?: string;
  name?: string;
  owner?: string;
  started?: boolean;
  logger?: Logger;
  application?: Application;
  stopped?: boolean;
};

export type Role = {
  application?: Application;
  childRoles?: Role[];
  description?: string;
  name?: string;
};

export type ScheduledExecutorService = {
  terminated?: boolean;
  shutdown?: boolean;
};

export type SelectableChannel = {
  registered?: boolean;
  blocking?: boolean;
  open?: boolean;
};

export type SelectionListener = Record<string, any>;

export type SelectionRegistration = {
  canceling?: boolean;
  /**
   * @format int32
   */
  interestOperations?: number;
  selectionListener?: SelectionListener;
  /**
   * @format int32
   */
  readyOperations?: number;
  selectableChannel?: SelectableChannel;
  wakeupListener?: WakeupListener;
  readable?: boolean;
  writable?: boolean;
  connectable?: boolean;
  interestReady?: boolean;
};

export type ServerInfo = {
  acceptingRanges?: boolean;
  address?: string;
  agent?: string;
  /**
   * @format int32
   */
  port?: number;
};

export type Service = {
  context?: Context;
  enabled?: boolean;
  started?: boolean;
  stopped?: boolean;
};

export type ShsSubscription = {
  type?: "B2C" | "B2B";
  state?:
    | "ACTIVE"
    | "INACTIVE"
    | "CANCELLED"
    | "EXPIRED"
    | "ON_HOLD"
    | "PENDING"
    | "PENDING_CANCEL";
  shsSubscriptionType?: "BUSINESS" | "STANDARD" | "BUSINESS_PLUS" | "API_ONLY";
  /**
   * @format date-time
   */
  updateDate?: string;
  /**
   * @format date-time
   */
  creationDate?: string;
  /**
   * @format date-time
   */
  expirationDate?: string;
  isInGracePeriod?: boolean;
  isGracePeriodWarningDismissed?: boolean;
  gracePeriodWarningEmailSent?: boolean;
};

export type Smartlock = {
  /**
   * The smartlock id
   *
   * @format int64
   */
  smartlockId: number;
  /**
   * The account id
   *
   * @format int32
   */
  accountId: number;
  /**
   * The type: 0 .. keyturner, 1 .. box, 2 .. opener, 3 .. smartdoor, 4 .. smartlock 3.0/4. Gen
   *
   * @format int32
   */
  type: number;
  /**
   * The lock mechanism used in the smart door lock: 1 .. MyEVO, 2 .. KFV Genius (only for type = 3)
   *
   * @format int32
   */
  lmType?: number;
  /**
   * The authorization id
   *
   * @format int32
   */
  authId: number;
  /**
   * The name of the smartlock
   */
  name: string;
  /**
   * The favorite flag
   */
  favorite: boolean;
  config?: SmartlockConfig;
  advancedConfig?: SmartlockAdvancedConfig;
  openerAdvancedConfig?: SmartlockOpenerAdvancedConfig;
  smartdoorAdvancedConfig?: SmartlockSmartdoorAdvancedConfig;
  webConfig?: SmartlockWebConfig;
  state?: SmartlockState;
  /**
   * The firmware version
   *
   * @format int32
   */
  firmwareVersion?: number;
  /**
   * The hardware version
   *
   * @format int32
   */
  hardwareVersion?: number;
  /**
   * The operation id - if set it's locked for another operation
   */
  operationId?: string;
  /**
   * The server state: 0 .. ok, 1 .. unregistered, 2 .. auth uuid invalid, 3 .. auth invalid, 4 .. offline
   *
   * @format int32
   * @minimum 0
   * @maximum 4
   */
  serverState: number;
  /**
   * The admin pin state: 0 .. ok, 1 .. missing, 2 .. invalid
   *
   * @format int32
   * @minimum 0
   * @maximum 2
   */
  adminPinState: number;
  /**
   * The flag indicating a virtual Smart Lock
   */
  virtualDevice?: boolean;
  /**
   * The creation date
   *
   * @format date-time
   */
  creationDate?: string;
  /**
   * The update date
   *
   * @format date-time
   */
  updateDate?: string;
  /**
   * In case of any error, it contains the error message
   */
  error?: string;
  /**
   * Previous Subscriptions
   */
  previousSubscriptions?: ShsSubscription[];
  currentSubscription?: ShsSubscription;
  /**
   * The region
   *
   * @format int32
   */
  region?: number;
  /**
   * The mounting variant
   *
   * @format int32
   */
  mountingVariant?: number;
  opener?: boolean;
  box?: boolean;
  smartDoor?: boolean;
  keyturner?: boolean;
};

export type SmartlockAdvancedConfig = {
  /**
   * Timeout in seconds for lock ‘n’ go
   *
   * @format int32
   */
  lngTimeout?: 5 | 10 | 15 | 20 | 30 | 45 | 60;
  /**
   * The desired action, if the button is pressed once: 0 .. no action, 1 .. intelligent, 2 .. unlock, 3 .. lock, 4 .. unlatch, 5 .. lock 'n' go, 6 .. show status
   *
   * @format int32
   */
  singleButtonPressAction?: number;
  /**
   * The desired action, if the button is pressed twice: 0 .. no action, 1 .. intelligent, 2 .. unlock, 3 .. lock, 4 .. unlatch, 5 .. lock 'n' go, 6 .. show status
   *
   * @format int32
   */
  doubleButtonPressAction?: number;
  /**
   * Flag that indicates if the automatic detection of the battery type is enabled
   */
  automaticBatteryTypeDetection?: boolean;
  /**
   * Duration in seconds for holding the latch in unlatched position
   *
   * @format int32
   */
  unlatchDuration?: 1 | 3 | 5 | 7 | 10 | 15 | 20 | 30;
  /**
   * The operation id - if set it's locked for another operation
   */
  operationId?: string;
  /**
   * The absolute total position in degrees that has been reached during calibration
   *
   * @format int32
   */
  totalDegrees: number;
  /**
   * Offset that alters the single locked position
   *
   * @format int32
   */
  singleLockedPositionOffsetDegrees: number;
  /**
   * Offset that alters the position where transition from unlocked to locked happens
   *
   * @format int32
   */
  unlockedToLockedTransitionOffsetDegrees?: number;
  /**
   * Offset that alters the unlocked position
   *
   * @format int32
   */
  unlockedPositionOffsetDegrees: number;
  /**
   * Offset that alters the locked position
   *
   * @format int32
   */
  lockedPositionOffsetDegrees: number;
  /**
   * Flag that indicates that the inner side of the used cylinder is detached from the outer side
   */
  detachedCylinder?: boolean;
  /**
   * The type of the batteries present in the smart lock: 0 .. alkali, 1 .. accumulator, 2 .. lithium
   *
   * @format int32
   */
  batteryType: number;
  /**
   * New separate flag with FW >= 2.7.8/1.9.1: The Auto Lock feature automatically locks your door when it has been unlocked for a certain period of time
   */
  autoLock?: boolean;
  /**
   * Seconds until the smart lock relocks itself after it has been unlocked. FW < 2.7.8/1.9.1: No auto relock if value is 0, FW >= 2.7.8/1.9.1: has to be >=2 (defaults to 2 for values <2 if autoLock is set to true)
   *
   * @format int32
   */
  autoLockTimeout?: number;
  /**
   * Flag that indicates if available firmware updates for the deviceshould be installed automatically
   */
  autoUpdateEnabled?: boolean;
  /**
   * Field used for setting the motor speed. 0x00 ... standard, 0x01 ... fast, 0x02 ... slow
   *
   * @format int32
   */
  motorSpeed?: number;
  /**
   * Flag indicating if the slow speed shall be applied during NightMode
   */
  enableSlowSpeedDuringNightmode?: boolean;
};

export type SmartlockConfig = {
  /**
   * The name of the smartlock for new users
   */
  name: string;
  /**
   * The latitude of the smartlock position
   *
   * @format float
   */
  latitude: number;
  /**
   * The longitude of the smartlock position
   *
   * @format float
   */
  longitude: number;
  /**
   * The capabilities indicate whether door opening via app is possible, RTO is possible or both: 0 .. only door opening possible, 1 .. both possible, 2 .. only RTO possible (only for type=2)
   *
   * @format int32
   * @minimum 0
   * @maximum 2
   */
  capabilities?: number;
  /**
   * True if the door should be unlatched on unlocking (knob) (only for type=1 and type=3)
   */
  autoUnlatch?: boolean;
  /**
   * True if the door has a lift up handle, which is required to be lifted up to lock the door
   */
  liftUpHandle?: boolean;
  /**
   * True if the pairing is allowed via the smartlock button
   */
  pairingEnabled?: boolean;
  /**
   * True if the button on the smartlock is enabled
   */
  buttonEnabled?: boolean;
  /**
   * True if the LED on the smartlock is enabled
   */
  ledEnabled?: boolean;
  /**
   * The brightness of the LED: 0 .. off, 5 .. max (only for type=1 and type=3)
   *
   * @format int32
   */
  ledBrightness?: number;
  /**
   * [deprecated] The timezone offset (in minutes)
   *
   * @format int32
   */
  timezoneOffset: number;
  /**
   * [deprecated] The daylight saving mode: 0 .. off, 1 .. european
   *
   * @format int32
   */
  daylightSavingMode?: number;
  /**
   * True if a fob is paired with the smartlock
   */
  fobPaired?: boolean;
  /**
   * The fob action if button is pressed once: type=0/3/4: 0 .. none, 1 .. unlock, 2 .. lock, 3 .. lock 'n' go, 4 .. intelligent (lock/unlocked based on the current state); type=2: 0 .. none, 1 .. toggle ring to open, 2 .. activate ring to open, 3 .. deactivate ring to open, 7 .. open (electric strike actuation), 8 .. ring
   *
   * @format int32
   * @minimum 0
   * @maximum 8
   */
  fobAction1?: number;
  /**
   * The fob action if button is pressed twice: type=0/3/4: 0 .. none, 1 .. unlock, 2 .. lock, 3 .. lock 'n' go, 4 .. intelligent (lock/unlocked based on the current state); type=2: 0 .. none, 1 .. toggle ring to open, 2 .. activate ring to open, 3 .. deactivate ring to open, 7 .. open (electric strike actuation), 8 .. ring
   *
   * @format int32
   * @minimum 0
   * @maximum 8
   */
  fobAction2?: number;
  /**
   * The fob action if button is pressed 3 times: type=0/3/4: 0 .. none, 1 .. unlock, 2 .. lock, 3 .. lock 'n' go, 4 .. intelligent (lock/unlocked based on the current state); type=2: 0 .. none, 1 .. toggle ring to open, 2 .. activate ring to open, 3 .. deactivate ring to open, 7 .. open (electric strike actuation), 8 .. ring
   *
   * @format int32
   * @minimum 0
   * @maximum 8
   */
  fobAction3?: number;
  /**
   * True if the smartlock should only lock once (instead of twice) (only for type=1)
   */
  singleLock: boolean;
  /**
   * The operating mode of the opener (only for type=2): 0x00 .. generic door opener, 0x01 .. analogue intercom, 0x02 .. digital intercom, 0x03 .. digital intercom Siedle, 0x04 .. digital intercom TCS, 0x05 .. digital intercom Bticino, 0x06 .. analog intercom Siedle HTS, 0x07 .. digital intercom STR, 0x08 .. digital intercom Ritto, 0x09 .. digital intercom Fermax, 0x0A .. digital intercom Comelit, 0x0B .. digital intercom Urmet BiBus, 0x0C .. digital intercom Urmet 2Voice, 0x0D .. digital intercom Golmar, 0x0E .. digital intercom SKS, 0x0F .. digital intercom Spare
   *
   * @format int32
   */
  operatingMode?: number;
  /**
   * The advertising mode (battery saving): 0 .. automatic, 1 .. normal, 2 .. slow, 3 .. slowest
   *
   * @format int32
   * @minimum 0
   * @maximum 3
   */
  advertisingMode: number;
  /**
   * True if a keypad is paired with the smartlock
   */
  keypadPaired?: boolean;
  /**
   * True if a keypad 2 is paired with the smartlock
   */
  keypad2Paired?: boolean;
  /**
   * The homekit state: 0 .. unavailable, 1 .. disabled, 2 .. enabled, 3 .. enabled & paired
   *
   * @format int32
   * @minimum 0
   * @maximum 3
   */
  homekitState?: number;
  /**
   * The matter state: 0 .. not available, 1 .. disabled and no certificate available, 2 .. disabled, 3 .. enabled, 4 .. enabled & paired
   *
   * @format int32
   * @minimum 0
   * @maximum 4
   */
  matterState?: number;
  /**
   * The timezone id (check https://developer.nuki.io for ids)
   *
   * @format int32
   * @minimum 0
   * @maximum 45
   */
  timezoneId: number;
  /**
   * The device type of a Nuki device
   *
   * @format int32
   */
  deviceType?: number;
  /**
   * Flag that indicates if the devices internal WIFI module can be used
   */
  wifiEnabled?: boolean;
  /**
   * The operation id - if set it's locked for another operation
   */
  operationId?: string;
  /**
   * The product variant for Smartlock 5: 1 .. Go, 2 .. Pro, 3 .. Ultra
   *
   * @format int32
   * @minimum 1
   * @maximum 3
   */
  productVariant?: number;
};

export type SmartlockOpenerAdvancedConfig = {
  /**
   * The database ID of the connected intercom
   *
   * @format int32
   */
  intercomId: number;
  /**
   * Method to switch between data and analogue mode
   *
   * @format int32
   */
  busModeSwitch: 0 | 1;
  /**
   * Duration of the short circuit for BUS mode switching in ms
   *
   * @format int32
   */
  shortCircuitDuration: number;
  /**
   * Delay of electric strike activation in ms after lock action 3 'electric strike actuation'
   *
   * @format int32
   */
  electricStrikeDelay: number;
  /**
   * Random electricStrikeDelay (range 3000 - 7000 ms) in order to simulate a person inside actuating the electric strike
   */
  randomElectricStrikeDelay: boolean;
  /**
   * Duration in ms of electric strike actuation lock action 3 'electric strike actuation'
   *
   * @format int32
   */
  electricStrikeDuration: number;
  /**
   * Flag to disable RTO after ring
   */
  disableRtoAfterRing: boolean;
  /**
   * After this period of time in minutes, RTO gets deactivated automatically
   *
   * @format int32
   */
  rtoTimeout: number;
  /**
   * The doorbell supression bitmask: first bit (least significant) .. whenever the doorbell rings and CM and RTO are inactive, second bit .. RTO is active, third bit .. CM is active
   *
   * @format int32
   */
  doorbellSuppression: number;
  /**
   * Duration in ms of doorbell suppression (only in Operating mode 2 'digital Intercom')
   *
   * @format int32
   */
  doorbellSuppressionDuration: number;
  /**
   * The sound for ring: 0 .. no sound, 1 .. Sound1, 2 .. Sound2, 3 .. Sound3
   *
   * @format int32
   */
  soundRing: 0 | 1 | 2 | 3;
  /**
   * The sound for open: 0 .. no sound, 1 .. Sound1, 2 .. Sound2, 3 .. Sound3
   *
   * @format int32
   */
  soundOpen: 0 | 1 | 2 | 3;
  /**
   * The sound for RTO: 0 .. no sound, 1 .. Sound1, 2 .. Sound2, 3 .. Sound3
   *
   * @format int32
   */
  soundRto: 0 | 1 | 2 | 3;
  /**
   * The sound for CM: 0 .. no sound, 1 .. Sound1, 2 .. Sound2, 3 .. Sound3
   *
   * @format int32
   */
  soundCm: 0 | 1 | 2 | 3;
  /**
   * The sound confirmation: 0 .. no sound, 1 .. sound
   *
   * @format int32
   */
  soundConfirmation: 0 | 1;
  /**
   * The sound level
   *
   * @format int32
   */
  soundLevel: number;
  /**
   * The desired action, if the button is pressed once: 0 .. no action, 1 .. toggle RTO, 2 .. activate RTO, 3 .. deactivate RTO, 4 .. toggle CM, 5 .. activate CM, 6 .. deactivate CM, 7 .. open
   *
   * @format int32
   */
  singleButtonPressAction: number;
  /**
   * The desired action, if the button is pressed twice: 0 .. no action, 1 .. toggle RTO, 2 .. activate RTO, 3 .. deactivate RTO, 4 .. toggle CM, 5 .. activate CM, 6 .. deactivate CM, 7 .. open
   *
   * @format int32
   */
  doubleButtonPressAction: number;
  /**
   * The type of the batteries present in the smart lock: 0 .. alkali, 1 .. accumulator, 2 .. lithium, 3 .. fixed
   *
   * @format int32
   */
  batteryType: number;
  /**
   * Flag that indicates if the automatic detection of the battery type is enabled
   */
  automaticBatteryTypeDetection?: boolean;
  /**
   * Flag that indicates if available firmware updates for the deviceshould be installed automatically
   */
  autoUpdateEnabled?: boolean;
  /**
   * The operation id - if set it's locked for another operation
   */
  operationId?: string;
};

export type SmartlockSmartdoorAdvancedConfig = {
  /**
   * Timeout in seconds for lock ‘n’ go
   *
   * @format int32
   */
  lngTimeout?: 5 | 10 | 15 | 20 | 30 | 45 | 60;
  /**
   * The desired action, if the button is pressed once: 0 .. no action, 1 .. intelligent, 2 .. unlock, 3 .. lock, 4 .. unlatch, 5 .. lock 'n' go, 6 .. show status
   *
   * @format int32
   */
  singleButtonPressAction?: number;
  /**
   * The desired action, if the button is pressed twice: 0 .. no action, 1 .. intelligent, 2 .. unlock, 3 .. lock, 4 .. unlatch, 5 .. lock 'n' go, 6 .. show status
   *
   * @format int32
   */
  doubleButtonPressAction?: number;
  /**
   * Flag that indicates if the automatic detection of the battery type is enabled
   */
  automaticBatteryTypeDetection?: boolean;
  /**
   * Duration in seconds for holding the latch in unlatched position
   *
   * @format int32
   */
  unlatchDuration?: 1 | 3 | 5 | 7 | 10 | 15 | 20 | 30;
  /**
   * The operation id - if set it's locked for another operation
   */
  operationId?: string;
  /**
   * The volume of the buzzer: 0 .. off, 1 .. low, 2 .. normal
   *
   * @format int32
   */
  buzzerVolume?: 0 | 1 | 2;
  /**
   * Set of supported battery types: 0 .. alkali, 1 .. accumulator, 2 .. lithium, 3 .. fixed, 254 .. automatic, 255 .. unknown
   *
   * @uniqueItems true
   */
  supportedBatteryTypes?: number[];
  /**
   * The type of the batteries present in the smart lock: 0 .. alkali, 1 .. accumulator, 2 .. lithium, 3 .. fixed, 255 .. unknown
   *
   * @format int32
   */
  batteryType: number;
  /**
   * Seconds until the smart lock relocks itself after it has been unlocked. No auto relock if value is 0
   *
   * @format int32
   */
  autoLockTimeout?: number;
  /**
   * The Auto Lock feature automatically locks your door when it has been unlocked for a certain period of time
   */
  autoLock: boolean;
};

export type SmartlockState = {
  /**
   * The smartlock mode: 0 .. uninitialized, 1 .. pairing, 2 .. door (default), 3 .. continuous (type=2 only), 4 .. maintenance, 5 .. off-door charging
   *
   * @format int32
   * @minimum 0
   * @maximum 4
   */
  mode: number;
  /**
   * The smartlock state: type=0/3/4: 0 .. uncalibrated, 1 .. locked, 2 .. unlocking, 3 .. unlocked, 4 .. locking, 5 .. unlatched, 6 .. unlocked (lock 'n' go), 7 .. unlatching, 224 .. Error wrong entry code, 225 .. Error wrong Fingerprint, 254 .. motor blocked, 255 .. undefined; type=2: 0 .. untrained, 1 .. online, 3 .. ring to open active, 5 .. open, 7 .. opening, 253 .. boot run, 255 .. undefined
   *
   * @format int32
   * @minimum 0
   * @maximum 255
   */
  state: number;
  /**
   * The state trigger: 0 .. system, 1 .. manual, 2 .. button, 3 .. automatic, 4 .. web (type=1 only), 5 .. app (type=1 only), 6 .. continuous mode (type=2 only), 7 .. accessory (type=3 only)
   *
   * @format int32
   * @minimum 0
   * @maximum 6
   */
  trigger: number;
  /**
   * The action: type=0/3/4: 1 .. unlock, 2 .. lock, 3 .. unlatch, 4 .. lock 'n' go, 5 .. lock 'n' go with unlatch; type=1: 1 .. unlock; type=2: 1 .. activate ring to open, 2 .. deactivate ring to open, 3 .. open (electric strike actuation)
   *
   * @format int32
   * @minimum 0
   * @maximum 5
   */
  lastAction: number;
  /**
   * True if the battery state of the device is critical
   */
  batteryCritical: boolean;
  /**
   * True if a Nuki battery pack in a Smart Lock is currently charging
   */
  batteryCharging?: boolean;
  /**
   * Remaining capacity of a Nuki battery pack in %
   *
   * @format int32
   * @minimum 0
   * @maximum 100
   */
  batteryCharge?: number;
  /**
   * True if the battery of a paired Keypad is critical (only available for supported devices)
   */
  keypadBatteryCritical?: boolean;
  /**
   * True if the battery of a paired doorsensor is critical (only available for supported devices)
   */
  doorsensorBatteryCritical?: boolean;
  /**
   * The door state: 0 .. unavailable/not paired, 1 .. deactivated, 2 .. door closed, 3 .. door opened, 4 .. door state unknown, 5 .. calibrating, 16 .. uncalibrated, 240 .. removed, 255 .. unknown
   *
   * @format int32
   * @minimum 0
   * @maximum 255
   */
  doorState: number;
  /**
   * [deprecated] Remaining ring to open time; 0 if ring to open is not active (type=2 only)
   *
   * @format int32
   * @minimum 0
   * @maximum 65535
   */
  ringToOpenTimer: number;
  /**
   * End date of ring to open timeout; null if ring to open is not active (type=2 only)
   *
   * @format date-time
   */
  ringToOpenEnd?: string;
  /**
   * True if night mode currently active
   */
  nightMode: boolean;
  /**
   * The operation id - if set it's locked for another operation
   */
  operationId?: string;
};

export type SmartlockWebConfig = {
  /**
   * True if a battery warning is send via email, if null/not send, the value is not being updated
   */
  batteryWarningPerMailEnabled?: boolean;
  /**
   * Contains the account ids which have dismissed the lift up handle warning, if null/not send, the value is not being updated. To clear send a empty array []
   */
  dismissedLiftUpHandleWarning?: number[];
};

export type SmartlockAction = {
  /**
   * The action: type=0/3/4: 1 .. unlock, 2 .. lock, 3 .. unlatch, 4 .. lock 'n' go, 5 .. lock 'n' go with unlatch; type=1: 1 .. unlock; type=2: 1 activate ring to open, 2 .. deactivate ring to open, 3 .. open (electric strike actuation), 6 ... activate continuous mode, 7 ... deactivate continuous mode
   *
   * @format int32
   * @minimum 0
   * @maximum 7
   */
  action: number;
  /**
   * The option mask: 0 .. none, 2 .. force, 4 .. full lock
   *
   * @format int32
   * @minimum 0
   * @maximum 7
   */
  option?: number;
};

export type SmartlockAdminPinUpdate = {
  /**
   * The admin pin
   *
   * @format int32
   * @minimum 0
   * @maximum 9999
   */
  adminPin: number;
};

export type SmartlockAuth = {
  /**
   * The unique id for the smartlock authorization
   */
  id: string;
  /**
   * The smartlock id
   *
   * @format int64
   */
  smartlockId: number;
  /**
   * The id of the linked account user
   *
   * @format int32
   */
  accountUserId?: number;
  /**
   * The smartlock authorization id
   *
   * @format int32
   */
  authId?: number;
  /**
   * The keypad code (only for type keypad)
   *
   * @format int32
   */
  code?: number;
  fingerprints?: {
    [key: string]: string;
  };
  /**
   * The type of the authorization: 0 .. app, 1 .. bridge, 2 .. fob, 3 .. keypad, 13 .. keypad code, 14 .. z-key, 15 .. virtual
   *
   * @format int32
   * @minimum 0
   * @maximum 2
   */
  type: number;
  /**
   * The name of the authorization (max 32 chars)
   */
  name: string;
  /**
   * True if the auth is enabled
   */
  enabled: boolean;
  /**
   * True if the auth has remote access
   */
  remoteAllowed: boolean;
  /**
   * The lock count
   *
   * @format int32
   */
  lockCount: number;
  /**
   * The allowed from date
   *
   * @format date-time
   */
  allowedFromDate?: string;
  /**
   * The allowed until date
   *
   * @format date-time
   */
  allowedUntilDate?: string;
  /**
   * The allowed weekdays bitmask: 64 .. monday, 32 .. tuesday, 16 .. wednesday, 8 .. thursday, 4 .. friday, 2 .. saturday, 1 .. sunday
   *
   * @format int32
   * @minimum 0
   * @maximum 127
   */
  allowedWeekDays?: number;
  /**
   * The allowed from time (in minutes from midnight)
   *
   * @format int32
   */
  allowedFromTime?: number;
  /**
   * The allowed until time (in minutes from midnight)
   *
   * @format int32
   */
  allowedUntilTime?: number;
  /**
   * The last active date
   *
   * @format date-time
   */
  lastActiveDate?: string;
  /**
   * The creation date
   *
   * @format date-time
   */
  creationDate?: string;
  /**
   * The update date
   *
   * @format date-time
   */
  updateDate?: string;
  operationId?: ObjectId;
  /**
   * In case of any error, it contains the error message
   */
  error?: string;
  /**
   * The ID of the Nuki App
   *
   * @format int32
   */
  appId?: number;
  authTypeAsString?: string;
};

export type SmartlockAuthCreate = {
  /**
   * The name of the authorization (max 32 chars)
   */
  name: string;
  /**
   * The allowed from date
   *
   * @format date-time
   */
  allowedFromDate?: string;
  /**
   * The allowed until date
   *
   * @format date-time
   */
  allowedUntilDate?: string;
  /**
   * The allowed weekdays bitmask: 64 .. monday, 32 .. tuesday, 16 .. wednesday, 8 .. thursday, 4 .. friday, 2 .. saturday, 1 .. sunday
   *
   * @format int32
   * @minimum 0
   * @maximum 127
   */
  allowedWeekDays?: number;
  /**
   * The allowed from time (in minutes from midnight)
   *
   * @format int32
   */
  allowedFromTime?: number;
  /**
   * The allowed until time (in minutes from midnight)
   *
   * @format int32
   */
  allowedUntilTime?: number;
  /**
   * The id of the linked account user (required if type is NOT 13 .. keypad)
   *
   * @format int32
   */
  accountUserId?: number;
  /**
   * True if the auth has remote access
   */
  remoteAllowed: boolean;
  /**
   * The smart actions enabled flag
   */
  smartActionsEnabled?: boolean;
  /**
   * The optional type of the auth 0 .. app (default), 2 .. fob, 13 .. keypad
   *
   * @format int32
   */
  type?: number;
  /**
   * The code of the keypad authorization (only for keypad)
   *
   * @format int32
   */
  code?: number;
};

export type SmartlockAuthMultiUpdate = {
  /**
   * The name of the authorization (max 32 chars)
   */
  name: string;
  /**
   * The allowed from date
   *
   * @format date-time
   */
  allowedFromDate?: string;
  /**
   * The allowed until date
   *
   * @format date-time
   */
  allowedUntilDate?: string;
  /**
   * The allowed weekdays bitmask: 64 .. monday, 32 .. tuesday, 16 .. wednesday, 8 .. thursday, 4 .. friday, 2 .. saturday, 1 .. sunday
   *
   * @format int32
   * @minimum 0
   * @maximum 127
   */
  allowedWeekDays?: number;
  /**
   * The allowed from time (in minutes from midnight)
   *
   * @format int32
   */
  allowedFromTime?: number;
  /**
   * The allowed until time (in minutes from midnight)
   *
   * @format int32
   */
  allowedUntilTime?: number;
  /**
   * The id of the linked account user
   *
   * @format int32
   */
  accountUserId?: number;
  /**
   * True if the auth is enabled
   */
  enabled?: boolean;
  /**
   * True if the auth has remote access
   */
  remoteAllowed?: boolean;
  /**
   * The code of the keypad authorization (only for keypad)
   *
   * @format int32
   */
  code?: number;
  /**
   * The unique id for the smartlock authorization
   */
  id: string;
};

export type SmartlockAuthUpdate = {
  /**
   * The name of the authorization (max 32 chars)
   */
  name: string;
  /**
   * The allowed from date
   *
   * @format date-time
   */
  allowedFromDate?: string;
  /**
   * The allowed until date
   *
   * @format date-time
   */
  allowedUntilDate?: string;
  /**
   * The allowed weekdays bitmask: 64 .. monday, 32 .. tuesday, 16 .. wednesday, 8 .. thursday, 4 .. friday, 2 .. saturday, 1 .. sunday
   *
   * @format int32
   * @minimum 0
   * @maximum 127
   */
  allowedWeekDays?: number;
  /**
   * The allowed from time (in minutes from midnight)
   *
   * @format int32
   */
  allowedFromTime?: number;
  /**
   * The allowed until time (in minutes from midnight)
   *
   * @format int32
   */
  allowedUntilTime?: number;
  /**
   * The id of the linked account user
   *
   * @format int32
   */
  accountUserId?: number;
  /**
   * True if the auth is enabled
   */
  enabled?: boolean;
  /**
   * True if the auth has remote access
   */
  remoteAllowed?: boolean;
  /**
   * The code of the keypad authorization (only for keypad)
   *
   * @format int32
   */
  code?: number;
};

export type SmartlockAuthWithSharedKeyCreate = {
  /**
   * The name of the authorization (max 32 chars)
   */
  name: string;
  /**
   * The allowed from date
   *
   * @format date-time
   */
  allowedFromDate?: string;
  /**
   * The allowed until date
   *
   * @format date-time
   */
  allowedUntilDate?: string;
  /**
   * The allowed weekdays bitmask: 64 .. monday, 32 .. tuesday, 16 .. wednesday, 8 .. thursday, 4 .. friday, 2 .. saturday, 1 .. sunday
   *
   * @format int32
   * @minimum 0
   * @maximum 127
   */
  allowedWeekDays?: number;
  /**
   * The allowed from time (in minutes from midnight)
   *
   * @format int32
   */
  allowedFromTime?: number;
  /**
   * The allowed until time (in minutes from midnight)
   *
   * @format int32
   */
  allowedUntilTime?: number;
  /**
   * The id of the linked account user
   *
   * @format int32
   */
  accountUserId?: number;
};

export type SmartlockLog = {
  /**
   * The unique id for the smartlock log
   */
  id: string;
  /**
   * The smartlock id
   *
   * @format int64
   */
  smartlockId: number;
  /**
   * The device type: 0 .. smartlock and box, 2 .. opener, 3 .. smartdoor
   *
   * @format int32
   */
  deviceType: 0 | 2 | 3;
  /**
   * The id of the linked account user
   *
   * @format int32
   */
  accountUserId?: number;
  /**
   * The id of the linked smartlock auth
   */
  authId?: string;
  /**
   * The name
   */
  name: string;
  /**
   * The action: 1 .. unlock, 2 .. lock, 3 .. unlatch, 4 .. lock'n'go, 5 .. lock'n'go with unlatch, 11 .. Restore reset to default setting, 208 .. door warning ajar, 209 door warning status mismatch, 224 .. doorbell recognition (only Opener), 240 .. door opened, 241 .. door closed, 242 .. door sensor jammed, 243 .. firmware update, 250 .. door log enabled, 251 .. door log disabled, 252 .. initialization, 253 .. calibration, 254 .. log enabled, 255 .. log disabled
   *
   * @format int32
   * @minimum 1
   * @maximum 255
   */
  action: number;
  /**
   * The trigger: 0 .. system, 1 .. manual, 2 .. button, 3 .. automatic, 4 .. web, 5 .. app, 6 .. auto lock, 7 .. accessory, 255 .. keypad
   *
   * @format int32
   * @minimum 0
   * @maximum 255
   */
  trigger: number;
  /**
   * The completion state: 0 .. Success, 1 .. Motor blocked, 2 .. Canceled, 3 .. Too recent, 4 .. Busy, 5 .. Low motor voltage, 6 .. Clutch failure, 7 .. Motor power failure, 8 .. Incomplete, 9 .. Rejected, 10 .. Rejected night mode, 224 .. Invalid Code, 225 .. Invalid Fingerprint, 226 .. Invalid NFC Tag, 254 .. Other error, 255 .. Unknown error
   *
   * @format int32
   * @minimum 1
   * @maximum 255
   */
  state: number;
  /**
   * True if it was an auto unlock
   */
  autoUnlock: boolean;
  /**
   * The log date
   *
   * @format date-time
   */
  date: string;
  openerLog?: SmartlockLogOpenerLog;
  /**
   * The door sensor warning ajar timeout (in minutes, only for action = 208)
   *
   * @format int32
   */
  ajarTimeout?: number;
  /**
   * The source of action: 1 .. Keypad code, 2 .. Fingerprint, 3 .. Tap to Unlock, 0 .. Default
   *
   * @format int32
   */
  source?: number;
  /**
   * In case of any error, it contains the error message
   */
  error?: string;
};

export type SmartlockLogOpenerLog = {
  /**
   * Flag indicating if continuous mode was active
   */
  activeCm: boolean;
  /**
   * Flag indicating if ring to open was active
   */
  activeRto: boolean;
  /**
   * The cause of the activation of ring to open or continuous mode: 0 .. doorbell, 1 .. timecontrol, 2 .. app, 3 .. button, 4 .. fob, 5 .. bridge, 6 .. keypad
   *
   * @format int32
   * @minimum 0
   * @maximum 6
   */
  source: number;
  /**
   * Flag indicating a geo fence induced action
   */
  flagGeoFence: boolean;
  /**
   * Flag indicating a force induced action
   */
  flagForce: boolean;
  /**
   * Flag indicating if doorbell suppression was active
   */
  flagDoorbellSuppression: boolean;
};

export type SmartlockUpdate = {
  /**
   * The new name of the smartlock
   */
  name?: string;
  /**
   * True if the smartlock is favorite
   */
  favorite?: boolean;
};

export type SmartlocksAuthAdvancedCreate = {
  /**
   * The name of the authorization (max 32 chars)
   */
  name: string;
  /**
   * The allowed from date
   *
   * @format date-time
   */
  allowedFromDate?: string;
  /**
   * The allowed until date
   *
   * @format date-time
   */
  allowedUntilDate?: string;
  /**
   * The allowed weekdays bitmask: 64 .. monday, 32 .. tuesday, 16 .. wednesday, 8 .. thursday, 4 .. friday, 2 .. saturday, 1 .. sunday
   *
   * @format int32
   * @minimum 0
   * @maximum 127
   */
  allowedWeekDays?: number;
  /**
   * The allowed from time (in minutes from midnight)
   *
   * @format int32
   */
  allowedFromTime?: number;
  /**
   * The allowed until time (in minutes from midnight)
   *
   * @format int32
   */
  allowedUntilTime?: number;
  /**
   * The id of the linked account user
   *
   * @format int32
   */
  accountUserId: number;
  /**
   * The list of smartlock ids
   */
  smartlockIds: number[];
  /**
   * True if the auth has remote access
   */
  remoteAllowed: boolean;
  /**
   * The smart actions enabled flag
   */
  smartActionsEnabled?: boolean;
};

export type SmartlocksAuthCreate = {
  /**
   * The name of the authorization (max 32 chars)
   */
  name: string;
  /**
   * The allowed from date
   *
   * @format date-time
   */
  allowedFromDate?: string;
  /**
   * The allowed until date
   *
   * @format date-time
   */
  allowedUntilDate?: string;
  /**
   * The allowed weekdays bitmask: 64 .. monday, 32 .. tuesday, 16 .. wednesday, 8 .. thursday, 4 .. friday, 2 .. saturday, 1 .. sunday
   *
   * @format int32
   * @minimum 0
   * @maximum 127
   */
  allowedWeekDays?: number;
  /**
   * The allowed from time (in minutes from midnight)
   *
   * @format int32
   */
  allowedFromTime?: number;
  /**
   * The allowed until time (in minutes from midnight)
   *
   * @format int32
   */
  allowedUntilTime?: number;
  /**
   * The id of the linked account user (required if type is NOT 13 .. keypad)
   *
   * @format int32
   */
  accountUserId?: number;
  /**
   * The list of smartlock ids
   */
  smartlockIds?: number[];
  /**
   * True if the auth has remote access
   */
  remoteAllowed: boolean;
  /**
   * The smart actions enabled flag
   */
  smartActionsEnabled?: boolean;
  /**
   * The optional type of the auth 0 .. app (default), 2 .. fob, 13 .. keypad
   *
   * @format int32
   */
  type?: number;
  /**
   * The code of the keypad authorization (only for keypad)
   *
   * @format int32
   */
  code?: number;
};

export type StackTraceElement = {
  classLoaderName?: string;
  moduleName?: string;
  moduleVersion?: string;
  methodName?: string;
  fileName?: string;
  /**
   * @format int32
   */
  lineNumber?: number;
  className?: string;
  nativeMethod?: boolean;
};

export type StaleDevice = {
  /**
   * @format int64
   */
  smartlockId?: number;
  name?: string;
  read?: boolean;
};

export type Status = {
  /**
   * @format int32
   */
  code?: number;
  description?: string;
  reasonPhrase?: string;
  throwable?: Throwable;
  uri?: string;
  error?: boolean;
  success?: boolean;
  serverError?: boolean;
  connectorError?: boolean;
  clientError?: boolean;
  globalError?: boolean;
  informational?: boolean;
  redirection?: boolean;
  recoverableError?: boolean;
};

export type StatusService = {
  context?: Context;
  enabled?: boolean;
  started?: boolean;
  connegService?: ConnegService;
  contactEmail?: string;
  converterService?: ConverterService;
  homeRef?: Reference;
  metadataService?: MetadataService;
  overwriting?: boolean;
  stopped?: boolean;
};

export type Tag = {
  name?: string;
  weak?: boolean;
};

export type TaskService = {
  context?: Context;
  enabled?: boolean;
  started?: boolean;
  /**
   * @format int32
   */
  corePoolSize?: number;
  daemon?: boolean;
  shutdownAllowed?: boolean;
  terminated?: boolean;
  shutdown?: boolean;
  stopped?: boolean;
};

export type TermsOfUse = {
  state?: "Accepted" | "Inactive";
  /**
   * @format date-time
   */
  publishDate?: string;
  /**
   * @format date-time
   */
  acceptanceDate?: string;
};

export type Throwable = {
  cause?: Throwable;
  stackTrace?: StackTraceElement[];
  message?: string;
  suppressed?: Throwable[];
  localizedMessage?: string;
};

export type TunnelService = {
  context?: Context;
  enabled?: boolean;
  started?: boolean;
  characterSetParameter?: string;
  encodingParameter?: string;
  extensionsTunnel?: boolean;
  headersTunnel?: boolean;
  languageParameter?: string;
  mediaTypeParameter?: string;
  methodHeader?: string;
  methodParameter?: string;
  methodTunnel?: boolean;
  preferencesTunnel?: boolean;
  queryTunnel?: boolean;
  userAgentTunnel?: boolean;
  stopped?: boolean;
};

export type Uniform = Record<string, any>;

export type User = {
  email?: string;
  firstName?: string;
  identifier?: string;
  lastName?: string;
  secret?: string[];
  name?: string;
};

export type Variant = {
  characterSet?: CharacterSet;
  encodings?: Encoding[];
  locationRef?: Reference;
  languages?: Language[];
  mediaType?: MediaType;
};

export type Verifier = Record<string, any>;

export type WakeupListener = Record<string, any>;

export type Warning = {
  agent?: string;
  /**
   * @format date-time
   */
  date?: string;
  status?: Status;
  text?: string;
};

export type WebConfigRequest = {
  /**
   * @format int64
   */
  smartlockId?: number;
  webConfig?: SmartlockWebConfig;
};

export type WebhookLog = {
  /**
   * The WebhookLog id
   */
  id: string;
  /**
   * Request id, set when api-triggered request otherwise empty
   */
  requestId?: string;
  /**
   * If the webhooks sends the data successfully
   */
  succeeded?: boolean;
  /**
   * Http Status code of the webhook response
   *
   * @format int32
   */
  responseStatus?: number;
  /**
   * The duration of the webhook in milli seconds
   *
   * @format int64
   */
  duration?: number;
  /**
   * The account id
   *
   * @format int32
   */
  accountId: number;
  request?: WebhookMessage;
  response?: WebhookMessage;
  /**
   * Used Api Key for the webhook
   *
   * @format int32
   */
  apiKeyId: number;
  /**
   * last updated time
   *
   * @format date-time
   */
  updated: string;
  /**
   * Creation Date
   *
   * @format date-time
   */
  created: string;
};

export type WebhookMessage = {
  /**
   * Http Headers as key value pairs
   */
  headers: {
    [key: string]: string;
  };
  /**
   * Http Body as Json
   */
  body?: {
    [key: string]: Record<string, any>;
  };
  /**
   * The timestamp when the message was created
   *
   * @format date-time
   */
  timestamp?: string;
  /**
   * Path of the message
   */
  path: string;
};
