/**
 * Generated by @openapi-codegen
 *
 * @version 4.0.0
 */
import type * as Schemas from "./schemas";

export type ApiShieldBulkCreateRules =
  Schemas.ApiShieldCreateSingleRuleRequest[];

export type ApiShieldBulkEditRules = ({
  /**
   * Rule ID this patch applies to
   *
   * @example 0d9bf70c-92e1-4bb3-9411-34a3bcc59003
   * @format uuid
   * @maxLength 36
   * @x-auditable true
   */
  id: string;
} & Schemas.ApiShieldEditSingleRuleRequest)[];

export type ApiShieldConfigUpdate = Schemas.ApiShieldConfiguration;

export type ApiShieldCreateConfig = {
  credentials: Schemas.ApiShieldCredentials;
  description: Schemas.ApiShieldDescription;
  title: Schemas.ApiShieldTitle;
  token_sources: Schemas.ApiShieldTokenSources;
  token_type: Schemas.ApiShieldTokenType;
};

export type ApiShieldCreateRule = Schemas.ApiShieldCreateSingleRuleRequest;

export type ApiShieldEditConfig = {
  description?: Schemas.ApiShieldDescription;
  title?: Schemas.ApiShieldTitle;
  token_sources?: Schemas.ApiShieldTokenSources;
};

export type ApiShieldEditRule = Schemas.ApiShieldEditSingleRuleRequest;

export type ApiShieldGlobalSettingsEdit =
  Schemas.ApiShieldGlobalSettingChangeBase;

export type ApiShieldGlobalSettingsUpdate = {
  /**
   * The default mitigation action used
   * Mitigation actions are as follows:
   *
   *   - `"log"` - log request when request does not conform to schema
   *   - `"block"` - deny access to the site when request does not conform to schema
   *   - `"none"` - skip running schema validation
   *
   * @example block
   * @x-auditable true
   */
  validation_default_mitigation_action: "none" | "log" | "block";
  /**
   * When set, this overrides both zone level and operation level mitigation actions.
   *
   *   - `"none"` - skip running schema validation entirely for the request
   *   - `null` - clears any existing override
   *
   * @x-auditable true
   */
  validation_override_mitigation_action?: "none" | any | null;
};

export type ApiShieldPerOperationSettingUpdate = {
  /**
   * When set, this applies a mitigation action to this operation
   *
   *   - `"log"` - log request when request does not conform to schema for this operation
   *   - `"block"` - deny access to the site when request does not conform to schema for this operation
   *   - `"none"` - will skip mitigation for this operation
   *   - `null` - clears any mitigation action
   *
   * @example block
   * @x-auditable true
   */
  mitigation_action: "log" | "block" | "none" | any | null;
};

/**
 * @example {"3818d821-5901-4147-a474-f5f5aec1d54e":{"mitigation_action":"log"},"b17c8043-99a0-4202-b7d9-8f7cdbee02cd":{"mitigation_action":"block"}}
 */
export type ApiShieldPerOperationSettingsBulkEdit = {
  [key: string]: {
    /**
     * Mitigation actions are as follows:
     * * `log` - log request when request does not conform to schema * `block` - deny access to the site when request does not conform to schema * `none` - skip running schema validation * null - clears any existing per-operation setting
     *
     * @example block
     */
    mitigation_action?: "none" | "log" | "block" | any | null;
  };
};

export type ApiShieldPreviewRules = Schemas.ApiShieldSelector;

export type ApiShieldSchemaCreate = {
  /**
   * The kind of the schema
   *
   * @example openapi_v3
   */
  kind: "openapi_v3";
  /**
   * A human-readable name for the schema
   *
   * @example petstore schema
   */
  name: string;
  /**
   * The raw schema, e.g., the OpenAPI schema, either as JSON or YAML
   *
   * @example <schema file contents>
   */
  source: string;
  /**
   * An indicator if this schema is enabled
   */
  validation_enabled: boolean;
};

export type ApiShieldSchemaEdit = {
  /**
   * Flag whether schema is enabled for validation.
   */
  validation_enabled?: boolean;
};

export type ApiShieldUpdateConfigCredentials = Schemas.ApiShieldCredentials;

export type PayPerCrawlDaricConfig = Schemas.PayPerCrawlDaricConfig;

export type PayPerCrawlZonesCanBeEnabledPayload =
  Schemas.PayPerCrawlZonesCanBeEnabledPayload;

export type RealtimekitAddParticipantBody = {
  /**
   * A unique participant ID. You must specify a unique ID for the participant, for example, UUID, email address, and so on.
   */
  custom_participant_id: string;
  /**
   * (Optional) Name of the participant.
   *
   * @example Mary Sue
   */
  name?: string | null;
  /**
   * (Optional) A URL to a picture to be used for the participant.
   *
   * @example https://i.imgur.com/test.jpg
   * @format uri
   */
  picture?: string | null;
  /**
   * Name of the preset to apply to this participant.
   *
   * @default group_call_host
   */
  preset_name: string;
};

export type RealtimekitCreateApp = {
  name: string;
};

export type RealtimekitCreateMeetingBody = {
  ai_config?: Schemas.RealtimekitAIConfig;
  /**
   * Specifies if the meeting should start getting livestreamed on start.
   *
   * @default false
   */
  live_stream_on_start?: boolean | null;
  /**
   * If a meeting is set to persist_chat, meeting chat would remain for a week within the meeting space.
   *
   * @default false
   */
  persist_chat?: boolean;
  /**
   * Specifies if the meeting should start getting recorded as soon as someone joins the meeting.
   *
   * @default false
   */
  record_on_start?: boolean | null;
  recording_config?: Schemas.RealtimekitRecordingConfig;
  /**
   * Time in seconds, for which a session remains active, after the last participant has left the meeting.
   *
   * @default 60
   * @maximum 600
   * @minimum 60
   */
  session_keep_alive_time_in_secs?: number;
  /**
   * Automatically generate summary of meetings using transcripts. Requires Transcriptions to be enabled, and can be retrieved via Webhooks or summary API.
   *
   * @default false
   */
  summarize_on_end?: boolean;
  /**
   * Title of the meeting
   */
  title?: string | null;
};

export type RealtimekitCreatePollBody = {
  /**
   * if voters on a poll are anonymous
   */
  anonymous?: boolean;
  /**
   * if votes on an option are visible before a person votes
   */
  hide_votes?: boolean;
  /**
   * Different options for the question
   */
  options: string[];
  /**
   * Question of the poll
   */
  question: string;
};

export type RealtimekitCreatePresetBody = Schemas.RealtimekitPreset;

export type RealtimekitEditParticipantBody = {
  /**
   * (Optional) Name of the participant.
   *
   * @example Jane Doe
   */
  name?: string | null;
  /**
   * (Optional) A URL to a picture to be used for the participant.
   *
   * @format uri
   */
  picture?: string | null;
  /**
   * (Optional) Name of the preset to apply to this participant.
   */
  preset_name?: string | null;
};

export type RealtimekitKickParticipantsBody = {
  custom_participant_ids: string[];
  participant_ids: string[];
};

export type RealtimekitMuteAllParticipantsBody = {
  /**
   * if false, participants won't be able to unmute themselves after they are muted
   */
  allow_unmute: boolean;
};

export type RealtimekitStartRecording = {
  /**
   * By default, a meeting allows only one recording to run at a time. Enabling the `allow_multiple_recordings` parameter to true allows you to initiate multiple recordings concurrently in the same meeting. This allows you to record separate videos of the same meeting with different configurations, such as portrait mode or landscape mode.
   *
   * @default false
   */
  allow_multiple_recordings?: boolean;
  audio_config?: Schemas.RealtimekitAudioConfig;
  /**
   * Update the recording file name.
   */
  file_name_prefix?: string;
  interactive_config?: Schemas.RealtimekitInteractiveConfig;
  /**
   * Specifies the maximum duration for recording in seconds, ranging from a minimum of 60 seconds to a maximum of 24 hours.
   *
   * @maximum 86400
   * @minimum 60
   */
  max_seconds?: number;
  /**
   * ID of the meeting to record.
   *
   * @format uuid
   */
  meeting_id?: string;
  realtimekit_bucket_config?: Schemas.RealtimekitRealtimekitBucketConfig;
  rtmp_out_config?: Schemas.RealtimekitLivestreamingConfig;
  storage_config?: Schemas.RealtimekitStorageConfig;
  /**
   * Pass a custom url to record arbitary screen
   *
   * @format uri
   */
  url?: string;
  video_config?: Schemas.RealtimekitVideoConfig;
};

export type RealtimekitStartTrackRecordingBody = {
  layers: {
    [key: string]: Schemas.RealtimekitTrackConfigLayer;
  };
  /**
   * Maximum seconds this recording should be active for (beta)
   */
  max_seconds?: number;
  /**
   * ID of the meeting to record.
   */
  meeting_id: string;
};

export type RealtimekitUpdateMeetingBody = {
  ai_config?: Schemas.RealtimekitAIConfig;
  /**
   * Specifies if the meeting should start getting livestreamed on start.
   *
   * @default false
   */
  live_stream_on_start?: boolean;
  /**
   * If a meeting is updated to persist_chat, meeting chat would remain for a week within the meeting space.
   *
   * @default false
   */
  persist_chat?: boolean;
  /**
   * Specifies if the meeting should start getting recorded as soon as someone joins the meeting.
   *
   * @default false
   */
  record_on_start?: boolean;
  /**
   * Time in seconds, for which a session remains active, after the last participant has left the meeting.
   *
   * @default 60
   * @maximum 600
   * @minimum 60
   */
  session_keep_alive_time_in_secs?: number;
  /**
   * Whether the meeting is `ACTIVE` or `INACTIVE`. Users will not be able to join an `INACTIVE` meeting.
   *
   * @example INACTIVE
   */
  status?: "ACTIVE" | "INACTIVE";
  /**
   * Automatically generate summary of meetings using transcripts. Requires Transcriptions to be enabled, and can be retrieved via Webhooks or summary API.
   *
   * @default false
   */
  summarize_on_end?: boolean;
  /**
   * Title of the meeting
   */
  title?: string;
};

export type RealtimekitUpdatePresetBody = Schemas.RealtimekitUpdatePreset;

/**
 * A ruleset object.
 */
export type RulesetsCreateRuleset = Schemas.RulesetsRuleset & {
  kind: Schemas.RulesetsRulesetKind;
  phase: Schemas.RulesetsRulesetPhase;
  rules?: Schemas.RulesetsRequestRules;
};

export type RulesetsManagedTransforms = Schemas.RulesetsManagedTransforms;

export type RulesetsRule = Schemas.RulesetsRequestRule & {
  position?:
    | (Schemas.RulesetsRulePosition & {
        /**
         * The ID of another rule to place the rule before. An empty value causes the rule to be placed at the top.
         *
         * @example da5e8e506c8e7877fe06cdf4c41add54
         * @pattern ^[0-9a-f]{32}$
         */
        before?: string;
      })
    | (Schemas.RulesetsRulePosition & {
        /**
         * The ID of another rule to place the rule after. An empty value causes the rule to be placed at the bottom.
         *
         * @example 5bccdbb2a5142cd25cad8591255bd209
         * @pattern ^[0-9a-f]{32}$
         */
        after?: string;
      })
    | (Schemas.RulesetsRulePosition & {
        /**
         * An index at which to place the rule, where index 1 is the first rule.
         *
         * @example 1
         * @minimum 1
         */
        index?: number;
      });
};

/**
 * A ruleset object.
 */
export type RulesetsUpdateEntrypointRuleset = Schemas.RulesetsRuleset & {
  rules?: Schemas.RulesetsRequestRules;
};

/**
 * A ruleset object.
 */
export type RulesetsUpdateRuleset = Schemas.RulesetsRuleset & {
  kind?: Schemas.RulesetsRulesetKind;
  phase?: Schemas.RulesetsRulesetPhase;
  rules?: Schemas.RulesetsRequestRules;
};

export type RulesetsUrlNormalization = Schemas.RulesetsUrlNormalization;

/**
 * A snippet object.
 */
export type SnippetsSnippet = {
  /**
   * Metadata about the snippet.
   */
  metadata: {
    main_module: Schemas.SnippetsSnippetMainModule;
  };
} & {
  [key: string]: Schemas.SnippetsSnippetFiles;
};

/**
 * A snippet rules object.
 */
export type SnippetsSnippetRules = {
  rules: Schemas.SnippetsSnippetRules;
};

export type WorkersScriptUpload = Schemas.WorkersMultipartScript;

export type WorkersVersionPost = {
  /**
   * An array of modules (often JavaScript files) comprising a Worker script. At least one module must be present and referenced in the metadata as `main_module` or `body_part` by filename.<br/>Possible Content-Type(s) are: `application/javascript+module`, `text/javascript+module`, `application/javascript`, `text/javascript`, `text/x-python`, `text/x-python-requirement`, `application/wasm`, `text/plain`, `application/octet-stream`, `application/source-map`.
   *
   * @x-stainless-collection-type set
   */
  files?: Blob[];
  /**
   * JSON-encoded metadata about the uploaded parts and Worker configuration.
   */
  metadata: {
    annotations?: {
      /**
       * Associated alias for a version.
       *
       * @example staging
       * @maxLength 63
       */
      ["workers/alias"]?: string;
      /**
       * Human-readable message about the version. Truncated to 100 bytes.
       *
       * @example Fixed worker code.
       * @maxLength 100
       */
      ["workers/message"]?: string;
      /**
       * User-provided identifier for the version.
       *
       * @example any-identifier-from-external-system
       * @maxLength 25
       */
      ["workers/tag"]?: string;
    };
    bindings?: Schemas.WorkersBindings;
    compatibility_date?: Schemas.WorkersCompatibilityDate;
    compatibility_flags?: Schemas.WorkersCompatibilityFlags;
    /**
     * List of binding types to keep from previous_upload.
     *
     * @x-stainless-collection-type set
     */
    keep_bindings?: string[];
    /**
     * Name of the uploaded file that contains the main module (e.g. the file exporting a `fetch` handler). Indicates a `module syntax` Worker, which is required for Version Upload.
     *
     * @example worker.js
     */
    main_module: string;
    usage_model?: Schemas.WorkersUsageModel;
  };
};
