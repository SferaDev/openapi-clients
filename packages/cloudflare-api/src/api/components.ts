/**
 * Generated by @openapi-codegen
 *
 * @version 4.0.0
 */
import type * as Fetcher from './fetcher';
import { fetch, FetcherExtraProps } from './fetcher';
import type * as Schemas from './schemas';
import type * as RequestBodies from './requestBodies';
import type * as Responses from './responses';
import type { ClientErrorStatus, ServerErrorStatus } from './utils';

export type AccountsListAccountsQueryParams = {
  /**
   * @example example.com
   */
  name?: string;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example desc
   */
  direction?: 'asc' | 'desc';
};

export type AccountsListAccountsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountsListAccountsVariables = {
  queryParams?: AccountsListAccountsQueryParams;
} & FetcherExtraProps;

/**
 * List all accounts you have ownership or verified access to.
 */
export const accountsListAccounts = (variables: AccountsListAccountsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamResponseCollectionAccounts,
    AccountsListAccountsError,
    undefined,
    {},
    AccountsListAccountsQueryParams,
    {}
  >({ url: '/accounts', method: 'get', ...variables, signal });

export type AccountCreationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountCreationVariables = {
  body: Schemas.IamCreateAccount;
} & FetcherExtraProps;

/**
 * Create an account (only available for tenant admins at this time)
 */
export const accountCreation = (variables: AccountCreationVariables, signal?: AbortSignal) =>
  fetch<Schemas.IamResponseSingleAccount, AccountCreationError, Schemas.IamCreateAccount, {}, {}, {}>({
    url: '/accounts',
    method: 'post',
    ...variables,
    signal
  });

export type CloudforceOneRequestListPathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
};

export type CloudforceOneRequestListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOneRequestListResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsRequestListItem[];
};

export type CloudforceOneRequestListVariables = {
  body: Schemas.CloudforceOneRequestsRequestList;
  pathParams: CloudforceOneRequestListPathParams;
} & FetcherExtraProps;

export const cloudforceOneRequestList = (variables: CloudforceOneRequestListVariables, signal?: AbortSignal) =>
  fetch<
    CloudforceOneRequestListResponse,
    CloudforceOneRequestListError,
    Schemas.CloudforceOneRequestsRequestList,
    {},
    {},
    CloudforceOneRequestListPathParams
  >({ url: '/accounts/{accountIdentifier}/cloudforce-one/requests', method: 'post', ...variables, signal });

export type CloudforceOneRequestConstantsPathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
};

export type CloudforceOneRequestConstantsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOneRequestConstantsResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsRequestConstants;
};

export type CloudforceOneRequestConstantsVariables = {
  pathParams: CloudforceOneRequestConstantsPathParams;
} & FetcherExtraProps;

export const cloudforceOneRequestConstants = (
  variables: CloudforceOneRequestConstantsVariables,
  signal?: AbortSignal
) =>
  fetch<
    CloudforceOneRequestConstantsResponse,
    CloudforceOneRequestConstantsError,
    undefined,
    {},
    {},
    CloudforceOneRequestConstantsPathParams
  >({ url: '/accounts/{accountIdentifier}/cloudforce-one/requests/constants', method: 'get', ...variables, signal });

export type CloudforceOneRequestNewPathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
};

export type CloudforceOneRequestNewError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOneRequestNewResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsRequestItem;
};

export type CloudforceOneRequestNewVariables = {
  body?: Schemas.CloudforceOneRequestsRequestEdit;
  pathParams: CloudforceOneRequestNewPathParams;
} & FetcherExtraProps;

/**
 * Creating a request adds the request into the Cloudforce One queue for analysis. In addition to the content, a short title, type, priority, and releasability should be provided. If one is not provided, a default will be assigned.
 */
export const cloudforceOneRequestNew = (variables: CloudforceOneRequestNewVariables, signal?: AbortSignal) =>
  fetch<
    CloudforceOneRequestNewResponse,
    CloudforceOneRequestNewError,
    Schemas.CloudforceOneRequestsRequestEdit,
    {},
    {},
    CloudforceOneRequestNewPathParams
  >({ url: '/accounts/{accountIdentifier}/cloudforce-one/requests/new', method: 'post', ...variables, signal });

export type CloudforceOnePriorityListPathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
};

export type CloudforceOnePriorityListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOnePriorityListResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsPriorityItem[];
};

export type CloudforceOnePriorityListVariables = {
  body: Schemas.CloudforceOneRequestsPriorityList;
  pathParams: CloudforceOnePriorityListPathParams;
} & FetcherExtraProps;

export const cloudforceOnePriorityList = (variables: CloudforceOnePriorityListVariables, signal?: AbortSignal) =>
  fetch<
    CloudforceOnePriorityListResponse,
    CloudforceOnePriorityListError,
    Schemas.CloudforceOneRequestsPriorityList,
    {},
    {},
    CloudforceOnePriorityListPathParams
  >({ url: '/accounts/{accountIdentifier}/cloudforce-one/requests/priority', method: 'post', ...variables, signal });

export type CloudforceOnePriorityNewPathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
};

export type CloudforceOnePriorityNewError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOnePriorityNewResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsPriorityItem;
};

export type CloudforceOnePriorityNewVariables = {
  body: Schemas.CloudforceOneRequestsPriorityEdit;
  pathParams: CloudforceOnePriorityNewPathParams;
} & FetcherExtraProps;

export const cloudforceOnePriorityNew = (variables: CloudforceOnePriorityNewVariables, signal?: AbortSignal) =>
  fetch<
    CloudforceOnePriorityNewResponse,
    CloudforceOnePriorityNewError,
    Schemas.CloudforceOneRequestsPriorityEdit,
    {},
    {},
    CloudforceOnePriorityNewPathParams
  >({
    url: '/accounts/{accountIdentifier}/cloudforce-one/requests/priority/new',
    method: 'post',
    ...variables,
    signal
  });

export type CloudforceOnePriorityQuotaPathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
};

export type CloudforceOnePriorityQuotaError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOnePriorityQuotaResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsQuota;
};

export type CloudforceOnePriorityQuotaVariables = {
  pathParams: CloudforceOnePriorityQuotaPathParams;
} & FetcherExtraProps;

export const cloudforceOnePriorityQuota = (variables: CloudforceOnePriorityQuotaVariables, signal?: AbortSignal) =>
  fetch<
    CloudforceOnePriorityQuotaResponse,
    CloudforceOnePriorityQuotaError,
    undefined,
    {},
    {},
    CloudforceOnePriorityQuotaPathParams
  >({
    url: '/accounts/{accountIdentifier}/cloudforce-one/requests/priority/quota',
    method: 'get',
    ...variables,
    signal
  });

export type CloudforceOnePriorityDeletePathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
  priorityIdentifer: Schemas.CloudforceOneRequestsUuid;
};

export type CloudforceOnePriorityDeleteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOnePriorityDeleteVariables = {
  pathParams: CloudforceOnePriorityDeletePathParams;
} & FetcherExtraProps;

export const cloudforceOnePriorityDelete = (variables: CloudforceOnePriorityDeleteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.CloudforceOneRequestsApiResponseCommon,
    CloudforceOnePriorityDeleteError,
    undefined,
    {},
    {},
    CloudforceOnePriorityDeletePathParams
  >({
    url: '/accounts/{accountIdentifier}/cloudforce-one/requests/priority/{priorityIdentifer}',
    method: 'delete',
    ...variables,
    signal
  });

export type CloudforceOnePriorityGetPathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
  priorityIdentifer: Schemas.CloudforceOneRequestsUuid;
};

export type CloudforceOnePriorityGetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOnePriorityGetResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsRequestItem;
};

export type CloudforceOnePriorityGetVariables = {
  pathParams: CloudforceOnePriorityGetPathParams;
} & FetcherExtraProps;

export const cloudforceOnePriorityGet = (variables: CloudforceOnePriorityGetVariables, signal?: AbortSignal) =>
  fetch<
    CloudforceOnePriorityGetResponse,
    CloudforceOnePriorityGetError,
    undefined,
    {},
    {},
    CloudforceOnePriorityGetPathParams
  >({
    url: '/accounts/{accountIdentifier}/cloudforce-one/requests/priority/{priorityIdentifer}',
    method: 'get',
    ...variables,
    signal
  });

export type CloudforceOnePriorityUpdatePathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
  priorityIdentifer: Schemas.CloudforceOneRequestsUuid;
};

export type CloudforceOnePriorityUpdateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOnePriorityUpdateResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsRequestItem;
};

export type CloudforceOnePriorityUpdateVariables = {
  body: Schemas.CloudforceOneRequestsPriorityEdit;
  pathParams: CloudforceOnePriorityUpdatePathParams;
} & FetcherExtraProps;

export const cloudforceOnePriorityUpdate = (variables: CloudforceOnePriorityUpdateVariables, signal?: AbortSignal) =>
  fetch<
    CloudforceOnePriorityUpdateResponse,
    CloudforceOnePriorityUpdateError,
    Schemas.CloudforceOneRequestsPriorityEdit,
    {},
    {},
    CloudforceOnePriorityUpdatePathParams
  >({
    url: '/accounts/{accountIdentifier}/cloudforce-one/requests/priority/{priorityIdentifer}',
    method: 'put',
    ...variables,
    signal
  });

export type CloudforceOneRequestQuotaPathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
};

export type CloudforceOneRequestQuotaError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOneRequestQuotaResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsQuota;
};

export type CloudforceOneRequestQuotaVariables = {
  pathParams: CloudforceOneRequestQuotaPathParams;
} & FetcherExtraProps;

export const cloudforceOneRequestQuota = (variables: CloudforceOneRequestQuotaVariables, signal?: AbortSignal) =>
  fetch<
    CloudforceOneRequestQuotaResponse,
    CloudforceOneRequestQuotaError,
    undefined,
    {},
    {},
    CloudforceOneRequestQuotaPathParams
  >({ url: '/accounts/{accountIdentifier}/cloudforce-one/requests/quota', method: 'get', ...variables, signal });

export type CloudforceOneRequestTypesPathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
};

export type CloudforceOneRequestTypesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOneRequestTypesResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsRequestTypes;
};

export type CloudforceOneRequestTypesVariables = {
  pathParams: CloudforceOneRequestTypesPathParams;
} & FetcherExtraProps;

export const cloudforceOneRequestTypes = (variables: CloudforceOneRequestTypesVariables, signal?: AbortSignal) =>
  fetch<
    CloudforceOneRequestTypesResponse,
    CloudforceOneRequestTypesError,
    undefined,
    {},
    {},
    CloudforceOneRequestTypesPathParams
  >({ url: '/accounts/{accountIdentifier}/cloudforce-one/requests/types', method: 'get', ...variables, signal });

export type CloudforceOneRequestDeletePathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
  requestIdentifier: Schemas.CloudforceOneRequestsUuid;
};

export type CloudforceOneRequestDeleteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOneRequestDeleteVariables = {
  pathParams: CloudforceOneRequestDeletePathParams;
} & FetcherExtraProps;

export const cloudforceOneRequestDelete = (variables: CloudforceOneRequestDeleteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.CloudforceOneRequestsApiResponseCommon,
    CloudforceOneRequestDeleteError,
    undefined,
    {},
    {},
    CloudforceOneRequestDeletePathParams
  >({
    url: '/accounts/{accountIdentifier}/cloudforce-one/requests/{requestIdentifier}',
    method: 'delete',
    ...variables,
    signal
  });

export type CloudforceOneRequestGetPathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
  requestIdentifier: Schemas.CloudforceOneRequestsUuid;
};

export type CloudforceOneRequestGetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOneRequestGetResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsRequestItem;
};

export type CloudforceOneRequestGetVariables = {
  pathParams: CloudforceOneRequestGetPathParams;
} & FetcherExtraProps;

export const cloudforceOneRequestGet = (variables: CloudforceOneRequestGetVariables, signal?: AbortSignal) =>
  fetch<
    CloudforceOneRequestGetResponse,
    CloudforceOneRequestGetError,
    undefined,
    {},
    {},
    CloudforceOneRequestGetPathParams
  >({
    url: '/accounts/{accountIdentifier}/cloudforce-one/requests/{requestIdentifier}',
    method: 'get',
    ...variables,
    signal
  });

export type CloudforceOneRequestUpdatePathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
  requestIdentifier: Schemas.CloudforceOneRequestsUuid;
};

export type CloudforceOneRequestUpdateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOneRequestUpdateResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsRequestItem;
};

export type CloudforceOneRequestUpdateVariables = {
  body?: Schemas.CloudforceOneRequestsRequestEdit;
  pathParams: CloudforceOneRequestUpdatePathParams;
} & FetcherExtraProps;

/**
 * Updating a request alters the request in the Cloudforce One queue. This API may be used to update any attributes of the request after the initial submission. Only fields that you choose to update need to be add to the request body.
 */
export const cloudforceOneRequestUpdate = (variables: CloudforceOneRequestUpdateVariables, signal?: AbortSignal) =>
  fetch<
    CloudforceOneRequestUpdateResponse,
    CloudforceOneRequestUpdateError,
    Schemas.CloudforceOneRequestsRequestEdit,
    {},
    {},
    CloudforceOneRequestUpdatePathParams
  >({
    url: '/accounts/{accountIdentifier}/cloudforce-one/requests/{requestIdentifier}',
    method: 'put',
    ...variables,
    signal
  });

export type CloudforceOneRequestAssetListPathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
  requestIdentifier: Schemas.CloudforceOneRequestsUuid;
};

export type CloudforceOneRequestAssetListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOneRequestAssetListResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsRequestAssetItem[];
};

export type CloudforceOneRequestAssetListVariables = {
  body: Schemas.CloudforceOneRequestsRequestAssetList;
  pathParams: CloudforceOneRequestAssetListPathParams;
} & FetcherExtraProps;

export const cloudforceOneRequestAssetList = (
  variables: CloudforceOneRequestAssetListVariables,
  signal?: AbortSignal
) =>
  fetch<
    CloudforceOneRequestAssetListResponse,
    CloudforceOneRequestAssetListError,
    Schemas.CloudforceOneRequestsRequestAssetList,
    {},
    {},
    CloudforceOneRequestAssetListPathParams
  >({
    url: '/accounts/{accountIdentifier}/cloudforce-one/requests/{requestIdentifier}/asset',
    method: 'post',
    ...variables,
    signal
  });

export type CloudforceOneRequestAssetNewPathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
  requestIdentifier: Schemas.CloudforceOneRequestsUuid;
};

export type CloudforceOneRequestAssetNewError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOneRequestAssetNewResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsRequestAssetItem;
};

export type CloudforceOneRequestAssetNewVariables = {
  body?: Schemas.CloudforceOneRequestsRequestAssetEdit;
  pathParams: CloudforceOneRequestAssetNewPathParams;
} & FetcherExtraProps;

export const cloudforceOneRequestAssetNew = (variables: CloudforceOneRequestAssetNewVariables, signal?: AbortSignal) =>
  fetch<
    CloudforceOneRequestAssetNewResponse,
    CloudforceOneRequestAssetNewError,
    Schemas.CloudforceOneRequestsRequestAssetEdit,
    {},
    {},
    CloudforceOneRequestAssetNewPathParams
  >({
    url: '/accounts/{accountIdentifier}/cloudforce-one/requests/{requestIdentifier}/asset/new',
    method: 'post',
    ...variables,
    signal
  });

export type CloudforceOneRequestAssetDeletePathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
  requestIdentifier: Schemas.CloudforceOneRequestsUuid;
  assetIdentifer: Schemas.CloudforceOneRequestsUuid;
};

export type CloudforceOneRequestAssetDeleteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOneRequestAssetDeleteVariables = {
  pathParams: CloudforceOneRequestAssetDeletePathParams;
} & FetcherExtraProps;

export const cloudforceOneRequestAssetDelete = (
  variables: CloudforceOneRequestAssetDeleteVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CloudforceOneRequestsApiResponseCommon,
    CloudforceOneRequestAssetDeleteError,
    undefined,
    {},
    {},
    CloudforceOneRequestAssetDeletePathParams
  >({
    url: '/accounts/{accountIdentifier}/cloudforce-one/requests/{requestIdentifier}/asset/{assetIdentifer}',
    method: 'delete',
    ...variables,
    signal
  });

export type CloudforceOneRequestAssetGetPathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
  requestIdentifier: Schemas.CloudforceOneRequestsUuid;
  assetIdentifer: Schemas.CloudforceOneRequestsUuid;
};

export type CloudforceOneRequestAssetGetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOneRequestAssetGetResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsRequestAssetItem[];
};

export type CloudforceOneRequestAssetGetVariables = {
  pathParams: CloudforceOneRequestAssetGetPathParams;
} & FetcherExtraProps;

export const cloudforceOneRequestAssetGet = (variables: CloudforceOneRequestAssetGetVariables, signal?: AbortSignal) =>
  fetch<
    CloudforceOneRequestAssetGetResponse,
    CloudforceOneRequestAssetGetError,
    undefined,
    {},
    {},
    CloudforceOneRequestAssetGetPathParams
  >({
    url: '/accounts/{accountIdentifier}/cloudforce-one/requests/{requestIdentifier}/asset/{assetIdentifer}',
    method: 'get',
    ...variables,
    signal
  });

export type CloudforceOneRequestAssetUpdatePathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
  requestIdentifier: Schemas.CloudforceOneRequestsUuid;
  assetIdentifer: Schemas.CloudforceOneRequestsUuid;
};

export type CloudforceOneRequestAssetUpdateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOneRequestAssetUpdateResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsRequestAssetItem;
};

export type CloudforceOneRequestAssetUpdateVariables = {
  body?: Schemas.CloudforceOneRequestsRequestAssetEdit;
  pathParams: CloudforceOneRequestAssetUpdatePathParams;
} & FetcherExtraProps;

export const cloudforceOneRequestAssetUpdate = (
  variables: CloudforceOneRequestAssetUpdateVariables,
  signal?: AbortSignal
) =>
  fetch<
    CloudforceOneRequestAssetUpdateResponse,
    CloudforceOneRequestAssetUpdateError,
    Schemas.CloudforceOneRequestsRequestAssetEdit,
    {},
    {},
    CloudforceOneRequestAssetUpdatePathParams
  >({
    url: '/accounts/{accountIdentifier}/cloudforce-one/requests/{requestIdentifier}/asset/{assetIdentifer}',
    method: 'put',
    ...variables,
    signal
  });

export type CloudforceOneRequestMessageListPathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
  requestIdentifier: Schemas.CloudforceOneRequestsUuid;
};

export type CloudforceOneRequestMessageListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOneRequestMessageListResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsRequestMessageItem[];
};

export type CloudforceOneRequestMessageListVariables = {
  body: Schemas.CloudforceOneRequestsRequestMessageList;
  pathParams: CloudforceOneRequestMessageListPathParams;
} & FetcherExtraProps;

export const cloudforceOneRequestMessageList = (
  variables: CloudforceOneRequestMessageListVariables,
  signal?: AbortSignal
) =>
  fetch<
    CloudforceOneRequestMessageListResponse,
    CloudforceOneRequestMessageListError,
    Schemas.CloudforceOneRequestsRequestMessageList,
    {},
    {},
    CloudforceOneRequestMessageListPathParams
  >({
    url: '/accounts/{accountIdentifier}/cloudforce-one/requests/{requestIdentifier}/message',
    method: 'post',
    ...variables,
    signal
  });

export type CloudforceOneRequestMessageNewPathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
  requestIdentifier: Schemas.CloudforceOneRequestsUuid;
};

export type CloudforceOneRequestMessageNewError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOneRequestMessageNewResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsRequestMessageItem;
};

export type CloudforceOneRequestMessageNewVariables = {
  body?: Schemas.CloudforceOneRequestsRequestMessageEdit;
  pathParams: CloudforceOneRequestMessageNewPathParams;
} & FetcherExtraProps;

export const cloudforceOneRequestMessageNew = (
  variables: CloudforceOneRequestMessageNewVariables,
  signal?: AbortSignal
) =>
  fetch<
    CloudforceOneRequestMessageNewResponse,
    CloudforceOneRequestMessageNewError,
    Schemas.CloudforceOneRequestsRequestMessageEdit,
    {},
    {},
    CloudforceOneRequestMessageNewPathParams
  >({
    url: '/accounts/{accountIdentifier}/cloudforce-one/requests/{requestIdentifier}/message/new',
    method: 'post',
    ...variables,
    signal
  });

export type CloudforceOneRequestMessageDeletePathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
  requestIdentifier: Schemas.CloudforceOneRequestsUuid;
  messageIdentifer: number;
};

export type CloudforceOneRequestMessageDeleteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOneRequestMessageDeleteVariables = {
  pathParams: CloudforceOneRequestMessageDeletePathParams;
} & FetcherExtraProps;

export const cloudforceOneRequestMessageDelete = (
  variables: CloudforceOneRequestMessageDeleteVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CloudforceOneRequestsApiResponseCommon,
    CloudforceOneRequestMessageDeleteError,
    undefined,
    {},
    {},
    CloudforceOneRequestMessageDeletePathParams
  >({
    url: '/accounts/{accountIdentifier}/cloudforce-one/requests/{requestIdentifier}/message/{messageIdentifer}',
    method: 'delete',
    ...variables,
    signal
  });

export type CloudforceOneRequestMessageUpdatePathParams = {
  accountIdentifier: Schemas.CloudforceOneRequestsIdentifier;
  requestIdentifier: Schemas.CloudforceOneRequestsUuid;
  messageIdentifer: number;
};

export type CloudforceOneRequestMessageUpdateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneRequestsApiResponseCommonFailure;
}>;

export type CloudforceOneRequestMessageUpdateResponse = Schemas.CloudforceOneRequestsApiResponseCommon & {
  result?: Schemas.CloudforceOneRequestsRequestMessageItem;
};

export type CloudforceOneRequestMessageUpdateVariables = {
  body?: Schemas.CloudforceOneRequestsRequestMessageEdit;
  pathParams: CloudforceOneRequestMessageUpdatePathParams;
} & FetcherExtraProps;

export const cloudforceOneRequestMessageUpdate = (
  variables: CloudforceOneRequestMessageUpdateVariables,
  signal?: AbortSignal
) =>
  fetch<
    CloudforceOneRequestMessageUpdateResponse,
    CloudforceOneRequestMessageUpdateError,
    Schemas.CloudforceOneRequestsRequestMessageEdit,
    {},
    {},
    CloudforceOneRequestMessageUpdatePathParams
  >({
    url: '/accounts/{accountIdentifier}/cloudforce-one/requests/{requestIdentifier}/message/{messageIdentifer}',
    method: 'put',
    ...variables,
    signal
  });

export type CustomPagesForAnAccountListCustomPagesPathParams = {
  accountIdentifier: Schemas.CustomPagesIdentifier;
};

export type CustomPagesForAnAccountListCustomPagesError = Fetcher.ErrorWrapper<{
  status: ClientErrorStatus;
  payload: Schemas.CustomPagesCustomPagesResponseCollection & Schemas.CustomPagesApiResponseCommonFailure;
}>;

export type CustomPagesForAnAccountListCustomPagesVariables = {
  pathParams: CustomPagesForAnAccountListCustomPagesPathParams;
} & FetcherExtraProps;

/**
 * Fetches all the custom pages at the account level.
 */
export const customPagesForAnAccountListCustomPages = (
  variables: CustomPagesForAnAccountListCustomPagesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CustomPagesCustomPagesResponseCollection,
    CustomPagesForAnAccountListCustomPagesError,
    undefined,
    {},
    {},
    CustomPagesForAnAccountListCustomPagesPathParams
  >({ url: '/accounts/{accountIdentifier}/custom_pages', method: 'get', ...variables, signal });

export type CustomPagesForAnAccountGetACustomPagePathParams = {
  identifier: Schemas.CustomPagesIdentifier;
  accountIdentifier: Schemas.CustomPagesIdentifier;
};

export type CustomPagesForAnAccountGetACustomPageError = Fetcher.ErrorWrapper<{
  status: ClientErrorStatus;
  payload: Schemas.CustomPagesCustomPagesResponseSingle & Schemas.CustomPagesApiResponseCommonFailure;
}>;

export type CustomPagesForAnAccountGetACustomPageVariables = {
  pathParams: CustomPagesForAnAccountGetACustomPagePathParams;
} & FetcherExtraProps;

/**
 * Fetches the details of a custom page.
 */
export const customPagesForAnAccountGetACustomPage = (
  variables: CustomPagesForAnAccountGetACustomPageVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CustomPagesCustomPagesResponseSingle,
    CustomPagesForAnAccountGetACustomPageError,
    undefined,
    {},
    {},
    CustomPagesForAnAccountGetACustomPagePathParams
  >({ url: '/accounts/{accountIdentifier}/custom_pages/{identifier}', method: 'get', ...variables, signal });

export type CustomPagesForAnAccountUpdateACustomPagePathParams = {
  identifier: Schemas.CustomPagesIdentifier;
  accountIdentifier: Schemas.CustomPagesIdentifier;
};

export type CustomPagesForAnAccountUpdateACustomPageError = Fetcher.ErrorWrapper<{
  status: ClientErrorStatus;
  payload: Schemas.CustomPagesCustomPagesResponseSingle & Schemas.CustomPagesApiResponseCommonFailure;
}>;

export type CustomPagesForAnAccountUpdateACustomPageRequestBody = {
  state: Schemas.CustomPagesState;
  url: Schemas.CustomPagesUrl;
};

export type CustomPagesForAnAccountUpdateACustomPageVariables = {
  body: CustomPagesForAnAccountUpdateACustomPageRequestBody;
  pathParams: CustomPagesForAnAccountUpdateACustomPagePathParams;
} & FetcherExtraProps;

/**
 * Updates the configuration of an existing custom page.
 */
export const customPagesForAnAccountUpdateACustomPage = (
  variables: CustomPagesForAnAccountUpdateACustomPageVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CustomPagesCustomPagesResponseSingle,
    CustomPagesForAnAccountUpdateACustomPageError,
    CustomPagesForAnAccountUpdateACustomPageRequestBody,
    {},
    {},
    CustomPagesForAnAccountUpdateACustomPagePathParams
  >({ url: '/accounts/{accountIdentifier}/custom_pages/{identifier}', method: 'put', ...variables, signal });

export type ListsGetBulkOperationStatusPathParams = {
  operationId: Schemas.ListsOperationId;
  accountIdentifier: Schemas.ListsIdentifier;
};

export type ListsGetBulkOperationStatusError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ListsBulkOperationResponseCollection & Schemas.ListsApiResponseCommonFailure;
}>;

export type ListsGetBulkOperationStatusVariables = {
  pathParams: ListsGetBulkOperationStatusPathParams;
} & FetcherExtraProps;

/**
 * Gets the current status of an asynchronous operation on a list.
 *
 * The `status` property can have one of the following values: `pending`, `running`, `completed`, or `failed`. If the status is `failed`, the `error` property will contain a message describing the error.
 */
export const listsGetBulkOperationStatus = (variables: ListsGetBulkOperationStatusVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ListsBulkOperationResponseCollection,
    ListsGetBulkOperationStatusError,
    undefined,
    {},
    {},
    ListsGetBulkOperationStatusPathParams
  >({
    url: '/accounts/{accountIdentifier}/rules/lists/bulk_operations/{operationId}',
    method: 'get',
    ...variables,
    signal
  });

export type ListsGetAListItemPathParams = {
  itemId: Schemas.ListsItemId;
  listId: Schemas.ListsListId;
  accountIdentifier: Schemas.ListsIdentifier;
};

export type ListsGetAListItemError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ListsItemResponseCollection & Schemas.ListsApiResponseCommonFailure;
}>;

export type ListsGetAListItemVariables = {
  pathParams: ListsGetAListItemPathParams;
} & FetcherExtraProps;

/**
 * Fetches a list item in the list.
 */
export const listsGetAListItem = (variables: ListsGetAListItemVariables, signal?: AbortSignal) =>
  fetch<Schemas.ListsItemResponseCollection, ListsGetAListItemError, undefined, {}, {}, ListsGetAListItemPathParams>({
    url: '/accounts/{accountIdentifier}/rules/lists/{listId}/items/{itemId}',
    method: 'get',
    ...variables,
    signal
  });

export type AccountDeletionPathParams = {
  accountId: string;
};

export type AccountDeletionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountDeletionVariables = {
  pathParams: AccountDeletionPathParams;
} & FetcherExtraProps;

/**
 * Delete a specific account (only available for tenant admins at this time). This is a permanent operation that will delete any zones or other resources under the account
 */
export const accountDeletion = (variables: AccountDeletionVariables, signal?: AbortSignal) =>
  fetch<Schemas.IamApiResponseSingleId, AccountDeletionError, undefined, {}, {}, AccountDeletionPathParams>({
    url: '/accounts/{accountId}',
    method: 'delete',
    ...variables,
    signal
  });

export type AccountsAccountDetailsPathParams = {
  accountId: Schemas.IamAccountIdentifier;
};

export type AccountsAccountDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountsAccountDetailsVariables = {
  pathParams: AccountsAccountDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get information about a specific account that you are a member of.
 */
export const accountsAccountDetails = (variables: AccountsAccountDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamResponseSingleAccount,
    AccountsAccountDetailsError,
    undefined,
    {},
    {},
    AccountsAccountDetailsPathParams
  >({ url: '/accounts/{accountId}', method: 'get', ...variables, signal });

export type AccountsUpdateAccountPathParams = {
  accountId: Schemas.IamAccountIdentifier;
};

export type AccountsUpdateAccountError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountsUpdateAccountVariables = {
  body?: Schemas.IamComponentsSchemasAccount;
  pathParams: AccountsUpdateAccountPathParams;
} & FetcherExtraProps;

/**
 * Update an existing account.
 */
export const accountsUpdateAccount = (variables: AccountsUpdateAccountVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamResponseSingleAccount,
    AccountsUpdateAccountError,
    Schemas.IamComponentsSchemasAccount,
    {},
    {},
    AccountsUpdateAccountPathParams
  >({ url: '/accounts/{accountId}', method: 'put', ...variables, signal });

export type SubmitAbuseReportPathParams = {
  /**
   * The account ID of the submitter.
   *
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   * @maxLength 32
   */
  accountId: string;
  /**
   * The report type to be submitted
   */
  reportType: Schemas.AbuseReportsReportType;
};

export type SubmitAbuseReportError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.AbuseReportsSubmitErrorResponse;
    }
  | {
      status: 500;
      payload: Schemas.AbuseReportsSubmitErrorResponse;
    }
>;

export type SubmitAbuseReportVariables = {
  body: Schemas.AbuseReportsSubmitReportRequest;
  pathParams: SubmitAbuseReportPathParams;
} & FetcherExtraProps;

export const submitAbuseReport = (variables: SubmitAbuseReportVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.AbuseReportsSubmitReportResponse,
    SubmitAbuseReportError,
    Schemas.AbuseReportsSubmitReportRequest,
    {},
    {},
    SubmitAbuseReportPathParams
  >({ url: '/accounts/{accountId}/abuse-reports/{reportType}', method: 'post', ...variables, signal });

export type AccessApplicationsListAccessApplicationsPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessApplicationsListAccessApplicationsQueryParams = {
  name?: string;
  domain?: string;
  aud?: string;
  search?: string;
};

export type AccessApplicationsListAccessApplicationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessApplicationsListAccessApplicationsVariables = {
  pathParams: AccessApplicationsListAccessApplicationsPathParams;
  queryParams?: AccessApplicationsListAccessApplicationsQueryParams;
} & FetcherExtraProps;

/**
 * Lists all Access applications in an account.
 */
export const accessApplicationsListAccessApplications = (
  variables: AccessApplicationsListAccessApplicationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessAppsComponentsSchemasResponseCollection,
    AccessApplicationsListAccessApplicationsError,
    undefined,
    {},
    AccessApplicationsListAccessApplicationsQueryParams,
    AccessApplicationsListAccessApplicationsPathParams
  >({ url: '/accounts/{accountId}/access/apps', method: 'get', ...variables, signal });

export type AccessApplicationsAddAnApplicationPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessApplicationsAddAnApplicationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessApplicationsAddAnApplicationResponse = Schemas.AccessAppsComponentsSchemasSingleResponse & {
  result?: Schemas.AccessAppResponse;
};

export type AccessApplicationsAddAnApplicationVariables = {
  body?: Schemas.AccessAppRequest;
  pathParams: AccessApplicationsAddAnApplicationPathParams;
} & FetcherExtraProps;

/**
 * Adds a new application to Access.
 */
export const accessApplicationsAddAnApplication = (
  variables: AccessApplicationsAddAnApplicationVariables,
  signal?: AbortSignal
) =>
  fetch<
    AccessApplicationsAddAnApplicationResponse,
    AccessApplicationsAddAnApplicationError,
    Schemas.AccessAppRequest,
    {},
    {},
    AccessApplicationsAddAnApplicationPathParams
  >({ url: '/accounts/{accountId}/access/apps', method: 'post', ...variables, signal });

export type AccessShortLivedCertificateCAsListShortLivedCertificateCAsPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessShortLivedCertificateCAsListShortLivedCertificateCAsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessShortLivedCertificateCAsListShortLivedCertificateCAsVariables = {
  pathParams: AccessShortLivedCertificateCAsListShortLivedCertificateCAsPathParams;
} & FetcherExtraProps;

/**
 * Lists short-lived certificate CAs and their public keys.
 */
export const accessShortLivedCertificateCAsListShortLivedCertificateCAs = (
  variables: AccessShortLivedCertificateCAsListShortLivedCertificateCAsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCaComponentsSchemasResponseCollection,
    AccessShortLivedCertificateCAsListShortLivedCertificateCAsError,
    undefined,
    {},
    {},
    AccessShortLivedCertificateCAsListShortLivedCertificateCAsPathParams
  >({ url: '/accounts/{accountId}/access/apps/ca', method: 'get', ...variables, signal });

export type AccessApplicationsDeleteAnAccessApplicationPathParams = {
  appId: Schemas.AccessAppId;
  accountId: Schemas.AccessIdentifier;
};

export type AccessApplicationsDeleteAnAccessApplicationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessApplicationsDeleteAnAccessApplicationVariables = {
  pathParams: AccessApplicationsDeleteAnAccessApplicationPathParams;
} & FetcherExtraProps;

/**
 * Deletes an application from Access.
 */
export const accessApplicationsDeleteAnAccessApplication = (
  variables: AccessApplicationsDeleteAnAccessApplicationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessIdResponse,
    AccessApplicationsDeleteAnAccessApplicationError,
    undefined,
    {},
    {},
    AccessApplicationsDeleteAnAccessApplicationPathParams
  >({ url: '/accounts/{accountId}/access/apps/{appId}', method: 'delete', ...variables, signal });

export type AccessApplicationsGetAnAccessApplicationPathParams = {
  appId: Schemas.AccessAppId;
  accountId: Schemas.AccessIdentifier;
};

export type AccessApplicationsGetAnAccessApplicationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessApplicationsGetAnAccessApplicationVariables = {
  pathParams: AccessApplicationsGetAnAccessApplicationPathParams;
} & FetcherExtraProps;

/**
 * Fetches information about an Access application.
 */
export const accessApplicationsGetAnAccessApplication = (
  variables: AccessApplicationsGetAnAccessApplicationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessAppsComponentsSchemasSingleResponse,
    AccessApplicationsGetAnAccessApplicationError,
    undefined,
    {},
    {},
    AccessApplicationsGetAnAccessApplicationPathParams
  >({ url: '/accounts/{accountId}/access/apps/{appId}', method: 'get', ...variables, signal });

export type AccessApplicationsUpdateAnAccessApplicationPathParams = {
  appId: Schemas.AccessAppId;
  accountId: Schemas.AccessIdentifier;
};

export type AccessApplicationsUpdateAnAccessApplicationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessApplicationsUpdateAnAccessApplicationResponse = Schemas.AccessAppsComponentsSchemasSingleResponse & {
  result?: Schemas.AccessAppResponse;
};

export type AccessApplicationsUpdateAnAccessApplicationVariables = {
  body?: Schemas.AccessAppRequest;
  pathParams: AccessApplicationsUpdateAnAccessApplicationPathParams;
} & FetcherExtraProps;

/**
 * Updates an Access application.
 */
export const accessApplicationsUpdateAnAccessApplication = (
  variables: AccessApplicationsUpdateAnAccessApplicationVariables,
  signal?: AbortSignal
) =>
  fetch<
    AccessApplicationsUpdateAnAccessApplicationResponse,
    AccessApplicationsUpdateAnAccessApplicationError,
    Schemas.AccessAppRequest,
    {},
    {},
    AccessApplicationsUpdateAnAccessApplicationPathParams
  >({ url: '/accounts/{accountId}/access/apps/{appId}', method: 'put', ...variables, signal });

export type AccessShortLivedCertificateCAsDeleteAShortLivedCertificateCaPathParams = {
  appId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessShortLivedCertificateCAsDeleteAShortLivedCertificateCaError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessShortLivedCertificateCAsDeleteAShortLivedCertificateCaVariables = {
  pathParams: AccessShortLivedCertificateCAsDeleteAShortLivedCertificateCaPathParams;
} & FetcherExtraProps;

/**
 * Deletes a short-lived certificate CA.
 */
export const accessShortLivedCertificateCAsDeleteAShortLivedCertificateCa = (
  variables: AccessShortLivedCertificateCAsDeleteAShortLivedCertificateCaVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessSchemasIdResponse,
    AccessShortLivedCertificateCAsDeleteAShortLivedCertificateCaError,
    undefined,
    {},
    {},
    AccessShortLivedCertificateCAsDeleteAShortLivedCertificateCaPathParams
  >({ url: '/accounts/{accountId}/access/apps/{appId}/ca', method: 'delete', ...variables, signal });

export type AccessShortLivedCertificateCAsGetAShortLivedCertificateCaPathParams = {
  appId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessShortLivedCertificateCAsGetAShortLivedCertificateCaError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessShortLivedCertificateCAsGetAShortLivedCertificateCaVariables = {
  pathParams: AccessShortLivedCertificateCAsGetAShortLivedCertificateCaPathParams;
} & FetcherExtraProps;

/**
 * Fetches a short-lived certificate CA and its public key.
 */
export const accessShortLivedCertificateCAsGetAShortLivedCertificateCa = (
  variables: AccessShortLivedCertificateCAsGetAShortLivedCertificateCaVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCaComponentsSchemasSingleResponse,
    AccessShortLivedCertificateCAsGetAShortLivedCertificateCaError,
    undefined,
    {},
    {},
    AccessShortLivedCertificateCAsGetAShortLivedCertificateCaPathParams
  >({ url: '/accounts/{accountId}/access/apps/{appId}/ca', method: 'get', ...variables, signal });

export type AccessShortLivedCertificateCAsCreateAShortLivedCertificateCaPathParams = {
  appId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessShortLivedCertificateCAsCreateAShortLivedCertificateCaError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessShortLivedCertificateCAsCreateAShortLivedCertificateCaVariables = {
  pathParams: AccessShortLivedCertificateCAsCreateAShortLivedCertificateCaPathParams;
} & FetcherExtraProps;

/**
 * Generates a new short-lived certificate CA and public key.
 */
export const accessShortLivedCertificateCAsCreateAShortLivedCertificateCa = (
  variables: AccessShortLivedCertificateCAsCreateAShortLivedCertificateCaVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCaComponentsSchemasSingleResponse,
    AccessShortLivedCertificateCAsCreateAShortLivedCertificateCaError,
    undefined,
    {},
    {},
    AccessShortLivedCertificateCAsCreateAShortLivedCertificateCaPathParams
  >({ url: '/accounts/{accountId}/access/apps/{appId}/ca', method: 'post', ...variables, signal });

export type AccessPoliciesListAccessAppPoliciesPathParams = {
  /**
   * The application ID.
   */
  appId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessPoliciesListAccessAppPoliciesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessPoliciesListAccessAppPoliciesVariables = {
  pathParams: AccessPoliciesListAccessAppPoliciesPathParams;
} & FetcherExtraProps;

/**
 * Lists Access policies configured for an application. Returns both exclusively scoped and reusable policies used by the application.
 */
export const accessPoliciesListAccessAppPolicies = (
  variables: AccessPoliciesListAccessAppPoliciesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessAppPoliciesComponentsSchemasResponseCollection,
    AccessPoliciesListAccessAppPoliciesError,
    undefined,
    {},
    {},
    AccessPoliciesListAccessAppPoliciesPathParams
  >({ url: '/accounts/{accountId}/access/apps/{appId}/policies', method: 'get', ...variables, signal });

export type AccessPoliciesCreateAnAccessPolicyPathParams = {
  /**
   * The application ID.
   */
  appId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessPoliciesCreateAnAccessPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessPoliciesCreateAnAccessPolicyVariables = {
  body?: Schemas.AccessAppPolicyRequest;
  pathParams: AccessPoliciesCreateAnAccessPolicyPathParams;
} & FetcherExtraProps;

/**
 * Creates a policy applying exclusive to a single application that defines the users or groups who can reach it. We recommend creating a reusable policy instead and subsequently referencing its ID in the application's 'policies' array.
 */
export const accessPoliciesCreateAnAccessPolicy = (
  variables: AccessPoliciesCreateAnAccessPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessAppPoliciesComponentsSchemasSingleResponse,
    AccessPoliciesCreateAnAccessPolicyError,
    Schemas.AccessAppPolicyRequest,
    {},
    {},
    AccessPoliciesCreateAnAccessPolicyPathParams
  >({ url: '/accounts/{accountId}/access/apps/{appId}/policies', method: 'post', ...variables, signal });

export type AccessPoliciesDeleteAnAccessPolicyPathParams = {
  /**
   * The application ID.
   */
  appId: Schemas.AccessUuid;
  /**
   * The policy ID.
   */
  policyId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessPoliciesDeleteAnAccessPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessPoliciesDeleteAnAccessPolicyVariables = {
  pathParams: AccessPoliciesDeleteAnAccessPolicyPathParams;
} & FetcherExtraProps;

/**
 * Deletes an Access policy specific to an application. To delete a reusable policy, use the /accounts/{account_id}/policies/{uid} endpoint.
 */
export const accessPoliciesDeleteAnAccessPolicy = (
  variables: AccessPoliciesDeleteAnAccessPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessIdResponse,
    AccessPoliciesDeleteAnAccessPolicyError,
    undefined,
    {},
    {},
    AccessPoliciesDeleteAnAccessPolicyPathParams
  >({ url: '/accounts/{accountId}/access/apps/{appId}/policies/{policyId}', method: 'delete', ...variables, signal });

export type AccessPoliciesGetAnAccessPolicyPathParams = {
  /**
   * The application ID.
   */
  appId: Schemas.AccessUuid;
  /**
   * The policy ID.
   */
  policyId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessPoliciesGetAnAccessPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessPoliciesGetAnAccessPolicyVariables = {
  pathParams: AccessPoliciesGetAnAccessPolicyPathParams;
} & FetcherExtraProps;

/**
 * Fetches a single Access policy configured for an application. Returns both exclusively owned and reusable policies used by the application.
 */
export const accessPoliciesGetAnAccessPolicy = (
  variables: AccessPoliciesGetAnAccessPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessAppPoliciesComponentsSchemasSingleResponse,
    AccessPoliciesGetAnAccessPolicyError,
    undefined,
    {},
    {},
    AccessPoliciesGetAnAccessPolicyPathParams
  >({ url: '/accounts/{accountId}/access/apps/{appId}/policies/{policyId}', method: 'get', ...variables, signal });

export type AccessPoliciesUpdateAnAccessPolicyPathParams = {
  /**
   * The application ID.
   */
  appId: Schemas.AccessUuid;
  /**
   * The policy ID.
   */
  policyId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessPoliciesUpdateAnAccessPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessPoliciesUpdateAnAccessPolicyVariables = {
  body?: Schemas.AccessAppPolicyRequest;
  pathParams: AccessPoliciesUpdateAnAccessPolicyPathParams;
} & FetcherExtraProps;

/**
 * Updates an Access policy specific to an application. To update a reusable policy, use the /accounts/{account_id}/policies/{uid} endpoint.
 */
export const accessPoliciesUpdateAnAccessPolicy = (
  variables: AccessPoliciesUpdateAnAccessPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessAppPoliciesComponentsSchemasSingleResponse,
    AccessPoliciesUpdateAnAccessPolicyError,
    Schemas.AccessAppPolicyRequest,
    {},
    {},
    AccessPoliciesUpdateAnAccessPolicyPathParams
  >({ url: '/accounts/{accountId}/access/apps/{appId}/policies/{policyId}', method: 'put', ...variables, signal });

export type AccessApplicationsRevokeServiceTokensPathParams = {
  appId: Schemas.AccessAppId;
  accountId: Schemas.AccessIdentifier;
};

export type AccessApplicationsRevokeServiceTokensError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessApplicationsRevokeServiceTokensVariables = {
  pathParams: AccessApplicationsRevokeServiceTokensPathParams;
} & FetcherExtraProps;

/**
 * Revokes all tokens issued for an application.
 */
export const accessApplicationsRevokeServiceTokens = (
  variables: AccessApplicationsRevokeServiceTokensVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessSchemasEmptyResponse,
    AccessApplicationsRevokeServiceTokensError,
    undefined,
    {},
    {},
    AccessApplicationsRevokeServiceTokensPathParams
  >({ url: '/accounts/{accountId}/access/apps/{appId}/revoke_tokens', method: 'post', ...variables, signal });

export type AccessApplicationsTestAccessPoliciesPathParams = {
  appId: Schemas.AccessAppId;
  accountId: Schemas.AccessIdentifier;
};

export type AccessApplicationsTestAccessPoliciesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessApplicationsTestAccessPoliciesVariables = {
  pathParams: AccessApplicationsTestAccessPoliciesPathParams;
} & FetcherExtraProps;

/**
 * Tests if a specific user has permission to access an application.
 */
export const accessApplicationsTestAccessPolicies = (
  variables: AccessApplicationsTestAccessPoliciesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessPolicyCheckResponse,
    AccessApplicationsTestAccessPoliciesError,
    undefined,
    {},
    {},
    AccessApplicationsTestAccessPoliciesPathParams
  >({ url: '/accounts/{accountId}/access/apps/{appId}/user_policy_checks', method: 'get', ...variables, signal });

export type AccessBookmarkApplicationsDeprecatedListBookmarkApplicationsPathParams = {
  accountId: Schemas.AccessComponentsSchemasIdentifier;
};

export type AccessBookmarkApplicationsDeprecatedListBookmarkApplicationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessBookmarkApplicationsDeprecatedListBookmarkApplicationsVariables = {
  pathParams: AccessBookmarkApplicationsDeprecatedListBookmarkApplicationsPathParams;
} & FetcherExtraProps;

/**
 * Lists Bookmark applications.
 */
export const accessBookmarkApplicationsDeprecatedListBookmarkApplications = (
  variables: AccessBookmarkApplicationsDeprecatedListBookmarkApplicationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessBookmarksComponentsSchemasResponseCollection,
    AccessBookmarkApplicationsDeprecatedListBookmarkApplicationsError,
    undefined,
    {},
    {},
    AccessBookmarkApplicationsDeprecatedListBookmarkApplicationsPathParams
  >({ url: '/accounts/{accountId}/access/bookmarks', method: 'get', ...variables, signal });

export type AccessBookmarkApplicationsDeprecatedDeleteABookmarkApplicationPathParams = {
  bookmarkId: Schemas.AccessUuid;
  accountId: Schemas.AccessComponentsSchemasIdentifier;
};

export type AccessBookmarkApplicationsDeprecatedDeleteABookmarkApplicationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessBookmarkApplicationsDeprecatedDeleteABookmarkApplicationVariables = {
  pathParams: AccessBookmarkApplicationsDeprecatedDeleteABookmarkApplicationPathParams;
} & FetcherExtraProps;

/**
 * Deletes a Bookmark application.
 */
export const accessBookmarkApplicationsDeprecatedDeleteABookmarkApplication = (
  variables: AccessBookmarkApplicationsDeprecatedDeleteABookmarkApplicationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessIdResponse,
    AccessBookmarkApplicationsDeprecatedDeleteABookmarkApplicationError,
    undefined,
    {},
    {},
    AccessBookmarkApplicationsDeprecatedDeleteABookmarkApplicationPathParams
  >({ url: '/accounts/{accountId}/access/bookmarks/{bookmarkId}', method: 'delete', ...variables, signal });

export type AccessBookmarkApplicationsDeprecatedGetABookmarkApplicationPathParams = {
  bookmarkId: Schemas.AccessUuid;
  accountId: Schemas.AccessComponentsSchemasIdentifier;
};

export type AccessBookmarkApplicationsDeprecatedGetABookmarkApplicationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessBookmarkApplicationsDeprecatedGetABookmarkApplicationVariables = {
  pathParams: AccessBookmarkApplicationsDeprecatedGetABookmarkApplicationPathParams;
} & FetcherExtraProps;

/**
 * Fetches a single Bookmark application.
 */
export const accessBookmarkApplicationsDeprecatedGetABookmarkApplication = (
  variables: AccessBookmarkApplicationsDeprecatedGetABookmarkApplicationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessBookmarksComponentsSchemasSingleResponse,
    AccessBookmarkApplicationsDeprecatedGetABookmarkApplicationError,
    undefined,
    {},
    {},
    AccessBookmarkApplicationsDeprecatedGetABookmarkApplicationPathParams
  >({ url: '/accounts/{accountId}/access/bookmarks/{bookmarkId}', method: 'get', ...variables, signal });

export type AccessBookmarkApplicationsDeprecatedCreateABookmarkApplicationPathParams = {
  bookmarkId: Schemas.AccessUuid;
  accountId: Schemas.AccessComponentsSchemasIdentifier;
};

export type AccessBookmarkApplicationsDeprecatedCreateABookmarkApplicationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessBookmarkApplicationsDeprecatedCreateABookmarkApplicationVariables = {
  pathParams: AccessBookmarkApplicationsDeprecatedCreateABookmarkApplicationPathParams;
} & FetcherExtraProps;

/**
 * Create a new Bookmark application.
 */
export const accessBookmarkApplicationsDeprecatedCreateABookmarkApplication = (
  variables: AccessBookmarkApplicationsDeprecatedCreateABookmarkApplicationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessBookmarksComponentsSchemasSingleResponse,
    AccessBookmarkApplicationsDeprecatedCreateABookmarkApplicationError,
    undefined,
    {},
    {},
    AccessBookmarkApplicationsDeprecatedCreateABookmarkApplicationPathParams
  >({ url: '/accounts/{accountId}/access/bookmarks/{bookmarkId}', method: 'post', ...variables, signal });

export type AccessBookmarkApplicationsDeprecatedUpdateABookmarkApplicationPathParams = {
  bookmarkId: Schemas.AccessUuid;
  accountId: Schemas.AccessComponentsSchemasIdentifier;
};

export type AccessBookmarkApplicationsDeprecatedUpdateABookmarkApplicationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessBookmarkApplicationsDeprecatedUpdateABookmarkApplicationVariables = {
  pathParams: AccessBookmarkApplicationsDeprecatedUpdateABookmarkApplicationPathParams;
} & FetcherExtraProps;

/**
 * Updates a configured Bookmark application.
 */
export const accessBookmarkApplicationsDeprecatedUpdateABookmarkApplication = (
  variables: AccessBookmarkApplicationsDeprecatedUpdateABookmarkApplicationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessBookmarksComponentsSchemasSingleResponse,
    AccessBookmarkApplicationsDeprecatedUpdateABookmarkApplicationError,
    undefined,
    {},
    {},
    AccessBookmarkApplicationsDeprecatedUpdateABookmarkApplicationPathParams
  >({ url: '/accounts/{accountId}/access/bookmarks/{bookmarkId}', method: 'put', ...variables, signal });

export type AccessMtlsAuthenticationListMtlsCertificatesPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessMtlsAuthenticationListMtlsCertificatesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessMtlsAuthenticationListMtlsCertificatesVariables = {
  pathParams: AccessMtlsAuthenticationListMtlsCertificatesPathParams;
} & FetcherExtraProps;

/**
 * Lists all mTLS root certificates.
 */
export const accessMtlsAuthenticationListMtlsCertificates = (
  variables: AccessMtlsAuthenticationListMtlsCertificatesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCertificatesComponentsSchemasResponseCollection,
    AccessMtlsAuthenticationListMtlsCertificatesError,
    undefined,
    {},
    {},
    AccessMtlsAuthenticationListMtlsCertificatesPathParams
  >({ url: '/accounts/{accountId}/access/certificates', method: 'get', ...variables, signal });

export type AccessMtlsAuthenticationAddAnMtlsCertificatePathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessMtlsAuthenticationAddAnMtlsCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessMtlsAuthenticationAddAnMtlsCertificateRequestBody = {
  associated_hostnames?: Schemas.AccessAssociatedHostnames;
  /**
     * The certificate content.
     *
     * @example -----BEGIN CERTIFICATE-----
    MIIGAjCCA+qgAwIBAgIJAI7kymlF7CWT...N4RI7KKB7nikiuUf8vhULKy5IX10
    DrUtmu/B
    -----END CERTIFICATE-----
     */
  certificate: string;
  name: Schemas.AccessCertificatesComponentsSchemasName;
};

export type AccessMtlsAuthenticationAddAnMtlsCertificateVariables = {
  body: AccessMtlsAuthenticationAddAnMtlsCertificateRequestBody;
  pathParams: AccessMtlsAuthenticationAddAnMtlsCertificatePathParams;
} & FetcherExtraProps;

/**
 * Adds a new mTLS root certificate to Access.
 */
export const accessMtlsAuthenticationAddAnMtlsCertificate = (
  variables: AccessMtlsAuthenticationAddAnMtlsCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCertificatesComponentsSchemasSingleResponse,
    AccessMtlsAuthenticationAddAnMtlsCertificateError,
    AccessMtlsAuthenticationAddAnMtlsCertificateRequestBody,
    {},
    {},
    AccessMtlsAuthenticationAddAnMtlsCertificatePathParams
  >({ url: '/accounts/{accountId}/access/certificates', method: 'post', ...variables, signal });

export type AccessMtlsAuthenticationListMtlsCertificatesHostnameSettingsPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessMtlsAuthenticationListMtlsCertificatesHostnameSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessMtlsAuthenticationListMtlsCertificatesHostnameSettingsVariables = {
  pathParams: AccessMtlsAuthenticationListMtlsCertificatesHostnameSettingsPathParams;
} & FetcherExtraProps;

/**
 * List all mTLS hostname settings for this account.
 */
export const accessMtlsAuthenticationListMtlsCertificatesHostnameSettings = (
  variables: AccessMtlsAuthenticationListMtlsCertificatesHostnameSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessResponseCollectionHostnames,
    AccessMtlsAuthenticationListMtlsCertificatesHostnameSettingsError,
    undefined,
    {},
    {},
    AccessMtlsAuthenticationListMtlsCertificatesHostnameSettingsPathParams
  >({ url: '/accounts/{accountId}/access/certificates/settings', method: 'get', ...variables, signal });

export type AccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsRequestBody = {
  settings: Schemas.AccessSettings[];
};

export type AccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsVariables = {
  body: AccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsRequestBody;
  pathParams: AccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsPathParams;
} & FetcherExtraProps;

/**
 * Updates an mTLS certificate's hostname settings.
 */
export const accessMtlsAuthenticationUpdateAnMtlsCertificateSettings = (
  variables: AccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessResponseCollectionHostnames,
    AccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsError,
    AccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsRequestBody,
    {},
    {},
    AccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsPathParams
  >({ url: '/accounts/{accountId}/access/certificates/settings', method: 'put', ...variables, signal });

export type AccessMtlsAuthenticationDeleteAnMtlsCertificatePathParams = {
  certificateId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessMtlsAuthenticationDeleteAnMtlsCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessMtlsAuthenticationDeleteAnMtlsCertificateVariables = {
  pathParams: AccessMtlsAuthenticationDeleteAnMtlsCertificatePathParams;
} & FetcherExtraProps;

/**
 * Deletes an mTLS certificate.
 */
export const accessMtlsAuthenticationDeleteAnMtlsCertificate = (
  variables: AccessMtlsAuthenticationDeleteAnMtlsCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessComponentsSchemasIdResponse,
    AccessMtlsAuthenticationDeleteAnMtlsCertificateError,
    undefined,
    {},
    {},
    AccessMtlsAuthenticationDeleteAnMtlsCertificatePathParams
  >({ url: '/accounts/{accountId}/access/certificates/{certificateId}', method: 'delete', ...variables, signal });

export type AccessMtlsAuthenticationGetAnMtlsCertificatePathParams = {
  certificateId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessMtlsAuthenticationGetAnMtlsCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessMtlsAuthenticationGetAnMtlsCertificateVariables = {
  pathParams: AccessMtlsAuthenticationGetAnMtlsCertificatePathParams;
} & FetcherExtraProps;

/**
 * Fetches a single mTLS certificate.
 */
export const accessMtlsAuthenticationGetAnMtlsCertificate = (
  variables: AccessMtlsAuthenticationGetAnMtlsCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCertificatesComponentsSchemasSingleResponse,
    AccessMtlsAuthenticationGetAnMtlsCertificateError,
    undefined,
    {},
    {},
    AccessMtlsAuthenticationGetAnMtlsCertificatePathParams
  >({ url: '/accounts/{accountId}/access/certificates/{certificateId}', method: 'get', ...variables, signal });

export type AccessMtlsAuthenticationUpdateAnMtlsCertificatePathParams = {
  certificateId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessMtlsAuthenticationUpdateAnMtlsCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessMtlsAuthenticationUpdateAnMtlsCertificateRequestBody = {
  associated_hostnames: Schemas.AccessAssociatedHostnames;
  name?: Schemas.AccessCertificatesComponentsSchemasName;
};

export type AccessMtlsAuthenticationUpdateAnMtlsCertificateVariables = {
  body: AccessMtlsAuthenticationUpdateAnMtlsCertificateRequestBody;
  pathParams: AccessMtlsAuthenticationUpdateAnMtlsCertificatePathParams;
} & FetcherExtraProps;

/**
 * Updates a configured mTLS certificate.
 */
export const accessMtlsAuthenticationUpdateAnMtlsCertificate = (
  variables: AccessMtlsAuthenticationUpdateAnMtlsCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCertificatesComponentsSchemasSingleResponse,
    AccessMtlsAuthenticationUpdateAnMtlsCertificateError,
    AccessMtlsAuthenticationUpdateAnMtlsCertificateRequestBody,
    {},
    {},
    AccessMtlsAuthenticationUpdateAnMtlsCertificatePathParams
  >({ url: '/accounts/{accountId}/access/certificates/{certificateId}', method: 'put', ...variables, signal });

export type AccessCustomPagesListCustomPagesPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessCustomPagesListCustomPagesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessCustomPagesListCustomPagesVariables = {
  pathParams: AccessCustomPagesListCustomPagesPathParams;
} & FetcherExtraProps;

/**
 * List custom pages
 */
export const accessCustomPagesListCustomPages = (
  variables: AccessCustomPagesListCustomPagesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCustomPagesComponentsSchemasResponseCollection,
    AccessCustomPagesListCustomPagesError,
    undefined,
    {},
    {},
    AccessCustomPagesListCustomPagesPathParams
  >({ url: '/accounts/{accountId}/access/custom_pages', method: 'get', ...variables, signal });

export type AccessCustomPagesCreateACustomPagePathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessCustomPagesCreateACustomPageError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessCustomPagesCreateACustomPageVariables = {
  body: Schemas.AccessCustomPage;
  pathParams: AccessCustomPagesCreateACustomPagePathParams;
} & FetcherExtraProps;

/**
 * Create a custom page
 */
export const accessCustomPagesCreateACustomPage = (
  variables: AccessCustomPagesCreateACustomPageVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessSingleResponseWithoutHtml,
    AccessCustomPagesCreateACustomPageError,
    Schemas.AccessCustomPage,
    {},
    {},
    AccessCustomPagesCreateACustomPagePathParams
  >({ url: '/accounts/{accountId}/access/custom_pages', method: 'post', ...variables, signal });

export type AccessCustomPagesDeleteACustomPagePathParams = {
  customPageId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessCustomPagesDeleteACustomPageError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessCustomPagesDeleteACustomPageVariables = {
  pathParams: AccessCustomPagesDeleteACustomPagePathParams;
} & FetcherExtraProps;

/**
 * Delete a custom page
 */
export const accessCustomPagesDeleteACustomPage = (
  variables: AccessCustomPagesDeleteACustomPageVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessComponentsSchemasIdResponse,
    AccessCustomPagesDeleteACustomPageError,
    undefined,
    {},
    {},
    AccessCustomPagesDeleteACustomPagePathParams
  >({ url: '/accounts/{accountId}/access/custom_pages/{customPageId}', method: 'delete', ...variables, signal });

export type AccessCustomPagesGetACustomPagePathParams = {
  customPageId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessCustomPagesGetACustomPageError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessCustomPagesGetACustomPageVariables = {
  pathParams: AccessCustomPagesGetACustomPagePathParams;
} & FetcherExtraProps;

/**
 * Fetches a custom page and also returns its HTML.
 */
export const accessCustomPagesGetACustomPage = (
  variables: AccessCustomPagesGetACustomPageVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCustomPagesComponentsSchemasSingleResponse,
    AccessCustomPagesGetACustomPageError,
    undefined,
    {},
    {},
    AccessCustomPagesGetACustomPagePathParams
  >({ url: '/accounts/{accountId}/access/custom_pages/{customPageId}', method: 'get', ...variables, signal });

export type AccessCustomPagesUpdateACustomPagePathParams = {
  customPageId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessCustomPagesUpdateACustomPageError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessCustomPagesUpdateACustomPageVariables = {
  body: Schemas.AccessCustomPage;
  pathParams: AccessCustomPagesUpdateACustomPagePathParams;
} & FetcherExtraProps;

/**
 * Update a custom page
 */
export const accessCustomPagesUpdateACustomPage = (
  variables: AccessCustomPagesUpdateACustomPageVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessSingleResponseWithoutHtml,
    AccessCustomPagesUpdateACustomPageError,
    Schemas.AccessCustomPage,
    {},
    {},
    AccessCustomPagesUpdateACustomPagePathParams
  >({ url: '/accounts/{accountId}/access/custom_pages/{customPageId}', method: 'put', ...variables, signal });

export type AccessGatewayCaListSSHCaPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessGatewayCaListSSHCaError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessGatewayCaListSSHCaVariables = {
  pathParams: AccessGatewayCaListSSHCaPathParams;
} & FetcherExtraProps;

/**
 * Lists SSH Certificate Authorities (CA).
 */
export const accessGatewayCaListSSHCa = (variables: AccessGatewayCaListSSHCaVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.AccessGatewayCaComponentsSchemasResponseCollection,
    AccessGatewayCaListSSHCaError,
    undefined,
    {},
    {},
    AccessGatewayCaListSSHCaPathParams
  >({ url: '/accounts/{accountId}/access/gateway_ca', method: 'get', ...variables, signal });

export type AccessGatewayCaAddAnSSHCaPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessGatewayCaAddAnSSHCaError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessGatewayCaAddAnSSHCaVariables = {
  pathParams: AccessGatewayCaAddAnSSHCaPathParams;
} & FetcherExtraProps;

/**
 * Adds a new SSH Certificate Authority (CA).
 */
export const accessGatewayCaAddAnSSHCa = (variables: AccessGatewayCaAddAnSSHCaVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.AccessGatewayCaComponentsSchemasSingleResponse,
    AccessGatewayCaAddAnSSHCaError,
    undefined,
    {},
    {},
    AccessGatewayCaAddAnSSHCaPathParams
  >({ url: '/accounts/{accountId}/access/gateway_ca', method: 'post', ...variables, signal });

export type AccessGatewayCaDeleteAnSSHCaPathParams = {
  certificateId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessGatewayCaDeleteAnSSHCaError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessGatewayCaDeleteAnSSHCaVariables = {
  pathParams: AccessGatewayCaDeleteAnSSHCaPathParams;
} & FetcherExtraProps;

/**
 * Deletes an SSH Certificate Authority.
 */
export const accessGatewayCaDeleteAnSSHCa = (variables: AccessGatewayCaDeleteAnSSHCaVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.AccessIdResponse,
    AccessGatewayCaDeleteAnSSHCaError,
    undefined,
    {},
    {},
    AccessGatewayCaDeleteAnSSHCaPathParams
  >({ url: '/accounts/{accountId}/access/gateway_ca/{certificateId}', method: 'delete', ...variables, signal });

export type AccessGroupsListAccessGroupsPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessGroupsListAccessGroupsQueryParams = {
  name?: string;
  search?: string;
};

export type AccessGroupsListAccessGroupsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessGroupsListAccessGroupsVariables = {
  pathParams: AccessGroupsListAccessGroupsPathParams;
  queryParams?: AccessGroupsListAccessGroupsQueryParams;
} & FetcherExtraProps;

/**
 * Lists all Access groups.
 */
export const accessGroupsListAccessGroups = (variables: AccessGroupsListAccessGroupsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.AccessSchemasResponseCollection,
    AccessGroupsListAccessGroupsError,
    undefined,
    {},
    AccessGroupsListAccessGroupsQueryParams,
    AccessGroupsListAccessGroupsPathParams
  >({ url: '/accounts/{accountId}/access/groups', method: 'get', ...variables, signal });

export type AccessGroupsCreateAnAccessGroupPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessGroupsCreateAnAccessGroupError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessGroupsCreateAnAccessGroupRequestBody = {
  exclude?: Schemas.AccessExclude;
  include: Schemas.AccessInclude;
  is_default?: Schemas.AccessIsDefault;
  name: Schemas.AccessGroupsComponentsSchemasName;
  require?: Schemas.AccessRequire;
};

export type AccessGroupsCreateAnAccessGroupVariables = {
  body: AccessGroupsCreateAnAccessGroupRequestBody;
  pathParams: AccessGroupsCreateAnAccessGroupPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Access group.
 */
export const accessGroupsCreateAnAccessGroup = (
  variables: AccessGroupsCreateAnAccessGroupVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessGroupsComponentsSchemasSingleResponse,
    AccessGroupsCreateAnAccessGroupError,
    AccessGroupsCreateAnAccessGroupRequestBody,
    {},
    {},
    AccessGroupsCreateAnAccessGroupPathParams
  >({ url: '/accounts/{accountId}/access/groups', method: 'post', ...variables, signal });

export type AccessGroupsDeleteAnAccessGroupPathParams = {
  groupId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessGroupsDeleteAnAccessGroupError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessGroupsDeleteAnAccessGroupVariables = {
  pathParams: AccessGroupsDeleteAnAccessGroupPathParams;
} & FetcherExtraProps;

/**
 * Deletes an Access group.
 */
export const accessGroupsDeleteAnAccessGroup = (
  variables: AccessGroupsDeleteAnAccessGroupVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessIdResponse,
    AccessGroupsDeleteAnAccessGroupError,
    undefined,
    {},
    {},
    AccessGroupsDeleteAnAccessGroupPathParams
  >({ url: '/accounts/{accountId}/access/groups/{groupId}', method: 'delete', ...variables, signal });

export type AccessGroupsGetAnAccessGroupPathParams = {
  groupId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessGroupsGetAnAccessGroupError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessGroupsGetAnAccessGroupVariables = {
  pathParams: AccessGroupsGetAnAccessGroupPathParams;
} & FetcherExtraProps;

/**
 * Fetches a single Access group.
 */
export const accessGroupsGetAnAccessGroup = (variables: AccessGroupsGetAnAccessGroupVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.AccessGroupsComponentsSchemasSingleResponse,
    AccessGroupsGetAnAccessGroupError,
    undefined,
    {},
    {},
    AccessGroupsGetAnAccessGroupPathParams
  >({ url: '/accounts/{accountId}/access/groups/{groupId}', method: 'get', ...variables, signal });

export type AccessGroupsUpdateAnAccessGroupPathParams = {
  groupId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessGroupsUpdateAnAccessGroupError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessGroupsUpdateAnAccessGroupRequestBody = {
  exclude?: Schemas.AccessExclude;
  include: Schemas.AccessInclude;
  is_default?: Schemas.AccessIsDefault;
  name: Schemas.AccessGroupsComponentsSchemasName;
  require?: Schemas.AccessRequire;
};

export type AccessGroupsUpdateAnAccessGroupVariables = {
  body: AccessGroupsUpdateAnAccessGroupRequestBody;
  pathParams: AccessGroupsUpdateAnAccessGroupPathParams;
} & FetcherExtraProps;

/**
 * Updates a configured Access group.
 */
export const accessGroupsUpdateAnAccessGroup = (
  variables: AccessGroupsUpdateAnAccessGroupVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessGroupsComponentsSchemasSingleResponse,
    AccessGroupsUpdateAnAccessGroupError,
    AccessGroupsUpdateAnAccessGroupRequestBody,
    {},
    {},
    AccessGroupsUpdateAnAccessGroupPathParams
  >({ url: '/accounts/{accountId}/access/groups/{groupId}', method: 'put', ...variables, signal });

export type AccessIdentityProvidersListAccessIdentityProvidersPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessIdentityProvidersListAccessIdentityProvidersQueryParams = {
  /**
   * @example true
   */
  scim_enabled?: string;
};

export type AccessIdentityProvidersListAccessIdentityProvidersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessIdentityProvidersListAccessIdentityProvidersVariables = {
  pathParams: AccessIdentityProvidersListAccessIdentityProvidersPathParams;
  queryParams?: AccessIdentityProvidersListAccessIdentityProvidersQueryParams;
} & FetcherExtraProps;

/**
 * Lists all configured identity providers.
 */
export const accessIdentityProvidersListAccessIdentityProviders = (
  variables: AccessIdentityProvidersListAccessIdentityProvidersVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessResponseCollection,
    AccessIdentityProvidersListAccessIdentityProvidersError,
    undefined,
    {},
    AccessIdentityProvidersListAccessIdentityProvidersQueryParams,
    AccessIdentityProvidersListAccessIdentityProvidersPathParams
  >({ url: '/accounts/{accountId}/access/identity_providers', method: 'get', ...variables, signal });

export type AccessIdentityProvidersAddAnAccessIdentityProviderPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessIdentityProvidersAddAnAccessIdentityProviderError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessIdentityProvidersAddAnAccessIdentityProviderVariables = {
  body?: Schemas.AccessIdentityProviders;
  pathParams: AccessIdentityProvidersAddAnAccessIdentityProviderPathParams;
} & FetcherExtraProps;

/**
 * Adds a new identity provider to Access.
 */
export const accessIdentityProvidersAddAnAccessIdentityProvider = (
  variables: AccessIdentityProvidersAddAnAccessIdentityProviderVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessComponentsSchemasSingleResponse,
    AccessIdentityProvidersAddAnAccessIdentityProviderError,
    Schemas.AccessIdentityProviders,
    {},
    {},
    AccessIdentityProvidersAddAnAccessIdentityProviderPathParams
  >({ url: '/accounts/{accountId}/access/identity_providers', method: 'post', ...variables, signal });

export type AccessIdentityProvidersDeleteAnAccessIdentityProviderPathParams = {
  identityProviderId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessIdentityProvidersDeleteAnAccessIdentityProviderError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessIdentityProvidersDeleteAnAccessIdentityProviderVariables = {
  pathParams: AccessIdentityProvidersDeleteAnAccessIdentityProviderPathParams;
} & FetcherExtraProps;

/**
 * Deletes an identity provider from Access.
 */
export const accessIdentityProvidersDeleteAnAccessIdentityProvider = (
  variables: AccessIdentityProvidersDeleteAnAccessIdentityProviderVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessIdResponse,
    AccessIdentityProvidersDeleteAnAccessIdentityProviderError,
    undefined,
    {},
    {},
    AccessIdentityProvidersDeleteAnAccessIdentityProviderPathParams
  >({
    url: '/accounts/{accountId}/access/identity_providers/{identityProviderId}',
    method: 'delete',
    ...variables,
    signal
  });

export type AccessIdentityProvidersGetAnAccessIdentityProviderPathParams = {
  identityProviderId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessIdentityProvidersGetAnAccessIdentityProviderError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessIdentityProvidersGetAnAccessIdentityProviderVariables = {
  pathParams: AccessIdentityProvidersGetAnAccessIdentityProviderPathParams;
} & FetcherExtraProps;

/**
 * Fetches a configured identity provider.
 */
export const accessIdentityProvidersGetAnAccessIdentityProvider = (
  variables: AccessIdentityProvidersGetAnAccessIdentityProviderVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessComponentsSchemasSingleResponse,
    AccessIdentityProvidersGetAnAccessIdentityProviderError,
    undefined,
    {},
    {},
    AccessIdentityProvidersGetAnAccessIdentityProviderPathParams
  >({
    url: '/accounts/{accountId}/access/identity_providers/{identityProviderId}',
    method: 'get',
    ...variables,
    signal
  });

export type AccessIdentityProvidersUpdateAnAccessIdentityProviderPathParams = {
  identityProviderId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessIdentityProvidersUpdateAnAccessIdentityProviderError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessIdentityProvidersUpdateAnAccessIdentityProviderVariables = {
  body?: Schemas.AccessIdentityProviders;
  pathParams: AccessIdentityProvidersUpdateAnAccessIdentityProviderPathParams;
} & FetcherExtraProps;

/**
 * Updates a configured identity provider.
 */
export const accessIdentityProvidersUpdateAnAccessIdentityProvider = (
  variables: AccessIdentityProvidersUpdateAnAccessIdentityProviderVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessComponentsSchemasSingleResponse,
    AccessIdentityProvidersUpdateAnAccessIdentityProviderError,
    Schemas.AccessIdentityProviders,
    {},
    {},
    AccessIdentityProvidersUpdateAnAccessIdentityProviderPathParams
  >({
    url: '/accounts/{accountId}/access/identity_providers/{identityProviderId}',
    method: 'put',
    ...variables,
    signal
  });

export type AccessKeyConfigurationGetTheAccessKeyConfigurationPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessKeyConfigurationGetTheAccessKeyConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessKeyConfigurationGetTheAccessKeyConfigurationVariables = {
  pathParams: AccessKeyConfigurationGetTheAccessKeyConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Gets the Access key rotation settings for an account.
 */
export const accessKeyConfigurationGetTheAccessKeyConfiguration = (
  variables: AccessKeyConfigurationGetTheAccessKeyConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessKeysComponentsSchemasSingleResponse,
    AccessKeyConfigurationGetTheAccessKeyConfigurationError,
    undefined,
    {},
    {},
    AccessKeyConfigurationGetTheAccessKeyConfigurationPathParams
  >({ url: '/accounts/{accountId}/access/keys', method: 'get', ...variables, signal });

export type AccessKeyConfigurationUpdateTheAccessKeyConfigurationPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessKeyConfigurationUpdateTheAccessKeyConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessKeyConfigurationUpdateTheAccessKeyConfigurationRequestBody = {
  key_rotation_interval_days: Schemas.AccessKeyRotationIntervalDays;
};

export type AccessKeyConfigurationUpdateTheAccessKeyConfigurationVariables = {
  body: AccessKeyConfigurationUpdateTheAccessKeyConfigurationRequestBody;
  pathParams: AccessKeyConfigurationUpdateTheAccessKeyConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Updates the Access key rotation settings for an account.
 */
export const accessKeyConfigurationUpdateTheAccessKeyConfiguration = (
  variables: AccessKeyConfigurationUpdateTheAccessKeyConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessKeysComponentsSchemasSingleResponse,
    AccessKeyConfigurationUpdateTheAccessKeyConfigurationError,
    AccessKeyConfigurationUpdateTheAccessKeyConfigurationRequestBody,
    {},
    {},
    AccessKeyConfigurationUpdateTheAccessKeyConfigurationPathParams
  >({ url: '/accounts/{accountId}/access/keys', method: 'put', ...variables, signal });

export type AccessKeyConfigurationRotateAccessKeysPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessKeyConfigurationRotateAccessKeysError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessKeyConfigurationRotateAccessKeysVariables = {
  pathParams: AccessKeyConfigurationRotateAccessKeysPathParams;
} & FetcherExtraProps;

/**
 * Perfoms a key rotation for an account.
 */
export const accessKeyConfigurationRotateAccessKeys = (
  variables: AccessKeyConfigurationRotateAccessKeysVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessKeysComponentsSchemasSingleResponse,
    AccessKeyConfigurationRotateAccessKeysError,
    undefined,
    {},
    {},
    AccessKeyConfigurationRotateAccessKeysPathParams
  >({ url: '/accounts/{accountId}/access/keys/rotate', method: 'post', ...variables, signal });

export type AccessAuthenticationLogsGetAccessAuthenticationLogsPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessAuthenticationLogsGetAccessAuthenticationLogsQueryParams = {
  /**
   * The maximum number of log entries to retrieve.
   *
   * @default 25
   */
  limit?: number;
  /**
   * The chronological sorting order for the logs.
   *
   * @default desc
   */
  direction?: 'desc' | 'asc';
  /**
   * The earliest event timestamp to query.
   *
   * @example 2020-07-01T05:20:00Z
   * @format date-time
   */
  since?: string;
  /**
   * The latest event timestamp to query.
   *
   * @example 2020-10-01T05:20:00Z
   * @format date-time
   */
  until?: string;
};

export type AccessAuthenticationLogsGetAccessAuthenticationLogsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessAuthenticationLogsGetAccessAuthenticationLogsVariables = {
  pathParams: AccessAuthenticationLogsGetAccessAuthenticationLogsPathParams;
  queryParams?: AccessAuthenticationLogsGetAccessAuthenticationLogsQueryParams;
} & FetcherExtraProps;

/**
 * Gets a list of Access authentication audit logs for an account.
 */
export const accessAuthenticationLogsGetAccessAuthenticationLogs = (
  variables: AccessAuthenticationLogsGetAccessAuthenticationLogsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessAccessRequestsComponentsSchemasResponseCollection,
    AccessAuthenticationLogsGetAccessAuthenticationLogsError,
    undefined,
    {},
    AccessAuthenticationLogsGetAccessAuthenticationLogsQueryParams,
    AccessAuthenticationLogsGetAccessAuthenticationLogsPathParams
  >({ url: '/accounts/{accountId}/access/logs/access_requests', method: 'get', ...variables, signal });

export type ZeroTrustOrganizationGetYourZeroTrustOrganizationPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type ZeroTrustOrganizationGetYourZeroTrustOrganizationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZeroTrustOrganizationGetYourZeroTrustOrganizationVariables = {
  pathParams: ZeroTrustOrganizationGetYourZeroTrustOrganizationPathParams;
} & FetcherExtraProps;

/**
 * Returns the configuration for your Zero Trust organization.
 */
export const zeroTrustOrganizationGetYourZeroTrustOrganization = (
  variables: ZeroTrustOrganizationGetYourZeroTrustOrganizationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessSingleResponse,
    ZeroTrustOrganizationGetYourZeroTrustOrganizationError,
    undefined,
    {},
    {},
    ZeroTrustOrganizationGetYourZeroTrustOrganizationPathParams
  >({ url: '/accounts/{accountId}/access/organizations', method: 'get', ...variables, signal });

export type ZeroTrustOrganizationCreateYourZeroTrustOrganizationPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type ZeroTrustOrganizationCreateYourZeroTrustOrganizationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZeroTrustOrganizationCreateYourZeroTrustOrganizationRequestBody = {
  allow_authenticate_via_warp?: Schemas.AccessAllowAuthenticateViaWarp;
  auth_domain: Schemas.AccessAuthDomain;
  auto_redirect_to_identity?: Schemas.AccessAutoRedirectToIdentity;
  is_ui_read_only?: Schemas.AccessIsUiReadOnly;
  login_design?: Schemas.AccessLoginDesign;
  name: Schemas.AccessName;
  session_duration?: Schemas.AccessSessionDuration;
  ui_read_only_toggle_reason?: Schemas.AccessUiReadOnlyToggleReason;
  user_seat_expiration_inactive_time?: Schemas.AccessUserSeatExpirationInactiveTime;
  warp_auth_session_duration?: Schemas.AccessWarpAuthSessionDuration;
};

export type ZeroTrustOrganizationCreateYourZeroTrustOrganizationVariables = {
  body: ZeroTrustOrganizationCreateYourZeroTrustOrganizationRequestBody;
  pathParams: ZeroTrustOrganizationCreateYourZeroTrustOrganizationPathParams;
} & FetcherExtraProps;

/**
 * Sets up a Zero Trust organization for your account.
 */
export const zeroTrustOrganizationCreateYourZeroTrustOrganization = (
  variables: ZeroTrustOrganizationCreateYourZeroTrustOrganizationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessSingleResponse,
    ZeroTrustOrganizationCreateYourZeroTrustOrganizationError,
    ZeroTrustOrganizationCreateYourZeroTrustOrganizationRequestBody,
    {},
    {},
    ZeroTrustOrganizationCreateYourZeroTrustOrganizationPathParams
  >({ url: '/accounts/{accountId}/access/organizations', method: 'post', ...variables, signal });

export type ZeroTrustOrganizationUpdateYourZeroTrustOrganizationPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type ZeroTrustOrganizationUpdateYourZeroTrustOrganizationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZeroTrustOrganizationUpdateYourZeroTrustOrganizationRequestBody = {
  allow_authenticate_via_warp?: Schemas.AccessAllowAuthenticateViaWarp;
  auth_domain?: Schemas.AccessAuthDomain;
  auto_redirect_to_identity?: Schemas.AccessAutoRedirectToIdentity;
  custom_pages?: Schemas.AccessCustomPages;
  is_ui_read_only?: Schemas.AccessIsUiReadOnly;
  login_design?: Schemas.AccessLoginDesign;
  name?: Schemas.AccessName;
  session_duration?: Schemas.AccessSessionDuration;
  ui_read_only_toggle_reason?: Schemas.AccessUiReadOnlyToggleReason;
  user_seat_expiration_inactive_time?: Schemas.AccessUserSeatExpirationInactiveTime;
  warp_auth_session_duration?: Schemas.AccessWarpAuthSessionDuration;
};

export type ZeroTrustOrganizationUpdateYourZeroTrustOrganizationVariables = {
  body?: ZeroTrustOrganizationUpdateYourZeroTrustOrganizationRequestBody;
  pathParams: ZeroTrustOrganizationUpdateYourZeroTrustOrganizationPathParams;
} & FetcherExtraProps;

/**
 * Updates the configuration for your Zero Trust organization.
 */
export const zeroTrustOrganizationUpdateYourZeroTrustOrganization = (
  variables: ZeroTrustOrganizationUpdateYourZeroTrustOrganizationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessSingleResponse,
    ZeroTrustOrganizationUpdateYourZeroTrustOrganizationError,
    ZeroTrustOrganizationUpdateYourZeroTrustOrganizationRequestBody,
    {},
    {},
    ZeroTrustOrganizationUpdateYourZeroTrustOrganizationPathParams
  >({ url: '/accounts/{accountId}/access/organizations', method: 'put', ...variables, signal });

export type ZeroTrustOrganizationGetYourZeroTrustOrganizationDohSettingsPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type ZeroTrustOrganizationGetYourZeroTrustOrganizationDohSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZeroTrustOrganizationGetYourZeroTrustOrganizationDohSettingsResponse =
  Schemas.AccessSchemasSingleResponse & {
    result?: {
      /**
       * The duration the DoH JWT is valid for. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.  Note that the maximum duration for this setting is the same as the key rotation period on the account.
       *
       * @example 800h
       */
      doh_jwt_duration?: string;
    };
  };

export type ZeroTrustOrganizationGetYourZeroTrustOrganizationDohSettingsVariables = {
  pathParams: ZeroTrustOrganizationGetYourZeroTrustOrganizationDohSettingsPathParams;
} & FetcherExtraProps;

/**
 * Returns the DoH settings for your Zero Trust organization.
 */
export const zeroTrustOrganizationGetYourZeroTrustOrganizationDohSettings = (
  variables: ZeroTrustOrganizationGetYourZeroTrustOrganizationDohSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZeroTrustOrganizationGetYourZeroTrustOrganizationDohSettingsResponse,
    ZeroTrustOrganizationGetYourZeroTrustOrganizationDohSettingsError,
    undefined,
    {},
    {},
    ZeroTrustOrganizationGetYourZeroTrustOrganizationDohSettingsPathParams
  >({ url: '/accounts/{accountId}/access/organizations/doh', method: 'get', ...variables, signal });

export type ZeroTrustOrganizationUpdateYourZeroTrustOrganizationDohSettingsPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type ZeroTrustOrganizationUpdateYourZeroTrustOrganizationDohSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZeroTrustOrganizationUpdateYourZeroTrustOrganizationDohSettingsResponse =
  Schemas.AccessSchemasSingleResponse & {
    result?: {
      doh_jwt_duration?: Schemas.AccessDohJwtDuration;
    };
  };

export type ZeroTrustOrganizationUpdateYourZeroTrustOrganizationDohSettingsRequestBody = {
  doh_jwt_duration?: Schemas.AccessDohJwtDuration;
  /**
   * The uuid of the service token you want to use for DoH authentication
   *
   * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
   */
  service_token_id?: string;
};

export type ZeroTrustOrganizationUpdateYourZeroTrustOrganizationDohSettingsVariables = {
  body?: ZeroTrustOrganizationUpdateYourZeroTrustOrganizationDohSettingsRequestBody;
  pathParams: ZeroTrustOrganizationUpdateYourZeroTrustOrganizationDohSettingsPathParams;
} & FetcherExtraProps;

/**
 * Updates the DoH settings for your Zero Trust organization.
 */
export const zeroTrustOrganizationUpdateYourZeroTrustOrganizationDohSettings = (
  variables: ZeroTrustOrganizationUpdateYourZeroTrustOrganizationDohSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZeroTrustOrganizationUpdateYourZeroTrustOrganizationDohSettingsResponse,
    ZeroTrustOrganizationUpdateYourZeroTrustOrganizationDohSettingsError,
    ZeroTrustOrganizationUpdateYourZeroTrustOrganizationDohSettingsRequestBody,
    {},
    {},
    ZeroTrustOrganizationUpdateYourZeroTrustOrganizationDohSettingsPathParams
  >({ url: '/accounts/{accountId}/access/organizations/doh', method: 'put', ...variables, signal });

export type ZeroTrustOrganizationRevokeAllAccessTokensForAUserPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type ZeroTrustOrganizationRevokeAllAccessTokensForAUserQueryParams = {
  /**
   * When set to `true`, all devices associated with the user will be revoked.
   */
  devices?: boolean;
};

export type ZeroTrustOrganizationRevokeAllAccessTokensForAUserError = Fetcher.ErrorWrapper<{
  status: ClientErrorStatus;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZeroTrustOrganizationRevokeAllAccessTokensForAUserRequestBody = {
  /**
   * When set to `true`, all devices associated with the user will be revoked.
   *
   * @example true
   */
  devices?: boolean;
  /**
   * The email of the user to revoke.
   *
   * @example test@example.com
   */
  email: string;
  /**
   * The uuid of the user to revoke.
   *
   * @example 699d98642c564d2e855e9661899b7252
   */
  user_uid?: string;
  /**
   * When set to `true`, the user will be required to re-authenticate to WARP for all Gateway policies that enforce a WARP client session duration. When `false`, the user’s WARP session will remain active
   *
   * @example true
   */
  warp_session_reauth?: boolean;
};

export type ZeroTrustOrganizationRevokeAllAccessTokensForAUserVariables = {
  body: ZeroTrustOrganizationRevokeAllAccessTokensForAUserRequestBody;
  pathParams: ZeroTrustOrganizationRevokeAllAccessTokensForAUserPathParams;
  queryParams?: ZeroTrustOrganizationRevokeAllAccessTokensForAUserQueryParams;
} & FetcherExtraProps;

/**
 * Revokes a user's access across all applications.
 */
export const zeroTrustOrganizationRevokeAllAccessTokensForAUser = (
  variables: ZeroTrustOrganizationRevokeAllAccessTokensForAUserVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessEmptyResponse,
    ZeroTrustOrganizationRevokeAllAccessTokensForAUserError,
    ZeroTrustOrganizationRevokeAllAccessTokensForAUserRequestBody,
    {},
    ZeroTrustOrganizationRevokeAllAccessTokensForAUserQueryParams,
    ZeroTrustOrganizationRevokeAllAccessTokensForAUserPathParams
  >({ url: '/accounts/{accountId}/access/organizations/revoke_user', method: 'post', ...variables, signal });

export type AccessPoliciesListAccessReusablePoliciesPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessPoliciesListAccessReusablePoliciesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessPoliciesListAccessReusablePoliciesVariables = {
  pathParams: AccessPoliciesListAccessReusablePoliciesPathParams;
} & FetcherExtraProps;

/**
 * Lists Access reusable policies.
 */
export const accessPoliciesListAccessReusablePolicies = (
  variables: AccessPoliciesListAccessReusablePoliciesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessReusablePoliciesComponentsSchemasResponseCollection,
    AccessPoliciesListAccessReusablePoliciesError,
    undefined,
    {},
    {},
    AccessPoliciesListAccessReusablePoliciesPathParams
  >({ url: '/accounts/{accountId}/access/policies', method: 'get', ...variables, signal });

export type AccessPoliciesCreateAnAccessReusablePolicyPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessPoliciesCreateAnAccessReusablePolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessPoliciesCreateAnAccessReusablePolicyVariables = {
  body?: Schemas.AccessPolicyReq;
  pathParams: AccessPoliciesCreateAnAccessReusablePolicyPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Access reusable policy.
 */
export const accessPoliciesCreateAnAccessReusablePolicy = (
  variables: AccessPoliciesCreateAnAccessReusablePolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessReusablePoliciesComponentsSchemasSingleResponse,
    AccessPoliciesCreateAnAccessReusablePolicyError,
    Schemas.AccessPolicyReq,
    {},
    {},
    AccessPoliciesCreateAnAccessReusablePolicyPathParams
  >({ url: '/accounts/{accountId}/access/policies', method: 'post', ...variables, signal });

export type AccessPoliciesDeleteAnAccessReusablePolicyPathParams = {
  accountId: Schemas.AccessIdentifier;
  policyId: Schemas.AccessSchemasUuid;
};

export type AccessPoliciesDeleteAnAccessReusablePolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessPoliciesDeleteAnAccessReusablePolicyVariables = {
  pathParams: AccessPoliciesDeleteAnAccessReusablePolicyPathParams;
} & FetcherExtraProps;

/**
 * Deletes an Access reusable policy.
 */
export const accessPoliciesDeleteAnAccessReusablePolicy = (
  variables: AccessPoliciesDeleteAnAccessReusablePolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessReusablePoliciesComponentsSchemasIdResponse,
    AccessPoliciesDeleteAnAccessReusablePolicyError,
    undefined,
    {},
    {},
    AccessPoliciesDeleteAnAccessReusablePolicyPathParams
  >({ url: '/accounts/{accountId}/access/policies/{policyId}', method: 'delete', ...variables, signal });

export type AccessPoliciesGetAnAccessReusablePolicyPathParams = {
  accountId: Schemas.AccessIdentifier;
  policyId: Schemas.AccessSchemasUuid;
};

export type AccessPoliciesGetAnAccessReusablePolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessPoliciesGetAnAccessReusablePolicyVariables = {
  pathParams: AccessPoliciesGetAnAccessReusablePolicyPathParams;
} & FetcherExtraProps;

/**
 * Fetches a single Access reusable policy.
 */
export const accessPoliciesGetAnAccessReusablePolicy = (
  variables: AccessPoliciesGetAnAccessReusablePolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessReusablePoliciesComponentsSchemasSingleResponse,
    AccessPoliciesGetAnAccessReusablePolicyError,
    undefined,
    {},
    {},
    AccessPoliciesGetAnAccessReusablePolicyPathParams
  >({ url: '/accounts/{accountId}/access/policies/{policyId}', method: 'get', ...variables, signal });

export type AccessPoliciesUpdateAnAccessReusablePolicyPathParams = {
  accountId: Schemas.AccessIdentifier;
  policyId: Schemas.AccessSchemasUuid;
};

export type AccessPoliciesUpdateAnAccessReusablePolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessPoliciesUpdateAnAccessReusablePolicyVariables = {
  body?: Schemas.AccessPolicyReq;
  pathParams: AccessPoliciesUpdateAnAccessReusablePolicyPathParams;
} & FetcherExtraProps;

/**
 * Updates a Access reusable policy.
 */
export const accessPoliciesUpdateAnAccessReusablePolicy = (
  variables: AccessPoliciesUpdateAnAccessReusablePolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessReusablePoliciesComponentsSchemasSingleResponse,
    AccessPoliciesUpdateAnAccessReusablePolicyError,
    Schemas.AccessPolicyReq,
    {},
    {},
    AccessPoliciesUpdateAnAccessReusablePolicyPathParams
  >({ url: '/accounts/{accountId}/access/policies/{policyId}', method: 'put', ...variables, signal });

export type AccessPolicyTestsPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessPolicyTestsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessPolicyTestsVariables = {
  body?: Schemas.AccessPolicyResp;
  pathParams: AccessPolicyTestsPathParams;
} & FetcherExtraProps;

/**
 * Starts an Access policy test.
 */
export const accessPolicyTests = (variables: AccessPolicyTestsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.AccessPolicyInitResp,
    AccessPolicyTestsError,
    Schemas.AccessPolicyResp,
    {},
    {},
    AccessPolicyTestsPathParams
  >({ url: '/accounts/{accountId}/access/policy-tests', method: 'post', ...variables, signal });

export type AccessPolicyTestsGetAnUpdatePathParams = {
  accountId: Schemas.AccessIdentifier;
  policyTestId: Schemas.AccessPolicyTestId;
};

export type AccessPolicyTestsGetAnUpdateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessPolicyTestsGetAnUpdateVariables = {
  pathParams: AccessPolicyTestsGetAnUpdatePathParams;
} & FetcherExtraProps;

/**
 * Fetches the current status of a given Access policy test.
 */
export const accessPolicyTestsGetAnUpdate = (variables: AccessPolicyTestsGetAnUpdateVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.AccessPolicyUpdateResp,
    AccessPolicyTestsGetAnUpdateError,
    undefined,
    {},
    {},
    AccessPolicyTestsGetAnUpdatePathParams
  >({ url: '/accounts/{accountId}/access/policy-tests/{policyTestId}', method: 'get', ...variables, signal });

export type AccessPolicyTestsGetAUserPagePathParams = {
  accountId: Schemas.AccessIdentifier;
  policyTestId: Schemas.AccessPolicyTestId;
};

export type AccessPolicyTestsGetAUserPageError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessPolicyTestsGetAUserPageVariables = {
  pathParams: AccessPolicyTestsGetAUserPagePathParams;
} & FetcherExtraProps;

/**
 * Fetches a single page of user results from an Access policy test.
 */
export const accessPolicyTestsGetAUserPage = (
  variables: AccessPolicyTestsGetAUserPageVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessPolicyUsersResp,
    AccessPolicyTestsGetAUserPageError,
    undefined,
    {},
    {},
    AccessPolicyTestsGetAUserPagePathParams
  >({ url: '/accounts/{accountId}/access/policy-tests/{policyTestId}/users', method: 'get', ...variables, signal });

export type ZeroTrustSeatsUpdateAUserSeatPathParams = {
  accountId: Schemas.AccessSchemasIdentifier;
};

export type ZeroTrustSeatsUpdateAUserSeatError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZeroTrustSeatsUpdateAUserSeatVariables = {
  body: Schemas.AccessSeatsDefinition;
  pathParams: ZeroTrustSeatsUpdateAUserSeatPathParams;
} & FetcherExtraProps;

/**
 * Removes a user from a Zero Trust seat when both `access_seat` and `gateway_seat` are set to false.
 */
export const zeroTrustSeatsUpdateAUserSeat = (
  variables: ZeroTrustSeatsUpdateAUserSeatVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessSeatsComponentsSchemasResponseCollection,
    ZeroTrustSeatsUpdateAUserSeatError,
    Schemas.AccessSeatsDefinition,
    {},
    {},
    ZeroTrustSeatsUpdateAUserSeatPathParams
  >({ url: '/accounts/{accountId}/access/seats', method: 'patch', ...variables, signal });

export type AccessServiceTokensListServiceTokensPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessServiceTokensListServiceTokensQueryParams = {
  name?: string;
  search?: string;
};

export type AccessServiceTokensListServiceTokensError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessServiceTokensListServiceTokensVariables = {
  pathParams: AccessServiceTokensListServiceTokensPathParams;
  queryParams?: AccessServiceTokensListServiceTokensQueryParams;
} & FetcherExtraProps;

/**
 * Lists all service tokens.
 */
export const accessServiceTokensListServiceTokens = (
  variables: AccessServiceTokensListServiceTokensVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessComponentsSchemasResponseCollection,
    AccessServiceTokensListServiceTokensError,
    undefined,
    {},
    AccessServiceTokensListServiceTokensQueryParams,
    AccessServiceTokensListServiceTokensPathParams
  >({ url: '/accounts/{accountId}/access/service_tokens', method: 'get', ...variables, signal });

export type AccessServiceTokensCreateAServiceTokenPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessServiceTokensCreateAServiceTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessServiceTokensCreateAServiceTokenRequestBody = {
  duration?: Schemas.AccessDuration;
  name: Schemas.AccessSchemasName;
};

export type AccessServiceTokensCreateAServiceTokenVariables = {
  body: AccessServiceTokensCreateAServiceTokenRequestBody;
  pathParams: AccessServiceTokensCreateAServiceTokenPathParams;
} & FetcherExtraProps;

/**
 * Generates a new service token. **Note:** This is the only time you can get the Client Secret. If you lose the Client Secret, you will have to rotate the Client Secret or create a new service token.
 */
export const accessServiceTokensCreateAServiceToken = (
  variables: AccessServiceTokensCreateAServiceTokenVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCreateResponse,
    AccessServiceTokensCreateAServiceTokenError,
    AccessServiceTokensCreateAServiceTokenRequestBody,
    {},
    {},
    AccessServiceTokensCreateAServiceTokenPathParams
  >({ url: '/accounts/{accountId}/access/service_tokens', method: 'post', ...variables, signal });

export type AccessServiceTokensDeleteAServiceTokenPathParams = {
  serviceTokenId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessServiceTokensDeleteAServiceTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessServiceTokensDeleteAServiceTokenVariables = {
  pathParams: AccessServiceTokensDeleteAServiceTokenPathParams;
} & FetcherExtraProps;

/**
 * Deletes a service token.
 */
export const accessServiceTokensDeleteAServiceToken = (
  variables: AccessServiceTokensDeleteAServiceTokenVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessSchemasSingleResponse,
    AccessServiceTokensDeleteAServiceTokenError,
    undefined,
    {},
    {},
    AccessServiceTokensDeleteAServiceTokenPathParams
  >({ url: '/accounts/{accountId}/access/service_tokens/{serviceTokenId}', method: 'delete', ...variables, signal });

export type AccessServiceTokensGetAServiceTokenPathParams = {
  serviceTokenId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessServiceTokensGetAServiceTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessServiceTokensGetAServiceTokenVariables = {
  pathParams: AccessServiceTokensGetAServiceTokenPathParams;
} & FetcherExtraProps;

/**
 * Fetches a single service token.
 */
export const accessServiceTokensGetAServiceToken = (
  variables: AccessServiceTokensGetAServiceTokenVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessSchemasSingleResponse,
    AccessServiceTokensGetAServiceTokenError,
    undefined,
    {},
    {},
    AccessServiceTokensGetAServiceTokenPathParams
  >({ url: '/accounts/{accountId}/access/service_tokens/{serviceTokenId}', method: 'get', ...variables, signal });

export type AccessServiceTokensUpdateAServiceTokenPathParams = {
  serviceTokenId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessServiceTokensUpdateAServiceTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessServiceTokensUpdateAServiceTokenRequestBody = {
  duration?: Schemas.AccessDuration;
  name?: Schemas.AccessSchemasName;
};

export type AccessServiceTokensUpdateAServiceTokenVariables = {
  body?: AccessServiceTokensUpdateAServiceTokenRequestBody;
  pathParams: AccessServiceTokensUpdateAServiceTokenPathParams;
} & FetcherExtraProps;

/**
 * Updates a configured service token.
 */
export const accessServiceTokensUpdateAServiceToken = (
  variables: AccessServiceTokensUpdateAServiceTokenVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessSchemasSingleResponse,
    AccessServiceTokensUpdateAServiceTokenError,
    AccessServiceTokensUpdateAServiceTokenRequestBody,
    {},
    {},
    AccessServiceTokensUpdateAServiceTokenPathParams
  >({ url: '/accounts/{accountId}/access/service_tokens/{serviceTokenId}', method: 'put', ...variables, signal });

export type AccessServiceTokensRefreshAServiceTokenPathParams = {
  serviceTokenId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessServiceTokensRefreshAServiceTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessServiceTokensRefreshAServiceTokenVariables = {
  pathParams: AccessServiceTokensRefreshAServiceTokenPathParams;
} & FetcherExtraProps;

/**
 * Refreshes the expiration of a service token.
 */
export const accessServiceTokensRefreshAServiceToken = (
  variables: AccessServiceTokensRefreshAServiceTokenVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessSchemasSingleResponse,
    AccessServiceTokensRefreshAServiceTokenError,
    undefined,
    {},
    {},
    AccessServiceTokensRefreshAServiceTokenPathParams
  >({
    url: '/accounts/{accountId}/access/service_tokens/{serviceTokenId}/refresh',
    method: 'post',
    ...variables,
    signal
  });

export type AccessServiceTokensRotateAServiceTokenPathParams = {
  serviceTokenId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type AccessServiceTokensRotateAServiceTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessServiceTokensRotateAServiceTokenVariables = {
  pathParams: AccessServiceTokensRotateAServiceTokenPathParams;
} & FetcherExtraProps;

/**
 * Generates a new Client Secret for a service token and revokes the old one.
 */
export const accessServiceTokensRotateAServiceToken = (
  variables: AccessServiceTokensRotateAServiceTokenVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCreateResponse,
    AccessServiceTokensRotateAServiceTokenError,
    undefined,
    {},
    {},
    AccessServiceTokensRotateAServiceTokenPathParams
  >({
    url: '/accounts/{accountId}/access/service_tokens/{serviceTokenId}/rotate',
    method: 'post',
    ...variables,
    signal
  });

export type AccessTagsListTagsPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessTagsListTagsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessTagsListTagsVariables = {
  pathParams: AccessTagsListTagsPathParams;
} & FetcherExtraProps;

/**
 * List tags
 */
export const accessTagsListTags = (variables: AccessTagsListTagsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.AccessTagsComponentsSchemasResponseCollection,
    AccessTagsListTagsError,
    undefined,
    {},
    {},
    AccessTagsListTagsPathParams
  >({ url: '/accounts/{accountId}/access/tags', method: 'get', ...variables, signal });

export type AccessTagsCreateTagPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type AccessTagsCreateTagError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessTagsCreateTagRequestBody = {
  name?: Schemas.AccessTagsComponentsSchemasName;
};

export type AccessTagsCreateTagVariables = {
  body?: AccessTagsCreateTagRequestBody;
  pathParams: AccessTagsCreateTagPathParams;
} & FetcherExtraProps;

/**
 * Create a tag
 */
export const accessTagsCreateTag = (variables: AccessTagsCreateTagVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.AccessTagsComponentsSchemasSingleResponse,
    AccessTagsCreateTagError,
    AccessTagsCreateTagRequestBody,
    {},
    {},
    AccessTagsCreateTagPathParams
  >({ url: '/accounts/{accountId}/access/tags', method: 'post', ...variables, signal });

export type AccessTagsDeleteATagPathParams = {
  accountId: Schemas.AccessIdentifier;
  tagName: Schemas.AccessTagsComponentsSchemasName;
};

export type AccessTagsDeleteATagError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessTagsDeleteATagVariables = {
  pathParams: AccessTagsDeleteATagPathParams;
} & FetcherExtraProps;

/**
 * Delete a tag
 */
export const accessTagsDeleteATag = (variables: AccessTagsDeleteATagVariables, signal?: AbortSignal) =>
  fetch<Schemas.AccessNameResponse, AccessTagsDeleteATagError, undefined, {}, {}, AccessTagsDeleteATagPathParams>({
    url: '/accounts/{accountId}/access/tags/{tagName}',
    method: 'delete',
    ...variables,
    signal
  });

export type AccessTagsGetATagPathParams = {
  accountId: Schemas.AccessIdentifier;
  tagName: Schemas.AccessTagsComponentsSchemasName;
};

export type AccessTagsGetATagError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessTagsGetATagVariables = {
  pathParams: AccessTagsGetATagPathParams;
} & FetcherExtraProps;

/**
 * Get a tag
 */
export const accessTagsGetATag = (variables: AccessTagsGetATagVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.AccessTagsComponentsSchemasSingleResponse,
    AccessTagsGetATagError,
    undefined,
    {},
    {},
    AccessTagsGetATagPathParams
  >({ url: '/accounts/{accountId}/access/tags/{tagName}', method: 'get', ...variables, signal });

export type AccessTagsUpdateATagPathParams = {
  accountId: Schemas.AccessIdentifier;
  tagName: Schemas.AccessTagsComponentsSchemasName;
};

export type AccessTagsUpdateATagError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type AccessTagsUpdateATagVariables = {
  body: Schemas.AccessTagWithoutAppCount;
  pathParams: AccessTagsUpdateATagPathParams;
} & FetcherExtraProps;

/**
 * Update a tag
 */
export const accessTagsUpdateATag = (variables: AccessTagsUpdateATagVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.AccessTagsComponentsSchemasSingleResponse,
    AccessTagsUpdateATagError,
    Schemas.AccessTagWithoutAppCount,
    {},
    {},
    AccessTagsUpdateATagPathParams
  >({ url: '/accounts/{accountId}/access/tags/{tagName}', method: 'put', ...variables, signal });

export type ZeroTrustUsersGetUsersPathParams = {
  accountId: Schemas.AccessIdentifier;
};

export type ZeroTrustUsersGetUsersQueryParams = {
  name?: string;
  email?: string;
  search?: string;
};

export type ZeroTrustUsersGetUsersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZeroTrustUsersGetUsersVariables = {
  pathParams: ZeroTrustUsersGetUsersPathParams;
  queryParams?: ZeroTrustUsersGetUsersQueryParams;
} & FetcherExtraProps;

/**
 * Gets a list of users for an account.
 */
export const zeroTrustUsersGetUsers = (variables: ZeroTrustUsersGetUsersVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.AccessUsersComponentsSchemasResponseCollection,
    ZeroTrustUsersGetUsersError,
    undefined,
    {},
    ZeroTrustUsersGetUsersQueryParams,
    ZeroTrustUsersGetUsersPathParams
  >({ url: '/accounts/{accountId}/access/users', method: 'get', ...variables, signal });

export type ZeroTrustUsersGetActiveSessionsPathParams = {
  userId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type ZeroTrustUsersGetActiveSessionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZeroTrustUsersGetActiveSessionsVariables = {
  pathParams: ZeroTrustUsersGetActiveSessionsPathParams;
} & FetcherExtraProps;

/**
 * Get active sessions for a single user.
 */
export const zeroTrustUsersGetActiveSessions = (
  variables: ZeroTrustUsersGetActiveSessionsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessActiveSessionsResponse,
    ZeroTrustUsersGetActiveSessionsError,
    undefined,
    {},
    {},
    ZeroTrustUsersGetActiveSessionsPathParams
  >({ url: '/accounts/{accountId}/access/users/{userId}/active_sessions', method: 'get', ...variables, signal });

export type ZeroTrustUsersGetActiveSessionPathParams = {
  userId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
  nonce: Schemas.AccessNonce;
};

export type ZeroTrustUsersGetActiveSessionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZeroTrustUsersGetActiveSessionVariables = {
  pathParams: ZeroTrustUsersGetActiveSessionPathParams;
} & FetcherExtraProps;

/**
 * Get an active session for a single user.
 */
export const zeroTrustUsersGetActiveSession = (
  variables: ZeroTrustUsersGetActiveSessionVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessActiveSessionResponse,
    ZeroTrustUsersGetActiveSessionError,
    undefined,
    {},
    {},
    ZeroTrustUsersGetActiveSessionPathParams
  >({
    url: '/accounts/{accountId}/access/users/{userId}/active_sessions/{nonce}',
    method: 'get',
    ...variables,
    signal
  });

export type ZeroTrustUsersGetFailedLoginsPathParams = {
  userId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type ZeroTrustUsersGetFailedLoginsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZeroTrustUsersGetFailedLoginsVariables = {
  pathParams: ZeroTrustUsersGetFailedLoginsPathParams;
} & FetcherExtraProps;

/**
 * Get all failed login attempts for a single user.
 */
export const zeroTrustUsersGetFailedLogins = (
  variables: ZeroTrustUsersGetFailedLoginsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessFailedLoginResponse,
    ZeroTrustUsersGetFailedLoginsError,
    undefined,
    {},
    {},
    ZeroTrustUsersGetFailedLoginsPathParams
  >({ url: '/accounts/{accountId}/access/users/{userId}/failed_logins', method: 'get', ...variables, signal });

export type ZeroTrustUsersGetLastSeenIdentityPathParams = {
  userId: Schemas.AccessUuid;
  accountId: Schemas.AccessIdentifier;
};

export type ZeroTrustUsersGetLastSeenIdentityError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZeroTrustUsersGetLastSeenIdentityVariables = {
  pathParams: ZeroTrustUsersGetLastSeenIdentityPathParams;
} & FetcherExtraProps;

/**
 * Get last seen identity for a single user.
 */
export const zeroTrustUsersGetLastSeenIdentity = (
  variables: ZeroTrustUsersGetLastSeenIdentityVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessLastSeenIdentityResponse,
    ZeroTrustUsersGetLastSeenIdentityError,
    undefined,
    {},
    {},
    ZeroTrustUsersGetLastSeenIdentityPathParams
  >({ url: '/accounts/{accountId}/access/users/{userId}/last_seen_identity', method: 'get', ...variables, signal });

export type IpAddressManagementAddressMapsListAddressMapsPathParams = {
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementAddressMapsListAddressMapsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingComponentsSchemasResponseCollection & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementAddressMapsListAddressMapsVariables = {
  pathParams: IpAddressManagementAddressMapsListAddressMapsPathParams;
} & FetcherExtraProps;

/**
 * List all address maps owned by the account.
 */
export const ipAddressManagementAddressMapsListAddressMaps = (
  variables: IpAddressManagementAddressMapsListAddressMapsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingComponentsSchemasResponseCollection,
    IpAddressManagementAddressMapsListAddressMapsError,
    undefined,
    {},
    {},
    IpAddressManagementAddressMapsListAddressMapsPathParams
  >({ url: '/accounts/{accountId}/addressing/address_maps', method: 'get', ...variables, signal });

export type IpAddressManagementAddressMapsCreateAddressMapPathParams = {
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementAddressMapsCreateAddressMapError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingFullResponse & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementAddressMapsCreateAddressMapRequestBody = {
  description?: Schemas.AddressingSchemasDescription;
  enabled?: Schemas.AddressingEnabled;
  ips?: Schemas.AddressingIpAddress[];
  memberships?: Schemas.AddressingMemberships;
};

export type IpAddressManagementAddressMapsCreateAddressMapVariables = {
  body?: IpAddressManagementAddressMapsCreateAddressMapRequestBody;
  pathParams: IpAddressManagementAddressMapsCreateAddressMapPathParams;
} & FetcherExtraProps;

/**
 * Create a new address map under the account.
 */
export const ipAddressManagementAddressMapsCreateAddressMap = (
  variables: IpAddressManagementAddressMapsCreateAddressMapVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingFullResponse,
    IpAddressManagementAddressMapsCreateAddressMapError,
    IpAddressManagementAddressMapsCreateAddressMapRequestBody,
    {},
    {},
    IpAddressManagementAddressMapsCreateAddressMapPathParams
  >({ url: '/accounts/{accountId}/addressing/address_maps', method: 'post', ...variables, signal });

export type IpAddressManagementAddressMapsDeleteAddressMapPathParams = {
  addressMapId: Schemas.AddressingAddressMapIdentifier;
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementAddressMapsDeleteAddressMapError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingApiResponseCollection & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementAddressMapsDeleteAddressMapVariables = {
  pathParams: IpAddressManagementAddressMapsDeleteAddressMapPathParams;
} & FetcherExtraProps;

/**
 * Delete a particular address map owned by the account. An Address Map must be disabled before it can be deleted.
 */
export const ipAddressManagementAddressMapsDeleteAddressMap = (
  variables: IpAddressManagementAddressMapsDeleteAddressMapVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingApiResponseCollection,
    IpAddressManagementAddressMapsDeleteAddressMapError,
    undefined,
    {},
    {},
    IpAddressManagementAddressMapsDeleteAddressMapPathParams
  >({ url: '/accounts/{accountId}/addressing/address_maps/{addressMapId}', method: 'delete', ...variables, signal });

export type IpAddressManagementAddressMapsAddressMapDetailsPathParams = {
  addressMapId: Schemas.AddressingAddressMapIdentifier;
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementAddressMapsAddressMapDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingFullResponse & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementAddressMapsAddressMapDetailsVariables = {
  pathParams: IpAddressManagementAddressMapsAddressMapDetailsPathParams;
} & FetcherExtraProps;

/**
 * Show a particular address map owned by the account.
 */
export const ipAddressManagementAddressMapsAddressMapDetails = (
  variables: IpAddressManagementAddressMapsAddressMapDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingFullResponse,
    IpAddressManagementAddressMapsAddressMapDetailsError,
    undefined,
    {},
    {},
    IpAddressManagementAddressMapsAddressMapDetailsPathParams
  >({ url: '/accounts/{accountId}/addressing/address_maps/{addressMapId}', method: 'get', ...variables, signal });

export type IpAddressManagementAddressMapsUpdateAddressMapPathParams = {
  addressMapId: Schemas.AddressingAddressMapIdentifier;
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementAddressMapsUpdateAddressMapError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingComponentsSchemasSingleResponse & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementAddressMapsUpdateAddressMapRequestBody = {
  default_sni?: Schemas.AddressingDefaultSni;
  description?: Schemas.AddressingSchemasDescription;
  enabled?: Schemas.AddressingEnabled;
};

export type IpAddressManagementAddressMapsUpdateAddressMapVariables = {
  body?: IpAddressManagementAddressMapsUpdateAddressMapRequestBody;
  pathParams: IpAddressManagementAddressMapsUpdateAddressMapPathParams;
} & FetcherExtraProps;

/**
 * Modify properties of an address map owned by the account.
 */
export const ipAddressManagementAddressMapsUpdateAddressMap = (
  variables: IpAddressManagementAddressMapsUpdateAddressMapVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingComponentsSchemasSingleResponse,
    IpAddressManagementAddressMapsUpdateAddressMapError,
    IpAddressManagementAddressMapsUpdateAddressMapRequestBody,
    {},
    {},
    IpAddressManagementAddressMapsUpdateAddressMapPathParams
  >({ url: '/accounts/{accountId}/addressing/address_maps/{addressMapId}', method: 'patch', ...variables, signal });

export type IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapPathParams = {
  accountId: Schemas.AddressingAccountIdentifier;
  addressMapId: Schemas.AddressingAddressMapIdentifier;
};

export type IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingApiResponseCollection & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapVariables = {
  pathParams: IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapPathParams;
} & FetcherExtraProps;

/**
 * Remove an account as a member of a particular address map.
 */
export const ipAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMap = (
  variables: IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingApiResponseCollection,
    IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapError,
    undefined,
    {},
    {},
    IpAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMapPathParams
  >({
    url: '/accounts/{accountId}/addressing/address_maps/{addressMapId}/accounts/{accountId}',
    method: 'delete',
    ...variables,
    signal
  });

export type IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapPathParams = {
  accountId: Schemas.AddressingAccountIdentifier;
  addressMapId: Schemas.AddressingAddressMapIdentifier;
};

export type IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingApiResponseCollection & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapVariables = {
  pathParams: IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapPathParams;
} & FetcherExtraProps;

/**
 * Add an account as a member of a particular address map.
 */
export const ipAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMap = (
  variables: IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingApiResponseCollection,
    IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapError,
    undefined,
    {},
    {},
    IpAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMapPathParams
  >({
    url: '/accounts/{accountId}/addressing/address_maps/{addressMapId}/accounts/{accountId}',
    method: 'put',
    ...variables,
    signal
  });

export type IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapPathParams = {
  ipAddress: Schemas.AddressingIpAddress;
  addressMapId: Schemas.AddressingAddressMapIdentifier;
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingApiResponseCollection & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapVariables = {
  pathParams: IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapPathParams;
} & FetcherExtraProps;

/**
 * Remove an IP from a particular address map.
 */
export const ipAddressManagementAddressMapsRemoveAnIpFromAnAddressMap = (
  variables: IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingApiResponseCollection,
    IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapError,
    undefined,
    {},
    {},
    IpAddressManagementAddressMapsRemoveAnIpFromAnAddressMapPathParams
  >({
    url: '/accounts/{accountId}/addressing/address_maps/{addressMapId}/ips/{ipAddress}',
    method: 'delete',
    ...variables,
    signal
  });

export type IpAddressManagementAddressMapsAddAnIpToAnAddressMapPathParams = {
  ipAddress: Schemas.AddressingIpAddress;
  addressMapId: Schemas.AddressingAddressMapIdentifier;
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementAddressMapsAddAnIpToAnAddressMapError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingApiResponseCollection & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementAddressMapsAddAnIpToAnAddressMapVariables = {
  pathParams: IpAddressManagementAddressMapsAddAnIpToAnAddressMapPathParams;
} & FetcherExtraProps;

/**
 * Add an IP from a prefix owned by the account to a particular address map.
 */
export const ipAddressManagementAddressMapsAddAnIpToAnAddressMap = (
  variables: IpAddressManagementAddressMapsAddAnIpToAnAddressMapVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingApiResponseCollection,
    IpAddressManagementAddressMapsAddAnIpToAnAddressMapError,
    undefined,
    {},
    {},
    IpAddressManagementAddressMapsAddAnIpToAnAddressMapPathParams
  >({
    url: '/accounts/{accountId}/addressing/address_maps/{addressMapId}/ips/{ipAddress}',
    method: 'put',
    ...variables,
    signal
  });

export type IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapPathParams = {
  zoneId: Schemas.AddressingZoneIdentifier;
  addressMapId: Schemas.AddressingAddressMapIdentifier;
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingApiResponseCollection & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapVariables = {
  pathParams: IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapPathParams;
} & FetcherExtraProps;

/**
 * Remove a zone as a member of a particular address map.
 */
export const ipAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMap = (
  variables: IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingApiResponseCollection,
    IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapError,
    undefined,
    {},
    {},
    IpAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMapPathParams
  >({
    url: '/accounts/{accountId}/addressing/address_maps/{addressMapId}/zones/{zoneId}',
    method: 'delete',
    ...variables,
    signal
  });

export type IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapPathParams = {
  zoneId: Schemas.AddressingZoneIdentifier;
  addressMapId: Schemas.AddressingAddressMapIdentifier;
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingApiResponseCollection & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapVariables = {
  pathParams: IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapPathParams;
} & FetcherExtraProps;

/**
 * Add a zone as a member of a particular address map.
 */
export const ipAddressManagementAddressMapsAddAZoneMembershipToAnAddressMap = (
  variables: IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingApiResponseCollection,
    IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapError,
    undefined,
    {},
    {},
    IpAddressManagementAddressMapsAddAZoneMembershipToAnAddressMapPathParams
  >({
    url: '/accounts/{accountId}/addressing/address_maps/{addressMapId}/zones/{zoneId}',
    method: 'put',
    ...variables,
    signal
  });

export type IpAddressManagementPrefixesUploadLoaDocumentPathParams = {
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementPrefixesUploadLoaDocumentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingLoaUploadResponse & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementPrefixesUploadLoaDocumentRequestBody = {
  /**
   * LOA document to upload.
   *
   * @example @document.pdf
   */
  loa_document: string;
};

export type IpAddressManagementPrefixesUploadLoaDocumentVariables = {
  body: IpAddressManagementPrefixesUploadLoaDocumentRequestBody;
  pathParams: IpAddressManagementPrefixesUploadLoaDocumentPathParams;
} & FetcherExtraProps;

/**
 * Submit LOA document (pdf format) under the account.
 */
export const ipAddressManagementPrefixesUploadLoaDocument = (
  variables: IpAddressManagementPrefixesUploadLoaDocumentVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingLoaUploadResponse,
    IpAddressManagementPrefixesUploadLoaDocumentError,
    IpAddressManagementPrefixesUploadLoaDocumentRequestBody,
    {},
    {},
    IpAddressManagementPrefixesUploadLoaDocumentPathParams
  >({ url: '/accounts/{accountId}/addressing/loa_documents', method: 'post', ...variables, signal });

export type IpAddressManagementPrefixesDownloadLoaDocumentPathParams = {
  loaDocumentId: Schemas.AddressingLoaDocumentIdentifier;
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementPrefixesDownloadLoaDocumentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: void & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementPrefixesDownloadLoaDocumentVariables = {
  pathParams: IpAddressManagementPrefixesDownloadLoaDocumentPathParams;
} & FetcherExtraProps;

/**
 * Download specified LOA document under the account.
 */
export const ipAddressManagementPrefixesDownloadLoaDocument = (
  variables: IpAddressManagementPrefixesDownloadLoaDocumentVariables,
  signal?: AbortSignal
) =>
  fetch<
    undefined,
    IpAddressManagementPrefixesDownloadLoaDocumentError,
    undefined,
    {},
    {},
    IpAddressManagementPrefixesDownloadLoaDocumentPathParams
  >({
    url: '/accounts/{accountId}/addressing/loa_documents/{loaDocumentId}/download',
    method: 'get',
    ...variables,
    signal
  });

export type IpAddressManagementPrefixesListPrefixesPathParams = {
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementPrefixesListPrefixesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingResponseCollection & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementPrefixesListPrefixesVariables = {
  pathParams: IpAddressManagementPrefixesListPrefixesPathParams;
} & FetcherExtraProps;

/**
 * List all prefixes owned by the account.
 */
export const ipAddressManagementPrefixesListPrefixes = (
  variables: IpAddressManagementPrefixesListPrefixesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingResponseCollection,
    IpAddressManagementPrefixesListPrefixesError,
    undefined,
    {},
    {},
    IpAddressManagementPrefixesListPrefixesPathParams
  >({ url: '/accounts/{accountId}/addressing/prefixes', method: 'get', ...variables, signal });

export type IpAddressManagementPrefixesAddPrefixPathParams = {
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementPrefixesAddPrefixError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingSingleResponse & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementPrefixesAddPrefixRequestBody = {
  asn: Schemas.AddressingAsn;
  cidr: Schemas.AddressingCidr;
  loa_document_id: Schemas.AddressingLoaDocumentIdentifier;
};

export type IpAddressManagementPrefixesAddPrefixVariables = {
  body: IpAddressManagementPrefixesAddPrefixRequestBody;
  pathParams: IpAddressManagementPrefixesAddPrefixPathParams;
} & FetcherExtraProps;

/**
 * Add a new prefix under the account.
 */
export const ipAddressManagementPrefixesAddPrefix = (
  variables: IpAddressManagementPrefixesAddPrefixVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingSingleResponse,
    IpAddressManagementPrefixesAddPrefixError,
    IpAddressManagementPrefixesAddPrefixRequestBody,
    {},
    {},
    IpAddressManagementPrefixesAddPrefixPathParams
  >({ url: '/accounts/{accountId}/addressing/prefixes', method: 'post', ...variables, signal });

export type IpAddressManagementPrefixesDeletePrefixPathParams = {
  prefixId: Schemas.AddressingPrefixIdentifier;
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementPrefixesDeletePrefixError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingApiResponseCollection & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementPrefixesDeletePrefixVariables = {
  pathParams: IpAddressManagementPrefixesDeletePrefixPathParams;
} & FetcherExtraProps;

/**
 * Delete an unapproved prefix owned by the account.
 */
export const ipAddressManagementPrefixesDeletePrefix = (
  variables: IpAddressManagementPrefixesDeletePrefixVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingApiResponseCollection,
    IpAddressManagementPrefixesDeletePrefixError,
    undefined,
    {},
    {},
    IpAddressManagementPrefixesDeletePrefixPathParams
  >({ url: '/accounts/{accountId}/addressing/prefixes/{prefixId}', method: 'delete', ...variables, signal });

export type IpAddressManagementPrefixesPrefixDetailsPathParams = {
  prefixId: Schemas.AddressingPrefixIdentifier;
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementPrefixesPrefixDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingSingleResponse & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementPrefixesPrefixDetailsVariables = {
  pathParams: IpAddressManagementPrefixesPrefixDetailsPathParams;
} & FetcherExtraProps;

/**
 * List a particular prefix owned by the account.
 */
export const ipAddressManagementPrefixesPrefixDetails = (
  variables: IpAddressManagementPrefixesPrefixDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingSingleResponse,
    IpAddressManagementPrefixesPrefixDetailsError,
    undefined,
    {},
    {},
    IpAddressManagementPrefixesPrefixDetailsPathParams
  >({ url: '/accounts/{accountId}/addressing/prefixes/{prefixId}', method: 'get', ...variables, signal });

export type IpAddressManagementPrefixesUpdatePrefixDescriptionPathParams = {
  prefixId: Schemas.AddressingPrefixIdentifier;
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementPrefixesUpdatePrefixDescriptionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingSingleResponse & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementPrefixesUpdatePrefixDescriptionRequestBody = {
  description: Schemas.AddressingDescription;
};

export type IpAddressManagementPrefixesUpdatePrefixDescriptionVariables = {
  body: IpAddressManagementPrefixesUpdatePrefixDescriptionRequestBody;
  pathParams: IpAddressManagementPrefixesUpdatePrefixDescriptionPathParams;
} & FetcherExtraProps;

/**
 * Modify the description for a prefix owned by the account.
 */
export const ipAddressManagementPrefixesUpdatePrefixDescription = (
  variables: IpAddressManagementPrefixesUpdatePrefixDescriptionVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingSingleResponse,
    IpAddressManagementPrefixesUpdatePrefixDescriptionError,
    IpAddressManagementPrefixesUpdatePrefixDescriptionRequestBody,
    {},
    {},
    IpAddressManagementPrefixesUpdatePrefixDescriptionPathParams
  >({ url: '/accounts/{accountId}/addressing/prefixes/{prefixId}', method: 'patch', ...variables, signal });

export type IpAddressManagementPrefixesListBgpPrefixesPathParams = {
  accountId: Schemas.AddressingAccountIdentifier;
  prefixId: Schemas.AddressingPrefixIdentifier;
};

export type IpAddressManagementPrefixesListBgpPrefixesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingResponseCollectionBgp & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementPrefixesListBgpPrefixesVariables = {
  pathParams: IpAddressManagementPrefixesListBgpPrefixesPathParams;
} & FetcherExtraProps;

/**
 * List all BGP Prefixes within the specified IP Prefix. BGP Prefixes are used to control which specific subnets are advertised to the Internet. It is possible to advertise subnets more specific than an IP Prefix by creating more specific BGP Prefixes.
 */
export const ipAddressManagementPrefixesListBgpPrefixes = (
  variables: IpAddressManagementPrefixesListBgpPrefixesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingResponseCollectionBgp,
    IpAddressManagementPrefixesListBgpPrefixesError,
    undefined,
    {},
    {},
    IpAddressManagementPrefixesListBgpPrefixesPathParams
  >({ url: '/accounts/{accountId}/addressing/prefixes/{prefixId}/bgp/prefixes', method: 'get', ...variables, signal });

export type IpAddressManagementPrefixesCreateBgpPrefixPathParams = {
  accountId: Schemas.AddressingAccountIdentifier;
  prefixId: Schemas.AddressingPrefixIdentifier;
};

export type IpAddressManagementPrefixesCreateBgpPrefixError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingSingleResponseBgp & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementPrefixesCreateBgpPrefixVariables = {
  body?: Schemas.AddressingBgpPrefixCreate;
  pathParams: IpAddressManagementPrefixesCreateBgpPrefixPathParams;
} & FetcherExtraProps;

/**
 * Create a BGP prefix, controlling the BGP advertisement status of a specific subnet. When created, BGP prefixes are initially withdrawn, and can be advertised with the Update BGP Prefix API.
 */
export const ipAddressManagementPrefixesCreateBgpPrefix = (
  variables: IpAddressManagementPrefixesCreateBgpPrefixVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingSingleResponseBgp,
    IpAddressManagementPrefixesCreateBgpPrefixError,
    Schemas.AddressingBgpPrefixCreate,
    {},
    {},
    IpAddressManagementPrefixesCreateBgpPrefixPathParams
  >({ url: '/accounts/{accountId}/addressing/prefixes/{prefixId}/bgp/prefixes', method: 'post', ...variables, signal });

export type IpAddressManagementPrefixesFetchBgpPrefixPathParams = {
  accountId: Schemas.AddressingAccountIdentifier;
  prefixId: Schemas.AddressingPrefixIdentifier;
  bgpPrefixId: Schemas.AddressingBgpPrefixIdentifier;
};

export type IpAddressManagementPrefixesFetchBgpPrefixError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingSingleResponseBgp & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementPrefixesFetchBgpPrefixVariables = {
  pathParams: IpAddressManagementPrefixesFetchBgpPrefixPathParams;
} & FetcherExtraProps;

/**
 * Retrieve a single BGP Prefix according to its identifier
 */
export const ipAddressManagementPrefixesFetchBgpPrefix = (
  variables: IpAddressManagementPrefixesFetchBgpPrefixVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingSingleResponseBgp,
    IpAddressManagementPrefixesFetchBgpPrefixError,
    undefined,
    {},
    {},
    IpAddressManagementPrefixesFetchBgpPrefixPathParams
  >({
    url: '/accounts/{accountId}/addressing/prefixes/{prefixId}/bgp/prefixes/{bgpPrefixId}',
    method: 'get',
    ...variables,
    signal
  });

export type IpAddressManagementPrefixesUpdateBgpPrefixPathParams = {
  accountId: Schemas.AddressingAccountIdentifier;
  prefixId: Schemas.AddressingPrefixIdentifier;
  bgpPrefixId: Schemas.AddressingBgpPrefixIdentifier;
};

export type IpAddressManagementPrefixesUpdateBgpPrefixError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingSingleResponseBgp & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementPrefixesUpdateBgpPrefixVariables = {
  body?: Schemas.AddressingBgpPrefixUpdateAdvertisement;
  pathParams: IpAddressManagementPrefixesUpdateBgpPrefixPathParams;
} & FetcherExtraProps;

/**
 * Update the properties of a BGP Prefix, such as the on demand advertisement status (advertised or withdrawn).
 */
export const ipAddressManagementPrefixesUpdateBgpPrefix = (
  variables: IpAddressManagementPrefixesUpdateBgpPrefixVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingSingleResponseBgp,
    IpAddressManagementPrefixesUpdateBgpPrefixError,
    Schemas.AddressingBgpPrefixUpdateAdvertisement,
    {},
    {},
    IpAddressManagementPrefixesUpdateBgpPrefixPathParams
  >({
    url: '/accounts/{accountId}/addressing/prefixes/{prefixId}/bgp/prefixes/{bgpPrefixId}',
    method: 'patch',
    ...variables,
    signal
  });

export type IpAddressManagementDynamicAdvertisementGetAdvertisementStatusPathParams = {
  prefixId: Schemas.AddressingPrefixIdentifier;
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementDynamicAdvertisementGetAdvertisementStatusError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingAdvertisedResponse & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementDynamicAdvertisementGetAdvertisementStatusVariables = {
  pathParams: IpAddressManagementDynamicAdvertisementGetAdvertisementStatusPathParams;
} & FetcherExtraProps;

/**
 * View the current advertisement state for a prefix.
 *
 * **Deprecated:** Prefer the BGP Prefixes endpoints, which additionally allow for advertising and withdrawing
 * subnets of an IP prefix.
 */
export const ipAddressManagementDynamicAdvertisementGetAdvertisementStatus = (
  variables: IpAddressManagementDynamicAdvertisementGetAdvertisementStatusVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingAdvertisedResponse,
    IpAddressManagementDynamicAdvertisementGetAdvertisementStatusError,
    undefined,
    {},
    {},
    IpAddressManagementDynamicAdvertisementGetAdvertisementStatusPathParams
  >({ url: '/accounts/{accountId}/addressing/prefixes/{prefixId}/bgp/status', method: 'get', ...variables, signal });

export type IpAddressManagementDynamicAdvertisementUpdatePrefixDynamicAdvertisementStatusPathParams = {
  prefixId: Schemas.AddressingPrefixIdentifier;
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementDynamicAdvertisementUpdatePrefixDynamicAdvertisementStatusError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingAdvertisedResponse & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementDynamicAdvertisementUpdatePrefixDynamicAdvertisementStatusRequestBody = {
  advertised: Schemas.AddressingSchemasAdvertised;
};

export type IpAddressManagementDynamicAdvertisementUpdatePrefixDynamicAdvertisementStatusVariables = {
  body: IpAddressManagementDynamicAdvertisementUpdatePrefixDynamicAdvertisementStatusRequestBody;
  pathParams: IpAddressManagementDynamicAdvertisementUpdatePrefixDynamicAdvertisementStatusPathParams;
} & FetcherExtraProps;

/**
 * Advertise or withdraw the BGP route for a prefix.
 *
 * **Deprecated:** Prefer the BGP Prefixes endpoints, which additionally allow for advertising and withdrawing
 * subnets of an IP prefix.
 */
export const ipAddressManagementDynamicAdvertisementUpdatePrefixDynamicAdvertisementStatus = (
  variables: IpAddressManagementDynamicAdvertisementUpdatePrefixDynamicAdvertisementStatusVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingAdvertisedResponse,
    IpAddressManagementDynamicAdvertisementUpdatePrefixDynamicAdvertisementStatusError,
    IpAddressManagementDynamicAdvertisementUpdatePrefixDynamicAdvertisementStatusRequestBody,
    {},
    {},
    IpAddressManagementDynamicAdvertisementUpdatePrefixDynamicAdvertisementStatusPathParams
  >({ url: '/accounts/{accountId}/addressing/prefixes/{prefixId}/bgp/status', method: 'patch', ...variables, signal });

export type IpAddressManagementServiceBindingsListServiceBindingsPathParams = {
  accountId: Schemas.AddressingAccountIdentifier;
  prefixId: Schemas.AddressingPrefixIdentifier;
};

export type IpAddressManagementServiceBindingsListServiceBindingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementServiceBindingsListServiceBindingsResponse = Schemas.AddressingApiResponseCommon & {
  result?: Schemas.AddressingServiceBinding[];
};

export type IpAddressManagementServiceBindingsListServiceBindingsVariables = {
  pathParams: IpAddressManagementServiceBindingsListServiceBindingsPathParams;
} & FetcherExtraProps;

/**
 * List the Cloudflare services this prefix is currently bound to. Traffic sent to an address within an IP prefix will be routed to the Cloudflare service of the most-specific Service Binding matching the address.
 * **Example:** binding `192.0.2.0/24` to Cloudflare Magic Transit and `192.0.2.1/32` to the Cloudflare CDN would route traffic for `192.0.2.1` to the CDN, and traffic for all other IPs in the prefix to Cloudflare Magic Transit.
 */
export const ipAddressManagementServiceBindingsListServiceBindings = (
  variables: IpAddressManagementServiceBindingsListServiceBindingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    IpAddressManagementServiceBindingsListServiceBindingsResponse,
    IpAddressManagementServiceBindingsListServiceBindingsError,
    undefined,
    {},
    {},
    IpAddressManagementServiceBindingsListServiceBindingsPathParams
  >({ url: '/accounts/{accountId}/addressing/prefixes/{prefixId}/bindings', method: 'get', ...variables, signal });

export type IpAddressManagementServiceBindingsCreateServiceBindingPathParams = {
  accountId: Schemas.AddressingAccountIdentifier;
  prefixId: Schemas.AddressingPrefixIdentifier;
};

export type IpAddressManagementServiceBindingsCreateServiceBindingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementServiceBindingsCreateServiceBindingResponse = Schemas.AddressingApiResponseCommon & {
  result?: Schemas.AddressingServiceBinding;
};

export type IpAddressManagementServiceBindingsCreateServiceBindingVariables = {
  body?: Schemas.AddressingCreateBindingRequest;
  pathParams: IpAddressManagementServiceBindingsCreateServiceBindingPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Service Binding, routing traffic to IPs within the given CIDR to a service running on Cloudflare's network.
 * **Note:** This API may only be used on prefixes currently configured with a Magic Transit service binding, and only allows creating service bindings for the Cloudflare CDN or Cloudflare Spectrum.
 */
export const ipAddressManagementServiceBindingsCreateServiceBinding = (
  variables: IpAddressManagementServiceBindingsCreateServiceBindingVariables,
  signal?: AbortSignal
) =>
  fetch<
    IpAddressManagementServiceBindingsCreateServiceBindingResponse,
    IpAddressManagementServiceBindingsCreateServiceBindingError,
    Schemas.AddressingCreateBindingRequest,
    {},
    {},
    IpAddressManagementServiceBindingsCreateServiceBindingPathParams
  >({ url: '/accounts/{accountId}/addressing/prefixes/{prefixId}/bindings', method: 'post', ...variables, signal });

export type IpAddressManagementServiceBindingsDeleteServiceBindingPathParams = {
  accountId: Schemas.AddressingAccountIdentifier;
  prefixId: Schemas.AddressingPrefixIdentifier;
  bindingId: Schemas.AddressingServiceBindingIdentifier;
};

export type IpAddressManagementServiceBindingsDeleteServiceBindingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementServiceBindingsDeleteServiceBindingVariables = {
  pathParams: IpAddressManagementServiceBindingsDeleteServiceBindingPathParams;
} & FetcherExtraProps;

/**
 * Delete a Service Binding
 */
export const ipAddressManagementServiceBindingsDeleteServiceBinding = (
  variables: IpAddressManagementServiceBindingsDeleteServiceBindingVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingApiResponseCommon,
    IpAddressManagementServiceBindingsDeleteServiceBindingError,
    undefined,
    {},
    {},
    IpAddressManagementServiceBindingsDeleteServiceBindingPathParams
  >({
    url: '/accounts/{accountId}/addressing/prefixes/{prefixId}/bindings/{bindingId}',
    method: 'delete',
    ...variables,
    signal
  });

export type IpAddressManagementServiceBindingsGetServiceBindingPathParams = {
  accountId: Schemas.AddressingAccountIdentifier;
  prefixId: Schemas.AddressingPrefixIdentifier;
  bindingId: Schemas.AddressingServiceBindingIdentifier;
};

export type IpAddressManagementServiceBindingsGetServiceBindingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementServiceBindingsGetServiceBindingResponse = Schemas.AddressingApiResponseCommon & {
  result?: Schemas.AddressingServiceBinding;
};

export type IpAddressManagementServiceBindingsGetServiceBindingVariables = {
  pathParams: IpAddressManagementServiceBindingsGetServiceBindingPathParams;
} & FetcherExtraProps;

/**
 * Fetch a single Service Binding
 */
export const ipAddressManagementServiceBindingsGetServiceBinding = (
  variables: IpAddressManagementServiceBindingsGetServiceBindingVariables,
  signal?: AbortSignal
) =>
  fetch<
    IpAddressManagementServiceBindingsGetServiceBindingResponse,
    IpAddressManagementServiceBindingsGetServiceBindingError,
    undefined,
    {},
    {},
    IpAddressManagementServiceBindingsGetServiceBindingPathParams
  >({
    url: '/accounts/{accountId}/addressing/prefixes/{prefixId}/bindings/{bindingId}',
    method: 'get',
    ...variables,
    signal
  });

export type IpAddressManagementPrefixDelegationListPrefixDelegationsPathParams = {
  prefixId: Schemas.AddressingPrefixIdentifier;
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementPrefixDelegationListPrefixDelegationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingSchemasResponseCollection & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementPrefixDelegationListPrefixDelegationsVariables = {
  pathParams: IpAddressManagementPrefixDelegationListPrefixDelegationsPathParams;
} & FetcherExtraProps;

/**
 * List all delegations for a given account IP prefix.
 */
export const ipAddressManagementPrefixDelegationListPrefixDelegations = (
  variables: IpAddressManagementPrefixDelegationListPrefixDelegationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingSchemasResponseCollection,
    IpAddressManagementPrefixDelegationListPrefixDelegationsError,
    undefined,
    {},
    {},
    IpAddressManagementPrefixDelegationListPrefixDelegationsPathParams
  >({ url: '/accounts/{accountId}/addressing/prefixes/{prefixId}/delegations', method: 'get', ...variables, signal });

export type IpAddressManagementPrefixDelegationCreatePrefixDelegationPathParams = {
  prefixId: Schemas.AddressingPrefixIdentifier;
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementPrefixDelegationCreatePrefixDelegationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingSchemasSingleResponse & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementPrefixDelegationCreatePrefixDelegationRequestBody = {
  cidr: Schemas.AddressingCidr;
  delegated_account_id: Schemas.AddressingDelegatedAccountIdentifier;
};

export type IpAddressManagementPrefixDelegationCreatePrefixDelegationVariables = {
  body: IpAddressManagementPrefixDelegationCreatePrefixDelegationRequestBody;
  pathParams: IpAddressManagementPrefixDelegationCreatePrefixDelegationPathParams;
} & FetcherExtraProps;

/**
 * Create a new account delegation for a given IP prefix.
 */
export const ipAddressManagementPrefixDelegationCreatePrefixDelegation = (
  variables: IpAddressManagementPrefixDelegationCreatePrefixDelegationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingSchemasSingleResponse,
    IpAddressManagementPrefixDelegationCreatePrefixDelegationError,
    IpAddressManagementPrefixDelegationCreatePrefixDelegationRequestBody,
    {},
    {},
    IpAddressManagementPrefixDelegationCreatePrefixDelegationPathParams
  >({ url: '/accounts/{accountId}/addressing/prefixes/{prefixId}/delegations', method: 'post', ...variables, signal });

export type IpAddressManagementPrefixDelegationDeletePrefixDelegationPathParams = {
  delegationId: Schemas.AddressingDelegationIdentifier;
  prefixId: Schemas.AddressingPrefixIdentifier;
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementPrefixDelegationDeletePrefixDelegationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingIdResponse & Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementPrefixDelegationDeletePrefixDelegationVariables = {
  pathParams: IpAddressManagementPrefixDelegationDeletePrefixDelegationPathParams;
} & FetcherExtraProps;

/**
 * Delete an account delegation for a given IP prefix.
 */
export const ipAddressManagementPrefixDelegationDeletePrefixDelegation = (
  variables: IpAddressManagementPrefixDelegationDeletePrefixDelegationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AddressingIdResponse,
    IpAddressManagementPrefixDelegationDeletePrefixDelegationError,
    undefined,
    {},
    {},
    IpAddressManagementPrefixDelegationDeletePrefixDelegationPathParams
  >({
    url: '/accounts/{accountId}/addressing/prefixes/{prefixId}/delegations/{delegationId}',
    method: 'delete',
    ...variables,
    signal
  });

export type DlsAccountRegionalHostnamesAccountListRegionsPathParams = {
  accountId: Schemas.DlsIdentifier;
};

export type DlsAccountRegionalHostnamesAccountListRegionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlsApiResponseCommonFailure;
}>;

export type DlsAccountRegionalHostnamesAccountListRegionsResponse = Schemas.DlsApiResponseCollection & {
  result?: {
    key?: Schemas.DlsRegionKey;
    /**
     * Human-readable text label for the region
     *
     * @example Canada
     */
    label?: string;
  }[];
};

export type DlsAccountRegionalHostnamesAccountListRegionsVariables = {
  pathParams: DlsAccountRegionalHostnamesAccountListRegionsPathParams;
} & FetcherExtraProps;

/**
 * List all Regional Services regions available for use by this account.
 */
export const dlsAccountRegionalHostnamesAccountListRegions = (
  variables: DlsAccountRegionalHostnamesAccountListRegionsVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlsAccountRegionalHostnamesAccountListRegionsResponse,
    DlsAccountRegionalHostnamesAccountListRegionsError,
    undefined,
    {},
    {},
    DlsAccountRegionalHostnamesAccountListRegionsPathParams
  >({ url: '/accounts/{accountId}/addressing/regional_hostnames/regions', method: 'get', ...variables, signal });

export type IpAddressManagementServiceBindingsListServicesPathParams = {
  accountId: Schemas.AddressingAccountIdentifier;
};

export type IpAddressManagementServiceBindingsListServicesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AddressingApiResponseCommonFailure;
}>;

export type IpAddressManagementServiceBindingsListServicesResponse = Schemas.AddressingApiResponseCommon & {
  result?: {
    id?: Schemas.AddressingServiceIdentifier;
    name?: Schemas.AddressingServiceName;
  }[];
};

export type IpAddressManagementServiceBindingsListServicesVariables = {
  pathParams: IpAddressManagementServiceBindingsListServicesPathParams;
} & FetcherExtraProps;

/**
 * Bring-Your-Own IP (BYOIP) prefixes onboarded to Cloudflare must be bound to a service running on the Cloudflare network to enable a Cloudflare product on the IP addresses. This endpoint can be used as a reference of available services on the Cloudflare network, and their service IDs.
 */
export const ipAddressManagementServiceBindingsListServices = (
  variables: IpAddressManagementServiceBindingsListServicesVariables,
  signal?: AbortSignal
) =>
  fetch<
    IpAddressManagementServiceBindingsListServicesResponse,
    IpAddressManagementServiceBindingsListServicesError,
    undefined,
    {},
    {},
    IpAddressManagementServiceBindingsListServicesPathParams
  >({ url: '/accounts/{accountId}/addressing/services', method: 'get', ...variables, signal });

export type AigConfigListEvaluatorsPathParams = {
  /**
   * @example 0d37909e38d3e99c29fa2cd343ac421a
   */
  accountId: string;
};

export type AigConfigListEvaluatorsQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * @default mandatory
   */
  order_by?: string;
  /**
   * @default desc
   */
  order_by_direction?: 'asc' | 'desc';
};

export type AigConfigListEvaluatorsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type AigConfigListEvaluatorsResponse = {
  result: {
    /**
     * @format date-time
     */
    created_at: string;
    description: string;
    enable: boolean;
    id: string;
    mandatory: boolean;
    /**
     * @format date-time
     */
    modified_at: string;
    name: string;
    type: string;
  }[];
  result_info: {
    count: number;
    page: number;
    per_page: number;
    total_count: number;
  };
  success: boolean;
};

export type AigConfigListEvaluatorsVariables = {
  pathParams: AigConfigListEvaluatorsPathParams;
  queryParams?: AigConfigListEvaluatorsQueryParams;
} & FetcherExtraProps;

export const aigConfigListEvaluators = (variables: AigConfigListEvaluatorsVariables, signal?: AbortSignal) =>
  fetch<
    AigConfigListEvaluatorsResponse,
    AigConfigListEvaluatorsError,
    undefined,
    {},
    AigConfigListEvaluatorsQueryParams,
    AigConfigListEvaluatorsPathParams
  >({ url: '/accounts/{accountId}/ai-gateway/evaluation-types', method: 'get', ...variables, signal });

export type AigConfigListGatewayPathParams = {
  /**
   * @example 3ebbcb006d4d46d7bb6a8c7f14676cb0
   */
  accountId: string;
};

export type AigConfigListGatewayQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 100
   * @minimum 1
   */
  per_page?: number;
  search?: string;
};

export type AigConfigListGatewayError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type AigConfigListGatewayResponse = {
  result: {
    account_id: string;
    account_tag: string;
    cache_invalidate_on_update: boolean;
    /**
     * @minimum 0
     */
    cache_ttl: number | null;
    collect_logs: boolean;
    /**
     * @format date-time
     */
    created_at: string;
    /**
     * gateway id
     *
     * @example my-gateway
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
     */
    id: string;
    /**
     * @format uuid
     */
    internal_id: string;
    logpush?: boolean;
    /**
     * @maxLength 1024
     * @minLength 16
     */
    logpush_public_key?: string | null;
    /**
     * @format date-time
     */
    modified_at: string;
    /**
     * @minimum 0
     */
    rate_limiting_interval: number | null;
    /**
     * @minimum 0
     */
    rate_limiting_limit: number | null;
    rate_limiting_technique: 'fixed' | 'sliding';
  }[];
  success: boolean;
};

export type AigConfigListGatewayVariables = {
  pathParams: AigConfigListGatewayPathParams;
  queryParams?: AigConfigListGatewayQueryParams;
} & FetcherExtraProps;

export const aigConfigListGateway = (variables: AigConfigListGatewayVariables, signal?: AbortSignal) =>
  fetch<
    AigConfigListGatewayResponse,
    AigConfigListGatewayError,
    undefined,
    {},
    AigConfigListGatewayQueryParams,
    AigConfigListGatewayPathParams
  >({ url: '/accounts/{accountId}/ai-gateway/gateways', method: 'get', ...variables, signal });

export type AigConfigCreateGatewayPathParams = {
  /**
   * @example 3ebbcb006d4d46d7bb6a8c7f14676cb0
   */
  accountId: string;
};

export type AigConfigCreateGatewayError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      /**
       * @example 7001
       */
      code: number;
      /**
       * @example Input Validation Error
       */
      message: string;
      path: string[];
    }[];
    success: boolean;
  };
}>;

export type AigConfigCreateGatewayResponse = {
  result: {
    account_id: string;
    account_tag: string;
    cache_invalidate_on_update: boolean;
    /**
     * @minimum 0
     */
    cache_ttl: number | null;
    collect_logs: boolean;
    /**
     * @format date-time
     */
    created_at: string;
    /**
     * gateway id
     *
     * @example my-gateway
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
     */
    id: string;
    /**
     * @format uuid
     */
    internal_id: string;
    logpush?: boolean;
    /**
     * @maxLength 1024
     * @minLength 16
     */
    logpush_public_key?: string | null;
    /**
     * @format date-time
     */
    modified_at: string;
    /**
     * @minimum 0
     */
    rate_limiting_interval: number | null;
    /**
     * @minimum 0
     */
    rate_limiting_limit: number | null;
    rate_limiting_technique: 'fixed' | 'sliding';
  };
  success: boolean;
};

export type AigConfigCreateGatewayRequestBody = {
  cache_invalidate_on_update: boolean;
  /**
   * @minimum 0
   */
  cache_ttl: number | null;
  collect_logs: boolean;
  /**
   * gateway id
   *
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  id: string;
  logpush?: boolean;
  /**
   * @maxLength 1024
   * @minLength 16
   */
  logpush_public_key?: string | null;
  /**
   * @minimum 0
   */
  rate_limiting_interval: number | null;
  /**
   * @minimum 0
   */
  rate_limiting_limit: number | null;
  rate_limiting_technique: 'fixed' | 'sliding';
};

export type AigConfigCreateGatewayVariables = {
  body: AigConfigCreateGatewayRequestBody;
  pathParams: AigConfigCreateGatewayPathParams;
} & FetcherExtraProps;

export const aigConfigCreateGateway = (variables: AigConfigCreateGatewayVariables, signal?: AbortSignal) =>
  fetch<
    AigConfigCreateGatewayResponse,
    AigConfigCreateGatewayError,
    AigConfigCreateGatewayRequestBody,
    {},
    {},
    AigConfigCreateGatewayPathParams
  >({ url: '/accounts/{accountId}/ai-gateway/gateways', method: 'post', ...variables, signal });

export type AigConfigListDatasetPathParams = {
  /**
   * @example 3ebbcb006d4d46d7bb6a8c7f14676cb0
   */
  accountId: string;
  /**
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  gatewayId: string;
};

export type AigConfigListDatasetQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 100
   * @minimum 1
   */
  per_page?: number;
  name?: string;
  enable?: boolean;
  search?: string;
};

export type AigConfigListDatasetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type AigConfigListDatasetResponse = {
  result: {
    account_id: string;
    account_tag: string;
    /**
     * @format date-time
     */
    created_at: string;
    enable: boolean;
    filters: {
      key:
        | 'created_at'
        | 'request_content_type'
        | 'response_content_type'
        | 'success'
        | 'cached'
        | 'provider'
        | 'model'
        | 'cost'
        | 'tokens'
        | 'tokens_in'
        | 'tokens_out'
        | 'duration'
        | 'feedback';
      operator: 'eq' | 'contains' | 'lt' | 'gt';
      value: (string | number | boolean)[];
    }[];
    /**
     * gateway id
     *
     * @example my-gateway
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
     */
    gateway_id: string;
    id: string;
    /**
     * @format date-time
     */
    modified_at: string;
    name: string;
  }[];
  success: boolean;
};

export type AigConfigListDatasetVariables = {
  pathParams: AigConfigListDatasetPathParams;
  queryParams?: AigConfigListDatasetQueryParams;
} & FetcherExtraProps;

export const aigConfigListDataset = (variables: AigConfigListDatasetVariables, signal?: AbortSignal) =>
  fetch<
    AigConfigListDatasetResponse,
    AigConfigListDatasetError,
    undefined,
    {},
    AigConfigListDatasetQueryParams,
    AigConfigListDatasetPathParams
  >({ url: '/accounts/{accountId}/ai-gateway/gateways/{gatewayId}/datasets', method: 'get', ...variables, signal });

export type AigConfigCreateDatasetPathParams = {
  /**
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  gatewayId: string;
  /**
   * @example 3ebbcb006d4d46d7bb6a8c7f14676cb0
   */
  accountId: string;
};

export type AigConfigCreateDatasetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      /**
       * @example 7001
       */
      code: number;
      /**
       * @example Input Validation Error
       */
      message: string;
      path: string[];
    }[];
    success: boolean;
  };
}>;

export type AigConfigCreateDatasetResponse = {
  result: {
    account_id: string;
    account_tag: string;
    /**
     * @format date-time
     */
    created_at: string;
    enable: boolean;
    filters: {
      key:
        | 'created_at'
        | 'request_content_type'
        | 'response_content_type'
        | 'success'
        | 'cached'
        | 'provider'
        | 'model'
        | 'cost'
        | 'tokens'
        | 'tokens_in'
        | 'tokens_out'
        | 'duration'
        | 'feedback';
      operator: 'eq' | 'contains' | 'lt' | 'gt';
      value: (string | number | boolean)[];
    }[];
    /**
     * gateway id
     *
     * @example my-gateway
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
     */
    gateway_id: string;
    id: string;
    /**
     * @format date-time
     */
    modified_at: string;
    name: string;
  };
  success: boolean;
};

export type AigConfigCreateDatasetRequestBody = {
  enable: boolean;
  filters: {
    key:
      | 'created_at'
      | 'request_content_type'
      | 'response_content_type'
      | 'success'
      | 'cached'
      | 'provider'
      | 'model'
      | 'cost'
      | 'tokens'
      | 'tokens_in'
      | 'tokens_out'
      | 'duration'
      | 'feedback';
    operator: 'eq' | 'contains' | 'lt' | 'gt';
    value: (string | number | boolean)[];
  }[];
  name: string;
};

export type AigConfigCreateDatasetVariables = {
  body: AigConfigCreateDatasetRequestBody;
  pathParams: AigConfigCreateDatasetPathParams;
} & FetcherExtraProps;

export const aigConfigCreateDataset = (variables: AigConfigCreateDatasetVariables, signal?: AbortSignal) =>
  fetch<
    AigConfigCreateDatasetResponse,
    AigConfigCreateDatasetError,
    AigConfigCreateDatasetRequestBody,
    {},
    {},
    AigConfigCreateDatasetPathParams
  >({ url: '/accounts/{accountId}/ai-gateway/gateways/{gatewayId}/datasets', method: 'post', ...variables, signal });

export type AigConfigDeleteDatasetPathParams = {
  /**
   * @example 3ebbcb006d4d46d7bb6a8c7f14676cb0
   */
  accountId: string;
  /**
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  gatewayId: string;
  id: string;
};

export type AigConfigDeleteDatasetError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    errors: {
      /**
       * @example 7002
       */
      code: number;
      /**
       * @example Not Found
       */
      message: string;
    }[];
    success: boolean;
  };
}>;

export type AigConfigDeleteDatasetResponse = {
  result: {
    account_id: string;
    account_tag: string;
    /**
     * @format date-time
     */
    created_at: string;
    enable: boolean;
    filters: {
      key:
        | 'created_at'
        | 'request_content_type'
        | 'response_content_type'
        | 'success'
        | 'cached'
        | 'provider'
        | 'model'
        | 'cost'
        | 'tokens'
        | 'tokens_in'
        | 'tokens_out'
        | 'duration'
        | 'feedback';
      operator: 'eq' | 'contains' | 'lt' | 'gt';
      value: (string | number | boolean)[];
    }[];
    /**
     * gateway id
     *
     * @example my-gateway
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
     */
    gateway_id: string;
    id: string;
    /**
     * @format date-time
     */
    modified_at: string;
    name: string;
  };
  success: boolean;
};

export type AigConfigDeleteDatasetVariables = {
  pathParams: AigConfigDeleteDatasetPathParams;
} & FetcherExtraProps;

export const aigConfigDeleteDataset = (variables: AigConfigDeleteDatasetVariables, signal?: AbortSignal) =>
  fetch<
    AigConfigDeleteDatasetResponse,
    AigConfigDeleteDatasetError,
    undefined,
    {},
    {},
    AigConfigDeleteDatasetPathParams
  >({
    url: '/accounts/{accountId}/ai-gateway/gateways/{gatewayId}/datasets/{id}',
    method: 'delete',
    ...variables,
    signal
  });

export type AigConfigFetchDatasetPathParams = {
  /**
   * @example 3ebbcb006d4d46d7bb6a8c7f14676cb0
   */
  accountId: string;
  /**
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  gatewayId: string;
  id: string;
};

export type AigConfigFetchDatasetError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    errors: {
      /**
       * @example 7002
       */
      code: number;
      /**
       * @example Not Found
       */
      message: string;
    }[];
    success: boolean;
  };
}>;

export type AigConfigFetchDatasetResponse = {
  result: {
    account_id: string;
    account_tag: string;
    /**
     * @format date-time
     */
    created_at: string;
    enable: boolean;
    filters: {
      key:
        | 'created_at'
        | 'request_content_type'
        | 'response_content_type'
        | 'success'
        | 'cached'
        | 'provider'
        | 'model'
        | 'cost'
        | 'tokens'
        | 'tokens_in'
        | 'tokens_out'
        | 'duration'
        | 'feedback';
      operator: 'eq' | 'contains' | 'lt' | 'gt';
      value: (string | number | boolean)[];
    }[];
    /**
     * gateway id
     *
     * @example my-gateway
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
     */
    gateway_id: string;
    id: string;
    /**
     * @format date-time
     */
    modified_at: string;
    name: string;
  };
  success: boolean;
};

export type AigConfigFetchDatasetVariables = {
  pathParams: AigConfigFetchDatasetPathParams;
} & FetcherExtraProps;

export const aigConfigFetchDataset = (variables: AigConfigFetchDatasetVariables, signal?: AbortSignal) =>
  fetch<AigConfigFetchDatasetResponse, AigConfigFetchDatasetError, undefined, {}, {}, AigConfigFetchDatasetPathParams>({
    url: '/accounts/{accountId}/ai-gateway/gateways/{gatewayId}/datasets/{id}',
    method: 'get',
    ...variables,
    signal
  });

export type AigConfigUpdateDatasetPathParams = {
  /**
   * @example 3ebbcb006d4d46d7bb6a8c7f14676cb0
   */
  accountId: string;
  /**
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  gatewayId: string;
  id: string;
};

export type AigConfigUpdateDatasetError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          /**
           * @example 7001
           */
          code: number;
          /**
           * @example Input Validation Error
           */
          message: string;
          path: string[];
        }[];
        success: boolean;
      };
    }
  | {
      status: 404;
      payload: {
        errors: {
          /**
           * @example 7002
           */
          code: number;
          /**
           * @example Not Found
           */
          message: string;
        }[];
        success: boolean;
      };
    }
>;

export type AigConfigUpdateDatasetResponse = {
  result: {
    account_id: string;
    account_tag: string;
    /**
     * @format date-time
     */
    created_at: string;
    enable: boolean;
    filters: {
      key:
        | 'created_at'
        | 'request_content_type'
        | 'response_content_type'
        | 'success'
        | 'cached'
        | 'provider'
        | 'model'
        | 'cost'
        | 'tokens'
        | 'tokens_in'
        | 'tokens_out'
        | 'duration'
        | 'feedback';
      operator: 'eq' | 'contains' | 'lt' | 'gt';
      value: (string | number | boolean)[];
    }[];
    /**
     * gateway id
     *
     * @example my-gateway
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
     */
    gateway_id: string;
    id: string;
    /**
     * @format date-time
     */
    modified_at: string;
    name: string;
  };
  success: boolean;
};

export type AigConfigUpdateDatasetRequestBody = {
  enable: boolean;
  filters: {
    key:
      | 'created_at'
      | 'request_content_type'
      | 'response_content_type'
      | 'success'
      | 'cached'
      | 'provider'
      | 'model'
      | 'cost'
      | 'tokens'
      | 'tokens_in'
      | 'tokens_out'
      | 'duration'
      | 'feedback';
    operator: 'eq' | 'contains' | 'lt' | 'gt';
    value: (string | number | boolean)[];
  }[];
  name: string;
};

export type AigConfigUpdateDatasetVariables = {
  body: AigConfigUpdateDatasetRequestBody;
  pathParams: AigConfigUpdateDatasetPathParams;
} & FetcherExtraProps;

export const aigConfigUpdateDataset = (variables: AigConfigUpdateDatasetVariables, signal?: AbortSignal) =>
  fetch<
    AigConfigUpdateDatasetResponse,
    AigConfigUpdateDatasetError,
    AigConfigUpdateDatasetRequestBody,
    {},
    {},
    AigConfigUpdateDatasetPathParams
  >({
    url: '/accounts/{accountId}/ai-gateway/gateways/{gatewayId}/datasets/{id}',
    method: 'put',
    ...variables,
    signal
  });

export type AigConfigListEvaluationsPathParams = {
  /**
   * @example 3ebbcb006d4d46d7bb6a8c7f14676cb0
   */
  accountId: string;
  /**
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  gatewayId: string;
};

export type AigConfigListEvaluationsQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 100
   * @minimum 1
   */
  per_page?: number;
  name?: string;
  processed?: boolean;
  search?: string;
};

export type AigConfigListEvaluationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type AigConfigListEvaluationsResponse = {
  result: {
    account_id: string;
    account_tag: string;
    /**
     * @format date-time
     */
    created_at: string;
    datasets: {
      account_id: string;
      account_tag: string;
      /**
       * @format date-time
       */
      created_at: string;
      enable: boolean;
      filters: {
        key:
          | 'created_at'
          | 'request_content_type'
          | 'response_content_type'
          | 'success'
          | 'cached'
          | 'provider'
          | 'model'
          | 'cost'
          | 'tokens'
          | 'tokens_in'
          | 'tokens_out'
          | 'duration'
          | 'feedback';
        operator: 'eq' | 'contains' | 'lt' | 'gt';
        value: (string | number | boolean)[];
      }[];
      /**
       * gateway id
       *
       * @example my-gateway
       * @maxLength 64
       * @minLength 1
       * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
       */
      gateway_id: string;
      id: string;
      /**
       * @format date-time
       */
      modified_at: string;
      name: string;
    }[];
    /**
     * gateway id
     *
     * @example my-gateway
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
     */
    gateway_id: string;
    id: string;
    /**
     * @format date-time
     */
    modified_at: string;
    name: string;
    processed: boolean;
    results: {
      /**
       * @format date-time
       */
      created_at: string;
      evaluation_id: string;
      evaluation_type_id: string;
      id: string;
      /**
       * @format date-time
       */
      modified_at: string;
      result: string;
      status: number;
      status_description: string;
      total_logs: number;
    }[];
    total_logs: number;
  }[];
  success: boolean;
};

export type AigConfigListEvaluationsVariables = {
  pathParams: AigConfigListEvaluationsPathParams;
  queryParams?: AigConfigListEvaluationsQueryParams;
} & FetcherExtraProps;

export const aigConfigListEvaluations = (variables: AigConfigListEvaluationsVariables, signal?: AbortSignal) =>
  fetch<
    AigConfigListEvaluationsResponse,
    AigConfigListEvaluationsError,
    undefined,
    {},
    AigConfigListEvaluationsQueryParams,
    AigConfigListEvaluationsPathParams
  >({ url: '/accounts/{accountId}/ai-gateway/gateways/{gatewayId}/evaluations', method: 'get', ...variables, signal });

export type AigConfigCreateEvaluationsPathParams = {
  /**
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  gatewayId: string;
  /**
   * @example 3ebbcb006d4d46d7bb6a8c7f14676cb0
   */
  accountId: string;
};

export type AigConfigCreateEvaluationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      /**
       * @example 7001
       */
      code: number;
      /**
       * @example Input Validation Error
       */
      message: string;
      path: string[];
    }[];
    success: boolean;
  };
}>;

export type AigConfigCreateEvaluationsResponse = {
  result: {
    account_id: string;
    account_tag: string;
    /**
     * @format date-time
     */
    created_at: string;
    datasets: {
      account_id: string;
      account_tag: string;
      /**
       * @format date-time
       */
      created_at: string;
      enable: boolean;
      filters: {
        key:
          | 'created_at'
          | 'request_content_type'
          | 'response_content_type'
          | 'success'
          | 'cached'
          | 'provider'
          | 'model'
          | 'cost'
          | 'tokens'
          | 'tokens_in'
          | 'tokens_out'
          | 'duration'
          | 'feedback';
        operator: 'eq' | 'contains' | 'lt' | 'gt';
        value: (string | number | boolean)[];
      }[];
      /**
       * gateway id
       *
       * @example my-gateway
       * @maxLength 64
       * @minLength 1
       * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
       */
      gateway_id: string;
      id: string;
      /**
       * @format date-time
       */
      modified_at: string;
      name: string;
    }[];
    /**
     * gateway id
     *
     * @example my-gateway
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
     */
    gateway_id: string;
    id: string;
    /**
     * @format date-time
     */
    modified_at: string;
    name: string;
    processed: boolean;
    results: {
      /**
       * @format date-time
       */
      created_at: string;
      evaluation_id: string;
      evaluation_type_id: string;
      id: string;
      /**
       * @format date-time
       */
      modified_at: string;
      result: string;
      status: number;
      status_description: string;
      total_logs: number;
    }[];
    total_logs: number;
  };
  success: boolean;
};

export type AigConfigCreateEvaluationsRequestBody = {
  /**
   * @maxItems 5
   * @minItems 1
   */
  dataset_ids: string[];
  evaluation_type_ids: string[];
  name: string;
};

export type AigConfigCreateEvaluationsVariables = {
  body: AigConfigCreateEvaluationsRequestBody;
  pathParams: AigConfigCreateEvaluationsPathParams;
} & FetcherExtraProps;

export const aigConfigCreateEvaluations = (variables: AigConfigCreateEvaluationsVariables, signal?: AbortSignal) =>
  fetch<
    AigConfigCreateEvaluationsResponse,
    AigConfigCreateEvaluationsError,
    AigConfigCreateEvaluationsRequestBody,
    {},
    {},
    AigConfigCreateEvaluationsPathParams
  >({ url: '/accounts/{accountId}/ai-gateway/gateways/{gatewayId}/evaluations', method: 'post', ...variables, signal });

export type AigConfigDeleteEvaluationsPathParams = {
  /**
   * @example 3ebbcb006d4d46d7bb6a8c7f14676cb0
   */
  accountId: string;
  /**
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  gatewayId: string;
  id: string;
};

export type AigConfigDeleteEvaluationsError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    errors: {
      /**
       * @example 7002
       */
      code: number;
      /**
       * @example Not Found
       */
      message: string;
    }[];
    success: boolean;
  };
}>;

export type AigConfigDeleteEvaluationsResponse = {
  result: {
    account_id: string;
    account_tag: string;
    /**
     * @format date-time
     */
    created_at: string;
    datasets: {
      account_id: string;
      account_tag: string;
      /**
       * @format date-time
       */
      created_at: string;
      enable: boolean;
      filters: {
        key:
          | 'created_at'
          | 'request_content_type'
          | 'response_content_type'
          | 'success'
          | 'cached'
          | 'provider'
          | 'model'
          | 'cost'
          | 'tokens'
          | 'tokens_in'
          | 'tokens_out'
          | 'duration'
          | 'feedback';
        operator: 'eq' | 'contains' | 'lt' | 'gt';
        value: (string | number | boolean)[];
      }[];
      /**
       * gateway id
       *
       * @example my-gateway
       * @maxLength 64
       * @minLength 1
       * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
       */
      gateway_id: string;
      id: string;
      /**
       * @format date-time
       */
      modified_at: string;
      name: string;
    }[];
    /**
     * gateway id
     *
     * @example my-gateway
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
     */
    gateway_id: string;
    id: string;
    /**
     * @format date-time
     */
    modified_at: string;
    name: string;
    processed: boolean;
    results: {
      /**
       * @format date-time
       */
      created_at: string;
      evaluation_id: string;
      evaluation_type_id: string;
      id: string;
      /**
       * @format date-time
       */
      modified_at: string;
      result: string;
      status: number;
      status_description: string;
      total_logs: number;
    }[];
    total_logs: number;
  };
  success: boolean;
};

export type AigConfigDeleteEvaluationsVariables = {
  pathParams: AigConfigDeleteEvaluationsPathParams;
} & FetcherExtraProps;

export const aigConfigDeleteEvaluations = (variables: AigConfigDeleteEvaluationsVariables, signal?: AbortSignal) =>
  fetch<
    AigConfigDeleteEvaluationsResponse,
    AigConfigDeleteEvaluationsError,
    undefined,
    {},
    {},
    AigConfigDeleteEvaluationsPathParams
  >({
    url: '/accounts/{accountId}/ai-gateway/gateways/{gatewayId}/evaluations/{id}',
    method: 'delete',
    ...variables,
    signal
  });

export type AigConfigFetchEvaluationsPathParams = {
  /**
   * @example 3ebbcb006d4d46d7bb6a8c7f14676cb0
   */
  accountId: string;
  /**
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  gatewayId: string;
  id: string;
};

export type AigConfigFetchEvaluationsError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    errors: {
      /**
       * @example 7002
       */
      code: number;
      /**
       * @example Not Found
       */
      message: string;
    }[];
    success: boolean;
  };
}>;

export type AigConfigFetchEvaluationsResponse = {
  result: {
    account_id: string;
    account_tag: string;
    /**
     * @format date-time
     */
    created_at: string;
    datasets: {
      account_id: string;
      account_tag: string;
      /**
       * @format date-time
       */
      created_at: string;
      enable: boolean;
      filters: {
        key:
          | 'created_at'
          | 'request_content_type'
          | 'response_content_type'
          | 'success'
          | 'cached'
          | 'provider'
          | 'model'
          | 'cost'
          | 'tokens'
          | 'tokens_in'
          | 'tokens_out'
          | 'duration'
          | 'feedback';
        operator: 'eq' | 'contains' | 'lt' | 'gt';
        value: (string | number | boolean)[];
      }[];
      /**
       * gateway id
       *
       * @example my-gateway
       * @maxLength 64
       * @minLength 1
       * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
       */
      gateway_id: string;
      id: string;
      /**
       * @format date-time
       */
      modified_at: string;
      name: string;
    }[];
    /**
     * gateway id
     *
     * @example my-gateway
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
     */
    gateway_id: string;
    id: string;
    /**
     * @format date-time
     */
    modified_at: string;
    name: string;
    processed: boolean;
    results: {
      /**
       * @format date-time
       */
      created_at: string;
      evaluation_id: string;
      evaluation_type_id: string;
      id: string;
      /**
       * @format date-time
       */
      modified_at: string;
      result: string;
      status: number;
      status_description: string;
      total_logs: number;
    }[];
    total_logs: number;
  };
  success: boolean;
};

export type AigConfigFetchEvaluationsVariables = {
  pathParams: AigConfigFetchEvaluationsPathParams;
} & FetcherExtraProps;

export const aigConfigFetchEvaluations = (variables: AigConfigFetchEvaluationsVariables, signal?: AbortSignal) =>
  fetch<
    AigConfigFetchEvaluationsResponse,
    AigConfigFetchEvaluationsError,
    undefined,
    {},
    {},
    AigConfigFetchEvaluationsPathParams
  >({
    url: '/accounts/{accountId}/ai-gateway/gateways/{gatewayId}/evaluations/{id}',
    method: 'get',
    ...variables,
    signal
  });

export type AigConfigDeleteGatewayLogsPathParams = {
  /**
   * @example 0d37909e38d3e99c29fa2cd343ac421a
   */
  accountId: string;
  /**
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  gatewayId: string;
};

export type AigConfigDeleteGatewayLogsQueryParams = {
  /**
   * @default created_at
   */
  order_by?:
    | 'created_at'
    | 'provider'
    | 'model'
    | 'model_type'
    | 'success'
    | 'cached'
    | 'cost'
    | 'tokens_in'
    | 'tokens_out'
    | 'duration'
    | 'feedback';
  /**
   * @default asc
   */
  order_by_direction?: 'asc' | 'desc';
  filters?: {
    key:
      | 'id'
      | 'created_at'
      | 'request_content_type'
      | 'response_content_type'
      | 'success'
      | 'cached'
      | 'provider'
      | 'model'
      | 'model_type'
      | 'cost'
      | 'tokens'
      | 'tokens_in'
      | 'tokens_out'
      | 'duration'
      | 'feedback'
      | 'event_id'
      | 'request_type'
      | 'metadata.key'
      | 'metadata.value';
    operator: 'eq' | 'neq' | 'contains' | 'lt' | 'gt';
    value: ((string | null) | number | boolean)[];
  }[];
  /**
   * @default 10000
   * @maximum 10000
   * @minimum 1
   */
  limit?: number;
};

export type AigConfigDeleteGatewayLogsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type AigConfigDeleteGatewayLogsResponse = {
  success: boolean;
};

export type AigConfigDeleteGatewayLogsVariables = {
  pathParams: AigConfigDeleteGatewayLogsPathParams;
  queryParams?: AigConfigDeleteGatewayLogsQueryParams;
} & FetcherExtraProps;

export const aigConfigDeleteGatewayLogs = (variables: AigConfigDeleteGatewayLogsVariables, signal?: AbortSignal) =>
  fetch<
    AigConfigDeleteGatewayLogsResponse,
    AigConfigDeleteGatewayLogsError,
    undefined,
    {},
    AigConfigDeleteGatewayLogsQueryParams,
    AigConfigDeleteGatewayLogsPathParams
  >({ url: '/accounts/{accountId}/ai-gateway/gateways/{gatewayId}/logs', method: 'delete', ...variables, signal });

export type AigConfigListGatewayLogsPathParams = {
  /**
   * @example 0d37909e38d3e99c29fa2cd343ac421a
   */
  accountId: string;
  /**
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  gatewayId: string;
};

export type AigConfigListGatewayLogsQueryParams = {
  search?: string;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 50
   * @minimum 1
   */
  per_page?: number;
  /**
   * @default created_at
   */
  order_by?: 'created_at' | 'provider' | 'model' | 'model_type' | 'success' | 'cached';
  /**
   * @default desc
   */
  order_by_direction?: 'asc' | 'desc';
  filters?: {
    key:
      | 'id'
      | 'created_at'
      | 'request_content_type'
      | 'response_content_type'
      | 'success'
      | 'cached'
      | 'provider'
      | 'model'
      | 'model_type'
      | 'cost'
      | 'tokens'
      | 'tokens_in'
      | 'tokens_out'
      | 'duration'
      | 'feedback'
      | 'event_id'
      | 'request_type'
      | 'metadata.key'
      | 'metadata.value';
    operator: 'eq' | 'neq' | 'contains' | 'lt' | 'gt';
    value: ((string | null) | number | boolean)[];
  }[];
  meta_info?: boolean;
  /**
   * @deprecated true
   */
  direction?: 'asc' | 'desc';
  /**
   * @deprecated true
   * @format date-time
   */
  start_date?: string;
  /**
   * @deprecated true
   * @format date-time
   */
  end_date?: string;
  /**
   * @deprecated true
   */
  min_cost?: number;
  /**
   * @deprecated true
   */
  max_cost?: number;
  /**
   * @deprecated true
   */
  min_tokens_in?: number;
  /**
   * @deprecated true
   */
  max_tokens_in?: number;
  /**
   * @deprecated true
   */
  min_tokens_out?: number;
  /**
   * @deprecated true
   */
  max_tokens_out?: number;
  /**
   * @deprecated true
   */
  min_total_tokens?: number;
  /**
   * @deprecated true
   */
  max_total_tokens?: number;
  /**
   * @deprecated true
   */
  min_duration?: number;
  /**
   * @deprecated true
   */
  max_duration?: number;
  /**
   * @deprecated true
   */
  feedback?: -1 | 0 | 1;
  /**
   * @deprecated true
   */
  success?: boolean;
  /**
   * @deprecated true
   */
  cached?: boolean;
  /**
   * @deprecated true
   */
  model?: string;
  /**
   * @deprecated true
   */
  model_type?: string;
  /**
   * @deprecated true
   */
  provider?: string;
  /**
   * @deprecated true
   */
  request_content_type?: string;
  /**
   * @deprecated true
   */
  response_content_type?: string;
};

export type AigConfigListGatewayLogsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type AigConfigListGatewayLogsResponse = {
  result: {
    cached: boolean;
    cost?: number;
    /**
     * @format date-time
     */
    created_at: string;
    custom_cost?: boolean;
    duration: number;
    id: string;
    metadata?: string;
    model: string;
    model_type?: string;
    path: string;
    provider: string;
    request_content_type?: string;
    request_type?: string;
    response_content_type?: string;
    status_code?: number;
    step?: number;
    success: boolean;
    tokens_in: number | null;
    tokens_out: number | null;
  }[];
  result_info: {
    count?: number;
    max_cost?: number;
    max_duration?: number;
    max_tokens_in?: number;
    max_tokens_out?: number;
    max_total_tokens?: number;
    min_cost?: number;
    min_duration?: number;
    min_tokens_in?: number;
    min_tokens_out?: number;
    min_total_tokens?: number;
    page?: number;
    per_page?: number;
    total_count?: number;
  };
  success: boolean;
};

export type AigConfigListGatewayLogsVariables = {
  pathParams: AigConfigListGatewayLogsPathParams;
  queryParams?: AigConfigListGatewayLogsQueryParams;
} & FetcherExtraProps;

export const aigConfigListGatewayLogs = (variables: AigConfigListGatewayLogsVariables, signal?: AbortSignal) =>
  fetch<
    AigConfigListGatewayLogsResponse,
    AigConfigListGatewayLogsError,
    undefined,
    {},
    AigConfigListGatewayLogsQueryParams,
    AigConfigListGatewayLogsPathParams
  >({ url: '/accounts/{accountId}/ai-gateway/gateways/{gatewayId}/logs', method: 'get', ...variables, signal });

export type AigConfigGetGatewayLogDetailPathParams = {
  id: string;
  /**
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  gatewayId: string;
  /**
   * @example 0d37909e38d3e99c29fa2cd343ac421a
   */
  accountId: string;
};

export type AigConfigGetGatewayLogDetailError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    errors: {
      /**
       * @example 7002
       */
      code: number;
      /**
       * @example Not Found
       */
      message: string;
    }[];
    success: boolean;
  };
}>;

export type AigConfigGetGatewayLogDetailResponse = {
  result: {
    cached: boolean;
    cost?: number;
    /**
     * @format date-time
     */
    created_at: string;
    custom_cost?: boolean;
    duration: number;
    id: string;
    metadata?: string;
    model: string;
    model_type?: string;
    path: string;
    provider: string;
    request_content_type?: string;
    request_head?: string;
    request_head_complete?: boolean;
    request_size?: number;
    request_type?: string;
    response_content_type?: string;
    response_head?: string;
    response_head_complete?: boolean;
    response_size?: number;
    status_code?: number;
    step?: number;
    success: boolean;
    tokens_in: number | null;
    tokens_out: number | null;
  };
  success: boolean;
};

export type AigConfigGetGatewayLogDetailVariables = {
  pathParams: AigConfigGetGatewayLogDetailPathParams;
} & FetcherExtraProps;

export const aigConfigGetGatewayLogDetail = (variables: AigConfigGetGatewayLogDetailVariables, signal?: AbortSignal) =>
  fetch<
    AigConfigGetGatewayLogDetailResponse,
    AigConfigGetGatewayLogDetailError,
    undefined,
    {},
    {},
    AigConfigGetGatewayLogDetailPathParams
  >({ url: '/accounts/{accountId}/ai-gateway/gateways/{gatewayId}/logs/{id}', method: 'get', ...variables, signal });

export type AigConfigPatchGatewayLogPathParams = {
  id: string;
  /**
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  gatewayId: string;
  /**
   * @example 0d37909e38d3e99c29fa2cd343ac421a
   */
  accountId: string;
};

export type AigConfigPatchGatewayLogError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    errors: {
      /**
       * @example 7002
       */
      code: number;
      /**
       * @example Not Found
       */
      message: string;
    }[];
    success: boolean;
  };
}>;

export type AigConfigPatchGatewayLogResponse = {
  result: Record<string, any>;
  success: boolean;
};

export type AigConfigPatchGatewayLogRequestBody = {
  /**
   * @maximum 1
   * @minimum -1
   */
  feedback?: number | null;
  metadata?: {
    [key: string]: string | number | boolean;
  } | null;
  /**
   * @maximum 100
   * @minimum 0
   */
  score?: number | null;
};

export type AigConfigPatchGatewayLogVariables = {
  body?: AigConfigPatchGatewayLogRequestBody;
  pathParams: AigConfigPatchGatewayLogPathParams;
} & FetcherExtraProps;

export const aigConfigPatchGatewayLog = (variables: AigConfigPatchGatewayLogVariables, signal?: AbortSignal) =>
  fetch<
    AigConfigPatchGatewayLogResponse,
    AigConfigPatchGatewayLogError,
    AigConfigPatchGatewayLogRequestBody,
    {},
    {},
    AigConfigPatchGatewayLogPathParams
  >({ url: '/accounts/{accountId}/ai-gateway/gateways/{gatewayId}/logs/{id}', method: 'patch', ...variables, signal });

export type AigConfigGetGatewayLogRequestPathParams = {
  id: string;
  /**
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  gatewayId: string;
  /**
   * @example 0d37909e38d3e99c29fa2cd343ac421a
   */
  accountId: string;
};

export type AigConfigGetGatewayLogRequestError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    errors: {
      /**
       * @example 7002
       */
      code: number;
      /**
       * @example Not Found
       */
      message: string;
    }[];
    success: boolean;
  };
}>;

export type AigConfigGetGatewayLogRequestVariables = {
  pathParams: AigConfigGetGatewayLogRequestPathParams;
} & FetcherExtraProps;

export const aigConfigGetGatewayLogRequest = (
  variables: AigConfigGetGatewayLogRequestVariables,
  signal?: AbortSignal
) =>
  fetch<
    Record<string, any>,
    AigConfigGetGatewayLogRequestError,
    undefined,
    {},
    {},
    AigConfigGetGatewayLogRequestPathParams
  >({
    url: '/accounts/{accountId}/ai-gateway/gateways/{gatewayId}/logs/{id}/request',
    method: 'get',
    ...variables,
    signal
  });

export type AigConfigGetGatewayLogResponsePathParams = {
  id: string;
  /**
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  gatewayId: string;
  /**
   * @example 0d37909e38d3e99c29fa2cd343ac421a
   */
  accountId: string;
};

export type AigConfigGetGatewayLogResponseError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    errors: {
      /**
       * @example 7002
       */
      code: number;
      /**
       * @example Not Found
       */
      message: string;
    }[];
    success: boolean;
  };
}>;

export type AigConfigGetGatewayLogResponseVariables = {
  pathParams: AigConfigGetGatewayLogResponsePathParams;
} & FetcherExtraProps;

export const aigConfigGetGatewayLogResponse = (
  variables: AigConfigGetGatewayLogResponseVariables,
  signal?: AbortSignal
) =>
  fetch<
    Record<string, any>,
    AigConfigGetGatewayLogResponseError,
    undefined,
    {},
    {},
    AigConfigGetGatewayLogResponsePathParams
  >({
    url: '/accounts/{accountId}/ai-gateway/gateways/{gatewayId}/logs/{id}/response',
    method: 'get',
    ...variables,
    signal
  });

export type AigConfigDeleteGatewayPathParams = {
  /**
   * @example 3ebbcb006d4d46d7bb6a8c7f14676cb0
   */
  accountId: string;
  /**
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  id: string;
};

export type AigConfigDeleteGatewayError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    errors: {
      /**
       * @example 7002
       */
      code: number;
      /**
       * @example Not Found
       */
      message: string;
    }[];
    success: boolean;
  };
}>;

export type AigConfigDeleteGatewayResponse = {
  result: {
    account_id: string;
    account_tag: string;
    cache_invalidate_on_update: boolean;
    /**
     * @minimum 0
     */
    cache_ttl: number | null;
    collect_logs: boolean;
    /**
     * @format date-time
     */
    created_at: string;
    /**
     * gateway id
     *
     * @example my-gateway
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
     */
    id: string;
    /**
     * @format uuid
     */
    internal_id: string;
    logpush?: boolean;
    /**
     * @maxLength 1024
     * @minLength 16
     */
    logpush_public_key?: string | null;
    /**
     * @format date-time
     */
    modified_at: string;
    /**
     * @minimum 0
     */
    rate_limiting_interval: number | null;
    /**
     * @minimum 0
     */
    rate_limiting_limit: number | null;
    rate_limiting_technique: 'fixed' | 'sliding';
  };
  success: boolean;
};

export type AigConfigDeleteGatewayVariables = {
  pathParams: AigConfigDeleteGatewayPathParams;
} & FetcherExtraProps;

export const aigConfigDeleteGateway = (variables: AigConfigDeleteGatewayVariables, signal?: AbortSignal) =>
  fetch<
    AigConfigDeleteGatewayResponse,
    AigConfigDeleteGatewayError,
    undefined,
    {},
    {},
    AigConfigDeleteGatewayPathParams
  >({ url: '/accounts/{accountId}/ai-gateway/gateways/{id}', method: 'delete', ...variables, signal });

export type AigConfigFetchGatewayPathParams = {
  /**
   * @example 3ebbcb006d4d46d7bb6a8c7f14676cb0
   */
  accountId: string;
  /**
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  id: string;
};

export type AigConfigFetchGatewayError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    errors: {
      /**
       * @example 7002
       */
      code: number;
      /**
       * @example Not Found
       */
      message: string;
    }[];
    success: boolean;
  };
}>;

export type AigConfigFetchGatewayResponse = {
  result: {
    account_id: string;
    account_tag: string;
    cache_invalidate_on_update: boolean;
    /**
     * @minimum 0
     */
    cache_ttl: number | null;
    collect_logs: boolean;
    /**
     * @format date-time
     */
    created_at: string;
    /**
     * gateway id
     *
     * @example my-gateway
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
     */
    id: string;
    /**
     * @format uuid
     */
    internal_id: string;
    logpush?: boolean;
    /**
     * @maxLength 1024
     * @minLength 16
     */
    logpush_public_key?: string | null;
    /**
     * @format date-time
     */
    modified_at: string;
    /**
     * @minimum 0
     */
    rate_limiting_interval: number | null;
    /**
     * @minimum 0
     */
    rate_limiting_limit: number | null;
    rate_limiting_technique: 'fixed' | 'sliding';
  };
  success: boolean;
};

export type AigConfigFetchGatewayVariables = {
  pathParams: AigConfigFetchGatewayPathParams;
} & FetcherExtraProps;

export const aigConfigFetchGateway = (variables: AigConfigFetchGatewayVariables, signal?: AbortSignal) =>
  fetch<AigConfigFetchGatewayResponse, AigConfigFetchGatewayError, undefined, {}, {}, AigConfigFetchGatewayPathParams>({
    url: '/accounts/{accountId}/ai-gateway/gateways/{id}',
    method: 'get',
    ...variables,
    signal
  });

export type AigConfigUpdateGatewayPathParams = {
  /**
   * @example 3ebbcb006d4d46d7bb6a8c7f14676cb0
   */
  accountId: string;
  /**
   * @example my-gateway
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  id: string;
};

export type AigConfigUpdateGatewayError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          /**
           * @example 7001
           */
          code: number;
          /**
           * @example Input Validation Error
           */
          message: string;
          path: string[];
        }[];
        success: boolean;
      };
    }
  | {
      status: 404;
      payload: {
        errors: {
          /**
           * @example 7002
           */
          code: number;
          /**
           * @example Not Found
           */
          message: string;
        }[];
        success: boolean;
      };
    }
>;

export type AigConfigUpdateGatewayResponse = {
  result: {
    account_id: string;
    account_tag: string;
    cache_invalidate_on_update: boolean;
    /**
     * @minimum 0
     */
    cache_ttl: number | null;
    collect_logs: boolean;
    /**
     * @format date-time
     */
    created_at: string;
    /**
     * gateway id
     *
     * @example my-gateway
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
     */
    id: string;
    /**
     * @format uuid
     */
    internal_id: string;
    logpush?: boolean;
    /**
     * @maxLength 1024
     * @minLength 16
     */
    logpush_public_key?: string | null;
    /**
     * @format date-time
     */
    modified_at: string;
    /**
     * @minimum 0
     */
    rate_limiting_interval: number | null;
    /**
     * @minimum 0
     */
    rate_limiting_limit: number | null;
    rate_limiting_technique: 'fixed' | 'sliding';
  };
  success: boolean;
};

export type AigConfigUpdateGatewayRequestBody = {
  cache_invalidate_on_update: boolean;
  /**
   * @minimum 0
   */
  cache_ttl: number | null;
  collect_logs: boolean;
  logpush?: boolean;
  /**
   * @maxLength 1024
   * @minLength 16
   */
  logpush_public_key?: string | null;
  /**
   * @minimum 0
   */
  rate_limiting_interval: number | null;
  /**
   * @minimum 0
   */
  rate_limiting_limit: number | null;
  rate_limiting_technique: 'fixed' | 'sliding';
};

export type AigConfigUpdateGatewayVariables = {
  body: AigConfigUpdateGatewayRequestBody;
  pathParams: AigConfigUpdateGatewayPathParams;
} & FetcherExtraProps;

export const aigConfigUpdateGateway = (variables: AigConfigUpdateGatewayVariables, signal?: AbortSignal) =>
  fetch<
    AigConfigUpdateGatewayResponse,
    AigConfigUpdateGatewayError,
    AigConfigUpdateGatewayRequestBody,
    {},
    {},
    AigConfigUpdateGatewayPathParams
  >({ url: '/accounts/{accountId}/ai-gateway/gateways/{id}', method: 'put', ...variables, signal });

export type WorkersAiSearchAuthorPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiSearchAuthorError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    error: string;
    success: boolean;
  };
}>;

export type WorkersAiSearchAuthorResponse = {
  errors: Record<string, any>[];
  messages: Record<string, any>[];
  result: Record<string, any>[];
  success: boolean;
};

export type WorkersAiSearchAuthorVariables = {
  pathParams: WorkersAiSearchAuthorPathParams;
} & FetcherExtraProps;

export const workersAiSearchAuthor = (variables: WorkersAiSearchAuthorVariables, signal?: AbortSignal) =>
  fetch<WorkersAiSearchAuthorResponse, WorkersAiSearchAuthorError, undefined, {}, {}, WorkersAiSearchAuthorPathParams>({
    url: '/accounts/{accountId}/ai/authors/search',
    method: 'get',
    ...variables,
    signal
  });

export type WorkersAiListFinetunesPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiListFinetunesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type WorkersAiListFinetunesResponse = {
  result: {
    /**
     * @format date-time
     */
    created_at: string;
    description?: string;
    /**
     * @format uuid
     */
    id: string;
    model: string;
    /**
     * @format date-time
     */
    modified_at: string;
    name: string;
  };
  success: boolean;
};

export type WorkersAiListFinetunesVariables = {
  pathParams: WorkersAiListFinetunesPathParams;
} & FetcherExtraProps;

export const workersAiListFinetunes = (variables: WorkersAiListFinetunesVariables, signal?: AbortSignal) =>
  fetch<
    WorkersAiListFinetunesResponse,
    WorkersAiListFinetunesError,
    undefined,
    {},
    {},
    WorkersAiListFinetunesPathParams
  >({ url: '/accounts/{accountId}/ai/finetunes', method: 'get', ...variables, signal });

export type WorkersAiCreateFinetunePathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiCreateFinetuneError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: string;
    success: boolean;
  };
}>;

export type WorkersAiCreateFinetuneResponse = {
  result: {
    /**
     * @format date-time
     */
    created_at: string;
    description?: string;
    /**
     * @format uuid
     */
    id: string;
    model: string;
    /**
     * @format date-time
     */
    modified_at: string;
    name: string;
    public: boolean;
  };
  success: boolean;
};

export type WorkersAiCreateFinetuneRequestBody = {
  description?: string;
  model: string;
  name: string;
  public?: boolean;
};

export type WorkersAiCreateFinetuneVariables = {
  body: WorkersAiCreateFinetuneRequestBody;
  pathParams: WorkersAiCreateFinetunePathParams;
} & FetcherExtraProps;

export const workersAiCreateFinetune = (variables: WorkersAiCreateFinetuneVariables, signal?: AbortSignal) =>
  fetch<
    WorkersAiCreateFinetuneResponse,
    WorkersAiCreateFinetuneError,
    WorkersAiCreateFinetuneRequestBody,
    {},
    {},
    WorkersAiCreateFinetunePathParams
  >({ url: '/accounts/{accountId}/ai/finetunes', method: 'post', ...variables, signal });

export type WorkersAiListPublicFinetunesPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiListPublicFinetunesQueryParams = {
  /**
   * Pagination Limit
   */
  limit?: number;
  /**
   * Pagination Offset
   */
  offset?: number;
  /**
   * Order By Column Name
   */
  orderBy?: string;
};

export type WorkersAiListPublicFinetunesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type WorkersAiListPublicFinetunesResponse = {
  result: {
    /**
     * @format date-time
     */
    created_at: string;
    description?: string;
    /**
     * @format uuid
     */
    id: string;
    model: string;
    /**
     * @format date-time
     */
    modified_at: string;
    name: string;
    public: boolean;
  }[];
  success: boolean;
};

export type WorkersAiListPublicFinetunesVariables = {
  pathParams: WorkersAiListPublicFinetunesPathParams;
  queryParams?: WorkersAiListPublicFinetunesQueryParams;
} & FetcherExtraProps;

export const workersAiListPublicFinetunes = (variables: WorkersAiListPublicFinetunesVariables, signal?: AbortSignal) =>
  fetch<
    WorkersAiListPublicFinetunesResponse,
    WorkersAiListPublicFinetunesError,
    undefined,
    {},
    WorkersAiListPublicFinetunesQueryParams,
    WorkersAiListPublicFinetunesPathParams
  >({ url: '/accounts/{accountId}/ai/finetunes/public', method: 'get', ...variables, signal });

export type WorkersAiUploadFinetuneAssetPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
  /**
   * @example bc451aef-f723-4b26-a6b2-901afd2e7a8a
   */
  finetuneId: string;
};

export type WorkersAiUploadFinetuneAssetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: string;
    success: boolean;
  };
}>;

export type WorkersAiUploadFinetuneAssetResponse = {
  result: {
    bucket_name: string;
    /**
     * @format date-time
     */
    created_at: string;
    file_name: string;
    /**
     * @example bc451aef-f723-4b26-a6b2-901afd2e7a8a
     */
    finetune_id: string;
    /**
     * @format uuid
     */
    id: string;
    /**
     * @format date-time
     */
    modified_at: string;
  };
  success: boolean;
};

export type WorkersAiUploadFinetuneAssetRequestBody = {
  /**
   * @format binary
   */
  file?: Blob;
  file_name?: string;
};

export type WorkersAiUploadFinetuneAssetVariables = {
  body?: WorkersAiUploadFinetuneAssetRequestBody;
  pathParams: WorkersAiUploadFinetuneAssetPathParams;
} & FetcherExtraProps;

export const workersAiUploadFinetuneAsset = (variables: WorkersAiUploadFinetuneAssetVariables, signal?: AbortSignal) =>
  fetch<
    WorkersAiUploadFinetuneAssetResponse,
    WorkersAiUploadFinetuneAssetError,
    WorkersAiUploadFinetuneAssetRequestBody,
    {},
    {},
    WorkersAiUploadFinetuneAssetPathParams
  >({ url: '/accounts/{accountId}/ai/finetunes/{finetuneId}/finetune-assets', method: 'post', ...variables, signal });

export type WorkersAiGetModelSchemaPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiGetModelSchemaQueryParams = {
  /**
   * Model Name
   */
  model: string;
};

export type WorkersAiGetModelSchemaError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type WorkersAiGetModelSchemaResponse = {
  result: Record<string, any>;
  success: boolean;
};

export type WorkersAiGetModelSchemaVariables = {
  pathParams: WorkersAiGetModelSchemaPathParams;
  queryParams: WorkersAiGetModelSchemaQueryParams;
} & FetcherExtraProps;

export const workersAiGetModelSchema = (variables: WorkersAiGetModelSchemaVariables, signal?: AbortSignal) =>
  fetch<
    WorkersAiGetModelSchemaResponse,
    WorkersAiGetModelSchemaError,
    undefined,
    {},
    WorkersAiGetModelSchemaQueryParams,
    WorkersAiGetModelSchemaPathParams
  >({ url: '/accounts/{accountId}/ai/models/schema', method: 'get', ...variables, signal });

export type WorkersAiSearchModelPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiSearchModelQueryParams = {
  per_page?: number;
  page?: number;
  /**
   * Filter by Task Name
   *
   * @example Text Generation
   */
  task?: string;
  /**
   * Filter by Author
   */
  author?: string;
  /**
   * Filter by Source Id
   */
  source?: number;
  /**
   * Filter to hide experimental models
   */
  hide_experimental?: boolean;
  /**
   * Search
   */
  search?: string;
};

export type WorkersAiSearchModelError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    error: string;
    success: boolean;
  };
}>;

export type WorkersAiSearchModelResponse = {
  errors: Record<string, any>[];
  messages: Record<string, any>[];
  result: Record<string, any>[];
  success: boolean;
};

export type WorkersAiSearchModelVariables = {
  pathParams: WorkersAiSearchModelPathParams;
  queryParams?: WorkersAiSearchModelQueryParams;
} & FetcherExtraProps;

export const workersAiSearchModel = (variables: WorkersAiSearchModelVariables, signal?: AbortSignal) =>
  fetch<
    WorkersAiSearchModelResponse,
    WorkersAiSearchModelError,
    undefined,
    {},
    WorkersAiSearchModelQueryParams,
    WorkersAiSearchModelPathParams
  >({ url: '/accounts/{accountId}/ai/models/search', method: 'get', ...variables, signal });

export type WorkersAiPostRunCfBaaiBgeBaseEnV15PathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfBaaiBgeBaseEnV15Error = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfBaaiBgeBaseEnV15Response = {
  result?: {
    /**
     * Embeddings of the requested text values
     */
    data?: number[][];
    shape?: number[];
  };
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfBaaiBgeBaseEnV15RequestBody = {
  text: string | string[];
};

export type WorkersAiPostRunCfBaaiBgeBaseEnV15Variables = {
  body: WorkersAiPostRunCfBaaiBgeBaseEnV15RequestBody;
  pathParams: WorkersAiPostRunCfBaaiBgeBaseEnV15PathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfBaaiBgeBaseEnV15 = (
  variables: WorkersAiPostRunCfBaaiBgeBaseEnV15Variables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfBaaiBgeBaseEnV15Response,
    WorkersAiPostRunCfBaaiBgeBaseEnV15Error,
    WorkersAiPostRunCfBaaiBgeBaseEnV15RequestBody,
    {},
    {},
    WorkersAiPostRunCfBaaiBgeBaseEnV15PathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/baai/bge-base-en-v1.5', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfBaaiBgeLargeEnV15PathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfBaaiBgeLargeEnV15Error = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfBaaiBgeLargeEnV15Response = {
  result?: {
    /**
     * Embeddings of the requested text values
     */
    data?: number[][];
    shape?: number[];
  };
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfBaaiBgeLargeEnV15RequestBody = {
  text: string | string[];
};

export type WorkersAiPostRunCfBaaiBgeLargeEnV15Variables = {
  body: WorkersAiPostRunCfBaaiBgeLargeEnV15RequestBody;
  pathParams: WorkersAiPostRunCfBaaiBgeLargeEnV15PathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfBaaiBgeLargeEnV15 = (
  variables: WorkersAiPostRunCfBaaiBgeLargeEnV15Variables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfBaaiBgeLargeEnV15Response,
    WorkersAiPostRunCfBaaiBgeLargeEnV15Error,
    WorkersAiPostRunCfBaaiBgeLargeEnV15RequestBody,
    {},
    {},
    WorkersAiPostRunCfBaaiBgeLargeEnV15PathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/baai/bge-large-en-v1.5', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfBaaiBgeSmallEnV15PathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfBaaiBgeSmallEnV15Error = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfBaaiBgeSmallEnV15Response = {
  result?: {
    /**
     * Embeddings of the requested text values
     */
    data?: number[][];
    shape?: number[];
  };
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfBaaiBgeSmallEnV15RequestBody = {
  text: string | string[];
};

export type WorkersAiPostRunCfBaaiBgeSmallEnV15Variables = {
  body: WorkersAiPostRunCfBaaiBgeSmallEnV15RequestBody;
  pathParams: WorkersAiPostRunCfBaaiBgeSmallEnV15PathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfBaaiBgeSmallEnV15 = (
  variables: WorkersAiPostRunCfBaaiBgeSmallEnV15Variables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfBaaiBgeSmallEnV15Response,
    WorkersAiPostRunCfBaaiBgeSmallEnV15Error,
    WorkersAiPostRunCfBaaiBgeSmallEnV15RequestBody,
    {},
    {},
    WorkersAiPostRunCfBaaiBgeSmallEnV15PathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/baai/bge-small-en-v1.5', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfBlackForestLabsFlux1SchnellPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfBlackForestLabsFlux1SchnellError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfBlackForestLabsFlux1SchnellResponse = {
  result?: {
    /**
     * The generated image in Base64 format.
     */
    image?: string;
  };
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfBlackForestLabsFlux1SchnellRequestBody = {
  /**
   * A text description of the image you want to generate.
   *
   * @maxLength 2048
   * @minLength 1
   */
  prompt: string;
  /**
   * The number of diffusion steps; higher values can improve quality but take longer.
   *
   * @default 4
   * @maximum 8
   */
  steps?: number;
};

export type WorkersAiPostRunCfBlackForestLabsFlux1SchnellVariables = {
  body: WorkersAiPostRunCfBlackForestLabsFlux1SchnellRequestBody;
  pathParams: WorkersAiPostRunCfBlackForestLabsFlux1SchnellPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfBlackForestLabsFlux1Schnell = (
  variables: WorkersAiPostRunCfBlackForestLabsFlux1SchnellVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfBlackForestLabsFlux1SchnellResponse,
    WorkersAiPostRunCfBlackForestLabsFlux1SchnellError,
    WorkersAiPostRunCfBlackForestLabsFlux1SchnellRequestBody,
    {},
    {},
    WorkersAiPostRunCfBlackForestLabsFlux1SchnellPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/black-forest-labs/flux-1-schnell', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfBytedanceStableDiffusionXlLightningPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfBytedanceStableDiffusionXlLightningError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfBytedanceStableDiffusionXlLightningRequestBody = {
  /**
   * Controls how closely the generated image should adhere to the prompt; higher values make the image more aligned with the prompt
   *
   * @default 7.5
   */
  guidance?: number;
  /**
   * The height of the generated image in pixels
   *
   * @maximum 2048
   * @minimum 256
   */
  height?: number;
  /**
   * For use with img2img tasks. An array of integers that represent the image data constrained to 8-bit unsigned integer values
   */
  image?: number[];
  /**
   * For use with img2img tasks. A base64-encoded string of the input image
   */
  image_b64?: string;
  /**
   * An array representing An array of integers that represent mask image data for inpainting constrained to 8-bit unsigned integer values
   */
  mask?: number[];
  /**
   * Text describing elements to avoid in the generated image
   */
  negative_prompt?: string;
  /**
   * The number of diffusion steps; higher values can improve quality but take longer
   *
   * @default 20
   * @maximum 20
   */
  num_steps?: number;
  /**
   * A text description of the image you want to generate
   *
   * @minLength 1
   */
  prompt: string;
  /**
   * Random seed for reproducibility of the image generation
   */
  seed?: number;
  /**
   * A value between 0 and 1 indicating how strongly to apply the transformation during img2img tasks; lower values make the output closer to the input image
   *
   * @default 1
   */
  strength?: number;
  /**
   * The width of the generated image in pixels
   *
   * @maximum 2048
   * @minimum 256
   */
  width?: number;
};

export type WorkersAiPostRunCfBytedanceStableDiffusionXlLightningVariables = {
  body: WorkersAiPostRunCfBytedanceStableDiffusionXlLightningRequestBody;
  pathParams: WorkersAiPostRunCfBytedanceStableDiffusionXlLightningPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfBytedanceStableDiffusionXlLightning = (
  variables: WorkersAiPostRunCfBytedanceStableDiffusionXlLightningVariables,
  signal?: AbortSignal
) =>
  fetch<
    undefined,
    WorkersAiPostRunCfBytedanceStableDiffusionXlLightningError,
    WorkersAiPostRunCfBytedanceStableDiffusionXlLightningRequestBody,
    {},
    {},
    WorkersAiPostRunCfBytedanceStableDiffusionXlLightningPathParams
  >({
    url: '/accounts/{accountId}/ai/run/@cf/bytedance/stable-diffusion-xl-lightning',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunCfDeepseekAiDeepseekMath7bInstructPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfDeepseekAiDeepseekMath7bInstructError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfDeepseekAiDeepseekMath7bInstructResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfDeepseekAiDeepseekMath7bInstructVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfDeepseekAiDeepseekMath7bInstructPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfDeepseekAiDeepseekMath7bInstruct = (
  variables: WorkersAiPostRunCfDeepseekAiDeepseekMath7bInstructVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfDeepseekAiDeepseekMath7bInstructResponse,
    WorkersAiPostRunCfDeepseekAiDeepseekMath7bInstructError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfDeepseekAiDeepseekMath7bInstructPathParams
  >({
    url: '/accounts/{accountId}/ai/run/@cf/deepseek-ai/deepseek-math-7b-instruct',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunCfDefogSqlcoder7b2PathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfDefogSqlcoder7b2Error = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfDefogSqlcoder7b2Response = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfDefogSqlcoder7b2Variables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfDefogSqlcoder7b2PathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfDefogSqlcoder7b2 = (
  variables: WorkersAiPostRunCfDefogSqlcoder7b2Variables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfDefogSqlcoder7b2Response,
    WorkersAiPostRunCfDefogSqlcoder7b2Error,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfDefogSqlcoder7b2PathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/defog/sqlcoder-7b-2', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfFacebookBartLargeCnnPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfFacebookBartLargeCnnError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfFacebookBartLargeCnnResponse = {
  result?: {
    /**
     * The summarized version of the input text
     */
    summary?: string;
  };
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfFacebookBartLargeCnnRequestBody = {
  /**
   * The text that you want the model to summarize
   *
   * @minLength 1
   */
  input_text: string;
  /**
   * The maximum length of the generated summary in tokens
   *
   * @default 1024
   */
  max_length?: number;
};

export type WorkersAiPostRunCfFacebookBartLargeCnnVariables = {
  body: WorkersAiPostRunCfFacebookBartLargeCnnRequestBody;
  pathParams: WorkersAiPostRunCfFacebookBartLargeCnnPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfFacebookBartLargeCnn = (
  variables: WorkersAiPostRunCfFacebookBartLargeCnnVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfFacebookBartLargeCnnResponse,
    WorkersAiPostRunCfFacebookBartLargeCnnError,
    WorkersAiPostRunCfFacebookBartLargeCnnRequestBody,
    {},
    {},
    WorkersAiPostRunCfFacebookBartLargeCnnPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/facebook/bart-large-cnn', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfFacebookDetrResnet50PathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfFacebookDetrResnet50Error = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfFacebookDetrResnet50Response = {
  /**
   * An array of detected objects within the input image
   */
  result?: {
    /**
     * Coordinates defining the bounding box around the detected object
     */
    box?: {
      /**
       * The x-coordinate of the bottom-right corner of the bounding box
       */
      xmax?: number;
      /**
       * The x-coordinate of the top-left corner of the bounding box
       */
      xmin?: number;
      /**
       * The y-coordinate of the bottom-right corner of the bounding box
       */
      ymax?: number;
      /**
       * The y-coordinate of the top-left corner of the bounding box
       */
      ymin?: number;
    };
    /**
     * The class label or name of the detected object
     */
    label?: string;
    /**
     * Confidence score indicating the likelihood that the detection is correct
     */
    score?: number;
  }[];
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfFacebookDetrResnet50Variables = {
  body?: Blob;
  pathParams: WorkersAiPostRunCfFacebookDetrResnet50PathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfFacebookDetrResnet50 = (
  variables: WorkersAiPostRunCfFacebookDetrResnet50Variables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfFacebookDetrResnet50Response,
    WorkersAiPostRunCfFacebookDetrResnet50Error,
    Blob,
    {},
    {},
    WorkersAiPostRunCfFacebookDetrResnet50PathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/facebook/detr-resnet-50', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfFblgitUnaCybertron7bV2Bf16PathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfFblgitUnaCybertron7bV2Bf16Error = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfFblgitUnaCybertron7bV2Bf16Response = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfFblgitUnaCybertron7bV2Bf16Variables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfFblgitUnaCybertron7bV2Bf16PathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfFblgitUnaCybertron7bV2Bf16 = (
  variables: WorkersAiPostRunCfFblgitUnaCybertron7bV2Bf16Variables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfFblgitUnaCybertron7bV2Bf16Response,
    WorkersAiPostRunCfFblgitUnaCybertron7bV2Bf16Error,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfFblgitUnaCybertron7bV2Bf16PathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/fblgit/una-cybertron-7b-v2-bf16', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfGoogleGemma2bItLoraPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfGoogleGemma2bItLoraError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfGoogleGemma2bItLoraResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfGoogleGemma2bItLoraVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfGoogleGemma2bItLoraPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfGoogleGemma2bItLora = (
  variables: WorkersAiPostRunCfGoogleGemma2bItLoraVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfGoogleGemma2bItLoraResponse,
    WorkersAiPostRunCfGoogleGemma2bItLoraError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfGoogleGemma2bItLoraPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/google/gemma-2b-it-lora', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfGoogleGemma7bItLoraPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfGoogleGemma7bItLoraError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfGoogleGemma7bItLoraResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfGoogleGemma7bItLoraVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfGoogleGemma7bItLoraPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfGoogleGemma7bItLora = (
  variables: WorkersAiPostRunCfGoogleGemma7bItLoraVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfGoogleGemma7bItLoraResponse,
    WorkersAiPostRunCfGoogleGemma7bItLoraError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfGoogleGemma7bItLoraPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/google/gemma-7b-it-lora', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfHuggingfaceDistilbertSst2Int8PathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfHuggingfaceDistilbertSst2Int8Error = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfHuggingfaceDistilbertSst2Int8Response = {
  /**
   * An array of classification results for the input text
   */
  result?: {
    /**
     * The classification label assigned to the text (e.g., 'POSITIVE' or 'NEGATIVE')
     */
    label?: string;
    /**
     * Confidence score indicating the likelihood that the text belongs to the specified label
     */
    score?: number;
  }[];
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfHuggingfaceDistilbertSst2Int8RequestBody = {
  /**
   * The text that you want to classify
   *
   * @minLength 1
   */
  text: string;
};

export type WorkersAiPostRunCfHuggingfaceDistilbertSst2Int8Variables = {
  body: WorkersAiPostRunCfHuggingfaceDistilbertSst2Int8RequestBody;
  pathParams: WorkersAiPostRunCfHuggingfaceDistilbertSst2Int8PathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfHuggingfaceDistilbertSst2Int8 = (
  variables: WorkersAiPostRunCfHuggingfaceDistilbertSst2Int8Variables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfHuggingfaceDistilbertSst2Int8Response,
    WorkersAiPostRunCfHuggingfaceDistilbertSst2Int8Error,
    WorkersAiPostRunCfHuggingfaceDistilbertSst2Int8RequestBody,
    {},
    {},
    WorkersAiPostRunCfHuggingfaceDistilbertSst2Int8PathParams
  >({
    url: '/accounts/{accountId}/ai/run/@cf/huggingface/distilbert-sst-2-int8',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunCfLykonDreamshaper8LcmPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfLykonDreamshaper8LcmError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfLykonDreamshaper8LcmRequestBody = {
  /**
   * Controls how closely the generated image should adhere to the prompt; higher values make the image more aligned with the prompt
   *
   * @default 7.5
   */
  guidance?: number;
  /**
   * The height of the generated image in pixels
   *
   * @maximum 2048
   * @minimum 256
   */
  height?: number;
  /**
   * For use with img2img tasks. An array of integers that represent the image data constrained to 8-bit unsigned integer values
   */
  image?: number[];
  /**
   * For use with img2img tasks. A base64-encoded string of the input image
   */
  image_b64?: string;
  /**
   * An array representing An array of integers that represent mask image data for inpainting constrained to 8-bit unsigned integer values
   */
  mask?: number[];
  /**
   * Text describing elements to avoid in the generated image
   */
  negative_prompt?: string;
  /**
   * The number of diffusion steps; higher values can improve quality but take longer
   *
   * @default 20
   * @maximum 20
   */
  num_steps?: number;
  /**
   * A text description of the image you want to generate
   *
   * @minLength 1
   */
  prompt: string;
  /**
   * Random seed for reproducibility of the image generation
   */
  seed?: number;
  /**
   * A value between 0 and 1 indicating how strongly to apply the transformation during img2img tasks; lower values make the output closer to the input image
   *
   * @default 1
   */
  strength?: number;
  /**
   * The width of the generated image in pixels
   *
   * @maximum 2048
   * @minimum 256
   */
  width?: number;
};

export type WorkersAiPostRunCfLykonDreamshaper8LcmVariables = {
  body: WorkersAiPostRunCfLykonDreamshaper8LcmRequestBody;
  pathParams: WorkersAiPostRunCfLykonDreamshaper8LcmPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfLykonDreamshaper8Lcm = (
  variables: WorkersAiPostRunCfLykonDreamshaper8LcmVariables,
  signal?: AbortSignal
) =>
  fetch<
    undefined,
    WorkersAiPostRunCfLykonDreamshaper8LcmError,
    WorkersAiPostRunCfLykonDreamshaper8LcmRequestBody,
    {},
    {},
    WorkersAiPostRunCfLykonDreamshaper8LcmPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/lykon/dreamshaper-8-lcm', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfMetaLlamaLlama27bChatHfLoraPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMetaLlamaLlama27bChatHfLoraError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMetaLlamaLlama27bChatHfLoraResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMetaLlamaLlama27bChatHfLoraVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMetaLlamaLlama27bChatHfLoraPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMetaLlamaLlama27bChatHfLora = (
  variables: WorkersAiPostRunCfMetaLlamaLlama27bChatHfLoraVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMetaLlamaLlama27bChatHfLoraResponse,
    WorkersAiPostRunCfMetaLlamaLlama27bChatHfLoraError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMetaLlamaLlama27bChatHfLoraPathParams
  >({
    url: '/accounts/{accountId}/ai/run/@cf/meta-llama/llama-2-7b-chat-hf-lora',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunCfMetaLlama27bChatFp16PathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMetaLlama27bChatFp16Error = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMetaLlama27bChatFp16Response = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMetaLlama27bChatFp16Variables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMetaLlama27bChatFp16PathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMetaLlama27bChatFp16 = (
  variables: WorkersAiPostRunCfMetaLlama27bChatFp16Variables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMetaLlama27bChatFp16Response,
    WorkersAiPostRunCfMetaLlama27bChatFp16Error,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMetaLlama27bChatFp16PathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/meta/llama-2-7b-chat-fp16', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfMetaLlama27bChatInt8PathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMetaLlama27bChatInt8Error = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMetaLlama27bChatInt8Response = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMetaLlama27bChatInt8Variables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMetaLlama27bChatInt8PathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMetaLlama27bChatInt8 = (
  variables: WorkersAiPostRunCfMetaLlama27bChatInt8Variables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMetaLlama27bChatInt8Response,
    WorkersAiPostRunCfMetaLlama27bChatInt8Error,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMetaLlama27bChatInt8PathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/meta/llama-2-7b-chat-int8', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfMetaLlama38bInstructPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMetaLlama38bInstructError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMetaLlama38bInstructResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMetaLlama38bInstructVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMetaLlama38bInstructPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMetaLlama38bInstruct = (
  variables: WorkersAiPostRunCfMetaLlama38bInstructVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMetaLlama38bInstructResponse,
    WorkersAiPostRunCfMetaLlama38bInstructError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMetaLlama38bInstructPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/meta/llama-3-8b-instruct', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfMetaLlama38bInstructAwqPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMetaLlama38bInstructAwqError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMetaLlama38bInstructAwqResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMetaLlama38bInstructAwqVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMetaLlama38bInstructAwqPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMetaLlama38bInstructAwq = (
  variables: WorkersAiPostRunCfMetaLlama38bInstructAwqVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMetaLlama38bInstructAwqResponse,
    WorkersAiPostRunCfMetaLlama38bInstructAwqError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMetaLlama38bInstructAwqPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/meta/llama-3-8b-instruct-awq', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfMetaLlama3170bInstructPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMetaLlama3170bInstructError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMetaLlama3170bInstructResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMetaLlama3170bInstructVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMetaLlama3170bInstructPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMetaLlama3170bInstruct = (
  variables: WorkersAiPostRunCfMetaLlama3170bInstructVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMetaLlama3170bInstructResponse,
    WorkersAiPostRunCfMetaLlama3170bInstructError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMetaLlama3170bInstructPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/meta/llama-3.1-70b-instruct', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfMetaLlama3170bInstructPreviewPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMetaLlama3170bInstructPreviewError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMetaLlama3170bInstructPreviewResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMetaLlama3170bInstructPreviewVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMetaLlama3170bInstructPreviewPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMetaLlama3170bInstructPreview = (
  variables: WorkersAiPostRunCfMetaLlama3170bInstructPreviewVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMetaLlama3170bInstructPreviewResponse,
    WorkersAiPostRunCfMetaLlama3170bInstructPreviewError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMetaLlama3170bInstructPreviewPathParams
  >({
    url: '/accounts/{accountId}/ai/run/@cf/meta/llama-3.1-70b-instruct-preview',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunCfMetaLlama3170bPreviewPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMetaLlama3170bPreviewError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMetaLlama3170bPreviewResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMetaLlama3170bPreviewVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMetaLlama3170bPreviewPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMetaLlama3170bPreview = (
  variables: WorkersAiPostRunCfMetaLlama3170bPreviewVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMetaLlama3170bPreviewResponse,
    WorkersAiPostRunCfMetaLlama3170bPreviewError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMetaLlama3170bPreviewPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/meta/llama-3.1-70b-preview', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfMetaLlama318bInstructPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMetaLlama318bInstructError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMetaLlama318bInstructResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMetaLlama318bInstructVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMetaLlama318bInstructPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMetaLlama318bInstruct = (
  variables: WorkersAiPostRunCfMetaLlama318bInstructVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMetaLlama318bInstructResponse,
    WorkersAiPostRunCfMetaLlama318bInstructError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMetaLlama318bInstructPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/meta/llama-3.1-8b-instruct', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfMetaLlama318bInstructAwqPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMetaLlama318bInstructAwqError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMetaLlama318bInstructAwqResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMetaLlama318bInstructAwqVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMetaLlama318bInstructAwqPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMetaLlama318bInstructAwq = (
  variables: WorkersAiPostRunCfMetaLlama318bInstructAwqVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMetaLlama318bInstructAwqResponse,
    WorkersAiPostRunCfMetaLlama318bInstructAwqError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMetaLlama318bInstructAwqPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/meta/llama-3.1-8b-instruct-awq', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfMetaLlama318bInstructFastPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMetaLlama318bInstructFastError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMetaLlama318bInstructFastResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMetaLlama318bInstructFastVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMetaLlama318bInstructFastPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMetaLlama318bInstructFast = (
  variables: WorkersAiPostRunCfMetaLlama318bInstructFastVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMetaLlama318bInstructFastResponse,
    WorkersAiPostRunCfMetaLlama318bInstructFastError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMetaLlama318bInstructFastPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/meta/llama-3.1-8b-instruct-fast', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfMetaLlama318bInstructFp8PathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMetaLlama318bInstructFp8Error = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMetaLlama318bInstructFp8Response = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMetaLlama318bInstructFp8Variables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMetaLlama318bInstructFp8PathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMetaLlama318bInstructFp8 = (
  variables: WorkersAiPostRunCfMetaLlama318bInstructFp8Variables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMetaLlama318bInstructFp8Response,
    WorkersAiPostRunCfMetaLlama318bInstructFp8Error,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMetaLlama318bInstructFp8PathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/meta/llama-3.1-8b-instruct-fp8', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfMetaLlama318bPreviewPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMetaLlama318bPreviewError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMetaLlama318bPreviewResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMetaLlama318bPreviewVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMetaLlama318bPreviewPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMetaLlama318bPreview = (
  variables: WorkersAiPostRunCfMetaLlama318bPreviewVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMetaLlama318bPreviewResponse,
    WorkersAiPostRunCfMetaLlama318bPreviewError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMetaLlama318bPreviewPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/meta/llama-3.1-8b-preview', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfMetaLlama3211bVisionInstructPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMetaLlama3211bVisionInstructError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMetaLlama3211bVisionInstructResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMetaLlama3211bVisionInstructVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        image?: number[] | Blob;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        image?: number[] | Blob;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMetaLlama3211bVisionInstructPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMetaLlama3211bVisionInstruct = (
  variables: WorkersAiPostRunCfMetaLlama3211bVisionInstructVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMetaLlama3211bVisionInstructResponse,
    WorkersAiPostRunCfMetaLlama3211bVisionInstructError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        image?: number[] | Blob;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        image?: number[] | Blob;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMetaLlama3211bVisionInstructPathParams
  >({
    url: '/accounts/{accountId}/ai/run/@cf/meta/llama-3.2-11b-vision-instruct',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunCfMetaLlama321bInstructPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMetaLlama321bInstructError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMetaLlama321bInstructResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMetaLlama321bInstructVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMetaLlama321bInstructPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMetaLlama321bInstruct = (
  variables: WorkersAiPostRunCfMetaLlama321bInstructVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMetaLlama321bInstructResponse,
    WorkersAiPostRunCfMetaLlama321bInstructError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMetaLlama321bInstructPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/meta/llama-3.2-1b-instruct', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfMetaLlama323bInstructPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMetaLlama323bInstructError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMetaLlama323bInstructResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMetaLlama323bInstructVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMetaLlama323bInstructPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMetaLlama323bInstruct = (
  variables: WorkersAiPostRunCfMetaLlama323bInstructVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMetaLlama323bInstructResponse,
    WorkersAiPostRunCfMetaLlama323bInstructError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMetaLlama323bInstructPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/meta/llama-3.2-3b-instruct', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfMetaLlama3370bInstructFp8FastPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMetaLlama3370bInstructFp8FastError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMetaLlama3370bInstructFp8FastResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMetaLlama3370bInstructFp8FastVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMetaLlama3370bInstructFp8FastPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMetaLlama3370bInstructFp8Fast = (
  variables: WorkersAiPostRunCfMetaLlama3370bInstructFp8FastVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMetaLlama3370bInstructFp8FastResponse,
    WorkersAiPostRunCfMetaLlama3370bInstructFp8FastError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMetaLlama3370bInstructFp8FastPathParams
  >({
    url: '/accounts/{accountId}/ai/run/@cf/meta/llama-3.3-70b-instruct-fp8-fast',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunCfMetaM2m10012bPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMetaM2m10012bError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMetaM2m10012bResponse = {
  result?: {
    /**
     * The translated text in the target language
     */
    translated_text?: string;
  };
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMetaM2m10012bRequestBody = {
  /**
   * The language code of the source text (e.g., 'en' for English). Defaults to 'en' if not specified
   *
   * @default en
   */
  source_lang?: string;
  /**
   * The language code to translate the text into (e.g., 'es' for Spanish)
   */
  target_lang: string;
  /**
   * The text to be translated
   *
   * @minLength 1
   */
  text: string;
};

export type WorkersAiPostRunCfMetaM2m10012bVariables = {
  body: WorkersAiPostRunCfMetaM2m10012bRequestBody;
  pathParams: WorkersAiPostRunCfMetaM2m10012bPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMetaM2m10012b = (
  variables: WorkersAiPostRunCfMetaM2m10012bVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMetaM2m10012bResponse,
    WorkersAiPostRunCfMetaM2m10012bError,
    WorkersAiPostRunCfMetaM2m10012bRequestBody,
    {},
    {},
    WorkersAiPostRunCfMetaM2m10012bPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/meta/m2m100-1.2b', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfMicrosoftPhi2PathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMicrosoftPhi2Error = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMicrosoftPhi2Response = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMicrosoftPhi2Variables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMicrosoftPhi2PathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMicrosoftPhi2 = (
  variables: WorkersAiPostRunCfMicrosoftPhi2Variables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMicrosoftPhi2Response,
    WorkersAiPostRunCfMicrosoftPhi2Error,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMicrosoftPhi2PathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/microsoft/phi-2', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfMicrosoftResnet50PathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMicrosoftResnet50Error = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMicrosoftResnet50Response = {
  result?: {
    /**
     * The predicted category or class for the input image based on analysis
     */
    label?: string;
    /**
     * A confidence value, between 0 and 1, indicating how certain the model is about the predicted label
     */
    score?: number;
  }[];
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMicrosoftResnet50Variables = {
  body?: Blob;
  pathParams: WorkersAiPostRunCfMicrosoftResnet50PathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMicrosoftResnet50 = (
  variables: WorkersAiPostRunCfMicrosoftResnet50Variables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMicrosoftResnet50Response,
    WorkersAiPostRunCfMicrosoftResnet50Error,
    Blob,
    {},
    {},
    WorkersAiPostRunCfMicrosoftResnet50PathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/microsoft/resnet-50', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfMistralMistral7bInstructV01PathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMistralMistral7bInstructV01Error = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMistralMistral7bInstructV01Response = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMistralMistral7bInstructV01Variables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMistralMistral7bInstructV01PathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMistralMistral7bInstructV01 = (
  variables: WorkersAiPostRunCfMistralMistral7bInstructV01Variables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMistralMistral7bInstructV01Response,
    WorkersAiPostRunCfMistralMistral7bInstructV01Error,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMistralMistral7bInstructV01PathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/mistral/mistral-7b-instruct-v0.1', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfMistralMistral7bInstructV02LoraPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfMistralMistral7bInstructV02LoraError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfMistralMistral7bInstructV02LoraResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfMistralMistral7bInstructV02LoraVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfMistralMistral7bInstructV02LoraPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfMistralMistral7bInstructV02Lora = (
  variables: WorkersAiPostRunCfMistralMistral7bInstructV02LoraVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfMistralMistral7bInstructV02LoraResponse,
    WorkersAiPostRunCfMistralMistral7bInstructV02LoraError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfMistralMistral7bInstructV02LoraPathParams
  >({
    url: '/accounts/{accountId}/ai/run/@cf/mistral/mistral-7b-instruct-v0.2-lora',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunCfOpenaiWhisperPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfOpenaiWhisperError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfOpenaiWhisperResponse = {
  result?: {
    /**
     * The transcription
     */
    text: string;
    vtt?: string;
    word_count?: number;
    words?: {
      /**
       * The ending second when the word completes
       */
      end?: number;
      /**
       * The second this word begins in the recording
       */
      start?: number;
      word?: string;
    }[];
  };
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfOpenaiWhisperVariables = {
  body?: Blob;
  pathParams: WorkersAiPostRunCfOpenaiWhisperPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfOpenaiWhisper = (
  variables: WorkersAiPostRunCfOpenaiWhisperVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfOpenaiWhisperResponse,
    WorkersAiPostRunCfOpenaiWhisperError,
    Blob,
    {},
    {},
    WorkersAiPostRunCfOpenaiWhisperPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/openai/whisper', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfOpenaiWhisperLargeV3TurboPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfOpenaiWhisperLargeV3TurboError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfOpenaiWhisperLargeV3TurboResponse = {
  result?: {
    segments?: {
      /**
       * The average log probability of the predictions for the words in this segment, indicating overall confidence.
       */
      avg_logprob?: number;
      /**
       * The compression ratio of the input to the output, measuring how much the text was compressed during the transcription process.
       */
      compression_ratio?: number;
      /**
       * The ending time of the segment within the audio, in seconds.
       */
      end?: number;
      /**
       * The probability that the segment contains no speech, represented as a decimal between 0 and 1.
       */
      no_speech_prob?: number;
      /**
       * The starting time of the segment within the audio, in seconds.
       */
      start?: number;
      /**
       * The temperature used in the decoding process, controlling randomness in predictions. Lower values result in more deterministic outputs.
       */
      temperature?: number;
      /**
       * The transcription of the segment.
       */
      text?: string;
      words?: {
        /**
         * The ending time of the word within the audio, in seconds.
         */
        end?: number;
        /**
         * The starting time of the word within the audio, in seconds.
         */
        start?: number;
        /**
         * The individual word transcribed from the audio.
         */
        word?: string;
      }[];
    };
    /**
     * The complete transcription of the audio.
     */
    text: string;
    transcription_info?: {
      /**
       * The total duration of the original audio file, in seconds.
       */
      duration?: number;
      /**
       * The duration of the audio after applying Voice Activity Detection (VAD) to remove silent or irrelevant sections, in seconds.
       */
      duration_after_vad?: number;
      /**
       * The language of the audio being transcribed or translated.
       */
      language?: string;
      /**
       * The confidence level or probability of the detected language being accurate, represented as a decimal between 0 and 1.
       */
      language_probability?: number;
    };
    /**
     * The transcription in WebVTT format, which includes timing and text information for use in subtitles.
     */
    vtt?: string;
    /**
     * The total number of words in the transcription.
     */
    word_count?: number;
  };
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfOpenaiWhisperLargeV3TurboRequestBody = {
  /**
   * Base64 encoded value of the audio data.
   */
  audio: string;
  /**
   * A text prompt to help provide context to the model on the contents of the audio.
   */
  initial_prompt?: string;
  /**
   * The language of the audio being transcribed or translated.
   *
   * @default en
   */
  language?: string;
  /**
   * The prefix it appended the the beginning of the output of the transcription and can guide the transcription result.
   */
  prefix?: string;
  /**
   * Supported tasks are 'translate' or 'transcribe'.
   *
   * @default transcribe
   */
  task?: string;
  /**
   * Preprocess the audio with a voice activity detection model.
   *
   * @default false
   */
  vad_filter?: string;
};

export type WorkersAiPostRunCfOpenaiWhisperLargeV3TurboVariables = {
  body: WorkersAiPostRunCfOpenaiWhisperLargeV3TurboRequestBody;
  pathParams: WorkersAiPostRunCfOpenaiWhisperLargeV3TurboPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfOpenaiWhisperLargeV3Turbo = (
  variables: WorkersAiPostRunCfOpenaiWhisperLargeV3TurboVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfOpenaiWhisperLargeV3TurboResponse,
    WorkersAiPostRunCfOpenaiWhisperLargeV3TurboError,
    WorkersAiPostRunCfOpenaiWhisperLargeV3TurboRequestBody,
    {},
    {},
    WorkersAiPostRunCfOpenaiWhisperLargeV3TurboPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/openai/whisper-large-v3-turbo', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfOpenaiWhisperTinyEnPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfOpenaiWhisperTinyEnError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfOpenaiWhisperTinyEnResponse = {
  result?: {
    /**
     * The transcription
     */
    text: string;
    vtt?: string;
    word_count?: number;
    words?: {
      /**
       * The ending second when the word completes
       */
      end?: number;
      /**
       * The second this word begins in the recording
       */
      start?: number;
      word?: string;
    }[];
  };
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfOpenaiWhisperTinyEnVariables = {
  body?: Blob;
  pathParams: WorkersAiPostRunCfOpenaiWhisperTinyEnPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfOpenaiWhisperTinyEn = (
  variables: WorkersAiPostRunCfOpenaiWhisperTinyEnVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfOpenaiWhisperTinyEnResponse,
    WorkersAiPostRunCfOpenaiWhisperTinyEnError,
    Blob,
    {},
    {},
    WorkersAiPostRunCfOpenaiWhisperTinyEnPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/openai/whisper-tiny-en', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfOpenchatOpenchat350106PathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfOpenchatOpenchat350106Error = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfOpenchatOpenchat350106Response = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfOpenchatOpenchat350106Variables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfOpenchatOpenchat350106PathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfOpenchatOpenchat350106 = (
  variables: WorkersAiPostRunCfOpenchatOpenchat350106Variables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfOpenchatOpenchat350106Response,
    WorkersAiPostRunCfOpenchatOpenchat350106Error,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfOpenchatOpenchat350106PathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/openchat/openchat-3.5-0106', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfQwenQwen1505bChatPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfQwenQwen1505bChatError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfQwenQwen1505bChatResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfQwenQwen1505bChatVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfQwenQwen1505bChatPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfQwenQwen1505bChat = (
  variables: WorkersAiPostRunCfQwenQwen1505bChatVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfQwenQwen1505bChatResponse,
    WorkersAiPostRunCfQwenQwen1505bChatError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfQwenQwen1505bChatPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/qwen/qwen1.5-0.5b-chat', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfQwenQwen1518bChatPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfQwenQwen1518bChatError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfQwenQwen1518bChatResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfQwenQwen1518bChatVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfQwenQwen1518bChatPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfQwenQwen1518bChat = (
  variables: WorkersAiPostRunCfQwenQwen1518bChatVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfQwenQwen1518bChatResponse,
    WorkersAiPostRunCfQwenQwen1518bChatError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfQwenQwen1518bChatPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/qwen/qwen1.5-1.8b-chat', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfQwenQwen1514bChatAwqPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfQwenQwen1514bChatAwqError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfQwenQwen1514bChatAwqResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfQwenQwen1514bChatAwqVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfQwenQwen1514bChatAwqPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfQwenQwen1514bChatAwq = (
  variables: WorkersAiPostRunCfQwenQwen1514bChatAwqVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfQwenQwen1514bChatAwqResponse,
    WorkersAiPostRunCfQwenQwen1514bChatAwqError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfQwenQwen1514bChatAwqPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/qwen/qwen1.5-14b-chat-awq', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfQwenQwen157bChatAwqPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfQwenQwen157bChatAwqError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfQwenQwen157bChatAwqResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfQwenQwen157bChatAwqVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfQwenQwen157bChatAwqPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfQwenQwen157bChatAwq = (
  variables: WorkersAiPostRunCfQwenQwen157bChatAwqVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfQwenQwen157bChatAwqResponse,
    WorkersAiPostRunCfQwenQwen157bChatAwqError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfQwenQwen157bChatAwqPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/qwen/qwen1.5-7b-chat-awq', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfRunwaymlStableDiffusionV15Img2imgPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfRunwaymlStableDiffusionV15Img2imgError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfRunwaymlStableDiffusionV15Img2imgRequestBody = {
  /**
   * Controls how closely the generated image should adhere to the prompt; higher values make the image more aligned with the prompt
   *
   * @default 7.5
   */
  guidance?: number;
  /**
   * The height of the generated image in pixels
   *
   * @maximum 2048
   * @minimum 256
   */
  height?: number;
  /**
   * For use with img2img tasks. An array of integers that represent the image data constrained to 8-bit unsigned integer values
   */
  image?: number[];
  /**
   * For use with img2img tasks. A base64-encoded string of the input image
   */
  image_b64?: string;
  /**
   * An array representing An array of integers that represent mask image data for inpainting constrained to 8-bit unsigned integer values
   */
  mask?: number[];
  /**
   * Text describing elements to avoid in the generated image
   */
  negative_prompt?: string;
  /**
   * The number of diffusion steps; higher values can improve quality but take longer
   *
   * @default 20
   * @maximum 20
   */
  num_steps?: number;
  /**
   * A text description of the image you want to generate
   *
   * @minLength 1
   */
  prompt: string;
  /**
   * Random seed for reproducibility of the image generation
   */
  seed?: number;
  /**
   * A value between 0 and 1 indicating how strongly to apply the transformation during img2img tasks; lower values make the output closer to the input image
   *
   * @default 1
   */
  strength?: number;
  /**
   * The width of the generated image in pixels
   *
   * @maximum 2048
   * @minimum 256
   */
  width?: number;
};

export type WorkersAiPostRunCfRunwaymlStableDiffusionV15Img2imgVariables = {
  body: WorkersAiPostRunCfRunwaymlStableDiffusionV15Img2imgRequestBody;
  pathParams: WorkersAiPostRunCfRunwaymlStableDiffusionV15Img2imgPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfRunwaymlStableDiffusionV15Img2img = (
  variables: WorkersAiPostRunCfRunwaymlStableDiffusionV15Img2imgVariables,
  signal?: AbortSignal
) =>
  fetch<
    undefined,
    WorkersAiPostRunCfRunwaymlStableDiffusionV15Img2imgError,
    WorkersAiPostRunCfRunwaymlStableDiffusionV15Img2imgRequestBody,
    {},
    {},
    WorkersAiPostRunCfRunwaymlStableDiffusionV15Img2imgPathParams
  >({
    url: '/accounts/{accountId}/ai/run/@cf/runwayml/stable-diffusion-v1-5-img2img',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunCfRunwaymlStableDiffusionV15InpaintingPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfRunwaymlStableDiffusionV15InpaintingError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfRunwaymlStableDiffusionV15InpaintingRequestBody = {
  /**
   * Controls how closely the generated image should adhere to the prompt; higher values make the image more aligned with the prompt
   *
   * @default 7.5
   */
  guidance?: number;
  /**
   * The height of the generated image in pixels
   *
   * @maximum 2048
   * @minimum 256
   */
  height?: number;
  /**
   * For use with img2img tasks. An array of integers that represent the image data constrained to 8-bit unsigned integer values
   */
  image?: number[];
  /**
   * For use with img2img tasks. A base64-encoded string of the input image
   */
  image_b64?: string;
  /**
   * An array representing An array of integers that represent mask image data for inpainting constrained to 8-bit unsigned integer values
   */
  mask?: number[];
  /**
   * Text describing elements to avoid in the generated image
   */
  negative_prompt?: string;
  /**
   * The number of diffusion steps; higher values can improve quality but take longer
   *
   * @default 20
   * @maximum 20
   */
  num_steps?: number;
  /**
   * A text description of the image you want to generate
   *
   * @minLength 1
   */
  prompt: string;
  /**
   * Random seed for reproducibility of the image generation
   */
  seed?: number;
  /**
   * A value between 0 and 1 indicating how strongly to apply the transformation during img2img tasks; lower values make the output closer to the input image
   *
   * @default 1
   */
  strength?: number;
  /**
   * The width of the generated image in pixels
   *
   * @maximum 2048
   * @minimum 256
   */
  width?: number;
};

export type WorkersAiPostRunCfRunwaymlStableDiffusionV15InpaintingVariables = {
  body: WorkersAiPostRunCfRunwaymlStableDiffusionV15InpaintingRequestBody;
  pathParams: WorkersAiPostRunCfRunwaymlStableDiffusionV15InpaintingPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfRunwaymlStableDiffusionV15Inpainting = (
  variables: WorkersAiPostRunCfRunwaymlStableDiffusionV15InpaintingVariables,
  signal?: AbortSignal
) =>
  fetch<
    undefined,
    WorkersAiPostRunCfRunwaymlStableDiffusionV15InpaintingError,
    WorkersAiPostRunCfRunwaymlStableDiffusionV15InpaintingRequestBody,
    {},
    {},
    WorkersAiPostRunCfRunwaymlStableDiffusionV15InpaintingPathParams
  >({
    url: '/accounts/{accountId}/ai/run/@cf/runwayml/stable-diffusion-v1-5-inpainting',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunCfStabilityaiStableDiffusionXlBase10PathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfStabilityaiStableDiffusionXlBase10Error = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfStabilityaiStableDiffusionXlBase10RequestBody = {
  /**
   * Controls how closely the generated image should adhere to the prompt; higher values make the image more aligned with the prompt
   *
   * @default 7.5
   */
  guidance?: number;
  /**
   * The height of the generated image in pixels
   *
   * @maximum 2048
   * @minimum 256
   */
  height?: number;
  /**
   * For use with img2img tasks. An array of integers that represent the image data constrained to 8-bit unsigned integer values
   */
  image?: number[];
  /**
   * For use with img2img tasks. A base64-encoded string of the input image
   */
  image_b64?: string;
  /**
   * An array representing An array of integers that represent mask image data for inpainting constrained to 8-bit unsigned integer values
   */
  mask?: number[];
  /**
   * Text describing elements to avoid in the generated image
   */
  negative_prompt?: string;
  /**
   * The number of diffusion steps; higher values can improve quality but take longer
   *
   * @default 20
   * @maximum 20
   */
  num_steps?: number;
  /**
   * A text description of the image you want to generate
   *
   * @minLength 1
   */
  prompt: string;
  /**
   * Random seed for reproducibility of the image generation
   */
  seed?: number;
  /**
   * A value between 0 and 1 indicating how strongly to apply the transformation during img2img tasks; lower values make the output closer to the input image
   *
   * @default 1
   */
  strength?: number;
  /**
   * The width of the generated image in pixels
   *
   * @maximum 2048
   * @minimum 256
   */
  width?: number;
};

export type WorkersAiPostRunCfStabilityaiStableDiffusionXlBase10Variables = {
  body: WorkersAiPostRunCfStabilityaiStableDiffusionXlBase10RequestBody;
  pathParams: WorkersAiPostRunCfStabilityaiStableDiffusionXlBase10PathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfStabilityaiStableDiffusionXlBase10 = (
  variables: WorkersAiPostRunCfStabilityaiStableDiffusionXlBase10Variables,
  signal?: AbortSignal
) =>
  fetch<
    undefined,
    WorkersAiPostRunCfStabilityaiStableDiffusionXlBase10Error,
    WorkersAiPostRunCfStabilityaiStableDiffusionXlBase10RequestBody,
    {},
    {},
    WorkersAiPostRunCfStabilityaiStableDiffusionXlBase10PathParams
  >({
    url: '/accounts/{accountId}/ai/run/@cf/stabilityai/stable-diffusion-xl-base-1.0',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunCfTheblokeDiscolmGerman7bV1AwqPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfTheblokeDiscolmGerman7bV1AwqError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfTheblokeDiscolmGerman7bV1AwqResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfTheblokeDiscolmGerman7bV1AwqVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfTheblokeDiscolmGerman7bV1AwqPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfTheblokeDiscolmGerman7bV1Awq = (
  variables: WorkersAiPostRunCfTheblokeDiscolmGerman7bV1AwqVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfTheblokeDiscolmGerman7bV1AwqResponse,
    WorkersAiPostRunCfTheblokeDiscolmGerman7bV1AwqError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfTheblokeDiscolmGerman7bV1AwqPathParams
  >({
    url: '/accounts/{accountId}/ai/run/@cf/thebloke/discolm-german-7b-v1-awq',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunCfTiiuaeFalcon7bInstructPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfTiiuaeFalcon7bInstructError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfTiiuaeFalcon7bInstructResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfTiiuaeFalcon7bInstructVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfTiiuaeFalcon7bInstructPathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfTiiuaeFalcon7bInstruct = (
  variables: WorkersAiPostRunCfTiiuaeFalcon7bInstructVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfTiiuaeFalcon7bInstructResponse,
    WorkersAiPostRunCfTiiuaeFalcon7bInstructError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfTiiuaeFalcon7bInstructPathParams
  >({ url: '/accounts/{accountId}/ai/run/@cf/tiiuae/falcon-7b-instruct', method: 'post', ...variables, signal });

export type WorkersAiPostRunCfTinyllamaTinyllama11bChatV10PathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunCfTinyllamaTinyllama11bChatV10Error = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunCfTinyllamaTinyllama11bChatV10Response = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunCfTinyllamaTinyllama11bChatV10Variables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunCfTinyllamaTinyllama11bChatV10PathParams;
} & FetcherExtraProps;

export const workersAiPostRunCfTinyllamaTinyllama11bChatV10 = (
  variables: WorkersAiPostRunCfTinyllamaTinyllama11bChatV10Variables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunCfTinyllamaTinyllama11bChatV10Response,
    WorkersAiPostRunCfTinyllamaTinyllama11bChatV10Error,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunCfTinyllamaTinyllama11bChatV10PathParams
  >({
    url: '/accounts/{accountId}/ai/run/@cf/tinyllama/tinyllama-1.1b-chat-v1.0',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunHfGoogleGemma7bItPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunHfGoogleGemma7bItError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunHfGoogleGemma7bItResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunHfGoogleGemma7bItVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunHfGoogleGemma7bItPathParams;
} & FetcherExtraProps;

export const workersAiPostRunHfGoogleGemma7bIt = (
  variables: WorkersAiPostRunHfGoogleGemma7bItVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunHfGoogleGemma7bItResponse,
    WorkersAiPostRunHfGoogleGemma7bItError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunHfGoogleGemma7bItPathParams
  >({ url: '/accounts/{accountId}/ai/run/@hf/google/gemma-7b-it', method: 'post', ...variables, signal });

export type WorkersAiPostRunHfMetaLlamaMetaLlama38bInstructPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunHfMetaLlamaMetaLlama38bInstructError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunHfMetaLlamaMetaLlama38bInstructResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunHfMetaLlamaMetaLlama38bInstructVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunHfMetaLlamaMetaLlama38bInstructPathParams;
} & FetcherExtraProps;

export const workersAiPostRunHfMetaLlamaMetaLlama38bInstruct = (
  variables: WorkersAiPostRunHfMetaLlamaMetaLlama38bInstructVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunHfMetaLlamaMetaLlama38bInstructResponse,
    WorkersAiPostRunHfMetaLlamaMetaLlama38bInstructError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunHfMetaLlamaMetaLlama38bInstructPathParams
  >({
    url: '/accounts/{accountId}/ai/run/@hf/meta-llama/meta-llama-3-8b-instruct',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunHfMistralMistral7bInstructV02PathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunHfMistralMistral7bInstructV02Error = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunHfMistralMistral7bInstructV02Response = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunHfMistralMistral7bInstructV02Variables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunHfMistralMistral7bInstructV02PathParams;
} & FetcherExtraProps;

export const workersAiPostRunHfMistralMistral7bInstructV02 = (
  variables: WorkersAiPostRunHfMistralMistral7bInstructV02Variables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunHfMistralMistral7bInstructV02Response,
    WorkersAiPostRunHfMistralMistral7bInstructV02Error,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunHfMistralMistral7bInstructV02PathParams
  >({ url: '/accounts/{accountId}/ai/run/@hf/mistral/mistral-7b-instruct-v0.2', method: 'post', ...variables, signal });

export type WorkersAiPostRunHfMistralaiMistral7bInstructV02PathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunHfMistralaiMistral7bInstructV02Error = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunHfMistralaiMistral7bInstructV02Response = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunHfMistralaiMistral7bInstructV02Variables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunHfMistralaiMistral7bInstructV02PathParams;
} & FetcherExtraProps;

export const workersAiPostRunHfMistralaiMistral7bInstructV02 = (
  variables: WorkersAiPostRunHfMistralaiMistral7bInstructV02Variables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunHfMistralaiMistral7bInstructV02Response,
    WorkersAiPostRunHfMistralaiMistral7bInstructV02Error,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunHfMistralaiMistral7bInstructV02PathParams
  >({
    url: '/accounts/{accountId}/ai/run/@hf/mistralai/mistral-7b-instruct-v0.2',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunHfNexusflowStarlingLm7bBetaPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunHfNexusflowStarlingLm7bBetaError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunHfNexusflowStarlingLm7bBetaResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunHfNexusflowStarlingLm7bBetaVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunHfNexusflowStarlingLm7bBetaPathParams;
} & FetcherExtraProps;

export const workersAiPostRunHfNexusflowStarlingLm7bBeta = (
  variables: WorkersAiPostRunHfNexusflowStarlingLm7bBetaVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunHfNexusflowStarlingLm7bBetaResponse,
    WorkersAiPostRunHfNexusflowStarlingLm7bBetaError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunHfNexusflowStarlingLm7bBetaPathParams
  >({ url: '/accounts/{accountId}/ai/run/@hf/nexusflow/starling-lm-7b-beta', method: 'post', ...variables, signal });

export type WorkersAiPostRunHfNousresearchHermes2ProMistral7bPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunHfNousresearchHermes2ProMistral7bError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunHfNousresearchHermes2ProMistral7bResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunHfNousresearchHermes2ProMistral7bVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunHfNousresearchHermes2ProMistral7bPathParams;
} & FetcherExtraProps;

export const workersAiPostRunHfNousresearchHermes2ProMistral7b = (
  variables: WorkersAiPostRunHfNousresearchHermes2ProMistral7bVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunHfNousresearchHermes2ProMistral7bResponse,
    WorkersAiPostRunHfNousresearchHermes2ProMistral7bError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunHfNousresearchHermes2ProMistral7bPathParams
  >({
    url: '/accounts/{accountId}/ai/run/@hf/nousresearch/hermes-2-pro-mistral-7b',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunHfTheblokeDeepseekCoder67bBaseAwqPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunHfTheblokeDeepseekCoder67bBaseAwqError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunHfTheblokeDeepseekCoder67bBaseAwqResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunHfTheblokeDeepseekCoder67bBaseAwqVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunHfTheblokeDeepseekCoder67bBaseAwqPathParams;
} & FetcherExtraProps;

export const workersAiPostRunHfTheblokeDeepseekCoder67bBaseAwq = (
  variables: WorkersAiPostRunHfTheblokeDeepseekCoder67bBaseAwqVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunHfTheblokeDeepseekCoder67bBaseAwqResponse,
    WorkersAiPostRunHfTheblokeDeepseekCoder67bBaseAwqError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunHfTheblokeDeepseekCoder67bBaseAwqPathParams
  >({
    url: '/accounts/{accountId}/ai/run/@hf/thebloke/deepseek-coder-6.7b-base-awq',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunHfTheblokeDeepseekCoder67bInstructAwqPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunHfTheblokeDeepseekCoder67bInstructAwqError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunHfTheblokeDeepseekCoder67bInstructAwqResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunHfTheblokeDeepseekCoder67bInstructAwqVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunHfTheblokeDeepseekCoder67bInstructAwqPathParams;
} & FetcherExtraProps;

export const workersAiPostRunHfTheblokeDeepseekCoder67bInstructAwq = (
  variables: WorkersAiPostRunHfTheblokeDeepseekCoder67bInstructAwqVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunHfTheblokeDeepseekCoder67bInstructAwqResponse,
    WorkersAiPostRunHfTheblokeDeepseekCoder67bInstructAwqError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunHfTheblokeDeepseekCoder67bInstructAwqPathParams
  >({
    url: '/accounts/{accountId}/ai/run/@hf/thebloke/deepseek-coder-6.7b-instruct-awq',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunHfTheblokeLlama213bChatAwqPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunHfTheblokeLlama213bChatAwqError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunHfTheblokeLlama213bChatAwqResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunHfTheblokeLlama213bChatAwqVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunHfTheblokeLlama213bChatAwqPathParams;
} & FetcherExtraProps;

export const workersAiPostRunHfTheblokeLlama213bChatAwq = (
  variables: WorkersAiPostRunHfTheblokeLlama213bChatAwqVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunHfTheblokeLlama213bChatAwqResponse,
    WorkersAiPostRunHfTheblokeLlama213bChatAwqError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunHfTheblokeLlama213bChatAwqPathParams
  >({ url: '/accounts/{accountId}/ai/run/@hf/thebloke/llama-2-13b-chat-awq', method: 'post', ...variables, signal });

export type WorkersAiPostRunHfTheblokeLlamaguard7bAwqPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunHfTheblokeLlamaguard7bAwqError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunHfTheblokeLlamaguard7bAwqResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunHfTheblokeLlamaguard7bAwqVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunHfTheblokeLlamaguard7bAwqPathParams;
} & FetcherExtraProps;

export const workersAiPostRunHfTheblokeLlamaguard7bAwq = (
  variables: WorkersAiPostRunHfTheblokeLlamaguard7bAwqVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunHfTheblokeLlamaguard7bAwqResponse,
    WorkersAiPostRunHfTheblokeLlamaguard7bAwqError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunHfTheblokeLlamaguard7bAwqPathParams
  >({ url: '/accounts/{accountId}/ai/run/@hf/thebloke/llamaguard-7b-awq', method: 'post', ...variables, signal });

export type WorkersAiPostRunHfTheblokeMistral7bInstructV01AwqPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunHfTheblokeMistral7bInstructV01AwqError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunHfTheblokeMistral7bInstructV01AwqResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunHfTheblokeMistral7bInstructV01AwqVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunHfTheblokeMistral7bInstructV01AwqPathParams;
} & FetcherExtraProps;

export const workersAiPostRunHfTheblokeMistral7bInstructV01Awq = (
  variables: WorkersAiPostRunHfTheblokeMistral7bInstructV01AwqVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunHfTheblokeMistral7bInstructV01AwqResponse,
    WorkersAiPostRunHfTheblokeMistral7bInstructV01AwqError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunHfTheblokeMistral7bInstructV01AwqPathParams
  >({
    url: '/accounts/{accountId}/ai/run/@hf/thebloke/mistral-7b-instruct-v0.1-awq',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunHfTheblokeNeuralChat7bV31AwqPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunHfTheblokeNeuralChat7bV31AwqError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunHfTheblokeNeuralChat7bV31AwqResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunHfTheblokeNeuralChat7bV31AwqVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunHfTheblokeNeuralChat7bV31AwqPathParams;
} & FetcherExtraProps;

export const workersAiPostRunHfTheblokeNeuralChat7bV31Awq = (
  variables: WorkersAiPostRunHfTheblokeNeuralChat7bV31AwqVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunHfTheblokeNeuralChat7bV31AwqResponse,
    WorkersAiPostRunHfTheblokeNeuralChat7bV31AwqError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunHfTheblokeNeuralChat7bV31AwqPathParams
  >({ url: '/accounts/{accountId}/ai/run/@hf/thebloke/neural-chat-7b-v3-1-awq', method: 'post', ...variables, signal });

export type WorkersAiPostRunHfTheblokeOpenhermes25Mistral7bAwqPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunHfTheblokeOpenhermes25Mistral7bAwqError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunHfTheblokeOpenhermes25Mistral7bAwqResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunHfTheblokeOpenhermes25Mistral7bAwqVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunHfTheblokeOpenhermes25Mistral7bAwqPathParams;
} & FetcherExtraProps;

export const workersAiPostRunHfTheblokeOpenhermes25Mistral7bAwq = (
  variables: WorkersAiPostRunHfTheblokeOpenhermes25Mistral7bAwqVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunHfTheblokeOpenhermes25Mistral7bAwqResponse,
    WorkersAiPostRunHfTheblokeOpenhermes25Mistral7bAwqError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunHfTheblokeOpenhermes25Mistral7bAwqPathParams
  >({
    url: '/accounts/{accountId}/ai/run/@hf/thebloke/openhermes-2.5-mistral-7b-awq',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersAiPostRunHfTheblokeZephyr7bBetaAwqPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiPostRunHfTheblokeZephyr7bBetaAwqError = Fetcher.ErrorWrapper<undefined>;

export type WorkersAiPostRunHfTheblokeZephyr7bBetaAwqResponse = {
  result?:
    | {
        /**
         * The generated text response from the model
         */
        response?: string;
        /**
         * An array of tool calls requests made during the response generation
         */
        tool_calls?: {
          /**
           * The arguments passed to be passed to the tool call request
           */
          arguments?: Record<string, any>;
          /**
           * The name of the tool to be called
           */
          name?: string;
        }[];
      }
    | Blob;
  /**
   * @default true
   */
  success?: boolean;
};

export type WorkersAiPostRunHfTheblokeZephyr7bBetaAwqVariables = {
  body?:
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      };
  pathParams: WorkersAiPostRunHfTheblokeZephyr7bBetaAwqPathParams;
} & FetcherExtraProps;

export const workersAiPostRunHfTheblokeZephyr7bBetaAwq = (
  variables: WorkersAiPostRunHfTheblokeZephyr7bBetaAwqVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersAiPostRunHfTheblokeZephyr7bBetaAwqResponse,
    WorkersAiPostRunHfTheblokeZephyr7bBetaAwqError,
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        /**
         * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
         */
        lora?: string;
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * The input text prompt for the model to generate a response.
         *
         * @maxLength 131072
         * @minLength 1
         */
        prompt: string;
        /**
         * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
         *
         * @default false
         */
        raw?: boolean;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      }
    | {
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         *
         * @maximum 2
         * @minimum 0
         */
        frequency_penalty?: number;
        functions?: {
          code: string;
          name: string;
        }[];
        /**
         * The maximum number of tokens to generate in the response.
         *
         * @default 256
         */
        max_tokens?: number;
        /**
         * An array of message objects representing the conversation history.
         */
        messages: {
          /**
           * The content of the message as a string.
           *
           * @maxLength 131072
           */
          content: string;
          /**
           * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
           */
          role: string;
        }[];
        /**
         * Increases the likelihood of the model introducing new topics.
         *
         * @maximum 2
         * @minimum 0
         */
        presence_penalty?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         *
         * @maximum 2
         * @minimum 0
         */
        repetition_penalty?: number;
        /**
         * Random seed for reproducibility of the generation.
         *
         * @maximum 9999999999
         * @minimum 1
         */
        seed?: number;
        /**
         * If true, the response will be streamed back incrementally.
         *
         * @default false
         */
        stream?: boolean;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         *
         * @default 0.6
         * @maximum 5
         * @minimum 0
         */
        temperature?: number;
        /**
         * A list of tools available for the assistant to use.
         */
        tools?: (
          | {
              /**
               * A brief description of what the tool does.
               */
              description: string;
              /**
               * The name of the tool. More descriptive the better.
               */
              name: string;
              /**
               * Schema defining the parameters accepted by the tool.
               */
              parameters: {
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                  [key: string]: {
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                  };
                };
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
              };
            }
          | {
              /**
               * Details of the function tool.
               */
              ['function']: {
                /**
                 * A brief description of what the function does.
                 */
                description: string;
                /**
                 * The name of the function.
                 */
                name: string;
                /**
                 * Schema defining the parameters accepted by the function.
                 */
                parameters: {
                  /**
                   * Definitions of each parameter.
                   */
                  properties: {
                    [key: string]: {
                      /**
                       * A description of the expected parameter.
                       */
                      description: string;
                      /**
                       * The data type of the parameter.
                       */
                      type: string;
                    };
                  };
                  /**
                   * List of required parameter names.
                   */
                  required?: string[];
                  /**
                   * The type of the parameters object (usually 'object').
                   */
                  type: string;
                };
              };
              /**
               * Specifies the type of tool (e.g., 'function').
               */
              type: string;
            }
        )[];
        /**
         * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
         *
         * @maximum 50
         * @minimum 1
         */
        top_k?: number;
        /**
         * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         *
         * @maximum 2
         * @minimum 0
         */
        top_p?: number;
      },
    {},
    {},
    WorkersAiPostRunHfTheblokeZephyr7bBetaAwqPathParams
  >({ url: '/accounts/{accountId}/ai/run/@hf/thebloke/zephyr-7b-beta-awq', method: 'post', ...variables, signal });

export type WorkersAiPostRunModelPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
  modelName: string;
};

export type WorkersAiPostRunModelError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type WorkersAiPostRunModelResponse = {
  result?:
    | {
        /**
         * The classification label assigned to the text (e.g., 'POSITIVE' or 'NEGATIVE')
         */
        label?: string;
        /**
         * Confidence score indicating the likelihood that the text belongs to the specified label
         */
        score?: number;
      }[]
    | Blob
    | (
        | {
            /**
             * The generated audio in MP3 format, base64-encoded
             */
            audio?: string;
          }
        | Blob
      )
    | {
        /**
         * Embeddings of the requested text values
         */
        data?: number[][];
        shape?: number[];
      }
    | {
        /**
         * The transcription
         */
        text: string;
        vtt?: string;
        word_count?: number;
        words?: {
          /**
           * The ending second when the word completes
           */
          end?: number;
          /**
           * The second this word begins in the recording
           */
          start?: number;
          word?: string;
        }[];
      }
    | {
        /**
         * The predicted category or class for the input image based on analysis
         */
        label?: string;
        /**
         * A confidence value, between 0 and 1, indicating how certain the model is about the predicted label
         */
        score?: number;
      }[]
    | {
        /**
         * Coordinates defining the bounding box around the detected object
         */
        box?: {
          /**
           * The x-coordinate of the bottom-right corner of the bounding box
           */
          xmax?: number;
          /**
           * The x-coordinate of the top-left corner of the bounding box
           */
          xmin?: number;
          /**
           * The y-coordinate of the bottom-right corner of the bounding box
           */
          ymax?: number;
          /**
           * The y-coordinate of the top-left corner of the bounding box
           */
          ymin?: number;
        };
        /**
         * The class label or name of the detected object
         */
        label?: string;
        /**
         * Confidence score indicating the likelihood that the detection is correct
         */
        score?: number;
      }[]
    | (
        | {
            /**
             * The generated text response from the model
             */
            response?: string;
            /**
             * An array of tool calls requests made during the response generation
             */
            tool_calls?: {
              /**
               * The arguments passed to be passed to the tool call request
               */
              arguments?: Record<string, any>;
              /**
               * The name of the tool to be called
               */
              name?: string;
            }[];
          }
        | Blob
      )
    | {
        /**
         * The translated text in the target language
         */
        translated_text?: string;
      }
    | {
        /**
         * The summarized version of the input text
         */
        summary?: string;
      }
    | {
        description?: string;
      };
};

export type WorkersAiPostRunModelVariables = {
  body?:
    | {
        /**
         * The text that you want to classify
         *
         * @minLength 1
         */
        text: string;
      }
    | {
        /**
         * Controls how closely the generated image should adhere to the prompt; higher values make the image more aligned with the prompt
         *
         * @default 7.5
         */
        guidance?: number;
        /**
         * The height of the generated image in pixels
         *
         * @maximum 2048
         * @minimum 256
         */
        height?: number;
        /**
         * For use with img2img tasks. An array of integers that represent the image data constrained to 8-bit unsigned integer values
         */
        image?: number[];
        /**
         * For use with img2img tasks. A base64-encoded string of the input image
         */
        image_b64?: string;
        /**
         * An array representing An array of integers that represent mask image data for inpainting constrained to 8-bit unsigned integer values
         */
        mask?: number[];
        /**
         * Text describing elements to avoid in the generated image
         */
        negative_prompt?: string;
        /**
         * The number of diffusion steps; higher values can improve quality but take longer
         *
         * @default 20
         * @maximum 20
         */
        num_steps?: number;
        /**
         * A text description of the image you want to generate
         *
         * @minLength 1
         */
        prompt: string;
        /**
         * Random seed for reproducibility of the image generation
         */
        seed?: number;
        /**
         * A value between 0 and 1 indicating how strongly to apply the transformation during img2img tasks; lower values make the output closer to the input image
         *
         * @default 1
         */
        strength?: number;
        /**
         * The width of the generated image in pixels
         *
         * @maximum 2048
         * @minimum 256
         */
        width?: number;
      }
    | {
        /**
         * The speech language (e.g., 'en' for English, 'fr' for French). Defaults to 'en' if not specified
         *
         * @default en
         */
        lang?: string;
        /**
         * A text description of the image you want to generate
         *
         * @minLength 1
         */
        prompt: string;
      }
    | {
        text: string | string[];
      }
    | (
        | Blob
        | {
            /**
             * An array of integers that represent the audio data constrained to 8-bit unsigned integer values
             */
            audio: number[];
            /**
             * The language of the recorded audio
             */
            source_lang?: string;
            /**
             * The language to translate the transcription into. Currently only English is supported.
             */
            target_lang?: string;
          }
      )
    | (
        | Blob
        | {
            /**
             * An array of integers that represent the image data constrained to 8-bit unsigned integer values
             */
            image: number[];
          }
      )
    | (
        | Blob
        | {
            /**
             * An array of integers that represent the image data constrained to 8-bit unsigned integer values
             */
            image?: number[];
          }
      )
    | (
        | {
            /**
             * Decreases the likelihood of the model repeating the same lines verbatim.
             *
             * @maximum 2
             * @minimum 0
             */
            frequency_penalty?: number;
            /**
             * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
             */
            lora?: string;
            /**
             * The maximum number of tokens to generate in the response.
             *
             * @default 256
             */
            max_tokens?: number;
            /**
             * Increases the likelihood of the model introducing new topics.
             *
             * @maximum 2
             * @minimum 0
             */
            presence_penalty?: number;
            /**
             * The input text prompt for the model to generate a response.
             *
             * @maxLength 131072
             * @minLength 1
             */
            prompt: string;
            /**
             * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
             *
             * @default false
             */
            raw?: boolean;
            /**
             * Penalty for repeated tokens; higher values discourage repetition.
             *
             * @maximum 2
             * @minimum 0
             */
            repetition_penalty?: number;
            /**
             * Random seed for reproducibility of the generation.
             *
             * @maximum 9999999999
             * @minimum 1
             */
            seed?: number;
            /**
             * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
             *
             * @default false
             */
            stream?: boolean;
            /**
             * Controls the randomness of the output; higher values produce more random results.
             *
             * @default 0.6
             * @maximum 5
             * @minimum 0
             */
            temperature?: number;
            /**
             * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
             *
             * @maximum 50
             * @minimum 1
             */
            top_k?: number;
            /**
             * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
             *
             * @maximum 2
             * @minimum 0
             */
            top_p?: number;
          }
        | {
            /**
             * Decreases the likelihood of the model repeating the same lines verbatim.
             *
             * @maximum 2
             * @minimum 0
             */
            frequency_penalty?: number;
            functions?: {
              code: string;
              name: string;
            }[];
            /**
             * The maximum number of tokens to generate in the response.
             *
             * @default 256
             */
            max_tokens?: number;
            /**
             * An array of message objects representing the conversation history.
             */
            messages: {
              /**
               * The content of the message as a string.
               *
               * @maxLength 131072
               */
              content: string;
              /**
               * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
               */
              role: string;
            }[];
            /**
             * Increases the likelihood of the model introducing new topics.
             *
             * @maximum 2
             * @minimum 0
             */
            presence_penalty?: number;
            /**
             * Penalty for repeated tokens; higher values discourage repetition.
             *
             * @maximum 2
             * @minimum 0
             */
            repetition_penalty?: number;
            /**
             * Random seed for reproducibility of the generation.
             *
             * @maximum 9999999999
             * @minimum 1
             */
            seed?: number;
            /**
             * If true, the response will be streamed back incrementally.
             *
             * @default false
             */
            stream?: boolean;
            /**
             * Controls the randomness of the output; higher values produce more random results.
             *
             * @default 0.6
             * @maximum 5
             * @minimum 0
             */
            temperature?: number;
            /**
             * A list of tools available for the assistant to use.
             */
            tools?: (
              | {
                  /**
                   * A brief description of what the tool does.
                   */
                  description: string;
                  /**
                   * The name of the tool. More descriptive the better.
                   */
                  name: string;
                  /**
                   * Schema defining the parameters accepted by the tool.
                   */
                  parameters: {
                    /**
                     * Definitions of each parameter.
                     */
                    properties: {
                      [key: string]: {
                        /**
                         * A description of the expected parameter.
                         */
                        description: string;
                        /**
                         * The data type of the parameter.
                         */
                        type: string;
                      };
                    };
                    /**
                     * List of required parameter names.
                     */
                    required?: string[];
                    /**
                     * The type of the parameters object (usually 'object').
                     */
                    type: string;
                  };
                }
              | {
                  /**
                   * Details of the function tool.
                   */
                  ['function']: {
                    /**
                     * A brief description of what the function does.
                     */
                    description: string;
                    /**
                     * The name of the function.
                     */
                    name: string;
                    /**
                     * Schema defining the parameters accepted by the function.
                     */
                    parameters: {
                      /**
                       * Definitions of each parameter.
                       */
                      properties: {
                        [key: string]: {
                          /**
                           * A description of the expected parameter.
                           */
                          description: string;
                          /**
                           * The data type of the parameter.
                           */
                          type: string;
                        };
                      };
                      /**
                       * List of required parameter names.
                       */
                      required?: string[];
                      /**
                       * The type of the parameters object (usually 'object').
                       */
                      type: string;
                    };
                  };
                  /**
                   * Specifies the type of tool (e.g., 'function').
                   */
                  type: string;
                }
            )[];
            /**
             * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
             *
             * @maximum 50
             * @minimum 1
             */
            top_k?: number;
            /**
             * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
             *
             * @maximum 2
             * @minimum 0
             */
            top_p?: number;
          }
      )
    | {
        /**
         * The language code of the source text (e.g., 'en' for English). Defaults to 'en' if not specified
         *
         * @default en
         */
        source_lang?: string;
        /**
         * The language code to translate the text into (e.g., 'es' for Spanish)
         */
        target_lang: string;
        /**
         * The text to be translated
         *
         * @minLength 1
         */
        text: string;
      }
    | {
        /**
         * The text that you want the model to summarize
         *
         * @minLength 1
         */
        input_text: string;
        /**
         * The maximum length of the generated summary in tokens
         *
         * @default 1024
         */
        max_length?: number;
      }
    | (
        | Blob
        | {
            image: number[] | Blob;
            /**
             * The maximum number of tokens to generate in the response.
             *
             * @default 512
             */
            max_tokens?: number;
            /**
             * The input text prompt for the model to generate a response.
             */
            prompt?: string;
            /**
             * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
             *
             * @default false
             */
            raw?: boolean;
            /**
             * Controls the randomness of the output; higher values produce more random results.
             */
            temperature?: number;
          }
      );
  pathParams: WorkersAiPostRunModelPathParams;
} & FetcherExtraProps;

/**
 * This endpoint provides users with the capability to run specific AI models on-demand.
 *
 * By submitting the required input data, users can receive real-time predictions or results generated by the chosen AI
 * model. The endpoint supports various AI model types, ensuring flexibility and adaptability for diverse use cases.
 *
 * Model specific inputs available in [Cloudflare Docs](https://developers.cloudflare.com/workers-ai/models/).
 */
export const workersAiPostRunModel = (variables: WorkersAiPostRunModelVariables, signal?: AbortSignal) =>
  fetch<
    WorkersAiPostRunModelResponse,
    WorkersAiPostRunModelError,
    | {
        /**
         * The text that you want to classify
         *
         * @minLength 1
         */
        text: string;
      }
    | {
        /**
         * Controls how closely the generated image should adhere to the prompt; higher values make the image more aligned with the prompt
         *
         * @default 7.5
         */
        guidance?: number;
        /**
         * The height of the generated image in pixels
         *
         * @maximum 2048
         * @minimum 256
         */
        height?: number;
        /**
         * For use with img2img tasks. An array of integers that represent the image data constrained to 8-bit unsigned integer values
         */
        image?: number[];
        /**
         * For use with img2img tasks. A base64-encoded string of the input image
         */
        image_b64?: string;
        /**
         * An array representing An array of integers that represent mask image data for inpainting constrained to 8-bit unsigned integer values
         */
        mask?: number[];
        /**
         * Text describing elements to avoid in the generated image
         */
        negative_prompt?: string;
        /**
         * The number of diffusion steps; higher values can improve quality but take longer
         *
         * @default 20
         * @maximum 20
         */
        num_steps?: number;
        /**
         * A text description of the image you want to generate
         *
         * @minLength 1
         */
        prompt: string;
        /**
         * Random seed for reproducibility of the image generation
         */
        seed?: number;
        /**
         * A value between 0 and 1 indicating how strongly to apply the transformation during img2img tasks; lower values make the output closer to the input image
         *
         * @default 1
         */
        strength?: number;
        /**
         * The width of the generated image in pixels
         *
         * @maximum 2048
         * @minimum 256
         */
        width?: number;
      }
    | {
        /**
         * The speech language (e.g., 'en' for English, 'fr' for French). Defaults to 'en' if not specified
         *
         * @default en
         */
        lang?: string;
        /**
         * A text description of the image you want to generate
         *
         * @minLength 1
         */
        prompt: string;
      }
    | {
        text: string | string[];
      }
    | (
        | Blob
        | {
            /**
             * An array of integers that represent the audio data constrained to 8-bit unsigned integer values
             */
            audio: number[];
            /**
             * The language of the recorded audio
             */
            source_lang?: string;
            /**
             * The language to translate the transcription into. Currently only English is supported.
             */
            target_lang?: string;
          }
      )
    | (
        | Blob
        | {
            /**
             * An array of integers that represent the image data constrained to 8-bit unsigned integer values
             */
            image: number[];
          }
      )
    | (
        | Blob
        | {
            /**
             * An array of integers that represent the image data constrained to 8-bit unsigned integer values
             */
            image?: number[];
          }
      )
    | (
        | {
            /**
             * Decreases the likelihood of the model repeating the same lines verbatim.
             *
             * @maximum 2
             * @minimum 0
             */
            frequency_penalty?: number;
            /**
             * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
             */
            lora?: string;
            /**
             * The maximum number of tokens to generate in the response.
             *
             * @default 256
             */
            max_tokens?: number;
            /**
             * Increases the likelihood of the model introducing new topics.
             *
             * @maximum 2
             * @minimum 0
             */
            presence_penalty?: number;
            /**
             * The input text prompt for the model to generate a response.
             *
             * @maxLength 131072
             * @minLength 1
             */
            prompt: string;
            /**
             * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
             *
             * @default false
             */
            raw?: boolean;
            /**
             * Penalty for repeated tokens; higher values discourage repetition.
             *
             * @maximum 2
             * @minimum 0
             */
            repetition_penalty?: number;
            /**
             * Random seed for reproducibility of the generation.
             *
             * @maximum 9999999999
             * @minimum 1
             */
            seed?: number;
            /**
             * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
             *
             * @default false
             */
            stream?: boolean;
            /**
             * Controls the randomness of the output; higher values produce more random results.
             *
             * @default 0.6
             * @maximum 5
             * @minimum 0
             */
            temperature?: number;
            /**
             * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
             *
             * @maximum 50
             * @minimum 1
             */
            top_k?: number;
            /**
             * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
             *
             * @maximum 2
             * @minimum 0
             */
            top_p?: number;
          }
        | {
            /**
             * Decreases the likelihood of the model repeating the same lines verbatim.
             *
             * @maximum 2
             * @minimum 0
             */
            frequency_penalty?: number;
            functions?: {
              code: string;
              name: string;
            }[];
            /**
             * The maximum number of tokens to generate in the response.
             *
             * @default 256
             */
            max_tokens?: number;
            /**
             * An array of message objects representing the conversation history.
             */
            messages: {
              /**
               * The content of the message as a string.
               *
               * @maxLength 131072
               */
              content: string;
              /**
               * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
               */
              role: string;
            }[];
            /**
             * Increases the likelihood of the model introducing new topics.
             *
             * @maximum 2
             * @minimum 0
             */
            presence_penalty?: number;
            /**
             * Penalty for repeated tokens; higher values discourage repetition.
             *
             * @maximum 2
             * @minimum 0
             */
            repetition_penalty?: number;
            /**
             * Random seed for reproducibility of the generation.
             *
             * @maximum 9999999999
             * @minimum 1
             */
            seed?: number;
            /**
             * If true, the response will be streamed back incrementally.
             *
             * @default false
             */
            stream?: boolean;
            /**
             * Controls the randomness of the output; higher values produce more random results.
             *
             * @default 0.6
             * @maximum 5
             * @minimum 0
             */
            temperature?: number;
            /**
             * A list of tools available for the assistant to use.
             */
            tools?: (
              | {
                  /**
                   * A brief description of what the tool does.
                   */
                  description: string;
                  /**
                   * The name of the tool. More descriptive the better.
                   */
                  name: string;
                  /**
                   * Schema defining the parameters accepted by the tool.
                   */
                  parameters: {
                    /**
                     * Definitions of each parameter.
                     */
                    properties: {
                      [key: string]: {
                        /**
                         * A description of the expected parameter.
                         */
                        description: string;
                        /**
                         * The data type of the parameter.
                         */
                        type: string;
                      };
                    };
                    /**
                     * List of required parameter names.
                     */
                    required?: string[];
                    /**
                     * The type of the parameters object (usually 'object').
                     */
                    type: string;
                  };
                }
              | {
                  /**
                   * Details of the function tool.
                   */
                  ['function']: {
                    /**
                     * A brief description of what the function does.
                     */
                    description: string;
                    /**
                     * The name of the function.
                     */
                    name: string;
                    /**
                     * Schema defining the parameters accepted by the function.
                     */
                    parameters: {
                      /**
                       * Definitions of each parameter.
                       */
                      properties: {
                        [key: string]: {
                          /**
                           * A description of the expected parameter.
                           */
                          description: string;
                          /**
                           * The data type of the parameter.
                           */
                          type: string;
                        };
                      };
                      /**
                       * List of required parameter names.
                       */
                      required?: string[];
                      /**
                       * The type of the parameters object (usually 'object').
                       */
                      type: string;
                    };
                  };
                  /**
                   * Specifies the type of tool (e.g., 'function').
                   */
                  type: string;
                }
            )[];
            /**
             * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
             *
             * @maximum 50
             * @minimum 1
             */
            top_k?: number;
            /**
             * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
             *
             * @maximum 2
             * @minimum 0
             */
            top_p?: number;
          }
      )
    | {
        /**
         * The language code of the source text (e.g., 'en' for English). Defaults to 'en' if not specified
         *
         * @default en
         */
        source_lang?: string;
        /**
         * The language code to translate the text into (e.g., 'es' for Spanish)
         */
        target_lang: string;
        /**
         * The text to be translated
         *
         * @minLength 1
         */
        text: string;
      }
    | {
        /**
         * The text that you want the model to summarize
         *
         * @minLength 1
         */
        input_text: string;
        /**
         * The maximum length of the generated summary in tokens
         *
         * @default 1024
         */
        max_length?: number;
      }
    | (
        | Blob
        | {
            image: number[] | Blob;
            /**
             * The maximum number of tokens to generate in the response.
             *
             * @default 512
             */
            max_tokens?: number;
            /**
             * The input text prompt for the model to generate a response.
             */
            prompt?: string;
            /**
             * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
             *
             * @default false
             */
            raw?: boolean;
            /**
             * Controls the randomness of the output; higher values produce more random results.
             */
            temperature?: number;
          }
      ),
    {},
    {},
    WorkersAiPostRunModelPathParams
  >({ url: '/accounts/{accountId}/ai/run/{modelName}', method: 'post', ...variables, signal });

export type WorkersAiSearchTaskPathParams = {
  /**
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   */
  accountId: string;
};

export type WorkersAiSearchTaskError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    error: string;
    success: boolean;
  };
}>;

export type WorkersAiSearchTaskResponse = {
  errors: Record<string, any>[];
  messages: Record<string, any>[];
  result: Record<string, any>[];
  success: boolean;
};

export type WorkersAiSearchTaskVariables = {
  pathParams: WorkersAiSearchTaskPathParams;
} & FetcherExtraProps;

export const workersAiSearchTask = (variables: WorkersAiSearchTaskVariables, signal?: AbortSignal) =>
  fetch<WorkersAiSearchTaskResponse, WorkersAiSearchTaskError, undefined, {}, {}, WorkersAiSearchTaskPathParams>({
    url: '/accounts/{accountId}/ai/tasks/search',
    method: 'get',
    ...variables,
    signal
  });

export type NotificationAlertTypesGetAlertTypesPathParams = {
  accountId: Schemas.AaaAccountId;
};

export type NotificationAlertTypesGetAlertTypesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaResponseCollection & Schemas.AaaComponentsSchemasApiResponseCommonFailure;
}>;

export type NotificationAlertTypesGetAlertTypesVariables = {
  pathParams: NotificationAlertTypesGetAlertTypesPathParams;
} & FetcherExtraProps;

/**
 * Gets a list of all alert types for which an account is eligible.
 */
export const notificationAlertTypesGetAlertTypes = (
  variables: NotificationAlertTypesGetAlertTypesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaResponseCollection,
    NotificationAlertTypesGetAlertTypesError,
    undefined,
    {},
    {},
    NotificationAlertTypesGetAlertTypesPathParams
  >({ url: '/accounts/{accountId}/alerting/v3/available_alerts', method: 'get', ...variables, signal });

export type NotificationMechanismEligibilityGetDeliveryMechanismEligibilityPathParams = {
  accountId: Schemas.AaaAccountId;
};

export type NotificationMechanismEligibilityGetDeliveryMechanismEligibilityError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaSchemasResponseCollection & Schemas.AaaComponentsSchemasApiResponseCommonFailure;
}>;

export type NotificationMechanismEligibilityGetDeliveryMechanismEligibilityVariables = {
  pathParams: NotificationMechanismEligibilityGetDeliveryMechanismEligibilityPathParams;
} & FetcherExtraProps;

/**
 * Get a list of all delivery mechanism types for which an account is eligible.
 */
export const notificationMechanismEligibilityGetDeliveryMechanismEligibility = (
  variables: NotificationMechanismEligibilityGetDeliveryMechanismEligibilityVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaSchemasResponseCollection,
    NotificationMechanismEligibilityGetDeliveryMechanismEligibilityError,
    undefined,
    {},
    {},
    NotificationMechanismEligibilityGetDeliveryMechanismEligibilityPathParams
  >({ url: '/accounts/{accountId}/alerting/v3/destinations/eligible', method: 'get', ...variables, signal });

export type NotificationDestinationsWithPagerDutyDeletePagerDutyServicesPathParams = {
  accountId: Schemas.AaaAccountId;
};

export type NotificationDestinationsWithPagerDutyDeletePagerDutyServicesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaApiResponseCollection & Schemas.AaaComponentsSchemasApiResponseCommonFailure;
}>;

export type NotificationDestinationsWithPagerDutyDeletePagerDutyServicesVariables = {
  pathParams: NotificationDestinationsWithPagerDutyDeletePagerDutyServicesPathParams;
} & FetcherExtraProps;

/**
 * Deletes all the PagerDuty Services connected to the account.
 */
export const notificationDestinationsWithPagerDutyDeletePagerDutyServices = (
  variables: NotificationDestinationsWithPagerDutyDeletePagerDutyServicesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaApiResponseCollection,
    NotificationDestinationsWithPagerDutyDeletePagerDutyServicesError,
    undefined,
    {},
    {},
    NotificationDestinationsWithPagerDutyDeletePagerDutyServicesPathParams
  >({ url: '/accounts/{accountId}/alerting/v3/destinations/pagerduty', method: 'delete', ...variables, signal });

export type NotificationDestinationsWithPagerDutyListPagerDutyServicesPathParams = {
  accountId: Schemas.AaaAccountId;
};

export type NotificationDestinationsWithPagerDutyListPagerDutyServicesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaComponentsSchemasResponseCollection & Schemas.AaaComponentsSchemasApiResponseCommonFailure;
}>;

export type NotificationDestinationsWithPagerDutyListPagerDutyServicesVariables = {
  pathParams: NotificationDestinationsWithPagerDutyListPagerDutyServicesPathParams;
} & FetcherExtraProps;

/**
 * Get a list of all configured PagerDuty services.
 */
export const notificationDestinationsWithPagerDutyListPagerDutyServices = (
  variables: NotificationDestinationsWithPagerDutyListPagerDutyServicesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaComponentsSchemasResponseCollection,
    NotificationDestinationsWithPagerDutyListPagerDutyServicesError,
    undefined,
    {},
    {},
    NotificationDestinationsWithPagerDutyListPagerDutyServicesPathParams
  >({ url: '/accounts/{accountId}/alerting/v3/destinations/pagerduty', method: 'get', ...variables, signal });

export type NotificationDestinationsWithPagerDutyConnectPagerDutyPathParams = {
  accountId: Schemas.AaaAccountId;
};

export type NotificationDestinationsWithPagerDutyConnectPagerDutyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaIdResponse & Schemas.AaaComponentsSchemasApiResponseCommonFailure;
}>;

export type NotificationDestinationsWithPagerDutyConnectPagerDutyVariables = {
  pathParams: NotificationDestinationsWithPagerDutyConnectPagerDutyPathParams;
} & FetcherExtraProps;

/**
 * Creates a new token for integrating with PagerDuty.
 */
export const notificationDestinationsWithPagerDutyConnectPagerDuty = (
  variables: NotificationDestinationsWithPagerDutyConnectPagerDutyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaSensitiveIdResponse,
    NotificationDestinationsWithPagerDutyConnectPagerDutyError,
    undefined,
    {},
    {},
    NotificationDestinationsWithPagerDutyConnectPagerDutyPathParams
  >({ url: '/accounts/{accountId}/alerting/v3/destinations/pagerduty/connect', method: 'post', ...variables, signal });

export type NotificationDestinationsWithPagerDutyConnectPagerDutyTokenPathParams = {
  accountId: Schemas.AaaAccountId;
  tokenId: Schemas.AaaIntegrationToken;
};

export type NotificationDestinationsWithPagerDutyConnectPagerDutyTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaIdResponse & Schemas.AaaComponentsSchemasApiResponseCommonFailure;
}>;

export type NotificationDestinationsWithPagerDutyConnectPagerDutyTokenVariables = {
  pathParams: NotificationDestinationsWithPagerDutyConnectPagerDutyTokenPathParams;
} & FetcherExtraProps;

/**
 * Links PagerDuty with the account using the integration token.
 */
export const notificationDestinationsWithPagerDutyConnectPagerDutyToken = (
  variables: NotificationDestinationsWithPagerDutyConnectPagerDutyTokenVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaIdResponse,
    NotificationDestinationsWithPagerDutyConnectPagerDutyTokenError,
    undefined,
    {},
    {},
    NotificationDestinationsWithPagerDutyConnectPagerDutyTokenPathParams
  >({
    url: '/accounts/{accountId}/alerting/v3/destinations/pagerduty/connect/{tokenId}',
    method: 'get',
    ...variables,
    signal
  });

export type NotificationWebhooksListWebhooksPathParams = {
  accountId: Schemas.AaaAccountId;
};

export type NotificationWebhooksListWebhooksError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaWebhooksComponentsSchemasResponseCollection &
    Schemas.AaaComponentsSchemasApiResponseCommonFailure;
}>;

export type NotificationWebhooksListWebhooksVariables = {
  pathParams: NotificationWebhooksListWebhooksPathParams;
} & FetcherExtraProps;

/**
 * Gets a list of all configured webhook destinations.
 */
export const notificationWebhooksListWebhooks = (
  variables: NotificationWebhooksListWebhooksVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaWebhooksComponentsSchemasResponseCollection,
    NotificationWebhooksListWebhooksError,
    undefined,
    {},
    {},
    NotificationWebhooksListWebhooksPathParams
  >({ url: '/accounts/{accountId}/alerting/v3/destinations/webhooks', method: 'get', ...variables, signal });

export type NotificationWebhooksCreateAWebhookPathParams = {
  accountId: Schemas.AaaAccountId;
};

export type NotificationWebhooksCreateAWebhookError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaIdResponse & Schemas.AaaComponentsSchemasApiResponseCommonFailure;
}>;

export type NotificationWebhooksCreateAWebhookRequestBody = {
  name: Schemas.AaaComponentsSchemasName;
  secret?: Schemas.AaaSecret;
  url: Schemas.AaaUrl;
};

export type NotificationWebhooksCreateAWebhookVariables = {
  body: NotificationWebhooksCreateAWebhookRequestBody;
  pathParams: NotificationWebhooksCreateAWebhookPathParams;
} & FetcherExtraProps;

/**
 * Creates a new webhook destination.
 */
export const notificationWebhooksCreateAWebhook = (
  variables: NotificationWebhooksCreateAWebhookVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaIdResponse,
    NotificationWebhooksCreateAWebhookError,
    NotificationWebhooksCreateAWebhookRequestBody,
    {},
    {},
    NotificationWebhooksCreateAWebhookPathParams
  >({ url: '/accounts/{accountId}/alerting/v3/destinations/webhooks', method: 'post', ...variables, signal });

export type NotificationWebhooksDeleteAWebhookPathParams = {
  webhookId: Schemas.AaaWebhookId;
  accountId: Schemas.AaaAccountId;
};

export type NotificationWebhooksDeleteAWebhookError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaApiResponseCollection & Schemas.AaaComponentsSchemasApiResponseCommonFailure;
}>;

export type NotificationWebhooksDeleteAWebhookVariables = {
  pathParams: NotificationWebhooksDeleteAWebhookPathParams;
} & FetcherExtraProps;

/**
 * Delete a configured webhook destination.
 */
export const notificationWebhooksDeleteAWebhook = (
  variables: NotificationWebhooksDeleteAWebhookVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaApiResponseCollection,
    NotificationWebhooksDeleteAWebhookError,
    undefined,
    {},
    {},
    NotificationWebhooksDeleteAWebhookPathParams
  >({
    url: '/accounts/{accountId}/alerting/v3/destinations/webhooks/{webhookId}',
    method: 'delete',
    ...variables,
    signal
  });

export type NotificationWebhooksGetAWebhookPathParams = {
  accountId: Schemas.AaaAccountId;
  webhookId: Schemas.AaaWebhookId;
};

export type NotificationWebhooksGetAWebhookError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaSchemasSingleResponse & Schemas.AaaComponentsSchemasApiResponseCommonFailure;
}>;

export type NotificationWebhooksGetAWebhookVariables = {
  pathParams: NotificationWebhooksGetAWebhookPathParams;
} & FetcherExtraProps;

/**
 * Get details for a single webhooks destination.
 */
export const notificationWebhooksGetAWebhook = (
  variables: NotificationWebhooksGetAWebhookVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaSchemasSingleResponse,
    NotificationWebhooksGetAWebhookError,
    undefined,
    {},
    {},
    NotificationWebhooksGetAWebhookPathParams
  >({
    url: '/accounts/{accountId}/alerting/v3/destinations/webhooks/{webhookId}',
    method: 'get',
    ...variables,
    signal
  });

export type NotificationWebhooksUpdateAWebhookPathParams = {
  webhookId: Schemas.AaaWebhookId;
  accountId: Schemas.AaaAccountId;
};

export type NotificationWebhooksUpdateAWebhookError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaIdResponse & Schemas.AaaComponentsSchemasApiResponseCommonFailure;
}>;

export type NotificationWebhooksUpdateAWebhookRequestBody = {
  name: Schemas.AaaComponentsSchemasName;
  secret?: Schemas.AaaSecret;
  url: Schemas.AaaUrl;
};

export type NotificationWebhooksUpdateAWebhookVariables = {
  body: NotificationWebhooksUpdateAWebhookRequestBody;
  pathParams: NotificationWebhooksUpdateAWebhookPathParams;
} & FetcherExtraProps;

/**
 * Update a webhook destination.
 */
export const notificationWebhooksUpdateAWebhook = (
  variables: NotificationWebhooksUpdateAWebhookVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaIdResponse,
    NotificationWebhooksUpdateAWebhookError,
    NotificationWebhooksUpdateAWebhookRequestBody,
    {},
    {},
    NotificationWebhooksUpdateAWebhookPathParams
  >({
    url: '/accounts/{accountId}/alerting/v3/destinations/webhooks/{webhookId}',
    method: 'put',
    ...variables,
    signal
  });

export type NotificationHistoryListHistoryPathParams = {
  accountId: Schemas.AaaAccountId;
};

export type NotificationHistoryListHistoryQueryParams = {
  per_page?: Schemas.AaaPerPage;
  before?: Schemas.AaaBefore;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @example 2022-05-19T20:29:58.679897Z
   * @format date-time
   */
  since?: string;
};

export type NotificationHistoryListHistoryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaHistoryComponentsSchemasResponseCollection & Schemas.AaaComponentsSchemasApiResponseCommonFailure;
}>;

export type NotificationHistoryListHistoryVariables = {
  pathParams: NotificationHistoryListHistoryPathParams;
  queryParams?: NotificationHistoryListHistoryQueryParams;
} & FetcherExtraProps;

/**
 * Gets a list of history records for notifications sent to an account. The records are displayed for last `x` number of days based on the zone plan (free = 30, pro = 30, biz = 30, ent = 90).
 */
export const notificationHistoryListHistory = (
  variables: NotificationHistoryListHistoryVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaHistoryComponentsSchemasResponseCollection,
    NotificationHistoryListHistoryError,
    undefined,
    {},
    NotificationHistoryListHistoryQueryParams,
    NotificationHistoryListHistoryPathParams
  >({ url: '/accounts/{accountId}/alerting/v3/history', method: 'get', ...variables, signal });

export type NotificationPoliciesListNotificationPoliciesPathParams = {
  accountId: Schemas.AaaAccountId;
};

export type NotificationPoliciesListNotificationPoliciesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaPoliciesComponentsSchemasResponseCollection &
    Schemas.AaaComponentsSchemasApiResponseCommonFailure;
}>;

export type NotificationPoliciesListNotificationPoliciesVariables = {
  pathParams: NotificationPoliciesListNotificationPoliciesPathParams;
} & FetcherExtraProps;

/**
 * Get a list of all Notification policies.
 */
export const notificationPoliciesListNotificationPolicies = (
  variables: NotificationPoliciesListNotificationPoliciesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaPoliciesComponentsSchemasResponseCollection,
    NotificationPoliciesListNotificationPoliciesError,
    undefined,
    {},
    {},
    NotificationPoliciesListNotificationPoliciesPathParams
  >({ url: '/accounts/{accountId}/alerting/v3/policies', method: 'get', ...variables, signal });

export type NotificationPoliciesCreateANotificationPolicyPathParams = {
  accountId: Schemas.AaaAccountId;
};

export type NotificationPoliciesCreateANotificationPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaIdResponse & Schemas.AaaComponentsSchemasApiResponseCommonFailure;
}>;

export type NotificationPoliciesCreateANotificationPolicyRequestBody = {
  alert_interval?: Schemas.AaaAlertInterval;
  alert_type: Schemas.AaaAlertType;
  description?: Schemas.AaaSchemasDescription;
  enabled: Schemas.AaaEnabled;
  filters?: Schemas.AaaFilters;
  mechanisms: Schemas.AaaMechanisms;
  name: Schemas.AaaSchemasName;
};

export type NotificationPoliciesCreateANotificationPolicyVariables = {
  body: NotificationPoliciesCreateANotificationPolicyRequestBody;
  pathParams: NotificationPoliciesCreateANotificationPolicyPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Notification policy.
 */
export const notificationPoliciesCreateANotificationPolicy = (
  variables: NotificationPoliciesCreateANotificationPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaIdResponse,
    NotificationPoliciesCreateANotificationPolicyError,
    NotificationPoliciesCreateANotificationPolicyRequestBody,
    {},
    {},
    NotificationPoliciesCreateANotificationPolicyPathParams
  >({ url: '/accounts/{accountId}/alerting/v3/policies', method: 'post', ...variables, signal });

export type NotificationPoliciesDeleteANotificationPolicyPathParams = {
  accountId: Schemas.AaaAccountId;
  policyId: Schemas.AaaPolicyId;
};

export type NotificationPoliciesDeleteANotificationPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaApiResponseCollection & Schemas.AaaComponentsSchemasApiResponseCommonFailure;
}>;

export type NotificationPoliciesDeleteANotificationPolicyVariables = {
  pathParams: NotificationPoliciesDeleteANotificationPolicyPathParams;
} & FetcherExtraProps;

/**
 * Delete a Notification policy.
 */
export const notificationPoliciesDeleteANotificationPolicy = (
  variables: NotificationPoliciesDeleteANotificationPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaApiResponseCollection,
    NotificationPoliciesDeleteANotificationPolicyError,
    undefined,
    {},
    {},
    NotificationPoliciesDeleteANotificationPolicyPathParams
  >({ url: '/accounts/{accountId}/alerting/v3/policies/{policyId}', method: 'delete', ...variables, signal });

export type NotificationPoliciesGetANotificationPolicyPathParams = {
  accountId: Schemas.AaaAccountId;
  policyId: Schemas.AaaPolicyId;
};

export type NotificationPoliciesGetANotificationPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaSingleResponse & Schemas.AaaComponentsSchemasApiResponseCommonFailure;
}>;

export type NotificationPoliciesGetANotificationPolicyVariables = {
  pathParams: NotificationPoliciesGetANotificationPolicyPathParams;
} & FetcherExtraProps;

/**
 * Get details for a single policy.
 */
export const notificationPoliciesGetANotificationPolicy = (
  variables: NotificationPoliciesGetANotificationPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaSingleResponse,
    NotificationPoliciesGetANotificationPolicyError,
    undefined,
    {},
    {},
    NotificationPoliciesGetANotificationPolicyPathParams
  >({ url: '/accounts/{accountId}/alerting/v3/policies/{policyId}', method: 'get', ...variables, signal });

export type NotificationPoliciesUpdateANotificationPolicyPathParams = {
  accountId: Schemas.AaaAccountId;
  policyId: Schemas.AaaPolicyId;
};

export type NotificationPoliciesUpdateANotificationPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaIdResponse & Schemas.AaaComponentsSchemasApiResponseCommonFailure;
}>;

export type NotificationPoliciesUpdateANotificationPolicyRequestBody = {
  alert_interval?: Schemas.AaaAlertInterval;
  alert_type?: Schemas.AaaAlertType;
  description?: Schemas.AaaSchemasDescription;
  enabled?: Schemas.AaaEnabled;
  filters?: Schemas.AaaFilters;
  mechanisms?: Schemas.AaaMechanisms;
  name?: Schemas.AaaSchemasName;
};

export type NotificationPoliciesUpdateANotificationPolicyVariables = {
  body?: NotificationPoliciesUpdateANotificationPolicyRequestBody;
  pathParams: NotificationPoliciesUpdateANotificationPolicyPathParams;
} & FetcherExtraProps;

/**
 * Update a Notification policy.
 */
export const notificationPoliciesUpdateANotificationPolicy = (
  variables: NotificationPoliciesUpdateANotificationPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaIdResponse,
    NotificationPoliciesUpdateANotificationPolicyError,
    NotificationPoliciesUpdateANotificationPolicyRequestBody,
    {},
    {},
    NotificationPoliciesUpdateANotificationPolicyPathParams
  >({ url: '/accounts/{accountId}/alerting/v3/policies/{policyId}', method: 'put', ...variables, signal });

export type AuditLogsGetAccountAuditLogsPathParams = {
  accountId: Schemas.AaaIdentifier;
};

export type AuditLogsGetAccountAuditLogsQueryParams = {
  /**
   * @example f174be97-19b1-40d6-954d-70cd5fbd52db
   */
  id?: string;
  /**
   * @example true
   */
  ['export']?: boolean;
  /**
   * @example add
   */
  ['action.type']?: string;
  /**
   * @example 17.168.228.63
   */
  ['actor.ip']?: string;
  /**
   * @example alice@example.com
   * @format email
   */
  ['actor.email']?: string;
  since?: string | string;
  before?: string | string;
  /**
   * @example example.com
   */
  ['zone.name']?: string;
  /**
   * @default desc
   * @example desc
   */
  direction?: 'desc' | 'asc';
  /**
   * @default 100
   * @example 25
   * @maximum 1000
   * @minimum 1
   */
  per_page?: number;
  /**
   * @default 1
   * @example 50
   * @minimum 1
   */
  page?: number;
  /**
   * @default false
   */
  hide_user_logs?: boolean;
};

export type AuditLogsGetAccountAuditLogsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaAuditLogsResponseCollection & Schemas.AaaApiResponseCommonFailure;
}>;

export type AuditLogsGetAccountAuditLogsVariables = {
  pathParams: AuditLogsGetAccountAuditLogsPathParams;
  queryParams?: AuditLogsGetAccountAuditLogsQueryParams;
} & FetcherExtraProps;

/**
 * Gets a list of audit logs for an account. Can be filtered by who made the change, on which zone, and the timeframe of the change.
 */
export const auditLogsGetAccountAuditLogs = (variables: AuditLogsGetAccountAuditLogsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.AaaAuditLogsResponseCollection,
    AuditLogsGetAccountAuditLogsError,
    undefined,
    {},
    AuditLogsGetAccountAuditLogsQueryParams,
    AuditLogsGetAccountAuditLogsPathParams
  >({ url: '/accounts/{accountId}/audit_logs', method: 'get', ...variables, signal });

export type AccountBillingProfileDeprecatedBillingProfileDetailsPathParams = {
  accountId: Schemas.BillSubsApiIdentifier;
};

export type AccountBillingProfileDeprecatedBillingProfileDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.BillSubsApiBillingResponseSingle & Schemas.BillSubsApiApiResponseCommonFailure;
}>;

export type AccountBillingProfileDeprecatedBillingProfileDetailsVariables = {
  pathParams: AccountBillingProfileDeprecatedBillingProfileDetailsPathParams;
} & FetcherExtraProps;

/**
 * Gets the current billing profile for the account.
 */
export const accountBillingProfileDeprecatedBillingProfileDetails = (
  variables: AccountBillingProfileDeprecatedBillingProfileDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.BillSubsApiBillingResponseSingle,
    AccountBillingProfileDeprecatedBillingProfileDetailsError,
    undefined,
    {},
    {},
    AccountBillingProfileDeprecatedBillingProfileDetailsPathParams
  >({ url: '/accounts/{accountId}/billing/profile', method: 'get', ...variables, signal });

export type BotnetThreatFeedGetDayReportPathParams = {
  accountId: Schemas.DosIdentifier;
  asnId: Schemas.DosAsn;
};

export type BotnetThreatFeedGetDayReportQueryParams = {
  date?: Schemas.DosTimestamp;
};

export type BotnetThreatFeedGetDayReportError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DosApiResponseCommonFailure;
}>;

export type BotnetThreatFeedGetDayReportResponse = Schemas.DosApiResponseCommon & {
  result?: {
    /**
     * @example 1.1.1.1/32
     */
    cidr?: string;
    /**
     * @example 2014-01-01T05:20:00.12345Z
     * @format date-time
     */
    date?: string;
    /**
     * @example 1000
     */
    offense_count?: number;
  };
};

export type BotnetThreatFeedGetDayReportVariables = {
  pathParams: BotnetThreatFeedGetDayReportPathParams;
  queryParams?: BotnetThreatFeedGetDayReportQueryParams;
} & FetcherExtraProps;

/**
 * Gets all the data the botnet tracking database has for a given ASN registered to user account for given date. If no date is given, it will return results for the previous day.
 */
export const botnetThreatFeedGetDayReport = (variables: BotnetThreatFeedGetDayReportVariables, signal?: AbortSignal) =>
  fetch<
    BotnetThreatFeedGetDayReportResponse,
    BotnetThreatFeedGetDayReportError,
    undefined,
    {},
    BotnetThreatFeedGetDayReportQueryParams,
    BotnetThreatFeedGetDayReportPathParams
  >({ url: '/accounts/{accountId}/botnet_feed/asn/{asnId}/day_report', method: 'get', ...variables, signal });

export type BotnetThreatFeedGetFullReportPathParams = {
  accountId: Schemas.DosIdentifier;
  asnId: Schemas.DosAsn;
};

export type BotnetThreatFeedGetFullReportError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DosApiResponseCommonFailure;
}>;

export type BotnetThreatFeedGetFullReportResponse = Schemas.DosApiResponseCommon & {
  result?: {
    /**
     * @example 1.1.1.1/32
     */
    cidr?: string;
    /**
     * @example 2014-01-01T05:20:00.12345Z
     * @format date-time
     */
    date?: string;
    /**
     * @example 1000
     */
    offense_count?: number;
  };
};

export type BotnetThreatFeedGetFullReportVariables = {
  pathParams: BotnetThreatFeedGetFullReportPathParams;
} & FetcherExtraProps;

/**
 * Gets all the data the botnet threat feed tracking database has for a given ASN registered to user account.
 */
export const botnetThreatFeedGetFullReport = (
  variables: BotnetThreatFeedGetFullReportVariables,
  signal?: AbortSignal
) =>
  fetch<
    BotnetThreatFeedGetFullReportResponse,
    BotnetThreatFeedGetFullReportError,
    undefined,
    {},
    {},
    BotnetThreatFeedGetFullReportPathParams
  >({ url: '/accounts/{accountId}/botnet_feed/asn/{asnId}/full_report', method: 'get', ...variables, signal });

export type BotnetThreatFeedListAsnPathParams = {
  accountId: Schemas.DosIdentifier;
};

export type BotnetThreatFeedListAsnError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DosApiResponseCommonFailure;
}>;

export type BotnetThreatFeedListAsnResponse = Schemas.DosApiResponseCommon & {
  result?: {
    /**
     * @example 13335
     */
    asn?: number;
  };
};

export type BotnetThreatFeedListAsnVariables = {
  pathParams: BotnetThreatFeedListAsnPathParams;
} & FetcherExtraProps;

/**
 * Gets a list of all ASNs registered for a user for the DDoS Botnet Feed API.
 */
export const botnetThreatFeedListAsn = (variables: BotnetThreatFeedListAsnVariables, signal?: AbortSignal) =>
  fetch<
    BotnetThreatFeedListAsnResponse,
    BotnetThreatFeedListAsnError,
    undefined,
    {},
    {},
    BotnetThreatFeedListAsnPathParams
  >({ url: '/accounts/{accountId}/botnet_feed/configs/asn', method: 'get', ...variables, signal });

export type BotnetThreatFeedDeleteAsnPathParams = {
  accountId: Schemas.DosIdentifier;
  asnId: Schemas.DosAsn;
};

export type BotnetThreatFeedDeleteAsnError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DosApiResponseCommonFailure;
}>;

export type BotnetThreatFeedDeleteAsnResponse = Schemas.DosApiResponseCommon & {
  result?: {
    /**
     * @example 13335
     */
    asn?: number;
  };
};

export type BotnetThreatFeedDeleteAsnVariables = {
  pathParams: BotnetThreatFeedDeleteAsnPathParams;
} & FetcherExtraProps;

/**
 * Delete an ASN from botnet threat feed for a given user.
 */
export const botnetThreatFeedDeleteAsn = (variables: BotnetThreatFeedDeleteAsnVariables, signal?: AbortSignal) =>
  fetch<
    BotnetThreatFeedDeleteAsnResponse,
    BotnetThreatFeedDeleteAsnError,
    undefined,
    {},
    {},
    BotnetThreatFeedDeleteAsnPathParams
  >({ url: '/accounts/{accountId}/botnet_feed/configs/asn/{asnId}', method: 'delete', ...variables, signal });

export type PhishingUrlScannerSubmitSuspiciousUrlForScanningPathParams = {
  accountId: Schemas.IntelIdentifier;
};

export type PhishingUrlScannerSubmitSuspiciousUrlForScanningError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IntelPhishingUrlSubmitComponentsSchemasSingleResponse & Schemas.IntelApiResponseCommonFailure;
}>;

export type PhishingUrlScannerSubmitSuspiciousUrlForScanningRequestBody = Schemas.IntelUrlParam;

export type PhishingUrlScannerSubmitSuspiciousUrlForScanningVariables = {
  body?: PhishingUrlScannerSubmitSuspiciousUrlForScanningRequestBody;
  pathParams: PhishingUrlScannerSubmitSuspiciousUrlForScanningPathParams;
} & FetcherExtraProps;

/**
 * Submit suspicious URL for scanning
 */
export const phishingUrlScannerSubmitSuspiciousUrlForScanning = (
  variables: PhishingUrlScannerSubmitSuspiciousUrlForScanningVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.IntelPhishingUrlSubmitComponentsSchemasSingleResponse,
    PhishingUrlScannerSubmitSuspiciousUrlForScanningError,
    PhishingUrlScannerSubmitSuspiciousUrlForScanningRequestBody,
    {},
    {},
    PhishingUrlScannerSubmitSuspiciousUrlForScanningPathParams
  >({ url: '/accounts/{accountId}/brand-protection/submit', method: 'post', ...variables, signal });

export type PhishingUrlInformationGetResultsForAUrlScanPathParams = {
  accountId: Schemas.IntelIdentifier;
};

export type PhishingUrlInformationGetResultsForAUrlScanQueryParams = {
  /**
   * Submission ID(s) to filter submission results by.
   */
  url_id?: number[];
  /**
   * Submission URL(s) to filter submission results by.
   */
  url?: string[];
};

export type PhishingUrlInformationGetResultsForAUrlScanError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IntelPhishingUrlInfoComponentsSchemasSingleResponse & Schemas.IntelApiResponseCommonFailure;
}>;

export type PhishingUrlInformationGetResultsForAUrlScanVariables = {
  pathParams: PhishingUrlInformationGetResultsForAUrlScanPathParams;
  queryParams?: PhishingUrlInformationGetResultsForAUrlScanQueryParams;
} & FetcherExtraProps;

/**
 * Gets phishing details about a URL.
 */
export const phishingUrlInformationGetResultsForAUrlScan = (
  variables: PhishingUrlInformationGetResultsForAUrlScanVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.IntelPhishingUrlInfoComponentsSchemasSingleResponse,
    PhishingUrlInformationGetResultsForAUrlScanError,
    undefined,
    {},
    PhishingUrlInformationGetResultsForAUrlScanQueryParams,
    PhishingUrlInformationGetResultsForAUrlScanPathParams
  >({ url: '/accounts/{accountId}/brand-protection/url-info', method: 'get', ...variables, signal });

export type CallsAppsListPathParams = {
  accountId: Schemas.CallsAccountIdentifier;
};

export type CallsAppsListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CallsApiResponseCommonFailure;
}>;

export type CallsAppsListVariables = {
  pathParams: CallsAppsListPathParams;
} & FetcherExtraProps;

/**
 * Lists all apps in the Cloudflare account
 */
export const callsAppsList = (variables: CallsAppsListVariables, signal?: AbortSignal) =>
  fetch<Schemas.CallsAppResponseCollection, CallsAppsListError, undefined, {}, {}, CallsAppsListPathParams>({
    url: '/accounts/{accountId}/calls/apps',
    method: 'get',
    ...variables,
    signal
  });

export type CallsAppsCreateANewAppPathParams = {
  accountId: Schemas.CallsAccountIdentifier;
};

export type CallsAppsCreateANewAppError = Fetcher.ErrorWrapper<undefined>;

export type CallsAppsCreateANewAppVariables = {
  body?: Schemas.CallsAppEditableFields;
  pathParams: CallsAppsCreateANewAppPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Cloudflare calls app. An app is an unique enviroment where each Session can access all Tracks within the app.
 */
export const callsAppsCreateANewApp = (variables: CallsAppsCreateANewAppVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.CallsAppResponseSingleWithSecret,
    CallsAppsCreateANewAppError,
    Schemas.CallsAppEditableFields,
    {},
    {},
    CallsAppsCreateANewAppPathParams
  >({ url: '/accounts/{accountId}/calls/apps', method: 'post', ...variables, signal });

export type CallsAppsDeleteAppPathParams = {
  appId: Schemas.CallsIdentifier;
  accountId: Schemas.CallsAccountIdentifier;
};

export type CallsAppsDeleteAppError = Fetcher.ErrorWrapper<undefined>;

export type CallsAppsDeleteAppVariables = {
  pathParams: CallsAppsDeleteAppPathParams;
} & FetcherExtraProps;

/**
 * Deletes an app from Cloudflare Calls
 */
export const callsAppsDeleteApp = (variables: CallsAppsDeleteAppVariables, signal?: AbortSignal) =>
  fetch<Schemas.CallsAppResponseSingle, CallsAppsDeleteAppError, undefined, {}, {}, CallsAppsDeleteAppPathParams>({
    url: '/accounts/{accountId}/calls/apps/{appId}',
    method: 'delete',
    ...variables,
    signal
  });

export type CallsAppsRetrieveAppDetailsPathParams = {
  appId: Schemas.CallsIdentifier;
  accountId: Schemas.CallsAccountIdentifier;
};

export type CallsAppsRetrieveAppDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CallsApiResponseCommonFailure;
}>;

export type CallsAppsRetrieveAppDetailsVariables = {
  pathParams: CallsAppsRetrieveAppDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetches details for a single Calls app.
 */
export const callsAppsRetrieveAppDetails = (variables: CallsAppsRetrieveAppDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.CallsAppResponseSingle,
    CallsAppsRetrieveAppDetailsError,
    undefined,
    {},
    {},
    CallsAppsRetrieveAppDetailsPathParams
  >({ url: '/accounts/{accountId}/calls/apps/{appId}', method: 'get', ...variables, signal });

export type CallsAppsUpdateAppDetailsPathParams = {
  appId: Schemas.CallsIdentifier;
  accountId: Schemas.CallsAccountIdentifier;
};

export type CallsAppsUpdateAppDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CallsApiResponseCommonFailure;
}>;

export type CallsAppsUpdateAppDetailsVariables = {
  body?: Schemas.CallsAppEditableFields;
  pathParams: CallsAppsUpdateAppDetailsPathParams;
} & FetcherExtraProps;

/**
 * Edit details for a single app.
 */
export const callsAppsUpdateAppDetails = (variables: CallsAppsUpdateAppDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.CallsAppResponseSingle,
    CallsAppsUpdateAppDetailsError,
    Schemas.CallsAppEditableFields,
    {},
    {},
    CallsAppsUpdateAppDetailsPathParams
  >({ url: '/accounts/{accountId}/calls/apps/{appId}', method: 'put', ...variables, signal });

export type CallsTurnKeyListPathParams = {
  accountId: Schemas.CallsAccountIdentifier;
};

export type CallsTurnKeyListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CallsApiResponseCommonFailure;
}>;

export type CallsTurnKeyListVariables = {
  pathParams: CallsTurnKeyListPathParams;
} & FetcherExtraProps;

/**
 * Lists all TURN keys in the Cloudflare account
 */
export const callsTurnKeyList = (variables: CallsTurnKeyListVariables, signal?: AbortSignal) =>
  fetch<Schemas.CallsTurnKeyCollection, CallsTurnKeyListError, undefined, {}, {}, CallsTurnKeyListPathParams>({
    url: '/accounts/{accountId}/calls/turn_keys',
    method: 'get',
    ...variables,
    signal
  });

export type CallsTurnKeyCreatePathParams = {
  accountId: Schemas.CallsAccountIdentifier;
};

export type CallsTurnKeyCreateError = Fetcher.ErrorWrapper<undefined>;

export type CallsTurnKeyCreateVariables = {
  body?: Schemas.CallsTurnKeyEditableFields;
  pathParams: CallsTurnKeyCreatePathParams;
} & FetcherExtraProps;

/**
 * Creates a new Cloudflare Calls TURN key.
 */
export const callsTurnKeyCreate = (variables: CallsTurnKeyCreateVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.CallsTurnKeyWithKey,
    CallsTurnKeyCreateError,
    Schemas.CallsTurnKeyEditableFields,
    {},
    {},
    CallsTurnKeyCreatePathParams
  >({ url: '/accounts/{accountId}/calls/turn_keys', method: 'post', ...variables, signal });

export type CallsDeleteTurnKeyPathParams = {
  keyId: Schemas.CallsIdentifier;
  accountId: Schemas.CallsAccountIdentifier;
};

export type CallsDeleteTurnKeyError = Fetcher.ErrorWrapper<undefined>;

export type CallsDeleteTurnKeyVariables = {
  pathParams: CallsDeleteTurnKeyPathParams;
} & FetcherExtraProps;

/**
 * Deletes a TURN key from Cloudflare Calls
 */
export const callsDeleteTurnKey = (variables: CallsDeleteTurnKeyVariables, signal?: AbortSignal) =>
  fetch<Schemas.CallsTurnKeyResponseSingle, CallsDeleteTurnKeyError, undefined, {}, {}, CallsDeleteTurnKeyPathParams>({
    url: '/accounts/{accountId}/calls/turn_keys/{keyId}',
    method: 'delete',
    ...variables,
    signal
  });

export type CallsRetrieveTurnKeyDetailsPathParams = {
  keyId: Schemas.CallsIdentifier;
  accountId: Schemas.CallsAccountIdentifier;
};

export type CallsRetrieveTurnKeyDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CallsApiResponseCommonFailure;
}>;

export type CallsRetrieveTurnKeyDetailsVariables = {
  pathParams: CallsRetrieveTurnKeyDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetches details for a single TURN key.
 */
export const callsRetrieveTurnKeyDetails = (variables: CallsRetrieveTurnKeyDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.CallsTurnKeyResponseSingle,
    CallsRetrieveTurnKeyDetailsError,
    undefined,
    {},
    {},
    CallsRetrieveTurnKeyDetailsPathParams
  >({ url: '/accounts/{accountId}/calls/turn_keys/{keyId}', method: 'get', ...variables, signal });

export type CallsUpdateTurnKeyPathParams = {
  keyId: Schemas.CallsIdentifier;
  accountId: Schemas.CallsAccountIdentifier;
};

export type CallsUpdateTurnKeyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CallsApiResponseCommonFailure;
}>;

export type CallsUpdateTurnKeyVariables = {
  body?: Schemas.CallsTurnKeyEditableFields;
  pathParams: CallsUpdateTurnKeyPathParams;
} & FetcherExtraProps;

/**
 * Edit details for a single TURN key.
 */
export const callsUpdateTurnKey = (variables: CallsUpdateTurnKeyVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.CallsTurnKeyResponseSingle,
    CallsUpdateTurnKeyError,
    Schemas.CallsTurnKeyEditableFields,
    {},
    {},
    CallsUpdateTurnKeyPathParams
  >({ url: '/accounts/{accountId}/calls/turn_keys/{keyId}', method: 'put', ...variables, signal });

export type CloudflareTunnelListCloudflareTunnelsPathParams = {
  accountId: Schemas.TunnelAccountId;
};

export type CloudflareTunnelListCloudflareTunnelsQueryParams = {
  name?: Schemas.TunnelTunnelName;
  /**
   * @example true
   */
  is_deleted?: boolean;
  existed_at?: Schemas.TunnelExistedAt;
  uuid?: Schemas.TunnelTunnelId;
  /**
   * @example 2009-11-10T23:00:00Z
   * @format date-time
   */
  was_active_at?: string;
  /**
   * @example 2009-11-10T23:00:00Z
   * @format date-time
   */
  was_inactive_at?: string;
  /**
   * @example vpc1-
   */
  include_prefix?: string;
  /**
   * @example vpc1-
   */
  exclude_prefix?: string;
  status?: Schemas.TunnelStatus;
  per_page?: Schemas.TunnelPerPage;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
};

export type CloudflareTunnelListCloudflareTunnelsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelTunnelResponseCollection & Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelListCloudflareTunnelsVariables = {
  pathParams: CloudflareTunnelListCloudflareTunnelsPathParams;
  queryParams?: CloudflareTunnelListCloudflareTunnelsQueryParams;
} & FetcherExtraProps;

/**
 * Lists and filters Cloudflare Tunnels in an account.
 */
export const cloudflareTunnelListCloudflareTunnels = (
  variables: CloudflareTunnelListCloudflareTunnelsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelTunnelResponseCollection,
    CloudflareTunnelListCloudflareTunnelsError,
    undefined,
    {},
    CloudflareTunnelListCloudflareTunnelsQueryParams,
    CloudflareTunnelListCloudflareTunnelsPathParams
  >({ url: '/accounts/{accountId}/cfd_tunnel', method: 'get', ...variables, signal });

export type CloudflareTunnelCreateACloudflareTunnelPathParams = {
  accountId: Schemas.TunnelAccountId;
};

export type CloudflareTunnelCreateACloudflareTunnelError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelTunnelResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelCreateACloudflareTunnelRequestBody = {
  config_src?: Schemas.TunnelConfigSrc;
  name: Schemas.TunnelTunnelName;
  tunnel_secret?: Schemas.TunnelTunnelSecret;
};

export type CloudflareTunnelCreateACloudflareTunnelVariables = {
  body: CloudflareTunnelCreateACloudflareTunnelRequestBody;
  pathParams: CloudflareTunnelCreateACloudflareTunnelPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Cloudflare Tunnel in an account.
 */
export const cloudflareTunnelCreateACloudflareTunnel = (
  variables: CloudflareTunnelCreateACloudflareTunnelVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelTunnelResponseSingle,
    CloudflareTunnelCreateACloudflareTunnelError,
    CloudflareTunnelCreateACloudflareTunnelRequestBody,
    {},
    {},
    CloudflareTunnelCreateACloudflareTunnelPathParams
  >({ url: '/accounts/{accountId}/cfd_tunnel', method: 'post', ...variables, signal });

export type CloudflareTunnelDeleteACloudflareTunnelPathParams = {
  accountId: Schemas.TunnelAccountId;
  tunnelId: Schemas.TunnelTunnelId;
};

export type CloudflareTunnelDeleteACloudflareTunnelError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelTunnelResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelDeleteACloudflareTunnelVariables = {
  body?: Record<string, any>;
  pathParams: CloudflareTunnelDeleteACloudflareTunnelPathParams;
} & FetcherExtraProps;

/**
 * Deletes a Cloudflare Tunnel from an account.
 */
export const cloudflareTunnelDeleteACloudflareTunnel = (
  variables: CloudflareTunnelDeleteACloudflareTunnelVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelTunnelResponseSingle,
    CloudflareTunnelDeleteACloudflareTunnelError,
    Record<string, any>,
    {},
    {},
    CloudflareTunnelDeleteACloudflareTunnelPathParams
  >({ url: '/accounts/{accountId}/cfd_tunnel/{tunnelId}', method: 'delete', ...variables, signal });

export type CloudflareTunnelGetACloudflareTunnelPathParams = {
  accountId: Schemas.TunnelAccountId;
  tunnelId: Schemas.TunnelTunnelId;
};

export type CloudflareTunnelGetACloudflareTunnelError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelTunnelResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelGetACloudflareTunnelVariables = {
  pathParams: CloudflareTunnelGetACloudflareTunnelPathParams;
} & FetcherExtraProps;

/**
 * Fetches a single Cloudflare Tunnel.
 */
export const cloudflareTunnelGetACloudflareTunnel = (
  variables: CloudflareTunnelGetACloudflareTunnelVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelTunnelResponseSingle,
    CloudflareTunnelGetACloudflareTunnelError,
    undefined,
    {},
    {},
    CloudflareTunnelGetACloudflareTunnelPathParams
  >({ url: '/accounts/{accountId}/cfd_tunnel/{tunnelId}', method: 'get', ...variables, signal });

export type CloudflareTunnelUpdateACloudflareTunnelPathParams = {
  tunnelId: Schemas.TunnelTunnelId;
  accountId: Schemas.TunnelAccountId;
};

export type CloudflareTunnelUpdateACloudflareTunnelError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelTunnelResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelUpdateACloudflareTunnelRequestBody = {
  name?: Schemas.TunnelTunnelName;
  tunnel_secret?: Schemas.TunnelTunnelSecret;
};

export type CloudflareTunnelUpdateACloudflareTunnelVariables = {
  body?: CloudflareTunnelUpdateACloudflareTunnelRequestBody;
  pathParams: CloudflareTunnelUpdateACloudflareTunnelPathParams;
} & FetcherExtraProps;

/**
 * Updates an existing Cloudflare Tunnel.
 */
export const cloudflareTunnelUpdateACloudflareTunnel = (
  variables: CloudflareTunnelUpdateACloudflareTunnelVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelTunnelResponseSingle,
    CloudflareTunnelUpdateACloudflareTunnelError,
    CloudflareTunnelUpdateACloudflareTunnelRequestBody,
    {},
    {},
    CloudflareTunnelUpdateACloudflareTunnelPathParams
  >({ url: '/accounts/{accountId}/cfd_tunnel/{tunnelId}', method: 'patch', ...variables, signal });

export type CloudflareTunnelConfigurationGetConfigurationPathParams = {
  accountId: Schemas.TunnelIdentifier;
  tunnelId: Schemas.TunnelTunnelId;
};

export type CloudflareTunnelConfigurationGetConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelConfigurationGetConfigurationVariables = {
  pathParams: CloudflareTunnelConfigurationGetConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Gets the configuration for a remotely-managed tunnel
 */
export const cloudflareTunnelConfigurationGetConfiguration = (
  variables: CloudflareTunnelConfigurationGetConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelConfigurationResponse,
    CloudflareTunnelConfigurationGetConfigurationError,
    undefined,
    {},
    {},
    CloudflareTunnelConfigurationGetConfigurationPathParams
  >({ url: '/accounts/{accountId}/cfd_tunnel/{tunnelId}/configurations', method: 'get', ...variables, signal });

export type CloudflareTunnelConfigurationPutConfigurationPathParams = {
  accountId: Schemas.TunnelIdentifier;
  tunnelId: Schemas.TunnelTunnelId;
};

export type CloudflareTunnelConfigurationPutConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelConfigurationPutConfigurationRequestBody = {
  config?: Schemas.TunnelConfig;
};

export type CloudflareTunnelConfigurationPutConfigurationVariables = {
  body?: CloudflareTunnelConfigurationPutConfigurationRequestBody;
  pathParams: CloudflareTunnelConfigurationPutConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Adds or updates the configuration for a remotely-managed tunnel.
 */
export const cloudflareTunnelConfigurationPutConfiguration = (
  variables: CloudflareTunnelConfigurationPutConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelConfigurationResponse,
    CloudflareTunnelConfigurationPutConfigurationError,
    CloudflareTunnelConfigurationPutConfigurationRequestBody,
    {},
    {},
    CloudflareTunnelConfigurationPutConfigurationPathParams
  >({ url: '/accounts/{accountId}/cfd_tunnel/{tunnelId}/configurations', method: 'put', ...variables, signal });

export type CloudflareTunnelCleanUpCloudflareTunnelConnectionsPathParams = {
  accountId: Schemas.TunnelAccountId;
  tunnelId: Schemas.TunnelTunnelId;
};

export type CloudflareTunnelCleanUpCloudflareTunnelConnectionsQueryParams = {
  client_id?: Schemas.TunnelClientId;
};

export type CloudflareTunnelCleanUpCloudflareTunnelConnectionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelEmptyResponse & Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelCleanUpCloudflareTunnelConnectionsVariables = {
  body?: Record<string, any>;
  pathParams: CloudflareTunnelCleanUpCloudflareTunnelConnectionsPathParams;
  queryParams?: CloudflareTunnelCleanUpCloudflareTunnelConnectionsQueryParams;
} & FetcherExtraProps;

/**
 * Removes a connection (aka Cloudflare Tunnel Connector) from a Cloudflare Tunnel independently of its current state. If no connector id (client_id) is provided all connectors will be removed. We recommend running this command after rotating tokens.
 */
export const cloudflareTunnelCleanUpCloudflareTunnelConnections = (
  variables: CloudflareTunnelCleanUpCloudflareTunnelConnectionsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelEmptyResponse,
    CloudflareTunnelCleanUpCloudflareTunnelConnectionsError,
    Record<string, any>,
    {},
    CloudflareTunnelCleanUpCloudflareTunnelConnectionsQueryParams,
    CloudflareTunnelCleanUpCloudflareTunnelConnectionsPathParams
  >({ url: '/accounts/{accountId}/cfd_tunnel/{tunnelId}/connections', method: 'delete', ...variables, signal });

export type CloudflareTunnelListCloudflareTunnelConnectionsPathParams = {
  accountId: Schemas.TunnelAccountId;
  tunnelId: Schemas.TunnelTunnelId;
};

export type CloudflareTunnelListCloudflareTunnelConnectionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelTunnelConnectionsResponse & Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelListCloudflareTunnelConnectionsVariables = {
  pathParams: CloudflareTunnelListCloudflareTunnelConnectionsPathParams;
} & FetcherExtraProps;

/**
 * Fetches connection details for a Cloudflare Tunnel.
 */
export const cloudflareTunnelListCloudflareTunnelConnections = (
  variables: CloudflareTunnelListCloudflareTunnelConnectionsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelTunnelConnectionsResponse,
    CloudflareTunnelListCloudflareTunnelConnectionsError,
    undefined,
    {},
    {},
    CloudflareTunnelListCloudflareTunnelConnectionsPathParams
  >({ url: '/accounts/{accountId}/cfd_tunnel/{tunnelId}/connections', method: 'get', ...variables, signal });

export type CloudflareTunnelGetCloudflareTunnelConnectorPathParams = {
  accountId: Schemas.TunnelAccountId;
  tunnelId: Schemas.TunnelTunnelId;
  connectorId: Schemas.TunnelClientId;
};

export type CloudflareTunnelGetCloudflareTunnelConnectorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelTunnelClientResponse & Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelGetCloudflareTunnelConnectorVariables = {
  pathParams: CloudflareTunnelGetCloudflareTunnelConnectorPathParams;
} & FetcherExtraProps;

/**
 * Fetches connector and connection details for a Cloudflare Tunnel.
 */
export const cloudflareTunnelGetCloudflareTunnelConnector = (
  variables: CloudflareTunnelGetCloudflareTunnelConnectorVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelTunnelClientResponse,
    CloudflareTunnelGetCloudflareTunnelConnectorError,
    undefined,
    {},
    {},
    CloudflareTunnelGetCloudflareTunnelConnectorPathParams
  >({
    url: '/accounts/{accountId}/cfd_tunnel/{tunnelId}/connectors/{connectorId}',
    method: 'get',
    ...variables,
    signal
  });

export type CloudflareTunnelGetACloudflareTunnelManagementTokenPathParams = {
  accountId: Schemas.TunnelAccountId;
  tunnelId: Schemas.TunnelTunnelId;
};

export type CloudflareTunnelGetACloudflareTunnelManagementTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelTunnelResponseToken & Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelGetACloudflareTunnelManagementTokenRequestBody = {
  resources: Schemas.TunnelManagementResources[];
};

export type CloudflareTunnelGetACloudflareTunnelManagementTokenVariables = {
  body: CloudflareTunnelGetACloudflareTunnelManagementTokenRequestBody;
  pathParams: CloudflareTunnelGetACloudflareTunnelManagementTokenPathParams;
} & FetcherExtraProps;

/**
 * Gets a management token used to access the management resources (i.e. Streaming Logs) of a tunnel.
 */
export const cloudflareTunnelGetACloudflareTunnelManagementToken = (
  variables: CloudflareTunnelGetACloudflareTunnelManagementTokenVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelTunnelResponseToken,
    CloudflareTunnelGetACloudflareTunnelManagementTokenError,
    CloudflareTunnelGetACloudflareTunnelManagementTokenRequestBody,
    {},
    {},
    CloudflareTunnelGetACloudflareTunnelManagementTokenPathParams
  >({ url: '/accounts/{accountId}/cfd_tunnel/{tunnelId}/management', method: 'post', ...variables, signal });

export type CloudflareTunnelGetACloudflareTunnelTokenPathParams = {
  accountId: Schemas.TunnelAccountId;
  tunnelId: Schemas.TunnelTunnelId;
};

export type CloudflareTunnelGetACloudflareTunnelTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelTunnelResponseToken & Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelGetACloudflareTunnelTokenVariables = {
  pathParams: CloudflareTunnelGetACloudflareTunnelTokenPathParams;
} & FetcherExtraProps;

/**
 * Gets the token used to associate cloudflared with a specific tunnel.
 */
export const cloudflareTunnelGetACloudflareTunnelToken = (
  variables: CloudflareTunnelGetACloudflareTunnelTokenVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelTunnelResponseToken,
    CloudflareTunnelGetACloudflareTunnelTokenError,
    undefined,
    {},
    {},
    CloudflareTunnelGetACloudflareTunnelTokenPathParams
  >({ url: '/accounts/{accountId}/cfd_tunnel/{tunnelId}/token', method: 'get', ...variables, signal });

export type AccountsTurnstileWidgetsListPathParams = {
  accountId: Schemas.TurnstileIdentifier;
};

export type AccountsTurnstileWidgetsListQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 25
   * @maximum 1000
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example id
   */
  order?: 'id' | 'sitekey' | 'name' | 'created_on' | 'modified_on';
  /**
   * @example asc
   */
  direction?: 'asc' | 'desc';
};

export type AccountsTurnstileWidgetsListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TurnstileApiResponseCommonFailure;
}>;

export type AccountsTurnstileWidgetsListResponse = Schemas.TurnstileApiResponseCommon & {
  result_info?: Schemas.TurnstileResultInfo;
} & {
  result?: Schemas.TurnstileWidgetList[];
};

export type AccountsTurnstileWidgetsListVariables = {
  pathParams: AccountsTurnstileWidgetsListPathParams;
  queryParams?: AccountsTurnstileWidgetsListQueryParams;
} & FetcherExtraProps;

/**
 * Lists all turnstile widgets of an account.
 */
export const accountsTurnstileWidgetsList = (variables: AccountsTurnstileWidgetsListVariables, signal?: AbortSignal) =>
  fetch<
    AccountsTurnstileWidgetsListResponse,
    AccountsTurnstileWidgetsListError,
    undefined,
    {},
    AccountsTurnstileWidgetsListQueryParams,
    AccountsTurnstileWidgetsListPathParams
  >({ url: '/accounts/{accountId}/challenges/widgets', method: 'get', ...variables, signal });

export type AccountsTurnstileWidgetCreatePathParams = {
  accountId: Schemas.TurnstileIdentifier;
};

export type AccountsTurnstileWidgetCreateQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 25
   * @maximum 1000
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example id
   */
  order?: 'id' | 'sitekey' | 'name' | 'created_on' | 'modified_on';
  /**
   * @example asc
   */
  direction?: 'asc' | 'desc';
};

export type AccountsTurnstileWidgetCreateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TurnstileApiResponseCommonFailure;
}>;

export type AccountsTurnstileWidgetCreateResponse = Schemas.TurnstileApiResponseCommon & {
  result_info?: Schemas.TurnstileResultInfo;
} & {
  result?: Schemas.TurnstileWidgetDetail;
};

export type AccountsTurnstileWidgetCreateRequestBody = {
  bot_fight_mode?: Schemas.TurnstileBotFightMode;
  clearance_level?: Schemas.TurnstileClearanceLevel;
  domains: Schemas.TurnstileDomains;
  ephemeral_id?: Schemas.TurnstileEphemeralId;
  mode: Schemas.TurnstileMode;
  name: Schemas.TurnstileName;
  offlabel?: Schemas.TurnstileOfflabel;
  region?: Schemas.TurnstileRegion;
};

export type AccountsTurnstileWidgetCreateVariables = {
  body: AccountsTurnstileWidgetCreateRequestBody;
  pathParams: AccountsTurnstileWidgetCreatePathParams;
  queryParams?: AccountsTurnstileWidgetCreateQueryParams;
} & FetcherExtraProps;

/**
 * Lists challenge widgets.
 */
export const accountsTurnstileWidgetCreate = (
  variables: AccountsTurnstileWidgetCreateVariables,
  signal?: AbortSignal
) =>
  fetch<
    AccountsTurnstileWidgetCreateResponse,
    AccountsTurnstileWidgetCreateError,
    AccountsTurnstileWidgetCreateRequestBody,
    {},
    AccountsTurnstileWidgetCreateQueryParams,
    AccountsTurnstileWidgetCreatePathParams
  >({ url: '/accounts/{accountId}/challenges/widgets', method: 'post', ...variables, signal });

export type AccountsTurnstileWidgetDeletePathParams = {
  accountId: Schemas.TurnstileIdentifier;
  sitekey: Schemas.TurnstileSitekey;
};

export type AccountsTurnstileWidgetDeleteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TurnstileApiResponseCommonFailure;
}>;

export type AccountsTurnstileWidgetDeleteResponse = Schemas.TurnstileApiResponseCommon & {
  result?: Schemas.TurnstileWidgetDetail;
};

export type AccountsTurnstileWidgetDeleteVariables = {
  pathParams: AccountsTurnstileWidgetDeletePathParams;
} & FetcherExtraProps;

/**
 * Destroy a Turnstile Widget.
 */
export const accountsTurnstileWidgetDelete = (
  variables: AccountsTurnstileWidgetDeleteVariables,
  signal?: AbortSignal
) =>
  fetch<
    AccountsTurnstileWidgetDeleteResponse,
    AccountsTurnstileWidgetDeleteError,
    undefined,
    {},
    {},
    AccountsTurnstileWidgetDeletePathParams
  >({ url: '/accounts/{accountId}/challenges/widgets/{sitekey}', method: 'delete', ...variables, signal });

export type AccountsTurnstileWidgetGetPathParams = {
  accountId: Schemas.TurnstileIdentifier;
  sitekey: Schemas.TurnstileSitekey;
};

export type AccountsTurnstileWidgetGetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TurnstileApiResponseCommonFailure;
}>;

export type AccountsTurnstileWidgetGetResponse = Schemas.TurnstileApiResponseCommon & {
  result?: Schemas.TurnstileWidgetDetail;
};

export type AccountsTurnstileWidgetGetVariables = {
  pathParams: AccountsTurnstileWidgetGetPathParams;
} & FetcherExtraProps;

/**
 * Show a single challenge widget configuration.
 */
export const accountsTurnstileWidgetGet = (variables: AccountsTurnstileWidgetGetVariables, signal?: AbortSignal) =>
  fetch<
    AccountsTurnstileWidgetGetResponse,
    AccountsTurnstileWidgetGetError,
    undefined,
    {},
    {},
    AccountsTurnstileWidgetGetPathParams
  >({ url: '/accounts/{accountId}/challenges/widgets/{sitekey}', method: 'get', ...variables, signal });

export type AccountsTurnstileWidgetUpdatePathParams = {
  accountId: Schemas.TurnstileIdentifier;
  sitekey: Schemas.TurnstileSitekey;
};

export type AccountsTurnstileWidgetUpdateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TurnstileApiResponseCommonFailure;
}>;

export type AccountsTurnstileWidgetUpdateResponse = Schemas.TurnstileApiResponseCommon & {
  result?: Schemas.TurnstileWidgetDetail;
};

export type AccountsTurnstileWidgetUpdateRequestBody = {
  bot_fight_mode?: Schemas.TurnstileBotFightMode;
  clearance_level?: Schemas.TurnstileClearanceLevel;
  domains: Schemas.TurnstileDomains;
  ephemeral_id?: Schemas.TurnstileEphemeralId;
  mode: Schemas.TurnstileMode;
  name: Schemas.TurnstileName;
  offlabel?: Schemas.TurnstileOfflabel;
};

export type AccountsTurnstileWidgetUpdateVariables = {
  body: AccountsTurnstileWidgetUpdateRequestBody;
  pathParams: AccountsTurnstileWidgetUpdatePathParams;
} & FetcherExtraProps;

/**
 * Update the configuration of a widget.
 */
export const accountsTurnstileWidgetUpdate = (
  variables: AccountsTurnstileWidgetUpdateVariables,
  signal?: AbortSignal
) =>
  fetch<
    AccountsTurnstileWidgetUpdateResponse,
    AccountsTurnstileWidgetUpdateError,
    AccountsTurnstileWidgetUpdateRequestBody,
    {},
    {},
    AccountsTurnstileWidgetUpdatePathParams
  >({ url: '/accounts/{accountId}/challenges/widgets/{sitekey}', method: 'put', ...variables, signal });

export type AccountsTurnstileWidgetRotateSecretPathParams = {
  accountId: Schemas.TurnstileIdentifier;
  sitekey: Schemas.TurnstileSitekey;
};

export type AccountsTurnstileWidgetRotateSecretError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TurnstileApiResponseCommonFailure;
}>;

export type AccountsTurnstileWidgetRotateSecretResponse = Schemas.TurnstileApiResponseCommon & {
  result?: Schemas.TurnstileWidgetDetail;
};

export type AccountsTurnstileWidgetRotateSecretRequestBody = {
  invalidate_immediately?: Schemas.TurnstileInvalidateImmediately;
};

export type AccountsTurnstileWidgetRotateSecretVariables = {
  body?: AccountsTurnstileWidgetRotateSecretRequestBody;
  pathParams: AccountsTurnstileWidgetRotateSecretPathParams;
} & FetcherExtraProps;

/**
 * Generate a new secret key for this widget. If `invalidate_immediately`
 * is set to `false`, the previous secret remains valid for 2 hours.
 *
 * Note that secrets cannot be rotated again during the grace period.
 */
export const accountsTurnstileWidgetRotateSecret = (
  variables: AccountsTurnstileWidgetRotateSecretVariables,
  signal?: AbortSignal
) =>
  fetch<
    AccountsTurnstileWidgetRotateSecretResponse,
    AccountsTurnstileWidgetRotateSecretError,
    AccountsTurnstileWidgetRotateSecretRequestBody,
    {},
    {},
    AccountsTurnstileWidgetRotateSecretPathParams
  >({ url: '/accounts/{accountId}/challenges/widgets/{sitekey}/rotate_secret', method: 'post', ...variables, signal });

export type AccountLevelCustomNameserversListAccountCustomNameserversPathParams = {
  accountId: Schemas.DnsCustomNameserversIdentifier;
};

export type AccountLevelCustomNameserversListAccountCustomNameserversError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsCustomNameserversAcnsResponseCollection & Schemas.DnsCustomNameserversApiResponseCommonFailure;
}>;

export type AccountLevelCustomNameserversListAccountCustomNameserversVariables = {
  pathParams: AccountLevelCustomNameserversListAccountCustomNameserversPathParams;
} & FetcherExtraProps;

/**
 * List an account's custom nameservers.
 */
export const accountLevelCustomNameserversListAccountCustomNameservers = (
  variables: AccountLevelCustomNameserversListAccountCustomNameserversVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsCustomNameserversAcnsResponseCollection,
    AccountLevelCustomNameserversListAccountCustomNameserversError,
    undefined,
    {},
    {},
    AccountLevelCustomNameserversListAccountCustomNameserversPathParams
  >({ url: '/accounts/{accountId}/custom_ns', method: 'get', ...variables, signal });

export type AccountLevelCustomNameserversAddAccountCustomNameserverPathParams = {
  accountId: Schemas.DnsCustomNameserversIdentifier;
};

export type AccountLevelCustomNameserversAddAccountCustomNameserverError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsCustomNameserversAcnsResponseSingle & Schemas.DnsCustomNameserversApiResponseCommonFailure;
}>;

export type AccountLevelCustomNameserversAddAccountCustomNameserverVariables = {
  body: Schemas.DnsCustomNameserversCustomNSInput;
  pathParams: AccountLevelCustomNameserversAddAccountCustomNameserverPathParams;
} & FetcherExtraProps;

export const accountLevelCustomNameserversAddAccountCustomNameserver = (
  variables: AccountLevelCustomNameserversAddAccountCustomNameserverVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsCustomNameserversAcnsResponseSingle,
    AccountLevelCustomNameserversAddAccountCustomNameserverError,
    Schemas.DnsCustomNameserversCustomNSInput,
    {},
    {},
    AccountLevelCustomNameserversAddAccountCustomNameserverPathParams
  >({ url: '/accounts/{accountId}/custom_ns', method: 'post', ...variables, signal });

export type AccountLevelCustomNameserversGetEligibleZonesForAccountCustomNameserversPathParams = {
  accountId: Schemas.DnsCustomNameserversIdentifier;
};

export type AccountLevelCustomNameserversGetEligibleZonesForAccountCustomNameserversError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsCustomNameserversAvailabilityResponse & Schemas.DnsCustomNameserversApiResponseCommonFailure;
}>;

export type AccountLevelCustomNameserversGetEligibleZonesForAccountCustomNameserversVariables = {
  pathParams: AccountLevelCustomNameserversGetEligibleZonesForAccountCustomNameserversPathParams;
} & FetcherExtraProps;

export const accountLevelCustomNameserversGetEligibleZonesForAccountCustomNameservers = (
  variables: AccountLevelCustomNameserversGetEligibleZonesForAccountCustomNameserversVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsCustomNameserversAvailabilityResponse,
    AccountLevelCustomNameserversGetEligibleZonesForAccountCustomNameserversError,
    undefined,
    {},
    {},
    AccountLevelCustomNameserversGetEligibleZonesForAccountCustomNameserversPathParams
  >({ url: '/accounts/{accountId}/custom_ns/availability', method: 'get', ...variables, signal });

export type AccountLevelCustomNameserversDeleteAccountCustomNameserverPathParams = {
  customNsId: Schemas.DnsCustomNameserversNsName;
  accountId: Schemas.DnsCustomNameserversIdentifier;
};

export type AccountLevelCustomNameserversDeleteAccountCustomNameserverError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsCustomNameserversEmptyResponse & Schemas.DnsCustomNameserversApiResponseCommonFailure;
}>;

export type AccountLevelCustomNameserversDeleteAccountCustomNameserverVariables = {
  pathParams: AccountLevelCustomNameserversDeleteAccountCustomNameserverPathParams;
} & FetcherExtraProps;

export const accountLevelCustomNameserversDeleteAccountCustomNameserver = (
  variables: AccountLevelCustomNameserversDeleteAccountCustomNameserverVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsCustomNameserversEmptyResponse,
    AccountLevelCustomNameserversDeleteAccountCustomNameserverError,
    undefined,
    {},
    {},
    AccountLevelCustomNameserversDeleteAccountCustomNameserverPathParams
  >({ url: '/accounts/{accountId}/custom_ns/{customNsId}', method: 'delete', ...variables, signal });

export type CloudflareD1ListDatabasesPathParams = {
  accountId: Schemas.D1AccountIdentifier;
};

export type CloudflareD1ListDatabasesQueryParams = {
  name?: string;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 1000
   * @maximum 10000
   * @minimum 10
   */
  per_page?: number;
};

export type CloudflareD1ListDatabasesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.D1ApiResponseCommonFailure;
}>;

export type CloudflareD1ListDatabasesResponse = {
  errors: Schemas.D1Messages;
  messages: Schemas.D1Messages;
  result: never;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
  result_info?: {
    /**
     * Total number of results for the requested service
     *
     * @example 1
     */
    count?: number;
    /**
     * Current page within paginated list of results
     *
     * @example 1
     */
    page?: number;
    /**
     * Number of results per page of results
     *
     * @example 20
     */
    per_page?: number;
    /**
     * Total results available without any search parameters
     *
     * @example 2000
     */
    total_count?: number;
  };
};

export type CloudflareD1ListDatabasesVariables = {
  pathParams: CloudflareD1ListDatabasesPathParams;
  queryParams?: CloudflareD1ListDatabasesQueryParams;
} & FetcherExtraProps;

/**
 * Returns a list of D1 databases.
 */
export const cloudflareD1ListDatabases = (variables: CloudflareD1ListDatabasesVariables, signal?: AbortSignal) =>
  fetch<
    CloudflareD1ListDatabasesResponse,
    CloudflareD1ListDatabasesError,
    undefined,
    {},
    CloudflareD1ListDatabasesQueryParams,
    CloudflareD1ListDatabasesPathParams
  >({ url: '/accounts/{accountId}/d1/database', method: 'get', ...variables, signal });

export type CloudflareD1CreateDatabasePathParams = {
  accountId: Schemas.D1AccountIdentifier;
};

export type CloudflareD1CreateDatabaseError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.D1ApiResponseCommonFailure;
}>;

export type CloudflareD1CreateDatabaseResponse = {
  errors: Schemas.D1Messages;
  messages: Schemas.D1Messages;
  result: Schemas.D1DatabaseDetailsResponse;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type CloudflareD1CreateDatabaseRequestBody = {
  name: Schemas.D1DatabaseName;
  primary_location_hint?: Schemas.D1PrimaryLocationHint;
};

export type CloudflareD1CreateDatabaseVariables = {
  body: CloudflareD1CreateDatabaseRequestBody;
  pathParams: CloudflareD1CreateDatabasePathParams;
} & FetcherExtraProps;

/**
 * Returns the created D1 database.
 */
export const cloudflareD1CreateDatabase = (variables: CloudflareD1CreateDatabaseVariables, signal?: AbortSignal) =>
  fetch<
    CloudflareD1CreateDatabaseResponse,
    CloudflareD1CreateDatabaseError,
    CloudflareD1CreateDatabaseRequestBody,
    {},
    {},
    CloudflareD1CreateDatabasePathParams
  >({ url: '/accounts/{accountId}/d1/database', method: 'post', ...variables, signal });

export type CloudflareD1DeleteDatabasePathParams = {
  accountId: Schemas.D1AccountIdentifier;
  databaseId: Schemas.D1DatabaseIdentifier;
};

export type CloudflareD1DeleteDatabaseError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.D1ApiResponseCommonFailure;
}>;

export type CloudflareD1DeleteDatabaseResponse = {
  errors: Schemas.D1Messages;
  messages: Schemas.D1Messages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type CloudflareD1DeleteDatabaseVariables = {
  pathParams: CloudflareD1DeleteDatabasePathParams;
} & FetcherExtraProps;

/**
 * Deletes the specified D1 database.
 */
export const cloudflareD1DeleteDatabase = (variables: CloudflareD1DeleteDatabaseVariables, signal?: AbortSignal) =>
  fetch<
    CloudflareD1DeleteDatabaseResponse,
    CloudflareD1DeleteDatabaseError,
    undefined,
    {},
    {},
    CloudflareD1DeleteDatabasePathParams
  >({ url: '/accounts/{accountId}/d1/database/{databaseId}', method: 'delete', ...variables, signal });

export type CloudflareD1GetDatabasePathParams = {
  accountId: Schemas.D1AccountIdentifier;
  databaseId: Schemas.D1DatabaseIdentifier;
};

export type CloudflareD1GetDatabaseError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.D1ApiResponseCommonFailure;
}>;

export type CloudflareD1GetDatabaseResponse = {
  errors: Schemas.D1Messages;
  messages: Schemas.D1Messages;
  result: Schemas.D1DatabaseDetailsResponse;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type CloudflareD1GetDatabaseVariables = {
  pathParams: CloudflareD1GetDatabasePathParams;
} & FetcherExtraProps;

/**
 * Returns the specified D1 database.
 */
export const cloudflareD1GetDatabase = (variables: CloudflareD1GetDatabaseVariables, signal?: AbortSignal) =>
  fetch<
    CloudflareD1GetDatabaseResponse,
    CloudflareD1GetDatabaseError,
    undefined,
    {},
    {},
    CloudflareD1GetDatabasePathParams
  >({ url: '/accounts/{accountId}/d1/database/{databaseId}', method: 'get', ...variables, signal });

export type CloudflareD1ExportDatabasePathParams = {
  accountId: Schemas.D1AccountIdentifier;
  databaseId: Schemas.D1DatabaseIdentifier;
};

export type CloudflareD1ExportDatabaseError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.D1ApiResponseCommonFailure;
}>;

export type CloudflareD1ExportDatabaseRequestBody = {
  /**
   * To poll an in-progress export, provide the current bookmark (returned by your first polling response)
   */
  current_bookmark?: string;
  dump_options?: {
    /**
     * Export only the table definitions, not their contents
     */
    no_data?: boolean;
    /**
     * Export only each table's contents, not its definition
     */
    no_schema?: boolean;
    /**
     * Filter the export to just one or more tables. Passing an empty array is the same as not passing anything and means: export all tables.
     */
    tables?: string[];
  };
  /**
   * Specifies that you will poll this endpoint until the export completes
   */
  output_format: 'polling';
};

export type CloudflareD1ExportDatabaseVariables = {
  body: CloudflareD1ExportDatabaseRequestBody;
  pathParams: CloudflareD1ExportDatabasePathParams;
} & FetcherExtraProps;

/**
 * Returns a URL where the SQL contents of your D1 can be downloaded. Note: this process may take
 * some time for larger DBs, during which your D1 will be unavailable to serve queries. To avoid
 * blocking your DB unnecessarily, an in-progress export must be continually polled or will automatically cancel.
 */
export const cloudflareD1ExportDatabase = (variables: CloudflareD1ExportDatabaseVariables, signal?: AbortSignal) =>
  fetch<
    | {
        errors: Schemas.D1Messages;
        messages: Schemas.D1Messages;
        result: {
          /**
           * The current time-travel bookmark for your D1, used to poll for updates. Will not change for the duration of the export task.
           */
          at_bookmark?: string;
          /**
           * Only present when status = 'error'. Contains the error message.
           */
          error?: string;
          /**
           * Logs since the last time you polled
           */
          messages?: string[];
          /**
           * Only present when status = 'complete'
           */
          result?: {
            /**
             * The generated SQL filename.
             */
            filename?: string;
            /**
             * The URL to download the exported SQL. Available for one hour.
             */
            signed_url?: string;
          };
          status?: 'complete' | 'error';
          success?: boolean;
          type?: 'export';
        };
        /**
         * Whether the API call was successful
         *
         * @example true
         */
        success: true;
      }
    | {
        errors: Schemas.D1Messages;
        messages: Schemas.D1Messages;
        result: {
          /**
           * The current time-travel bookmark for your D1, used to poll for updates. Will not change for the duration of the export task.
           */
          at_bookmark?: string;
          /**
           * Logs since the last time you polled
           */
          messages?: string[];
          status?: 'active';
          success?: boolean;
          type?: 'export';
        };
        /**
         * Whether the API call was successful
         *
         * @example true
         */
        success: true;
      },
    CloudflareD1ExportDatabaseError,
    CloudflareD1ExportDatabaseRequestBody,
    {},
    {},
    CloudflareD1ExportDatabasePathParams
  >({ url: '/accounts/{accountId}/d1/database/{databaseId}/export', method: 'post', ...variables, signal });

export type CloudflareD1ImportDatabasePathParams = {
  accountId: Schemas.D1AccountIdentifier;
  databaseId: Schemas.D1DatabaseIdentifier;
};

export type CloudflareD1ImportDatabaseError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.D1ApiResponseCommonFailure;
}>;

export type CloudflareD1ImportDatabaseVariables = {
  body?:
    | {
        /**
         * Indicates you have a new SQL file to upload.
         */
        action: 'init';
        /**
         * Required when action is 'init' or 'ingest'. An md5 hash of the file you're uploading. Used to check if it already exists, and validate its contents before ingesting.
         */
        etag: string;
      }
    | {
        /**
         * Indicates you've finished uploading to tell the D1 to start consuming it
         */
        action: 'ingest';
        /**
         * An md5 hash of the file you're uploading. Used to check if it already exists, and validate its contents before ingesting.
         */
        etag: string;
        /**
         * The filename you have successfully uploaded.
         */
        filename: string;
      }
    | {
        /**
         * Indicates you've finished uploading to tell the D1 to start consuming it
         */
        action: 'poll';
        /**
         * This identifies the currently-running import, checking its status.
         */
        current_bookmark: string;
      };
  pathParams: CloudflareD1ImportDatabasePathParams;
} & FetcherExtraProps;

/**
 * Generates a temporary URL for uploading an SQL file to, then instructing the D1 to import it
 * and polling it for status updates. Imports block the D1 for their duration.
 */
export const cloudflareD1ImportDatabase = (variables: CloudflareD1ImportDatabaseVariables, signal?: AbortSignal) =>
  fetch<
    | {
        errors: Schemas.D1Messages;
        messages: Schemas.D1Messages;
        result: {
          /**
           * The current time-travel bookmark for your D1, used to poll for updates. Will not change for the duration of the import. Only returned if an import process is currently running or recently finished.
           */
          at_bookmark?: string;
          /**
           * Only present when status = 'error'. Contains the error message that prevented the import from succeeding.
           */
          error?: string;
          /**
           * Derived from the database ID and etag, to use in avoiding repeated uploads. Only returned when for the 'init' action.
           */
          filename?: string;
          /**
           * Logs since the last time you polled
           */
          messages?: string[];
          /**
           * Only present when status = 'complete'
           */
          result?: {
            /**
             * The time-travel bookmark if you need restore your D1 to directly after the import succeeded.
             */
            final_bookmark?: string;
            meta?: Schemas.D1QueryMeta;
            /**
             * The total number of queries that were executed during the import.
             */
            num_queries?: number;
          };
          status?: 'complete' | 'error';
          success?: boolean;
          type?: 'import';
          /**
           * The R2 presigned URL to use for uploading. Only returned when for the 'init' action.
           */
          upload_url?: string;
        };
        /**
         * Whether the API call was successful
         *
         * @example true
         */
        success: true;
      }
    | {
        errors: Schemas.D1Messages;
        messages: Schemas.D1Messages;
        result: {
          /**
           * The current time-travel bookmark for your D1, used to poll for updates. Will not change for the duration of the import.
           */
          at_bookmark?: string;
          /**
           * Logs since the last time you polled
           */
          messages?: string[];
          status?: 'active';
          success?: boolean;
          type?: 'import';
        };
        /**
         * Whether the API call was successful
         *
         * @example true
         */
        success: true;
      },
    CloudflareD1ImportDatabaseError,
    | {
        /**
         * Indicates you have a new SQL file to upload.
         */
        action: 'init';
        /**
         * Required when action is 'init' or 'ingest'. An md5 hash of the file you're uploading. Used to check if it already exists, and validate its contents before ingesting.
         */
        etag: string;
      }
    | {
        /**
         * Indicates you've finished uploading to tell the D1 to start consuming it
         */
        action: 'ingest';
        /**
         * An md5 hash of the file you're uploading. Used to check if it already exists, and validate its contents before ingesting.
         */
        etag: string;
        /**
         * The filename you have successfully uploaded.
         */
        filename: string;
      }
    | {
        /**
         * Indicates you've finished uploading to tell the D1 to start consuming it
         */
        action: 'poll';
        /**
         * This identifies the currently-running import, checking its status.
         */
        current_bookmark: string;
      },
    {},
    {},
    CloudflareD1ImportDatabasePathParams
  >({ url: '/accounts/{accountId}/d1/database/{databaseId}/import', method: 'post', ...variables, signal });

export type CloudflareD1QueryDatabasePathParams = {
  accountId: Schemas.D1AccountIdentifier;
  databaseId: Schemas.D1DatabaseIdentifier;
};

export type CloudflareD1QueryDatabaseError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.D1ApiResponseCommonFailure;
}>;

export type CloudflareD1QueryDatabaseResponse = {
  errors: Schemas.D1Messages;
  messages: Schemas.D1Messages;
  result: never;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type CloudflareD1QueryDatabaseRequestBody = {
  params?: Schemas.D1Params;
  sql: Schemas.D1Sql;
};

export type CloudflareD1QueryDatabaseVariables = {
  body: CloudflareD1QueryDatabaseRequestBody;
  pathParams: CloudflareD1QueryDatabasePathParams;
} & FetcherExtraProps;

/**
 * Returns the query result as an object.
 */
export const cloudflareD1QueryDatabase = (variables: CloudflareD1QueryDatabaseVariables, signal?: AbortSignal) =>
  fetch<
    CloudflareD1QueryDatabaseResponse,
    CloudflareD1QueryDatabaseError,
    CloudflareD1QueryDatabaseRequestBody,
    {},
    {},
    CloudflareD1QueryDatabasePathParams
  >({ url: '/accounts/{accountId}/d1/database/{databaseId}/query', method: 'post', ...variables, signal });

export type CloudflareD1RawDatabaseQueryPathParams = {
  accountId: Schemas.D1AccountIdentifier;
  databaseId: Schemas.D1DatabaseIdentifier;
};

export type CloudflareD1RawDatabaseQueryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.D1ApiResponseCommonFailure;
}>;

export type CloudflareD1RawDatabaseQueryResponse = {
  errors: Schemas.D1Messages;
  messages: Schemas.D1Messages;
  result: never;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type CloudflareD1RawDatabaseQueryRequestBody = {
  params?: Schemas.D1Params;
  sql: Schemas.D1Sql;
};

export type CloudflareD1RawDatabaseQueryVariables = {
  body: CloudflareD1RawDatabaseQueryRequestBody;
  pathParams: CloudflareD1RawDatabaseQueryPathParams;
} & FetcherExtraProps;

/**
 * Returns the query result rows as arrays rather than objects. This is a performance-optimized version of the /query endpoint.
 */
export const cloudflareD1RawDatabaseQuery = (variables: CloudflareD1RawDatabaseQueryVariables, signal?: AbortSignal) =>
  fetch<
    CloudflareD1RawDatabaseQueryResponse,
    CloudflareD1RawDatabaseQueryError,
    CloudflareD1RawDatabaseQueryRequestBody,
    {},
    {},
    CloudflareD1RawDatabaseQueryPathParams
  >({ url: '/accounts/{accountId}/d1/database/{databaseId}/raw', method: 'post', ...variables, signal });

export type DevicesListDevicesPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesListDevicesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesDevicesResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesListDevicesVariables = {
  pathParams: DevicesListDevicesPathParams;
} & FetcherExtraProps;

/**
 * Fetches a list of enrolled devices.
 */
export const devicesListDevices = (variables: DevicesListDevicesVariables, signal?: AbortSignal) =>
  fetch<Schemas.TeamsDevicesDevicesResponse, DevicesListDevicesError, undefined, {}, {}, DevicesListDevicesPathParams>({
    url: '/accounts/{accountId}/devices',
    method: 'get',
    ...variables,
    signal
  });

export type DeviceDexTestDetailsPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DeviceDexTestDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesDexSingleResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DeviceDexTestDetailsVariables = {
  pathParams: DeviceDexTestDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetch all DEX tests.
 */
export const deviceDexTestDetails = (variables: DeviceDexTestDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.TeamsDevicesDexResponseCollection,
    DeviceDexTestDetailsError,
    undefined,
    {},
    {},
    DeviceDexTestDetailsPathParams
  >({ url: '/accounts/{accountId}/devices/dex_tests', method: 'get', ...variables, signal });

export type DeviceDexTestCreateDeviceDexTestPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DeviceDexTestCreateDeviceDexTestError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesDexSingleResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DeviceDexTestCreateDeviceDexTestVariables = {
  body: Schemas.TeamsDevicesDeviceDexTestSchemasHttp;
  pathParams: DeviceDexTestCreateDeviceDexTestPathParams;
} & FetcherExtraProps;

/**
 * Create a DEX test.
 */
export const deviceDexTestCreateDeviceDexTest = (
  variables: DeviceDexTestCreateDeviceDexTestVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesDexSingleResponse,
    DeviceDexTestCreateDeviceDexTestError,
    Schemas.TeamsDevicesDeviceDexTestSchemasHttp,
    {},
    {},
    DeviceDexTestCreateDeviceDexTestPathParams
  >({ url: '/accounts/{accountId}/devices/dex_tests', method: 'post', ...variables, signal });

export type DeviceDexTestDeleteDeviceDexTestPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
  dexTestId: Schemas.TeamsDevicesUuid;
};

export type DeviceDexTestDeleteDeviceDexTestError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesDexResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DeviceDexTestDeleteDeviceDexTestVariables = {
  pathParams: DeviceDexTestDeleteDeviceDexTestPathParams;
} & FetcherExtraProps;

/**
 * Delete a Device DEX test. Returns the remaining device dex tests for the account.
 */
export const deviceDexTestDeleteDeviceDexTest = (
  variables: DeviceDexTestDeleteDeviceDexTestVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesDexDeleteResponseCollection,
    DeviceDexTestDeleteDeviceDexTestError,
    undefined,
    {},
    {},
    DeviceDexTestDeleteDeviceDexTestPathParams
  >({ url: '/accounts/{accountId}/devices/dex_tests/{dexTestId}', method: 'delete', ...variables, signal });

export type DeviceDexTestGetDeviceDexTestPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
  dexTestId: Schemas.TeamsDevicesSchemasTestId;
};

export type DeviceDexTestGetDeviceDexTestError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesDexSingleResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DeviceDexTestGetDeviceDexTestVariables = {
  pathParams: DeviceDexTestGetDeviceDexTestPathParams;
} & FetcherExtraProps;

/**
 * Fetch a single DEX test.
 */
export const deviceDexTestGetDeviceDexTest = (
  variables: DeviceDexTestGetDeviceDexTestVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesDexSingleResponse,
    DeviceDexTestGetDeviceDexTestError,
    undefined,
    {},
    {},
    DeviceDexTestGetDeviceDexTestPathParams
  >({ url: '/accounts/{accountId}/devices/dex_tests/{dexTestId}', method: 'get', ...variables, signal });

export type DeviceDexTestUpdateDeviceDexTestPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
  dexTestId: Schemas.TeamsDevicesUuid;
};

export type DeviceDexTestUpdateDeviceDexTestError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesDexSingleResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DeviceDexTestUpdateDeviceDexTestVariables = {
  body: Schemas.TeamsDevicesDeviceDexTestSchemasHttp;
  pathParams: DeviceDexTestUpdateDeviceDexTestPathParams;
} & FetcherExtraProps;

/**
 * Update a DEX test.
 */
export const deviceDexTestUpdateDeviceDexTest = (
  variables: DeviceDexTestUpdateDeviceDexTestVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesDexSingleResponse,
    DeviceDexTestUpdateDeviceDexTestError,
    Schemas.TeamsDevicesDeviceDexTestSchemasHttp,
    {},
    {},
    DeviceDexTestUpdateDeviceDexTestPathParams
  >({ url: '/accounts/{accountId}/devices/dex_tests/{dexTestId}', method: 'put', ...variables, signal });

export type DeviceManagedNetworksListDeviceManagedNetworksPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DeviceManagedNetworksListDeviceManagedNetworksError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesComponentsSchemasResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DeviceManagedNetworksListDeviceManagedNetworksVariables = {
  pathParams: DeviceManagedNetworksListDeviceManagedNetworksPathParams;
} & FetcherExtraProps;

/**
 * Fetches a list of managed networks for an account.
 */
export const deviceManagedNetworksListDeviceManagedNetworks = (
  variables: DeviceManagedNetworksListDeviceManagedNetworksVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesComponentsSchemasResponseCollection,
    DeviceManagedNetworksListDeviceManagedNetworksError,
    undefined,
    {},
    {},
    DeviceManagedNetworksListDeviceManagedNetworksPathParams
  >({ url: '/accounts/{accountId}/devices/networks', method: 'get', ...variables, signal });

export type DeviceManagedNetworksCreateDeviceManagedNetworkPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DeviceManagedNetworksCreateDeviceManagedNetworkError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesComponentsSchemasSingleResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DeviceManagedNetworksCreateDeviceManagedNetworkRequestBody = {
  config: Schemas.TeamsDevicesSchemasConfigRequest;
  name: Schemas.TeamsDevicesDeviceManagedNetworksComponentsSchemasName;
  type: Schemas.TeamsDevicesComponentsSchemasType;
};

export type DeviceManagedNetworksCreateDeviceManagedNetworkVariables = {
  body: DeviceManagedNetworksCreateDeviceManagedNetworkRequestBody;
  pathParams: DeviceManagedNetworksCreateDeviceManagedNetworkPathParams;
} & FetcherExtraProps;

/**
 * Creates a new device managed network.
 */
export const deviceManagedNetworksCreateDeviceManagedNetwork = (
  variables: DeviceManagedNetworksCreateDeviceManagedNetworkVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesComponentsSchemasSingleResponse,
    DeviceManagedNetworksCreateDeviceManagedNetworkError,
    DeviceManagedNetworksCreateDeviceManagedNetworkRequestBody,
    {},
    {},
    DeviceManagedNetworksCreateDeviceManagedNetworkPathParams
  >({ url: '/accounts/{accountId}/devices/networks', method: 'post', ...variables, signal });

export type DeviceManagedNetworksDeleteDeviceManagedNetworkPathParams = {
  networkId: Schemas.TeamsDevicesUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DeviceManagedNetworksDeleteDeviceManagedNetworkError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesComponentsSchemasResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DeviceManagedNetworksDeleteDeviceManagedNetworkVariables = {
  pathParams: DeviceManagedNetworksDeleteDeviceManagedNetworkPathParams;
} & FetcherExtraProps;

/**
 * Deletes a device managed network and fetches a list of the remaining device managed networks for an account.
 */
export const deviceManagedNetworksDeleteDeviceManagedNetwork = (
  variables: DeviceManagedNetworksDeleteDeviceManagedNetworkVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesComponentsSchemasResponseCollection,
    DeviceManagedNetworksDeleteDeviceManagedNetworkError,
    undefined,
    {},
    {},
    DeviceManagedNetworksDeleteDeviceManagedNetworkPathParams
  >({ url: '/accounts/{accountId}/devices/networks/{networkId}', method: 'delete', ...variables, signal });

export type DeviceManagedNetworksDeviceManagedNetworkDetailsPathParams = {
  networkId: Schemas.TeamsDevicesUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DeviceManagedNetworksDeviceManagedNetworkDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesComponentsSchemasSingleResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DeviceManagedNetworksDeviceManagedNetworkDetailsVariables = {
  pathParams: DeviceManagedNetworksDeviceManagedNetworkDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetches details for a single managed network.
 */
export const deviceManagedNetworksDeviceManagedNetworkDetails = (
  variables: DeviceManagedNetworksDeviceManagedNetworkDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesComponentsSchemasSingleResponse,
    DeviceManagedNetworksDeviceManagedNetworkDetailsError,
    undefined,
    {},
    {},
    DeviceManagedNetworksDeviceManagedNetworkDetailsPathParams
  >({ url: '/accounts/{accountId}/devices/networks/{networkId}', method: 'get', ...variables, signal });

export type DeviceManagedNetworksUpdateDeviceManagedNetworkPathParams = {
  networkId: Schemas.TeamsDevicesUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DeviceManagedNetworksUpdateDeviceManagedNetworkError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesComponentsSchemasSingleResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DeviceManagedNetworksUpdateDeviceManagedNetworkRequestBody = {
  config?: Schemas.TeamsDevicesSchemasConfigRequest;
  name?: Schemas.TeamsDevicesDeviceManagedNetworksComponentsSchemasName;
  type?: Schemas.TeamsDevicesComponentsSchemasType;
};

export type DeviceManagedNetworksUpdateDeviceManagedNetworkVariables = {
  body?: DeviceManagedNetworksUpdateDeviceManagedNetworkRequestBody;
  pathParams: DeviceManagedNetworksUpdateDeviceManagedNetworkPathParams;
} & FetcherExtraProps;

/**
 * Updates a configured device managed network.
 */
export const deviceManagedNetworksUpdateDeviceManagedNetwork = (
  variables: DeviceManagedNetworksUpdateDeviceManagedNetworkVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesComponentsSchemasSingleResponse,
    DeviceManagedNetworksUpdateDeviceManagedNetworkError,
    DeviceManagedNetworksUpdateDeviceManagedNetworkRequestBody,
    {},
    {},
    DeviceManagedNetworksUpdateDeviceManagedNetworkPathParams
  >({ url: '/accounts/{accountId}/devices/networks/{networkId}', method: 'put', ...variables, signal });

export type DevicesListDeviceSettingsPoliciesPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesListDeviceSettingsPoliciesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesDeviceSettingsResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesListDeviceSettingsPoliciesVariables = {
  pathParams: DevicesListDeviceSettingsPoliciesPathParams;
} & FetcherExtraProps;

/**
 * Fetches a list of the device settings profiles for an account.
 */
export const devicesListDeviceSettingsPolicies = (
  variables: DevicesListDeviceSettingsPoliciesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesDeviceSettingsResponseCollection,
    DevicesListDeviceSettingsPoliciesError,
    undefined,
    {},
    {},
    DevicesListDeviceSettingsPoliciesPathParams
  >({ url: '/accounts/{accountId}/devices/policies', method: 'get', ...variables, signal });

export type DevicesGetDefaultDeviceSettingsPolicyPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesGetDefaultDeviceSettingsPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesDefaultDeviceSettingsResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesGetDefaultDeviceSettingsPolicyVariables = {
  pathParams: DevicesGetDefaultDeviceSettingsPolicyPathParams;
} & FetcherExtraProps;

/**
 * Fetches the default device settings profile for an account.
 */
export const devicesGetDefaultDeviceSettingsPolicy = (
  variables: DevicesGetDefaultDeviceSettingsPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesDefaultDeviceSettingsResponse,
    DevicesGetDefaultDeviceSettingsPolicyError,
    undefined,
    {},
    {},
    DevicesGetDefaultDeviceSettingsPolicyPathParams
  >({ url: '/accounts/{accountId}/devices/policy', method: 'get', ...variables, signal });

export type DevicesUpdateDefaultDeviceSettingsPolicyPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesUpdateDefaultDeviceSettingsPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesDefaultDeviceSettingsResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesUpdateDefaultDeviceSettingsPolicyRequestBody = {
  allow_mode_switch?: Schemas.TeamsDevicesAllowModeSwitch;
  allow_updates?: Schemas.TeamsDevicesAllowUpdates;
  allowed_to_leave?: Schemas.TeamsDevicesAllowedToLeave;
  auto_connect?: Schemas.TeamsDevicesAutoConnect;
  captive_portal?: Schemas.TeamsDevicesCaptivePortal;
  disable_auto_fallback?: Schemas.TeamsDevicesDisableAutoFallback;
  exclude_office_ips?: Schemas.TeamsDevicesExcludeOfficeIps;
  service_mode_v2?: Schemas.TeamsDevicesServiceModeV2;
  support_url?: Schemas.TeamsDevicesSupportUrl;
  switch_locked?: Schemas.TeamsDevicesSwitchLocked;
  tunnel_protocol?: Schemas.TeamsDevicesTunnelProtocol;
};

export type DevicesUpdateDefaultDeviceSettingsPolicyVariables = {
  body?: DevicesUpdateDefaultDeviceSettingsPolicyRequestBody;
  pathParams: DevicesUpdateDefaultDeviceSettingsPolicyPathParams;
} & FetcherExtraProps;

/**
 * Updates the default device settings profile for an account.
 */
export const devicesUpdateDefaultDeviceSettingsPolicy = (
  variables: DevicesUpdateDefaultDeviceSettingsPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesDefaultDeviceSettingsResponse,
    DevicesUpdateDefaultDeviceSettingsPolicyError,
    DevicesUpdateDefaultDeviceSettingsPolicyRequestBody,
    {},
    {},
    DevicesUpdateDefaultDeviceSettingsPolicyPathParams
  >({ url: '/accounts/{accountId}/devices/policy', method: 'patch', ...variables, signal });

export type DevicesCreateDeviceSettingsPolicyPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesCreateDeviceSettingsPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesDeviceSettingsResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesCreateDeviceSettingsPolicyRequestBody = {
  allow_mode_switch?: Schemas.TeamsDevicesAllowModeSwitch;
  allow_updates?: Schemas.TeamsDevicesAllowUpdates;
  allowed_to_leave?: Schemas.TeamsDevicesAllowedToLeave;
  auto_connect?: Schemas.TeamsDevicesAutoConnect;
  captive_portal?: Schemas.TeamsDevicesCaptivePortal;
  description?: Schemas.TeamsDevicesSchemasDescription;
  disable_auto_fallback?: Schemas.TeamsDevicesDisableAutoFallback;
  /**
   * Whether the policy will be applied to matching devices.
   *
   * @example true
   */
  enabled?: boolean;
  exclude_office_ips?: Schemas.TeamsDevicesExcludeOfficeIps;
  lan_allow_minutes?: Schemas.TeamsDevicesLanAllowMinutes;
  lan_allow_subnet_size?: Schemas.TeamsDevicesLanAllowSubnetSize;
  match: Schemas.TeamsDevicesSchemasMatch;
  /**
   * The name of the device settings profile.
   *
   * @example Allow Developers
   * @maxLength 100
   */
  name: string;
  precedence: Schemas.TeamsDevicesPrecedence;
  service_mode_v2?: Schemas.TeamsDevicesServiceModeV2;
  support_url?: Schemas.TeamsDevicesSupportUrl;
  switch_locked?: Schemas.TeamsDevicesSwitchLocked;
  tunnel_protocol?: Schemas.TeamsDevicesTunnelProtocol;
};

export type DevicesCreateDeviceSettingsPolicyVariables = {
  body: DevicesCreateDeviceSettingsPolicyRequestBody;
  pathParams: DevicesCreateDeviceSettingsPolicyPathParams;
} & FetcherExtraProps;

/**
 * Creates a device settings profile to be applied to certain devices matching the criteria.
 */
export const devicesCreateDeviceSettingsPolicy = (
  variables: DevicesCreateDeviceSettingsPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesDeviceSettingsResponse,
    DevicesCreateDeviceSettingsPolicyError,
    DevicesCreateDeviceSettingsPolicyRequestBody,
    {},
    {},
    DevicesCreateDeviceSettingsPolicyPathParams
  >({ url: '/accounts/{accountId}/devices/policy', method: 'post', ...variables, signal });

export type DevicesGetSplitTunnelExcludeListPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesGetSplitTunnelExcludeListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesSplitTunnelResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesGetSplitTunnelExcludeListVariables = {
  pathParams: DevicesGetSplitTunnelExcludeListPathParams;
} & FetcherExtraProps;

/**
 * Fetches the list of routes excluded from the WARP client's tunnel.
 */
export const devicesGetSplitTunnelExcludeList = (
  variables: DevicesGetSplitTunnelExcludeListVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesSplitTunnelResponseCollection,
    DevicesGetSplitTunnelExcludeListError,
    undefined,
    {},
    {},
    DevicesGetSplitTunnelExcludeListPathParams
  >({ url: '/accounts/{accountId}/devices/policy/exclude', method: 'get', ...variables, signal });

export type DevicesSetSplitTunnelExcludeListPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesSetSplitTunnelExcludeListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesSplitTunnelResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesSetSplitTunnelExcludeListRequestBody = Schemas.TeamsDevicesSplitTunnel[];

export type DevicesSetSplitTunnelExcludeListVariables = {
  body?: DevicesSetSplitTunnelExcludeListRequestBody;
  pathParams: DevicesSetSplitTunnelExcludeListPathParams;
} & FetcherExtraProps;

/**
 * Sets the list of routes excluded from the WARP client's tunnel.
 */
export const devicesSetSplitTunnelExcludeList = (
  variables: DevicesSetSplitTunnelExcludeListVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesSplitTunnelResponseCollection,
    DevicesSetSplitTunnelExcludeListError,
    DevicesSetSplitTunnelExcludeListRequestBody,
    {},
    {},
    DevicesSetSplitTunnelExcludeListPathParams
  >({ url: '/accounts/{accountId}/devices/policy/exclude', method: 'put', ...variables, signal });

export type DevicesGetLocalDomainFallbackListPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesGetLocalDomainFallbackListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesFallbackDomainResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesGetLocalDomainFallbackListVariables = {
  pathParams: DevicesGetLocalDomainFallbackListPathParams;
} & FetcherExtraProps;

/**
 * Fetches a list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead.
 */
export const devicesGetLocalDomainFallbackList = (
  variables: DevicesGetLocalDomainFallbackListVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesFallbackDomainResponseCollection,
    DevicesGetLocalDomainFallbackListError,
    undefined,
    {},
    {},
    DevicesGetLocalDomainFallbackListPathParams
  >({ url: '/accounts/{accountId}/devices/policy/fallback_domains', method: 'get', ...variables, signal });

export type DevicesSetLocalDomainFallbackListPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesSetLocalDomainFallbackListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesFallbackDomainResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesSetLocalDomainFallbackListRequestBody = Schemas.TeamsDevicesFallbackDomain[];

export type DevicesSetLocalDomainFallbackListVariables = {
  body?: DevicesSetLocalDomainFallbackListRequestBody;
  pathParams: DevicesSetLocalDomainFallbackListPathParams;
} & FetcherExtraProps;

/**
 * Sets the list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead.
 */
export const devicesSetLocalDomainFallbackList = (
  variables: DevicesSetLocalDomainFallbackListVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesFallbackDomainResponseCollection,
    DevicesSetLocalDomainFallbackListError,
    DevicesSetLocalDomainFallbackListRequestBody,
    {},
    {},
    DevicesSetLocalDomainFallbackListPathParams
  >({ url: '/accounts/{accountId}/devices/policy/fallback_domains', method: 'put', ...variables, signal });

export type DevicesGetSplitTunnelIncludeListPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesGetSplitTunnelIncludeListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesSplitTunnelIncludeResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesGetSplitTunnelIncludeListVariables = {
  pathParams: DevicesGetSplitTunnelIncludeListPathParams;
} & FetcherExtraProps;

/**
 * Fetches the list of routes included in the WARP client's tunnel.
 */
export const devicesGetSplitTunnelIncludeList = (
  variables: DevicesGetSplitTunnelIncludeListVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesSplitTunnelIncludeResponseCollection,
    DevicesGetSplitTunnelIncludeListError,
    undefined,
    {},
    {},
    DevicesGetSplitTunnelIncludeListPathParams
  >({ url: '/accounts/{accountId}/devices/policy/include', method: 'get', ...variables, signal });

export type DevicesSetSplitTunnelIncludeListPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesSetSplitTunnelIncludeListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesSplitTunnelIncludeResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesSetSplitTunnelIncludeListRequestBody = Schemas.TeamsDevicesSplitTunnelInclude[];

export type DevicesSetSplitTunnelIncludeListVariables = {
  body?: DevicesSetSplitTunnelIncludeListRequestBody;
  pathParams: DevicesSetSplitTunnelIncludeListPathParams;
} & FetcherExtraProps;

/**
 * Sets the list of routes included in the WARP client's tunnel.
 */
export const devicesSetSplitTunnelIncludeList = (
  variables: DevicesSetSplitTunnelIncludeListVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesSplitTunnelIncludeResponseCollection,
    DevicesSetSplitTunnelIncludeListError,
    DevicesSetSplitTunnelIncludeListRequestBody,
    {},
    {},
    DevicesSetSplitTunnelIncludeListPathParams
  >({ url: '/accounts/{accountId}/devices/policy/include', method: 'put', ...variables, signal });

export type DevicesDeleteDeviceSettingsPolicyPathParams = {
  policyId: Schemas.TeamsDevicesSchemasUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesDeleteDeviceSettingsPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesDeviceSettingsResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesDeleteDeviceSettingsPolicyVariables = {
  pathParams: DevicesDeleteDeviceSettingsPolicyPathParams;
} & FetcherExtraProps;

/**
 * Deletes a device settings profile and fetches a list of the remaining profiles for an account.
 */
export const devicesDeleteDeviceSettingsPolicy = (
  variables: DevicesDeleteDeviceSettingsPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesDeviceSettingsResponseCollection,
    DevicesDeleteDeviceSettingsPolicyError,
    undefined,
    {},
    {},
    DevicesDeleteDeviceSettingsPolicyPathParams
  >({ url: '/accounts/{accountId}/devices/policy/{policyId}', method: 'delete', ...variables, signal });

export type DevicesGetDeviceSettingsPolicyByIdPathParams = {
  policyId: Schemas.TeamsDevicesSchemasUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesGetDeviceSettingsPolicyByIdError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesDeviceSettingsResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesGetDeviceSettingsPolicyByIdVariables = {
  pathParams: DevicesGetDeviceSettingsPolicyByIdPathParams;
} & FetcherExtraProps;

/**
 * Fetches a device settings profile by ID.
 */
export const devicesGetDeviceSettingsPolicyById = (
  variables: DevicesGetDeviceSettingsPolicyByIdVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesDeviceSettingsResponse,
    DevicesGetDeviceSettingsPolicyByIdError,
    undefined,
    {},
    {},
    DevicesGetDeviceSettingsPolicyByIdPathParams
  >({ url: '/accounts/{accountId}/devices/policy/{policyId}', method: 'get', ...variables, signal });

export type DevicesUpdateDeviceSettingsPolicyPathParams = {
  policyId: Schemas.TeamsDevicesSchemasUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesUpdateDeviceSettingsPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesDeviceSettingsResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesUpdateDeviceSettingsPolicyRequestBody = {
  allow_mode_switch?: Schemas.TeamsDevicesAllowModeSwitch;
  allow_updates?: Schemas.TeamsDevicesAllowUpdates;
  allowed_to_leave?: Schemas.TeamsDevicesAllowedToLeave;
  auto_connect?: Schemas.TeamsDevicesAutoConnect;
  captive_portal?: Schemas.TeamsDevicesCaptivePortal;
  description?: Schemas.TeamsDevicesSchemasDescription;
  disable_auto_fallback?: Schemas.TeamsDevicesDisableAutoFallback;
  /**
   * Whether the policy will be applied to matching devices.
   *
   * @example true
   */
  enabled?: boolean;
  exclude_office_ips?: Schemas.TeamsDevicesExcludeOfficeIps;
  match?: Schemas.TeamsDevicesSchemasMatch;
  /**
   * The name of the device settings profile.
   *
   * @example Allow Developers
   * @maxLength 100
   */
  name?: string;
  precedence?: Schemas.TeamsDevicesPrecedence;
  service_mode_v2?: Schemas.TeamsDevicesServiceModeV2;
  support_url?: Schemas.TeamsDevicesSupportUrl;
  switch_locked?: Schemas.TeamsDevicesSwitchLocked;
  tunnel_protocol?: Schemas.TeamsDevicesTunnelProtocol;
};

export type DevicesUpdateDeviceSettingsPolicyVariables = {
  body?: DevicesUpdateDeviceSettingsPolicyRequestBody;
  pathParams: DevicesUpdateDeviceSettingsPolicyPathParams;
} & FetcherExtraProps;

/**
 * Updates a configured device settings profile.
 */
export const devicesUpdateDeviceSettingsPolicy = (
  variables: DevicesUpdateDeviceSettingsPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesDeviceSettingsResponse,
    DevicesUpdateDeviceSettingsPolicyError,
    DevicesUpdateDeviceSettingsPolicyRequestBody,
    {},
    {},
    DevicesUpdateDeviceSettingsPolicyPathParams
  >({ url: '/accounts/{accountId}/devices/policy/{policyId}', method: 'patch', ...variables, signal });

export type DevicesGetSplitTunnelExcludeListForADeviceSettingsPolicyPathParams = {
  policyId: Schemas.TeamsDevicesSchemasUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesGetSplitTunnelExcludeListForADeviceSettingsPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesSplitTunnelResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesGetSplitTunnelExcludeListForADeviceSettingsPolicyVariables = {
  pathParams: DevicesGetSplitTunnelExcludeListForADeviceSettingsPolicyPathParams;
} & FetcherExtraProps;

/**
 * Fetches the list of routes excluded from the WARP client's tunnel for a specific device settings profile.
 */
export const devicesGetSplitTunnelExcludeListForADeviceSettingsPolicy = (
  variables: DevicesGetSplitTunnelExcludeListForADeviceSettingsPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesSplitTunnelResponseCollection,
    DevicesGetSplitTunnelExcludeListForADeviceSettingsPolicyError,
    undefined,
    {},
    {},
    DevicesGetSplitTunnelExcludeListForADeviceSettingsPolicyPathParams
  >({ url: '/accounts/{accountId}/devices/policy/{policyId}/exclude', method: 'get', ...variables, signal });

export type DevicesSetSplitTunnelExcludeListForADeviceSettingsPolicyPathParams = {
  policyId: Schemas.TeamsDevicesSchemasUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesSetSplitTunnelExcludeListForADeviceSettingsPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesSplitTunnelResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesSetSplitTunnelExcludeListForADeviceSettingsPolicyRequestBody = Schemas.TeamsDevicesSplitTunnel[];

export type DevicesSetSplitTunnelExcludeListForADeviceSettingsPolicyVariables = {
  body?: DevicesSetSplitTunnelExcludeListForADeviceSettingsPolicyRequestBody;
  pathParams: DevicesSetSplitTunnelExcludeListForADeviceSettingsPolicyPathParams;
} & FetcherExtraProps;

/**
 * Sets the list of routes excluded from the WARP client's tunnel for a specific device settings profile.
 */
export const devicesSetSplitTunnelExcludeListForADeviceSettingsPolicy = (
  variables: DevicesSetSplitTunnelExcludeListForADeviceSettingsPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesSplitTunnelResponseCollection,
    DevicesSetSplitTunnelExcludeListForADeviceSettingsPolicyError,
    DevicesSetSplitTunnelExcludeListForADeviceSettingsPolicyRequestBody,
    {},
    {},
    DevicesSetSplitTunnelExcludeListForADeviceSettingsPolicyPathParams
  >({ url: '/accounts/{accountId}/devices/policy/{policyId}/exclude', method: 'put', ...variables, signal });

export type DevicesGetLocalDomainFallbackListForADeviceSettingsPolicyPathParams = {
  policyId: Schemas.TeamsDevicesSchemasUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesGetLocalDomainFallbackListForADeviceSettingsPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesFallbackDomainResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesGetLocalDomainFallbackListForADeviceSettingsPolicyVariables = {
  pathParams: DevicesGetLocalDomainFallbackListForADeviceSettingsPolicyPathParams;
} & FetcherExtraProps;

/**
 * Fetches the list of domains to bypass Gateway DNS resolution from a specified device settings profile. These domains will use the specified local DNS resolver instead.
 */
export const devicesGetLocalDomainFallbackListForADeviceSettingsPolicy = (
  variables: DevicesGetLocalDomainFallbackListForADeviceSettingsPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesFallbackDomainResponseCollection,
    DevicesGetLocalDomainFallbackListForADeviceSettingsPolicyError,
    undefined,
    {},
    {},
    DevicesGetLocalDomainFallbackListForADeviceSettingsPolicyPathParams
  >({ url: '/accounts/{accountId}/devices/policy/{policyId}/fallback_domains', method: 'get', ...variables, signal });

export type DevicesSetLocalDomainFallbackListForADeviceSettingsPolicyPathParams = {
  policyId: Schemas.TeamsDevicesSchemasUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesSetLocalDomainFallbackListForADeviceSettingsPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesFallbackDomainResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesSetLocalDomainFallbackListForADeviceSettingsPolicyRequestBody = Schemas.TeamsDevicesFallbackDomain[];

export type DevicesSetLocalDomainFallbackListForADeviceSettingsPolicyVariables = {
  body?: DevicesSetLocalDomainFallbackListForADeviceSettingsPolicyRequestBody;
  pathParams: DevicesSetLocalDomainFallbackListForADeviceSettingsPolicyPathParams;
} & FetcherExtraProps;

/**
 * Sets the list of domains to bypass Gateway DNS resolution. These domains will use the specified local DNS resolver instead. This will only apply to the specified device settings profile.
 */
export const devicesSetLocalDomainFallbackListForADeviceSettingsPolicy = (
  variables: DevicesSetLocalDomainFallbackListForADeviceSettingsPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesFallbackDomainResponseCollection,
    DevicesSetLocalDomainFallbackListForADeviceSettingsPolicyError,
    DevicesSetLocalDomainFallbackListForADeviceSettingsPolicyRequestBody,
    {},
    {},
    DevicesSetLocalDomainFallbackListForADeviceSettingsPolicyPathParams
  >({ url: '/accounts/{accountId}/devices/policy/{policyId}/fallback_domains', method: 'put', ...variables, signal });

export type DevicesGetSplitTunnelIncludeListForADeviceSettingsPolicyPathParams = {
  policyId: Schemas.TeamsDevicesSchemasUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesGetSplitTunnelIncludeListForADeviceSettingsPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesSplitTunnelIncludeResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesGetSplitTunnelIncludeListForADeviceSettingsPolicyVariables = {
  pathParams: DevicesGetSplitTunnelIncludeListForADeviceSettingsPolicyPathParams;
} & FetcherExtraProps;

/**
 * Fetches the list of routes included in the WARP client's tunnel for a specific device settings profile.
 */
export const devicesGetSplitTunnelIncludeListForADeviceSettingsPolicy = (
  variables: DevicesGetSplitTunnelIncludeListForADeviceSettingsPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesSplitTunnelIncludeResponseCollection,
    DevicesGetSplitTunnelIncludeListForADeviceSettingsPolicyError,
    undefined,
    {},
    {},
    DevicesGetSplitTunnelIncludeListForADeviceSettingsPolicyPathParams
  >({ url: '/accounts/{accountId}/devices/policy/{policyId}/include', method: 'get', ...variables, signal });

export type DevicesSetSplitTunnelIncludeListForADeviceSettingsPolicyPathParams = {
  policyId: Schemas.TeamsDevicesSchemasUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesSetSplitTunnelIncludeListForADeviceSettingsPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesSplitTunnelIncludeResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesSetSplitTunnelIncludeListForADeviceSettingsPolicyRequestBody =
  Schemas.TeamsDevicesSplitTunnelInclude[];

export type DevicesSetSplitTunnelIncludeListForADeviceSettingsPolicyVariables = {
  body?: DevicesSetSplitTunnelIncludeListForADeviceSettingsPolicyRequestBody;
  pathParams: DevicesSetSplitTunnelIncludeListForADeviceSettingsPolicyPathParams;
} & FetcherExtraProps;

/**
 * Sets the list of routes included in the WARP client's tunnel for a specific device settings profile.
 */
export const devicesSetSplitTunnelIncludeListForADeviceSettingsPolicy = (
  variables: DevicesSetSplitTunnelIncludeListForADeviceSettingsPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesSplitTunnelIncludeResponseCollection,
    DevicesSetSplitTunnelIncludeListForADeviceSettingsPolicyError,
    DevicesSetSplitTunnelIncludeListForADeviceSettingsPolicyRequestBody,
    {},
    {},
    DevicesSetSplitTunnelIncludeListForADeviceSettingsPolicyPathParams
  >({ url: '/accounts/{accountId}/devices/policy/{policyId}/include', method: 'put', ...variables, signal });

export type DevicePostureRulesListDevicePostureRulesPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicePostureRulesListDevicePostureRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicePostureRulesListDevicePostureRulesVariables = {
  pathParams: DevicePostureRulesListDevicePostureRulesPathParams;
} & FetcherExtraProps;

/**
 * Fetches device posture rules for a Zero Trust account.
 */
export const devicePostureRulesListDevicePostureRules = (
  variables: DevicePostureRulesListDevicePostureRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesResponseCollection,
    DevicePostureRulesListDevicePostureRulesError,
    undefined,
    {},
    {},
    DevicePostureRulesListDevicePostureRulesPathParams
  >({ url: '/accounts/{accountId}/devices/posture', method: 'get', ...variables, signal });

export type DevicePostureRulesCreateDevicePostureRulePathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicePostureRulesCreateDevicePostureRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesSingleResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicePostureRulesCreateDevicePostureRuleRequestBody = {
  description?: Schemas.TeamsDevicesDescription;
  expiration?: Schemas.TeamsDevicesExpiration;
  input?: Schemas.TeamsDevicesInput;
  match?: Schemas.TeamsDevicesMatch;
  name: Schemas.TeamsDevicesName;
  schedule?: Schemas.TeamsDevicesSchedule;
  type: Schemas.TeamsDevicesType;
};

export type DevicePostureRulesCreateDevicePostureRuleVariables = {
  body: DevicePostureRulesCreateDevicePostureRuleRequestBody;
  pathParams: DevicePostureRulesCreateDevicePostureRulePathParams;
} & FetcherExtraProps;

/**
 * Creates a new device posture rule.
 */
export const devicePostureRulesCreateDevicePostureRule = (
  variables: DevicePostureRulesCreateDevicePostureRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesSingleResponse,
    DevicePostureRulesCreateDevicePostureRuleError,
    DevicePostureRulesCreateDevicePostureRuleRequestBody,
    {},
    {},
    DevicePostureRulesCreateDevicePostureRulePathParams
  >({ url: '/accounts/{accountId}/devices/posture', method: 'post', ...variables, signal });

export type DevicePostureIntegrationsListDevicePostureIntegrationsPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicePostureIntegrationsListDevicePostureIntegrationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesSchemasResponseCollection & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicePostureIntegrationsListDevicePostureIntegrationsVariables = {
  pathParams: DevicePostureIntegrationsListDevicePostureIntegrationsPathParams;
} & FetcherExtraProps;

/**
 * Fetches the list of device posture integrations for an account.
 */
export const devicePostureIntegrationsListDevicePostureIntegrations = (
  variables: DevicePostureIntegrationsListDevicePostureIntegrationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesSchemasResponseCollection,
    DevicePostureIntegrationsListDevicePostureIntegrationsError,
    undefined,
    {},
    {},
    DevicePostureIntegrationsListDevicePostureIntegrationsPathParams
  >({ url: '/accounts/{accountId}/devices/posture/integration', method: 'get', ...variables, signal });

export type DevicePostureIntegrationsCreateDevicePostureIntegrationPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicePostureIntegrationsCreateDevicePostureIntegrationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesSchemasSingleResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicePostureIntegrationsCreateDevicePostureIntegrationRequestBody = {
  config: Schemas.TeamsDevicesConfigRequest;
  interval: Schemas.TeamsDevicesInterval;
  name: Schemas.TeamsDevicesComponentsSchemasName;
  type: Schemas.TeamsDevicesSchemasType;
};

export type DevicePostureIntegrationsCreateDevicePostureIntegrationVariables = {
  body: DevicePostureIntegrationsCreateDevicePostureIntegrationRequestBody;
  pathParams: DevicePostureIntegrationsCreateDevicePostureIntegrationPathParams;
} & FetcherExtraProps;

/**
 * Create a new device posture integration.
 */
export const devicePostureIntegrationsCreateDevicePostureIntegration = (
  variables: DevicePostureIntegrationsCreateDevicePostureIntegrationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesSchemasSingleResponse,
    DevicePostureIntegrationsCreateDevicePostureIntegrationError,
    DevicePostureIntegrationsCreateDevicePostureIntegrationRequestBody,
    {},
    {},
    DevicePostureIntegrationsCreateDevicePostureIntegrationPathParams
  >({ url: '/accounts/{accountId}/devices/posture/integration', method: 'post', ...variables, signal });

export type DevicePostureIntegrationsDeleteDevicePostureIntegrationPathParams = {
  integrationId: Schemas.TeamsDevicesUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicePostureIntegrationsDeleteDevicePostureIntegrationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesSchemasIdResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicePostureIntegrationsDeleteDevicePostureIntegrationVariables = {
  pathParams: DevicePostureIntegrationsDeleteDevicePostureIntegrationPathParams;
} & FetcherExtraProps;

/**
 * Delete a configured device posture integration.
 */
export const devicePostureIntegrationsDeleteDevicePostureIntegration = (
  variables: DevicePostureIntegrationsDeleteDevicePostureIntegrationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesSchemasIdResponse,
    DevicePostureIntegrationsDeleteDevicePostureIntegrationError,
    undefined,
    {},
    {},
    DevicePostureIntegrationsDeleteDevicePostureIntegrationPathParams
  >({
    url: '/accounts/{accountId}/devices/posture/integration/{integrationId}',
    method: 'delete',
    ...variables,
    signal
  });

export type DevicePostureIntegrationsDevicePostureIntegrationDetailsPathParams = {
  integrationId: Schemas.TeamsDevicesUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicePostureIntegrationsDevicePostureIntegrationDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesSchemasSingleResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicePostureIntegrationsDevicePostureIntegrationDetailsVariables = {
  pathParams: DevicePostureIntegrationsDevicePostureIntegrationDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetches details for a single device posture integration.
 */
export const devicePostureIntegrationsDevicePostureIntegrationDetails = (
  variables: DevicePostureIntegrationsDevicePostureIntegrationDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesSchemasSingleResponse,
    DevicePostureIntegrationsDevicePostureIntegrationDetailsError,
    undefined,
    {},
    {},
    DevicePostureIntegrationsDevicePostureIntegrationDetailsPathParams
  >({ url: '/accounts/{accountId}/devices/posture/integration/{integrationId}', method: 'get', ...variables, signal });

export type DevicePostureIntegrationsUpdateDevicePostureIntegrationPathParams = {
  integrationId: Schemas.TeamsDevicesUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicePostureIntegrationsUpdateDevicePostureIntegrationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesSchemasSingleResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicePostureIntegrationsUpdateDevicePostureIntegrationRequestBody = {
  config?: Schemas.TeamsDevicesConfigRequest;
  interval?: Schemas.TeamsDevicesInterval;
  name?: Schemas.TeamsDevicesComponentsSchemasName;
  type?: Schemas.TeamsDevicesSchemasType;
};

export type DevicePostureIntegrationsUpdateDevicePostureIntegrationVariables = {
  body?: DevicePostureIntegrationsUpdateDevicePostureIntegrationRequestBody;
  pathParams: DevicePostureIntegrationsUpdateDevicePostureIntegrationPathParams;
} & FetcherExtraProps;

/**
 * Updates a configured device posture integration.
 */
export const devicePostureIntegrationsUpdateDevicePostureIntegration = (
  variables: DevicePostureIntegrationsUpdateDevicePostureIntegrationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesSchemasSingleResponse,
    DevicePostureIntegrationsUpdateDevicePostureIntegrationError,
    DevicePostureIntegrationsUpdateDevicePostureIntegrationRequestBody,
    {},
    {},
    DevicePostureIntegrationsUpdateDevicePostureIntegrationPathParams
  >({
    url: '/accounts/{accountId}/devices/posture/integration/{integrationId}',
    method: 'patch',
    ...variables,
    signal
  });

export type DevicePostureRulesDeleteDevicePostureRulePathParams = {
  ruleId: Schemas.TeamsDevicesUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicePostureRulesDeleteDevicePostureRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesIdResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicePostureRulesDeleteDevicePostureRuleVariables = {
  pathParams: DevicePostureRulesDeleteDevicePostureRulePathParams;
} & FetcherExtraProps;

/**
 * Deletes a device posture rule.
 */
export const devicePostureRulesDeleteDevicePostureRule = (
  variables: DevicePostureRulesDeleteDevicePostureRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesIdResponse,
    DevicePostureRulesDeleteDevicePostureRuleError,
    undefined,
    {},
    {},
    DevicePostureRulesDeleteDevicePostureRulePathParams
  >({ url: '/accounts/{accountId}/devices/posture/{ruleId}', method: 'delete', ...variables, signal });

export type DevicePostureRulesDevicePostureRulesDetailsPathParams = {
  ruleId: Schemas.TeamsDevicesUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicePostureRulesDevicePostureRulesDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesSingleResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicePostureRulesDevicePostureRulesDetailsVariables = {
  pathParams: DevicePostureRulesDevicePostureRulesDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetches a single device posture rule.
 */
export const devicePostureRulesDevicePostureRulesDetails = (
  variables: DevicePostureRulesDevicePostureRulesDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesSingleResponse,
    DevicePostureRulesDevicePostureRulesDetailsError,
    undefined,
    {},
    {},
    DevicePostureRulesDevicePostureRulesDetailsPathParams
  >({ url: '/accounts/{accountId}/devices/posture/{ruleId}', method: 'get', ...variables, signal });

export type DevicePostureRulesUpdateDevicePostureRulePathParams = {
  ruleId: Schemas.TeamsDevicesUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicePostureRulesUpdateDevicePostureRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesSingleResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicePostureRulesUpdateDevicePostureRuleRequestBody = {
  description?: Schemas.TeamsDevicesDescription;
  expiration?: Schemas.TeamsDevicesExpiration;
  input?: Schemas.TeamsDevicesInput;
  match?: Schemas.TeamsDevicesMatch;
  name: Schemas.TeamsDevicesName;
  schedule?: Schemas.TeamsDevicesSchedule;
  type: Schemas.TeamsDevicesType;
};

export type DevicePostureRulesUpdateDevicePostureRuleVariables = {
  body: DevicePostureRulesUpdateDevicePostureRuleRequestBody;
  pathParams: DevicePostureRulesUpdateDevicePostureRulePathParams;
} & FetcherExtraProps;

/**
 * Updates a device posture rule.
 */
export const devicePostureRulesUpdateDevicePostureRule = (
  variables: DevicePostureRulesUpdateDevicePostureRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesSingleResponse,
    DevicePostureRulesUpdateDevicePostureRuleError,
    DevicePostureRulesUpdateDevicePostureRuleRequestBody,
    {},
    {},
    DevicePostureRulesUpdateDevicePostureRulePathParams
  >({ url: '/accounts/{accountId}/devices/posture/{ruleId}', method: 'put', ...variables, signal });

export type DevicesRevokeDevicesPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesRevokeDevicesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesApiResponseSingle & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesRevokeDevicesVariables = {
  body?: Schemas.TeamsDevicesRevokeDevicesRequest;
  pathParams: DevicesRevokeDevicesPathParams;
} & FetcherExtraProps;

/**
 * Revokes a list of devices.
 */
export const devicesRevokeDevices = (variables: DevicesRevokeDevicesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.TeamsDevicesApiResponseSingle,
    DevicesRevokeDevicesError,
    Schemas.TeamsDevicesRevokeDevicesRequest,
    {},
    {},
    DevicesRevokeDevicesPathParams
  >({ url: '/accounts/{accountId}/devices/revoke', method: 'post', ...variables, signal });

export type ZeroTrustAccountsGetDeviceSettingsForZeroTrustAccountPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type ZeroTrustAccountsGetDeviceSettingsForZeroTrustAccountError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesZeroTrustAccountDeviceSettingsResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type ZeroTrustAccountsGetDeviceSettingsForZeroTrustAccountVariables = {
  pathParams: ZeroTrustAccountsGetDeviceSettingsForZeroTrustAccountPathParams;
} & FetcherExtraProps;

/**
 * Describes the current device settings for a Zero Trust account.
 */
export const zeroTrustAccountsGetDeviceSettingsForZeroTrustAccount = (
  variables: ZeroTrustAccountsGetDeviceSettingsForZeroTrustAccountVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesZeroTrustAccountDeviceSettingsResponse,
    ZeroTrustAccountsGetDeviceSettingsForZeroTrustAccountError,
    undefined,
    {},
    {},
    ZeroTrustAccountsGetDeviceSettingsForZeroTrustAccountPathParams
  >({ url: '/accounts/{accountId}/devices/settings', method: 'get', ...variables, signal });

export type ZeroTrustAccountsPatchDeviceSettingsForTheZeroTrustAccountPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type ZeroTrustAccountsPatchDeviceSettingsForTheZeroTrustAccountError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesZeroTrustAccountDeviceSettingsResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type ZeroTrustAccountsPatchDeviceSettingsForTheZeroTrustAccountVariables = {
  body?: Schemas.TeamsDevicesZeroTrustAccountDeviceSettings;
  pathParams: ZeroTrustAccountsPatchDeviceSettingsForTheZeroTrustAccountPathParams;
} & FetcherExtraProps;

/**
 * Patches the current device settings for a Zero Trust account.
 */
export const zeroTrustAccountsPatchDeviceSettingsForTheZeroTrustAccount = (
  variables: ZeroTrustAccountsPatchDeviceSettingsForTheZeroTrustAccountVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesZeroTrustAccountDeviceSettingsResponse,
    ZeroTrustAccountsPatchDeviceSettingsForTheZeroTrustAccountError,
    Schemas.TeamsDevicesZeroTrustAccountDeviceSettings,
    {},
    {},
    ZeroTrustAccountsPatchDeviceSettingsForTheZeroTrustAccountPathParams
  >({ url: '/accounts/{accountId}/devices/settings', method: 'patch', ...variables, signal });

export type ZeroTrustAccountsUpdateDeviceSettingsForTheZeroTrustAccountPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type ZeroTrustAccountsUpdateDeviceSettingsForTheZeroTrustAccountError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesZeroTrustAccountDeviceSettingsResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type ZeroTrustAccountsUpdateDeviceSettingsForTheZeroTrustAccountVariables = {
  body?: Schemas.TeamsDevicesZeroTrustAccountDeviceSettings;
  pathParams: ZeroTrustAccountsUpdateDeviceSettingsForTheZeroTrustAccountPathParams;
} & FetcherExtraProps;

/**
 * Updates the current device settings for a Zero Trust account.
 */
export const zeroTrustAccountsUpdateDeviceSettingsForTheZeroTrustAccount = (
  variables: ZeroTrustAccountsUpdateDeviceSettingsForTheZeroTrustAccountVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesZeroTrustAccountDeviceSettingsResponse,
    ZeroTrustAccountsUpdateDeviceSettingsForTheZeroTrustAccountError,
    Schemas.TeamsDevicesZeroTrustAccountDeviceSettings,
    {},
    {},
    ZeroTrustAccountsUpdateDeviceSettingsForTheZeroTrustAccountPathParams
  >({ url: '/accounts/{accountId}/devices/settings', method: 'put', ...variables, signal });

export type DevicesUnrevokeDevicesPathParams = {
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesUnrevokeDevicesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesApiResponseSingle & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesUnrevokeDevicesVariables = {
  body?: Schemas.TeamsDevicesUnrevokeDevicesRequest;
  pathParams: DevicesUnrevokeDevicesPathParams;
} & FetcherExtraProps;

/**
 * Unrevokes a list of devices.
 */
export const devicesUnrevokeDevices = (variables: DevicesUnrevokeDevicesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.TeamsDevicesApiResponseSingle,
    DevicesUnrevokeDevicesError,
    Schemas.TeamsDevicesUnrevokeDevicesRequest,
    {},
    {},
    DevicesUnrevokeDevicesPathParams
  >({ url: '/accounts/{accountId}/devices/unrevoke', method: 'post', ...variables, signal });

export type DevicesDeviceDetailsPathParams = {
  deviceId: Schemas.TeamsDevicesSchemasUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesDeviceDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesDeviceResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesDeviceDetailsVariables = {
  pathParams: DevicesDeviceDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetches details for a single device.
 */
export const devicesDeviceDetails = (variables: DevicesDeviceDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.TeamsDevicesDeviceResponse,
    DevicesDeviceDetailsError,
    undefined,
    {},
    {},
    DevicesDeviceDetailsPathParams
  >({ url: '/accounts/{accountId}/devices/{deviceId}', method: 'get', ...variables, signal });

export type DevicesListAdminOverrideCodeForDevicePathParams = {
  deviceId: Schemas.TeamsDevicesSchemasUuid;
  accountId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesListAdminOverrideCodeForDeviceError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesOverrideCodesResponse & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesListAdminOverrideCodeForDeviceVariables = {
  pathParams: DevicesListAdminOverrideCodeForDevicePathParams;
} & FetcherExtraProps;

/**
 * Fetches a one-time use admin override code for a device. This relies on the **Admin Override** setting being enabled in your device configuration.
 */
export const devicesListAdminOverrideCodeForDevice = (
  variables: DevicesListAdminOverrideCodeForDeviceVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesOverrideCodesResponse,
    DevicesListAdminOverrideCodeForDeviceError,
    undefined,
    {},
    {},
    DevicesListAdminOverrideCodeForDevicePathParams
  >({ url: '/accounts/{accountId}/devices/{deviceId}/override_codes', method: 'get', ...variables, signal });

export type DexEndpointsListColosPathParams = {
  /**
   * unique identifier linked to an account in the API request path.
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
};

export type DexEndpointsListColosQueryParams = {
  /**
   * Start time for connection period in ISO (RFC3339 - ISO 8601) format
   *
   * @example 2023-08-20T20:45:00Z
   */
  from: string;
  /**
   * End time for connection period in ISO (RFC3339 - ISO 8601) format
   *
   * @example 2023-08-24T20:45:00Z
   */
  to: string;
  /**
   * Type of usage that colos should be sorted by. If unspecified, returns all Cloudflare colos sorted alphabetically.
   */
  sortBy?: 'fleet-status-usage' | 'application-tests-usage';
};

export type DexEndpointsListColosError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type DexEndpointsListColosResponse = Schemas.DigitalExperienceMonitoringApiResponseCollection & {
  result?: Schemas.DigitalExperienceMonitoringColosResponse;
};

export type DexEndpointsListColosVariables = {
  pathParams: DexEndpointsListColosPathParams;
  queryParams: DexEndpointsListColosQueryParams;
} & FetcherExtraProps;

/**
 * List Cloudflare colos that account's devices were connected to during a time period, sorted by usage starting from the most used colo. Colos without traffic are also returned and sorted alphabetically.
 */
export const dexEndpointsListColos = (variables: DexEndpointsListColosVariables, signal?: AbortSignal) =>
  fetch<
    DexEndpointsListColosResponse,
    DexEndpointsListColosError,
    undefined,
    {},
    DexEndpointsListColosQueryParams,
    DexEndpointsListColosPathParams
  >({ url: '/accounts/{accountId}/dex/colos', method: 'get', ...variables, signal });

export type GetCommandsPathParams = {
  /**
   * unique identifier linked to an account in the API request path
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
};

export type GetCommandsQueryParams = {
  /**
   * Page number for pagination
   *
   * @example 1
   */
  page: number;
  /**
   * Number of results per page
   *
   * @example 50
   */
  per_page: number;
  /**
   * Start time for the query in ISO (RFC3339 - ISO 8601) format
   *
   * @example 2023-08-20T20:45:00Z
   * @format date-time
   */
  from?: string;
  /**
   * End time for the query in ISO (RFC3339 - ISO 8601) format
   *
   * @example 2023-08-24T20:45:00Z
   * @format date-time
   */
  to?: string;
  /**
   * Unique identifier for a device
   */
  device_id?: string;
  /**
   * Email tied to the device
   */
  user_email?: string;
  /**
   * Optionally filter executed commands by command type
   */
  command_type?: string;
  /**
   * Optionally filter executed commands by status
   */
  status?: 'PENDING_EXEC' | 'PENDING_UPLOAD' | 'SUCCESS' | 'FAILED';
};

export type GetCommandsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type GetCommandsResponse = Schemas.DigitalExperienceMonitoringApiResponseCollection & {
  result?: Schemas.DigitalExperienceMonitoringGetCommandsResponse;
};

export type GetCommandsVariables = {
  pathParams: GetCommandsPathParams;
  queryParams: GetCommandsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a paginated list of commands issued to devices under the specified account, optionally filtered by time range, device, or other parameters
 */
export const getCommands = (variables: GetCommandsVariables, signal?: AbortSignal) =>
  fetch<GetCommandsResponse, GetCommandsError, undefined, {}, GetCommandsQueryParams, GetCommandsPathParams>({
    url: '/accounts/{accountId}/dex/commands',
    method: 'get',
    ...variables,
    signal
  });

export type PostCommandsPathParams = {
  /**
   * unique identifier linked to an account in the API request path
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
};

export type PostCommandsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type PostCommandsResponse = Schemas.DigitalExperienceMonitoringApiResponseCollection & {
  result?: Schemas.DigitalExperienceMonitoringPostCommandsResponse;
};

export type PostCommandsRequestBody = {
  /**
   * List of device-level commands to execute
   *
   * @maxItems 20
   */
  commands: {
    command_args?: {
      /**
       * List of interfaces to capture packets on
       */
      interfaces?: ('default' | 'tunnel')[];
      /**
       * Maximum file size (in MB) for the capture file. Specifies the maximum file size of the warp-diag zip artifact that can be uploaded. If the zip artifact exceeds the specified max file size, it will NOT be uploaded
       *
       * @default 5
       * @minimum 1
       */
      ['max-file-size-mb']?: number;
      /**
       * Maximum number of bytes to save for each packet
       *
       * @default 160
       * @minimum 1
       */
      ['packet-size-bytes']?: number;
      /**
       * Test an IP address from all included or excluded ranges. Tests an IP address from all included or excluded ranges. Essentially the same as running 'route get <ip>'' and collecting the results. This option may increase the time taken to collect the warp-diag
       *
       * @default true
       */
      ['test-all-routes']?: boolean;
      /**
       * Limit on capture duration (in minutes)
       *
       * @default 5
       * @minimum 1
       */
      ['time-limit-min']?: number;
    };
    /**
     * Type of command to execute on the device
     */
    command_type: 'pcap' | 'warp-diag';
    /**
     * Unique identifier for the device
     */
    device_id: string;
    /**
     * Email tied to the device
     */
    user_email: string;
  }[];
};

export type PostCommandsVariables = {
  body: PostCommandsRequestBody;
  pathParams: PostCommandsPathParams;
} & FetcherExtraProps;

/**
 * Initiate commands for up to 10 devices per account
 */
export const postCommands = (variables: PostCommandsVariables, signal?: AbortSignal) =>
  fetch<PostCommandsResponse, PostCommandsError, PostCommandsRequestBody, {}, {}, PostCommandsPathParams>({
    url: '/accounts/{accountId}/dex/commands',
    method: 'post',
    ...variables,
    signal
  });

export type GetCommandsEligibleDevicesPathParams = {
  /**
   * unique identifier linked to an account in the API request path
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
};

export type GetCommandsEligibleDevicesQueryParams = {
  /**
   * Page number of paginated results
   *
   * @minimum 1
   */
  page: number;
  /**
   * Number of items per page
   *
   * @maximum 50
   * @minimum 1
   */
  per_page: number;
  /**
   * Filter devices by name or email
   */
  search?: string;
};

export type GetCommandsEligibleDevicesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type GetCommandsEligibleDevicesResponse = Schemas.DigitalExperienceMonitoringApiResponseCollection & {
  result?: Schemas.DigitalExperienceMonitoringCommandsDevicesResponse;
};

export type GetCommandsEligibleDevicesVariables = {
  pathParams: GetCommandsEligibleDevicesPathParams;
  queryParams: GetCommandsEligibleDevicesQueryParams;
} & FetcherExtraProps;

/**
 * List devices with WARP client support for remote captures which have been connected in the last 1 hour.
 */
export const getCommandsEligibleDevices = (variables: GetCommandsEligibleDevicesVariables, signal?: AbortSignal) =>
  fetch<
    GetCommandsEligibleDevicesResponse,
    GetCommandsEligibleDevicesError,
    undefined,
    {},
    GetCommandsEligibleDevicesQueryParams,
    GetCommandsEligibleDevicesPathParams
  >({ url: '/accounts/{accountId}/dex/commands/devices', method: 'get', ...variables, signal });

export type GetCommandsQuotaPathParams = {
  /**
   * unique identifier linked to an account in the API request path
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
};

export type GetCommandsQuotaError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type GetCommandsQuotaResponse = Schemas.DigitalExperienceMonitoringApiResponseCollection & {
  result?: Schemas.DigitalExperienceMonitoringGetCommandsQuotaResponse;
};

export type GetCommandsQuotaVariables = {
  pathParams: GetCommandsQuotaPathParams;
} & FetcherExtraProps;

/**
 * Retrieves the current quota usage and limits for device commands within a specific account, including the time when the quota will reset
 */
export const getCommandsQuota = (variables: GetCommandsQuotaVariables, signal?: AbortSignal) =>
  fetch<GetCommandsQuotaResponse, GetCommandsQuotaError, undefined, {}, {}, GetCommandsQuotaPathParams>({
    url: '/accounts/{accountId}/dex/commands/quota',
    method: 'get',
    ...variables,
    signal
  });

export type GetCommandsEligibleUsersPathParams = {
  /**
   * unique identifier linked to an account in the API request path
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
};

export type GetCommandsEligibleUsersQueryParams = {
  /**
   * filter user emails by search
   */
  search?: string;
};

export type GetCommandsEligibleUsersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type GetCommandsEligibleUsersResponse = Schemas.DigitalExperienceMonitoringApiResponseCollection & {
  result?: Schemas.DigitalExperienceMonitoringCommandsUsersResponse;
};

export type GetCommandsEligibleUsersVariables = {
  pathParams: GetCommandsEligibleUsersPathParams;
  queryParams?: GetCommandsEligibleUsersQueryParams;
} & FetcherExtraProps;

/**
 * List users emails associated with devices with WARP client support for remote captures which have been connected in the last 1 hour.
 */
export const getCommandsEligibleUsers = (variables: GetCommandsEligibleUsersVariables, signal?: AbortSignal) =>
  fetch<
    GetCommandsEligibleUsersResponse,
    GetCommandsEligibleUsersError,
    undefined,
    {},
    GetCommandsEligibleUsersQueryParams,
    GetCommandsEligibleUsersPathParams
  >({ url: '/accounts/{accountId}/dex/commands/users', method: 'get', ...variables, signal });

export type GetCommandsCommandIdDownloadsFilenamePathParams = {
  /**
   * unique identifier linked to an account in the API request path
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
  /**
   * Unique identifier for command
   */
  commandId: Schemas.DigitalExperienceMonitoringCommandId;
  /**
   * The name of the file to be downloaded, including the `.zip` extension
   */
  filename: string;
};

export type GetCommandsCommandIdDownloadsFilenameError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type GetCommandsCommandIdDownloadsFilenameVariables = {
  pathParams: GetCommandsCommandIdDownloadsFilenamePathParams;
} & FetcherExtraProps;

/**
 * Downloads artifacts for an executed command. Bulk downloads are not supported
 */
export const getCommandsCommandIdDownloadsFilename = (
  variables: GetCommandsCommandIdDownloadsFilenameVariables,
  signal?: AbortSignal
) =>
  fetch<
    undefined,
    GetCommandsCommandIdDownloadsFilenameError,
    undefined,
    {},
    {},
    GetCommandsCommandIdDownloadsFilenamePathParams
  >({
    url: '/accounts/{accountId}/dex/commands/{commandId}/downloads/{filename}',
    method: 'get',
    ...variables,
    signal
  });

export type DevicesLiveStatusPathParams = {
  /**
   * Unique identifier for account
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
  /**
   * Unique identifier for device
   */
  deviceId: Schemas.DigitalExperienceMonitoringDeviceId;
};

export type DevicesLiveStatusQueryParams = {
  /**
   * Number of minutes before current time
   */
  since_minutes: Schemas.DigitalExperienceMonitoringSinceMinutes;
  /**
   * Number of minutes before current time
   */
  time_now?: Schemas.DigitalExperienceMonitoringTimeNow;
  /**
   * List of data centers to filter results
   */
  colo?: Schemas.DigitalExperienceMonitoringColo;
};

export type DevicesLiveStatusError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseSingle &
    Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type DevicesLiveStatusVariables = {
  pathParams: DevicesLiveStatusPathParams;
  queryParams: DevicesLiveStatusQueryParams;
} & FetcherExtraProps;

/**
 * Get the live status of a latest device given device_id from the device_state table
 */
export const devicesLiveStatus = (variables: DevicesLiveStatusVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.DigitalExperienceMonitoringDevice,
    DevicesLiveStatusError,
    undefined,
    {},
    DevicesLiveStatusQueryParams,
    DevicesLiveStatusPathParams
  >({ url: '/accounts/{accountId}/dex/devices/{deviceId}/fleet-status/live', method: 'get', ...variables, signal });

export type DexFleetStatusDevicesPathParams = {
  /**
   * Unique identifier for account
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
};

export type DexFleetStatusDevicesQueryParams = {
  /**
   * Time range end in ISO format
   */
  to: Schemas.DigitalExperienceMonitoringTimestamp;
  /**
   * Time range beginning in ISO format
   */
  from: Schemas.DigitalExperienceMonitoringTimestamp;
  /**
   * Page number
   */
  page: Schemas.DigitalExperienceMonitoringPage;
  /**
   * Number of results per page
   */
  per_page: Schemas.DigitalExperienceMonitoringPerPage;
  /**
   * Dimension to sort results by
   */
  sort_by?: Schemas.DigitalExperienceMonitoringSortBy;
  /**
   * Cloudflare colo
   */
  colo?: Schemas.DigitalExperienceMonitoringColo;
  /**
   * Device-specific ID, given as UUID v4
   */
  device_id?: Schemas.DigitalExperienceMonitoringDeviceId;
  /**
   * The mode under which the WARP client is run
   */
  mode?: Schemas.DigitalExperienceMonitoringMode;
  /**
   * Network status
   */
  status?: Schemas.DigitalExperienceMonitoringStatus;
  /**
   * Operating system
   */
  platform?: Schemas.DigitalExperienceMonitoringPlatform;
  /**
   * WARP client version
   */
  version?: Schemas.DigitalExperienceMonitoringVersion;
  /**
   * Source:
   *   * `hourly` - device details aggregated hourly, up to 7 days prior
   *   * `last_seen` - device details, up to 24 hours prior
   *   * `raw` - device details, up to 7 days prior
   */
  source?: Schemas.DigitalExperienceMonitoringSource;
};

export type DexFleetStatusDevicesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseSingle &
    Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type DexFleetStatusDevicesVariables = {
  pathParams: DexFleetStatusDevicesPathParams;
  queryParams: DexFleetStatusDevicesQueryParams;
} & FetcherExtraProps;

/**
 * List details for devices using WARP
 */
export const dexFleetStatusDevices = (variables: DexFleetStatusDevicesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.DigitalExperienceMonitoringFleetStatusDevicesResponse,
    DexFleetStatusDevicesError,
    undefined,
    {},
    DexFleetStatusDevicesQueryParams,
    DexFleetStatusDevicesPathParams
  >({ url: '/accounts/{accountId}/dex/fleet-status/devices', method: 'get', ...variables, signal });

export type DexFleetStatusLivePathParams = {
  /**
   * Unique identifier for account
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
};

export type DexFleetStatusLiveQueryParams = {
  /**
   * Number of minutes before current time
   */
  since_minutes: Schemas.DigitalExperienceMonitoringSinceMinutes;
};

export type DexFleetStatusLiveError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseSingle &
    Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type DexFleetStatusLiveVariables = {
  pathParams: DexFleetStatusLivePathParams;
  queryParams: DexFleetStatusLiveQueryParams;
} & FetcherExtraProps;

/**
 * List details for live (up to 60 minutes) devices using WARP
 */
export const dexFleetStatusLive = (variables: DexFleetStatusLiveVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.DigitalExperienceMonitoringFleetStatusLiveResponse,
    DexFleetStatusLiveError,
    undefined,
    {},
    DexFleetStatusLiveQueryParams,
    DexFleetStatusLivePathParams
  >({ url: '/accounts/{accountId}/dex/fleet-status/live', method: 'get', ...variables, signal });

export type DexFleetStatusOverTimePathParams = {
  /**
   * Unique identifier for account
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
};

export type DexFleetStatusOverTimeQueryParams = {
  /**
   * Time range end in ISO format
   */
  to: Schemas.DigitalExperienceMonitoringTimestamp;
  /**
   * Time range beginning in ISO format
   */
  from: Schemas.DigitalExperienceMonitoringTimestamp;
  /**
   * Cloudflare colo
   */
  colo?: Schemas.DigitalExperienceMonitoringColo;
  /**
   * Device-specific ID, given as UUID v4
   */
  device_id?: Schemas.DigitalExperienceMonitoringDeviceId;
};

export type DexFleetStatusOverTimeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseSingle &
    Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type DexFleetStatusOverTimeVariables = {
  pathParams: DexFleetStatusOverTimePathParams;
  queryParams: DexFleetStatusOverTimeQueryParams;
} & FetcherExtraProps;

/**
 * List details for devices using WARP, up to 7 days
 */
export const dexFleetStatusOverTime = (variables: DexFleetStatusOverTimeVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    DexFleetStatusOverTimeError,
    undefined,
    {},
    DexFleetStatusOverTimeQueryParams,
    DexFleetStatusOverTimePathParams
  >({ url: '/accounts/{accountId}/dex/fleet-status/over-time', method: 'get', ...variables, signal });

export type DexEndpointsHttpTestDetailsPathParams = {
  /**
   * unique identifier linked to an account in the API request path.
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
  /**
   * unique identifier for a specific test
   */
  testId: Schemas.DigitalExperienceMonitoringUuid;
};

export type DexEndpointsHttpTestDetailsQueryParams = {
  /**
   * Optionally filter result stats to a specific device(s). Cannot be used in combination with colo param.
   */
  deviceId?: string[];
  /**
   * Start time for aggregate metrics in ISO ms
   *
   * @example 1689520412000
   */
  from: string;
  /**
   * End time for aggregate metrics in ISO ms
   *
   * @example 1689606812000
   */
  to: string;
  /**
   * Time interval for aggregate time slots.
   */
  interval: 'minute' | 'hour';
  /**
   * Optionally filter result stats to a Cloudflare colo. Cannot be used in combination with deviceId param.
   */
  colo?: string;
};

export type DexEndpointsHttpTestDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type DexEndpointsHttpTestDetailsResponse = Schemas.DigitalExperienceMonitoringApiResponseSingle & {
  result?: Schemas.DigitalExperienceMonitoringHttpDetailsResponse;
};

export type DexEndpointsHttpTestDetailsVariables = {
  pathParams: DexEndpointsHttpTestDetailsPathParams;
  queryParams: DexEndpointsHttpTestDetailsQueryParams;
} & FetcherExtraProps;

/**
 * Get test details and aggregate performance metrics for an http test for a given time period between 1 hour and 7 days.
 */
export const dexEndpointsHttpTestDetails = (variables: DexEndpointsHttpTestDetailsVariables, signal?: AbortSignal) =>
  fetch<
    DexEndpointsHttpTestDetailsResponse,
    DexEndpointsHttpTestDetailsError,
    undefined,
    {},
    DexEndpointsHttpTestDetailsQueryParams,
    DexEndpointsHttpTestDetailsPathParams
  >({ url: '/accounts/{accountId}/dex/http-tests/{testId}', method: 'get', ...variables, signal });

export type DexEndpointsHttpTestPercentilesPathParams = {
  /**
   * unique identifier linked to an account in the API request path.
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
  /**
   * unique identifier for a specific test
   */
  testId: Schemas.DigitalExperienceMonitoringUuid;
};

export type DexEndpointsHttpTestPercentilesQueryParams = {
  /**
   * Optionally filter result stats to a specific device(s). Cannot be used in combination with colo param.
   */
  deviceId?: string[];
  /**
   * Start time for the query in ISO (RFC3339 - ISO 8601) format
   *
   * @example 2023-09-20T17:00:00Z
   */
  from: string;
  /**
   * End time for the query in ISO (RFC3339 - ISO 8601) format
   *
   * @example 2023-09-20T17:00:00Z
   */
  to: string;
  /**
   * Optionally filter result stats to a Cloudflare colo. Cannot be used in combination with deviceId param.
   */
  colo?: string;
};

export type DexEndpointsHttpTestPercentilesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type DexEndpointsHttpTestPercentilesResponse = Schemas.DigitalExperienceMonitoringApiResponseSingle & {
  result?: Schemas.DigitalExperienceMonitoringHttpDetailsPercentilesResponse;
};

export type DexEndpointsHttpTestPercentilesVariables = {
  pathParams: DexEndpointsHttpTestPercentilesPathParams;
  queryParams: DexEndpointsHttpTestPercentilesQueryParams;
} & FetcherExtraProps;

/**
 * Get percentiles for an http test for a given time period between 1 hour and 7 days.
 */
export const dexEndpointsHttpTestPercentiles = (
  variables: DexEndpointsHttpTestPercentilesVariables,
  signal?: AbortSignal
) =>
  fetch<
    DexEndpointsHttpTestPercentilesResponse,
    DexEndpointsHttpTestPercentilesError,
    undefined,
    {},
    DexEndpointsHttpTestPercentilesQueryParams,
    DexEndpointsHttpTestPercentilesPathParams
  >({ url: '/accounts/{accountId}/dex/http-tests/{testId}/percentiles', method: 'get', ...variables, signal });

export type DexEndpointsListTestsOverviewPathParams = {
  /**
   * unique identifier linked to an account in the API request path.
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
};

export type DexEndpointsListTestsOverviewQueryParams = {
  /**
   * Optionally filter result stats to a Cloudflare colo. Cannot be used in combination with deviceId param.
   */
  colo?: string;
  /**
   * Optionally filter results by test name
   */
  testName?: string;
  /**
   * Optionally filter result stats to a specific device(s). Cannot be used in combination with colo param.
   */
  deviceId?: string[];
  /**
   * Page number of paginated results
   *
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * Number of items per page
   *
   * @default 10
   * @maximum 50
   * @minimum 1
   */
  per_page?: number;
};

export type DexEndpointsListTestsOverviewError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type DexEndpointsListTestsOverviewResponse = Schemas.DigitalExperienceMonitoringApiResponseSingle & {
  result?: Schemas.DigitalExperienceMonitoringTestsResponse;
  result_info?: Schemas.DigitalExperienceMonitoringResultInfo;
};

export type DexEndpointsListTestsOverviewVariables = {
  pathParams: DexEndpointsListTestsOverviewPathParams;
  queryParams?: DexEndpointsListTestsOverviewQueryParams;
} & FetcherExtraProps;

/**
 * List DEX tests with overview metrics
 */
export const dexEndpointsListTestsOverview = (
  variables: DexEndpointsListTestsOverviewVariables,
  signal?: AbortSignal
) =>
  fetch<
    DexEndpointsListTestsOverviewResponse,
    DexEndpointsListTestsOverviewError,
    undefined,
    {},
    DexEndpointsListTestsOverviewQueryParams,
    DexEndpointsListTestsOverviewPathParams
  >({ url: '/accounts/{accountId}/dex/tests/overview', method: 'get', ...variables, signal });

export type DexEndpointsTestsUniqueDevicesPathParams = {
  /**
   * unique identifier linked to an account in the API request path.
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
};

export type DexEndpointsTestsUniqueDevicesQueryParams = {
  /**
   * Optionally filter results by test name
   */
  testName?: string;
  /**
   * Optionally filter result stats to a specific device(s). Cannot be used in combination with colo param.
   */
  deviceId?: string[];
};

export type DexEndpointsTestsUniqueDevicesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type DexEndpointsTestsUniqueDevicesResponse = Schemas.DigitalExperienceMonitoringApiResponseSingle & {
  result?: Schemas.DigitalExperienceMonitoringUniqueDevicesResponse;
};

export type DexEndpointsTestsUniqueDevicesVariables = {
  pathParams: DexEndpointsTestsUniqueDevicesPathParams;
  queryParams?: DexEndpointsTestsUniqueDevicesQueryParams;
} & FetcherExtraProps;

/**
 * Returns unique count of devices that have run synthetic application monitoring tests in the past 7 days.
 */
export const dexEndpointsTestsUniqueDevices = (
  variables: DexEndpointsTestsUniqueDevicesVariables,
  signal?: AbortSignal
) =>
  fetch<
    DexEndpointsTestsUniqueDevicesResponse,
    DexEndpointsTestsUniqueDevicesError,
    undefined,
    {},
    DexEndpointsTestsUniqueDevicesQueryParams,
    DexEndpointsTestsUniqueDevicesPathParams
  >({ url: '/accounts/{accountId}/dex/tests/unique-devices', method: 'get', ...variables, signal });

export type DexEndpointsTracerouteTestResultNetworkPathPathParams = {
  /**
   * unique identifier linked to an account
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
  /**
   * unique identifier for a specific traceroute test
   */
  testResultId: Schemas.DigitalExperienceMonitoringUuid;
};

export type DexEndpointsTracerouteTestResultNetworkPathError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type DexEndpointsTracerouteTestResultNetworkPathResponse =
  Schemas.DigitalExperienceMonitoringApiResponseSingle & {
    result?: Schemas.DigitalExperienceMonitoringTracerouteTestResultNetworkPathResponse;
  };

export type DexEndpointsTracerouteTestResultNetworkPathVariables = {
  pathParams: DexEndpointsTracerouteTestResultNetworkPathPathParams;
} & FetcherExtraProps;

/**
 * Get a breakdown of hops and performance metrics for a specific traceroute test run
 */
export const dexEndpointsTracerouteTestResultNetworkPath = (
  variables: DexEndpointsTracerouteTestResultNetworkPathVariables,
  signal?: AbortSignal
) =>
  fetch<
    DexEndpointsTracerouteTestResultNetworkPathResponse,
    DexEndpointsTracerouteTestResultNetworkPathError,
    undefined,
    {},
    {},
    DexEndpointsTracerouteTestResultNetworkPathPathParams
  >({
    url: '/accounts/{accountId}/dex/traceroute-test-results/{testResultId}/network-path',
    method: 'get',
    ...variables,
    signal
  });

export type DexEndpointsTracerouteTestDetailsPathParams = {
  /**
   * Unique identifier linked to an account
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
  /**
   * Unique identifier for a specific test
   */
  testId: Schemas.DigitalExperienceMonitoringUuid;
};

export type DexEndpointsTracerouteTestDetailsQueryParams = {
  /**
   * Optionally filter result stats to a specific device(s). Cannot be used in combination with colo param.
   */
  deviceId?: string[];
  /**
   * Start time for aggregate metrics in ISO ms
   *
   * @example 1689520412000
   */
  from: string;
  /**
   * End time for aggregate metrics in ISO ms
   *
   * @example 1689606812000
   */
  to: string;
  /**
   * Time interval for aggregate time slots.
   */
  interval: 'minute' | 'hour';
  /**
   * Optionally filter result stats to a Cloudflare colo. Cannot be used in combination with deviceId param.
   */
  colo?: string;
};

export type DexEndpointsTracerouteTestDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type DexEndpointsTracerouteTestDetailsResponse = Schemas.DigitalExperienceMonitoringApiResponseSingle & {
  result?: Schemas.DigitalExperienceMonitoringTracerouteDetailsResponse;
};

export type DexEndpointsTracerouteTestDetailsVariables = {
  pathParams: DexEndpointsTracerouteTestDetailsPathParams;
  queryParams: DexEndpointsTracerouteTestDetailsQueryParams;
} & FetcherExtraProps;

/**
 * Get test details and aggregate performance metrics for an traceroute test for a given time period between 1 hour and 7 days.
 */
export const dexEndpointsTracerouteTestDetails = (
  variables: DexEndpointsTracerouteTestDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    DexEndpointsTracerouteTestDetailsResponse,
    DexEndpointsTracerouteTestDetailsError,
    undefined,
    {},
    DexEndpointsTracerouteTestDetailsQueryParams,
    DexEndpointsTracerouteTestDetailsPathParams
  >({ url: '/accounts/{accountId}/dex/traceroute-tests/{testId}', method: 'get', ...variables, signal });

export type DexEndpointsTracerouteTestNetworkPathPathParams = {
  /**
   * unique identifier linked to an account
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
  /**
   * unique identifier for a specific test
   */
  testId: Schemas.DigitalExperienceMonitoringUuid;
};

export type DexEndpointsTracerouteTestNetworkPathQueryParams = {
  /**
   * Device to filter tracroute result runs to
   */
  deviceId: string;
  /**
   * Start time for aggregate metrics in ISO ms
   *
   * @example 1689520412000
   */
  from: string;
  /**
   * End time for aggregate metrics in ISO ms
   *
   * @example 1689606812000
   */
  to: string;
  /**
   * Time interval for aggregate time slots.
   */
  interval: 'minute' | 'hour';
};

export type DexEndpointsTracerouteTestNetworkPathError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type DexEndpointsTracerouteTestNetworkPathResponse = Schemas.DigitalExperienceMonitoringApiResponseSingle & {
  result?: Schemas.DigitalExperienceMonitoringTracerouteTestNetworkPathResponse;
};

export type DexEndpointsTracerouteTestNetworkPathVariables = {
  pathParams: DexEndpointsTracerouteTestNetworkPathPathParams;
  queryParams: DexEndpointsTracerouteTestNetworkPathQueryParams;
} & FetcherExtraProps;

/**
 * Get a breakdown of metrics by hop for individual traceroute test runs
 */
export const dexEndpointsTracerouteTestNetworkPath = (
  variables: DexEndpointsTracerouteTestNetworkPathVariables,
  signal?: AbortSignal
) =>
  fetch<
    DexEndpointsTracerouteTestNetworkPathResponse,
    DexEndpointsTracerouteTestNetworkPathError,
    undefined,
    {},
    DexEndpointsTracerouteTestNetworkPathQueryParams,
    DexEndpointsTracerouteTestNetworkPathPathParams
  >({ url: '/accounts/{accountId}/dex/traceroute-tests/{testId}/network-path', method: 'get', ...variables, signal });

export type DexEndpointsTracerouteTestPercentilesPathParams = {
  /**
   * unique identifier linked to an account in the API request path.
   */
  accountId: Schemas.DigitalExperienceMonitoringAccountIdentifier;
  /**
   * unique identifier for a specific test
   */
  testId: Schemas.DigitalExperienceMonitoringUuid;
};

export type DexEndpointsTracerouteTestPercentilesQueryParams = {
  /**
   * Optionally filter result stats to a specific device(s). Cannot be used in combination with colo param.
   */
  deviceId?: string[];
  /**
   * Start time for the query in ISO (RFC3339 - ISO 8601) format
   *
   * @example 2023-09-20T17:00:00Z
   */
  from: string;
  /**
   * End time for the query in ISO (RFC3339 - ISO 8601) format
   *
   * @example 2023-09-20T17:00:00Z
   */
  to: string;
  /**
   * Optionally filter result stats to a Cloudflare colo. Cannot be used in combination with deviceId param.
   */
  colo?: string;
};

export type DexEndpointsTracerouteTestPercentilesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DigitalExperienceMonitoringApiResponseCommonFailure;
}>;

export type DexEndpointsTracerouteTestPercentilesResponse = Schemas.DigitalExperienceMonitoringApiResponseSingle & {
  result?: Schemas.DigitalExperienceMonitoringTracerouteDetailsPercentilesResponse;
};

export type DexEndpointsTracerouteTestPercentilesVariables = {
  pathParams: DexEndpointsTracerouteTestPercentilesPathParams;
  queryParams: DexEndpointsTracerouteTestPercentilesQueryParams;
} & FetcherExtraProps;

/**
 * Get percentiles for a traceroute test for a given time period between 1 hour and 7 days.
 */
export const dexEndpointsTracerouteTestPercentiles = (
  variables: DexEndpointsTracerouteTestPercentilesVariables,
  signal?: AbortSignal
) =>
  fetch<
    DexEndpointsTracerouteTestPercentilesResponse,
    DexEndpointsTracerouteTestPercentilesError,
    undefined,
    {},
    DexEndpointsTracerouteTestPercentilesQueryParams,
    DexEndpointsTracerouteTestPercentilesPathParams
  >({ url: '/accounts/{accountId}/dex/traceroute-tests/{testId}/percentiles', method: 'get', ...variables, signal });

export type DiagnosticsTraceroutePathParams = {
  accountId: Schemas.MagicTransitIdentifier;
};

export type DiagnosticsTracerouteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicTransitTracerouteResponseCollection & Schemas.MagicTransitApiResponseCommonFailure;
}>;

export type DiagnosticsTracerouteRequestBody = {
  colos?: Schemas.MagicTransitColos;
  options?: Schemas.MagicTransitOptions;
  targets: Schemas.MagicTransitTargets;
};

export type DiagnosticsTracerouteVariables = {
  body: DiagnosticsTracerouteRequestBody;
  pathParams: DiagnosticsTraceroutePathParams;
} & FetcherExtraProps;

/**
 * Run traceroutes from Cloudflare colos.
 */
export const diagnosticsTraceroute = (variables: DiagnosticsTracerouteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicTransitTracerouteResponseCollection,
    DiagnosticsTracerouteError,
    DiagnosticsTracerouteRequestBody,
    {},
    {},
    DiagnosticsTraceroutePathParams
  >({ url: '/accounts/{accountId}/diagnostics/traceroute', method: 'post', ...variables, signal });

export type DlpDatasetsReadAllPathParams = {
  accountId: string;
};

export type DlpDatasetsReadAllError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpDatasetsReadAllResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpDatasetArray;
};

export type DlpDatasetsReadAllVariables = {
  pathParams: DlpDatasetsReadAllPathParams;
} & FetcherExtraProps;

export const dlpDatasetsReadAll = (variables: DlpDatasetsReadAllVariables, signal?: AbortSignal) =>
  fetch<DlpDatasetsReadAllResponse, DlpDatasetsReadAllError, undefined, {}, {}, DlpDatasetsReadAllPathParams>({
    url: '/accounts/{accountId}/dlp/datasets',
    method: 'get',
    ...variables,
    signal
  });

export type DlpDatasetsCreatePathParams = {
  accountId: string;
};

export type DlpDatasetsCreateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpDatasetsCreateResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpDatasetCreation;
};

export type DlpDatasetsCreateVariables = {
  body: Schemas.DlpNewDataset;
  pathParams: DlpDatasetsCreatePathParams;
} & FetcherExtraProps;

export const dlpDatasetsCreate = (variables: DlpDatasetsCreateVariables, signal?: AbortSignal) =>
  fetch<DlpDatasetsCreateResponse, DlpDatasetsCreateError, Schemas.DlpNewDataset, {}, {}, DlpDatasetsCreatePathParams>({
    url: '/accounts/{accountId}/dlp/datasets',
    method: 'post',
    ...variables,
    signal
  });

export type DlpDatasetsDeletePathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  datasetId: string;
};

export type DlpDatasetsDeleteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpDatasetsDeleteVariables = {
  pathParams: DlpDatasetsDeletePathParams;
} & FetcherExtraProps;

/**
 * This deletes all versions of the dataset.
 */
export const dlpDatasetsDelete = (variables: DlpDatasetsDeleteVariables, signal?: AbortSignal) =>
  fetch<undefined, DlpDatasetsDeleteError, undefined, {}, {}, DlpDatasetsDeletePathParams>({
    url: '/accounts/{accountId}/dlp/datasets/{datasetId}',
    method: 'delete',
    ...variables,
    signal
  });

export type DlpDatasetsReadPathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  datasetId: string;
};

export type DlpDatasetsReadError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpDatasetsReadResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpDataset;
};

export type DlpDatasetsReadVariables = {
  pathParams: DlpDatasetsReadPathParams;
} & FetcherExtraProps;

export const dlpDatasetsRead = (variables: DlpDatasetsReadVariables, signal?: AbortSignal) =>
  fetch<DlpDatasetsReadResponse, DlpDatasetsReadError, undefined, {}, {}, DlpDatasetsReadPathParams>({
    url: '/accounts/{accountId}/dlp/datasets/{datasetId}',
    method: 'get',
    ...variables,
    signal
  });

export type DlpDatasetsUpdatePathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  datasetId: string;
};

export type DlpDatasetsUpdateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpDatasetsUpdateResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpDataset;
};

export type DlpDatasetsUpdateVariables = {
  body?: Schemas.DlpDatasetUpdate;
  pathParams: DlpDatasetsUpdatePathParams;
} & FetcherExtraProps;

export const dlpDatasetsUpdate = (variables: DlpDatasetsUpdateVariables, signal?: AbortSignal) =>
  fetch<
    DlpDatasetsUpdateResponse,
    DlpDatasetsUpdateError,
    Schemas.DlpDatasetUpdate,
    {},
    {},
    DlpDatasetsUpdatePathParams
  >({ url: '/accounts/{accountId}/dlp/datasets/{datasetId}', method: 'put', ...variables, signal });

export type DlpDatasetsCreateVersionPathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  datasetId: string;
};

export type DlpDatasetsCreateVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpDatasetsCreateVersionResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpDatasetNewVersion;
};

export type DlpDatasetsCreateVersionVariables = {
  pathParams: DlpDatasetsCreateVersionPathParams;
} & FetcherExtraProps;

export const dlpDatasetsCreateVersion = (variables: DlpDatasetsCreateVersionVariables, signal?: AbortSignal) =>
  fetch<
    DlpDatasetsCreateVersionResponse,
    DlpDatasetsCreateVersionError,
    undefined,
    {},
    {},
    DlpDatasetsCreateVersionPathParams
  >({ url: '/accounts/{accountId}/dlp/datasets/{datasetId}/upload', method: 'post', ...variables, signal });

export type DlpDatasetsUploadVersionPathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  datasetId: string;
  /**
   * @format int64
   */
  version: number;
};

export type DlpDatasetsUploadVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpDatasetsUploadVersionResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpDataset;
};

export type DlpDatasetsUploadVersionVariables = {
  body?: string;
  pathParams: DlpDatasetsUploadVersionPathParams;
} & FetcherExtraProps;

/**
 * This is used for single-column EDMv1 and Custom Word Lists. The EDM format
 * can only be created in the Cloudflare dashboard. For other clients, this
 * operation can only be used for non-secret Custom Word Lists. The body must
 * be a UTF-8 encoded, newline (NL or CRNL) separated list of words to be matched.
 */
export const dlpDatasetsUploadVersion = (variables: DlpDatasetsUploadVersionVariables, signal?: AbortSignal) =>
  fetch<
    DlpDatasetsUploadVersionResponse,
    DlpDatasetsUploadVersionError,
    string,
    {},
    {},
    DlpDatasetsUploadVersionPathParams
  >({ url: '/accounts/{accountId}/dlp/datasets/{datasetId}/upload/{version}', method: 'post', ...variables, signal });

export type DlpDatasetsDefineColumnsPathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  datasetId: string;
  /**
   * @format int64
   */
  version: number;
};

export type DlpDatasetsDefineColumnsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpDatasetsDefineColumnsResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpDatasetColumnArray;
};

export type DlpDatasetsDefineColumnsRequestBody = Schemas.DlpNewDatasetColumn[];

export type DlpDatasetsDefineColumnsVariables = {
  body?: DlpDatasetsDefineColumnsRequestBody;
  pathParams: DlpDatasetsDefineColumnsPathParams;
} & FetcherExtraProps;

/**
 * This is used for multi-column EDMv2 datasets. The EDMv2 format can only be
 * created in the Cloudflare dashboard. The columns in the response appear in
 * the same order as in the request.
 */
export const dlpDatasetsDefineColumns = (variables: DlpDatasetsDefineColumnsVariables, signal?: AbortSignal) =>
  fetch<
    DlpDatasetsDefineColumnsResponse,
    DlpDatasetsDefineColumnsError,
    DlpDatasetsDefineColumnsRequestBody,
    {},
    {},
    DlpDatasetsDefineColumnsPathParams
  >({ url: '/accounts/{accountId}/dlp/datasets/{datasetId}/versions/{version}', method: 'post', ...variables, signal });

export type DlpDatasetsUploadDatasetColumnPathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  datasetId: string;
  /**
   * @format int64
   */
  version: number;
  /**
   * @format uuid
   */
  entryId: string;
};

export type DlpDatasetsUploadDatasetColumnError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpDatasetsUploadDatasetColumnResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpDatasetColumn;
};

export type DlpDatasetsUploadDatasetColumnVariables = {
  body?: string;
  pathParams: DlpDatasetsUploadDatasetColumnPathParams;
} & FetcherExtraProps;

/**
 * This is used for multi-column EDMv2 datasets. The EDMv2 format can only be
 * created in the Cloudflare dashboard.
 */
export const dlpDatasetsUploadDatasetColumn = (
  variables: DlpDatasetsUploadDatasetColumnVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlpDatasetsUploadDatasetColumnResponse,
    DlpDatasetsUploadDatasetColumnError,
    string,
    {},
    {},
    DlpDatasetsUploadDatasetColumnPathParams
  >({
    url: '/accounts/{accountId}/dlp/datasets/{datasetId}/versions/{version}/entries/{entryId}',
    method: 'post',
    ...variables,
    signal
  });

export type DlpEmailScannerGetAccountMappingPathParams = {
  accountId: string;
};

export type DlpEmailScannerGetAccountMappingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpEmailScannerGetAccountMappingResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpAddinAccountMapping;
};

export type DlpEmailScannerGetAccountMappingVariables = {
  pathParams: DlpEmailScannerGetAccountMappingPathParams;
} & FetcherExtraProps;

export const dlpEmailScannerGetAccountMapping = (
  variables: DlpEmailScannerGetAccountMappingVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlpEmailScannerGetAccountMappingResponse,
    DlpEmailScannerGetAccountMappingError,
    undefined,
    {},
    {},
    DlpEmailScannerGetAccountMappingPathParams
  >({ url: '/accounts/{accountId}/dlp/email/account_mapping', method: 'get', ...variables, signal });

export type DlpEmailScannerCreateAccountMappingPathParams = {
  accountId: string;
};

export type DlpEmailScannerCreateAccountMappingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpEmailScannerCreateAccountMappingResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpAddinAccountMapping;
};

export type DlpEmailScannerCreateAccountMappingVariables = {
  body: Schemas.DlpUpdateAddinAccountMapping;
  pathParams: DlpEmailScannerCreateAccountMappingPathParams;
} & FetcherExtraProps;

export const dlpEmailScannerCreateAccountMapping = (
  variables: DlpEmailScannerCreateAccountMappingVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlpEmailScannerCreateAccountMappingResponse,
    DlpEmailScannerCreateAccountMappingError,
    Schemas.DlpUpdateAddinAccountMapping,
    {},
    {},
    DlpEmailScannerCreateAccountMappingPathParams
  >({ url: '/accounts/{accountId}/dlp/email/account_mapping', method: 'post', ...variables, signal });

export type DlpEmailScannerListAllRulesPathParams = {
  accountId: string;
};

export type DlpEmailScannerListAllRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpEmailScannerListAllRulesResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpEmailRuleArray;
};

export type DlpEmailScannerListAllRulesVariables = {
  pathParams: DlpEmailScannerListAllRulesPathParams;
} & FetcherExtraProps;

/**
 * Lists all email scanner rules for an account.
 */
export const dlpEmailScannerListAllRules = (variables: DlpEmailScannerListAllRulesVariables, signal?: AbortSignal) =>
  fetch<
    DlpEmailScannerListAllRulesResponse,
    DlpEmailScannerListAllRulesError,
    undefined,
    {},
    {},
    DlpEmailScannerListAllRulesPathParams
  >({ url: '/accounts/{accountId}/dlp/email/rules', method: 'get', ...variables, signal });

export type DlpEmailScannerUpdateRulePrioritiesPathParams = {
  accountId: string;
};

export type DlpEmailScannerUpdateRulePrioritiesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpEmailScannerUpdateRulePrioritiesResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpEmailRule;
};

export type DlpEmailScannerUpdateRulePrioritiesVariables = {
  body: Schemas.DlpUpdateEmailRulePriorities;
  pathParams: DlpEmailScannerUpdateRulePrioritiesPathParams;
} & FetcherExtraProps;

export const dlpEmailScannerUpdateRulePriorities = (
  variables: DlpEmailScannerUpdateRulePrioritiesVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlpEmailScannerUpdateRulePrioritiesResponse,
    DlpEmailScannerUpdateRulePrioritiesError,
    Schemas.DlpUpdateEmailRulePriorities,
    {},
    {},
    DlpEmailScannerUpdateRulePrioritiesPathParams
  >({ url: '/accounts/{accountId}/dlp/email/rules', method: 'patch', ...variables, signal });

export type DlpEmailScannerCreateRulePathParams = {
  accountId: string;
};

export type DlpEmailScannerCreateRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpEmailScannerCreateRuleResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpEmailRule;
};

export type DlpEmailScannerCreateRuleVariables = {
  body: Schemas.DlpCreateEmailRule;
  pathParams: DlpEmailScannerCreateRulePathParams;
} & FetcherExtraProps;

export const dlpEmailScannerCreateRule = (variables: DlpEmailScannerCreateRuleVariables, signal?: AbortSignal) =>
  fetch<
    DlpEmailScannerCreateRuleResponse,
    DlpEmailScannerCreateRuleError,
    Schemas.DlpCreateEmailRule,
    {},
    {},
    DlpEmailScannerCreateRulePathParams
  >({ url: '/accounts/{accountId}/dlp/email/rules', method: 'post', ...variables, signal });

export type DlpEmailScannerDeleteRulePathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  ruleId: string;
};

export type DlpEmailScannerDeleteRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpEmailScannerDeleteRuleResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpEmailRule;
};

export type DlpEmailScannerDeleteRuleVariables = {
  pathParams: DlpEmailScannerDeleteRulePathParams;
} & FetcherExtraProps;

export const dlpEmailScannerDeleteRule = (variables: DlpEmailScannerDeleteRuleVariables, signal?: AbortSignal) =>
  fetch<
    DlpEmailScannerDeleteRuleResponse,
    DlpEmailScannerDeleteRuleError,
    undefined,
    {},
    {},
    DlpEmailScannerDeleteRulePathParams
  >({ url: '/accounts/{accountId}/dlp/email/rules/{ruleId}', method: 'delete', ...variables, signal });

export type DlpEmailScannerGetRulePathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  ruleId: string;
};

export type DlpEmailScannerGetRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpEmailScannerGetRuleResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpEmailRule;
};

export type DlpEmailScannerGetRuleVariables = {
  pathParams: DlpEmailScannerGetRulePathParams;
} & FetcherExtraProps;

export const dlpEmailScannerGetRule = (variables: DlpEmailScannerGetRuleVariables, signal?: AbortSignal) =>
  fetch<
    DlpEmailScannerGetRuleResponse,
    DlpEmailScannerGetRuleError,
    undefined,
    {},
    {},
    DlpEmailScannerGetRulePathParams
  >({ url: '/accounts/{accountId}/dlp/email/rules/{ruleId}', method: 'get', ...variables, signal });

export type DlpEmailScannerUpdateRulePathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  ruleId: string;
};

export type DlpEmailScannerUpdateRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpEmailScannerUpdateRuleResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpEmailRule;
};

export type DlpEmailScannerUpdateRuleVariables = {
  body: Schemas.DlpCreateEmailRule;
  pathParams: DlpEmailScannerUpdateRulePathParams;
} & FetcherExtraProps;

export const dlpEmailScannerUpdateRule = (variables: DlpEmailScannerUpdateRuleVariables, signal?: AbortSignal) =>
  fetch<
    DlpEmailScannerUpdateRuleResponse,
    DlpEmailScannerUpdateRuleError,
    Schemas.DlpCreateEmailRule,
    {},
    {},
    DlpEmailScannerUpdateRulePathParams
  >({ url: '/accounts/{accountId}/dlp/email/rules/{ruleId}', method: 'put', ...variables, signal });

export type DlpEntriesListAllEntriesPathParams = {
  accountId: string;
};

export type DlpEntriesListAllEntriesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpEntriesListAllEntriesResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpEntry[];
};

export type DlpEntriesListAllEntriesVariables = {
  pathParams: DlpEntriesListAllEntriesPathParams;
} & FetcherExtraProps;

/**
 * Lists all DLP entries in an account.
 */
export const dlpEntriesListAllEntries = (variables: DlpEntriesListAllEntriesVariables, signal?: AbortSignal) =>
  fetch<
    DlpEntriesListAllEntriesResponse,
    DlpEntriesListAllEntriesError,
    undefined,
    {},
    {},
    DlpEntriesListAllEntriesPathParams
  >({ url: '/accounts/{accountId}/dlp/entries', method: 'get', ...variables, signal });

export type DlpEntriesCreateEntryPathParams = {
  accountId: string;
};

export type DlpEntriesCreateEntryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpEntriesCreateEntryResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpCustomEntry;
};

export type DlpEntriesCreateEntryVariables = {
  body: Schemas.DlpNewEntry;
  pathParams: DlpEntriesCreateEntryPathParams;
} & FetcherExtraProps;

/**
 * Creates a DLP custom entry.
 */
export const dlpEntriesCreateEntry = (variables: DlpEntriesCreateEntryVariables, signal?: AbortSignal) =>
  fetch<
    DlpEntriesCreateEntryResponse,
    DlpEntriesCreateEntryError,
    Schemas.DlpNewEntry,
    {},
    {},
    DlpEntriesCreateEntryPathParams
  >({ url: '/accounts/{accountId}/dlp/entries', method: 'post', ...variables, signal });

export type DlpEntriesDeleteEntryPathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  entryId: string;
};

export type DlpEntriesDeleteEntryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpEntriesDeleteEntryResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpEmpty;
};

export type DlpEntriesDeleteEntryVariables = {
  pathParams: DlpEntriesDeleteEntryPathParams;
} & FetcherExtraProps;

/**
 * Deletes a DLP custom entry.
 */
export const dlpEntriesDeleteEntry = (variables: DlpEntriesDeleteEntryVariables, signal?: AbortSignal) =>
  fetch<DlpEntriesDeleteEntryResponse, DlpEntriesDeleteEntryError, undefined, {}, {}, DlpEntriesDeleteEntryPathParams>({
    url: '/accounts/{accountId}/dlp/entries/{entryId}',
    method: 'delete',
    ...variables,
    signal
  });

export type DlpEntriesGetDlpEntryPathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  entryId: string;
};

export type DlpEntriesGetDlpEntryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpEntriesGetDlpEntryResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpEntry;
};

export type DlpEntriesGetDlpEntryVariables = {
  pathParams: DlpEntriesGetDlpEntryPathParams;
} & FetcherExtraProps;

/**
 * Fetches a DLP entry by ID
 */
export const dlpEntriesGetDlpEntry = (variables: DlpEntriesGetDlpEntryVariables, signal?: AbortSignal) =>
  fetch<DlpEntriesGetDlpEntryResponse, DlpEntriesGetDlpEntryError, undefined, {}, {}, DlpEntriesGetDlpEntryPathParams>({
    url: '/accounts/{accountId}/dlp/entries/{entryId}',
    method: 'get',
    ...variables,
    signal
  });

export type DlpEntriesUpdateEntryPathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  entryId: string;
};

export type DlpEntriesUpdateEntryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpEntriesUpdateEntryResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpEntry;
};

export type DlpEntriesUpdateEntryVariables = {
  body?: Schemas.DlpEntryUpdate;
  pathParams: DlpEntriesUpdateEntryPathParams;
} & FetcherExtraProps;

/**
 * Updates a DLP entry.
 */
export const dlpEntriesUpdateEntry = (variables: DlpEntriesUpdateEntryVariables, signal?: AbortSignal) =>
  fetch<
    DlpEntriesUpdateEntryResponse,
    DlpEntriesUpdateEntryError,
    Schemas.DlpEntryUpdate,
    {},
    {},
    DlpEntriesUpdateEntryPathParams
  >({ url: '/accounts/{accountId}/dlp/entries/{entryId}', method: 'put', ...variables, signal });

export type DlpLimitsGetPathParams = {
  accountId: string;
};

export type DlpLimitsGetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpLimitsGetResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpLimits;
};

export type DlpLimitsGetVariables = {
  pathParams: DlpLimitsGetPathParams;
} & FetcherExtraProps;

export const dlpLimitsGet = (variables: DlpLimitsGetVariables, signal?: AbortSignal) =>
  fetch<DlpLimitsGetResponse, DlpLimitsGetError, undefined, {}, {}, DlpLimitsGetPathParams>({
    url: '/accounts/{accountId}/dlp/limits',
    method: 'get',
    ...variables,
    signal
  });

export type DlpPatternValidatePathParams = {
  /**
   * Account ID
   */
  accountId: string;
};

export type DlpPatternValidateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpPatternValidateResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpRegexValidationResult;
};

export type DlpPatternValidateVariables = {
  body: Schemas.DlpRegexValidationQuery;
  pathParams: DlpPatternValidatePathParams;
} & FetcherExtraProps;

/**
 * Validates whether this pattern is a valid regular expression. Rejects it if
 * the regular expression is too complex or can match an unbounded-length
 * string. The regex will be rejected if it uses `*` or `+`. Bound the maximum
 * number of characters that can be matched using a range, e.g. `{1,100}`.
 */
export const dlpPatternValidate = (variables: DlpPatternValidateVariables, signal?: AbortSignal) =>
  fetch<
    DlpPatternValidateResponse,
    DlpPatternValidateError,
    Schemas.DlpRegexValidationQuery,
    {},
    {},
    DlpPatternValidatePathParams
  >({ url: '/accounts/{accountId}/dlp/patterns/validate', method: 'post', ...variables, signal });

export type DlpPayloadLogGetPathParams = {
  accountId: string;
};

export type DlpPayloadLogGetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpPayloadLogGetResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpPayloadLogSetting;
};

export type DlpPayloadLogGetVariables = {
  pathParams: DlpPayloadLogGetPathParams;
} & FetcherExtraProps;

export const dlpPayloadLogGet = (variables: DlpPayloadLogGetVariables, signal?: AbortSignal) =>
  fetch<DlpPayloadLogGetResponse, DlpPayloadLogGetError, undefined, {}, {}, DlpPayloadLogGetPathParams>({
    url: '/accounts/{accountId}/dlp/payload_log',
    method: 'get',
    ...variables,
    signal
  });

export type DlpPayloadLogPutPathParams = {
  accountId: string;
};

export type DlpPayloadLogPutError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpPayloadLogPutResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpPayloadLogSetting;
};

export type DlpPayloadLogPutVariables = {
  body?: Schemas.DlpPayloadLogSettingUpdate;
  pathParams: DlpPayloadLogPutPathParams;
} & FetcherExtraProps;

export const dlpPayloadLogPut = (variables: DlpPayloadLogPutVariables, signal?: AbortSignal) =>
  fetch<
    DlpPayloadLogPutResponse,
    DlpPayloadLogPutError,
    Schemas.DlpPayloadLogSettingUpdate,
    {},
    {},
    DlpPayloadLogPutPathParams
  >({ url: '/accounts/{accountId}/dlp/payload_log', method: 'put', ...variables, signal });

export type DlpProfilesListAllProfilesPathParams = {
  accountId: string;
};

export type DlpProfilesListAllProfilesQueryParams = {
  /**
   * Return all profiles, including those that current account does not have access to.
   */
  all?: boolean;
};

export type DlpProfilesListAllProfilesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpProfilesListAllProfilesResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpProfileArray;
};

export type DlpProfilesListAllProfilesVariables = {
  pathParams: DlpProfilesListAllProfilesPathParams;
  queryParams?: DlpProfilesListAllProfilesQueryParams;
} & FetcherExtraProps;

/**
 * Lists all DLP profiles in an account.
 */
export const dlpProfilesListAllProfiles = (variables: DlpProfilesListAllProfilesVariables, signal?: AbortSignal) =>
  fetch<
    DlpProfilesListAllProfilesResponse,
    DlpProfilesListAllProfilesError,
    undefined,
    {},
    DlpProfilesListAllProfilesQueryParams,
    DlpProfilesListAllProfilesPathParams
  >({ url: '/accounts/{accountId}/dlp/profiles', method: 'get', ...variables, signal });

export type DlpProfilesCreateCustomProfilesPathParams = {
  accountId: string;
};

export type DlpProfilesCreateCustomProfilesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpProfilesCreateCustomProfilesResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpProfileOrProfileArray;
};

export type DlpProfilesCreateCustomProfilesVariables = {
  body?: Schemas.DlpNewCustomProfiles;
  pathParams: DlpProfilesCreateCustomProfilesPathParams;
} & FetcherExtraProps;

/**
 * Creates a DLP custom profile.
 */
export const dlpProfilesCreateCustomProfiles = (
  variables: DlpProfilesCreateCustomProfilesVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlpProfilesCreateCustomProfilesResponse,
    DlpProfilesCreateCustomProfilesError,
    Schemas.DlpNewCustomProfiles,
    {},
    {},
    DlpProfilesCreateCustomProfilesPathParams
  >({ url: '/accounts/{accountId}/dlp/profiles/custom', method: 'post', ...variables, signal });

export type DlpProfilesDeleteCustomProfilePathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  profileId: string;
};

export type DlpProfilesDeleteCustomProfileError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpProfilesDeleteCustomProfileResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpEmpty;
};

export type DlpProfilesDeleteCustomProfileVariables = {
  pathParams: DlpProfilesDeleteCustomProfilePathParams;
} & FetcherExtraProps;

/**
 * Deletes a DLP custom profile.
 */
export const dlpProfilesDeleteCustomProfile = (
  variables: DlpProfilesDeleteCustomProfileVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlpProfilesDeleteCustomProfileResponse,
    DlpProfilesDeleteCustomProfileError,
    undefined,
    {},
    {},
    DlpProfilesDeleteCustomProfilePathParams
  >({ url: '/accounts/{accountId}/dlp/profiles/custom/{profileId}', method: 'delete', ...variables, signal });

export type DlpProfilesGetCustomProfilePathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  profileId: string;
};

export type DlpProfilesGetCustomProfileError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpProfilesGetCustomProfileResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpProfile;
};

export type DlpProfilesGetCustomProfileVariables = {
  pathParams: DlpProfilesGetCustomProfilePathParams;
} & FetcherExtraProps;

/**
 * Fetches a custom DLP profile by id.
 */
export const dlpProfilesGetCustomProfile = (variables: DlpProfilesGetCustomProfileVariables, signal?: AbortSignal) =>
  fetch<
    DlpProfilesGetCustomProfileResponse,
    DlpProfilesGetCustomProfileError,
    undefined,
    {},
    {},
    DlpProfilesGetCustomProfilePathParams
  >({ url: '/accounts/{accountId}/dlp/profiles/custom/{profileId}', method: 'get', ...variables, signal });

export type DlpProfilesUpdateCustomProfilePathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  profileId: string;
};

export type DlpProfilesUpdateCustomProfileError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpProfilesUpdateCustomProfileResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpProfile;
};

export type DlpProfilesUpdateCustomProfileVariables = {
  body: Schemas.DlpCustomProfileUpdate;
  pathParams: DlpProfilesUpdateCustomProfilePathParams;
} & FetcherExtraProps;

/**
 * Updates a DLP custom profile.
 */
export const dlpProfilesUpdateCustomProfile = (
  variables: DlpProfilesUpdateCustomProfileVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlpProfilesUpdateCustomProfileResponse,
    DlpProfilesUpdateCustomProfileError,
    Schemas.DlpCustomProfileUpdate,
    {},
    {},
    DlpProfilesUpdateCustomProfilePathParams
  >({ url: '/accounts/{accountId}/dlp/profiles/custom/{profileId}', method: 'put', ...variables, signal });

export type DlpProfilesGetPredefinedProfilePathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  profileId: string;
};

export type DlpProfilesGetPredefinedProfileError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpProfilesGetPredefinedProfileResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpProfile;
};

export type DlpProfilesGetPredefinedProfileVariables = {
  pathParams: DlpProfilesGetPredefinedProfilePathParams;
} & FetcherExtraProps;

/**
 * Fetches a predefined DLP profile by id.
 */
export const dlpProfilesGetPredefinedProfile = (
  variables: DlpProfilesGetPredefinedProfileVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlpProfilesGetPredefinedProfileResponse,
    DlpProfilesGetPredefinedProfileError,
    undefined,
    {},
    {},
    DlpProfilesGetPredefinedProfilePathParams
  >({ url: '/accounts/{accountId}/dlp/profiles/predefined/{profileId}', method: 'get', ...variables, signal });

export type DlpProfilesUpdatePredefinedProfilePathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  profileId: string;
};

export type DlpProfilesUpdatePredefinedProfileError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpProfilesUpdatePredefinedProfileResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpProfile;
};

export type DlpProfilesUpdatePredefinedProfileVariables = {
  body: Schemas.DlpPredefinedProfileUpdate;
  pathParams: DlpProfilesUpdatePredefinedProfilePathParams;
} & FetcherExtraProps;

/**
 * Updates a DLP predefined profile. Only supports enabling/disabling entries.
 */
export const dlpProfilesUpdatePredefinedProfile = (
  variables: DlpProfilesUpdatePredefinedProfileVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlpProfilesUpdatePredefinedProfileResponse,
    DlpProfilesUpdatePredefinedProfileError,
    Schemas.DlpPredefinedProfileUpdate,
    {},
    {},
    DlpProfilesUpdatePredefinedProfilePathParams
  >({ url: '/accounts/{accountId}/dlp/profiles/predefined/{profileId}', method: 'put', ...variables, signal });

export type DlpProfilesGetDlpProfilePathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  profileId: string;
};

export type DlpProfilesGetDlpProfileError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpProfilesGetDlpProfileResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpProfile;
};

export type DlpProfilesGetDlpProfileVariables = {
  pathParams: DlpProfilesGetDlpProfilePathParams;
} & FetcherExtraProps;

/**
 * Fetches a DLP profile by ID
 */
export const dlpProfilesGetDlpProfile = (variables: DlpProfilesGetDlpProfileVariables, signal?: AbortSignal) =>
  fetch<
    DlpProfilesGetDlpProfileResponse,
    DlpProfilesGetDlpProfileError,
    undefined,
    {},
    {},
    DlpProfilesGetDlpProfilePathParams
  >({ url: '/accounts/{accountId}/dlp/profiles/{profileId}', method: 'get', ...variables, signal });

export type DnsFirewallListDnsFirewallClustersPathParams = {
  accountId: Schemas.DnsFirewallIdentifier;
};

export type DnsFirewallListDnsFirewallClustersQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 100
   * @minimum 1
   */
  per_page?: number;
};

export type DnsFirewallListDnsFirewallClustersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsFirewallDnsFirewallResponseCollection & Schemas.DnsFirewallApiResponseCommonFailure;
}>;

export type DnsFirewallListDnsFirewallClustersVariables = {
  pathParams: DnsFirewallListDnsFirewallClustersPathParams;
  queryParams?: DnsFirewallListDnsFirewallClustersQueryParams;
} & FetcherExtraProps;

/**
 * List DNS Firewall clusters for an account
 */
export const dnsFirewallListDnsFirewallClusters = (
  variables: DnsFirewallListDnsFirewallClustersVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsFirewallDnsFirewallResponseCollection,
    DnsFirewallListDnsFirewallClustersError,
    undefined,
    {},
    DnsFirewallListDnsFirewallClustersQueryParams,
    DnsFirewallListDnsFirewallClustersPathParams
  >({ url: '/accounts/{accountId}/dns_firewall', method: 'get', ...variables, signal });

export type DnsFirewallCreateDnsFirewallClusterPathParams = {
  accountId: Schemas.DnsFirewallIdentifier;
};

export type DnsFirewallCreateDnsFirewallClusterError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsFirewallDnsFirewallSingleResponse & Schemas.DnsFirewallApiResponseCommonFailure;
}>;

export type DnsFirewallCreateDnsFirewallClusterVariables = {
  body: Schemas.DnsFirewallDnsFirewallClusterPost;
  pathParams: DnsFirewallCreateDnsFirewallClusterPathParams;
} & FetcherExtraProps;

/**
 * Create a DNS Firewall cluster
 */
export const dnsFirewallCreateDnsFirewallCluster = (
  variables: DnsFirewallCreateDnsFirewallClusterVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsFirewallDnsFirewallSingleResponse,
    DnsFirewallCreateDnsFirewallClusterError,
    Schemas.DnsFirewallDnsFirewallClusterPost,
    {},
    {},
    DnsFirewallCreateDnsFirewallClusterPathParams
  >({ url: '/accounts/{accountId}/dns_firewall', method: 'post', ...variables, signal });

export type DnsFirewallDeleteDnsFirewallClusterPathParams = {
  dnsFirewallId: Schemas.DnsFirewallIdentifier;
  accountId: Schemas.DnsFirewallIdentifier;
};

export type DnsFirewallDeleteDnsFirewallClusterError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.DnsFirewallApiResponseSingle & {
    result?: {
      id?: Schemas.DnsFirewallIdentifier;
    };
  }) &
    Schemas.DnsFirewallApiResponseCommonFailure;
}>;

export type DnsFirewallDeleteDnsFirewallClusterResponse = Schemas.DnsFirewallApiResponseSingle & {
  result?: {
    id?: Schemas.DnsFirewallIdentifier;
  };
};

export type DnsFirewallDeleteDnsFirewallClusterVariables = {
  pathParams: DnsFirewallDeleteDnsFirewallClusterPathParams;
} & FetcherExtraProps;

/**
 * Delete a DNS Firewall cluster
 */
export const dnsFirewallDeleteDnsFirewallCluster = (
  variables: DnsFirewallDeleteDnsFirewallClusterVariables,
  signal?: AbortSignal
) =>
  fetch<
    DnsFirewallDeleteDnsFirewallClusterResponse,
    DnsFirewallDeleteDnsFirewallClusterError,
    undefined,
    {},
    {},
    DnsFirewallDeleteDnsFirewallClusterPathParams
  >({ url: '/accounts/{accountId}/dns_firewall/{dnsFirewallId}', method: 'delete', ...variables, signal });

export type DnsFirewallDnsFirewallClusterDetailsPathParams = {
  dnsFirewallId: Schemas.DnsFirewallIdentifier;
  accountId: Schemas.DnsFirewallIdentifier;
};

export type DnsFirewallDnsFirewallClusterDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsFirewallDnsFirewallSingleResponse & Schemas.DnsFirewallApiResponseCommonFailure;
}>;

export type DnsFirewallDnsFirewallClusterDetailsVariables = {
  pathParams: DnsFirewallDnsFirewallClusterDetailsPathParams;
} & FetcherExtraProps;

/**
 * Show a single DNS Firewall cluster for an account
 */
export const dnsFirewallDnsFirewallClusterDetails = (
  variables: DnsFirewallDnsFirewallClusterDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsFirewallDnsFirewallSingleResponse,
    DnsFirewallDnsFirewallClusterDetailsError,
    undefined,
    {},
    {},
    DnsFirewallDnsFirewallClusterDetailsPathParams
  >({ url: '/accounts/{accountId}/dns_firewall/{dnsFirewallId}', method: 'get', ...variables, signal });

export type DnsFirewallUpdateDnsFirewallClusterPathParams = {
  dnsFirewallId: Schemas.DnsFirewallIdentifier;
  accountId: Schemas.DnsFirewallIdentifier;
};

export type DnsFirewallUpdateDnsFirewallClusterError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsFirewallDnsFirewallSingleResponse & Schemas.DnsFirewallApiResponseCommonFailure;
}>;

export type DnsFirewallUpdateDnsFirewallClusterVariables = {
  body?: Schemas.DnsFirewallDnsFirewallClusterPatch;
  pathParams: DnsFirewallUpdateDnsFirewallClusterPathParams;
} & FetcherExtraProps;

/**
 * Modify the configuration of a DNS Firewall cluster
 */
export const dnsFirewallUpdateDnsFirewallCluster = (
  variables: DnsFirewallUpdateDnsFirewallClusterVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsFirewallDnsFirewallSingleResponse,
    DnsFirewallUpdateDnsFirewallClusterError,
    Schemas.DnsFirewallDnsFirewallClusterPatch,
    {},
    {},
    DnsFirewallUpdateDnsFirewallClusterPathParams
  >({ url: '/accounts/{accountId}/dns_firewall/{dnsFirewallId}', method: 'patch', ...variables, signal });

export type DnsFirewallAnalyticsTablePathParams = {
  dnsFirewallId: Schemas.DnsAnalyticsIdentifier;
  accountId: Schemas.DnsAnalyticsIdentifier;
};

export type DnsFirewallAnalyticsTableQueryParams = {
  metrics?: Schemas.DnsAnalyticsMetrics;
  dimensions?: Schemas.DnsAnalyticsDimensions;
  since?: Schemas.DnsAnalyticsSince;
  until?: Schemas.DnsAnalyticsUntil;
  limit?: Schemas.DnsAnalyticsLimit;
  sort?: Schemas.DnsAnalyticsSort;
  filters?: Schemas.DnsAnalyticsFilters;
};

export type DnsFirewallAnalyticsTableError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.DnsAnalyticsApiResponseSingle & {
    result?: Schemas.DnsAnalyticsReport;
  }) &
    Schemas.DnsAnalyticsApiResponseCommonFailure;
}>;

export type DnsFirewallAnalyticsTableResponse = Schemas.DnsAnalyticsApiResponseSingle & {
  result?: Schemas.DnsAnalyticsReport;
};

export type DnsFirewallAnalyticsTableVariables = {
  pathParams: DnsFirewallAnalyticsTablePathParams;
  queryParams?: DnsFirewallAnalyticsTableQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of summarised aggregate metrics over a given time period.
 *
 * See [Analytics API properties](https://developers.cloudflare.com/dns/reference/analytics-api-properties/) for detailed information about the available query parameters.
 */
export const dnsFirewallAnalyticsTable = (variables: DnsFirewallAnalyticsTableVariables, signal?: AbortSignal) =>
  fetch<
    DnsFirewallAnalyticsTableResponse,
    DnsFirewallAnalyticsTableError,
    undefined,
    {},
    DnsFirewallAnalyticsTableQueryParams,
    DnsFirewallAnalyticsTablePathParams
  >({
    url: '/accounts/{accountId}/dns_firewall/{dnsFirewallId}/dns_analytics/report',
    method: 'get',
    ...variables,
    signal
  });

export type DnsFirewallAnalyticsByTimePathParams = {
  dnsFirewallId: Schemas.DnsAnalyticsIdentifier;
  accountId: Schemas.DnsAnalyticsIdentifier;
};

export type DnsFirewallAnalyticsByTimeQueryParams = {
  metrics?: Schemas.DnsAnalyticsMetrics;
  dimensions?: Schemas.DnsAnalyticsDimensions;
  since?: Schemas.DnsAnalyticsSince;
  until?: Schemas.DnsAnalyticsUntil;
  limit?: Schemas.DnsAnalyticsLimit;
  sort?: Schemas.DnsAnalyticsSort;
  filters?: Schemas.DnsAnalyticsFilters;
  time_delta?: Schemas.DnsAnalyticsTimeDelta;
};

export type DnsFirewallAnalyticsByTimeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.DnsAnalyticsApiResponseSingle & {
    result?: Schemas.DnsAnalyticsReportBytime;
  }) &
    Schemas.DnsAnalyticsApiResponseCommonFailure;
}>;

export type DnsFirewallAnalyticsByTimeResponse = Schemas.DnsAnalyticsApiResponseSingle & {
  result?: Schemas.DnsAnalyticsReportBytime;
};

export type DnsFirewallAnalyticsByTimeVariables = {
  pathParams: DnsFirewallAnalyticsByTimePathParams;
  queryParams?: DnsFirewallAnalyticsByTimeQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of aggregate metrics grouped by time interval.
 *
 * See [Analytics API properties](https://developers.cloudflare.com/dns/reference/analytics-api-properties/) for detailed information about the available query parameters.
 */
export const dnsFirewallAnalyticsByTime = (variables: DnsFirewallAnalyticsByTimeVariables, signal?: AbortSignal) =>
  fetch<
    DnsFirewallAnalyticsByTimeResponse,
    DnsFirewallAnalyticsByTimeError,
    undefined,
    {},
    DnsFirewallAnalyticsByTimeQueryParams,
    DnsFirewallAnalyticsByTimePathParams
  >({
    url: '/accounts/{accountId}/dns_firewall/{dnsFirewallId}/dns_analytics/report/bytime',
    method: 'get',
    ...variables,
    signal
  });

export type DnsFirewallShowDnsFirewallClusterReverseDnsPathParams = {
  dnsFirewallId: Schemas.DnsFirewallIdentifier;
  accountId: Schemas.DnsFirewallIdentifier;
};

export type DnsFirewallShowDnsFirewallClusterReverseDnsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsFirewallDnsFirewallReverseDnsResponse2 & Schemas.DnsFirewallApiResponseCommonFailure;
}>;

export type DnsFirewallShowDnsFirewallClusterReverseDnsVariables = {
  pathParams: DnsFirewallShowDnsFirewallClusterReverseDnsPathParams;
} & FetcherExtraProps;

/**
 * Show reverse DNS configuration (PTR records) for a DNS Firewall cluster
 */
export const dnsFirewallShowDnsFirewallClusterReverseDns = (
  variables: DnsFirewallShowDnsFirewallClusterReverseDnsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsFirewallDnsFirewallReverseDnsResponse2,
    DnsFirewallShowDnsFirewallClusterReverseDnsError,
    undefined,
    {},
    {},
    DnsFirewallShowDnsFirewallClusterReverseDnsPathParams
  >({ url: '/accounts/{accountId}/dns_firewall/{dnsFirewallId}/reverse_dns', method: 'get', ...variables, signal });

export type DnsFirewallUpdateDnsFirewallClusterReverseDnsPathParams = {
  dnsFirewallId: Schemas.DnsFirewallIdentifier;
  accountId: Schemas.DnsFirewallIdentifier;
};

export type DnsFirewallUpdateDnsFirewallClusterReverseDnsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsFirewallDnsFirewallReverseDnsResponse2 & Schemas.DnsFirewallApiResponseCommonFailure;
}>;

export type DnsFirewallUpdateDnsFirewallClusterReverseDnsVariables = {
  body?: Schemas.DnsFirewallDnsFirewallReverseDnsPatch;
  pathParams: DnsFirewallUpdateDnsFirewallClusterReverseDnsPathParams;
} & FetcherExtraProps;

/**
 * Update reverse DNS configuration (PTR records) for a DNS Firewall cluster
 */
export const dnsFirewallUpdateDnsFirewallClusterReverseDns = (
  variables: DnsFirewallUpdateDnsFirewallClusterReverseDnsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsFirewallDnsFirewallReverseDnsResponse2,
    DnsFirewallUpdateDnsFirewallClusterReverseDnsError,
    Schemas.DnsFirewallDnsFirewallReverseDnsPatch,
    {},
    {},
    DnsFirewallUpdateDnsFirewallClusterReverseDnsPathParams
  >({ url: '/accounts/{accountId}/dns_firewall/{dnsFirewallId}/reverse_dns', method: 'patch', ...variables, signal });

export type DnsSettingsForAnAccountListDnsSettingsPathParams = {
  accountId: Schemas.DnsSettingsIdentifier;
};

export type DnsSettingsForAnAccountListDnsSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsSettingsDnsResponseSingle & Schemas.DnsSettingsApiResponseCommonFailure;
}>;

export type DnsSettingsForAnAccountListDnsSettingsVariables = {
  pathParams: DnsSettingsForAnAccountListDnsSettingsPathParams;
} & FetcherExtraProps;

/**
 * Show DNS settings for an account
 */
export const dnsSettingsForAnAccountListDnsSettings = (
  variables: DnsSettingsForAnAccountListDnsSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsSettingsDnsResponseSingle,
    DnsSettingsForAnAccountListDnsSettingsError,
    undefined,
    {},
    {},
    DnsSettingsForAnAccountListDnsSettingsPathParams
  >({ url: '/accounts/{accountId}/dns_settings', method: 'get', ...variables, signal });

export type DnsSettingsForAnAccountUpdateDnsSettingsPathParams = {
  accountId: Schemas.DnsSettingsIdentifier;
};

export type DnsSettingsForAnAccountUpdateDnsSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsSettingsDnsResponseSingle & Schemas.DnsSettingsApiResponseCommonFailure;
}>;

export type DnsSettingsForAnAccountUpdateDnsSettingsVariables = {
  body?: Schemas.DnsSettingsAccountSettings;
  pathParams: DnsSettingsForAnAccountUpdateDnsSettingsPathParams;
} & FetcherExtraProps;

/**
 * Update DNS settings for an account
 */
export const dnsSettingsForAnAccountUpdateDnsSettings = (
  variables: DnsSettingsForAnAccountUpdateDnsSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsSettingsDnsResponseSingle,
    DnsSettingsForAnAccountUpdateDnsSettingsError,
    Schemas.DnsSettingsAccountSettings,
    {},
    {},
    DnsSettingsForAnAccountUpdateDnsSettingsPathParams
  >({ url: '/accounts/{accountId}/dns_settings', method: 'patch', ...variables, signal });

export type DnsViewsForAnAccountListInternalDnsViewsPathParams = {
  accountId: Schemas.DnsSettingsIdentifier;
};

export type DnsViewsForAnAccountListInternalDnsViewsQueryParams = {
  /**
   * @example my view
   */
  name?: string;
  /**
   * @example my view
   */
  ['name.exact']?: string;
  /**
   * @example view
   */
  ['name.contains']?: string;
  /**
   * @example my
   */
  ['name.startswith']?: string;
  /**
   * @example ew
   */
  ['name.endswith']?: string;
  /**
   * @example ae29bea30e2e427ba9cd8d78b628177b
   */
  zone_id?: string;
  /**
   * @example www.example.com
   */
  zone_name?: string;
  match?: Schemas.DnsSettingsMatch;
  page?: Schemas.DnsSettingsPage;
  per_page?: Schemas.DnsSettingsPerPage;
  order?: Schemas.DnsSettingsOrder;
  direction?: Schemas.DnsSettingsDirection;
};

export type DnsViewsForAnAccountListInternalDnsViewsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsSettingsDnsViewResponseCollection & Schemas.DnsSettingsApiResponseCommonFailure;
}>;

export type DnsViewsForAnAccountListInternalDnsViewsVariables = {
  pathParams: DnsViewsForAnAccountListInternalDnsViewsPathParams;
  queryParams?: DnsViewsForAnAccountListInternalDnsViewsQueryParams;
} & FetcherExtraProps;

/**
 * List DNS Internal Views for an Account
 */
export const dnsViewsForAnAccountListInternalDnsViews = (
  variables: DnsViewsForAnAccountListInternalDnsViewsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsSettingsDnsViewResponseCollection,
    DnsViewsForAnAccountListInternalDnsViewsError,
    undefined,
    {},
    DnsViewsForAnAccountListInternalDnsViewsQueryParams,
    DnsViewsForAnAccountListInternalDnsViewsPathParams
  >({ url: '/accounts/{accountId}/dns_settings/views', method: 'get', ...variables, signal });

export type DnsViewsForAnAccountCreateInternalDnsViewsPathParams = {
  accountId: Schemas.DnsSettingsIdentifier;
};

export type DnsViewsForAnAccountCreateInternalDnsViewsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsSettingsDnsViewResponseSingle & Schemas.DnsSettingsApiResponseCommonFailure;
}>;

export type DnsViewsForAnAccountCreateInternalDnsViewsVariables = {
  body: Schemas.DnsSettingsDnsViewPost;
  pathParams: DnsViewsForAnAccountCreateInternalDnsViewsPathParams;
} & FetcherExtraProps;

/**
 * Create Internal DNS View for an account
 */
export const dnsViewsForAnAccountCreateInternalDnsViews = (
  variables: DnsViewsForAnAccountCreateInternalDnsViewsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsSettingsDnsViewResponseSingle,
    DnsViewsForAnAccountCreateInternalDnsViewsError,
    Schemas.DnsSettingsDnsViewPost,
    {},
    {},
    DnsViewsForAnAccountCreateInternalDnsViewsPathParams
  >({ url: '/accounts/{accountId}/dns_settings/views', method: 'post', ...variables, signal });

export type DnsViewsForAnAccountDeleteInternalDnsViewPathParams = {
  accountId: Schemas.DnsSettingsIdentifier;
  viewId: Schemas.DnsSettingsIdentifier;
};

export type DnsViewsForAnAccountDeleteInternalDnsViewError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    result: any | null;
    /**
     * @example {"code":7003,"message":"No route for the URI"}
     * @minLength 1
     */
    errors: Schemas.DnsSettingsMessages;
    messages: Schemas.DnsSettingsMessages;
    /**
     * Whether the API call was successful
     *
     * @example false
     */
    success: false;
  };
}>;

export type DnsViewsForAnAccountDeleteInternalDnsViewResponse = {
  result?: {
    id?: Schemas.DnsSettingsIdentifier;
  };
};

export type DnsViewsForAnAccountDeleteInternalDnsViewVariables = {
  pathParams: DnsViewsForAnAccountDeleteInternalDnsViewPathParams;
} & FetcherExtraProps;

/**
 * Delete an existing Internal DNS View
 */
export const dnsViewsForAnAccountDeleteInternalDnsView = (
  variables: DnsViewsForAnAccountDeleteInternalDnsViewVariables,
  signal?: AbortSignal
) =>
  fetch<
    DnsViewsForAnAccountDeleteInternalDnsViewResponse,
    DnsViewsForAnAccountDeleteInternalDnsViewError,
    undefined,
    {},
    {},
    DnsViewsForAnAccountDeleteInternalDnsViewPathParams
  >({ url: '/accounts/{accountId}/dns_settings/views/{viewId}', method: 'delete', ...variables, signal });

export type DnsViewsForAnAccountGetInternalDnsViewPathParams = {
  accountId: Schemas.DnsSettingsIdentifier;
  viewId: Schemas.DnsSettingsIdentifier;
};

export type DnsViewsForAnAccountGetInternalDnsViewError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsSettingsDnsViewResponseSingle & Schemas.DnsSettingsApiResponseCommonFailure;
}>;

export type DnsViewsForAnAccountGetInternalDnsViewVariables = {
  pathParams: DnsViewsForAnAccountGetInternalDnsViewPathParams;
} & FetcherExtraProps;

/**
 * Get DNS Internal View
 */
export const dnsViewsForAnAccountGetInternalDnsView = (
  variables: DnsViewsForAnAccountGetInternalDnsViewVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsSettingsDnsViewResponseSingle,
    DnsViewsForAnAccountGetInternalDnsViewError,
    undefined,
    {},
    {},
    DnsViewsForAnAccountGetInternalDnsViewPathParams
  >({ url: '/accounts/{accountId}/dns_settings/views/{viewId}', method: 'get', ...variables, signal });

export type DnsViewsForAnAccountUpdateInternalDnsViewPathParams = {
  accountId: Schemas.DnsSettingsIdentifier;
  viewId: Schemas.DnsSettingsIdentifier;
};

export type DnsViewsForAnAccountUpdateInternalDnsViewError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsSettingsDnsViewResponseSingle & Schemas.DnsSettingsApiResponseCommonFailure;
}>;

export type DnsViewsForAnAccountUpdateInternalDnsViewVariables = {
  body?: Schemas.DnsSettingsDnsViewPatch;
  pathParams: DnsViewsForAnAccountUpdateInternalDnsViewPathParams;
} & FetcherExtraProps;

/**
 * Update an existing Internal DNS View
 */
export const dnsViewsForAnAccountUpdateInternalDnsView = (
  variables: DnsViewsForAnAccountUpdateInternalDnsViewVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsSettingsDnsViewResponseSingle,
    DnsViewsForAnAccountUpdateInternalDnsViewError,
    Schemas.DnsSettingsDnsViewPatch,
    {},
    {},
    DnsViewsForAnAccountUpdateInternalDnsViewPathParams
  >({ url: '/accounts/{accountId}/dns_settings/views/{viewId}', method: 'patch', ...variables, signal });

export type EmailSecurityInvestigatePathParams = {
  accountId: Schemas.EmailSecurityAccountId;
};

export type EmailSecurityInvestigateQueryParams = {
  /**
   * The beginning of the search date range.
   * Defaults to `now - 30 days`.
   *
   * @format date-time
   */
  start?: string;
  /**
   * The end of the search date range.
   * Defaults to `now`.
   *
   * @format date-time
   */
  end?: string;
  /**
   * The space-delimited term used in the query. The search is case-insensitive.
   *
   * The content of the following email metadata fields are searched:
   * * alert_id
   * * CC
   * * From (envelope_from)
   * * From Name
   * * final_disposition
   * * md5 hash (of any attachment)
   * * sha1 hash (of any attachment)
   * * sha256 hash (of any attachment)
   * * name (of any attachment)
   * * Reason
   * * Received DateTime (yyyy-mm-ddThh:mm:ss)
   * * Sent DateTime (yyyy-mm-ddThh:mm:ss)
   * * ReplyTo
   * * To (envelope_to)
   * * To Name
   * * Message-ID
   * * smtp_helo_server_ip
   * * smtp_previous_hop_ip
   * * x_originating_ip
   * * Subject
   */
  query?: string;
  /**
   * Determines if the search results will include detections or not.
   *
   * @default true
   */
  detections_only?: boolean;
  /**
   * Determines if the message action log is included in the response.
   *
   * @default true
   */
  action_log?: boolean;
  /**
   * The dispositions the search filters by.
   */
  final_disposition?: 'MALICIOUS' | 'SUSPICIOUS' | 'SPOOF' | 'SPAM' | 'BULK';
  metric?: string;
  /**
   * The message actions the search filters by.
   */
  message_action?: 'PREVIEW' | 'QUARANTINE_RELEASED' | 'MOVED';
  recipient?: string;
  sender?: string;
  alert_id?: string;
  /**
   * The sender domains the search filters by.
   */
  domain?: string;
  message_id?: string;
  /**
   * The page number of paginated results.
   *
   * @default 1
   * @format int32
   * @minimum 1
   */
  page?: number;
  /**
   * The number of results per page.
   *
   * @default 20
   * @format int32
   * @minimum 1
   */
  per_page?: number;
};

export type EmailSecurityInvestigateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityInvestigateResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: Schemas.EmailSecurityMailsearchMessage[];
  result_info: Schemas.EmailSecurityResultInfo;
};

export type EmailSecurityInvestigateVariables = {
  pathParams: EmailSecurityInvestigatePathParams;
  queryParams?: EmailSecurityInvestigateQueryParams;
} & FetcherExtraProps;

/**
 * Returns information for each email that matches the search parameter(s).
 */
export const emailSecurityInvestigate = (variables: EmailSecurityInvestigateVariables, signal?: AbortSignal) =>
  fetch<
    EmailSecurityInvestigateResponse,
    EmailSecurityInvestigateError,
    undefined,
    {},
    EmailSecurityInvestigateQueryParams,
    EmailSecurityInvestigatePathParams
  >({ url: '/accounts/{accountId}/email-security/investigate', method: 'get', ...variables, signal });

export type EmailSecurityPostBulkMessageMovePathParams = {
  accountId: Schemas.EmailSecurityAccountId;
};

export type EmailSecurityPostBulkMessageMoveError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityPostBulkMessageMoveResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: Schemas.EmailSecurityRetractionResponseItem[];
};

export type EmailSecurityPostBulkMessageMoveRequestBody = {
  destination: 'Inbox' | 'JunkEmail' | 'DeletedItems' | 'RecoverableItemsDeletions' | 'RecoverableItemsPurges';
  postfix_ids: Schemas.EmailSecurityPostfixId[];
};

export type EmailSecurityPostBulkMessageMoveVariables = {
  body: EmailSecurityPostBulkMessageMoveRequestBody;
  pathParams: EmailSecurityPostBulkMessageMovePathParams;
} & FetcherExtraProps;

export const emailSecurityPostBulkMessageMove = (
  variables: EmailSecurityPostBulkMessageMoveVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityPostBulkMessageMoveResponse,
    EmailSecurityPostBulkMessageMoveError,
    EmailSecurityPostBulkMessageMoveRequestBody,
    {},
    {},
    EmailSecurityPostBulkMessageMovePathParams
  >({ url: '/accounts/{accountId}/email-security/investigate/move', method: 'post', ...variables, signal });

export type EmailSecurityPostPreviewPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
};

export type EmailSecurityPostPreviewError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityPostPreviewResponse = Schemas.EmailSecurityApiResponseCommon & {
  /**
   * @example {"screenshot":"iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAAAAXNSR0IArs4c6QAAAIRlWElmTU0AKgAAAAgABQESAAMAAAABAAEAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAIdpAAQAAAABAAAAWgAAAAAAAABgAAAAAQAAAGAAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAAGCgAwAEAAAAAQAAAGAAAAAAtVTeigAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KGV7hBwAACXtJREFUeAHtmwtwXFUZgP9zX7t3b7LNa9M2tGmLDbaWKpL6aBBJHdERQWGkU4u8CraVWmYQYWQUMSoKhZJikYo4Qqc6RVqkKmNHC0K1FGYoM9pqS4FAa9s0aTavfd3d+zq/527YSNvdzWY3m2ySc2c2595z/vOf///+e+4959wTAH5wApwAJ8AJcAKcACfACXACnAAnwAlwApwAJ8AJcAKcACfACXACnAAnwAlwApwAJ8AJcAKcACfACXACnAAnwAlwAhOJABmvzuCz158HXmUp2rCEOlhGbEdFh2qASFAgtiCKMUGgh8FM7IDDp3aQlt12Kfo6rgKAz3ylAQ3rJ/Fg39XYfyx32wUJpJpZ7wiq8LPebuGJaXfuipVKMHJ3YowsRgQC265aE+/quYf2/Le2YDM85aBOn/m7GDHX+m/4W0/B+gpUUNIBwN98rknvif4J+9urC/Tz7OqKBp66+vWSUf9dsvpx62yB0ckpyQDgLxtlS5iyyTx59OuATlFJkOrZYV9l7afItdv/XdSGMigvuQBEHmyqJRLug9DJ+gw2j3y2qIDWcOEPyFef/tHIK8+usaQCEGpdPFd0rEMQC8rZzS5OqXr+JU+JV2+5pjja02sV0mePfm7/I5+eIznm22MF3/U4/p+/L3d23LhxNL0viR7Qs/ETfo/lnIBIsHw0nU/bFiGgLbp0BfnirzanLR/hzJLoAV6QXywJ+C5cNu6N7d/7JD6zat4Is06rbswDENvU/A3sPd6Y1rqxyjRjkDj1zp7RaH5MA3CkpdkL0fAvRsPR4bbhBNtqcNvS7w233nDlxzQAgUp7E+pjPhnNyEw/duRefJLdJEU8pGLo7mptnuuTSJNHkeaBIPhMK/6Gbjm7A7ftfTPV3sGWBQpEu1ekrksxxWgQoLr6Tmbbj4tl34iOgmIbPnsLG8w9hKETajqDiX86sCXJe/1a4D4QEnfF2t/6fjq5UsojFTNQu21v0Z4UIxKA4LqL6nwyfQ3DJ8/JBR7x1wGIEmDfsVzEx1xGO3f+xeT6v7xcDEMKjmystXmRSkPtucJ3nWCy4wZ+0l7wfLsY8F2dBQWg46cfDaDVtw+MSLHsKwm98VDky8UypKAA+BVpF8T7i2Vb6eg1IiPyqE7nUN6joL51jUsw2nVBOqUTLc9TGfi965O++dLlomZvBSICyBoQpdyQVP8R4hFfgAQ+Spb8/PBwfc87AGWadrcR7x5ue+NS3qK2OxQFpcq72jGi7CXGvlGYYUAz7LGi7e6Shftba/x5ma1UB9ZDL2khlz1iuHWGOvJ+BJl65DNDKZ8I5UL17E515a4jri+OEbsoq096l2QeP3iXaR5N4MurH8SWliH5DimQqUHUezMVTah8tVx7wHUIdy6/gv3N7YlhRcHseOsOc9HBKL54S9Z1rrwCcLxlQdWEopzJGfbdGG7Y+XAyABK9MZNYxvx4t2r2vv067l55ayaZvAJgQ0zPpHAi5StT52xjnwfQ9cnWI9kfP5kcZ+8LM9i2EXfffE86kbwCMBuOmiCnXW1I18a4zCO+KuiVrZtSxqMVn5o6zyc1g+/+EF+47uYz6+Y8vg0/vPhygQjLRFH5JLXNWgx3+oGW5GazM33M61o+Z96VnpV//WOqsrF9SbInpK7zStnwVdDqmuQvbHk1VT9rAI63Lq6qJnQTNfRlkAin6kz4VKit/5ZvzZ7ksz/lrPmHy6KsF7CXQoGHp1JXOmoqUnuRMj6CEq0ff6Ay2tVDQ52TB77INmME6lecCd9FLlfUPFUg+oHqRp+Pzk08mtJ1Vg/oallQVlZR/i/a3/GBlNBkSIWqGW2iR7vCs3pX2tksvtQi2frBU1TvLnwEKChgls2ZWv75x7pOC4C7O8GbMNvYGD8wGaAD27QrT2s4KsrON6UVz+8cymd8fZUPYvLzZk9bEzjmUOJZy5VAw29J8+PXnRaAWGvjIQx3z89aM89CEmhwRMUXQVGRmOMC+x5AWOr+2NIKSwl7Ggoish8lRKDsSxplTVnuTwTU2aZzQwCMszehxXYu2AIhCQDKpvvERAImUGIK7jXSePJHWWpRHWw7wQYLcaDolplA0GLnukWddvmmpw+khpnDcQvfXF8DAlkKhnkhmEY52IYKlqGiZWho2z5KDYWtEPtpondGRr3eKlDKFsqDAQhvaLxfCHV/J2OFQgpkL2g152mw6rl4Pg4X0nSx6iL7PwQ4tF0GpXOAYchDIdIxMFIKHkRQKz2m8W4nWzcqz2SDUvfhS5KVO+9vXFhm9B5gd0gm2YLzhepze8G2goiCA6J7dxN31y0bxxKbBcUdz9psJ3ryjgc2d2Gb0m0KaDGTbHbHs/7Ozh1IUGC5wHoDEsthZQjUrWMTBMtheQSphQJYyFKB9Q6Kznup24Mck3Uvk1IITaP73iAtTFkeB+6/oxao8jHWA2ex3lVLEQPEtmqpZVewfxKpQjOmYLx/OpjR6mzqlfqFTyQDEHrogufESN/l2YQnXBmLuhyY+YpBjS/5177WM5R/+I9bA+Cl66ye0DUYbfcMJZ9LuVgz/wQJbrh4uho+wb4R5nUz5NJOact4/WznQ8VHylbuOZDJUNx97Vazu2P5SDMi5bNAKpetpfZkhe8SdyeYEfUVdlZ2ZgBwx5UVjoL7zWB7/ZllI3GNiW425vDVrBkJZeNaR/iUFnns4g+93wd89qpqC+Jtjh4uCvxkW1YMBDNhfvD9DU/Wc0VwBoff+FKz5JDwPrTNrC/Rglm5/zyIkVMF65kICmyHzRPeO5w+2Ow4dE7qumgpmwsIk2JXQw4E43H9n65Y75am8x2HfC2HKgWLEG+1I4BU1L2nBRs5GgrcLZM1t+9vd9vy+jx3j0abbhuypu0TSNnkWPbJBpWtV/w6VS6gsDR1XvQU6Vapa4qkJvrVaRTEMFvAsB2drcewQ/Q5BNj0JOSjA1NtljdFFwY/Srgzlwp1QNaVTx1inNU77dV12gU4qjSoI1XHictn5dla71l5KfnBdIjXl1U2oNcMKTh9SgfaPazthoHaXjswuBQ/8/ZX4ymdHVFHU+tmimoo4Ul4JBmdBFt5khDVBJtbS1junvt0REtO/tx6RLaSjIg+kKZ0oclktCibx//fP0HzCIIlCwnPFLn2+LHJsa8nBYSnnAAnwAlwApwAJ8AJcAKcACfACXACnAAnwAlwApwAJ8AJcAKcACfACXACnAAnwAlwApwAJ8AJcAKcACfACXACk4DA/wDoepVZ2hARhAAAAABJRU5ErkJggg=="}
   */
  result: {
    /**
     * A base64 encoded PNG image of the email.
     */
    screenshot: string;
  };
};

export type EmailSecurityPostPreviewRequestBody = {
  postfix_id: Schemas.EmailSecurityPostfixId;
};

export type EmailSecurityPostPreviewVariables = {
  body: EmailSecurityPostPreviewRequestBody;
  pathParams: EmailSecurityPostPreviewPathParams;
} & FetcherExtraProps;

export const emailSecurityPostPreview = (variables: EmailSecurityPostPreviewVariables, signal?: AbortSignal) =>
  fetch<
    EmailSecurityPostPreviewResponse,
    EmailSecurityPostPreviewError,
    EmailSecurityPostPreviewRequestBody,
    {},
    {},
    EmailSecurityPostPreviewPathParams
  >({ url: '/accounts/{accountId}/email-security/investigate/preview', method: 'post', ...variables, signal });

export type EmailSecurityPostReleasePathParams = {
  accountId: Schemas.EmailSecurityAccountId;
};

export type EmailSecurityPostReleaseError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityPostReleaseResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: Schemas.EmailSecurityReleaseResponse[];
};

export type EmailSecurityPostReleaseRequestBody = Schemas.EmailSecurityPostfixId[];

export type EmailSecurityPostReleaseVariables = {
  body?: EmailSecurityPostReleaseRequestBody;
  pathParams: EmailSecurityPostReleasePathParams;
} & FetcherExtraProps;

export const emailSecurityPostRelease = (variables: EmailSecurityPostReleaseVariables, signal?: AbortSignal) =>
  fetch<
    EmailSecurityPostReleaseResponse,
    EmailSecurityPostReleaseError,
    EmailSecurityPostReleaseRequestBody,
    {},
    {},
    EmailSecurityPostReleasePathParams
  >({ url: '/accounts/{accountId}/email-security/investigate/release', method: 'post', ...variables, signal });

export type EmailSecurityGetMessagePathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  /**
   * @example 4Njp3P0STMz2c02Q
   */
  postfixId: string;
};

export type EmailSecurityGetMessageError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityGetMessageResponse = Schemas.EmailSecurityApiResponseCommon & {
  /**
   * @example {"action_log":[],"alert_id":"4Njp3P0STMz2c02Q-2022-12-30T02:44:49","client_recipients":["email@example.com"],"delivery_mode":"DIRECT","detection_reasons":["Selector is a source of spam/uce : Smtp-Helo-Server-Ip=<b>127.0.0[dot]186</b>"],"edf_hash":null,"final_disposition":"MALICIOUS","from":"d1994@example.com","from_name":"Sender Name","id":"47JJcT1w6GztQV7-email@example.com","is_phish_submission":false,"is_quarantined":false,"message_id":"<4VAZPrAdg7IGNxdt1DWRNu0gvOeL_iZiwP4BQfo4DaE.Yw-woXuugQbeFhBpzwFQtqq_v2v1HOKznoMBqbciQpE@example.com>","postfix_id":"47JJcT1w6GztQV7","sent_date":"2019-11-21T00:22:01","subject":"listen, I highly recommend u to read that email, just to ensure not a thing will take place","threat_categories":["IPReputation","ASNReputation"],"to":["email@example.com"],"to_name":["Recipient Name"],"ts":"2019-11-20T23:22:01","validation":{"comment":null,"dkim":"pass","dmarc":"none","spf":"fail"}}
   */
  result: {
    action_log: void;
    alert_id?: string | null;
    client_recipients: string[];
    delivery_mode?: Schemas.EmailSecurityMessageDeliveryMode & (string | null);
    detection_reasons: string[];
    edf_hash?: string | null;
    final_disposition?: Schemas.EmailSecurityDispositionLabel & (string | null);
    from?: string | null;
    from_name?: string | null;
    is_phish_submission: boolean;
    is_quarantined: boolean;
    message_id?: string | null;
    postfix_id: Schemas.EmailSecurityPostfixId;
    sent_date?: string | null;
    subject?: string | null;
    threat_categories?: string[] | null;
    to?: string[] | null;
    to_name?: string[] | null;
    ts?: string;
    validation?: {
      comment?: string | null;
      dkim?: Schemas.EmailSecurityValidationStatus & (string | null);
      dmarc?: Schemas.EmailSecurityValidationStatus & (string | null);
      spf?: Schemas.EmailSecurityValidationStatus & (string | null);
    } | null;
    id: string;
  };
};

export type EmailSecurityGetMessageVariables = {
  pathParams: EmailSecurityGetMessagePathParams;
} & FetcherExtraProps;

export const emailSecurityGetMessage = (variables: EmailSecurityGetMessageVariables, signal?: AbortSignal) =>
  fetch<
    EmailSecurityGetMessageResponse,
    EmailSecurityGetMessageError,
    undefined,
    {},
    {},
    EmailSecurityGetMessagePathParams
  >({ url: '/accounts/{accountId}/email-security/investigate/{postfixId}', method: 'get', ...variables, signal });

export type EmailSecurityGetMessageDetectionsPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  /**
   * @example 4Njp3P0STMz2c02Q
   */
  postfixId: string;
};

export type EmailSecurityGetMessageDetectionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityGetMessageDetectionsResponse = Schemas.EmailSecurityApiResponseCommon & {
  /**
   * @example {"action":"QUARANTINED","attachments":[],"final_disposition":"MALICIOUS","headers":[{"name":"From","value":"Sender Name <d1994@example.com>"},{"name":"Subject","value":"listen, I highly recommend u to read that email, just to ensure not a thing will take place"}],"links":[{"href":"https://example.com","text":"Click here!"}],"sender_info":{"as_name":"AS0","as_number":0,"geo":"US/-/-","ip":"127.0.0.1","pld":"example.com"},"threat_categories":[{"description":null,"id":1234,"name":"IP Reputation"}],"validation":{"comment":null,"dkim":"pass","dmarc":"none","spf":"fail"}}
   */
  result: {
    action: string;
    attachments: Schemas.EmailSecurityAttachment[];
    final_disposition?: Schemas.EmailSecurityDispositionLabel & (string | null);
    headers: Schemas.EmailSecurityMessageHeader[];
    links: Schemas.EmailSecurityLink[];
    sender_info: {
      /**
       * The name of the autonomous system.
       */
      as_name?: string | null;
      /**
       * The number of the autonomous system.
       *
       * @format int64
       */
      as_number?: number | null;
      geo?: string | null;
      ip?: string | null;
      pld?: string | null;
    };
    threat_categories: Schemas.EmailSecurityThreatCategory[];
    validation: {
      comment?: string | null;
      dkim?: Schemas.EmailSecurityValidationStatus & (string | null);
      dmarc?: Schemas.EmailSecurityValidationStatus & (string | null);
      spf?: Schemas.EmailSecurityValidationStatus & (string | null);
    };
  };
};

export type EmailSecurityGetMessageDetectionsVariables = {
  pathParams: EmailSecurityGetMessageDetectionsPathParams;
} & FetcherExtraProps;

/**
 * Returns detection details such as threat categories and sender information for non-benign messages.
 */
export const emailSecurityGetMessageDetections = (
  variables: EmailSecurityGetMessageDetectionsVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityGetMessageDetectionsResponse,
    EmailSecurityGetMessageDetectionsError,
    undefined,
    {},
    {},
    EmailSecurityGetMessageDetectionsPathParams
  >({
    url: '/accounts/{accountId}/email-security/investigate/{postfixId}/detections',
    method: 'get',
    ...variables,
    signal
  });

export type EmailSecurityPostMessageMovePathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  /**
   * @example 4Njp3P0STMz2c02Q
   */
  postfixId: string;
};

export type EmailSecurityPostMessageMoveError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityPostMessageMoveResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: Schemas.EmailSecurityRetractionResponseItem[];
};

export type EmailSecurityPostMessageMoveRequestBody = {
  destination: 'Inbox' | 'JunkEmail' | 'DeletedItems' | 'RecoverableItemsDeletions' | 'RecoverableItemsPurges';
};

export type EmailSecurityPostMessageMoveVariables = {
  body: EmailSecurityPostMessageMoveRequestBody;
  pathParams: EmailSecurityPostMessageMovePathParams;
} & FetcherExtraProps;

export const emailSecurityPostMessageMove = (variables: EmailSecurityPostMessageMoveVariables, signal?: AbortSignal) =>
  fetch<
    EmailSecurityPostMessageMoveResponse,
    EmailSecurityPostMessageMoveError,
    EmailSecurityPostMessageMoveRequestBody,
    {},
    {},
    EmailSecurityPostMessageMovePathParams
  >({ url: '/accounts/{accountId}/email-security/investigate/{postfixId}/move', method: 'post', ...variables, signal });

export type EmailSecurityGetMessagePreviewPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  /**
   * @example 4Njp3P0STMz2c02Q
   */
  postfixId: string;
};

export type EmailSecurityGetMessagePreviewError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityGetMessagePreviewResponse = Schemas.EmailSecurityApiResponseCommon & {
  /**
   * @example {"screenshot":"iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAAAAXNSR0IArs4c6QAAAIRlWElmTU0AKgAAAAgABQESAAMAAAABAAEAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAIdpAAQAAAABAAAAWgAAAAAAAABgAAAAAQAAAGAAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAAGCgAwAEAAAAAQAAAGAAAAAAtVTeigAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KGV7hBwAACXtJREFUeAHtmwtwXFUZgP9zX7t3b7LNa9M2tGmLDbaWKpL6aBBJHdERQWGkU4u8CraVWmYQYWQUMSoKhZJikYo4Qqc6RVqkKmNHC0K1FGYoM9pqS4FAa9s0aTavfd3d+zq/527YSNvdzWY3m2ySc2c2595z/vOf///+e+4959wTAH5wApwAJ8AJcAKcACfACXACnAAnwAlwApwAJ8AJcAKcACfACXACnAAnwAlwApwAJ8AJcAKcACfACXACnAAnwAlwAhOJABmvzuCz158HXmUp2rCEOlhGbEdFh2qASFAgtiCKMUGgh8FM7IDDp3aQlt12Kfo6rgKAz3ylAQ3rJ/Fg39XYfyx32wUJpJpZ7wiq8LPebuGJaXfuipVKMHJ3YowsRgQC265aE+/quYf2/Le2YDM85aBOn/m7GDHX+m/4W0/B+gpUUNIBwN98rknvif4J+9urC/Tz7OqKBp66+vWSUf9dsvpx62yB0ckpyQDgLxtlS5iyyTx59OuATlFJkOrZYV9l7afItdv/XdSGMigvuQBEHmyqJRLug9DJ+gw2j3y2qIDWcOEPyFef/tHIK8+usaQCEGpdPFd0rEMQC8rZzS5OqXr+JU+JV2+5pjja02sV0mePfm7/I5+eIznm22MF3/U4/p+/L3d23LhxNL0viR7Qs/ETfo/lnIBIsHw0nU/bFiGgLbp0BfnirzanLR/hzJLoAV6QXywJ+C5cNu6N7d/7JD6zat4Is06rbswDENvU/A3sPd6Y1rqxyjRjkDj1zp7RaH5MA3CkpdkL0fAvRsPR4bbhBNtqcNvS7w233nDlxzQAgUp7E+pjPhnNyEw/duRefJLdJEU8pGLo7mptnuuTSJNHkeaBIPhMK/6Gbjm7A7ftfTPV3sGWBQpEu1ekrksxxWgQoLr6Tmbbj4tl34iOgmIbPnsLG8w9hKETajqDiX86sCXJe/1a4D4QEnfF2t/6fjq5UsojFTNQu21v0Z4UIxKA4LqL6nwyfQ3DJ8/JBR7x1wGIEmDfsVzEx1xGO3f+xeT6v7xcDEMKjmystXmRSkPtucJ3nWCy4wZ+0l7wfLsY8F2dBQWg46cfDaDVtw+MSLHsKwm98VDky8UypKAA+BVpF8T7i2Vb6eg1IiPyqE7nUN6joL51jUsw2nVBOqUTLc9TGfi965O++dLlomZvBSICyBoQpdyQVP8R4hFfgAQ+Spb8/PBwfc87AGWadrcR7x5ue+NS3qK2OxQFpcq72jGi7CXGvlGYYUAz7LGi7e6Shftba/x5ma1UB9ZDL2khlz1iuHWGOvJ+BJl65DNDKZ8I5UL17E515a4jri+OEbsoq096l2QeP3iXaR5N4MurH8SWliH5DimQqUHUezMVTah8tVx7wHUIdy6/gv3N7YlhRcHseOsOc9HBKL54S9Z1rrwCcLxlQdWEopzJGfbdGG7Y+XAyABK9MZNYxvx4t2r2vv067l55ayaZvAJgQ0zPpHAi5StT52xjnwfQ9cnWI9kfP5kcZ+8LM9i2EXfffE86kbwCMBuOmiCnXW1I18a4zCO+KuiVrZtSxqMVn5o6zyc1g+/+EF+47uYz6+Y8vg0/vPhygQjLRFH5JLXNWgx3+oGW5GazM33M61o+Z96VnpV//WOqsrF9SbInpK7zStnwVdDqmuQvbHk1VT9rAI63Lq6qJnQTNfRlkAin6kz4VKit/5ZvzZ7ksz/lrPmHy6KsF7CXQoGHp1JXOmoqUnuRMj6CEq0ff6Ay2tVDQ52TB77INmME6lecCd9FLlfUPFUg+oHqRp+Pzk08mtJ1Vg/oallQVlZR/i/a3/GBlNBkSIWqGW2iR7vCs3pX2tksvtQi2frBU1TvLnwEKChgls2ZWv75x7pOC4C7O8GbMNvYGD8wGaAD27QrT2s4KsrON6UVz+8cymd8fZUPYvLzZk9bEzjmUOJZy5VAw29J8+PXnRaAWGvjIQx3z89aM89CEmhwRMUXQVGRmOMC+x5AWOr+2NIKSwl7Ggoish8lRKDsSxplTVnuTwTU2aZzQwCMszehxXYu2AIhCQDKpvvERAImUGIK7jXSePJHWWpRHWw7wQYLcaDolplA0GLnukWddvmmpw+khpnDcQvfXF8DAlkKhnkhmEY52IYKlqGiZWho2z5KDYWtEPtpondGRr3eKlDKFsqDAQhvaLxfCHV/J2OFQgpkL2g152mw6rl4Pg4X0nSx6iL7PwQ4tF0GpXOAYchDIdIxMFIKHkRQKz2m8W4nWzcqz2SDUvfhS5KVO+9vXFhm9B5gd0gm2YLzhepze8G2goiCA6J7dxN31y0bxxKbBcUdz9psJ3ryjgc2d2Gb0m0KaDGTbHbHs/7Ozh1IUGC5wHoDEsthZQjUrWMTBMtheQSphQJYyFKB9Q6Kznup24Mck3Uvk1IITaP73iAtTFkeB+6/oxao8jHWA2ex3lVLEQPEtmqpZVewfxKpQjOmYLx/OpjR6mzqlfqFTyQDEHrogufESN/l2YQnXBmLuhyY+YpBjS/5177WM5R/+I9bA+Cl66ye0DUYbfcMJZ9LuVgz/wQJbrh4uho+wb4R5nUz5NJOact4/WznQ8VHylbuOZDJUNx97Vazu2P5SDMi5bNAKpetpfZkhe8SdyeYEfUVdlZ2ZgBwx5UVjoL7zWB7/ZllI3GNiW425vDVrBkJZeNaR/iUFnns4g+93wd89qpqC+Jtjh4uCvxkW1YMBDNhfvD9DU/Wc0VwBoff+FKz5JDwPrTNrC/Rglm5/zyIkVMF65kICmyHzRPeO5w+2Ow4dE7qumgpmwsIk2JXQw4E43H9n65Y75am8x2HfC2HKgWLEG+1I4BU1L2nBRs5GgrcLZM1t+9vd9vy+jx3j0abbhuypu0TSNnkWPbJBpWtV/w6VS6gsDR1XvQU6Vapa4qkJvrVaRTEMFvAsB2drcewQ/Q5BNj0JOSjA1NtljdFFwY/Srgzlwp1QNaVTx1inNU77dV12gU4qjSoI1XHictn5dla71l5KfnBdIjXl1U2oNcMKTh9SgfaPazthoHaXjswuBQ/8/ZX4ymdHVFHU+tmimoo4Ul4JBmdBFt5khDVBJtbS1junvt0REtO/tx6RLaSjIg+kKZ0oclktCibx//fP0HzCIIlCwnPFLn2+LHJsa8nBYSnnAAnwAlwApwAJ8AJcAKcACfACXACnAAnwAlwApwAJ8AJcAKcACfACXACnAAnwAlwApwAJ8AJcAKcACfACXACk4DA/wDoepVZ2hARhAAAAABJRU5ErkJggg=="}
   */
  result: {
    /**
     * A base64 encoded PNG image of the email.
     */
    screenshot: string;
  };
};

export type EmailSecurityGetMessagePreviewVariables = {
  pathParams: EmailSecurityGetMessagePreviewPathParams;
} & FetcherExtraProps;

/**
 * Returns a preview of the message body as a base64 encoded PNG image for non-benign messages.
 */
export const emailSecurityGetMessagePreview = (
  variables: EmailSecurityGetMessagePreviewVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityGetMessagePreviewResponse,
    EmailSecurityGetMessagePreviewError,
    undefined,
    {},
    {},
    EmailSecurityGetMessagePreviewPathParams
  >({
    url: '/accounts/{accountId}/email-security/investigate/{postfixId}/preview',
    method: 'get',
    ...variables,
    signal
  });

export type EmailSecurityGetMessageRawPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  /**
   * @example 4Njp3P0STMz2c02Q
   */
  postfixId: string;
};

export type EmailSecurityGetMessageRawError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityGetMessageRawResponse = Schemas.EmailSecurityApiResponseCommon & {
  /**
   * @example {"raw":"MIME-Version: 1.0\nContent-Type: text/plain; charset=\"utf-8\"\n\nFrom: sender@example.com\nTo: recipient@example.com\nSubject: Test Email\n\nThis is a test email."}
   */
  result: {
    /**
     * A UTF-8 encoded eml file of the email.
     */
    raw: string;
  };
};

export type EmailSecurityGetMessageRawVariables = {
  pathParams: EmailSecurityGetMessageRawPathParams;
} & FetcherExtraProps;

/**
 * Returns the raw eml of any non-benign message.
 */
export const emailSecurityGetMessageRaw = (variables: EmailSecurityGetMessageRawVariables, signal?: AbortSignal) =>
  fetch<
    EmailSecurityGetMessageRawResponse,
    EmailSecurityGetMessageRawError,
    undefined,
    {},
    {},
    EmailSecurityGetMessageRawPathParams
  >({ url: '/accounts/{accountId}/email-security/investigate/{postfixId}/raw', method: 'get', ...variables, signal });

export type EmailSecurityPostReclassifyPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  /**
   * @example 4Njp3P0STMz2c02Q
   */
  postfixId: string;
};

export type EmailSecurityPostReclassifyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityPostReclassifyResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: Record<string, any>;
};

export type EmailSecurityPostReclassifyRequestBody = {
  /**
   * Base64 encoded content of the EML file
   */
  eml_content?: string | null;
  expected_disposition: 'NONE' | 'BULK' | 'MALICIOUS' | 'SPAM' | 'SPOOF' | 'SUSPICIOUS';
};

export type EmailSecurityPostReclassifyVariables = {
  body: EmailSecurityPostReclassifyRequestBody;
  pathParams: EmailSecurityPostReclassifyPathParams;
} & FetcherExtraProps;

export const emailSecurityPostReclassify = (variables: EmailSecurityPostReclassifyVariables, signal?: AbortSignal) =>
  fetch<
    EmailSecurityPostReclassifyResponse,
    EmailSecurityPostReclassifyError,
    EmailSecurityPostReclassifyRequestBody,
    {},
    {},
    EmailSecurityPostReclassifyPathParams
  >({
    url: '/accounts/{accountId}/email-security/investigate/{postfixId}/reclassify',
    method: 'post',
    ...variables,
    signal
  });

export type EmailSecurityGetMessageTracePathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  /**
   * @example 4Njp3P0STMz2c02Q
   */
  postfixId: string;
};

export type EmailSecurityGetMessageTraceError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityGetMessageTraceResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: {
    inbound: {
      lines?: Schemas.EmailSecurityTraceLine[] | null;
    };
    outbound: {
      lines?: Schemas.EmailSecurityTraceLine[] | null;
    };
  };
};

export type EmailSecurityGetMessageTraceVariables = {
  pathParams: EmailSecurityGetMessageTracePathParams;
} & FetcherExtraProps;

export const emailSecurityGetMessageTrace = (variables: EmailSecurityGetMessageTraceVariables, signal?: AbortSignal) =>
  fetch<
    EmailSecurityGetMessageTraceResponse,
    EmailSecurityGetMessageTraceError,
    undefined,
    {},
    {},
    EmailSecurityGetMessageTracePathParams
  >({ url: '/accounts/{accountId}/email-security/investigate/{postfixId}/trace', method: 'get', ...variables, signal });

export type EmailSecurityListAllowPoliciesPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
};

export type EmailSecurityListAllowPoliciesQueryParams = {
  /**
   * The page number of paginated results.
   *
   * @default 1
   * @format int32
   * @minimum 1
   */
  page?: number;
  /**
   * The number of results per page.
   *
   * @default 20
   * @format int32
   * @minimum 1
   */
  per_page?: number;
  /**
   * The field to sort by.
   */
  order?: 'pattern' | 'created_at';
  /**
   * The sorting direction.
   */
  direction?: Schemas.EmailSecuritySortingDirection;
  /**
   * Allows searching in multiple properties of a record simultaneously.
   * This parameter is intended for human users, not automation. Its exact
   * behavior is intentionally left unspecified and is subject to change
   * in the future.
   */
  search?: string;
  is_sender?: boolean;
  is_trusted_sender?: boolean;
  is_recipient?: boolean;
  is_exempt_recipient?: boolean;
  is_spoof?: boolean;
  is_acceptable_sender?: boolean;
  verify_sender?: boolean;
  pattern_type?: Schemas.EmailSecurityPatternType;
};

export type EmailSecurityListAllowPoliciesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityListAllowPoliciesResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: Schemas.EmailSecurityAllowPolicy[];
  result_info: Schemas.EmailSecurityResultInfo;
};

export type EmailSecurityListAllowPoliciesVariables = {
  pathParams: EmailSecurityListAllowPoliciesPathParams;
  queryParams?: EmailSecurityListAllowPoliciesQueryParams;
} & FetcherExtraProps;

/**
 * Lists, searches, and sorts an account’s email allow policies.
 */
export const emailSecurityListAllowPolicies = (
  variables: EmailSecurityListAllowPoliciesVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityListAllowPoliciesResponse,
    EmailSecurityListAllowPoliciesError,
    undefined,
    {},
    EmailSecurityListAllowPoliciesQueryParams,
    EmailSecurityListAllowPoliciesPathParams
  >({ url: '/accounts/{accountId}/email-security/settings/allow_policies', method: 'get', ...variables, signal });

export type EmailSecurityCreateAllowPolicyPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
};

export type EmailSecurityCreateAllowPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityCreateAllowPolicyResponse = Schemas.EmailSecurityApiResponseCommon & {
  /**
   * @example {"comments":"Trust all messages send from test@example.com","created_at":"2023-11-14T22:13:20Z","id":2401,"is_acceptable_sender":false,"is_exempt_recipient":false,"is_recipient":false,"is_regex":false,"is_sender":true,"is_spoof":false,"is_trusted_sender":true,"last_modified":"2023-11-14T22:13:20Z","pattern":"test@example.com","pattern_type":"EMAIL","verify_sender":true}
   */
  result: {
    /**
     * @maxLength 1024
     */
    comments?: string | null;
    /**
     * Messages from this sender will be exempted from Spam, Spoof and Bulk dispositions.
     * Note: This will not exempt messages with Malicious or Suspicious dispositions.
     */
    is_acceptable_sender?: boolean;
    /**
     * Messages to this recipient will bypass all detections.
     */
    is_exempt_recipient?: boolean;
    /**
     * @deprecated true
     */
    is_recipient?: boolean;
    is_regex: boolean;
    /**
     * @deprecated true
     */
    is_sender?: boolean;
    /**
     * @deprecated true
     */
    is_spoof?: boolean;
    /**
     * Messages from this sender will bypass all detections and link following.
     */
    is_trusted_sender?: boolean;
    /**
     * @maxLength 1024
     * @minLength 1
     */
    pattern: string;
    pattern_type: Schemas.EmailSecurityPatternType;
    /**
     * Enforce DMARC, SPF or DKIM authentication.
     * When on, Email Security only honors policies that pass authentication.
     */
    verify_sender: boolean;
    /**
     * @format date-time
     */
    created_at: string;
    id: Schemas.EmailSecurityAllowPolicyId;
    /**
     * @format date-time
     */
    last_modified: string;
  };
};

export type EmailSecurityCreateAllowPolicyVariables = {
  body: Schemas.EmailSecurityCreateAllowPolicy;
  pathParams: EmailSecurityCreateAllowPolicyPathParams;
} & FetcherExtraProps;

export const emailSecurityCreateAllowPolicy = (
  variables: EmailSecurityCreateAllowPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityCreateAllowPolicyResponse,
    EmailSecurityCreateAllowPolicyError,
    Schemas.EmailSecurityCreateAllowPolicy,
    {},
    {},
    EmailSecurityCreateAllowPolicyPathParams
  >({ url: '/accounts/{accountId}/email-security/settings/allow_policies', method: 'post', ...variables, signal });

export type EmailSecurityDeleteAllowPolicyPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  policyId: Schemas.EmailSecurityAllowPolicyId;
};

export type EmailSecurityDeleteAllowPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityDeleteAllowPolicyResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: {
    /**
     * The unique identifier for the allow policy.
     *
     * @example 2401
     * @format int32
     */
    id: number;
  };
};

export type EmailSecurityDeleteAllowPolicyVariables = {
  pathParams: EmailSecurityDeleteAllowPolicyPathParams;
} & FetcherExtraProps;

export const emailSecurityDeleteAllowPolicy = (
  variables: EmailSecurityDeleteAllowPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityDeleteAllowPolicyResponse,
    EmailSecurityDeleteAllowPolicyError,
    undefined,
    {},
    {},
    EmailSecurityDeleteAllowPolicyPathParams
  >({
    url: '/accounts/{accountId}/email-security/settings/allow_policies/{policyId}',
    method: 'delete',
    ...variables,
    signal
  });

export type EmailSecurityGetAllowPolicyPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  policyId: Schemas.EmailSecurityAllowPolicyId;
};

export type EmailSecurityGetAllowPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityGetAllowPolicyResponse = Schemas.EmailSecurityApiResponseCommon & {
  /**
   * @example {"comments":"Trust all messages send from test@example.com","created_at":"2023-11-14T22:13:20Z","id":2401,"is_acceptable_sender":false,"is_exempt_recipient":false,"is_recipient":false,"is_regex":false,"is_sender":true,"is_spoof":false,"is_trusted_sender":true,"last_modified":"2023-11-14T22:13:20Z","pattern":"test@example.com","pattern_type":"EMAIL","verify_sender":true}
   */
  result: {
    /**
     * @maxLength 1024
     */
    comments?: string | null;
    /**
     * Messages from this sender will be exempted from Spam, Spoof and Bulk dispositions.
     * Note: This will not exempt messages with Malicious or Suspicious dispositions.
     */
    is_acceptable_sender?: boolean;
    /**
     * Messages to this recipient will bypass all detections.
     */
    is_exempt_recipient?: boolean;
    /**
     * @deprecated true
     */
    is_recipient?: boolean;
    is_regex: boolean;
    /**
     * @deprecated true
     */
    is_sender?: boolean;
    /**
     * @deprecated true
     */
    is_spoof?: boolean;
    /**
     * Messages from this sender will bypass all detections and link following.
     */
    is_trusted_sender?: boolean;
    /**
     * @maxLength 1024
     * @minLength 1
     */
    pattern: string;
    pattern_type: Schemas.EmailSecurityPatternType;
    /**
     * Enforce DMARC, SPF or DKIM authentication.
     * When on, Email Security only honors policies that pass authentication.
     */
    verify_sender: boolean;
    /**
     * @format date-time
     */
    created_at: string;
    id: Schemas.EmailSecurityAllowPolicyId;
    /**
     * @format date-time
     */
    last_modified: string;
  };
};

export type EmailSecurityGetAllowPolicyVariables = {
  pathParams: EmailSecurityGetAllowPolicyPathParams;
} & FetcherExtraProps;

export const emailSecurityGetAllowPolicy = (variables: EmailSecurityGetAllowPolicyVariables, signal?: AbortSignal) =>
  fetch<
    EmailSecurityGetAllowPolicyResponse,
    EmailSecurityGetAllowPolicyError,
    undefined,
    {},
    {},
    EmailSecurityGetAllowPolicyPathParams
  >({
    url: '/accounts/{accountId}/email-security/settings/allow_policies/{policyId}',
    method: 'get',
    ...variables,
    signal
  });

export type EmailSecurityUpdateAllowPolicyPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  policyId: Schemas.EmailSecurityAllowPolicyId;
};

export type EmailSecurityUpdateAllowPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityUpdateAllowPolicyResponse = Schemas.EmailSecurityApiResponseCommon & {
  /**
   * @example {"comments":"Trust all messages send from test@example.com","created_at":"2023-11-14T22:13:20Z","id":2401,"is_acceptable_sender":false,"is_exempt_recipient":false,"is_recipient":false,"is_regex":false,"is_sender":true,"is_spoof":false,"is_trusted_sender":true,"last_modified":"2023-11-14T22:13:20Z","pattern":"test@example.com","pattern_type":"EMAIL","verify_sender":true}
   */
  result: {
    /**
     * @maxLength 1024
     */
    comments?: string | null;
    /**
     * Messages from this sender will be exempted from Spam, Spoof and Bulk dispositions.
     * Note: This will not exempt messages with Malicious or Suspicious dispositions.
     */
    is_acceptable_sender?: boolean;
    /**
     * Messages to this recipient will bypass all detections.
     */
    is_exempt_recipient?: boolean;
    /**
     * @deprecated true
     */
    is_recipient?: boolean;
    is_regex: boolean;
    /**
     * @deprecated true
     */
    is_sender?: boolean;
    /**
     * @deprecated true
     */
    is_spoof?: boolean;
    /**
     * Messages from this sender will bypass all detections and link following.
     */
    is_trusted_sender?: boolean;
    /**
     * @maxLength 1024
     * @minLength 1
     */
    pattern: string;
    pattern_type: Schemas.EmailSecurityPatternType;
    /**
     * Enforce DMARC, SPF or DKIM authentication.
     * When on, Email Security only honors policies that pass authentication.
     */
    verify_sender: boolean;
    /**
     * @format date-time
     */
    created_at: string;
    id: Schemas.EmailSecurityAllowPolicyId;
    /**
     * @format date-time
     */
    last_modified: string;
  };
};

export type EmailSecurityUpdateAllowPolicyVariables = {
  body?: Schemas.EmailSecurityUpdateAllowPolicy;
  pathParams: EmailSecurityUpdateAllowPolicyPathParams;
} & FetcherExtraProps;

export const emailSecurityUpdateAllowPolicy = (
  variables: EmailSecurityUpdateAllowPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityUpdateAllowPolicyResponse,
    EmailSecurityUpdateAllowPolicyError,
    Schemas.EmailSecurityUpdateAllowPolicy,
    {},
    {},
    EmailSecurityUpdateAllowPolicyPathParams
  >({
    url: '/accounts/{accountId}/email-security/settings/allow_policies/{policyId}',
    method: 'patch',
    ...variables,
    signal
  });

export type EmailSecurityListBlockedSendersPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
};

export type EmailSecurityListBlockedSendersQueryParams = {
  /**
   * The page number of paginated results.
   *
   * @default 1
   * @format int32
   * @minimum 1
   */
  page?: number;
  /**
   * The number of results per page.
   *
   * @default 20
   * @format int32
   * @minimum 1
   */
  per_page?: number;
  /**
   * The field to sort by.
   */
  order?: 'pattern' | 'created_at';
  /**
   * The sorting direction.
   */
  direction?: Schemas.EmailSecuritySortingDirection;
  /**
   * Allows searching in multiple properties of a record simultaneously.
   * This parameter is intended for human users, not automation. Its exact
   * behavior is intentionally left unspecified and is subject to change
   * in the future.
   */
  search?: string;
  pattern_type?: Schemas.EmailSecurityPatternType;
};

export type EmailSecurityListBlockedSendersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityListBlockedSendersResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: Schemas.EmailSecurityBlockedSender[];
  result_info: Schemas.EmailSecurityResultInfo;
};

export type EmailSecurityListBlockedSendersVariables = {
  pathParams: EmailSecurityListBlockedSendersPathParams;
  queryParams?: EmailSecurityListBlockedSendersQueryParams;
} & FetcherExtraProps;

export const emailSecurityListBlockedSenders = (
  variables: EmailSecurityListBlockedSendersVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityListBlockedSendersResponse,
    EmailSecurityListBlockedSendersError,
    undefined,
    {},
    EmailSecurityListBlockedSendersQueryParams,
    EmailSecurityListBlockedSendersPathParams
  >({ url: '/accounts/{accountId}/email-security/settings/block_senders', method: 'get', ...variables, signal });

export type EmailSecurityCreateBlockedSenderPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
};

export type EmailSecurityCreateBlockedSenderError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityCreateBlockedSenderResponse = Schemas.EmailSecurityApiResponseCommon & {
  /**
   * @example {"comments":"block sender with email test@example.com","created_at":"2023-11-14T22:13:20Z","id":2402,"is_regex":false,"last_modified":"2023-11-14T22:13:20Z","pattern":"test@example.com","pattern_type":"EMAIL"}
   */
  result: {
    /**
     * @maxLength 1024
     */
    comments?: string | null;
    is_regex?: boolean;
    /**
     * @maxLength 1024
     * @minLength 1
     */
    pattern?: string;
    pattern_type?: Schemas.EmailSecurityPatternType;
    /**
     * @format date-time
     */
    created_at: string;
    id: Schemas.EmailSecurityBlockedSenderId;
    /**
     * @format date-time
     */
    last_modified: string;
  };
};

export type EmailSecurityCreateBlockedSenderVariables = {
  body: Schemas.EmailSecurityCreateBlockedSender;
  pathParams: EmailSecurityCreateBlockedSenderPathParams;
} & FetcherExtraProps;

export const emailSecurityCreateBlockedSender = (
  variables: EmailSecurityCreateBlockedSenderVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityCreateBlockedSenderResponse,
    EmailSecurityCreateBlockedSenderError,
    Schemas.EmailSecurityCreateBlockedSender,
    {},
    {},
    EmailSecurityCreateBlockedSenderPathParams
  >({ url: '/accounts/{accountId}/email-security/settings/block_senders', method: 'post', ...variables, signal });

export type EmailSecurityDeleteBlockedSenderPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  patternId: Schemas.EmailSecurityBlockedSenderId;
};

export type EmailSecurityDeleteBlockedSenderError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityDeleteBlockedSenderResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: {
    /**
     * The unique identifier for the allow policy.
     *
     * @example 2402
     * @format int32
     */
    id: number;
  };
};

export type EmailSecurityDeleteBlockedSenderVariables = {
  pathParams: EmailSecurityDeleteBlockedSenderPathParams;
} & FetcherExtraProps;

export const emailSecurityDeleteBlockedSender = (
  variables: EmailSecurityDeleteBlockedSenderVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityDeleteBlockedSenderResponse,
    EmailSecurityDeleteBlockedSenderError,
    undefined,
    {},
    {},
    EmailSecurityDeleteBlockedSenderPathParams
  >({
    url: '/accounts/{accountId}/email-security/settings/block_senders/{patternId}',
    method: 'delete',
    ...variables,
    signal
  });

export type EmailSecurityGetBlockedSenderPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  patternId: Schemas.EmailSecurityBlockedSenderId;
};

export type EmailSecurityGetBlockedSenderError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityGetBlockedSenderResponse = Schemas.EmailSecurityApiResponseCommon & {
  /**
   * @example {"comments":"block sender with email test@example.com","created_at":"2023-11-14T22:13:20Z","id":2402,"is_regex":false,"last_modified":"2023-11-14T22:13:20Z","pattern":"test@example.com","pattern_type":"EMAIL"}
   */
  result: {
    /**
     * @maxLength 1024
     */
    comments?: string | null;
    is_regex?: boolean;
    /**
     * @maxLength 1024
     * @minLength 1
     */
    pattern?: string;
    pattern_type?: Schemas.EmailSecurityPatternType;
    /**
     * @format date-time
     */
    created_at: string;
    id: Schemas.EmailSecurityBlockedSenderId;
    /**
     * @format date-time
     */
    last_modified: string;
  };
};

export type EmailSecurityGetBlockedSenderVariables = {
  pathParams: EmailSecurityGetBlockedSenderPathParams;
} & FetcherExtraProps;

export const emailSecurityGetBlockedSender = (
  variables: EmailSecurityGetBlockedSenderVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityGetBlockedSenderResponse,
    EmailSecurityGetBlockedSenderError,
    undefined,
    {},
    {},
    EmailSecurityGetBlockedSenderPathParams
  >({
    url: '/accounts/{accountId}/email-security/settings/block_senders/{patternId}',
    method: 'get',
    ...variables,
    signal
  });

export type EmailSecurityUpdateBlockedSenderPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  patternId: Schemas.EmailSecurityBlockedSenderId;
};

export type EmailSecurityUpdateBlockedSenderError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityUpdateBlockedSenderResponse = Schemas.EmailSecurityApiResponseCommon & {
  /**
   * @example {"comments":"block sender with email test@example.com","created_at":"2023-11-14T22:13:20Z","id":2402,"is_regex":false,"last_modified":"2023-11-14T22:13:20Z","pattern":"test@example.com","pattern_type":"EMAIL"}
   */
  result: {
    /**
     * @maxLength 1024
     */
    comments?: string | null;
    is_regex?: boolean;
    /**
     * @maxLength 1024
     * @minLength 1
     */
    pattern?: string;
    pattern_type?: Schemas.EmailSecurityPatternType;
    /**
     * @format date-time
     */
    created_at: string;
    id: Schemas.EmailSecurityBlockedSenderId;
    /**
     * @format date-time
     */
    last_modified: string;
  };
};

export type EmailSecurityUpdateBlockedSenderVariables = {
  body?: Schemas.EmailSecurityUpdateBlockedSender;
  pathParams: EmailSecurityUpdateBlockedSenderPathParams;
} & FetcherExtraProps;

export const emailSecurityUpdateBlockedSender = (
  variables: EmailSecurityUpdateBlockedSenderVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityUpdateBlockedSenderResponse,
    EmailSecurityUpdateBlockedSenderError,
    Schemas.EmailSecurityUpdateBlockedSender,
    {},
    {},
    EmailSecurityUpdateBlockedSenderPathParams
  >({
    url: '/accounts/{accountId}/email-security/settings/block_senders/{patternId}',
    method: 'patch',
    ...variables,
    signal
  });

export type EmailSecurityDeleteDomainsPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
};

export type EmailSecurityDeleteDomainsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityDeleteDomainsResponse = Schemas.EmailSecurityApiResponseCommon & {
  /**
   * @minItems 1
   */
  result: {
    /**
     * The unique identifier for the domain.
     *
     * @example 2400
     * @format int32
     */
    id: number;
  }[];
};

export type EmailSecurityDeleteDomainsRequestBody = {
  /**
   * The unique identifier for the domain.
   *
   * @example 2400
   * @format int32
   */
  id: number;
}[];

export type EmailSecurityDeleteDomainsVariables = {
  body?: EmailSecurityDeleteDomainsRequestBody;
  pathParams: EmailSecurityDeleteDomainsPathParams;
} & FetcherExtraProps;

export const emailSecurityDeleteDomains = (variables: EmailSecurityDeleteDomainsVariables, signal?: AbortSignal) =>
  fetch<
    EmailSecurityDeleteDomainsResponse,
    EmailSecurityDeleteDomainsError,
    EmailSecurityDeleteDomainsRequestBody,
    {},
    {},
    EmailSecurityDeleteDomainsPathParams
  >({ url: '/accounts/{accountId}/email-security/settings/domains', method: 'delete', ...variables, signal });

export type EmailSecurityListDomainsPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
};

export type EmailSecurityListDomainsQueryParams = {
  /**
   * The page number of paginated results.
   *
   * @default 1
   * @format int32
   * @minimum 1
   */
  page?: number;
  /**
   * The number of results per page.
   *
   * @default 20
   * @format int32
   * @minimum 1
   */
  per_page?: number;
  /**
   * The field to sort by.
   */
  order?: 'domain' | 'created_at';
  /**
   * The sorting direction.
   */
  direction?: Schemas.EmailSecuritySortingDirection;
  /**
   * Allows searching in multiple properties of a record simultaneously.
   * This parameter is intended for human users, not automation. Its exact
   * behavior is intentionally left unspecified and is subject to change
   * in the future.
   */
  search?: string;
  /**
   * Filters response to domains with the provided delivery mode.
   */
  allowed_delivery_mode?: Schemas.EmailSecurityDeliveryMode;
  /**
   * Filters results by the provided domains, allowing for multiple occurrences.
   */
  domain?: string[];
};

export type EmailSecurityListDomainsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityListDomainsResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: Schemas.EmailSecurityDomain[];
  result_info: Schemas.EmailSecurityResultInfo;
};

export type EmailSecurityListDomainsVariables = {
  pathParams: EmailSecurityListDomainsPathParams;
  queryParams?: EmailSecurityListDomainsQueryParams;
} & FetcherExtraProps;

/**
 * Lists, searches, and sorts an account’s email domains.
 */
export const emailSecurityListDomains = (variables: EmailSecurityListDomainsVariables, signal?: AbortSignal) =>
  fetch<
    EmailSecurityListDomainsResponse,
    EmailSecurityListDomainsError,
    undefined,
    {},
    EmailSecurityListDomainsQueryParams,
    EmailSecurityListDomainsPathParams
  >({ url: '/accounts/{accountId}/email-security/settings/domains', method: 'get', ...variables, signal });

export type EmailSecurityDeleteDomainPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  /**
   * @example 2400
   * @format int32
   */
  domainId: number;
};

export type EmailSecurityDeleteDomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityDeleteDomainResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: {
    /**
     * The unique identifier for the domain.
     *
     * @example 2400
     * @format int32
     */
    id: number;
  };
};

export type EmailSecurityDeleteDomainVariables = {
  pathParams: EmailSecurityDeleteDomainPathParams;
} & FetcherExtraProps;

export const emailSecurityDeleteDomain = (variables: EmailSecurityDeleteDomainVariables, signal?: AbortSignal) =>
  fetch<
    EmailSecurityDeleteDomainResponse,
    EmailSecurityDeleteDomainError,
    undefined,
    {},
    {},
    EmailSecurityDeleteDomainPathParams
  >({
    url: '/accounts/{accountId}/email-security/settings/domains/{domainId}',
    method: 'delete',
    ...variables,
    signal
  });

export type EmailSecurityGetDomainPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  /**
   * @example 2400
   * @format int32
   */
  domainId: number;
};

export type EmailSecurityGetDomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityGetDomainResponse = Schemas.EmailSecurityApiResponseCommon & {
  /**
   * @example {"allowed_delivery_modes":["API"],"created_at":"2023-11-14T22:13:20Z","domain":"example.com","drop_dispositions":["MALICIOUS","SPAM"],"folder":"Inbox","id":2400,"inbox_provider":"Microsoft","integration_id":"a5dbb180-60ea-4578-84bb-d01a5d4e50c3","ip_restrictions":[],"last_modified":"2023-11-14T22:13:20Z","lookback_hops":2,"o365_tenant_id":"c3c3239d-8858-47df-9618-0e2d9bdf6aa8","require_tls_inbound":false,"require_tls_outbound":true,"transport":"example.com"}
   */
  result: {
    allowed_delivery_modes: Schemas.EmailSecurityDeliveryMode[];
    /**
     * @format date-time
     */
    created_at: string;
    domain: string;
    drop_dispositions: Schemas.EmailSecurityDispositionLabel[];
    folder?: Schemas.EmailSecurityScannableFolder & (string | null);
    /**
     * The unique identifier for the domain.
     *
     * @example 2400
     * @format int32
     */
    id: number;
    inbox_provider?: 'Microsoft' | 'Google' | null;
    /**
     * @format uuid
     */
    integration_id?: string | null;
    /**
     * @example 192.0.2.0/24
     * @example 2001:db8::/32
     */
    ip_restrictions: string[];
    /**
     * @format date-time
     */
    last_modified: string;
    /**
     * @format int32
     */
    lookback_hops: number;
    o365_tenant_id?: string | null;
    require_tls_inbound?: boolean | null;
    require_tls_outbound?: boolean | null;
    transport: string;
  };
};

export type EmailSecurityGetDomainVariables = {
  pathParams: EmailSecurityGetDomainPathParams;
} & FetcherExtraProps;

export const emailSecurityGetDomain = (variables: EmailSecurityGetDomainVariables, signal?: AbortSignal) =>
  fetch<
    EmailSecurityGetDomainResponse,
    EmailSecurityGetDomainError,
    undefined,
    {},
    {},
    EmailSecurityGetDomainPathParams
  >({ url: '/accounts/{accountId}/email-security/settings/domains/{domainId}', method: 'get', ...variables, signal });

export type EmailSecurityUpdateDomainPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  /**
   * @example 2400
   * @format int32
   */
  domainId: number;
};

export type EmailSecurityUpdateDomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityUpdateDomainResponse = Schemas.EmailSecurityApiResponseCommon & {
  /**
   * @example {"allowed_delivery_modes":["API"],"created_at":"2023-11-14T22:13:20Z","domain":"example.com","drop_dispositions":["MALICIOUS","SPAM"],"folder":"Inbox","id":2400,"inbox_provider":"Microsoft","integration_id":"a5dbb180-60ea-4578-84bb-d01a5d4e50c3","ip_restrictions":[],"last_modified":"2023-11-14T22:13:20Z","lookback_hops":2,"o365_tenant_id":"c3c3239d-8858-47df-9618-0e2d9bdf6aa8","require_tls_inbound":false,"require_tls_outbound":true,"transport":"example.com"}
   */
  result: {
    allowed_delivery_modes: Schemas.EmailSecurityDeliveryMode[];
    /**
     * @format date-time
     */
    created_at: string;
    domain: string;
    drop_dispositions: Schemas.EmailSecurityDispositionLabel[];
    folder?: Schemas.EmailSecurityScannableFolder & (string | null);
    /**
     * The unique identifier for the domain.
     *
     * @example 2400
     * @format int32
     */
    id: number;
    inbox_provider?: 'Microsoft' | 'Google' | null;
    /**
     * @format uuid
     */
    integration_id?: string | null;
    /**
     * @example 192.0.2.0/24
     * @example 2001:db8::/32
     */
    ip_restrictions: string[];
    /**
     * @format date-time
     */
    last_modified: string;
    /**
     * @format int32
     */
    lookback_hops: number;
    o365_tenant_id?: string | null;
    require_tls_inbound?: boolean | null;
    require_tls_outbound?: boolean | null;
    transport: string;
  };
};

export type EmailSecurityUpdateDomainRequestBody = {
  domain?: string | null;
  drop_dispositions?: Schemas.EmailSecurityDispositionLabel[];
  folder?: Schemas.EmailSecurityScannableFolder;
  /**
   * @format uuid
   */
  integration_id?: string | null;
  /**
   * @example 192.0.2.0/24
   * @example 2001:db8::/32
   */
  ip_restrictions: string[];
  /**
   * @format int32
   * @maximum 20
   * @minimum 1
   */
  lookback_hops?: number | null;
  require_tls_inbound?: boolean;
  require_tls_outbound?: boolean;
  transport?: string;
};

export type EmailSecurityUpdateDomainVariables = {
  body: EmailSecurityUpdateDomainRequestBody;
  pathParams: EmailSecurityUpdateDomainPathParams;
} & FetcherExtraProps;

export const emailSecurityUpdateDomain = (variables: EmailSecurityUpdateDomainVariables, signal?: AbortSignal) =>
  fetch<
    EmailSecurityUpdateDomainResponse,
    EmailSecurityUpdateDomainError,
    EmailSecurityUpdateDomainRequestBody,
    {},
    {},
    EmailSecurityUpdateDomainPathParams
  >({ url: '/accounts/{accountId}/email-security/settings/domains/{domainId}', method: 'patch', ...variables, signal });

export type EmailSecurityListDisplayNamesPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
};

export type EmailSecurityListDisplayNamesQueryParams = {
  /**
   * The page number of paginated results.
   *
   * @default 1
   * @format int32
   * @minimum 1
   */
  page?: number;
  /**
   * The number of results per page.
   *
   * @default 20
   * @format int32
   * @minimum 1
   */
  per_page?: number;
  /**
   * The field to sort by.
   */
  order?: 'name' | 'email' | 'created_at';
  /**
   * The sorting direction.
   */
  direction?: Schemas.EmailSecuritySortingDirection;
  /**
   * Allows searching in multiple properties of a record simultaneously.
   * This parameter is intended for human users, not automation. Its exact
   * behavior is intentionally left unspecified and is subject to change
   * in the future.
   */
  search?: string;
  provenance?: 'A1S_INTERNAL' | 'SNOOPY-CASB_OFFICE_365' | 'SNOOPY-OFFICE_365' | 'SNOOPY-GOOGLE_DIRECTORY';
};

export type EmailSecurityListDisplayNamesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityListDisplayNamesResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: Schemas.EmailSecurityDisplayName[];
  result_info: Schemas.EmailSecurityResultInfo;
};

export type EmailSecurityListDisplayNamesVariables = {
  pathParams: EmailSecurityListDisplayNamesPathParams;
  queryParams?: EmailSecurityListDisplayNamesQueryParams;
} & FetcherExtraProps;

/**
 * Lists, searches, and sorts entries in the impersonation registry.
 */
export const emailSecurityListDisplayNames = (
  variables: EmailSecurityListDisplayNamesVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityListDisplayNamesResponse,
    EmailSecurityListDisplayNamesError,
    undefined,
    {},
    EmailSecurityListDisplayNamesQueryParams,
    EmailSecurityListDisplayNamesPathParams
  >({
    url: '/accounts/{accountId}/email-security/settings/impersonation_registry',
    method: 'get',
    ...variables,
    signal
  });

export type EmailSecurityCreateDisplayNamePathParams = {
  accountId: Schemas.EmailSecurityAccountId;
};

export type EmailSecurityCreateDisplayNameError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityCreateDisplayNameResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: {
    email?: string;
    is_email_regex?: boolean;
    /**
     * @maxLength 1024
     */
    name?: string;
    comments?: string | null;
    /**
     * @format date-time
     */
    created_at: string;
    /**
     * @format int64
     */
    directory_id?: number | null;
    /**
     * @format int32
     */
    directory_node_id?: number | null;
    /**
     * @deprecated true
     */
    external_directory_node_id?: string | null;
    /**
     * @example 2403
     * @format int32
     */
    id: number;
    /**
     * @format date-time
     */
    last_modified: string;
    provenance?: string | null;
  };
};

export type EmailSecurityCreateDisplayNameVariables = {
  body: Schemas.EmailSecurityCreateDisplayName;
  pathParams: EmailSecurityCreateDisplayNamePathParams;
} & FetcherExtraProps;

export const emailSecurityCreateDisplayName = (
  variables: EmailSecurityCreateDisplayNameVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityCreateDisplayNameResponse,
    EmailSecurityCreateDisplayNameError,
    Schemas.EmailSecurityCreateDisplayName,
    {},
    {},
    EmailSecurityCreateDisplayNamePathParams
  >({
    url: '/accounts/{accountId}/email-security/settings/impersonation_registry',
    method: 'post',
    ...variables,
    signal
  });

export type EmailSecurityDeleteDisplayNamePathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  /**
   * @example 2403
   * @format int32
   */
  displayNameId: number;
};

export type EmailSecurityDeleteDisplayNameError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityDeleteDisplayNameResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: {
    /**
     * @example 2403
     * @format int32
     */
    id: number;
  };
};

export type EmailSecurityDeleteDisplayNameVariables = {
  pathParams: EmailSecurityDeleteDisplayNamePathParams;
} & FetcherExtraProps;

export const emailSecurityDeleteDisplayName = (
  variables: EmailSecurityDeleteDisplayNameVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityDeleteDisplayNameResponse,
    EmailSecurityDeleteDisplayNameError,
    undefined,
    {},
    {},
    EmailSecurityDeleteDisplayNamePathParams
  >({
    url: '/accounts/{accountId}/email-security/settings/impersonation_registry/{displayNameId}',
    method: 'delete',
    ...variables,
    signal
  });

export type EmailSecurityGetDisplayNamePathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  /**
   * @example 2403
   * @format int32
   */
  displayNameId: number;
};

export type EmailSecurityGetDisplayNameError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityGetDisplayNameResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: {
    email?: string;
    is_email_regex?: boolean;
    /**
     * @maxLength 1024
     */
    name?: string;
    comments?: string | null;
    /**
     * @format date-time
     */
    created_at: string;
    /**
     * @format int64
     */
    directory_id?: number | null;
    /**
     * @format int32
     */
    directory_node_id?: number | null;
    /**
     * @deprecated true
     */
    external_directory_node_id?: string | null;
    /**
     * @example 2403
     * @format int32
     */
    id: number;
    /**
     * @format date-time
     */
    last_modified: string;
    provenance?: string | null;
  };
};

export type EmailSecurityGetDisplayNameVariables = {
  pathParams: EmailSecurityGetDisplayNamePathParams;
} & FetcherExtraProps;

export const emailSecurityGetDisplayName = (variables: EmailSecurityGetDisplayNameVariables, signal?: AbortSignal) =>
  fetch<
    EmailSecurityGetDisplayNameResponse,
    EmailSecurityGetDisplayNameError,
    undefined,
    {},
    {},
    EmailSecurityGetDisplayNamePathParams
  >({
    url: '/accounts/{accountId}/email-security/settings/impersonation_registry/{displayNameId}',
    method: 'get',
    ...variables,
    signal
  });

export type EmailSecurityUpdateDisplayNamePathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  /**
   * @example 2403
   * @format int32
   */
  displayNameId: number;
};

export type EmailSecurityUpdateDisplayNameError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityUpdateDisplayNameResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: {
    email?: string;
    is_email_regex?: boolean;
    /**
     * @maxLength 1024
     */
    name?: string;
    comments?: string | null;
    /**
     * @format date-time
     */
    created_at: string;
    /**
     * @format int64
     */
    directory_id?: number | null;
    /**
     * @format int32
     */
    directory_node_id?: number | null;
    /**
     * @deprecated true
     */
    external_directory_node_id?: string | null;
    /**
     * @example 2403
     * @format int32
     */
    id: number;
    /**
     * @format date-time
     */
    last_modified: string;
    provenance?: string | null;
  };
};

export type EmailSecurityUpdateDisplayNameRequestBody = {
  email?: string | null;
  is_email_regex?: boolean | null;
  /**
   * @maxLength 1024
   */
  name?: string | null;
};

export type EmailSecurityUpdateDisplayNameVariables = {
  body?: EmailSecurityUpdateDisplayNameRequestBody;
  pathParams: EmailSecurityUpdateDisplayNamePathParams;
} & FetcherExtraProps;

export const emailSecurityUpdateDisplayName = (
  variables: EmailSecurityUpdateDisplayNameVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityUpdateDisplayNameResponse,
    EmailSecurityUpdateDisplayNameError,
    EmailSecurityUpdateDisplayNameRequestBody,
    {},
    {},
    EmailSecurityUpdateDisplayNamePathParams
  >({
    url: '/accounts/{accountId}/email-security/settings/impersonation_registry/{displayNameId}',
    method: 'patch',
    ...variables,
    signal
  });

export type EmailSecurityListTrustedDomainsPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
};

export type EmailSecurityListTrustedDomainsQueryParams = {
  /**
   * The page number of paginated results.
   *
   * @default 1
   * @format int32
   * @minimum 1
   */
  page?: number;
  /**
   * The number of results per page.
   *
   * @default 20
   * @format int32
   * @minimum 1
   */
  per_page?: number;
  /**
   * The field to sort by.
   */
  order?: 'pattern' | 'created_at';
  /**
   * The sorting direction.
   */
  direction?: Schemas.EmailSecuritySortingDirection;
  /**
   * Allows searching in multiple properties of a record simultaneously.
   * This parameter is intended for human users, not automation. Its exact
   * behavior is intentionally left unspecified and is subject to change
   * in the future.
   */
  search?: string;
  is_recent?: boolean;
  is_similarity?: boolean;
};

export type EmailSecurityListTrustedDomainsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityListTrustedDomainsResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: Schemas.EmailSecurityTrustedDomain[];
  result_info: Schemas.EmailSecurityResultInfo;
};

export type EmailSecurityListTrustedDomainsVariables = {
  pathParams: EmailSecurityListTrustedDomainsPathParams;
  queryParams?: EmailSecurityListTrustedDomainsQueryParams;
} & FetcherExtraProps;

/**
 * Lists, searches, and sorts an account’s trusted email domains.
 */
export const emailSecurityListTrustedDomains = (
  variables: EmailSecurityListTrustedDomainsVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityListTrustedDomainsResponse,
    EmailSecurityListTrustedDomainsError,
    undefined,
    {},
    EmailSecurityListTrustedDomainsQueryParams,
    EmailSecurityListTrustedDomainsPathParams
  >({ url: '/accounts/{accountId}/email-security/settings/trusted_domains', method: 'get', ...variables, signal });

export type EmailSecurityCreateTrustedDomainPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
};

export type EmailSecurityCreateTrustedDomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityCreateTrustedDomainResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: Schemas.EmailSecurityTrustedDomain | Schemas.EmailSecurityTrustedDomain[];
};

export type EmailSecurityCreateTrustedDomainVariables = {
  body?: Schemas.EmailSecurityCreateTrustedDomain | Schemas.EmailSecurityCreateTrustedDomain[];
  pathParams: EmailSecurityCreateTrustedDomainPathParams;
} & FetcherExtraProps;

export const emailSecurityCreateTrustedDomain = (
  variables: EmailSecurityCreateTrustedDomainVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityCreateTrustedDomainResponse,
    EmailSecurityCreateTrustedDomainError,
    Schemas.EmailSecurityCreateTrustedDomain | Schemas.EmailSecurityCreateTrustedDomain[],
    {},
    {},
    EmailSecurityCreateTrustedDomainPathParams
  >({ url: '/accounts/{accountId}/email-security/settings/trusted_domains', method: 'post', ...variables, signal });

export type EmailSecurityDeleteTrustedDomainPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  trustedDomainId: Schemas.EmailSecurityTrustedDomainId;
};

export type EmailSecurityDeleteTrustedDomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityDeleteTrustedDomainResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: {
    /**
     * The unique identifier for the trusted domain.
     *
     * @example 2401
     * @format int32
     */
    id: number;
  };
};

export type EmailSecurityDeleteTrustedDomainVariables = {
  pathParams: EmailSecurityDeleteTrustedDomainPathParams;
} & FetcherExtraProps;

export const emailSecurityDeleteTrustedDomain = (
  variables: EmailSecurityDeleteTrustedDomainVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityDeleteTrustedDomainResponse,
    EmailSecurityDeleteTrustedDomainError,
    undefined,
    {},
    {},
    EmailSecurityDeleteTrustedDomainPathParams
  >({
    url: '/accounts/{accountId}/email-security/settings/trusted_domains/{trustedDomainId}',
    method: 'delete',
    ...variables,
    signal
  });

export type EmailSecurityGetTrustedDomainPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  trustedDomainId: Schemas.EmailSecurityTrustedDomainId;
};

export type EmailSecurityGetTrustedDomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityGetTrustedDomainResponse = Schemas.EmailSecurityApiResponseCommon & {
  /**
   * @example {"comments":null,"created_at":"2023-11-14T22:13:20Z","id":2401,"is_recent":true,"is_regex":false,"is_similarity":false,"last_modified":"2023-11-14T22:13:20Z","pattern":"example.com"}
   */
  result: {
    /**
     * @maxLength 1024
     */
    comments?: string | null;
    /**
     * Select to prevent recently registered domains from triggering a
     * Suspicious or Malicious disposition.
     */
    is_recent?: boolean;
    is_regex?: boolean;
    /**
     * Select for partner or other approved domains that have similar
     * spelling to your connected domains. Prevents listed domains from
     * triggering a Spoof disposition.
     */
    is_similarity?: boolean;
    /**
     * @maxLength 1024
     * @minLength 1
     */
    pattern: string;
    /**
     * @format date-time
     */
    created_at: string;
    /**
     * The unique identifier for the trusted domain.
     *
     * @example 2401
     * @format int32
     */
    id: number;
    /**
     * @format date-time
     */
    last_modified: string;
  };
};

export type EmailSecurityGetTrustedDomainVariables = {
  pathParams: EmailSecurityGetTrustedDomainPathParams;
} & FetcherExtraProps;

export const emailSecurityGetTrustedDomain = (
  variables: EmailSecurityGetTrustedDomainVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityGetTrustedDomainResponse,
    EmailSecurityGetTrustedDomainError,
    undefined,
    {},
    {},
    EmailSecurityGetTrustedDomainPathParams
  >({
    url: '/accounts/{accountId}/email-security/settings/trusted_domains/{trustedDomainId}',
    method: 'get',
    ...variables,
    signal
  });

export type EmailSecurityUpdateTrustedDomainPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
  trustedDomainId: Schemas.EmailSecurityTrustedDomainId;
};

export type EmailSecurityUpdateTrustedDomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecurityUpdateTrustedDomainResponse = Schemas.EmailSecurityApiResponseCommon & {
  /**
   * @example {"comments":null,"created_at":"2023-11-14T22:13:20Z","id":2401,"is_recent":true,"is_regex":false,"is_similarity":false,"last_modified":"2023-11-14T22:13:20Z","pattern":"example.com"}
   */
  result: {
    /**
     * @maxLength 1024
     */
    comments?: string | null;
    /**
     * Select to prevent recently registered domains from triggering a
     * Suspicious or Malicious disposition.
     */
    is_recent?: boolean;
    is_regex?: boolean;
    /**
     * Select for partner or other approved domains that have similar
     * spelling to your connected domains. Prevents listed domains from
     * triggering a Spoof disposition.
     */
    is_similarity?: boolean;
    /**
     * @maxLength 1024
     * @minLength 1
     */
    pattern: string;
    /**
     * @format date-time
     */
    created_at: string;
    /**
     * The unique identifier for the trusted domain.
     *
     * @example 2401
     * @format int32
     */
    id: number;
    /**
     * @format date-time
     */
    last_modified: string;
  };
};

export type EmailSecurityUpdateTrustedDomainRequestBody = {
  /**
   * @maxLength 1024
   */
  comments?: string | null;
  /**
   * Select to prevent recently registered domains from triggering a
   * Suspicious or Malicious disposition.
   */
  is_recent?: boolean | null;
  is_regex?: boolean | null;
  /**
   * Select for partner or other approved domains that have similar
   * spelling to your connected domains. Prevents listed domains from
   * triggering a Spoof disposition.
   */
  is_similarity?: boolean | null;
  /**
   * @maxLength 1024
   * @minLength 1
   */
  pattern?: string | null;
};

export type EmailSecurityUpdateTrustedDomainVariables = {
  body?: EmailSecurityUpdateTrustedDomainRequestBody;
  pathParams: EmailSecurityUpdateTrustedDomainPathParams;
} & FetcherExtraProps;

export const emailSecurityUpdateTrustedDomain = (
  variables: EmailSecurityUpdateTrustedDomainVariables,
  signal?: AbortSignal
) =>
  fetch<
    EmailSecurityUpdateTrustedDomainResponse,
    EmailSecurityUpdateTrustedDomainError,
    EmailSecurityUpdateTrustedDomainRequestBody,
    {},
    {},
    EmailSecurityUpdateTrustedDomainPathParams
  >({
    url: '/accounts/{accountId}/email-security/settings/trusted_domains/{trustedDomainId}',
    method: 'patch',
    ...variables,
    signal
  });

export type EmailSecuritySubmissionsPathParams = {
  accountId: Schemas.EmailSecurityAccountId;
};

export type EmailSecuritySubmissionsQueryParams = {
  /**
   * The beginning of the search date range.
   * Defaults to `now - 30 days`.
   *
   * @format date-time
   */
  start?: string;
  /**
   * The end of the search date range.
   * Defaults to `now`.
   *
   * @format date-time
   */
  end?: string;
  type?: 'TEAM' | 'USER';
  submission_id?: string;
  /**
   * The page number of paginated results.
   *
   * @default 1
   * @format int32
   * @minimum 1
   */
  page?: number;
  /**
   * The number of results per page.
   *
   * @default 20
   * @format int32
   * @minimum 1
   */
  per_page?: number;
};

export type EmailSecuritySubmissionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.EmailSecurityClientError;
}>;

export type EmailSecuritySubmissionsResponse = Schemas.EmailSecurityApiResponseCommon & {
  result: Schemas.EmailSecuritySubmission[];
};

export type EmailSecuritySubmissionsVariables = {
  pathParams: EmailSecuritySubmissionsPathParams;
  queryParams?: EmailSecuritySubmissionsQueryParams;
} & FetcherExtraProps;

/**
 * This endpoint returns information for submissions to made to reclassify emails.
 */
export const emailSecuritySubmissions = (variables: EmailSecuritySubmissionsVariables, signal?: AbortSignal) =>
  fetch<
    EmailSecuritySubmissionsResponse,
    EmailSecuritySubmissionsError,
    undefined,
    {},
    EmailSecuritySubmissionsQueryParams,
    EmailSecuritySubmissionsPathParams
  >({ url: '/accounts/{accountId}/email-security/submissions', method: 'get', ...variables, signal });

export type EmailRoutingDestinationAddressesListDestinationAddressesPathParams = {
  accountId: Schemas.EmailIdentifier;
};

export type EmailRoutingDestinationAddressesListDestinationAddressesQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * @default asc
   * @example asc
   */
  direction?: 'asc' | 'desc';
  /**
   * @default true
   * @example true
   */
  verified?: true | false;
};

export type EmailRoutingDestinationAddressesListDestinationAddressesError = Fetcher.ErrorWrapper<undefined>;

export type EmailRoutingDestinationAddressesListDestinationAddressesVariables = {
  pathParams: EmailRoutingDestinationAddressesListDestinationAddressesPathParams;
  queryParams?: EmailRoutingDestinationAddressesListDestinationAddressesQueryParams;
} & FetcherExtraProps;

/**
 * Lists existing destination addresses.
 */
export const emailRoutingDestinationAddressesListDestinationAddresses = (
  variables: EmailRoutingDestinationAddressesListDestinationAddressesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.EmailDestinationAddressesResponseCollection,
    EmailRoutingDestinationAddressesListDestinationAddressesError,
    undefined,
    {},
    EmailRoutingDestinationAddressesListDestinationAddressesQueryParams,
    EmailRoutingDestinationAddressesListDestinationAddressesPathParams
  >({ url: '/accounts/{accountId}/email/routing/addresses', method: 'get', ...variables, signal });

export type EmailRoutingDestinationAddressesCreateADestinationAddressPathParams = {
  accountId: Schemas.EmailIdentifier;
};

export type EmailRoutingDestinationAddressesCreateADestinationAddressError = Fetcher.ErrorWrapper<undefined>;

export type EmailRoutingDestinationAddressesCreateADestinationAddressVariables = {
  body: Schemas.EmailCreateDestinationAddressProperties;
  pathParams: EmailRoutingDestinationAddressesCreateADestinationAddressPathParams;
} & FetcherExtraProps;

/**
 * Create a destination address to forward your emails to. Destination addresses need to be verified before they can be used.
 */
export const emailRoutingDestinationAddressesCreateADestinationAddress = (
  variables: EmailRoutingDestinationAddressesCreateADestinationAddressVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.EmailDestinationAddressResponseSingle,
    EmailRoutingDestinationAddressesCreateADestinationAddressError,
    Schemas.EmailCreateDestinationAddressProperties,
    {},
    {},
    EmailRoutingDestinationAddressesCreateADestinationAddressPathParams
  >({ url: '/accounts/{accountId}/email/routing/addresses', method: 'post', ...variables, signal });

export type EmailRoutingDestinationAddressesDeleteDestinationAddressPathParams = {
  destinationAddressIdentifier: Schemas.EmailDestinationAddressIdentifier;
  accountId: Schemas.EmailIdentifier;
};

export type EmailRoutingDestinationAddressesDeleteDestinationAddressError = Fetcher.ErrorWrapper<undefined>;

export type EmailRoutingDestinationAddressesDeleteDestinationAddressVariables = {
  pathParams: EmailRoutingDestinationAddressesDeleteDestinationAddressPathParams;
} & FetcherExtraProps;

/**
 * Deletes a specific destination address.
 */
export const emailRoutingDestinationAddressesDeleteDestinationAddress = (
  variables: EmailRoutingDestinationAddressesDeleteDestinationAddressVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.EmailDestinationAddressResponseSingle,
    EmailRoutingDestinationAddressesDeleteDestinationAddressError,
    undefined,
    {},
    {},
    EmailRoutingDestinationAddressesDeleteDestinationAddressPathParams
  >({
    url: '/accounts/{accountId}/email/routing/addresses/{destinationAddressIdentifier}',
    method: 'delete',
    ...variables,
    signal
  });

export type EmailRoutingDestinationAddressesGetADestinationAddressPathParams = {
  destinationAddressIdentifier: Schemas.EmailDestinationAddressIdentifier;
  accountId: Schemas.EmailIdentifier;
};

export type EmailRoutingDestinationAddressesGetADestinationAddressError = Fetcher.ErrorWrapper<undefined>;

export type EmailRoutingDestinationAddressesGetADestinationAddressVariables = {
  pathParams: EmailRoutingDestinationAddressesGetADestinationAddressPathParams;
} & FetcherExtraProps;

/**
 * Gets information for a specific destination email already created.
 */
export const emailRoutingDestinationAddressesGetADestinationAddress = (
  variables: EmailRoutingDestinationAddressesGetADestinationAddressVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.EmailDestinationAddressResponseSingle,
    EmailRoutingDestinationAddressesGetADestinationAddressError,
    undefined,
    {},
    {},
    EmailRoutingDestinationAddressesGetADestinationAddressPathParams
  >({
    url: '/accounts/{accountId}/email/routing/addresses/{destinationAddressIdentifier}',
    method: 'get',
    ...variables,
    signal
  });

export type R2GetEventNotificationConfigsPathParams = {
  bucketName: Schemas.R2BucketName;
  accountId: Schemas.R2AccountIdentifier;
};

export type R2GetEventNotificationConfigsHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2GetEventNotificationConfigsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.R2V4ResponseFailure;
    }
  | {
      status: 404;
      payload: Schemas.R2V4ResponseFailure;
    }
>;

export type R2GetEventNotificationConfigsResponse = {
  errors: Schemas.R2Errors;
  messages: Schemas.R2Messages;
  result: Schemas.R2BucketConfig;
  /**
   * Whether the API call was successful
   */
  success: true;
};

export type R2GetEventNotificationConfigsVariables = {
  headers?: R2GetEventNotificationConfigsHeaders;
  pathParams: R2GetEventNotificationConfigsPathParams;
} & FetcherExtraProps;

/**
 * List all event notification rules for a bucket.
 */
export const r2GetEventNotificationConfigs = (
  variables: R2GetEventNotificationConfigsVariables,
  signal?: AbortSignal
) =>
  fetch<
    R2GetEventNotificationConfigsResponse,
    R2GetEventNotificationConfigsError,
    undefined,
    R2GetEventNotificationConfigsHeaders,
    {},
    R2GetEventNotificationConfigsPathParams
  >({
    url: '/accounts/{accountId}/event_notifications/r2/{bucketName}/configuration',
    method: 'get',
    ...variables,
    signal
  });

export type R2EventNotificationDeleteConfigPathParams = {
  queueId: Schemas.R2QueueIdentifier;
  bucketName: Schemas.R2BucketName;
  accountId: Schemas.R2AccountIdentifier;
};

export type R2EventNotificationDeleteConfigHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2EventNotificationDeleteConfigError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2EventNotificationDeleteConfigResponse = Schemas.R2V4Response & Record<string, any>;

export type R2EventNotificationDeleteConfigRequestBody = {
  /**
   * Array of rule ids to delete
   */
  ruleIds?: string[];
};

export type R2EventNotificationDeleteConfigVariables = {
  body?: R2EventNotificationDeleteConfigRequestBody;
  headers?: R2EventNotificationDeleteConfigHeaders;
  pathParams: R2EventNotificationDeleteConfigPathParams;
} & FetcherExtraProps;

/**
 * Delete an event notification rule. **If no body is provided, all rules for specified queue will be deleted**.
 */
export const r2EventNotificationDeleteConfig = (
  variables: R2EventNotificationDeleteConfigVariables,
  signal?: AbortSignal
) =>
  fetch<
    R2EventNotificationDeleteConfigResponse,
    R2EventNotificationDeleteConfigError,
    R2EventNotificationDeleteConfigRequestBody,
    R2EventNotificationDeleteConfigHeaders,
    {},
    R2EventNotificationDeleteConfigPathParams
  >({
    url: '/accounts/{accountId}/event_notifications/r2/{bucketName}/configuration/queues/{queueId}',
    method: 'delete',
    ...variables,
    signal
  });

export type R2PutEventNotificationConfigPathParams = {
  queueId: Schemas.R2QueueIdentifier;
  bucketName: Schemas.R2BucketName;
  accountId: Schemas.R2AccountIdentifier;
};

export type R2PutEventNotificationConfigHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2PutEventNotificationConfigError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2PutEventNotificationConfigResponse = Schemas.R2V4Response & Record<string, any>;

export type R2PutEventNotificationConfigRequestBody = {
  /**
   * Array of rules to drive notifications
   */
  rules?: Schemas.R2Rule[];
};

export type R2PutEventNotificationConfigVariables = {
  body?: R2PutEventNotificationConfigRequestBody;
  headers?: R2PutEventNotificationConfigHeaders;
  pathParams: R2PutEventNotificationConfigPathParams;
} & FetcherExtraProps;

/**
 * Create event notification rule.
 */
export const r2PutEventNotificationConfig = (variables: R2PutEventNotificationConfigVariables, signal?: AbortSignal) =>
  fetch<
    R2PutEventNotificationConfigResponse,
    R2PutEventNotificationConfigError,
    R2PutEventNotificationConfigRequestBody,
    R2PutEventNotificationConfigHeaders,
    {},
    R2PutEventNotificationConfigPathParams
  >({
    url: '/accounts/{accountId}/event_notifications/r2/{bucketName}/configuration/queues/{queueId}',
    method: 'put',
    ...variables,
    signal
  });

export type IpAccessRulesForAnAccountListIpAccessRulesPathParams = {
  accountId: Schemas.FirewallAccountIdentifier;
};

export type IpAccessRulesForAnAccountListIpAccessRulesQueryParams = {
  mode?: Schemas.FirewallSchemasMode;
  /**
   * @example ip
   */
  ['configuration.target']?: 'ip' | 'ip_range' | 'asn' | 'country';
  /**
   * @example 198.51.100.4
   */
  ['configuration.value']?: string;
  /**
   * @example my note
   */
  notes?: string;
  /**
   * @default all
   */
  match?: 'any' | 'all';
  /**
   * @example 1
   */
  page?: number;
  /**
   * @example 20
   */
  per_page?: number;
  /**
   * @example mode
   */
  order?: 'configuration.target' | 'configuration.value' | 'mode';
  /**
   * @example desc
   */
  direction?: 'asc' | 'desc';
};

export type IpAccessRulesForAnAccountListIpAccessRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallResponseCollection & Schemas.FirewallApiResponseCommonFailure;
}>;

export type IpAccessRulesForAnAccountListIpAccessRulesVariables = {
  pathParams: IpAccessRulesForAnAccountListIpAccessRulesPathParams;
  queryParams?: IpAccessRulesForAnAccountListIpAccessRulesQueryParams;
} & FetcherExtraProps;

/**
 * Fetches IP Access rules of an account. These rules apply to all the zones in the account. You can filter the results using several optional parameters.
 */
export const ipAccessRulesForAnAccountListIpAccessRules = (
  variables: IpAccessRulesForAnAccountListIpAccessRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallResponseCollection,
    IpAccessRulesForAnAccountListIpAccessRulesError,
    undefined,
    {},
    IpAccessRulesForAnAccountListIpAccessRulesQueryParams,
    IpAccessRulesForAnAccountListIpAccessRulesPathParams
  >({ url: '/accounts/{accountId}/firewall/access_rules/rules', method: 'get', ...variables, signal });

export type IpAccessRulesForAnAccountCreateAnIpAccessRulePathParams = {
  accountId: Schemas.FirewallAccountIdentifier;
};

export type IpAccessRulesForAnAccountCreateAnIpAccessRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type IpAccessRulesForAnAccountCreateAnIpAccessRuleRequestBody = {
  configuration: Schemas.FirewallConfiguration;
  mode: Schemas.FirewallSchemasMode;
  notes?: Schemas.FirewallNotes;
};

export type IpAccessRulesForAnAccountCreateAnIpAccessRuleVariables = {
  body: IpAccessRulesForAnAccountCreateAnIpAccessRuleRequestBody;
  pathParams: IpAccessRulesForAnAccountCreateAnIpAccessRulePathParams;
} & FetcherExtraProps;

/**
 * Creates a new IP Access rule for an account. The rule will apply to all zones in the account.
 *
 * Note: To create an IP Access rule that applies to a single zone, refer to the [IP Access rules for a zone](#ip-access-rules-for-a-zone) endpoints.
 */
export const ipAccessRulesForAnAccountCreateAnIpAccessRule = (
  variables: IpAccessRulesForAnAccountCreateAnIpAccessRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallResponseSingle,
    IpAccessRulesForAnAccountCreateAnIpAccessRuleError,
    IpAccessRulesForAnAccountCreateAnIpAccessRuleRequestBody,
    {},
    {},
    IpAccessRulesForAnAccountCreateAnIpAccessRulePathParams
  >({ url: '/accounts/{accountId}/firewall/access_rules/rules', method: 'post', ...variables, signal });

export type IpAccessRulesForAnAccountDeleteAnIpAccessRulePathParams = {
  ruleId: Schemas.FirewallRuleIdentifier;
  accountId: Schemas.FirewallAccountIdentifier;
};

export type IpAccessRulesForAnAccountDeleteAnIpAccessRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallApiResponseSingleId & Schemas.FirewallApiResponseCommonFailure;
}>;

export type IpAccessRulesForAnAccountDeleteAnIpAccessRuleVariables = {
  pathParams: IpAccessRulesForAnAccountDeleteAnIpAccessRulePathParams;
} & FetcherExtraProps;

/**
 * Deletes an existing IP Access rule defined at the account level.
 *
 * Note: This operation will affect all zones in the account.
 */
export const ipAccessRulesForAnAccountDeleteAnIpAccessRule = (
  variables: IpAccessRulesForAnAccountDeleteAnIpAccessRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallApiResponseSingleId,
    IpAccessRulesForAnAccountDeleteAnIpAccessRuleError,
    undefined,
    {},
    {},
    IpAccessRulesForAnAccountDeleteAnIpAccessRulePathParams
  >({ url: '/accounts/{accountId}/firewall/access_rules/rules/{ruleId}', method: 'delete', ...variables, signal });

export type IpAccessRulesForAnAccountGetAnIpAccessRulePathParams = {
  ruleId: Schemas.FirewallRuleIdentifier;
  accountId: Schemas.FirewallAccountIdentifier;
};

export type IpAccessRulesForAnAccountGetAnIpAccessRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type IpAccessRulesForAnAccountGetAnIpAccessRuleVariables = {
  pathParams: IpAccessRulesForAnAccountGetAnIpAccessRulePathParams;
} & FetcherExtraProps;

/**
 * Fetches the details of an IP Access rule defined at the account level.
 */
export const ipAccessRulesForAnAccountGetAnIpAccessRule = (
  variables: IpAccessRulesForAnAccountGetAnIpAccessRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallResponseSingle,
    IpAccessRulesForAnAccountGetAnIpAccessRuleError,
    undefined,
    {},
    {},
    IpAccessRulesForAnAccountGetAnIpAccessRulePathParams
  >({ url: '/accounts/{accountId}/firewall/access_rules/rules/{ruleId}', method: 'get', ...variables, signal });

export type IpAccessRulesForAnAccountUpdateAnIpAccessRulePathParams = {
  ruleId: Schemas.FirewallRuleIdentifier;
  accountId: Schemas.FirewallAccountIdentifier;
};

export type IpAccessRulesForAnAccountUpdateAnIpAccessRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type IpAccessRulesForAnAccountUpdateAnIpAccessRuleVariables = {
  body: Schemas.FirewallSchemasRule;
  pathParams: IpAccessRulesForAnAccountUpdateAnIpAccessRulePathParams;
} & FetcherExtraProps;

/**
 * Updates an IP Access rule defined at the account level.
 *
 * Note: This operation will affect all zones in the account.
 */
export const ipAccessRulesForAnAccountUpdateAnIpAccessRule = (
  variables: IpAccessRulesForAnAccountUpdateAnIpAccessRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallResponseSingle,
    IpAccessRulesForAnAccountUpdateAnIpAccessRuleError,
    Schemas.FirewallSchemasRule,
    {},
    {},
    IpAccessRulesForAnAccountUpdateAnIpAccessRulePathParams
  >({ url: '/accounts/{accountId}/firewall/access_rules/rules/{ruleId}', method: 'patch', ...variables, signal });

export type ZeroTrustAccountsGetZeroTrustAccountInformationPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustAccountsGetZeroTrustAccountInformationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Record<string, any> &
    Schemas.ZeroTrustGatewayGatewayAccount &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustAccountsGetZeroTrustAccountInformationVariables = {
  pathParams: ZeroTrustAccountsGetZeroTrustAccountInformationPathParams;
} & FetcherExtraProps;

/**
 * Gets information about the current Zero Trust account.
 */
export const zeroTrustAccountsGetZeroTrustAccountInformation = (
  variables: ZeroTrustAccountsGetZeroTrustAccountInformationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayGatewayAccount,
    ZeroTrustAccountsGetZeroTrustAccountInformationError,
    undefined,
    {},
    {},
    ZeroTrustAccountsGetZeroTrustAccountInformationPathParams
  >({ url: '/accounts/{accountId}/gateway', method: 'get', ...variables, signal });

export type ZeroTrustAccountsCreateZeroTrustAccountPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustAccountsCreateZeroTrustAccountError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Record<string, any> &
    Schemas.ZeroTrustGatewayGatewayAccount &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustAccountsCreateZeroTrustAccountVariables = {
  pathParams: ZeroTrustAccountsCreateZeroTrustAccountPathParams;
} & FetcherExtraProps;

/**
 * Creates a Zero Trust account with an existing Cloudflare account.
 */
export const zeroTrustAccountsCreateZeroTrustAccount = (
  variables: ZeroTrustAccountsCreateZeroTrustAccountVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayGatewayAccount,
    ZeroTrustAccountsCreateZeroTrustAccountError,
    undefined,
    {},
    {},
    ZeroTrustAccountsCreateZeroTrustAccountPathParams
  >({ url: '/accounts/{accountId}/gateway', method: 'post', ...variables, signal });

export type ZeroTrustGatewayApplicationAndApplicationTypeMappingsListApplicationAndApplicationTypeMappingsPathParams = {
  accountId: Schemas.ZeroTrustGatewaySchemasIdentifier;
};

export type ZeroTrustGatewayApplicationAndApplicationTypeMappingsListApplicationAndApplicationTypeMappingsError =
  Fetcher.ErrorWrapper<{
    status: 400;
    payload: Schemas.ZeroTrustGatewayAppTypesComponentsSchemasResponseCollection &
      Schemas.ZeroTrustGatewayApiResponseCommonFailure;
  }>;

export type ZeroTrustGatewayApplicationAndApplicationTypeMappingsListApplicationAndApplicationTypeMappingsVariables = {
  pathParams: ZeroTrustGatewayApplicationAndApplicationTypeMappingsListApplicationAndApplicationTypeMappingsPathParams;
} & FetcherExtraProps;

/**
 * Fetches all application and application type mappings.
 */
export const zeroTrustGatewayApplicationAndApplicationTypeMappingsListApplicationAndApplicationTypeMappings = (
  variables: ZeroTrustGatewayApplicationAndApplicationTypeMappingsListApplicationAndApplicationTypeMappingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayAppTypesComponentsSchemasResponseCollection,
    ZeroTrustGatewayApplicationAndApplicationTypeMappingsListApplicationAndApplicationTypeMappingsError,
    undefined,
    {},
    {},
    ZeroTrustGatewayApplicationAndApplicationTypeMappingsListApplicationAndApplicationTypeMappingsPathParams
  >({ url: '/accounts/{accountId}/gateway/app_types', method: 'get', ...variables, signal });

export type ZeroTrustGetAuditSshSettingsPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustGetAuditSshSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayAuditSshSettingsComponentsSchemasSingleResponse &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustGetAuditSshSettingsVariables = {
  pathParams: ZeroTrustGetAuditSshSettingsPathParams;
} & FetcherExtraProps;

/**
 * Gets all Zero Trust Audit SSH and SSH with Access for Infrastructure settings for an account.
 */
export const zeroTrustGetAuditSshSettings = (variables: ZeroTrustGetAuditSshSettingsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ZeroTrustGatewayAuditSshSettingsComponentsSchemasSingleResponse,
    ZeroTrustGetAuditSshSettingsError,
    undefined,
    {},
    {},
    ZeroTrustGetAuditSshSettingsPathParams
  >({ url: '/accounts/{accountId}/gateway/audit_ssh_settings', method: 'get', ...variables, signal });

export type ZeroTrustUpdateAuditSshSettingsPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustUpdateAuditSshSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayAuditSshSettingsComponentsSchemasSingleResponse &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustUpdateAuditSshSettingsRequestBody = {
  public_key: Schemas.ZeroTrustGatewayPublicKey;
};

export type ZeroTrustUpdateAuditSshSettingsVariables = {
  body: ZeroTrustUpdateAuditSshSettingsRequestBody;
  pathParams: ZeroTrustUpdateAuditSshSettingsPathParams;
} & FetcherExtraProps;

/**
 * Updates Zero Trust Audit SSH and SSH with Access for Infrastructure settings for an account.
 */
export const zeroTrustUpdateAuditSshSettings = (
  variables: ZeroTrustUpdateAuditSshSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayAuditSshSettingsComponentsSchemasSingleResponse,
    ZeroTrustUpdateAuditSshSettingsError,
    ZeroTrustUpdateAuditSshSettingsRequestBody,
    {},
    {},
    ZeroTrustUpdateAuditSshSettingsPathParams
  >({ url: '/accounts/{accountId}/gateway/audit_ssh_settings', method: 'put', ...variables, signal });

export type ZeroTrustRotateSshAccountSeedPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustRotateSshAccountSeedError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayAuditSshSettingsComponentsSchemasSingleResponse &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustRotateSshAccountSeedVariables = {
  pathParams: ZeroTrustRotateSshAccountSeedPathParams;
} & FetcherExtraProps;

/**
 * Rotates the SSH account seed that is used for generating the host key identity when connecting through the Cloudflare SSH Proxy.
 */
export const zeroTrustRotateSshAccountSeed = (
  variables: ZeroTrustRotateSshAccountSeedVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayAuditSshSettingsComponentsSchemasSingleResponse,
    ZeroTrustRotateSshAccountSeedError,
    undefined,
    {},
    {},
    ZeroTrustRotateSshAccountSeedPathParams
  >({ url: '/accounts/{accountId}/gateway/audit_ssh_settings/rotate_seed', method: 'post', ...variables, signal });

export type ZeroTrustGatewayCategoriesListCategoriesPathParams = {
  accountId: Schemas.ZeroTrustGatewaySchemasIdentifier;
};

export type ZeroTrustGatewayCategoriesListCategoriesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayCategoriesComponentsSchemasResponseCollection &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustGatewayCategoriesListCategoriesVariables = {
  pathParams: ZeroTrustGatewayCategoriesListCategoriesPathParams;
} & FetcherExtraProps;

/**
 * Fetches a list of all categories.
 */
export const zeroTrustGatewayCategoriesListCategories = (
  variables: ZeroTrustGatewayCategoriesListCategoriesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayCategoriesComponentsSchemasResponseCollection,
    ZeroTrustGatewayCategoriesListCategoriesError,
    undefined,
    {},
    {},
    ZeroTrustGatewayCategoriesListCategoriesPathParams
  >({ url: '/accounts/{accountId}/gateway/categories', method: 'get', ...variables, signal });

export type ZeroTrustCertificatesListZeroTrustCertificatesPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustCertificatesListZeroTrustCertificatesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayResponseCollection & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustCertificatesListZeroTrustCertificatesVariables = {
  pathParams: ZeroTrustCertificatesListZeroTrustCertificatesPathParams;
} & FetcherExtraProps;

/**
 * Fetches all Zero Trust certificates for an account.
 */
export const zeroTrustCertificatesListZeroTrustCertificates = (
  variables: ZeroTrustCertificatesListZeroTrustCertificatesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayResponseCollection,
    ZeroTrustCertificatesListZeroTrustCertificatesError,
    undefined,
    {},
    {},
    ZeroTrustCertificatesListZeroTrustCertificatesPathParams
  >({ url: '/accounts/{accountId}/gateway/certificates', method: 'get', ...variables, signal });

export type ZeroTrustCertificatesCreateZeroTrustCertificatePathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustCertificatesCreateZeroTrustCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewaySingleResponse & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustCertificatesCreateZeroTrustCertificateVariables = {
  body?: Schemas.ZeroTrustGatewayGenerateCertRequest;
  pathParams: ZeroTrustCertificatesCreateZeroTrustCertificatePathParams;
} & FetcherExtraProps;

/**
 * Creates a new Zero Trust certificate.
 */
export const zeroTrustCertificatesCreateZeroTrustCertificate = (
  variables: ZeroTrustCertificatesCreateZeroTrustCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewaySingleResponse,
    ZeroTrustCertificatesCreateZeroTrustCertificateError,
    Schemas.ZeroTrustGatewayGenerateCertRequest,
    {},
    {},
    ZeroTrustCertificatesCreateZeroTrustCertificatePathParams
  >({ url: '/accounts/{accountId}/gateway/certificates', method: 'post', ...variables, signal });

export type ZeroTrustCertificatesDeleteZeroTrustCertificatePathParams = {
  certificateId: Schemas.ZeroTrustGatewayUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustCertificatesDeleteZeroTrustCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewaySingleResponse & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustCertificatesDeleteZeroTrustCertificateVariables = {
  pathParams: ZeroTrustCertificatesDeleteZeroTrustCertificatePathParams;
} & FetcherExtraProps;

/**
 * Deletes a gateway-managed Zero Trust certificate. A certificate must be deactivated from the edge (inactive) before it is deleted.
 */
export const zeroTrustCertificatesDeleteZeroTrustCertificate = (
  variables: ZeroTrustCertificatesDeleteZeroTrustCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewaySingleResponse,
    ZeroTrustCertificatesDeleteZeroTrustCertificateError,
    undefined,
    {},
    {},
    ZeroTrustCertificatesDeleteZeroTrustCertificatePathParams
  >({ url: '/accounts/{accountId}/gateway/certificates/{certificateId}', method: 'delete', ...variables, signal });

export type ZeroTrustCertificatesZeroTrustCertificateDetailsPathParams = {
  certificateId: Schemas.ZeroTrustGatewayUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustCertificatesZeroTrustCertificateDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewaySingleResponse & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustCertificatesZeroTrustCertificateDetailsVariables = {
  pathParams: ZeroTrustCertificatesZeroTrustCertificateDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetches a single Zero Trust certificate.
 */
export const zeroTrustCertificatesZeroTrustCertificateDetails = (
  variables: ZeroTrustCertificatesZeroTrustCertificateDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewaySingleResponse,
    ZeroTrustCertificatesZeroTrustCertificateDetailsError,
    undefined,
    {},
    {},
    ZeroTrustCertificatesZeroTrustCertificateDetailsPathParams
  >({ url: '/accounts/{accountId}/gateway/certificates/{certificateId}', method: 'get', ...variables, signal });

export type ZeroTrustCertificatesActivateZeroTrustCertificatePathParams = {
  certificateId: Schemas.ZeroTrustGatewayUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustCertificatesActivateZeroTrustCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewaySingleResponse & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustCertificatesActivateZeroTrustCertificateVariables = {
  pathParams: ZeroTrustCertificatesActivateZeroTrustCertificatePathParams;
} & FetcherExtraProps;

/**
 * Binds a single Zero Trust certificate to the edge.
 */
export const zeroTrustCertificatesActivateZeroTrustCertificate = (
  variables: ZeroTrustCertificatesActivateZeroTrustCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewaySingleResponse,
    ZeroTrustCertificatesActivateZeroTrustCertificateError,
    undefined,
    {},
    {},
    ZeroTrustCertificatesActivateZeroTrustCertificatePathParams
  >({
    url: '/accounts/{accountId}/gateway/certificates/{certificateId}/activate',
    method: 'post',
    ...variables,
    signal
  });

export type ZeroTrustCertificatesDeactivateZeroTrustCertificatePathParams = {
  certificateId: Schemas.ZeroTrustGatewayUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustCertificatesDeactivateZeroTrustCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewaySingleResponse & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustCertificatesDeactivateZeroTrustCertificateVariables = {
  pathParams: ZeroTrustCertificatesDeactivateZeroTrustCertificatePathParams;
} & FetcherExtraProps;

/**
 * Unbinds a single Zero Trust certificate from the edge
 */
export const zeroTrustCertificatesDeactivateZeroTrustCertificate = (
  variables: ZeroTrustCertificatesDeactivateZeroTrustCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewaySingleResponse,
    ZeroTrustCertificatesDeactivateZeroTrustCertificateError,
    undefined,
    {},
    {},
    ZeroTrustCertificatesDeactivateZeroTrustCertificatePathParams
  >({
    url: '/accounts/{accountId}/gateway/certificates/{certificateId}/deactivate',
    method: 'post',
    ...variables,
    signal
  });

export type ZeroTrustAccountsGetZeroTrustAccountConfigurationPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustAccountsGetZeroTrustAccountConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayGatewayAccountConfig & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustAccountsGetZeroTrustAccountConfigurationVariables = {
  pathParams: ZeroTrustAccountsGetZeroTrustAccountConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Fetches the current Zero Trust account configuration.
 */
export const zeroTrustAccountsGetZeroTrustAccountConfiguration = (
  variables: ZeroTrustAccountsGetZeroTrustAccountConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayGatewayAccountConfig,
    ZeroTrustAccountsGetZeroTrustAccountConfigurationError,
    undefined,
    {},
    {},
    ZeroTrustAccountsGetZeroTrustAccountConfigurationPathParams
  >({ url: '/accounts/{accountId}/gateway/configuration', method: 'get', ...variables, signal });

export type ZeroTrustAccountsPatchZeroTrustAccountConfigurationPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustAccountsPatchZeroTrustAccountConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayGatewayAccountConfig & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustAccountsPatchZeroTrustAccountConfigurationVariables = {
  body?: Schemas.ZeroTrustGatewayGatewayAccountSettings;
  pathParams: ZeroTrustAccountsPatchZeroTrustAccountConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Patches the current Zero Trust account configuration. This endpoint can update a single subcollection of settings such as `antivirus`, `tls_decrypt`, `activity_log`, `block_page`, `browser_isolation`, `fips`, `body_scanning`, or `certificate`, without updating the entire configuration object. Returns an error if any collection of settings is not properly configured.
 */
export const zeroTrustAccountsPatchZeroTrustAccountConfiguration = (
  variables: ZeroTrustAccountsPatchZeroTrustAccountConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayGatewayAccountConfig,
    ZeroTrustAccountsPatchZeroTrustAccountConfigurationError,
    Schemas.ZeroTrustGatewayGatewayAccountSettings,
    {},
    {},
    ZeroTrustAccountsPatchZeroTrustAccountConfigurationPathParams
  >({ url: '/accounts/{accountId}/gateway/configuration', method: 'patch', ...variables, signal });

export type ZeroTrustAccountsUpdateZeroTrustAccountConfigurationPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustAccountsUpdateZeroTrustAccountConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayGatewayAccountConfig & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustAccountsUpdateZeroTrustAccountConfigurationVariables = {
  body?: Schemas.ZeroTrustGatewayGatewayAccountSettings;
  pathParams: ZeroTrustAccountsUpdateZeroTrustAccountConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Updates the current Zero Trust account configuration.
 */
export const zeroTrustAccountsUpdateZeroTrustAccountConfiguration = (
  variables: ZeroTrustAccountsUpdateZeroTrustAccountConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayGatewayAccountConfig,
    ZeroTrustAccountsUpdateZeroTrustAccountConfigurationError,
    Schemas.ZeroTrustGatewayGatewayAccountSettings,
    {},
    {},
    ZeroTrustAccountsUpdateZeroTrustAccountConfigurationPathParams
  >({ url: '/accounts/{accountId}/gateway/configuration', method: 'put', ...variables, signal });

export type ZeroTrustAccountsGetZeroTrustCertificateConfigurationPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustAccountsGetZeroTrustCertificateConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayCustomCertificateSettings & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustAccountsGetZeroTrustCertificateConfigurationVariables = {
  pathParams: ZeroTrustAccountsGetZeroTrustCertificateConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Fetches the current Zero Trust certificate configuration.
 */
export const zeroTrustAccountsGetZeroTrustCertificateConfiguration = (
  variables: ZeroTrustAccountsGetZeroTrustCertificateConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayCustomCertificateSettings,
    ZeroTrustAccountsGetZeroTrustCertificateConfigurationError,
    undefined,
    {},
    {},
    ZeroTrustAccountsGetZeroTrustCertificateConfigurationPathParams
  >({ url: '/accounts/{accountId}/gateway/configuration/custom_certificate', method: 'get', ...variables, signal });

export type ZeroTrustListsListZeroTrustListsPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustListsListZeroTrustListsQueryParams = {
  type?: Schemas.ZeroTrustGatewaySchemasType;
};

export type ZeroTrustListsListZeroTrustListsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewaySchemasResponseCollection & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustListsListZeroTrustListsVariables = {
  pathParams: ZeroTrustListsListZeroTrustListsPathParams;
  queryParams?: ZeroTrustListsListZeroTrustListsQueryParams;
} & FetcherExtraProps;

/**
 * Fetches all Zero Trust lists for an account.
 */
export const zeroTrustListsListZeroTrustLists = (
  variables: ZeroTrustListsListZeroTrustListsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewaySchemasResponseCollection,
    ZeroTrustListsListZeroTrustListsError,
    undefined,
    {},
    ZeroTrustListsListZeroTrustListsQueryParams,
    ZeroTrustListsListZeroTrustListsPathParams
  >({ url: '/accounts/{accountId}/gateway/lists', method: 'get', ...variables, signal });

export type ZeroTrustListsCreateZeroTrustListPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustListsCreateZeroTrustListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewaySingleResponseWithListItems & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustListsCreateZeroTrustListRequestBody = {
  description?: Schemas.ZeroTrustGatewayDescription;
  items?: Schemas.ZeroTrustGatewayItems;
  name: Schemas.ZeroTrustGatewayName;
  type: Schemas.ZeroTrustGatewaySchemasType;
};

export type ZeroTrustListsCreateZeroTrustListVariables = {
  body: ZeroTrustListsCreateZeroTrustListRequestBody;
  pathParams: ZeroTrustListsCreateZeroTrustListPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Zero Trust list.
 */
export const zeroTrustListsCreateZeroTrustList = (
  variables: ZeroTrustListsCreateZeroTrustListVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewaySingleResponseWithListItems,
    ZeroTrustListsCreateZeroTrustListError,
    ZeroTrustListsCreateZeroTrustListRequestBody,
    {},
    {},
    ZeroTrustListsCreateZeroTrustListPathParams
  >({ url: '/accounts/{accountId}/gateway/lists', method: 'post', ...variables, signal });

export type ZeroTrustListsDeleteZeroTrustListPathParams = {
  listId: Schemas.ZeroTrustGatewaySchemasUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustListsDeleteZeroTrustListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayEmptyResponse & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustListsDeleteZeroTrustListVariables = {
  pathParams: ZeroTrustListsDeleteZeroTrustListPathParams;
} & FetcherExtraProps;

/**
 * Deletes a Zero Trust list.
 */
export const zeroTrustListsDeleteZeroTrustList = (
  variables: ZeroTrustListsDeleteZeroTrustListVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayEmptyResponse,
    ZeroTrustListsDeleteZeroTrustListError,
    undefined,
    {},
    {},
    ZeroTrustListsDeleteZeroTrustListPathParams
  >({ url: '/accounts/{accountId}/gateway/lists/{listId}', method: 'delete', ...variables, signal });

export type ZeroTrustListsZeroTrustListDetailsPathParams = {
  listId: Schemas.ZeroTrustGatewaySchemasUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustListsZeroTrustListDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewaySchemasSingleResponse & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustListsZeroTrustListDetailsVariables = {
  pathParams: ZeroTrustListsZeroTrustListDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetches a single Zero Trust list.
 */
export const zeroTrustListsZeroTrustListDetails = (
  variables: ZeroTrustListsZeroTrustListDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewaySchemasSingleResponse,
    ZeroTrustListsZeroTrustListDetailsError,
    undefined,
    {},
    {},
    ZeroTrustListsZeroTrustListDetailsPathParams
  >({ url: '/accounts/{accountId}/gateway/lists/{listId}', method: 'get', ...variables, signal });

export type ZeroTrustListsPatchZeroTrustListPathParams = {
  listId: Schemas.ZeroTrustGatewaySchemasUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustListsPatchZeroTrustListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewaySchemasSingleResponse & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustListsPatchZeroTrustListRequestBody = {
  append?: Schemas.ZeroTrustGatewayItems;
  /**
   * A list of the item values you want to remove.
   */
  remove?: Schemas.ZeroTrustGatewayValue[];
};

export type ZeroTrustListsPatchZeroTrustListVariables = {
  body?: ZeroTrustListsPatchZeroTrustListRequestBody;
  pathParams: ZeroTrustListsPatchZeroTrustListPathParams;
} & FetcherExtraProps;

/**
 * Appends or removes an item from a configured Zero Trust list.
 */
export const zeroTrustListsPatchZeroTrustList = (
  variables: ZeroTrustListsPatchZeroTrustListVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewaySchemasSingleResponse,
    ZeroTrustListsPatchZeroTrustListError,
    ZeroTrustListsPatchZeroTrustListRequestBody,
    {},
    {},
    ZeroTrustListsPatchZeroTrustListPathParams
  >({ url: '/accounts/{accountId}/gateway/lists/{listId}', method: 'patch', ...variables, signal });

export type ZeroTrustListsUpdateZeroTrustListPathParams = {
  listId: Schemas.ZeroTrustGatewaySchemasUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustListsUpdateZeroTrustListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewaySchemasSingleResponse & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustListsUpdateZeroTrustListRequestBody = {
  description?: Schemas.ZeroTrustGatewayDescription;
  items?: Schemas.ZeroTrustGatewayItems;
  name: Schemas.ZeroTrustGatewayName;
};

export type ZeroTrustListsUpdateZeroTrustListVariables = {
  body: ZeroTrustListsUpdateZeroTrustListRequestBody;
  pathParams: ZeroTrustListsUpdateZeroTrustListPathParams;
} & FetcherExtraProps;

/**
 * Updates a configured Zero Trust list. Skips updating list items if not included in the payload.
 */
export const zeroTrustListsUpdateZeroTrustList = (
  variables: ZeroTrustListsUpdateZeroTrustListVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewaySchemasSingleResponse,
    ZeroTrustListsUpdateZeroTrustListError,
    ZeroTrustListsUpdateZeroTrustListRequestBody,
    {},
    {},
    ZeroTrustListsUpdateZeroTrustListPathParams
  >({ url: '/accounts/{accountId}/gateway/lists/{listId}', method: 'put', ...variables, signal });

export type ZeroTrustListsZeroTrustListItemsPathParams = {
  listId: Schemas.ZeroTrustGatewaySchemasUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustListsZeroTrustListItemsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayListItemResponseCollection & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustListsZeroTrustListItemsVariables = {
  pathParams: ZeroTrustListsZeroTrustListItemsPathParams;
} & FetcherExtraProps;

/**
 * Fetches all items in a single Zero Trust list.
 */
export const zeroTrustListsZeroTrustListItems = (
  variables: ZeroTrustListsZeroTrustListItemsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayListItemResponseCollection,
    ZeroTrustListsZeroTrustListItemsError,
    undefined,
    {},
    {},
    ZeroTrustListsZeroTrustListItemsPathParams
  >({ url: '/accounts/{accountId}/gateway/lists/{listId}/items', method: 'get', ...variables, signal });

export type ZeroTrustGatewayLocationsListZeroTrustGatewayLocationsPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustGatewayLocationsListZeroTrustGatewayLocationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayComponentsSchemasResponseCollection &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustGatewayLocationsListZeroTrustGatewayLocationsVariables = {
  pathParams: ZeroTrustGatewayLocationsListZeroTrustGatewayLocationsPathParams;
} & FetcherExtraProps;

/**
 * Fetches Zero Trust Gateway locations for an account.
 */
export const zeroTrustGatewayLocationsListZeroTrustGatewayLocations = (
  variables: ZeroTrustGatewayLocationsListZeroTrustGatewayLocationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayComponentsSchemasResponseCollection,
    ZeroTrustGatewayLocationsListZeroTrustGatewayLocationsError,
    undefined,
    {},
    {},
    ZeroTrustGatewayLocationsListZeroTrustGatewayLocationsPathParams
  >({ url: '/accounts/{accountId}/gateway/locations', method: 'get', ...variables, signal });

export type ZeroTrustGatewayLocationsCreateZeroTrustGatewayLocationPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustGatewayLocationsCreateZeroTrustGatewayLocationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayComponentsSchemasSingleResponse & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustGatewayLocationsCreateZeroTrustGatewayLocationRequestBody = {
  client_default?: Schemas.ZeroTrustGatewayClientDefault;
  dns_destination_ips_id?: Schemas.ZeroTrustGatewayDnsDestinationIpsIdWrite;
  ecs_support?: Schemas.ZeroTrustGatewayEcsSupport;
  endpoints?: Schemas.ZeroTrustGatewayEndpoints;
  name: Schemas.ZeroTrustGatewaySchemasName;
  networks?: Schemas.ZeroTrustGatewayIpv4Networks;
};

export type ZeroTrustGatewayLocationsCreateZeroTrustGatewayLocationVariables = {
  body: ZeroTrustGatewayLocationsCreateZeroTrustGatewayLocationRequestBody;
  pathParams: ZeroTrustGatewayLocationsCreateZeroTrustGatewayLocationPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Zero Trust Gateway location.
 */
export const zeroTrustGatewayLocationsCreateZeroTrustGatewayLocation = (
  variables: ZeroTrustGatewayLocationsCreateZeroTrustGatewayLocationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayComponentsSchemasSingleResponse,
    ZeroTrustGatewayLocationsCreateZeroTrustGatewayLocationError,
    ZeroTrustGatewayLocationsCreateZeroTrustGatewayLocationRequestBody,
    {},
    {},
    ZeroTrustGatewayLocationsCreateZeroTrustGatewayLocationPathParams
  >({ url: '/accounts/{accountId}/gateway/locations', method: 'post', ...variables, signal });

export type ZeroTrustGatewayLocationsDeleteZeroTrustGatewayLocationPathParams = {
  locationId: Schemas.ZeroTrustGatewayComponentsSchemasUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustGatewayLocationsDeleteZeroTrustGatewayLocationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayEmptyResponse & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustGatewayLocationsDeleteZeroTrustGatewayLocationVariables = {
  pathParams: ZeroTrustGatewayLocationsDeleteZeroTrustGatewayLocationPathParams;
} & FetcherExtraProps;

/**
 * Deletes a configured Zero Trust Gateway location.
 */
export const zeroTrustGatewayLocationsDeleteZeroTrustGatewayLocation = (
  variables: ZeroTrustGatewayLocationsDeleteZeroTrustGatewayLocationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayEmptyResponse,
    ZeroTrustGatewayLocationsDeleteZeroTrustGatewayLocationError,
    undefined,
    {},
    {},
    ZeroTrustGatewayLocationsDeleteZeroTrustGatewayLocationPathParams
  >({ url: '/accounts/{accountId}/gateway/locations/{locationId}', method: 'delete', ...variables, signal });

export type ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsPathParams = {
  locationId: Schemas.ZeroTrustGatewayComponentsSchemasUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayComponentsSchemasSingleResponse & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsVariables = {
  pathParams: ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetches a single Zero Trust Gateway location.
 */
export const zeroTrustGatewayLocationsZeroTrustGatewayLocationDetails = (
  variables: ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayComponentsSchemasSingleResponse,
    ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsError,
    undefined,
    {},
    {},
    ZeroTrustGatewayLocationsZeroTrustGatewayLocationDetailsPathParams
  >({ url: '/accounts/{accountId}/gateway/locations/{locationId}', method: 'get', ...variables, signal });

export type ZeroTrustGatewayLocationsUpdateZeroTrustGatewayLocationPathParams = {
  locationId: Schemas.ZeroTrustGatewayComponentsSchemasUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustGatewayLocationsUpdateZeroTrustGatewayLocationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayComponentsSchemasSingleResponse & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustGatewayLocationsUpdateZeroTrustGatewayLocationRequestBody = {
  client_default?: Schemas.ZeroTrustGatewayClientDefault;
  dns_destination_ips_id?: Schemas.ZeroTrustGatewayDnsDestinationIpsIdWrite;
  ecs_support?: Schemas.ZeroTrustGatewayEcsSupport;
  endpoints?: Schemas.ZeroTrustGatewayEndpoints;
  name: Schemas.ZeroTrustGatewaySchemasName;
  networks?: Schemas.ZeroTrustGatewayIpv4Networks;
};

export type ZeroTrustGatewayLocationsUpdateZeroTrustGatewayLocationVariables = {
  body: ZeroTrustGatewayLocationsUpdateZeroTrustGatewayLocationRequestBody;
  pathParams: ZeroTrustGatewayLocationsUpdateZeroTrustGatewayLocationPathParams;
} & FetcherExtraProps;

/**
 * Updates a configured Zero Trust Gateway location.
 */
export const zeroTrustGatewayLocationsUpdateZeroTrustGatewayLocation = (
  variables: ZeroTrustGatewayLocationsUpdateZeroTrustGatewayLocationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayComponentsSchemasSingleResponse,
    ZeroTrustGatewayLocationsUpdateZeroTrustGatewayLocationError,
    ZeroTrustGatewayLocationsUpdateZeroTrustGatewayLocationRequestBody,
    {},
    {},
    ZeroTrustGatewayLocationsUpdateZeroTrustGatewayLocationPathParams
  >({ url: '/accounts/{accountId}/gateway/locations/{locationId}', method: 'put', ...variables, signal });

export type ZeroTrustAccountsGetLoggingSettingsForTheZeroTrustAccountPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustAccountsGetLoggingSettingsForTheZeroTrustAccountError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayGatewayAccountLoggingSettingsResponse &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustAccountsGetLoggingSettingsForTheZeroTrustAccountVariables = {
  pathParams: ZeroTrustAccountsGetLoggingSettingsForTheZeroTrustAccountPathParams;
} & FetcherExtraProps;

/**
 * Fetches the current logging settings for Zero Trust account.
 */
export const zeroTrustAccountsGetLoggingSettingsForTheZeroTrustAccount = (
  variables: ZeroTrustAccountsGetLoggingSettingsForTheZeroTrustAccountVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayGatewayAccountLoggingSettingsResponse,
    ZeroTrustAccountsGetLoggingSettingsForTheZeroTrustAccountError,
    undefined,
    {},
    {},
    ZeroTrustAccountsGetLoggingSettingsForTheZeroTrustAccountPathParams
  >({ url: '/accounts/{accountId}/gateway/logging', method: 'get', ...variables, signal });

export type ZeroTrustAccountsUpdateLoggingSettingsForTheZeroTrustAccountPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustAccountsUpdateLoggingSettingsForTheZeroTrustAccountError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayGatewayAccountLoggingSettingsResponse &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustAccountsUpdateLoggingSettingsForTheZeroTrustAccountVariables = {
  body?: Schemas.ZeroTrustGatewayGatewayAccountLoggingSettings;
  pathParams: ZeroTrustAccountsUpdateLoggingSettingsForTheZeroTrustAccountPathParams;
} & FetcherExtraProps;

/**
 * Updates logging settings for the current Zero Trust account.
 */
export const zeroTrustAccountsUpdateLoggingSettingsForTheZeroTrustAccount = (
  variables: ZeroTrustAccountsUpdateLoggingSettingsForTheZeroTrustAccountVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayGatewayAccountLoggingSettingsResponse,
    ZeroTrustAccountsUpdateLoggingSettingsForTheZeroTrustAccountError,
    Schemas.ZeroTrustGatewayGatewayAccountLoggingSettings,
    {},
    {},
    ZeroTrustAccountsUpdateLoggingSettingsForTheZeroTrustAccountPathParams
  >({ url: '/accounts/{accountId}/gateway/logging', method: 'put', ...variables, signal });

export type ZeroTrustGatewayProxyEndpointsListProxyEndpointsPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustGatewayProxyEndpointsListProxyEndpointsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayProxyEndpointsComponentsSchemasSingleResponse &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustGatewayProxyEndpointsListProxyEndpointsVariables = {
  pathParams: ZeroTrustGatewayProxyEndpointsListProxyEndpointsPathParams;
} & FetcherExtraProps;

/**
 * Fetches all Zero Trust Gateway proxy endpoints for an account.
 */
export const zeroTrustGatewayProxyEndpointsListProxyEndpoints = (
  variables: ZeroTrustGatewayProxyEndpointsListProxyEndpointsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayProxyEndpointsComponentsSchemasSingleResponse,
    ZeroTrustGatewayProxyEndpointsListProxyEndpointsError,
    undefined,
    {},
    {},
    ZeroTrustGatewayProxyEndpointsListProxyEndpointsPathParams
  >({ url: '/accounts/{accountId}/gateway/proxy_endpoints', method: 'get', ...variables, signal });

export type ZeroTrustGatewayProxyEndpointsCreateProxyEndpointPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustGatewayProxyEndpointsCreateProxyEndpointError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayProxyEndpointsComponentsSchemasSingleResponse &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustGatewayProxyEndpointsCreateProxyEndpointRequestBody = {
  ips: Schemas.ZeroTrustGatewayIps;
  name: Schemas.ZeroTrustGatewayProxyEndpointsComponentsSchemasName;
};

export type ZeroTrustGatewayProxyEndpointsCreateProxyEndpointVariables = {
  body: ZeroTrustGatewayProxyEndpointsCreateProxyEndpointRequestBody;
  pathParams: ZeroTrustGatewayProxyEndpointsCreateProxyEndpointPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Zero Trust Gateway proxy endpoint.
 */
export const zeroTrustGatewayProxyEndpointsCreateProxyEndpoint = (
  variables: ZeroTrustGatewayProxyEndpointsCreateProxyEndpointVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayProxyEndpointsComponentsSchemasSingleResponse,
    ZeroTrustGatewayProxyEndpointsCreateProxyEndpointError,
    ZeroTrustGatewayProxyEndpointsCreateProxyEndpointRequestBody,
    {},
    {},
    ZeroTrustGatewayProxyEndpointsCreateProxyEndpointPathParams
  >({ url: '/accounts/{accountId}/gateway/proxy_endpoints', method: 'post', ...variables, signal });

export type ZeroTrustGatewayProxyEndpointsDeleteProxyEndpointPathParams = {
  proxyEndpointId: Schemas.ZeroTrustGatewayComponentsSchemasUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustGatewayProxyEndpointsDeleteProxyEndpointError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Record<string, any> &
    Schemas.ZeroTrustGatewayEmptyResponse &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustGatewayProxyEndpointsDeleteProxyEndpointVariables = {
  pathParams: ZeroTrustGatewayProxyEndpointsDeleteProxyEndpointPathParams;
} & FetcherExtraProps;

/**
 * Deletes a configured Zero Trust Gateway proxy endpoint.
 */
export const zeroTrustGatewayProxyEndpointsDeleteProxyEndpoint = (
  variables: ZeroTrustGatewayProxyEndpointsDeleteProxyEndpointVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayEmptyResponse,
    ZeroTrustGatewayProxyEndpointsDeleteProxyEndpointError,
    undefined,
    {},
    {},
    ZeroTrustGatewayProxyEndpointsDeleteProxyEndpointPathParams
  >({ url: '/accounts/{accountId}/gateway/proxy_endpoints/{proxyEndpointId}', method: 'delete', ...variables, signal });

export type ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsPathParams = {
  proxyEndpointId: Schemas.ZeroTrustGatewayComponentsSchemasUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Record<string, any> &
    Schemas.ZeroTrustGatewayProxyEndpointsComponentsSchemasResponseCollection &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsVariables = {
  pathParams: ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetches a single Zero Trust Gateway proxy endpoint.
 */
export const zeroTrustGatewayProxyEndpointsProxyEndpointDetails = (
  variables: ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayProxyEndpointsComponentsSchemasResponseCollection,
    ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsError,
    undefined,
    {},
    {},
    ZeroTrustGatewayProxyEndpointsProxyEndpointDetailsPathParams
  >({ url: '/accounts/{accountId}/gateway/proxy_endpoints/{proxyEndpointId}', method: 'get', ...variables, signal });

export type ZeroTrustGatewayProxyEndpointsUpdateProxyEndpointPathParams = {
  proxyEndpointId: Schemas.ZeroTrustGatewayComponentsSchemasUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustGatewayProxyEndpointsUpdateProxyEndpointError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayProxyEndpointsComponentsSchemasSingleResponse &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustGatewayProxyEndpointsUpdateProxyEndpointRequestBody = {
  ips?: Schemas.ZeroTrustGatewayIps;
  name?: Schemas.ZeroTrustGatewayProxyEndpointsComponentsSchemasName;
};

export type ZeroTrustGatewayProxyEndpointsUpdateProxyEndpointVariables = {
  body?: ZeroTrustGatewayProxyEndpointsUpdateProxyEndpointRequestBody;
  pathParams: ZeroTrustGatewayProxyEndpointsUpdateProxyEndpointPathParams;
} & FetcherExtraProps;

/**
 * Updates a configured Zero Trust Gateway proxy endpoint.
 */
export const zeroTrustGatewayProxyEndpointsUpdateProxyEndpoint = (
  variables: ZeroTrustGatewayProxyEndpointsUpdateProxyEndpointVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayProxyEndpointsComponentsSchemasSingleResponse,
    ZeroTrustGatewayProxyEndpointsUpdateProxyEndpointError,
    ZeroTrustGatewayProxyEndpointsUpdateProxyEndpointRequestBody,
    {},
    {},
    ZeroTrustGatewayProxyEndpointsUpdateProxyEndpointPathParams
  >({ url: '/accounts/{accountId}/gateway/proxy_endpoints/{proxyEndpointId}', method: 'patch', ...variables, signal });

export type ZeroTrustGatewayRulesListZeroTrustGatewayRulesPathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustGatewayRulesListZeroTrustGatewayRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Record<string, any> &
    Schemas.ZeroTrustGatewayRulesComponentsSchemasResponseCollection &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustGatewayRulesListZeroTrustGatewayRulesVariables = {
  pathParams: ZeroTrustGatewayRulesListZeroTrustGatewayRulesPathParams;
} & FetcherExtraProps;

/**
 * Fetches the Zero Trust Gateway rules for an account.
 */
export const zeroTrustGatewayRulesListZeroTrustGatewayRules = (
  variables: ZeroTrustGatewayRulesListZeroTrustGatewayRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayRulesComponentsSchemasResponseCollection,
    ZeroTrustGatewayRulesListZeroTrustGatewayRulesError,
    undefined,
    {},
    {},
    ZeroTrustGatewayRulesListZeroTrustGatewayRulesPathParams
  >({ url: '/accounts/{accountId}/gateway/rules', method: 'get', ...variables, signal });

export type ZeroTrustGatewayRulesCreateZeroTrustGatewayRulePathParams = {
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustGatewayRulesCreateZeroTrustGatewayRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Record<string, any> &
    Schemas.ZeroTrustGatewayRulesComponentsSchemasSingleResponse &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustGatewayRulesCreateZeroTrustGatewayRuleRequestBody = {
  action: Schemas.ZeroTrustGatewayAction;
  description?: Schemas.ZeroTrustGatewaySchemasDescription;
  device_posture?: Schemas.ZeroTrustGatewayDevicePosture;
  enabled?: Schemas.ZeroTrustGatewayEnabled;
  expiration?: Schemas.ZeroTrustGatewayExpiration;
  filters?: Schemas.ZeroTrustGatewayFilters;
  identity?: Schemas.ZeroTrustGatewayIdentity;
  name: Schemas.ZeroTrustGatewayComponentsSchemasName;
  precedence?: Schemas.ZeroTrustGatewayPrecedence;
  rule_settings?: Schemas.ZeroTrustGatewayRuleSettings;
  schedule?: Schemas.ZeroTrustGatewaySchedule;
  traffic?: Schemas.ZeroTrustGatewayTraffic;
};

export type ZeroTrustGatewayRulesCreateZeroTrustGatewayRuleVariables = {
  body: ZeroTrustGatewayRulesCreateZeroTrustGatewayRuleRequestBody;
  pathParams: ZeroTrustGatewayRulesCreateZeroTrustGatewayRulePathParams;
} & FetcherExtraProps;

/**
 * Creates a new Zero Trust Gateway rule.
 */
export const zeroTrustGatewayRulesCreateZeroTrustGatewayRule = (
  variables: ZeroTrustGatewayRulesCreateZeroTrustGatewayRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayRulesComponentsSchemasSingleResponse,
    ZeroTrustGatewayRulesCreateZeroTrustGatewayRuleError,
    ZeroTrustGatewayRulesCreateZeroTrustGatewayRuleRequestBody,
    {},
    {},
    ZeroTrustGatewayRulesCreateZeroTrustGatewayRulePathParams
  >({ url: '/accounts/{accountId}/gateway/rules', method: 'post', ...variables, signal });

export type ZeroTrustGatewayRulesDeleteZeroTrustGatewayRulePathParams = {
  ruleId: Schemas.ZeroTrustGatewayRulesComponentsSchemasUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustGatewayRulesDeleteZeroTrustGatewayRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayEmptyResponse & Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustGatewayRulesDeleteZeroTrustGatewayRuleVariables = {
  pathParams: ZeroTrustGatewayRulesDeleteZeroTrustGatewayRulePathParams;
} & FetcherExtraProps;

/**
 * Deletes a Zero Trust Gateway rule.
 */
export const zeroTrustGatewayRulesDeleteZeroTrustGatewayRule = (
  variables: ZeroTrustGatewayRulesDeleteZeroTrustGatewayRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayEmptyResponse,
    ZeroTrustGatewayRulesDeleteZeroTrustGatewayRuleError,
    undefined,
    {},
    {},
    ZeroTrustGatewayRulesDeleteZeroTrustGatewayRulePathParams
  >({ url: '/accounts/{accountId}/gateway/rules/{ruleId}', method: 'delete', ...variables, signal });

export type ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsPathParams = {
  ruleId: Schemas.ZeroTrustGatewayRulesComponentsSchemasUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Record<string, any> &
    Schemas.ZeroTrustGatewayRulesComponentsSchemasSingleResponse &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsVariables = {
  pathParams: ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetches a single Zero Trust Gateway rule.
 */
export const zeroTrustGatewayRulesZeroTrustGatewayRuleDetails = (
  variables: ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayRulesComponentsSchemasSingleResponse,
    ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsError,
    undefined,
    {},
    {},
    ZeroTrustGatewayRulesZeroTrustGatewayRuleDetailsPathParams
  >({ url: '/accounts/{accountId}/gateway/rules/{ruleId}', method: 'get', ...variables, signal });

export type ZeroTrustGatewayRulesUpdateZeroTrustGatewayRulePathParams = {
  ruleId: Schemas.ZeroTrustGatewayRulesComponentsSchemasUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustGatewayRulesUpdateZeroTrustGatewayRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Record<string, any> &
    Schemas.ZeroTrustGatewayRulesComponentsSchemasSingleResponse &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustGatewayRulesUpdateZeroTrustGatewayRuleRequestBody = {
  action: Schemas.ZeroTrustGatewayAction;
  description?: Schemas.ZeroTrustGatewaySchemasDescription;
  device_posture?: Schemas.ZeroTrustGatewayDevicePosture;
  enabled?: Schemas.ZeroTrustGatewayEnabled;
  expiration?: Schemas.ZeroTrustGatewayExpiration;
  filters?: Schemas.ZeroTrustGatewayFilters;
  identity?: Schemas.ZeroTrustGatewayIdentity;
  name: Schemas.ZeroTrustGatewayComponentsSchemasName;
  precedence?: Schemas.ZeroTrustGatewayPrecedence;
  rule_settings?: Schemas.ZeroTrustGatewayRuleSettings;
  schedule?: Schemas.ZeroTrustGatewaySchedule;
  traffic?: Schemas.ZeroTrustGatewayTraffic;
};

export type ZeroTrustGatewayRulesUpdateZeroTrustGatewayRuleVariables = {
  body: ZeroTrustGatewayRulesUpdateZeroTrustGatewayRuleRequestBody;
  pathParams: ZeroTrustGatewayRulesUpdateZeroTrustGatewayRulePathParams;
} & FetcherExtraProps;

/**
 * Updates a configured Zero Trust Gateway rule.
 */
export const zeroTrustGatewayRulesUpdateZeroTrustGatewayRule = (
  variables: ZeroTrustGatewayRulesUpdateZeroTrustGatewayRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayRulesComponentsSchemasSingleResponse,
    ZeroTrustGatewayRulesUpdateZeroTrustGatewayRuleError,
    ZeroTrustGatewayRulesUpdateZeroTrustGatewayRuleRequestBody,
    {},
    {},
    ZeroTrustGatewayRulesUpdateZeroTrustGatewayRulePathParams
  >({ url: '/accounts/{accountId}/gateway/rules/{ruleId}', method: 'put', ...variables, signal });

export type ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRulePathParams = {
  ruleId: Schemas.ZeroTrustGatewayRulesComponentsSchemasUuid;
  accountId: Schemas.ZeroTrustGatewayIdentifier;
};

export type ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZeroTrustGatewayRulesComponentsSchemasSingleResponse &
    Schemas.ZeroTrustGatewayApiResponseCommonFailure;
}>;

export type ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRuleVariables = {
  pathParams: ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRulePathParams;
} & FetcherExtraProps;

/**
 * Resets the expiration of a Zero Trust Gateway Rule if its duration has elapsed and it has a default duration.
 *
 * The Zero Trust Gateway Rule must have values for both `expiration.expires_at` and `expiration.duration`.
 */
export const zeroTrustGatewayRulesResetExpirationZeroTrustGatewayRule = (
  variables: ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZeroTrustGatewayRulesComponentsSchemasSingleResponse,
    ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRuleError,
    undefined,
    {},
    {},
    ZeroTrustGatewayRulesResetExpirationZeroTrustGatewayRulePathParams
  >({ url: '/accounts/{accountId}/gateway/rules/{ruleId}/reset_expiration', method: 'post', ...variables, signal });

export type ListHyperdrivePathParams = {
  accountId: Schemas.HyperdriveIdentifier;
};

export type ListHyperdriveError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.HyperdriveApiResponseCommonFailure;
}>;

export type ListHyperdriveResponse = Schemas.HyperdriveApiResponseCollection & {
  result?: Schemas.HyperdriveHyperdriveConfigResponse[];
};

export type ListHyperdriveVariables = {
  pathParams: ListHyperdrivePathParams;
} & FetcherExtraProps;

/**
 * Returns a list of Hyperdrives
 */
export const listHyperdrive = (variables: ListHyperdriveVariables, signal?: AbortSignal) =>
  fetch<ListHyperdriveResponse, ListHyperdriveError, undefined, {}, {}, ListHyperdrivePathParams>({
    url: '/accounts/{accountId}/hyperdrive/configs',
    method: 'get',
    ...variables,
    signal
  });

export type CreateHyperdrivePathParams = {
  accountId: Schemas.HyperdriveIdentifier;
};

export type CreateHyperdriveError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.HyperdriveApiResponseCommonFailure;
}>;

export type CreateHyperdriveResponse = Schemas.HyperdriveApiResponseSingle & {
  result?: Schemas.HyperdriveHyperdriveConfigResponse;
};

export type CreateHyperdriveVariables = {
  body: Schemas.HyperdriveHyperdriveConfig;
  pathParams: CreateHyperdrivePathParams;
} & FetcherExtraProps;

/**
 * Creates and returns a new Hyperdrive configuration.
 */
export const createHyperdrive = (variables: CreateHyperdriveVariables, signal?: AbortSignal) =>
  fetch<
    CreateHyperdriveResponse,
    CreateHyperdriveError,
    Schemas.HyperdriveHyperdriveConfig,
    {},
    {},
    CreateHyperdrivePathParams
  >({ url: '/accounts/{accountId}/hyperdrive/configs', method: 'post', ...variables, signal });

export type DeleteHyperdrivePathParams = {
  accountId: Schemas.HyperdriveIdentifier;
  hyperdriveId: Schemas.HyperdriveIdentifier;
};

export type DeleteHyperdriveError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.HyperdriveApiResponseCommonFailure;
}>;

export type DeleteHyperdriveResponse = Schemas.HyperdriveApiResponseSingle & {
  result?: Record<string, any> | null;
};

export type DeleteHyperdriveVariables = {
  pathParams: DeleteHyperdrivePathParams;
} & FetcherExtraProps;

/**
 * Deletes the specified Hyperdrive.
 */
export const deleteHyperdrive = (variables: DeleteHyperdriveVariables, signal?: AbortSignal) =>
  fetch<DeleteHyperdriveResponse, DeleteHyperdriveError, undefined, {}, {}, DeleteHyperdrivePathParams>({
    url: '/accounts/{accountId}/hyperdrive/configs/{hyperdriveId}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetHyperdrivePathParams = {
  accountId: Schemas.HyperdriveIdentifier;
  hyperdriveId: Schemas.HyperdriveIdentifier;
};

export type GetHyperdriveError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.HyperdriveApiResponseCommonFailure;
}>;

export type GetHyperdriveResponse = Schemas.HyperdriveApiResponseSingle & {
  result?: Schemas.HyperdriveHyperdriveConfigResponse;
};

export type GetHyperdriveVariables = {
  pathParams: GetHyperdrivePathParams;
} & FetcherExtraProps;

/**
 * Returns the specified Hyperdrive configuration.
 */
export const getHyperdrive = (variables: GetHyperdriveVariables, signal?: AbortSignal) =>
  fetch<GetHyperdriveResponse, GetHyperdriveError, undefined, {}, {}, GetHyperdrivePathParams>({
    url: '/accounts/{accountId}/hyperdrive/configs/{hyperdriveId}',
    method: 'get',
    ...variables,
    signal
  });

export type PatchHyperdrivePathParams = {
  accountId: Schemas.HyperdriveIdentifier;
  hyperdriveId: Schemas.HyperdriveIdentifier;
};

export type PatchHyperdriveError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.HyperdriveApiResponseCommonFailure;
}>;

export type PatchHyperdriveResponse = {
  errors: Schemas.HyperdriveMessages;
  messages: Schemas.HyperdriveMessages;
  result: Schemas.HyperdriveHyperdriveConfigResponse;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type PatchHyperdriveVariables = {
  body?: Schemas.HyperdriveHyperdriveConfigPatch;
  pathParams: PatchHyperdrivePathParams;
} & FetcherExtraProps;

/**
 * Patches and returns the specified Hyperdrive configuration. Custom caching settings are not kept if caching is disabled.
 */
export const patchHyperdrive = (variables: PatchHyperdriveVariables, signal?: AbortSignal) =>
  fetch<
    PatchHyperdriveResponse,
    PatchHyperdriveError,
    Schemas.HyperdriveHyperdriveConfigPatch,
    {},
    {},
    PatchHyperdrivePathParams
  >({ url: '/accounts/{accountId}/hyperdrive/configs/{hyperdriveId}', method: 'patch', ...variables, signal });

export type UpdateHyperdrivePathParams = {
  accountId: Schemas.HyperdriveIdentifier;
  hyperdriveId: Schemas.HyperdriveIdentifier;
};

export type UpdateHyperdriveError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.HyperdriveApiResponseCommonFailure;
}>;

export type UpdateHyperdriveResponse = Schemas.HyperdriveApiResponseSingle & {
  result?: Schemas.HyperdriveHyperdriveConfigResponse;
};

export type UpdateHyperdriveVariables = {
  body: Schemas.HyperdriveHyperdriveConfig;
  pathParams: UpdateHyperdrivePathParams;
} & FetcherExtraProps;

/**
 * Updates and returns the specified Hyperdrive configuration.
 */
export const updateHyperdrive = (variables: UpdateHyperdriveVariables, signal?: AbortSignal) =>
  fetch<
    UpdateHyperdriveResponse,
    UpdateHyperdriveError,
    Schemas.HyperdriveHyperdriveConfig,
    {},
    {},
    UpdateHyperdrivePathParams
  >({ url: '/accounts/{accountId}/hyperdrive/configs/{hyperdriveId}', method: 'put', ...variables, signal });

export type AccountPermissionGroupListPathParams = {
  accountId: Schemas.IamAccountIdentifier;
};

export type AccountPermissionGroupListQueryParams = {
  /**
   * @example 6d7f2f5f5b1d4a0e9081fdc98d432fd1
   * @maxLength 32
   * @minLength 32
   */
  id?: string;
  /**
   * @example NameOfThePermissionGroup
   */
  name?: string;
  /**
   * @example labelOfThePermissionGroup
   */
  label?: string;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
};

export type AccountPermissionGroupListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountPermissionGroupListVariables = {
  pathParams: AccountPermissionGroupListPathParams;
  queryParams?: AccountPermissionGroupListQueryParams;
} & FetcherExtraProps;

/**
 * List all the permissions groups for an account.
 */
export const accountPermissionGroupList = (variables: AccountPermissionGroupListVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamCollectionPermissionGroupsResponse,
    AccountPermissionGroupListError,
    undefined,
    {},
    AccountPermissionGroupListQueryParams,
    AccountPermissionGroupListPathParams
  >({ url: '/accounts/{accountId}/iam/permission_groups', method: 'get', ...variables, signal });

export type AccountPermissionGroupDetailsPathParams = {
  accountId: Schemas.IamAccountIdentifier;
  permissionGroupId: Schemas.IamPermissionGroupComponentsSchemasIdentifier;
};

export type AccountPermissionGroupDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountPermissionGroupDetailsVariables = {
  pathParams: AccountPermissionGroupDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get information about a specific permission group in an account.
 */
export const accountPermissionGroupDetails = (
  variables: AccountPermissionGroupDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.IamPermissionGroup,
    AccountPermissionGroupDetailsError,
    undefined,
    {},
    {},
    AccountPermissionGroupDetailsPathParams
  >({ url: '/accounts/{accountId}/iam/permission_groups/{permissionGroupId}', method: 'get', ...variables, signal });

export type AccountResourceGroupListPathParams = {
  accountId: Schemas.IamAccountIdentifier;
};

export type AccountResourceGroupListQueryParams = {
  /**
   * @example 6d7f2f5f5b1d4a0e9081fdc98d432fd1
   * @maxLength 32
   * @minLength 32
   */
  id?: string;
  /**
   * @example NameOfTheResourceGroup
   */
  name?: string;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
};

export type AccountResourceGroupListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountResourceGroupListVariables = {
  pathParams: AccountResourceGroupListPathParams;
  queryParams?: AccountResourceGroupListQueryParams;
} & FetcherExtraProps;

/**
 * List all the resource groups for an account.
 */
export const accountResourceGroupList = (variables: AccountResourceGroupListVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamCollectionResourceGroupsResponse,
    AccountResourceGroupListError,
    undefined,
    {},
    AccountResourceGroupListQueryParams,
    AccountResourceGroupListPathParams
  >({ url: '/accounts/{accountId}/iam/resource_groups', method: 'get', ...variables, signal });

export type AccountResourceGroupCreatePathParams = {
  accountId: Schemas.IamAccountIdentifier;
};

export type AccountResourceGroupCreateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountResourceGroupCreateVariables = {
  body: Schemas.IamCreateResourceGroup;
  pathParams: AccountResourceGroupCreatePathParams;
} & FetcherExtraProps;

/**
 * Create a new Resource Group under the specified account.
 */
export const accountResourceGroupCreate = (variables: AccountResourceGroupCreateVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamCreatedResourceGroupResponse,
    AccountResourceGroupCreateError,
    Schemas.IamCreateResourceGroup,
    {},
    {},
    AccountResourceGroupCreatePathParams
  >({ url: '/accounts/{accountId}/iam/resource_groups', method: 'post', ...variables, signal });

export type AccountResourceGroupDeletePathParams = {
  accountId: Schemas.IamAccountIdentifier;
  resourceGroupId: Schemas.IamResourceGroupComponentsSchemasIdentifier;
};

export type AccountResourceGroupDeleteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountResourceGroupDeleteVariables = {
  pathParams: AccountResourceGroupDeletePathParams;
} & FetcherExtraProps;

/**
 * Remove a resource group from an account.
 */
export const accountResourceGroupDelete = (variables: AccountResourceGroupDeleteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamApiResponseSingleId,
    AccountResourceGroupDeleteError,
    undefined,
    {},
    {},
    AccountResourceGroupDeletePathParams
  >({ url: '/accounts/{accountId}/iam/resource_groups/{resourceGroupId}', method: 'delete', ...variables, signal });

export type AccountResourceGroupDetailsPathParams = {
  accountId: Schemas.IamAccountIdentifier;
  resourceGroupId: Schemas.IamResourceGroupComponentsSchemasIdentifier;
};

export type AccountResourceGroupDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountResourceGroupDetailsVariables = {
  pathParams: AccountResourceGroupDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get information about a specific resource group in an account.
 */
export const accountResourceGroupDetails = (variables: AccountResourceGroupDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamResourceGroup,
    AccountResourceGroupDetailsError,
    undefined,
    {},
    {},
    AccountResourceGroupDetailsPathParams
  >({ url: '/accounts/{accountId}/iam/resource_groups/{resourceGroupId}', method: 'get', ...variables, signal });

export type AccountResourceGroupUpdatePathParams = {
  accountId: Schemas.IamAccountIdentifier;
  resourceGroupId: Schemas.IamResourceGroupComponentsSchemasIdentifier;
};

export type AccountResourceGroupUpdateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountResourceGroupUpdateVariables = {
  body: Schemas.IamCreateResourceGroup;
  pathParams: AccountResourceGroupUpdatePathParams;
} & FetcherExtraProps;

/**
 * Modify an existing resource group.
 */
export const accountResourceGroupUpdate = (variables: AccountResourceGroupUpdateVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamResourceGroup,
    AccountResourceGroupUpdateError,
    Schemas.IamCreateResourceGroup,
    {},
    {},
    AccountResourceGroupUpdatePathParams
  >({ url: '/accounts/{accountId}/iam/resource_groups/{resourceGroupId}', method: 'put', ...variables, signal });

export type CloudflareImagesListImagesPathParams = {
  accountId: Schemas.ImagesAccountIdentifier;
};

export type CloudflareImagesListImagesQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 1000
   * @maximum 10000
   * @minimum 10
   */
  per_page?: number;
};

export type CloudflareImagesListImagesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ImagesImagesListResponse & Schemas.ImagesApiResponseCommonFailure;
}>;

export type CloudflareImagesListImagesVariables = {
  pathParams: CloudflareImagesListImagesPathParams;
  queryParams?: CloudflareImagesListImagesQueryParams;
} & FetcherExtraProps;

/**
 * List up to 100 images with one request. Use the optional parameters below to get a specific range of images.
 */
export const cloudflareImagesListImages = (variables: CloudflareImagesListImagesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ImagesImagesListResponse,
    CloudflareImagesListImagesError,
    undefined,
    {},
    CloudflareImagesListImagesQueryParams,
    CloudflareImagesListImagesPathParams
  >({ url: '/accounts/{accountId}/images/v1', method: 'get', ...variables, signal });

export type CloudflareImagesUploadAnImageViaUrlPathParams = {
  accountId: Schemas.ImagesAccountIdentifier;
};

export type CloudflareImagesUploadAnImageViaUrlError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ImagesImageResponseSingle & Schemas.ImagesApiResponseCommonFailure;
}>;

export type CloudflareImagesUploadAnImageViaUrlVariables = {
  body?: Schemas.ImagesImageBasicUpload;
  pathParams: CloudflareImagesUploadAnImageViaUrlPathParams;
} & FetcherExtraProps;

/**
 * Upload an image with up to 10 Megabytes using a single HTTP POST (multipart/form-data) request.
 * An image can be uploaded by sending an image file or passing an accessible to an API url.
 */
export const cloudflareImagesUploadAnImageViaUrl = (
  variables: CloudflareImagesUploadAnImageViaUrlVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ImagesImageResponseSingle,
    CloudflareImagesUploadAnImageViaUrlError,
    Schemas.ImagesImageBasicUpload,
    {},
    {},
    CloudflareImagesUploadAnImageViaUrlPathParams
  >({ url: '/accounts/{accountId}/images/v1', method: 'post', ...variables, signal });

export type CloudflareImagesKeysListSigningKeysPathParams = {
  accountId: Schemas.ImagesAccountIdentifier;
};

export type CloudflareImagesKeysListSigningKeysError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ImagesImageKeyResponseCollection & Schemas.ImagesApiResponseCommonFailure;
}>;

export type CloudflareImagesKeysListSigningKeysVariables = {
  pathParams: CloudflareImagesKeysListSigningKeysPathParams;
} & FetcherExtraProps;

/**
 * Lists your signing keys. These can be found on your Cloudflare Images dashboard.
 */
export const cloudflareImagesKeysListSigningKeys = (
  variables: CloudflareImagesKeysListSigningKeysVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ImagesImageKeyResponseCollection,
    CloudflareImagesKeysListSigningKeysError,
    undefined,
    {},
    {},
    CloudflareImagesKeysListSigningKeysPathParams
  >({ url: '/accounts/{accountId}/images/v1/keys', method: 'get', ...variables, signal });

export type CloudflareImagesKeysDeleteSigningKeyPathParams = {
  signingKeyName: Schemas.ImagesSigningKeyIdentifier;
  accountId: Schemas.ImagesAccountIdentifier;
};

export type CloudflareImagesKeysDeleteSigningKeyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ImagesImageKeyResponseCollection & Schemas.ImagesApiResponseCommonFailure;
}>;

export type CloudflareImagesKeysDeleteSigningKeyVariables = {
  pathParams: CloudflareImagesKeysDeleteSigningKeyPathParams;
} & FetcherExtraProps;

/**
 * Delete signing key with specified name. Returns all keys available.
 * When last key is removed, a new default signing key will be generated.
 */
export const cloudflareImagesKeysDeleteSigningKey = (
  variables: CloudflareImagesKeysDeleteSigningKeyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ImagesImageKeyResponseCollection,
    CloudflareImagesKeysDeleteSigningKeyError,
    undefined,
    {},
    {},
    CloudflareImagesKeysDeleteSigningKeyPathParams
  >({ url: '/accounts/{accountId}/images/v1/keys/{signingKeyName}', method: 'delete', ...variables, signal });

export type CloudflareImagesKeysAddSigningKeyPathParams = {
  signingKeyName: Schemas.ImagesSigningKeyIdentifier;
  accountId: Schemas.ImagesAccountIdentifier;
};

export type CloudflareImagesKeysAddSigningKeyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ImagesImageKeyResponseCollection & Schemas.ImagesApiResponseCommonFailure;
}>;

export type CloudflareImagesKeysAddSigningKeyVariables = {
  pathParams: CloudflareImagesKeysAddSigningKeyPathParams;
} & FetcherExtraProps;

/**
 * Create a new signing key with specified name. Returns all keys available.
 */
export const cloudflareImagesKeysAddSigningKey = (
  variables: CloudflareImagesKeysAddSigningKeyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ImagesImageKeyResponseCollection,
    CloudflareImagesKeysAddSigningKeyError,
    undefined,
    {},
    {},
    CloudflareImagesKeysAddSigningKeyPathParams
  >({ url: '/accounts/{accountId}/images/v1/keys/{signingKeyName}', method: 'put', ...variables, signal });

export type CloudflareImagesImagesUsageStatisticsPathParams = {
  accountId: Schemas.ImagesAccountIdentifier;
};

export type CloudflareImagesImagesUsageStatisticsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ImagesImagesStatsResponse & Schemas.ImagesApiResponseCommonFailure;
}>;

export type CloudflareImagesImagesUsageStatisticsVariables = {
  pathParams: CloudflareImagesImagesUsageStatisticsPathParams;
} & FetcherExtraProps;

/**
 * Fetch usage statistics details for Cloudflare Images.
 */
export const cloudflareImagesImagesUsageStatistics = (
  variables: CloudflareImagesImagesUsageStatisticsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ImagesImagesStatsResponse,
    CloudflareImagesImagesUsageStatisticsError,
    undefined,
    {},
    {},
    CloudflareImagesImagesUsageStatisticsPathParams
  >({ url: '/accounts/{accountId}/images/v1/stats', method: 'get', ...variables, signal });

export type CloudflareImagesVariantsListVariantsPathParams = {
  accountId: Schemas.ImagesAccountIdentifier;
};

export type CloudflareImagesVariantsListVariantsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ImagesImageVariantListResponse & Schemas.ImagesApiResponseCommonFailure;
}>;

export type CloudflareImagesVariantsListVariantsVariables = {
  pathParams: CloudflareImagesVariantsListVariantsPathParams;
} & FetcherExtraProps;

/**
 * Lists existing variants.
 */
export const cloudflareImagesVariantsListVariants = (
  variables: CloudflareImagesVariantsListVariantsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ImagesImageVariantListResponse,
    CloudflareImagesVariantsListVariantsError,
    undefined,
    {},
    {},
    CloudflareImagesVariantsListVariantsPathParams
  >({ url: '/accounts/{accountId}/images/v1/variants', method: 'get', ...variables, signal });

export type CloudflareImagesVariantsCreateAVariantPathParams = {
  accountId: Schemas.ImagesAccountIdentifier;
};

export type CloudflareImagesVariantsCreateAVariantError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ImagesImageVariantSimpleResponse & Schemas.ImagesApiResponseCommonFailure;
}>;

export type CloudflareImagesVariantsCreateAVariantVariables = {
  body: Schemas.ImagesImageVariantDefinition;
  pathParams: CloudflareImagesVariantsCreateAVariantPathParams;
} & FetcherExtraProps;

/**
 * Specify variants that allow you to resize images for different use cases.
 */
export const cloudflareImagesVariantsCreateAVariant = (
  variables: CloudflareImagesVariantsCreateAVariantVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ImagesImageVariantSimpleResponse,
    CloudflareImagesVariantsCreateAVariantError,
    Schemas.ImagesImageVariantDefinition,
    {},
    {},
    CloudflareImagesVariantsCreateAVariantPathParams
  >({ url: '/accounts/{accountId}/images/v1/variants', method: 'post', ...variables, signal });

export type CloudflareImagesVariantsDeleteAVariantPathParams = {
  variantId: Schemas.ImagesImageVariantIdentifier;
  accountId: Schemas.ImagesAccountIdentifier;
};

export type CloudflareImagesVariantsDeleteAVariantError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ImagesDeletedResponse & Schemas.ImagesApiResponseCommonFailure;
}>;

export type CloudflareImagesVariantsDeleteAVariantVariables = {
  pathParams: CloudflareImagesVariantsDeleteAVariantPathParams;
} & FetcherExtraProps;

/**
 * Deleting a variant purges the cache for all images associated with the variant.
 */
export const cloudflareImagesVariantsDeleteAVariant = (
  variables: CloudflareImagesVariantsDeleteAVariantVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ImagesDeletedResponse,
    CloudflareImagesVariantsDeleteAVariantError,
    undefined,
    {},
    {},
    CloudflareImagesVariantsDeleteAVariantPathParams
  >({ url: '/accounts/{accountId}/images/v1/variants/{variantId}', method: 'delete', ...variables, signal });

export type CloudflareImagesVariantsVariantDetailsPathParams = {
  variantId: Schemas.ImagesImageVariantIdentifier;
  accountId: Schemas.ImagesAccountIdentifier;
};

export type CloudflareImagesVariantsVariantDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ImagesImageVariantSimpleResponse & Schemas.ImagesApiResponseCommonFailure;
}>;

export type CloudflareImagesVariantsVariantDetailsVariables = {
  pathParams: CloudflareImagesVariantsVariantDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetch details for a single variant.
 */
export const cloudflareImagesVariantsVariantDetails = (
  variables: CloudflareImagesVariantsVariantDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ImagesImageVariantSimpleResponse,
    CloudflareImagesVariantsVariantDetailsError,
    undefined,
    {},
    {},
    CloudflareImagesVariantsVariantDetailsPathParams
  >({ url: '/accounts/{accountId}/images/v1/variants/{variantId}', method: 'get', ...variables, signal });

export type CloudflareImagesVariantsUpdateAVariantPathParams = {
  variantId: Schemas.ImagesImageVariantIdentifier;
  accountId: Schemas.ImagesAccountIdentifier;
};

export type CloudflareImagesVariantsUpdateAVariantError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ImagesImageVariantSimpleResponse & Schemas.ImagesApiResponseCommonFailure;
}>;

export type CloudflareImagesVariantsUpdateAVariantVariables = {
  body: Schemas.ImagesImageVariantPatchRequest;
  pathParams: CloudflareImagesVariantsUpdateAVariantPathParams;
} & FetcherExtraProps;

/**
 * Updating a variant purges the cache for all images associated with the variant.
 */
export const cloudflareImagesVariantsUpdateAVariant = (
  variables: CloudflareImagesVariantsUpdateAVariantVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ImagesImageVariantSimpleResponse,
    CloudflareImagesVariantsUpdateAVariantError,
    Schemas.ImagesImageVariantPatchRequest,
    {},
    {},
    CloudflareImagesVariantsUpdateAVariantPathParams
  >({ url: '/accounts/{accountId}/images/v1/variants/{variantId}', method: 'patch', ...variables, signal });

export type CloudflareImagesDeleteImagePathParams = {
  imageId: Schemas.ImagesImageIdentifier;
  accountId: Schemas.ImagesAccountIdentifier;
};

export type CloudflareImagesDeleteImageError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ImagesDeletedResponse & Schemas.ImagesApiResponseCommonFailure;
}>;

export type CloudflareImagesDeleteImageVariables = {
  pathParams: CloudflareImagesDeleteImagePathParams;
} & FetcherExtraProps;

/**
 * Delete an image on Cloudflare Images. On success, all copies of the image are deleted and purged from cache.
 */
export const cloudflareImagesDeleteImage = (variables: CloudflareImagesDeleteImageVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ImagesDeletedResponse,
    CloudflareImagesDeleteImageError,
    undefined,
    {},
    {},
    CloudflareImagesDeleteImagePathParams
  >({ url: '/accounts/{accountId}/images/v1/{imageId}', method: 'delete', ...variables, signal });

export type CloudflareImagesImageDetailsPathParams = {
  imageId: Schemas.ImagesImageIdentifier;
  accountId: Schemas.ImagesAccountIdentifier;
};

export type CloudflareImagesImageDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ImagesImageResponseSingle & Schemas.ImagesApiResponseCommonFailure;
}>;

export type CloudflareImagesImageDetailsVariables = {
  pathParams: CloudflareImagesImageDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetch details for a single image.
 */
export const cloudflareImagesImageDetails = (variables: CloudflareImagesImageDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ImagesImageResponseSingle,
    CloudflareImagesImageDetailsError,
    undefined,
    {},
    {},
    CloudflareImagesImageDetailsPathParams
  >({ url: '/accounts/{accountId}/images/v1/{imageId}', method: 'get', ...variables, signal });

export type CloudflareImagesUpdateImagePathParams = {
  imageId: Schemas.ImagesImageIdentifier;
  accountId: Schemas.ImagesAccountIdentifier;
};

export type CloudflareImagesUpdateImageError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ImagesImageResponseSingle & Schemas.ImagesApiResponseCommonFailure;
}>;

export type CloudflareImagesUpdateImageVariables = {
  body?: Schemas.ImagesImagePatchRequest;
  pathParams: CloudflareImagesUpdateImagePathParams;
} & FetcherExtraProps;

/**
 * Update image access control. On access control change, all copies of the image are purged from cache.
 */
export const cloudflareImagesUpdateImage = (variables: CloudflareImagesUpdateImageVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ImagesImageResponseSingle,
    CloudflareImagesUpdateImageError,
    Schemas.ImagesImagePatchRequest,
    {},
    {},
    CloudflareImagesUpdateImagePathParams
  >({ url: '/accounts/{accountId}/images/v1/{imageId}', method: 'patch', ...variables, signal });

export type CloudflareImagesBaseImagePathParams = {
  imageId: Schemas.ImagesImageIdentifier;
  accountId: Schemas.ImagesAccountIdentifier;
};

export type CloudflareImagesBaseImageError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ImagesImageResponseBlob & Schemas.ImagesApiResponseCommonFailure;
}>;

export type CloudflareImagesBaseImageVariables = {
  pathParams: CloudflareImagesBaseImagePathParams;
} & FetcherExtraProps;

/**
 * Fetch base image. For most images this will be the originally uploaded file. For larger images it can be a near-lossless version of the original.
 */
export const cloudflareImagesBaseImage = (variables: CloudflareImagesBaseImageVariables, signal?: AbortSignal) =>
  fetch<undefined, CloudflareImagesBaseImageError, undefined, {}, {}, CloudflareImagesBaseImagePathParams>({
    url: '/accounts/{accountId}/images/v1/{imageId}/blob',
    method: 'get',
    ...variables,
    signal
  });

export type CloudflareImagesListImagesV2PathParams = {
  accountId: Schemas.ImagesAccountIdentifier;
};

export type CloudflareImagesListImagesV2QueryParams = {
  continuation_token?: string | null;
  /**
   * @default 1000
   * @maximum 10000
   * @minimum 10
   */
  per_page?: number;
  /**
   * @default desc
   */
  sort_order?: 'asc' | 'desc';
};

export type CloudflareImagesListImagesV2Error = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ImagesImagesListResponseV2 & Schemas.ImagesApiResponseCommonFailure;
}>;

export type CloudflareImagesListImagesV2Variables = {
  pathParams: CloudflareImagesListImagesV2PathParams;
  queryParams?: CloudflareImagesListImagesV2QueryParams;
} & FetcherExtraProps;

/**
 * List up to 10000 images with one request. Use the optional parameters below to get a specific range of images.
 * Endpoint returns continuation_token if more images are present.
 */
export const cloudflareImagesListImagesV2 = (variables: CloudflareImagesListImagesV2Variables, signal?: AbortSignal) =>
  fetch<
    Schemas.ImagesImagesListResponseV2,
    CloudflareImagesListImagesV2Error,
    undefined,
    {},
    CloudflareImagesListImagesV2QueryParams,
    CloudflareImagesListImagesV2PathParams
  >({ url: '/accounts/{accountId}/images/v2', method: 'get', ...variables, signal });

export type CloudflareImagesCreateAuthenticatedDirectUploadUrlV2PathParams = {
  accountId: Schemas.ImagesAccountIdentifier;
};

export type CloudflareImagesCreateAuthenticatedDirectUploadUrlV2Error = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ImagesImageDirectUploadResponseV2 & Schemas.ImagesApiResponseCommonFailure;
}>;

export type CloudflareImagesCreateAuthenticatedDirectUploadUrlV2Variables = {
  body?: Schemas.ImagesImageDirectUploadRequestV2;
  pathParams: CloudflareImagesCreateAuthenticatedDirectUploadUrlV2PathParams;
} & FetcherExtraProps;

/**
 * Direct uploads allow users to upload images without API keys. A common use case are web apps, client-side applications, or mobile devices where users upload content directly to Cloudflare Images. This method creates a draft record for a future image. It returns an upload URL and an image identifier. To verify if the image itself has been uploaded, send an image details request (accounts/:account_identifier/images/v1/:identifier), and check that the `draft: true` property is not present.
 */
export const cloudflareImagesCreateAuthenticatedDirectUploadUrlV2 = (
  variables: CloudflareImagesCreateAuthenticatedDirectUploadUrlV2Variables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ImagesImageDirectUploadResponseV2,
    CloudflareImagesCreateAuthenticatedDirectUploadUrlV2Error,
    Schemas.ImagesImageDirectUploadRequestV2,
    {},
    {},
    CloudflareImagesCreateAuthenticatedDirectUploadUrlV2PathParams
  >({ url: '/accounts/{accountId}/images/v2/direct_upload', method: 'post', ...variables, signal });

export type InfraTargetsListPathParams = {
  accountId: Schemas.InfraAccountTag;
};

export type InfraTargetsListQueryParams = {
  /**
   * Hostname of a target
   */
  hostname?: string | null;
  /**
   * Partial match to the hostname of a target
   */
  hostname_contains?: string | null;
  /**
   * Private virtual network identifier of the target
   *
   * @format uuid
   */
  virtual_network_id?: string | null;
  /**
   * IPv4 address of the target
   */
  ip_v4?: string | null;
  /**
   * IPv6 address of the target
   */
  ip_v6?: string | null;
  /**
   * Date and time at which the target was created before (inclusive)
   *
   * @format date-time
   */
  created_before?: string | null;
  /**
   * Date and time at which the target was created after (inclusive)
   *
   * @format date-time
   */
  created_after?: string | null;
  /**
   * Date and time at which the target was modified before (inclusive)
   *
   * @format date-time
   */
  modified_before?: string | null;
  /**
   * Date and time at which the target was modified after (inclusive)
   *
   * @format date-time
   */
  modified_after?: string | null;
  /**
   * Filters for targets that have any of the following IP addresses. Specify
   * `ips` multiple times in query parameter to build list of candidates.
   */
  ips?: string[];
  /**
   * Current page in the response
   *
   * @default 1
   * @format int32
   * @minimum 1
   */
  page?: number;
  /**
   * Max amount of entries returned per page
   *
   * @default 1000
   * @format int32
   * @maximum 1000
   * @minimum 1
   */
  per_page?: number;
  /**
   * The field to sort by.
   */
  order?: 'hostname' | 'created_at';
  /**
   * The sorting direction.
   */
  direction?: Schemas.InfraSortingDirection;
};

export type InfraTargetsListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.InfraApiResponseCommonFailure;
}>;

export type InfraTargetsListResponse = Schemas.InfraApiResponseCollection & {
  result?: Schemas.InfraTargetArray;
};

export type InfraTargetsListVariables = {
  pathParams: InfraTargetsListPathParams;
  queryParams?: InfraTargetsListQueryParams;
} & FetcherExtraProps;

/**
 * Lists and sorts an account’s targets. Filters are optional and are ORed
 * together. However, when a timestamp is specified with both its before and
 * after counterparts, the timestamp filters are ANDed.
 */
export const infraTargetsList = (variables: InfraTargetsListVariables, signal?: AbortSignal) =>
  fetch<
    InfraTargetsListResponse,
    InfraTargetsListError,
    undefined,
    {},
    InfraTargetsListQueryParams,
    InfraTargetsListPathParams
  >({ url: '/accounts/{accountId}/infrastructure/targets', method: 'get', ...variables, signal });

export type InfraTargetsPostPathParams = {
  accountId: Schemas.InfraAccountTag;
};

export type InfraTargetsPostError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.InfraApiResponseCommonFailure;
}>;

export type InfraTargetsPostResponse = Schemas.InfraApiResponseSingle & {
  result?: Schemas.InfraTarget;
};

export type InfraTargetsPostRequestBody = {
  /**
   * A non-unique field that refers to a target. Case insensitive, maximum
   * length of 255 characters, supports the use of special characters dash
   * and period, does not support spaces, and must start and end with an
   * alphanumeric character.
   *
   * @example infra-access-target
   */
  hostname: string;
  ip: Schemas.InfraIPInfo;
};

export type InfraTargetsPostVariables = {
  body: InfraTargetsPostRequestBody;
  pathParams: InfraTargetsPostPathParams;
} & FetcherExtraProps;

export const infraTargetsPost = (variables: InfraTargetsPostVariables, signal?: AbortSignal) =>
  fetch<
    InfraTargetsPostResponse,
    InfraTargetsPostError,
    InfraTargetsPostRequestBody,
    {},
    {},
    InfraTargetsPostPathParams
  >({ url: '/accounts/{accountId}/infrastructure/targets', method: 'post', ...variables, signal });

export type InfraTargetsDeleteBatchPathParams = {
  accountId: Schemas.InfraAccountTag;
};

export type InfraTargetsDeleteBatchError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.InfraApiResponseCommonFailure;
}>;

export type InfraTargetsDeleteBatchRequestBody = {
  target_ids: Schemas.InfraTargetId[];
};

export type InfraTargetsDeleteBatchVariables = {
  body: InfraTargetsDeleteBatchRequestBody;
  pathParams: InfraTargetsDeleteBatchPathParams;
} & FetcherExtraProps;

/**
 * Removes one or more targets.
 */
export const infraTargetsDeleteBatch = (variables: InfraTargetsDeleteBatchVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    InfraTargetsDeleteBatchError,
    InfraTargetsDeleteBatchRequestBody,
    {},
    {},
    InfraTargetsDeleteBatchPathParams
  >({ url: '/accounts/{accountId}/infrastructure/targets/batch', method: 'delete', ...variables, signal });

export type InfraTargetsPutBatchPathParams = {
  accountId: Schemas.InfraAccountTag;
};

export type InfraTargetsPutBatchError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.InfraApiResponseCommonFailure;
}>;

export type InfraTargetsPutBatchResponse = Schemas.InfraTarget[];

export type InfraTargetsPutBatchRequestBody = {
  /**
   * A non-unique field that refers to a target. Case insensitive, maximum
   * length of 255 characters, supports the use of special characters dash
   * and period, does not support spaces, and must start and end with an
   * alphanumeric character.
   *
   * @example infra-access-target
   */
  hostname: string;
  ip: Schemas.InfraIPInfo;
}[];

export type InfraTargetsPutBatchVariables = {
  body?: InfraTargetsPutBatchRequestBody;
  pathParams: InfraTargetsPutBatchPathParams;
} & FetcherExtraProps;

/**
 * Adds one or more targets.
 */
export const infraTargetsPutBatch = (variables: InfraTargetsPutBatchVariables, signal?: AbortSignal) =>
  fetch<
    InfraTargetsPutBatchResponse,
    InfraTargetsPutBatchError,
    InfraTargetsPutBatchRequestBody,
    {},
    {},
    InfraTargetsPutBatchPathParams
  >({ url: '/accounts/{accountId}/infrastructure/targets/batch', method: 'put', ...variables, signal });

export type InfraTargetsDeletePathParams = {
  accountId: Schemas.InfraAccountTag;
  targetId: Schemas.InfraTargetId;
};

export type InfraTargetsDeleteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.InfraApiResponseCommonFailure;
}>;

export type InfraTargetsDeleteVariables = {
  pathParams: InfraTargetsDeletePathParams;
} & FetcherExtraProps;

export const infraTargetsDelete = (variables: InfraTargetsDeleteVariables, signal?: AbortSignal) =>
  fetch<undefined, InfraTargetsDeleteError, undefined, {}, {}, InfraTargetsDeletePathParams>({
    url: '/accounts/{accountId}/infrastructure/targets/{targetId}',
    method: 'delete',
    ...variables,
    signal
  });

export type InfraTargetsGetPathParams = {
  accountId: Schemas.InfraAccountTag;
  targetId: Schemas.InfraTargetId;
};

export type InfraTargetsGetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.InfraApiResponseCommonFailure;
}>;

export type InfraTargetsGetResponse = Schemas.InfraApiResponseSingle & {
  result?: Schemas.InfraTarget;
};

export type InfraTargetsGetVariables = {
  pathParams: InfraTargetsGetPathParams;
} & FetcherExtraProps;

export const infraTargetsGet = (variables: InfraTargetsGetVariables, signal?: AbortSignal) =>
  fetch<InfraTargetsGetResponse, InfraTargetsGetError, undefined, {}, {}, InfraTargetsGetPathParams>({
    url: '/accounts/{accountId}/infrastructure/targets/{targetId}',
    method: 'get',
    ...variables,
    signal
  });

export type InfraTargetsPutPathParams = {
  accountId: Schemas.InfraAccountTag;
  targetId: Schemas.InfraTargetId;
};

export type InfraTargetsPutError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.InfraApiResponseCommonFailure;
}>;

export type InfraTargetsPutResponse = Schemas.InfraApiResponseSingle & {
  result?: Schemas.InfraTarget;
};

export type InfraTargetsPutRequestBody = {
  /**
   * A non-unique field that refers to a target. Case insensitive, maximum
   * length of 255 characters, supports the use of special characters dash
   * and period, does not support spaces, and must start and end with an
   * alphanumeric character.
   *
   * @example infra-access-target
   */
  hostname: string;
  ip: Schemas.InfraIPInfo;
};

export type InfraTargetsPutVariables = {
  body: InfraTargetsPutRequestBody;
  pathParams: InfraTargetsPutPathParams;
} & FetcherExtraProps;

export const infraTargetsPut = (variables: InfraTargetsPutVariables, signal?: AbortSignal) =>
  fetch<InfraTargetsPutResponse, InfraTargetsPutError, InfraTargetsPutRequestBody, {}, {}, InfraTargetsPutPathParams>({
    url: '/accounts/{accountId}/infrastructure/targets/{targetId}',
    method: 'put',
    ...variables,
    signal
  });

export type AsnIntelligenceGetAsnOverviewPathParams = {
  asn: Schemas.IntelAsn;
  accountId: Schemas.IntelIdentifier;
};

export type AsnIntelligenceGetAsnOverviewError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IntelAsnComponentsSchemasResponse & Schemas.IntelApiResponseCommonFailure;
}>;

export type AsnIntelligenceGetAsnOverviewVariables = {
  pathParams: AsnIntelligenceGetAsnOverviewPathParams;
} & FetcherExtraProps;

/**
 * Gets an overview of the Autonomous System Number (ASN) and a list of subnets for it.
 */
export const asnIntelligenceGetAsnOverview = (
  variables: AsnIntelligenceGetAsnOverviewVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.IntelAsnComponentsSchemasResponse,
    AsnIntelligenceGetAsnOverviewError,
    undefined,
    {},
    {},
    AsnIntelligenceGetAsnOverviewPathParams
  >({ url: '/accounts/{accountId}/intel/asn/{asn}', method: 'get', ...variables, signal });

export type AsnIntelligenceGetAsnSubnetsPathParams = {
  asn: Schemas.IntelAsn;
  accountId: Schemas.IntelIdentifier;
};

export type AsnIntelligenceGetAsnSubnetsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    asn?: Schemas.IntelAsn;
    count?: Schemas.IntelCount;
    ip_count_total?: number;
    page?: Schemas.IntelPage;
    per_page?: Schemas.IntelPerPage;
    /**
     * @example 192.0.2.0/24
     * @example 2001:DB8::/32
     */
    subnets?: string[];
  } & Schemas.IntelApiResponseCommonFailure;
}>;

export type AsnIntelligenceGetAsnSubnetsResponse = {
  asn?: Schemas.IntelAsn;
  count?: Schemas.IntelCount;
  ip_count_total?: number;
  page?: Schemas.IntelPage;
  per_page?: Schemas.IntelPerPage;
  /**
   * @example 192.0.2.0/24
   * @example 2001:DB8::/32
   */
  subnets?: string[];
};

export type AsnIntelligenceGetAsnSubnetsVariables = {
  pathParams: AsnIntelligenceGetAsnSubnetsPathParams;
} & FetcherExtraProps;

/**
 * Get ASN Subnets
 */
export const asnIntelligenceGetAsnSubnets = (variables: AsnIntelligenceGetAsnSubnetsVariables, signal?: AbortSignal) =>
  fetch<
    AsnIntelligenceGetAsnSubnetsResponse,
    AsnIntelligenceGetAsnSubnetsError,
    undefined,
    {},
    {},
    AsnIntelligenceGetAsnSubnetsPathParams
  >({ url: '/accounts/{accountId}/intel/asn/{asn}/subnets', method: 'get', ...variables, signal });

export type GetSecurityCenterIssueTypesPathParams = {
  accountId: Schemas.SecurityCenterIdentifier;
};

export type GetSecurityCenterIssueTypesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecurityCenterApiResponseCommonFailure;
}>;

export type GetSecurityCenterIssueTypesResponse = Schemas.SecurityCenterApiResponseCommon & {
  result?: string[];
};

export type GetSecurityCenterIssueTypesVariables = {
  pathParams: GetSecurityCenterIssueTypesPathParams;
} & FetcherExtraProps;

export const getSecurityCenterIssueTypes = (variables: GetSecurityCenterIssueTypesVariables, signal?: AbortSignal) =>
  fetch<
    GetSecurityCenterIssueTypesResponse,
    GetSecurityCenterIssueTypesError,
    undefined,
    {},
    {},
    GetSecurityCenterIssueTypesPathParams
  >({ url: '/accounts/{accountId}/intel/attack-surface-report/issue-types', method: 'get', ...variables, signal });

export type GetSecurityCenterIssuesPathParams = {
  accountId: Schemas.SecurityCenterIdentifier;
};

export type GetSecurityCenterIssuesQueryParams = {
  dismissed?: Schemas.SecurityCenterDismissed;
  issue_class?: Schemas.SecurityCenterIssueClasses;
  issue_type?: Schemas.SecurityCenterIssueTypes;
  product?: Schemas.SecurityCenterProducts;
  severity?: Schemas.SecurityCenterSeverityQueryParam;
  subject?: Schemas.SecurityCenterSubjects;
  ['issue_class~neq']?: Schemas.SecurityCenterIssueClasses;
  ['issue_type~neq']?: Schemas.SecurityCenterIssueTypes;
  ['product~neq']?: Schemas.SecurityCenterProducts;
  ['severity~neq']?: Schemas.SecurityCenterSeverityQueryParam;
  ['subject~neq']?: Schemas.SecurityCenterSubjects;
  /**
   * Current page within paginated list of results
   *
   * @default 1
   * @example 1
   */
  page?: Schemas.SecurityCenterPage;
  /**
   * Number of results per page of results
   *
   * @default 25
   * @example 25
   * @maximum 1000
   * @minimum 1
   */
  per_page?: Schemas.SecurityCenterPerPage;
};

export type GetSecurityCenterIssuesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecurityCenterApiResponseCommonFailure;
}>;

export type GetSecurityCenterIssuesResponse = Schemas.SecurityCenterApiResponseCommon & {
  result?: {
    count?: Schemas.SecurityCenterCount;
    issues?: Schemas.SecurityCenterIssue[];
    page?: Schemas.SecurityCenterPage;
    per_page?: Schemas.SecurityCenterPerPage;
  };
};

export type GetSecurityCenterIssuesVariables = {
  pathParams: GetSecurityCenterIssuesPathParams;
  queryParams?: GetSecurityCenterIssuesQueryParams;
} & FetcherExtraProps;

export const getSecurityCenterIssues = (variables: GetSecurityCenterIssuesVariables, signal?: AbortSignal) =>
  fetch<
    GetSecurityCenterIssuesResponse,
    GetSecurityCenterIssuesError,
    undefined,
    {},
    GetSecurityCenterIssuesQueryParams,
    GetSecurityCenterIssuesPathParams
  >({ url: '/accounts/{accountId}/intel/attack-surface-report/issues', method: 'get', ...variables, signal });

export type GetSecurityCenterIssueCountsByClassPathParams = {
  accountId: Schemas.SecurityCenterIdentifier;
};

export type GetSecurityCenterIssueCountsByClassQueryParams = {
  dismissed?: Schemas.SecurityCenterDismissed;
  issue_class?: Schemas.SecurityCenterIssueClasses;
  issue_type?: Schemas.SecurityCenterIssueTypes;
  product?: Schemas.SecurityCenterProducts;
  severity?: Schemas.SecurityCenterSeverityQueryParam;
  subject?: Schemas.SecurityCenterSubjects;
  ['issue_class~neq']?: Schemas.SecurityCenterIssueClasses;
  ['issue_type~neq']?: Schemas.SecurityCenterIssueTypes;
  ['product~neq']?: Schemas.SecurityCenterProducts;
  ['severity~neq']?: Schemas.SecurityCenterSeverityQueryParam;
  ['subject~neq']?: Schemas.SecurityCenterSubjects;
};

export type GetSecurityCenterIssueCountsByClassError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecurityCenterApiResponseCommonFailure;
}>;

export type GetSecurityCenterIssueCountsByClassVariables = {
  pathParams: GetSecurityCenterIssueCountsByClassPathParams;
  queryParams?: GetSecurityCenterIssueCountsByClassQueryParams;
} & FetcherExtraProps;

export const getSecurityCenterIssueCountsByClass = (
  variables: GetSecurityCenterIssueCountsByClassVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SecurityCenterValueCountsResponse,
    GetSecurityCenterIssueCountsByClassError,
    undefined,
    {},
    GetSecurityCenterIssueCountsByClassQueryParams,
    GetSecurityCenterIssueCountsByClassPathParams
  >({ url: '/accounts/{accountId}/intel/attack-surface-report/issues/class', method: 'get', ...variables, signal });

export type GetSecurityCenterIssueCountsBySeverityPathParams = {
  accountId: Schemas.SecurityCenterIdentifier;
};

export type GetSecurityCenterIssueCountsBySeverityQueryParams = {
  dismissed?: Schemas.SecurityCenterDismissed;
  issue_class?: Schemas.SecurityCenterIssueClasses;
  issue_type?: Schemas.SecurityCenterIssueTypes;
  product?: Schemas.SecurityCenterProducts;
  severity?: Schemas.SecurityCenterSeverityQueryParam;
  subject?: Schemas.SecurityCenterSubjects;
  ['issue_class~neq']?: Schemas.SecurityCenterIssueClasses;
  ['issue_type~neq']?: Schemas.SecurityCenterIssueTypes;
  ['product~neq']?: Schemas.SecurityCenterProducts;
  ['severity~neq']?: Schemas.SecurityCenterSeverityQueryParam;
  ['subject~neq']?: Schemas.SecurityCenterSubjects;
};

export type GetSecurityCenterIssueCountsBySeverityError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecurityCenterApiResponseCommonFailure;
}>;

export type GetSecurityCenterIssueCountsBySeverityVariables = {
  pathParams: GetSecurityCenterIssueCountsBySeverityPathParams;
  queryParams?: GetSecurityCenterIssueCountsBySeverityQueryParams;
} & FetcherExtraProps;

export const getSecurityCenterIssueCountsBySeverity = (
  variables: GetSecurityCenterIssueCountsBySeverityVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SecurityCenterValueCountsResponse,
    GetSecurityCenterIssueCountsBySeverityError,
    undefined,
    {},
    GetSecurityCenterIssueCountsBySeverityQueryParams,
    GetSecurityCenterIssueCountsBySeverityPathParams
  >({ url: '/accounts/{accountId}/intel/attack-surface-report/issues/severity', method: 'get', ...variables, signal });

export type GetSecurityCenterIssueCountsByTypePathParams = {
  accountId: Schemas.SecurityCenterIdentifier;
};

export type GetSecurityCenterIssueCountsByTypeQueryParams = {
  dismissed?: Schemas.SecurityCenterDismissed;
  issue_class?: Schemas.SecurityCenterIssueClasses;
  issue_type?: Schemas.SecurityCenterIssueTypes;
  product?: Schemas.SecurityCenterProducts;
  severity?: Schemas.SecurityCenterSeverityQueryParam;
  subject?: Schemas.SecurityCenterSubjects;
  ['issue_class~neq']?: Schemas.SecurityCenterIssueClasses;
  ['issue_type~neq']?: Schemas.SecurityCenterIssueTypes;
  ['product~neq']?: Schemas.SecurityCenterProducts;
  ['severity~neq']?: Schemas.SecurityCenterSeverityQueryParam;
  ['subject~neq']?: Schemas.SecurityCenterSubjects;
};

export type GetSecurityCenterIssueCountsByTypeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecurityCenterApiResponseCommonFailure;
}>;

export type GetSecurityCenterIssueCountsByTypeVariables = {
  pathParams: GetSecurityCenterIssueCountsByTypePathParams;
  queryParams?: GetSecurityCenterIssueCountsByTypeQueryParams;
} & FetcherExtraProps;

export const getSecurityCenterIssueCountsByType = (
  variables: GetSecurityCenterIssueCountsByTypeVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SecurityCenterValueCountsResponse,
    GetSecurityCenterIssueCountsByTypeError,
    undefined,
    {},
    GetSecurityCenterIssueCountsByTypeQueryParams,
    GetSecurityCenterIssueCountsByTypePathParams
  >({ url: '/accounts/{accountId}/intel/attack-surface-report/issues/type', method: 'get', ...variables, signal });

export type ArchiveSecurityCenterInsightPathParams = {
  accountId: Schemas.SecurityCenterIdentifier;
  issueId: string;
};

export type ArchiveSecurityCenterInsightError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecurityCenterApiResponseCommonFailure;
}>;

export type ArchiveSecurityCenterInsightResponse = Schemas.SecurityCenterApiResponseSingle;

export type ArchiveSecurityCenterInsightRequestBody = {
  /**
   * @default true
   */
  dismiss?: boolean;
};

export type ArchiveSecurityCenterInsightVariables = {
  body?: ArchiveSecurityCenterInsightRequestBody;
  pathParams: ArchiveSecurityCenterInsightPathParams;
} & FetcherExtraProps;

export const archiveSecurityCenterInsight = (variables: ArchiveSecurityCenterInsightVariables, signal?: AbortSignal) =>
  fetch<
    ArchiveSecurityCenterInsightResponse,
    ArchiveSecurityCenterInsightError,
    ArchiveSecurityCenterInsightRequestBody,
    {},
    {},
    ArchiveSecurityCenterInsightPathParams
  >({
    url: '/accounts/{accountId}/intel/attack-surface-report/{issueId}/dismiss',
    method: 'put',
    ...variables,
    signal
  });

export type PassiveDnsByIpGetPassiveDnsByIpPathParams = {
  accountId: Schemas.IntelIdentifier;
};

export type PassiveDnsByIpGetPassiveDnsByIpQueryParams = {
  start_end_params?: Schemas.IntelStartEndParams;
  ipv4?: string;
  /**
   * @example 1
   */
  page?: number;
  /**
   * @example 20
   */
  per_page?: number;
};

export type PassiveDnsByIpGetPassiveDnsByIpError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IntelComponentsSchemasSingleResponse & Schemas.IntelApiResponseCommonFailure;
}>;

export type PassiveDnsByIpGetPassiveDnsByIpVariables = {
  pathParams: PassiveDnsByIpGetPassiveDnsByIpPathParams;
  queryParams?: PassiveDnsByIpGetPassiveDnsByIpQueryParams;
} & FetcherExtraProps;

/**
 * Gets a list of all the domains that have resolved to a specific IP address.
 */
export const passiveDnsByIpGetPassiveDnsByIp = (
  variables: PassiveDnsByIpGetPassiveDnsByIpVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.IntelComponentsSchemasSingleResponse,
    PassiveDnsByIpGetPassiveDnsByIpError,
    undefined,
    {},
    PassiveDnsByIpGetPassiveDnsByIpQueryParams,
    PassiveDnsByIpGetPassiveDnsByIpPathParams
  >({ url: '/accounts/{accountId}/intel/dns', method: 'get', ...variables, signal });

export type DomainIntelligenceGetDomainDetailsPathParams = {
  accountId: Schemas.IntelIdentifier;
};

export type DomainIntelligenceGetDomainDetailsQueryParams = {
  domain?: string;
};

export type DomainIntelligenceGetDomainDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IntelSingleResponse & Schemas.IntelApiResponseCommonFailure;
}>;

export type DomainIntelligenceGetDomainDetailsVariables = {
  pathParams: DomainIntelligenceGetDomainDetailsPathParams;
  queryParams?: DomainIntelligenceGetDomainDetailsQueryParams;
} & FetcherExtraProps;

/**
 * Gets security details and statistics about a domain.
 */
export const domainIntelligenceGetDomainDetails = (
  variables: DomainIntelligenceGetDomainDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.IntelSingleResponse,
    DomainIntelligenceGetDomainDetailsError,
    undefined,
    {},
    DomainIntelligenceGetDomainDetailsQueryParams,
    DomainIntelligenceGetDomainDetailsPathParams
  >({ url: '/accounts/{accountId}/intel/domain', method: 'get', ...variables, signal });

export type DomainHistoryGetDomainHistoryPathParams = {
  accountId: Schemas.IntelIdentifier;
};

export type DomainHistoryGetDomainHistoryQueryParams = {
  /**
   * @example example.com
   */
  domain?: void;
};

export type DomainHistoryGetDomainHistoryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IntelResponse & Schemas.IntelApiResponseCommonFailure;
}>;

export type DomainHistoryGetDomainHistoryVariables = {
  pathParams: DomainHistoryGetDomainHistoryPathParams;
  queryParams?: DomainHistoryGetDomainHistoryQueryParams;
} & FetcherExtraProps;

/**
 * Gets historical security threat and content categories currently and previously assigned to a domain.
 */
export const domainHistoryGetDomainHistory = (
  variables: DomainHistoryGetDomainHistoryVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.IntelResponse,
    DomainHistoryGetDomainHistoryError,
    undefined,
    {},
    DomainHistoryGetDomainHistoryQueryParams,
    DomainHistoryGetDomainHistoryPathParams
  >({ url: '/accounts/{accountId}/intel/domain-history', method: 'get', ...variables, signal });

export type DomainIntelligenceGetMultipleDomainDetailsPathParams = {
  accountId: Schemas.IntelIdentifier;
};

export type DomainIntelligenceGetMultipleDomainDetailsQueryParams = {
  domain?: void;
};

export type DomainIntelligenceGetMultipleDomainDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IntelCollectionResponse & Schemas.IntelApiResponseCommonFailure;
}>;

export type DomainIntelligenceGetMultipleDomainDetailsVariables = {
  pathParams: DomainIntelligenceGetMultipleDomainDetailsPathParams;
  queryParams?: DomainIntelligenceGetMultipleDomainDetailsQueryParams;
} & FetcherExtraProps;

/**
 * Same as summary
 */
export const domainIntelligenceGetMultipleDomainDetails = (
  variables: DomainIntelligenceGetMultipleDomainDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.IntelCollectionResponse,
    DomainIntelligenceGetMultipleDomainDetailsError,
    undefined,
    {},
    DomainIntelligenceGetMultipleDomainDetailsQueryParams,
    DomainIntelligenceGetMultipleDomainDetailsPathParams
  >({ url: '/accounts/{accountId}/intel/domain/bulk', method: 'get', ...variables, signal });

export type CustomIndicatorFeedsGetIndicatorFeedsPathParams = {
  accountId: Schemas.CustomIndicatorFeedsIdentifier;
};

export type CustomIndicatorFeedsGetIndicatorFeedsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CustomIndicatorFeedsIndicatorFeedResponse & Schemas.CustomIndicatorFeedsApiResponseCommonFailure;
}>;

export type CustomIndicatorFeedsGetIndicatorFeedsVariables = {
  pathParams: CustomIndicatorFeedsGetIndicatorFeedsPathParams;
} & FetcherExtraProps;

export const customIndicatorFeedsGetIndicatorFeeds = (
  variables: CustomIndicatorFeedsGetIndicatorFeedsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CustomIndicatorFeedsIndicatorFeedResponse,
    CustomIndicatorFeedsGetIndicatorFeedsError,
    undefined,
    {},
    {},
    CustomIndicatorFeedsGetIndicatorFeedsPathParams
  >({ url: '/accounts/{accountId}/intel/indicator-feeds', method: 'get', ...variables, signal });

export type CustomIndicatorFeedsCreateIndicatorFeedsPathParams = {
  accountId: Schemas.CustomIndicatorFeedsIdentifier;
};

export type CustomIndicatorFeedsCreateIndicatorFeedsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CustomIndicatorFeedsCreateFeedResponse & Schemas.CustomIndicatorFeedsApiResponseCommonFailure;
}>;

export type CustomIndicatorFeedsCreateIndicatorFeedsVariables = {
  body?: Schemas.CustomIndicatorFeedsCreateFeed;
  pathParams: CustomIndicatorFeedsCreateIndicatorFeedsPathParams;
} & FetcherExtraProps;

export const customIndicatorFeedsCreateIndicatorFeeds = (
  variables: CustomIndicatorFeedsCreateIndicatorFeedsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CustomIndicatorFeedsCreateFeedResponse,
    CustomIndicatorFeedsCreateIndicatorFeedsError,
    Schemas.CustomIndicatorFeedsCreateFeed,
    {},
    {},
    CustomIndicatorFeedsCreateIndicatorFeedsPathParams
  >({ url: '/accounts/{accountId}/intel/indicator-feeds', method: 'post', ...variables, signal });

export type CustomIndicatorFeedsAddPermissionPathParams = {
  accountId: Schemas.CustomIndicatorFeedsIdentifier;
};

export type CustomIndicatorFeedsAddPermissionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CustomIndicatorFeedsPermissionsResponse & Schemas.CustomIndicatorFeedsApiResponseCommonFailure;
}>;

export type CustomIndicatorFeedsAddPermissionVariables = {
  body?: Schemas.CustomIndicatorFeedsPermissionsRequest;
  pathParams: CustomIndicatorFeedsAddPermissionPathParams;
} & FetcherExtraProps;

export const customIndicatorFeedsAddPermission = (
  variables: CustomIndicatorFeedsAddPermissionVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CustomIndicatorFeedsPermissionsResponse,
    CustomIndicatorFeedsAddPermissionError,
    Schemas.CustomIndicatorFeedsPermissionsRequest,
    {},
    {},
    CustomIndicatorFeedsAddPermissionPathParams
  >({ url: '/accounts/{accountId}/intel/indicator-feeds/permissions/add', method: 'put', ...variables, signal });

export type CustomIndicatorFeedsRemovePermissionPathParams = {
  accountId: Schemas.CustomIndicatorFeedsIdentifier;
};

export type CustomIndicatorFeedsRemovePermissionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CustomIndicatorFeedsPermissionsResponse & Schemas.CustomIndicatorFeedsApiResponseCommonFailure;
}>;

export type CustomIndicatorFeedsRemovePermissionVariables = {
  body?: Schemas.CustomIndicatorFeedsPermissionsRequest;
  pathParams: CustomIndicatorFeedsRemovePermissionPathParams;
} & FetcherExtraProps;

export const customIndicatorFeedsRemovePermission = (
  variables: CustomIndicatorFeedsRemovePermissionVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CustomIndicatorFeedsPermissionsResponse,
    CustomIndicatorFeedsRemovePermissionError,
    Schemas.CustomIndicatorFeedsPermissionsRequest,
    {},
    {},
    CustomIndicatorFeedsRemovePermissionPathParams
  >({ url: '/accounts/{accountId}/intel/indicator-feeds/permissions/remove', method: 'put', ...variables, signal });

export type CustomIndicatorFeedsViewPermissionsPathParams = {
  accountId: Schemas.CustomIndicatorFeedsIdentifier;
};

export type CustomIndicatorFeedsViewPermissionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CustomIndicatorFeedsPermissionListItemResponse &
    Schemas.CustomIndicatorFeedsApiResponseCommonFailure;
}>;

export type CustomIndicatorFeedsViewPermissionsVariables = {
  pathParams: CustomIndicatorFeedsViewPermissionsPathParams;
} & FetcherExtraProps;

export const customIndicatorFeedsViewPermissions = (
  variables: CustomIndicatorFeedsViewPermissionsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CustomIndicatorFeedsPermissionListItemResponse,
    CustomIndicatorFeedsViewPermissionsError,
    undefined,
    {},
    {},
    CustomIndicatorFeedsViewPermissionsPathParams
  >({ url: '/accounts/{accountId}/intel/indicator-feeds/permissions/view', method: 'get', ...variables, signal });

export type CustomIndicatorFeedsGetIndicatorFeedMetadataPathParams = {
  accountId: Schemas.CustomIndicatorFeedsIdentifier;
  feedId: Schemas.CustomIndicatorFeedsFeedId;
};

export type CustomIndicatorFeedsGetIndicatorFeedMetadataError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CustomIndicatorFeedsIndicatorFeedMetadataResponse &
    Schemas.CustomIndicatorFeedsApiResponseCommonFailure;
}>;

export type CustomIndicatorFeedsGetIndicatorFeedMetadataVariables = {
  pathParams: CustomIndicatorFeedsGetIndicatorFeedMetadataPathParams;
} & FetcherExtraProps;

export const customIndicatorFeedsGetIndicatorFeedMetadata = (
  variables: CustomIndicatorFeedsGetIndicatorFeedMetadataVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CustomIndicatorFeedsIndicatorFeedMetadataResponse,
    CustomIndicatorFeedsGetIndicatorFeedMetadataError,
    undefined,
    {},
    {},
    CustomIndicatorFeedsGetIndicatorFeedMetadataPathParams
  >({ url: '/accounts/{accountId}/intel/indicator-feeds/{feedId}', method: 'get', ...variables, signal });

export type CustomIndicatorFeedsUpdateIndicatorFeedMetadataPathParams = {
  accountId: Schemas.CustomIndicatorFeedsIdentifier;
  feedId: Schemas.CustomIndicatorFeedsFeedId;
};

export type CustomIndicatorFeedsUpdateIndicatorFeedMetadataError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CustomIndicatorFeedsUpdatePublicFieldResponse & Schemas.CustomIndicatorFeedsApiResponseCommonFailure;
}>;

export type CustomIndicatorFeedsUpdateIndicatorFeedMetadataVariables = {
  body?: Schemas.CustomIndicatorFeedsUpdatePublicFieldRequest;
  pathParams: CustomIndicatorFeedsUpdateIndicatorFeedMetadataPathParams;
} & FetcherExtraProps;

export const customIndicatorFeedsUpdateIndicatorFeedMetadata = (
  variables: CustomIndicatorFeedsUpdateIndicatorFeedMetadataVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CustomIndicatorFeedsUpdatePublicFieldResponse,
    CustomIndicatorFeedsUpdateIndicatorFeedMetadataError,
    Schemas.CustomIndicatorFeedsUpdatePublicFieldRequest,
    {},
    {},
    CustomIndicatorFeedsUpdateIndicatorFeedMetadataPathParams
  >({ url: '/accounts/{accountId}/intel/indicator-feeds/{feedId}', method: 'put', ...variables, signal });

export type CustomIndicatorFeedsGetIndicatorFeedDataPathParams = {
  accountId: Schemas.CustomIndicatorFeedsIdentifier;
  feedId: Schemas.CustomIndicatorFeedsFeedId;
};

export type CustomIndicatorFeedsGetIndicatorFeedDataError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CustomIndicatorFeedsApiResponseCommonFailure;
}>;

export type CustomIndicatorFeedsGetIndicatorFeedDataVariables = {
  pathParams: CustomIndicatorFeedsGetIndicatorFeedDataPathParams;
} & FetcherExtraProps;

export const customIndicatorFeedsGetIndicatorFeedData = (
  variables: CustomIndicatorFeedsGetIndicatorFeedDataVariables,
  signal?: AbortSignal
) =>
  fetch<
    undefined,
    CustomIndicatorFeedsGetIndicatorFeedDataError,
    undefined,
    {},
    {},
    CustomIndicatorFeedsGetIndicatorFeedDataPathParams
  >({ url: '/accounts/{accountId}/intel/indicator-feeds/{feedId}/data', method: 'get', ...variables, signal });

export type CustomIndicatorFeedsUpdateIndicatorFeedDataPathParams = {
  accountId: Schemas.CustomIndicatorFeedsIdentifier;
  feedId: Schemas.CustomIndicatorFeedsFeedId;
};

export type CustomIndicatorFeedsUpdateIndicatorFeedDataError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CustomIndicatorFeedsApiResponseCommonFailure;
}>;

export type CustomIndicatorFeedsUpdateIndicatorFeedDataRequestBody = {
  /**
   * The file to upload
   *
   * @example @/Users/me/test.stix2
   */
  source?: string;
};

export type CustomIndicatorFeedsUpdateIndicatorFeedDataVariables = {
  body?: CustomIndicatorFeedsUpdateIndicatorFeedDataRequestBody;
  pathParams: CustomIndicatorFeedsUpdateIndicatorFeedDataPathParams;
} & FetcherExtraProps;

export const customIndicatorFeedsUpdateIndicatorFeedData = (
  variables: CustomIndicatorFeedsUpdateIndicatorFeedDataVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CustomIndicatorFeedsUpdateFeedResponse,
    CustomIndicatorFeedsUpdateIndicatorFeedDataError,
    CustomIndicatorFeedsUpdateIndicatorFeedDataRequestBody,
    {},
    {},
    CustomIndicatorFeedsUpdateIndicatorFeedDataPathParams
  >({ url: '/accounts/{accountId}/intel/indicator-feeds/{feedId}/snapshot', method: 'put', ...variables, signal });

export type CustomIndicatorFeedsDownloadIndicatorFeedDataPathParams = {
  accountId: Schemas.CustomIndicatorFeedsIdentifier;
  feedId: Schemas.CustomIndicatorFeedsFeedId;
};

export type CustomIndicatorFeedsDownloadIndicatorFeedDataError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CustomIndicatorFeedsApiResponseCommonFailure;
}>;

export type CustomIndicatorFeedsDownloadIndicatorFeedDataVariables = {
  pathParams: CustomIndicatorFeedsDownloadIndicatorFeedDataPathParams;
} & FetcherExtraProps;

export const customIndicatorFeedsDownloadIndicatorFeedData = (
  variables: CustomIndicatorFeedsDownloadIndicatorFeedDataVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CustomIndicatorFeedsUpdateFeedResponse,
    CustomIndicatorFeedsDownloadIndicatorFeedDataError,
    undefined,
    {},
    {},
    CustomIndicatorFeedsDownloadIndicatorFeedDataPathParams
  >({ url: '/accounts/{accountId}/intel/indicator_feeds/{feedId}/download', method: 'get', ...variables, signal });

export type IpIntelligenceGetIpOverviewPathParams = {
  accountId: Schemas.IntelIdentifier;
};

export type IpIntelligenceGetIpOverviewQueryParams = {
  ipv4?: string;
  ipv6?: string;
};

export type IpIntelligenceGetIpOverviewError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IntelSchemasResponse & Schemas.IntelApiResponseCommonFailure;
}>;

export type IpIntelligenceGetIpOverviewVariables = {
  pathParams: IpIntelligenceGetIpOverviewPathParams;
  queryParams?: IpIntelligenceGetIpOverviewQueryParams;
} & FetcherExtraProps;

/**
 * Gets the geolocation, ASN, infrastructure type of the ASN, and any security threat categories of an IP address.
 */
export const ipIntelligenceGetIpOverview = (variables: IpIntelligenceGetIpOverviewVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IntelSchemasResponse,
    IpIntelligenceGetIpOverviewError,
    undefined,
    {},
    IpIntelligenceGetIpOverviewQueryParams,
    IpIntelligenceGetIpOverviewPathParams
  >({ url: '/accounts/{accountId}/intel/ip', method: 'get', ...variables, signal });

export type IpListGetIpListsPathParams = {
  accountId: Schemas.IntelIdentifier;
};

export type IpListGetIpListsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IntelComponentsSchemasResponse & Schemas.IntelApiResponseCommonFailure;
}>;

export type IpListGetIpListsVariables = {
  pathParams: IpListGetIpListsPathParams;
} & FetcherExtraProps;

/**
 * Get IP Lists
 */
export const ipListGetIpLists = (variables: IpListGetIpListsVariables, signal?: AbortSignal) =>
  fetch<Schemas.IntelComponentsSchemasResponse, IpListGetIpListsError, undefined, {}, {}, IpListGetIpListsPathParams>({
    url: '/accounts/{accountId}/intel/ip-list',
    method: 'get',
    ...variables,
    signal
  });

export type MiscategorizationCreateMiscategorizationPathParams = {
  accountId: Schemas.IntelIdentifier;
};

export type MiscategorizationCreateMiscategorizationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IntelApiResponseSingle & Schemas.IntelApiResponseCommonFailure;
}>;

export type MiscategorizationCreateMiscategorizationVariables = {
  body?: Schemas.IntelMiscategorization;
  pathParams: MiscategorizationCreateMiscategorizationPathParams;
} & FetcherExtraProps;

/**
 * Allows you to submit requests to change a domain’s category.
 */
export const miscategorizationCreateMiscategorization = (
  variables: MiscategorizationCreateMiscategorizationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.IntelApiResponseSingle,
    MiscategorizationCreateMiscategorizationError,
    Schemas.IntelMiscategorization,
    {},
    {},
    MiscategorizationCreateMiscategorizationPathParams
  >({ url: '/accounts/{accountId}/intel/miscategorization', method: 'post', ...variables, signal });

export type SinkholeConfigGetSinkholesPathParams = {
  accountId: Schemas.IntelSinkholesIdentifier;
};

export type SinkholeConfigGetSinkholesError = Fetcher.ErrorWrapper<undefined>;

export type SinkholeConfigGetSinkholesVariables = {
  pathParams: SinkholeConfigGetSinkholesPathParams;
} & FetcherExtraProps;

export const sinkholeConfigGetSinkholes = (variables: SinkholeConfigGetSinkholesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IntelSinkholesGetSinkholesResponse,
    SinkholeConfigGetSinkholesError,
    undefined,
    {},
    {},
    SinkholeConfigGetSinkholesPathParams
  >({ url: '/accounts/{accountId}/intel/sinkholes', method: 'get', ...variables, signal });

export type WhoisRecordGetWhoisRecordPathParams = {
  accountId: Schemas.CloudforceOneWhoisIdentifier;
};

export type WhoisRecordGetWhoisRecordQueryParams = {
  domain?: string;
};

export type WhoisRecordGetWhoisRecordError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CloudforceOneWhoisSchemasSingleResponse & Schemas.CloudforceOneWhoisApiResponseCommonFailure;
}>;

export type WhoisRecordGetWhoisRecordVariables = {
  pathParams: WhoisRecordGetWhoisRecordPathParams;
  queryParams?: WhoisRecordGetWhoisRecordQueryParams;
} & FetcherExtraProps;

export const whoisRecordGetWhoisRecord = (variables: WhoisRecordGetWhoisRecordVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.CloudforceOneWhoisSchemasSingleResponse,
    WhoisRecordGetWhoisRecordError,
    undefined,
    {},
    WhoisRecordGetWhoisRecordQueryParams,
    WhoisRecordGetWhoisRecordPathParams
  >({ url: '/accounts/{accountId}/intel/whois', method: 'get', ...variables, signal });

export type AccountLoadBalancerMonitorsListMonitorsPathParams = {
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerMonitorsListMonitorsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingMonitorResponseCollection & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerMonitorsListMonitorsVariables = {
  pathParams: AccountLoadBalancerMonitorsListMonitorsPathParams;
} & FetcherExtraProps;

/**
 * List configured monitors for an account.
 */
export const accountLoadBalancerMonitorsListMonitors = (
  variables: AccountLoadBalancerMonitorsListMonitorsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingMonitorResponseCollection,
    AccountLoadBalancerMonitorsListMonitorsError,
    undefined,
    {},
    {},
    AccountLoadBalancerMonitorsListMonitorsPathParams
  >({ url: '/accounts/{accountId}/load_balancers/monitors', method: 'get', ...variables, signal });

export type AccountLoadBalancerMonitorsCreateMonitorPathParams = {
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerMonitorsCreateMonitorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingMonitorResponseSingle & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerMonitorsCreateMonitorRequestBody = Schemas.LoadBalancingMonitorEditable;

export type AccountLoadBalancerMonitorsCreateMonitorVariables = {
  body?: AccountLoadBalancerMonitorsCreateMonitorRequestBody;
  pathParams: AccountLoadBalancerMonitorsCreateMonitorPathParams;
} & FetcherExtraProps;

/**
 * Create a configured monitor.
 */
export const accountLoadBalancerMonitorsCreateMonitor = (
  variables: AccountLoadBalancerMonitorsCreateMonitorVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingMonitorResponseSingle,
    AccountLoadBalancerMonitorsCreateMonitorError,
    AccountLoadBalancerMonitorsCreateMonitorRequestBody,
    {},
    {},
    AccountLoadBalancerMonitorsCreateMonitorPathParams
  >({ url: '/accounts/{accountId}/load_balancers/monitors', method: 'post', ...variables, signal });

export type AccountLoadBalancerMonitorsDeleteMonitorPathParams = {
  monitorId: Schemas.LoadBalancingIdentifier;
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerMonitorsDeleteMonitorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingIdResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerMonitorsDeleteMonitorVariables = {
  pathParams: AccountLoadBalancerMonitorsDeleteMonitorPathParams;
} & FetcherExtraProps;

/**
 * Delete a configured monitor.
 */
export const accountLoadBalancerMonitorsDeleteMonitor = (
  variables: AccountLoadBalancerMonitorsDeleteMonitorVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingIdResponse,
    AccountLoadBalancerMonitorsDeleteMonitorError,
    undefined,
    {},
    {},
    AccountLoadBalancerMonitorsDeleteMonitorPathParams
  >({ url: '/accounts/{accountId}/load_balancers/monitors/{monitorId}', method: 'delete', ...variables, signal });

export type AccountLoadBalancerMonitorsMonitorDetailsPathParams = {
  monitorId: Schemas.LoadBalancingIdentifier;
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerMonitorsMonitorDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingMonitorResponseSingle & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerMonitorsMonitorDetailsVariables = {
  pathParams: AccountLoadBalancerMonitorsMonitorDetailsPathParams;
} & FetcherExtraProps;

/**
 * List a single configured monitor for an account.
 */
export const accountLoadBalancerMonitorsMonitorDetails = (
  variables: AccountLoadBalancerMonitorsMonitorDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingMonitorResponseSingle,
    AccountLoadBalancerMonitorsMonitorDetailsError,
    undefined,
    {},
    {},
    AccountLoadBalancerMonitorsMonitorDetailsPathParams
  >({ url: '/accounts/{accountId}/load_balancers/monitors/{monitorId}', method: 'get', ...variables, signal });

export type AccountLoadBalancerMonitorsPatchMonitorPathParams = {
  monitorId: Schemas.LoadBalancingIdentifier;
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerMonitorsPatchMonitorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingMonitorResponseSingle & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerMonitorsPatchMonitorRequestBody = Schemas.LoadBalancingMonitorEditable;

export type AccountLoadBalancerMonitorsPatchMonitorVariables = {
  body?: AccountLoadBalancerMonitorsPatchMonitorRequestBody;
  pathParams: AccountLoadBalancerMonitorsPatchMonitorPathParams;
} & FetcherExtraProps;

/**
 * Apply changes to an existing monitor, overwriting the supplied properties.
 */
export const accountLoadBalancerMonitorsPatchMonitor = (
  variables: AccountLoadBalancerMonitorsPatchMonitorVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingMonitorResponseSingle,
    AccountLoadBalancerMonitorsPatchMonitorError,
    AccountLoadBalancerMonitorsPatchMonitorRequestBody,
    {},
    {},
    AccountLoadBalancerMonitorsPatchMonitorPathParams
  >({ url: '/accounts/{accountId}/load_balancers/monitors/{monitorId}', method: 'patch', ...variables, signal });

export type AccountLoadBalancerMonitorsUpdateMonitorPathParams = {
  monitorId: Schemas.LoadBalancingIdentifier;
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerMonitorsUpdateMonitorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingMonitorResponseSingle & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerMonitorsUpdateMonitorRequestBody = Schemas.LoadBalancingMonitorEditable;

export type AccountLoadBalancerMonitorsUpdateMonitorVariables = {
  body?: AccountLoadBalancerMonitorsUpdateMonitorRequestBody;
  pathParams: AccountLoadBalancerMonitorsUpdateMonitorPathParams;
} & FetcherExtraProps;

/**
 * Modify a configured monitor.
 */
export const accountLoadBalancerMonitorsUpdateMonitor = (
  variables: AccountLoadBalancerMonitorsUpdateMonitorVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingMonitorResponseSingle,
    AccountLoadBalancerMonitorsUpdateMonitorError,
    AccountLoadBalancerMonitorsUpdateMonitorRequestBody,
    {},
    {},
    AccountLoadBalancerMonitorsUpdateMonitorPathParams
  >({ url: '/accounts/{accountId}/load_balancers/monitors/{monitorId}', method: 'put', ...variables, signal });

export type AccountLoadBalancerMonitorsPreviewMonitorPathParams = {
  monitorId: Schemas.LoadBalancingIdentifier;
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerMonitorsPreviewMonitorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingPreviewResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerMonitorsPreviewMonitorRequestBody = Schemas.LoadBalancingMonitorEditable;

export type AccountLoadBalancerMonitorsPreviewMonitorVariables = {
  body?: AccountLoadBalancerMonitorsPreviewMonitorRequestBody;
  pathParams: AccountLoadBalancerMonitorsPreviewMonitorPathParams;
} & FetcherExtraProps;

/**
 * Preview pools using the specified monitor with provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
 */
export const accountLoadBalancerMonitorsPreviewMonitor = (
  variables: AccountLoadBalancerMonitorsPreviewMonitorVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingPreviewResponse,
    AccountLoadBalancerMonitorsPreviewMonitorError,
    AccountLoadBalancerMonitorsPreviewMonitorRequestBody,
    {},
    {},
    AccountLoadBalancerMonitorsPreviewMonitorPathParams
  >({ url: '/accounts/{accountId}/load_balancers/monitors/{monitorId}/preview', method: 'post', ...variables, signal });

export type AccountLoadBalancerMonitorsListMonitorReferencesPathParams = {
  monitorId: Schemas.LoadBalancingIdentifier;
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerMonitorsListMonitorReferencesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingMonitorReferencesResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerMonitorsListMonitorReferencesVariables = {
  pathParams: AccountLoadBalancerMonitorsListMonitorReferencesPathParams;
} & FetcherExtraProps;

/**
 * Get the list of resources that reference the provided monitor.
 */
export const accountLoadBalancerMonitorsListMonitorReferences = (
  variables: AccountLoadBalancerMonitorsListMonitorReferencesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingMonitorReferencesResponse,
    AccountLoadBalancerMonitorsListMonitorReferencesError,
    undefined,
    {},
    {},
    AccountLoadBalancerMonitorsListMonitorReferencesPathParams
  >({
    url: '/accounts/{accountId}/load_balancers/monitors/{monitorId}/references',
    method: 'get',
    ...variables,
    signal
  });

export type AccountLoadBalancerPoolsListPoolsPathParams = {
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerPoolsListPoolsQueryParams = {
  monitor?: string;
};

export type AccountLoadBalancerPoolsListPoolsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingSchemasResponseCollection & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerPoolsListPoolsVariables = {
  pathParams: AccountLoadBalancerPoolsListPoolsPathParams;
  queryParams?: AccountLoadBalancerPoolsListPoolsQueryParams;
} & FetcherExtraProps;

/**
 * List configured pools.
 */
export const accountLoadBalancerPoolsListPools = (
  variables: AccountLoadBalancerPoolsListPoolsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingSchemasResponseCollection,
    AccountLoadBalancerPoolsListPoolsError,
    undefined,
    {},
    AccountLoadBalancerPoolsListPoolsQueryParams,
    AccountLoadBalancerPoolsListPoolsPathParams
  >({ url: '/accounts/{accountId}/load_balancers/pools', method: 'get', ...variables, signal });

export type AccountLoadBalancerPoolsPatchPoolsPathParams = {
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerPoolsPatchPoolsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingSchemasResponseCollection & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerPoolsPatchPoolsRequestBody = {
  notification_email?: Schemas.LoadBalancingPatchPoolsNotificationEmail;
};

export type AccountLoadBalancerPoolsPatchPoolsVariables = {
  body?: AccountLoadBalancerPoolsPatchPoolsRequestBody;
  pathParams: AccountLoadBalancerPoolsPatchPoolsPathParams;
} & FetcherExtraProps;

/**
 * Apply changes to a number of existing pools, overwriting the supplied properties. Pools are ordered by ascending `name`. Returns the list of affected pools. Supports the standard pagination query parameters, either `limit`/`offset` or `per_page`/`page`.
 */
export const accountLoadBalancerPoolsPatchPools = (
  variables: AccountLoadBalancerPoolsPatchPoolsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingSchemasResponseCollection,
    AccountLoadBalancerPoolsPatchPoolsError,
    AccountLoadBalancerPoolsPatchPoolsRequestBody,
    {},
    {},
    AccountLoadBalancerPoolsPatchPoolsPathParams
  >({ url: '/accounts/{accountId}/load_balancers/pools', method: 'patch', ...variables, signal });

export type AccountLoadBalancerPoolsCreatePoolPathParams = {
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerPoolsCreatePoolError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingSchemasSingleResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerPoolsCreatePoolRequestBody = {
  description?: Schemas.LoadBalancingSchemasDescription;
  enabled?: Schemas.LoadBalancingEnabled;
  latitude?: Schemas.LoadBalancingLatitude;
  load_shedding?: Schemas.LoadBalancingLoadShedding;
  longitude?: Schemas.LoadBalancingLongitude;
  minimum_origins?: Schemas.LoadBalancingMinimumOrigins;
  monitor?: Schemas.LoadBalancingMonitorId;
  name: Schemas.LoadBalancingName;
  notification_email?: Schemas.LoadBalancingNotificationEmail;
  notification_filter?: Schemas.LoadBalancingNotificationFilter;
  origin_steering?: Schemas.LoadBalancingOriginSteering;
  origins: Schemas.LoadBalancingOrigins;
};

export type AccountLoadBalancerPoolsCreatePoolVariables = {
  body: AccountLoadBalancerPoolsCreatePoolRequestBody;
  pathParams: AccountLoadBalancerPoolsCreatePoolPathParams;
} & FetcherExtraProps;

/**
 * Create a new pool.
 */
export const accountLoadBalancerPoolsCreatePool = (
  variables: AccountLoadBalancerPoolsCreatePoolVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingSchemasSingleResponse,
    AccountLoadBalancerPoolsCreatePoolError,
    AccountLoadBalancerPoolsCreatePoolRequestBody,
    {},
    {},
    AccountLoadBalancerPoolsCreatePoolPathParams
  >({ url: '/accounts/{accountId}/load_balancers/pools', method: 'post', ...variables, signal });

export type AccountLoadBalancerPoolsDeletePoolPathParams = {
  poolId: Schemas.LoadBalancingSchemasIdentifier;
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerPoolsDeletePoolError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingSchemasIdResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerPoolsDeletePoolVariables = {
  pathParams: AccountLoadBalancerPoolsDeletePoolPathParams;
} & FetcherExtraProps;

/**
 * Delete a configured pool.
 */
export const accountLoadBalancerPoolsDeletePool = (
  variables: AccountLoadBalancerPoolsDeletePoolVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingSchemasIdResponse,
    AccountLoadBalancerPoolsDeletePoolError,
    undefined,
    {},
    {},
    AccountLoadBalancerPoolsDeletePoolPathParams
  >({ url: '/accounts/{accountId}/load_balancers/pools/{poolId}', method: 'delete', ...variables, signal });

export type AccountLoadBalancerPoolsPoolDetailsPathParams = {
  poolId: Schemas.LoadBalancingSchemasIdentifier;
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerPoolsPoolDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingSchemasSingleResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerPoolsPoolDetailsVariables = {
  pathParams: AccountLoadBalancerPoolsPoolDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetch a single configured pool.
 */
export const accountLoadBalancerPoolsPoolDetails = (
  variables: AccountLoadBalancerPoolsPoolDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingSchemasSingleResponse,
    AccountLoadBalancerPoolsPoolDetailsError,
    undefined,
    {},
    {},
    AccountLoadBalancerPoolsPoolDetailsPathParams
  >({ url: '/accounts/{accountId}/load_balancers/pools/{poolId}', method: 'get', ...variables, signal });

export type AccountLoadBalancerPoolsPatchPoolPathParams = {
  poolId: Schemas.LoadBalancingSchemasIdentifier;
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerPoolsPatchPoolError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingSchemasSingleResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerPoolsPatchPoolRequestBody = {
  check_regions?: Schemas.LoadBalancingCheckRegions;
  description?: Schemas.LoadBalancingSchemasDescription;
  disabled_at?: Schemas.LoadBalancingSchemasDisabledAt;
  enabled?: Schemas.LoadBalancingEnabled;
  latitude?: Schemas.LoadBalancingLatitude;
  load_shedding?: Schemas.LoadBalancingLoadShedding;
  longitude?: Schemas.LoadBalancingLongitude;
  minimum_origins?: Schemas.LoadBalancingMinimumOrigins;
  monitor?: Schemas.LoadBalancingMonitorId;
  name?: Schemas.LoadBalancingName;
  notification_email?: Schemas.LoadBalancingNotificationEmail;
  notification_filter?: Schemas.LoadBalancingNotificationFilter;
  origin_steering?: Schemas.LoadBalancingOriginSteering;
  origins?: Schemas.LoadBalancingOrigins;
};

export type AccountLoadBalancerPoolsPatchPoolVariables = {
  body?: AccountLoadBalancerPoolsPatchPoolRequestBody;
  pathParams: AccountLoadBalancerPoolsPatchPoolPathParams;
} & FetcherExtraProps;

/**
 * Apply changes to an existing pool, overwriting the supplied properties.
 */
export const accountLoadBalancerPoolsPatchPool = (
  variables: AccountLoadBalancerPoolsPatchPoolVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingSchemasSingleResponse,
    AccountLoadBalancerPoolsPatchPoolError,
    AccountLoadBalancerPoolsPatchPoolRequestBody,
    {},
    {},
    AccountLoadBalancerPoolsPatchPoolPathParams
  >({ url: '/accounts/{accountId}/load_balancers/pools/{poolId}', method: 'patch', ...variables, signal });

export type AccountLoadBalancerPoolsUpdatePoolPathParams = {
  poolId: Schemas.LoadBalancingSchemasIdentifier;
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerPoolsUpdatePoolError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingSchemasSingleResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerPoolsUpdatePoolRequestBody = {
  check_regions?: Schemas.LoadBalancingCheckRegions;
  description?: Schemas.LoadBalancingSchemasDescription;
  disabled_at?: Schemas.LoadBalancingSchemasDisabledAt;
  enabled?: Schemas.LoadBalancingEnabled;
  latitude?: Schemas.LoadBalancingLatitude;
  load_shedding?: Schemas.LoadBalancingLoadShedding;
  longitude?: Schemas.LoadBalancingLongitude;
  minimum_origins?: Schemas.LoadBalancingMinimumOrigins;
  monitor?: Schemas.LoadBalancingMonitorId;
  name: Schemas.LoadBalancingName;
  notification_email?: Schemas.LoadBalancingNotificationEmail;
  notification_filter?: Schemas.LoadBalancingNotificationFilter;
  origin_steering?: Schemas.LoadBalancingOriginSteering;
  origins: Schemas.LoadBalancingOrigins;
};

export type AccountLoadBalancerPoolsUpdatePoolVariables = {
  body: AccountLoadBalancerPoolsUpdatePoolRequestBody;
  pathParams: AccountLoadBalancerPoolsUpdatePoolPathParams;
} & FetcherExtraProps;

/**
 * Modify a configured pool.
 */
export const accountLoadBalancerPoolsUpdatePool = (
  variables: AccountLoadBalancerPoolsUpdatePoolVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingSchemasSingleResponse,
    AccountLoadBalancerPoolsUpdatePoolError,
    AccountLoadBalancerPoolsUpdatePoolRequestBody,
    {},
    {},
    AccountLoadBalancerPoolsUpdatePoolPathParams
  >({ url: '/accounts/{accountId}/load_balancers/pools/{poolId}', method: 'put', ...variables, signal });

export type AccountLoadBalancerPoolsPoolHealthDetailsPathParams = {
  poolId: Schemas.LoadBalancingSchemasIdentifier;
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerPoolsPoolHealthDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingHealthDetails & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerPoolsPoolHealthDetailsVariables = {
  pathParams: AccountLoadBalancerPoolsPoolHealthDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetch the latest pool health status for a single pool.
 */
export const accountLoadBalancerPoolsPoolHealthDetails = (
  variables: AccountLoadBalancerPoolsPoolHealthDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingHealthDetails,
    AccountLoadBalancerPoolsPoolHealthDetailsError,
    undefined,
    {},
    {},
    AccountLoadBalancerPoolsPoolHealthDetailsPathParams
  >({ url: '/accounts/{accountId}/load_balancers/pools/{poolId}/health', method: 'get', ...variables, signal });

export type AccountLoadBalancerPoolsPreviewPoolPathParams = {
  poolId: Schemas.LoadBalancingSchemasIdentifier;
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerPoolsPreviewPoolError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingPreviewResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerPoolsPreviewPoolRequestBody = Schemas.LoadBalancingMonitorEditable;

export type AccountLoadBalancerPoolsPreviewPoolVariables = {
  body?: AccountLoadBalancerPoolsPreviewPoolRequestBody;
  pathParams: AccountLoadBalancerPoolsPreviewPoolPathParams;
} & FetcherExtraProps;

/**
 * Preview pool health using provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
 */
export const accountLoadBalancerPoolsPreviewPool = (
  variables: AccountLoadBalancerPoolsPreviewPoolVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingPreviewResponse,
    AccountLoadBalancerPoolsPreviewPoolError,
    AccountLoadBalancerPoolsPreviewPoolRequestBody,
    {},
    {},
    AccountLoadBalancerPoolsPreviewPoolPathParams
  >({ url: '/accounts/{accountId}/load_balancers/pools/{poolId}/preview', method: 'post', ...variables, signal });

export type AccountLoadBalancerPoolsListPoolReferencesPathParams = {
  poolId: Schemas.LoadBalancingSchemasIdentifier;
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerPoolsListPoolReferencesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingPoolsReferencesResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerPoolsListPoolReferencesVariables = {
  pathParams: AccountLoadBalancerPoolsListPoolReferencesPathParams;
} & FetcherExtraProps;

/**
 * Get the list of resources that reference the provided pool.
 */
export const accountLoadBalancerPoolsListPoolReferences = (
  variables: AccountLoadBalancerPoolsListPoolReferencesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingPoolsReferencesResponse,
    AccountLoadBalancerPoolsListPoolReferencesError,
    undefined,
    {},
    {},
    AccountLoadBalancerPoolsListPoolReferencesPathParams
  >({ url: '/accounts/{accountId}/load_balancers/pools/{poolId}/references', method: 'get', ...variables, signal });

export type AccountLoadBalancerMonitorsPreviewResultPathParams = {
  previewId: Schemas.LoadBalancingSchemasPreviewId;
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerMonitorsPreviewResultError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingPreviewResultResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerMonitorsPreviewResultVariables = {
  pathParams: AccountLoadBalancerMonitorsPreviewResultPathParams;
} & FetcherExtraProps;

/**
 * Get the result of a previous preview operation using the provided preview_id.
 */
export const accountLoadBalancerMonitorsPreviewResult = (
  variables: AccountLoadBalancerMonitorsPreviewResultVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingPreviewResultResponse,
    AccountLoadBalancerMonitorsPreviewResultError,
    undefined,
    {},
    {},
    AccountLoadBalancerMonitorsPreviewResultPathParams
  >({ url: '/accounts/{accountId}/load_balancers/preview/{previewId}', method: 'get', ...variables, signal });

export type LoadBalancerRegionsListRegionsPathParams = {
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type LoadBalancerRegionsListRegionsQueryParams = {
  subdivision_code?: Schemas.LoadBalancingSubdivisionCodeA2;
  subdivision_code_a2?: Schemas.LoadBalancingSubdivisionCodeA2;
  /**
   * @example US
   */
  country_code_a2?: string;
};

export type LoadBalancerRegionsListRegionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingRegionComponentsSchemasResponseCollection &
    Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerRegionsListRegionsVariables = {
  pathParams: LoadBalancerRegionsListRegionsPathParams;
  queryParams?: LoadBalancerRegionsListRegionsQueryParams;
} & FetcherExtraProps;

/**
 * List all region mappings.
 */
export const loadBalancerRegionsListRegions = (
  variables: LoadBalancerRegionsListRegionsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingRegionComponentsSchemasResponseCollection,
    LoadBalancerRegionsListRegionsError,
    undefined,
    {},
    LoadBalancerRegionsListRegionsQueryParams,
    LoadBalancerRegionsListRegionsPathParams
  >({ url: '/accounts/{accountId}/load_balancers/regions', method: 'get', ...variables, signal });

export type LoadBalancerRegionsGetRegionPathParams = {
  regionId: Schemas.LoadBalancingRegionCode;
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type LoadBalancerRegionsGetRegionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingComponentsSchemasSingleResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerRegionsGetRegionVariables = {
  pathParams: LoadBalancerRegionsGetRegionPathParams;
} & FetcherExtraProps;

/**
 * Get a single region mapping.
 */
export const loadBalancerRegionsGetRegion = (variables: LoadBalancerRegionsGetRegionVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.LoadBalancingComponentsSchemasSingleResponse,
    LoadBalancerRegionsGetRegionError,
    undefined,
    {},
    {},
    LoadBalancerRegionsGetRegionPathParams
  >({ url: '/accounts/{accountId}/load_balancers/regions/{regionId}', method: 'get', ...variables, signal });

export type AccountLoadBalancerSearchSearchResourcesPathParams = {
  accountId: Schemas.LoadBalancingComponentsSchemasIdentifier;
};

export type AccountLoadBalancerSearchSearchResourcesQueryParams = {
  search_params?: Schemas.LoadBalancingSearchParams;
  /**
   * @minimum 1
   */
  page?: number;
  /**
   * @default 25
   * @maximum 1000
   * @minimum 1
   */
  per_page?: number;
};

export type AccountLoadBalancerSearchSearchResourcesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.LoadBalancingApiPaginatedResponseCollection & Schemas.LoadBalancingSearchResult) &
    Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type AccountLoadBalancerSearchSearchResourcesResponse = Schemas.LoadBalancingApiPaginatedResponseCollection &
  Schemas.LoadBalancingSearchResult;

export type AccountLoadBalancerSearchSearchResourcesVariables = {
  pathParams: AccountLoadBalancerSearchSearchResourcesPathParams;
  queryParams?: AccountLoadBalancerSearchSearchResourcesQueryParams;
} & FetcherExtraProps;

/**
 * Search for Load Balancing resources.
 */
export const accountLoadBalancerSearchSearchResources = (
  variables: AccountLoadBalancerSearchSearchResourcesVariables,
  signal?: AbortSignal
) =>
  fetch<
    AccountLoadBalancerSearchSearchResourcesResponse,
    AccountLoadBalancerSearchSearchResourcesError,
    undefined,
    {},
    AccountLoadBalancerSearchSearchResourcesQueryParams,
    AccountLoadBalancerSearchSearchResourcesPathParams
  >({ url: '/accounts/{accountId}/load_balancers/search', method: 'get', ...variables, signal });

export type GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsPathParams = {
  datasetId: Schemas.LogpushDataset;
  accountId: Schemas.LogpushIdentifier;
};

export type GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsVariables = {
  pathParams: GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsPathParams;
} & FetcherExtraProps;

/**
 * Lists all fields available for a dataset. The response result is an object with key-value pairs, where keys are field names, and values are descriptions.
 */
export const getAccountsAccountIdLogpushDatasetsDatasetIdFields = (
  variables: GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushLogpushFieldResponseCollection,
    GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsError,
    undefined,
    {},
    {},
    GetAccountsAccountIdLogpushDatasetsDatasetIdFieldsPathParams
  >({ url: '/accounts/{accountId}/logpush/datasets/{datasetId}/fields', method: 'get', ...variables, signal });

export type GetAccountsAccountIdLogpushDatasetsDatasetIdJobsPathParams = {
  datasetId: Schemas.LogpushDataset;
  accountId: Schemas.LogpushIdentifier;
};

export type GetAccountsAccountIdLogpushDatasetsDatasetIdJobsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type GetAccountsAccountIdLogpushDatasetsDatasetIdJobsVariables = {
  pathParams: GetAccountsAccountIdLogpushDatasetsDatasetIdJobsPathParams;
} & FetcherExtraProps;

/**
 * Lists Logpush jobs for an account for a dataset.
 */
export const getAccountsAccountIdLogpushDatasetsDatasetIdJobs = (
  variables: GetAccountsAccountIdLogpushDatasetsDatasetIdJobsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushLogpushJobResponseCollection,
    GetAccountsAccountIdLogpushDatasetsDatasetIdJobsError,
    undefined,
    {},
    {},
    GetAccountsAccountIdLogpushDatasetsDatasetIdJobsPathParams
  >({ url: '/accounts/{accountId}/logpush/datasets/{datasetId}/jobs', method: 'get', ...variables, signal });

export type GetAccountsAccountIdLogpushJobsPathParams = {
  accountId: Schemas.LogpushIdentifier;
};

export type GetAccountsAccountIdLogpushJobsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type GetAccountsAccountIdLogpushJobsVariables = {
  pathParams: GetAccountsAccountIdLogpushJobsPathParams;
} & FetcherExtraProps;

/**
 * Lists Logpush jobs for an account.
 */
export const getAccountsAccountIdLogpushJobs = (
  variables: GetAccountsAccountIdLogpushJobsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushLogpushJobResponseCollection,
    GetAccountsAccountIdLogpushJobsError,
    undefined,
    {},
    {},
    GetAccountsAccountIdLogpushJobsPathParams
  >({ url: '/accounts/{accountId}/logpush/jobs', method: 'get', ...variables, signal });

export type PostAccountsAccountIdLogpushJobsPathParams = {
  accountId: Schemas.LogpushIdentifier;
};

export type PostAccountsAccountIdLogpushJobsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type PostAccountsAccountIdLogpushJobsRequestBody = {
  dataset?: Schemas.LogpushDataset;
  destination_conf: Schemas.LogpushDestinationConf;
  enabled?: Schemas.LogpushEnabled;
  frequency?: Schemas.LogpushFrequency;
  kind?: Schemas.LogpushKind;
  logpull_options?: Schemas.LogpushLogpullOptions;
  max_upload_bytes?: Schemas.LogpushMaxUploadBytes;
  max_upload_interval_seconds?: Schemas.LogpushMaxUploadIntervalSeconds;
  max_upload_records?: Schemas.LogpushMaxUploadRecords;
  name?: Schemas.LogpushName;
  output_options?: Schemas.LogpushOutputOptions;
  ownership_challenge?: Schemas.LogpushOwnershipChallenge;
};

export type PostAccountsAccountIdLogpushJobsVariables = {
  body: PostAccountsAccountIdLogpushJobsRequestBody;
  pathParams: PostAccountsAccountIdLogpushJobsPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Logpush job for an account.
 */
export const postAccountsAccountIdLogpushJobs = (
  variables: PostAccountsAccountIdLogpushJobsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushLogpushJobResponseSingle,
    PostAccountsAccountIdLogpushJobsError,
    PostAccountsAccountIdLogpushJobsRequestBody,
    {},
    {},
    PostAccountsAccountIdLogpushJobsPathParams
  >({ url: '/accounts/{accountId}/logpush/jobs', method: 'post', ...variables, signal });

export type DeleteAccountsAccountIdLogpushJobsJobIdPathParams = {
  jobId: Schemas.LogpushId;
  accountId: Schemas.LogpushIdentifier;
};

export type DeleteAccountsAccountIdLogpushJobsJobIdError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type DeleteAccountsAccountIdLogpushJobsJobIdResponse = Schemas.LogpushApiResponseCommon & {
  result?: {
    id?: Schemas.LogpushId;
  };
};

export type DeleteAccountsAccountIdLogpushJobsJobIdVariables = {
  pathParams: DeleteAccountsAccountIdLogpushJobsJobIdPathParams;
} & FetcherExtraProps;

/**
 * Deletes a Logpush job.
 */
export const deleteAccountsAccountIdLogpushJobsJobId = (
  variables: DeleteAccountsAccountIdLogpushJobsJobIdVariables,
  signal?: AbortSignal
) =>
  fetch<
    DeleteAccountsAccountIdLogpushJobsJobIdResponse,
    DeleteAccountsAccountIdLogpushJobsJobIdError,
    undefined,
    {},
    {},
    DeleteAccountsAccountIdLogpushJobsJobIdPathParams
  >({ url: '/accounts/{accountId}/logpush/jobs/{jobId}', method: 'delete', ...variables, signal });

export type GetAccountsAccountIdLogpushJobsJobIdPathParams = {
  jobId: Schemas.LogpushId;
  accountId: Schemas.LogpushIdentifier;
};

export type GetAccountsAccountIdLogpushJobsJobIdError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type GetAccountsAccountIdLogpushJobsJobIdVariables = {
  pathParams: GetAccountsAccountIdLogpushJobsJobIdPathParams;
} & FetcherExtraProps;

/**
 * Gets the details of a Logpush job.
 */
export const getAccountsAccountIdLogpushJobsJobId = (
  variables: GetAccountsAccountIdLogpushJobsJobIdVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushLogpushJobResponseSingle,
    GetAccountsAccountIdLogpushJobsJobIdError,
    undefined,
    {},
    {},
    GetAccountsAccountIdLogpushJobsJobIdPathParams
  >({ url: '/accounts/{accountId}/logpush/jobs/{jobId}', method: 'get', ...variables, signal });

export type PutAccountsAccountIdLogpushJobsJobIdPathParams = {
  jobId: Schemas.LogpushId;
  accountId: Schemas.LogpushIdentifier;
};

export type PutAccountsAccountIdLogpushJobsJobIdError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type PutAccountsAccountIdLogpushJobsJobIdRequestBody = {
  destination_conf?: Schemas.LogpushDestinationConf;
  enabled?: Schemas.LogpushEnabled;
  frequency?: Schemas.LogpushFrequency;
  kind?: Schemas.LogpushKind;
  logpull_options?: Schemas.LogpushLogpullOptions;
  max_upload_bytes?: Schemas.LogpushMaxUploadBytes;
  max_upload_interval_seconds?: Schemas.LogpushMaxUploadIntervalSeconds;
  max_upload_records?: Schemas.LogpushMaxUploadRecords;
  name?: Schemas.LogpushName;
  output_options?: Schemas.LogpushOutputOptions;
  ownership_challenge?: Schemas.LogpushOwnershipChallenge;
};

export type PutAccountsAccountIdLogpushJobsJobIdVariables = {
  body?: PutAccountsAccountIdLogpushJobsJobIdRequestBody;
  pathParams: PutAccountsAccountIdLogpushJobsJobIdPathParams;
} & FetcherExtraProps;

/**
 * Updates a Logpush job.
 */
export const putAccountsAccountIdLogpushJobsJobId = (
  variables: PutAccountsAccountIdLogpushJobsJobIdVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushLogpushJobResponseSingle,
    PutAccountsAccountIdLogpushJobsJobIdError,
    PutAccountsAccountIdLogpushJobsJobIdRequestBody,
    {},
    {},
    PutAccountsAccountIdLogpushJobsJobIdPathParams
  >({ url: '/accounts/{accountId}/logpush/jobs/{jobId}', method: 'put', ...variables, signal });

export type PostAccountsAccountIdLogpushOwnershipPathParams = {
  accountId: Schemas.LogpushIdentifier;
};

export type PostAccountsAccountIdLogpushOwnershipError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type PostAccountsAccountIdLogpushOwnershipRequestBody = {
  destination_conf: Schemas.LogpushDestinationConf;
};

export type PostAccountsAccountIdLogpushOwnershipVariables = {
  body: PostAccountsAccountIdLogpushOwnershipRequestBody;
  pathParams: PostAccountsAccountIdLogpushOwnershipPathParams;
} & FetcherExtraProps;

/**
 * Gets a new ownership challenge sent to your destination.
 */
export const postAccountsAccountIdLogpushOwnership = (
  variables: PostAccountsAccountIdLogpushOwnershipVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushGetOwnershipResponse,
    PostAccountsAccountIdLogpushOwnershipError,
    PostAccountsAccountIdLogpushOwnershipRequestBody,
    {},
    {},
    PostAccountsAccountIdLogpushOwnershipPathParams
  >({ url: '/accounts/{accountId}/logpush/ownership', method: 'post', ...variables, signal });

export type PostAccountsAccountIdLogpushOwnershipValidatePathParams = {
  accountId: Schemas.LogpushIdentifier;
};

export type PostAccountsAccountIdLogpushOwnershipValidateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type PostAccountsAccountIdLogpushOwnershipValidateRequestBody = {
  destination_conf: Schemas.LogpushDestinationConf;
  ownership_challenge: Schemas.LogpushOwnershipChallenge;
};

export type PostAccountsAccountIdLogpushOwnershipValidateVariables = {
  body: PostAccountsAccountIdLogpushOwnershipValidateRequestBody;
  pathParams: PostAccountsAccountIdLogpushOwnershipValidatePathParams;
} & FetcherExtraProps;

/**
 * Validates ownership challenge of the destination.
 */
export const postAccountsAccountIdLogpushOwnershipValidate = (
  variables: PostAccountsAccountIdLogpushOwnershipValidateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushValidateOwnershipResponse,
    PostAccountsAccountIdLogpushOwnershipValidateError,
    PostAccountsAccountIdLogpushOwnershipValidateRequestBody,
    {},
    {},
    PostAccountsAccountIdLogpushOwnershipValidatePathParams
  >({ url: '/accounts/{accountId}/logpush/ownership/validate', method: 'post', ...variables, signal });

export type DeleteAccountsAccountIdLogpushValidateDestinationPathParams = {
  accountId: Schemas.LogpushIdentifier;
};

export type DeleteAccountsAccountIdLogpushValidateDestinationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type DeleteAccountsAccountIdLogpushValidateDestinationRequestBody = {
  destination_conf: Schemas.LogpushDestinationConf;
};

export type DeleteAccountsAccountIdLogpushValidateDestinationVariables = {
  body: DeleteAccountsAccountIdLogpushValidateDestinationRequestBody;
  pathParams: DeleteAccountsAccountIdLogpushValidateDestinationPathParams;
} & FetcherExtraProps;

/**
 * Validates destination.
 */
export const deleteAccountsAccountIdLogpushValidateDestination = (
  variables: DeleteAccountsAccountIdLogpushValidateDestinationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushValidateResponse,
    DeleteAccountsAccountIdLogpushValidateDestinationError,
    DeleteAccountsAccountIdLogpushValidateDestinationRequestBody,
    {},
    {},
    DeleteAccountsAccountIdLogpushValidateDestinationPathParams
  >({ url: '/accounts/{accountId}/logpush/validate/destination', method: 'post', ...variables, signal });

export type DeleteAccountsAccountIdLogpushValidateDestinationExistsPathParams = {
  accountId: Schemas.LogpushIdentifier;
};

export type DeleteAccountsAccountIdLogpushValidateDestinationExistsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type DeleteAccountsAccountIdLogpushValidateDestinationExistsRequestBody = {
  destination_conf: Schemas.LogpushDestinationConf;
};

export type DeleteAccountsAccountIdLogpushValidateDestinationExistsVariables = {
  body: DeleteAccountsAccountIdLogpushValidateDestinationExistsRequestBody;
  pathParams: DeleteAccountsAccountIdLogpushValidateDestinationExistsPathParams;
} & FetcherExtraProps;

/**
 * Checks if there is an existing job with a destination.
 */
export const deleteAccountsAccountIdLogpushValidateDestinationExists = (
  variables: DeleteAccountsAccountIdLogpushValidateDestinationExistsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushDestinationExistsResponse,
    DeleteAccountsAccountIdLogpushValidateDestinationExistsError,
    DeleteAccountsAccountIdLogpushValidateDestinationExistsRequestBody,
    {},
    {},
    DeleteAccountsAccountIdLogpushValidateDestinationExistsPathParams
  >({ url: '/accounts/{accountId}/logpush/validate/destination/exists', method: 'post', ...variables, signal });

export type PostAccountsAccountIdLogpushValidateOriginPathParams = {
  accountId: Schemas.LogpushIdentifier;
};

export type PostAccountsAccountIdLogpushValidateOriginError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type PostAccountsAccountIdLogpushValidateOriginRequestBody = {
  logpull_options: Schemas.LogpushLogpullOptions;
};

export type PostAccountsAccountIdLogpushValidateOriginVariables = {
  body: PostAccountsAccountIdLogpushValidateOriginRequestBody;
  pathParams: PostAccountsAccountIdLogpushValidateOriginPathParams;
} & FetcherExtraProps;

/**
 * Validates logpull origin with logpull_options.
 */
export const postAccountsAccountIdLogpushValidateOrigin = (
  variables: PostAccountsAccountIdLogpushValidateOriginVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushValidateResponse,
    PostAccountsAccountIdLogpushValidateOriginError,
    PostAccountsAccountIdLogpushValidateOriginRequestBody,
    {},
    {},
    PostAccountsAccountIdLogpushValidateOriginPathParams
  >({ url: '/accounts/{accountId}/logpush/validate/origin', method: 'post', ...variables, signal });

export type AuditLogsV2GetAccountAuditLogsPathParams = {
  /**
   * @example a67e14daa5f8dceeb91fe5449ba496ef
   */
  accountId: string;
};

export type AuditLogsV2GetAccountAuditLogsQueryParams = {
  account_name?: string;
  /**
   * @example success
   */
  action_result?: 'success' | 'failure';
  /**
   * @example create
   */
  action_type?: 'create' | 'delete' | 'view' | 'update';
  /**
   * @example api_key
   */
  actor_context?: 'api_key' | 'api_token' | 'dash' | 'oauth' | 'origin_ca_key';
  /**
   * @example alice@example.com
   * @format email
   */
  actor_email?: string;
  /**
   * @example 1d20c3afe174f18b642710cec6298a9d
   */
  actor_id?: string;
  /**
   * @example 17.168.228.63
   */
  actor_ip_address?: string;
  /**
   * @example 144cdb2e39c55e203cf225d8d8208647
   */
  actor_token_id?: string;
  /**
   * @example Test Token
   */
  actor_token_name?: string;
  /**
   * @example account
   */
  actor_type?: 'cloudflare_admin' | 'account' | 'user';
  /**
   * @example f174be97-19b1-40d6-954d-70cd5fbd52db
   */
  audit_log_id?: string;
  /**
   * @example 8e8dd2156ef28414
   */
  raw_cf_ray_id?: string;
  /**
   * @example GET
   */
  raw_method?: string;
  /**
   * @example 200
   */
  raw_status_code?: number;
  raw_uri?: string;
  resource_id?: string;
  /**
   * @example Stream
   */
  resource_product?: string;
  /**
   * @example Video
   */
  resource_type?: string;
  /**
   * @example accounts
   */
  resource_scope?: 'accounts' | 'user' | 'zones';
  zone_id?: string;
  /**
   * @example example.com
   */
  zone_name?: string;
  /**
   * Filters actions based on a given timestamp in the format yyyy-mm-dd, returning only logs that occurred on and after the specified date.
   *
   * @example 2024-10-30
   * @format date
   */
  since: string;
  /**
   * Filters actions based on a given timestamp in the format yyyy-mm-dd, returning only logs that occurred on and before the specified date.
   *
   * @example 2024-10-31
   * @format date
   */
  before: string;
  /**
   * @default desc
   * @example desc
   */
  direction?: 'desc' | 'asc';
  /**
   * @default 100
   * @example 25
   * @maximum 1000
   * @minimum 1
   */
  limit?: number;
  /**
   * @example Q1buH-__DQqqig7SVYXT-SsMOTGY2Z3Y80W-fGgva7yaDdmPKveucH5ddOcHsJRhNb-xUK8agZQqkJSMAENGO8NU6g==
   */
  cursor?: string;
};

export type AuditLogsV2GetAccountAuditLogsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaSchemasApiResponseCommonFailure;
}>;

export type AuditLogsV2GetAccountAuditLogsVariables = {
  pathParams: AuditLogsV2GetAccountAuditLogsPathParams;
  queryParams: AuditLogsV2GetAccountAuditLogsQueryParams;
} & FetcherExtraProps;

/**
 * Gets a list of audit logs for an account. <br />  <br /> This is the beta release of Audit Logs Version 2. Since this is a beta version, there may be gaps or missing entries in the available audit logs. Be aware of the following limitations.  <br /> <ul> <li>Audit logs are available only for the past 30 days. <br /></li> <li>Error handling is not yet implemented.  <br /> </li> </ul>
 */
export const auditLogsV2GetAccountAuditLogs = (
  variables: AuditLogsV2GetAccountAuditLogsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaAuditLogsV2ResponseCollection,
    AuditLogsV2GetAccountAuditLogsError,
    undefined,
    {},
    AuditLogsV2GetAccountAuditLogsQueryParams,
    AuditLogsV2GetAccountAuditLogsPathParams
  >({ url: '/accounts/{accountId}/logs/audit', method: 'get', ...variables, signal });

export type DeleteAccountsAccountIdLogsControlCmbConfigPathParams = {
  accountId: Schemas.LogcontrolIdentifier;
};

export type DeleteAccountsAccountIdLogsControlCmbConfigError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogcontrolApiResponseCommonFailure;
}>;

export type DeleteAccountsAccountIdLogsControlCmbConfigResponse = Schemas.LogcontrolApiResponseCommon & {
  result?: any | null;
};

export type DeleteAccountsAccountIdLogsControlCmbConfigVariables = {
  pathParams: DeleteAccountsAccountIdLogsControlCmbConfigPathParams;
} & FetcherExtraProps;

/**
 * Deletes CMB config.
 */
export const deleteAccountsAccountIdLogsControlCmbConfig = (
  variables: DeleteAccountsAccountIdLogsControlCmbConfigVariables,
  signal?: AbortSignal
) =>
  fetch<
    DeleteAccountsAccountIdLogsControlCmbConfigResponse,
    DeleteAccountsAccountIdLogsControlCmbConfigError,
    undefined,
    {},
    {},
    DeleteAccountsAccountIdLogsControlCmbConfigPathParams
  >({ url: '/accounts/{accountId}/logs/control/cmb/config', method: 'delete', ...variables, signal });

export type GetAccountsAccountIdLogsControlCmbConfigPathParams = {
  accountId: Schemas.LogcontrolIdentifier;
};

export type GetAccountsAccountIdLogsControlCmbConfigError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogcontrolApiResponseCommonFailure;
}>;

export type GetAccountsAccountIdLogsControlCmbConfigVariables = {
  pathParams: GetAccountsAccountIdLogsControlCmbConfigPathParams;
} & FetcherExtraProps;

/**
 * Gets CMB config.
 */
export const getAccountsAccountIdLogsControlCmbConfig = (
  variables: GetAccountsAccountIdLogsControlCmbConfigVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogcontrolCmbConfigResponseSingle,
    GetAccountsAccountIdLogsControlCmbConfigError,
    undefined,
    {},
    {},
    GetAccountsAccountIdLogsControlCmbConfigPathParams
  >({ url: '/accounts/{accountId}/logs/control/cmb/config', method: 'get', ...variables, signal });

export type PostAccountsAccountIdLogsControlCmbConfigPathParams = {
  accountId: Schemas.LogcontrolIdentifier;
};

export type PostAccountsAccountIdLogsControlCmbConfigError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogcontrolApiResponseCommonFailure;
}>;

export type PostAccountsAccountIdLogsControlCmbConfigVariables = {
  body?: Schemas.LogcontrolCmbConfig;
  pathParams: PostAccountsAccountIdLogsControlCmbConfigPathParams;
} & FetcherExtraProps;

/**
 * Updates CMB config.
 */
export const postAccountsAccountIdLogsControlCmbConfig = (
  variables: PostAccountsAccountIdLogsControlCmbConfigVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogcontrolCmbConfigResponseSingle,
    PostAccountsAccountIdLogsControlCmbConfigError,
    Schemas.LogcontrolCmbConfig,
    {},
    {},
    PostAccountsAccountIdLogsControlCmbConfigPathParams
  >({ url: '/accounts/{accountId}/logs/control/cmb/config', method: 'post', ...variables, signal });

export type MagicAccountAppsListAppsPathParams = {
  accountId: Schemas.MagicIdentifier;
};

export type MagicAccountAppsListAppsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicAccountAppsListAppsVariables = {
  pathParams: MagicAccountAppsListAppsPathParams;
} & FetcherExtraProps;

/**
 * Lists Apps associated with an account.
 */
export const magicAccountAppsListApps = (variables: MagicAccountAppsListAppsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicAppsCollectionResponse,
    MagicAccountAppsListAppsError,
    undefined,
    {},
    {},
    MagicAccountAppsListAppsPathParams
  >({ url: '/accounts/{accountId}/magic/apps', method: 'get', ...variables, signal });

export type MagicAccountAppsAddAppPathParams = {
  accountId: Schemas.MagicIdentifier;
};

export type MagicAccountAppsAddAppError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicAccountAppsAddAppVariables = {
  body: Schemas.MagicAppAddSingleRequest;
  pathParams: MagicAccountAppsAddAppPathParams;
} & FetcherExtraProps;

/**
 * Creates a new App for an account
 */
export const magicAccountAppsAddApp = (variables: MagicAccountAppsAddAppVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicAppSingleResponse,
    MagicAccountAppsAddAppError,
    Schemas.MagicAppAddSingleRequest,
    {},
    {},
    MagicAccountAppsAddAppPathParams
  >({ url: '/accounts/{accountId}/magic/apps', method: 'post', ...variables, signal });

export type MagicAccountAppsDeleteAppPathParams = {
  accountId: Schemas.MagicIdentifier;
  accountAppId: Schemas.MagicIdentifier;
};

export type MagicAccountAppsDeleteAppError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicAccountAppsDeleteAppVariables = {
  pathParams: MagicAccountAppsDeleteAppPathParams;
} & FetcherExtraProps;

/**
 * Deletes specific Account App.
 */
export const magicAccountAppsDeleteApp = (variables: MagicAccountAppsDeleteAppVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicAppSingleResponse,
    MagicAccountAppsDeleteAppError,
    undefined,
    {},
    {},
    MagicAccountAppsDeleteAppPathParams
  >({ url: '/accounts/{accountId}/magic/apps/{accountAppId}', method: 'delete', ...variables, signal });

export type MagicAccountAppsUpdateAppPathParams = {
  accountId: Schemas.MagicIdentifier;
  accountAppId: Schemas.MagicIdentifier;
};

export type MagicAccountAppsUpdateAppError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicAccountAppsUpdateAppVariables = {
  body?: Schemas.MagicAppUpdateRequest;
  pathParams: MagicAccountAppsUpdateAppPathParams;
} & FetcherExtraProps;

/**
 * Updates an Account App
 */
export const magicAccountAppsUpdateApp = (variables: MagicAccountAppsUpdateAppVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicAppSingleResponse,
    MagicAccountAppsUpdateAppError,
    Schemas.MagicAppUpdateRequest,
    {},
    {},
    MagicAccountAppsUpdateAppPathParams
  >({ url: '/accounts/{accountId}/magic/apps/{accountAppId}', method: 'put', ...variables, signal });

export type MagicInterconnectsListInterconnectsPathParams = {
  accountId: Schemas.MagicIdentifier;
};

export type MagicInterconnectsListInterconnectsHeaders = {
  /**
   * If true, the health check target in the response body will be presented using the new object format. Defaults to false.
   */
  ['x-magic-new-hc-target']?: boolean;
};

export type MagicInterconnectsListInterconnectsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicComponentsSchemasTunnelsCollectionResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicInterconnectsListInterconnectsVariables = {
  headers?: MagicInterconnectsListInterconnectsHeaders;
  pathParams: MagicInterconnectsListInterconnectsPathParams;
} & FetcherExtraProps;

/**
 * Lists interconnects associated with an account.
 */
export const magicInterconnectsListInterconnects = (
  variables: MagicInterconnectsListInterconnectsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicComponentsSchemasTunnelsCollectionResponse,
    MagicInterconnectsListInterconnectsError,
    undefined,
    MagicInterconnectsListInterconnectsHeaders,
    {},
    MagicInterconnectsListInterconnectsPathParams
  >({ url: '/accounts/{accountId}/magic/cf_interconnects', method: 'get', ...variables, signal });

export type MagicInterconnectsUpdateMultipleInterconnectsPathParams = {
  accountId: Schemas.MagicIdentifier;
};

export type MagicInterconnectsUpdateMultipleInterconnectsHeaders = {
  /**
   * If true, the health check target in the request and response bodies will be presented using the new object format. Defaults to false.
   */
  ['x-magic-new-hc-target']?: boolean;
};

export type MagicInterconnectsUpdateMultipleInterconnectsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicComponentsSchemasModifiedTunnelsCollectionResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicInterconnectsUpdateMultipleInterconnectsVariables = {
  body: void;
  headers?: MagicInterconnectsUpdateMultipleInterconnectsHeaders;
  pathParams: MagicInterconnectsUpdateMultipleInterconnectsPathParams;
} & FetcherExtraProps;

/**
 * Updates multiple interconnects associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
 */
export const magicInterconnectsUpdateMultipleInterconnects = (
  variables: MagicInterconnectsUpdateMultipleInterconnectsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicComponentsSchemasModifiedTunnelsCollectionResponse,
    MagicInterconnectsUpdateMultipleInterconnectsError,
    void,
    MagicInterconnectsUpdateMultipleInterconnectsHeaders,
    {},
    MagicInterconnectsUpdateMultipleInterconnectsPathParams
  >({ url: '/accounts/{accountId}/magic/cf_interconnects', method: 'put', ...variables, signal });

export type MagicInterconnectsListInterconnectDetailsPathParams = {
  cfInterconnectId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
};

export type MagicInterconnectsListInterconnectDetailsHeaders = {
  /**
   * If true, the health check target in the response body will be presented using the new object format. Defaults to false.
   */
  ['x-magic-new-hc-target']?: boolean;
};

export type MagicInterconnectsListInterconnectDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicComponentsSchemasTunnelSingleResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicInterconnectsListInterconnectDetailsVariables = {
  headers?: MagicInterconnectsListInterconnectDetailsHeaders;
  pathParams: MagicInterconnectsListInterconnectDetailsPathParams;
} & FetcherExtraProps;

/**
 * Lists details for a specific interconnect.
 */
export const magicInterconnectsListInterconnectDetails = (
  variables: MagicInterconnectsListInterconnectDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicComponentsSchemasTunnelSingleResponse,
    MagicInterconnectsListInterconnectDetailsError,
    undefined,
    MagicInterconnectsListInterconnectDetailsHeaders,
    {},
    MagicInterconnectsListInterconnectDetailsPathParams
  >({ url: '/accounts/{accountId}/magic/cf_interconnects/{cfInterconnectId}', method: 'get', ...variables, signal });

export type MagicInterconnectsUpdateInterconnectPathParams = {
  cfInterconnectId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
};

export type MagicInterconnectsUpdateInterconnectHeaders = {
  /**
   * If true, the health check target in the request and response bodies will be presented using the new object format. Defaults to false.
   */
  ['x-magic-new-hc-target']?: boolean;
};

export type MagicInterconnectsUpdateInterconnectError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicComponentsSchemasTunnelModifiedResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicInterconnectsUpdateInterconnectVariables = {
  body?: Schemas.MagicInterconnectTunnelUpdateRequest;
  headers?: MagicInterconnectsUpdateInterconnectHeaders;
  pathParams: MagicInterconnectsUpdateInterconnectPathParams;
} & FetcherExtraProps;

/**
 * Updates a specific interconnect associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
 */
export const magicInterconnectsUpdateInterconnect = (
  variables: MagicInterconnectsUpdateInterconnectVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicComponentsSchemasTunnelModifiedResponse,
    MagicInterconnectsUpdateInterconnectError,
    Schemas.MagicInterconnectTunnelUpdateRequest,
    MagicInterconnectsUpdateInterconnectHeaders,
    {},
    MagicInterconnectsUpdateInterconnectPathParams
  >({ url: '/accounts/{accountId}/magic/cf_interconnects/{cfInterconnectId}', method: 'put', ...variables, signal });

export type MconnConnectorListPathParams = {
  accountId: Schemas.MconnAccountId;
};

export type MconnConnectorListError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.MconnBadResponse;
    }
  | {
      status: 401;
      payload: Schemas.MconnBadResponse;
    }
  | {
      status: 403;
      payload: Schemas.MconnBadResponse;
    }
  | {
      status: 500;
      payload: Schemas.MconnBadResponse;
    }
>;

export type MconnConnectorListVariables = {
  pathParams: MconnConnectorListPathParams;
} & FetcherExtraProps;

export const mconnConnectorList = (variables: MconnConnectorListVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MconnCustomerConnectorListResponse,
    MconnConnectorListError,
    undefined,
    {},
    {},
    MconnConnectorListPathParams
  >({ url: '/accounts/{accountId}/magic/connectors', method: 'get', ...variables, signal });

export type MconnConnectorFetchPathParams = {
  accountId: Schemas.MconnAccountId;
  connectorId: Schemas.MconnUuid;
};

export type MconnConnectorFetchError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.MconnBadResponse;
    }
  | {
      status: 401;
      payload: Schemas.MconnBadResponse;
    }
  | {
      status: 403;
      payload: Schemas.MconnBadResponse;
    }
  | {
      status: 500;
      payload: Schemas.MconnBadResponse;
    }
>;

export type MconnConnectorFetchVariables = {
  pathParams: MconnConnectorFetchPathParams;
} & FetcherExtraProps;

export const mconnConnectorFetch = (variables: MconnConnectorFetchVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MconnCustomerConnectorFetchResponse,
    MconnConnectorFetchError,
    undefined,
    {},
    {},
    MconnConnectorFetchPathParams
  >({ url: '/accounts/{accountId}/magic/connectors/{connectorId}', method: 'get', ...variables, signal });

export type MconnConnectorUpdatePathParams = {
  accountId: Schemas.MconnAccountId;
  connectorId: Schemas.MconnUuid;
};

export type MconnConnectorUpdateError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.MconnBadResponse;
    }
  | {
      status: 401;
      payload: Schemas.MconnBadResponse;
    }
  | {
      status: 403;
      payload: Schemas.MconnBadResponse;
    }
  | {
      status: 500;
      payload: Schemas.MconnBadResponse;
    }
>;

export type MconnConnectorUpdateVariables = {
  body?: Schemas.MconnCustomerConnectorUpdateRequest;
  pathParams: MconnConnectorUpdatePathParams;
} & FetcherExtraProps;

export const mconnConnectorUpdate = (variables: MconnConnectorUpdateVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MconnCustomerConnectorUpdateResponse,
    MconnConnectorUpdateError,
    Schemas.MconnCustomerConnectorUpdateRequest,
    {},
    {},
    MconnConnectorUpdatePathParams
  >({ url: '/accounts/{accountId}/magic/connectors/{connectorId}', method: 'patch', ...variables, signal });

export type MconnConnectorReplacePathParams = {
  accountId: Schemas.MconnAccountId;
  connectorId: Schemas.MconnUuid;
};

export type MconnConnectorReplaceError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.MconnBadResponse;
    }
  | {
      status: 401;
      payload: Schemas.MconnBadResponse;
    }
  | {
      status: 403;
      payload: Schemas.MconnBadResponse;
    }
  | {
      status: 500;
      payload: Schemas.MconnBadResponse;
    }
>;

export type MconnConnectorReplaceVariables = {
  body?: Schemas.MconnCustomerConnectorUpdateRequest;
  pathParams: MconnConnectorReplacePathParams;
} & FetcherExtraProps;

export const mconnConnectorReplace = (variables: MconnConnectorReplaceVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MconnCustomerConnectorUpdateResponse,
    MconnConnectorReplaceError,
    Schemas.MconnCustomerConnectorUpdateRequest,
    {},
    {},
    MconnConnectorReplacePathParams
  >({ url: '/accounts/{accountId}/magic/connectors/{connectorId}', method: 'put', ...variables, signal });

export type MagicGreTunnelsListGreTunnelsPathParams = {
  accountId: Schemas.MagicIdentifier;
};

export type MagicGreTunnelsListGreTunnelsHeaders = {
  /**
   * If true, the health check target in the response body will be presented using the new object format. Defaults to false.
   */
  ['x-magic-new-hc-target']?: boolean;
};

export type MagicGreTunnelsListGreTunnelsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicTunnelsCollectionResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicGreTunnelsListGreTunnelsVariables = {
  headers?: MagicGreTunnelsListGreTunnelsHeaders;
  pathParams: MagicGreTunnelsListGreTunnelsPathParams;
} & FetcherExtraProps;

/**
 * Lists GRE tunnels associated with an account.
 */
export const magicGreTunnelsListGreTunnels = (
  variables: MagicGreTunnelsListGreTunnelsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicTunnelsCollectionResponse,
    MagicGreTunnelsListGreTunnelsError,
    undefined,
    MagicGreTunnelsListGreTunnelsHeaders,
    {},
    MagicGreTunnelsListGreTunnelsPathParams
  >({ url: '/accounts/{accountId}/magic/gre_tunnels', method: 'get', ...variables, signal });

export type MagicGreTunnelsCreateGreTunnelsPathParams = {
  accountId: Schemas.MagicIdentifier;
};

export type MagicGreTunnelsCreateGreTunnelsHeaders = {
  /**
   * If true, the health check target in the request and response bodies will be presented using the new object format. Defaults to false.
   */
  ['x-magic-new-hc-target']?: boolean;
};

export type MagicGreTunnelsCreateGreTunnelsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicTunnelsCollectionResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicGreTunnelsCreateGreTunnelsVariables = {
  body: void;
  headers?: MagicGreTunnelsCreateGreTunnelsHeaders;
  pathParams: MagicGreTunnelsCreateGreTunnelsPathParams;
} & FetcherExtraProps;

/**
 * Creates new GRE tunnels. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
 */
export const magicGreTunnelsCreateGreTunnels = (
  variables: MagicGreTunnelsCreateGreTunnelsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicTunnelsCollectionResponse,
    MagicGreTunnelsCreateGreTunnelsError,
    void,
    MagicGreTunnelsCreateGreTunnelsHeaders,
    {},
    MagicGreTunnelsCreateGreTunnelsPathParams
  >({ url: '/accounts/{accountId}/magic/gre_tunnels', method: 'post', ...variables, signal });

export type MagicGreTunnelsUpdateMultipleGreTunnelsPathParams = {
  accountId: Schemas.MagicIdentifier;
};

export type MagicGreTunnelsUpdateMultipleGreTunnelsHeaders = {
  /**
   * If true, the health check target in the request and response bodies will be presented using the new object format. Defaults to false.
   */
  ['x-magic-new-hc-target']?: boolean;
};

export type MagicGreTunnelsUpdateMultipleGreTunnelsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicModifiedTunnelsCollectionResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicGreTunnelsUpdateMultipleGreTunnelsVariables = {
  body: void;
  headers?: MagicGreTunnelsUpdateMultipleGreTunnelsHeaders;
  pathParams: MagicGreTunnelsUpdateMultipleGreTunnelsPathParams;
} & FetcherExtraProps;

/**
 * Updates multiple GRE tunnels. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
 */
export const magicGreTunnelsUpdateMultipleGreTunnels = (
  variables: MagicGreTunnelsUpdateMultipleGreTunnelsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicModifiedTunnelsCollectionResponse,
    MagicGreTunnelsUpdateMultipleGreTunnelsError,
    void,
    MagicGreTunnelsUpdateMultipleGreTunnelsHeaders,
    {},
    MagicGreTunnelsUpdateMultipleGreTunnelsPathParams
  >({ url: '/accounts/{accountId}/magic/gre_tunnels', method: 'put', ...variables, signal });

export type MagicGreTunnelsDeleteGreTunnelPathParams = {
  greTunnelId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
};

export type MagicGreTunnelsDeleteGreTunnelHeaders = {
  /**
   * If true, the health check target in the response body will be presented using the new object format. Defaults to false.
   */
  ['x-magic-new-hc-target']?: boolean;
};

export type MagicGreTunnelsDeleteGreTunnelError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicTunnelDeletedResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicGreTunnelsDeleteGreTunnelVariables = {
  headers?: MagicGreTunnelsDeleteGreTunnelHeaders;
  pathParams: MagicGreTunnelsDeleteGreTunnelPathParams;
} & FetcherExtraProps;

/**
 * Disables and removes a specific static GRE tunnel. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
 */
export const magicGreTunnelsDeleteGreTunnel = (
  variables: MagicGreTunnelsDeleteGreTunnelVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicTunnelDeletedResponse,
    MagicGreTunnelsDeleteGreTunnelError,
    undefined,
    MagicGreTunnelsDeleteGreTunnelHeaders,
    {},
    MagicGreTunnelsDeleteGreTunnelPathParams
  >({ url: '/accounts/{accountId}/magic/gre_tunnels/{greTunnelId}', method: 'delete', ...variables, signal });

export type MagicGreTunnelsListGreTunnelDetailsPathParams = {
  greTunnelId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
};

export type MagicGreTunnelsListGreTunnelDetailsHeaders = {
  /**
   * If true, the health check target in the response body will be presented using the new object format. Defaults to false.
   */
  ['x-magic-new-hc-target']?: boolean;
};

export type MagicGreTunnelsListGreTunnelDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicTunnelSingleResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicGreTunnelsListGreTunnelDetailsVariables = {
  headers?: MagicGreTunnelsListGreTunnelDetailsHeaders;
  pathParams: MagicGreTunnelsListGreTunnelDetailsPathParams;
} & FetcherExtraProps;

/**
 * Lists informtion for a specific GRE tunnel.
 */
export const magicGreTunnelsListGreTunnelDetails = (
  variables: MagicGreTunnelsListGreTunnelDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicTunnelSingleResponse,
    MagicGreTunnelsListGreTunnelDetailsError,
    undefined,
    MagicGreTunnelsListGreTunnelDetailsHeaders,
    {},
    MagicGreTunnelsListGreTunnelDetailsPathParams
  >({ url: '/accounts/{accountId}/magic/gre_tunnels/{greTunnelId}', method: 'get', ...variables, signal });

export type MagicGreTunnelsUpdateGreTunnelPathParams = {
  greTunnelId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
};

export type MagicGreTunnelsUpdateGreTunnelHeaders = {
  /**
   * If true, the health check target in the request and response bodies will be presented using the new object format. Defaults to false.
   */
  ['x-magic-new-hc-target']?: boolean;
};

export type MagicGreTunnelsUpdateGreTunnelError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicTunnelModifiedResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicGreTunnelsUpdateGreTunnelVariables = {
  body?: Schemas.MagicGreTunnelUpdateRequest;
  headers?: MagicGreTunnelsUpdateGreTunnelHeaders;
  pathParams: MagicGreTunnelsUpdateGreTunnelPathParams;
} & FetcherExtraProps;

/**
 * Updates a specific GRE tunnel. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
 */
export const magicGreTunnelsUpdateGreTunnel = (
  variables: MagicGreTunnelsUpdateGreTunnelVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicTunnelModifiedResponse,
    MagicGreTunnelsUpdateGreTunnelError,
    Schemas.MagicGreTunnelUpdateRequest,
    MagicGreTunnelsUpdateGreTunnelHeaders,
    {},
    MagicGreTunnelsUpdateGreTunnelPathParams
  >({ url: '/accounts/{accountId}/magic/gre_tunnels/{greTunnelId}', method: 'put', ...variables, signal });

export type MagicIpsecTunnelsListIpsecTunnelsPathParams = {
  accountId: Schemas.MagicIdentifier;
};

export type MagicIpsecTunnelsListIpsecTunnelsHeaders = {
  /**
   * If true, the health check target in the response body will be presented using the new object format. Defaults to false.
   */
  ['x-magic-new-hc-target']?: boolean;
};

export type MagicIpsecTunnelsListIpsecTunnelsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicSchemasTunnelsCollectionResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicIpsecTunnelsListIpsecTunnelsVariables = {
  headers?: MagicIpsecTunnelsListIpsecTunnelsHeaders;
  pathParams: MagicIpsecTunnelsListIpsecTunnelsPathParams;
} & FetcherExtraProps;

/**
 * Lists IPsec tunnels associated with an account.
 */
export const magicIpsecTunnelsListIpsecTunnels = (
  variables: MagicIpsecTunnelsListIpsecTunnelsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicSchemasTunnelsCollectionResponse,
    MagicIpsecTunnelsListIpsecTunnelsError,
    undefined,
    MagicIpsecTunnelsListIpsecTunnelsHeaders,
    {},
    MagicIpsecTunnelsListIpsecTunnelsPathParams
  >({ url: '/accounts/{accountId}/magic/ipsec_tunnels', method: 'get', ...variables, signal });

export type MagicIpsecTunnelsCreateIpsecTunnelsPathParams = {
  accountId: Schemas.MagicIdentifier;
};

export type MagicIpsecTunnelsCreateIpsecTunnelsHeaders = {
  /**
   * If true, the health check target in the request and response bodies will be presented using the new object format. Defaults to false.
   */
  ['x-magic-new-hc-target']?: boolean;
};

export type MagicIpsecTunnelsCreateIpsecTunnelsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicSchemasTunnelsCollectionResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicIpsecTunnelsCreateIpsecTunnelsVariables = {
  body?: Schemas.MagicIpsecTunnelAddRequest;
  headers?: MagicIpsecTunnelsCreateIpsecTunnelsHeaders;
  pathParams: MagicIpsecTunnelsCreateIpsecTunnelsPathParams;
} & FetcherExtraProps;

/**
 * Creates new IPsec tunnels associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
 */
export const magicIpsecTunnelsCreateIpsecTunnels = (
  variables: MagicIpsecTunnelsCreateIpsecTunnelsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicSchemasTunnelsCollectionResponse,
    MagicIpsecTunnelsCreateIpsecTunnelsError,
    Schemas.MagicIpsecTunnelAddRequest,
    MagicIpsecTunnelsCreateIpsecTunnelsHeaders,
    {},
    MagicIpsecTunnelsCreateIpsecTunnelsPathParams
  >({ url: '/accounts/{accountId}/magic/ipsec_tunnels', method: 'post', ...variables, signal });

export type MagicIpsecTunnelsUpdateMultipleIpsecTunnelsPathParams = {
  accountId: Schemas.MagicIdentifier;
};

export type MagicIpsecTunnelsUpdateMultipleIpsecTunnelsHeaders = {
  /**
   * If true, the health check target in the request and response bodies will be presented using the new object format. Defaults to false.
   */
  ['x-magic-new-hc-target']?: boolean;
};

export type MagicIpsecTunnelsUpdateMultipleIpsecTunnelsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicSchemasModifiedTunnelsCollectionResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicIpsecTunnelsUpdateMultipleIpsecTunnelsVariables = {
  body: void;
  headers?: MagicIpsecTunnelsUpdateMultipleIpsecTunnelsHeaders;
  pathParams: MagicIpsecTunnelsUpdateMultipleIpsecTunnelsPathParams;
} & FetcherExtraProps;

/**
 * Update multiple IPsec tunnels associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
 */
export const magicIpsecTunnelsUpdateMultipleIpsecTunnels = (
  variables: MagicIpsecTunnelsUpdateMultipleIpsecTunnelsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicSchemasModifiedTunnelsCollectionResponse,
    MagicIpsecTunnelsUpdateMultipleIpsecTunnelsError,
    void,
    MagicIpsecTunnelsUpdateMultipleIpsecTunnelsHeaders,
    {},
    MagicIpsecTunnelsUpdateMultipleIpsecTunnelsPathParams
  >({ url: '/accounts/{accountId}/magic/ipsec_tunnels', method: 'put', ...variables, signal });

export type MagicIpsecTunnelsDeleteIpsecTunnelPathParams = {
  ipsecTunnelId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
};

export type MagicIpsecTunnelsDeleteIpsecTunnelHeaders = {
  /**
   * If true, the health check target in the response body will be presented using the new object format. Defaults to false.
   */
  ['x-magic-new-hc-target']?: boolean;
};

export type MagicIpsecTunnelsDeleteIpsecTunnelError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicSchemasTunnelDeletedResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicIpsecTunnelsDeleteIpsecTunnelVariables = {
  headers?: MagicIpsecTunnelsDeleteIpsecTunnelHeaders;
  pathParams: MagicIpsecTunnelsDeleteIpsecTunnelPathParams;
} & FetcherExtraProps;

/**
 * Disables and removes a specific static IPsec Tunnel associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
 */
export const magicIpsecTunnelsDeleteIpsecTunnel = (
  variables: MagicIpsecTunnelsDeleteIpsecTunnelVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicSchemasTunnelDeletedResponse,
    MagicIpsecTunnelsDeleteIpsecTunnelError,
    undefined,
    MagicIpsecTunnelsDeleteIpsecTunnelHeaders,
    {},
    MagicIpsecTunnelsDeleteIpsecTunnelPathParams
  >({ url: '/accounts/{accountId}/magic/ipsec_tunnels/{ipsecTunnelId}', method: 'delete', ...variables, signal });

export type MagicIpsecTunnelsListIpsecTunnelDetailsPathParams = {
  ipsecTunnelId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
};

export type MagicIpsecTunnelsListIpsecTunnelDetailsHeaders = {
  /**
   * If true, the health check target in the response body will be presented using the new object format. Defaults to false.
   */
  ['x-magic-new-hc-target']?: boolean;
};

export type MagicIpsecTunnelsListIpsecTunnelDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicSchemasTunnelSingleResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicIpsecTunnelsListIpsecTunnelDetailsVariables = {
  headers?: MagicIpsecTunnelsListIpsecTunnelDetailsHeaders;
  pathParams: MagicIpsecTunnelsListIpsecTunnelDetailsPathParams;
} & FetcherExtraProps;

/**
 * Lists details for a specific IPsec tunnel.
 */
export const magicIpsecTunnelsListIpsecTunnelDetails = (
  variables: MagicIpsecTunnelsListIpsecTunnelDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicSchemasTunnelSingleResponse,
    MagicIpsecTunnelsListIpsecTunnelDetailsError,
    undefined,
    MagicIpsecTunnelsListIpsecTunnelDetailsHeaders,
    {},
    MagicIpsecTunnelsListIpsecTunnelDetailsPathParams
  >({ url: '/accounts/{accountId}/magic/ipsec_tunnels/{ipsecTunnelId}', method: 'get', ...variables, signal });

export type MagicIpsecTunnelsUpdateIpsecTunnelPathParams = {
  ipsecTunnelId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
};

export type MagicIpsecTunnelsUpdateIpsecTunnelHeaders = {
  /**
   * If true, the health check target in the request and response bodies will be presented using the new object format. Defaults to false.
   */
  ['x-magic-new-hc-target']?: boolean;
};

export type MagicIpsecTunnelsUpdateIpsecTunnelError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicSchemasTunnelModifiedResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicIpsecTunnelsUpdateIpsecTunnelVariables = {
  body: Schemas.MagicIpsecTunnelAddSingleRequest;
  headers?: MagicIpsecTunnelsUpdateIpsecTunnelHeaders;
  pathParams: MagicIpsecTunnelsUpdateIpsecTunnelPathParams;
} & FetcherExtraProps;

/**
 * Updates a specific IPsec tunnel associated with an account. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes.
 */
export const magicIpsecTunnelsUpdateIpsecTunnel = (
  variables: MagicIpsecTunnelsUpdateIpsecTunnelVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicSchemasTunnelModifiedResponse,
    MagicIpsecTunnelsUpdateIpsecTunnelError,
    Schemas.MagicIpsecTunnelAddSingleRequest,
    MagicIpsecTunnelsUpdateIpsecTunnelHeaders,
    {},
    MagicIpsecTunnelsUpdateIpsecTunnelPathParams
  >({ url: '/accounts/{accountId}/magic/ipsec_tunnels/{ipsecTunnelId}', method: 'put', ...variables, signal });

export type MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsPathParams = {
  ipsecTunnelId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
};

export type MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicPskGenerationResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsVariables = {
  pathParams: MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsPathParams;
} & FetcherExtraProps;

/**
 * Generates a Pre Shared Key for a specific IPsec tunnel used in the IKE session. Use `?validate_only=true` as an optional query parameter to only run validation without persisting changes. After a PSK is generated, the PSK is immediately persisted to Cloudflare's edge and cannot be retrieved later. Note the PSK in a safe place.
 */
export const magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnels = (
  variables: MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicPskGenerationResponse,
    MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsError,
    undefined,
    {},
    {},
    MagicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnelsPathParams
  >({
    url: '/accounts/{accountId}/magic/ipsec_tunnels/{ipsecTunnelId}/psk_generate',
    method: 'post',
    ...variables,
    signal
  });

export type MagicStaticRoutesDeleteManyRoutesPathParams = {
  accountId: Schemas.MagicIdentifier;
};

export type MagicStaticRoutesDeleteManyRoutesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicMultipleRouteDeleteResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicStaticRoutesDeleteManyRoutesVariables = {
  body: Schemas.MagicRouteDeleteManyRequest;
  pathParams: MagicStaticRoutesDeleteManyRoutesPathParams;
} & FetcherExtraProps;

/**
 * Delete multiple Magic static routes.
 */
export const magicStaticRoutesDeleteManyRoutes = (
  variables: MagicStaticRoutesDeleteManyRoutesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicMultipleRouteDeleteResponse,
    MagicStaticRoutesDeleteManyRoutesError,
    Schemas.MagicRouteDeleteManyRequest,
    {},
    {},
    MagicStaticRoutesDeleteManyRoutesPathParams
  >({ url: '/accounts/{accountId}/magic/routes', method: 'delete', ...variables, signal });

export type MagicStaticRoutesListRoutesPathParams = {
  accountId: Schemas.MagicIdentifier;
};

export type MagicStaticRoutesListRoutesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicRoutesCollectionResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicStaticRoutesListRoutesVariables = {
  pathParams: MagicStaticRoutesListRoutesPathParams;
} & FetcherExtraProps;

/**
 * List all Magic static routes.
 */
export const magicStaticRoutesListRoutes = (variables: MagicStaticRoutesListRoutesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicRoutesCollectionResponse,
    MagicStaticRoutesListRoutesError,
    undefined,
    {},
    {},
    MagicStaticRoutesListRoutesPathParams
  >({ url: '/accounts/{accountId}/magic/routes', method: 'get', ...variables, signal });

export type MagicStaticRoutesCreateRoutesPathParams = {
  accountId: Schemas.MagicIdentifier;
};

export type MagicStaticRoutesCreateRoutesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicRoutesCollectionResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicStaticRoutesCreateRoutesVariables = {
  body: void;
  pathParams: MagicStaticRoutesCreateRoutesPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Magic static route. Use `?validate_only=true` as an optional query parameter to run validation only without persisting changes.
 */
export const magicStaticRoutesCreateRoutes = (
  variables: MagicStaticRoutesCreateRoutesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicRoutesCollectionResponse,
    MagicStaticRoutesCreateRoutesError,
    void,
    {},
    {},
    MagicStaticRoutesCreateRoutesPathParams
  >({ url: '/accounts/{accountId}/magic/routes', method: 'post', ...variables, signal });

export type MagicStaticRoutesUpdateManyRoutesPathParams = {
  accountId: Schemas.MagicIdentifier;
};

export type MagicStaticRoutesUpdateManyRoutesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicMultipleRouteModifiedResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicStaticRoutesUpdateManyRoutesVariables = {
  body: Schemas.MagicRouteUpdateManyRequest;
  pathParams: MagicStaticRoutesUpdateManyRoutesPathParams;
} & FetcherExtraProps;

/**
 * Update multiple Magic static routes. Use `?validate_only=true` as an optional query parameter to run validation only without persisting changes. Only fields for a route that need to be changed need be provided.
 */
export const magicStaticRoutesUpdateManyRoutes = (
  variables: MagicStaticRoutesUpdateManyRoutesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicMultipleRouteModifiedResponse,
    MagicStaticRoutesUpdateManyRoutesError,
    Schemas.MagicRouteUpdateManyRequest,
    {},
    {},
    MagicStaticRoutesUpdateManyRoutesPathParams
  >({ url: '/accounts/{accountId}/magic/routes', method: 'put', ...variables, signal });

export type MagicStaticRoutesDeleteRoutePathParams = {
  routeId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
};

export type MagicStaticRoutesDeleteRouteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicRouteDeletedResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicStaticRoutesDeleteRouteVariables = {
  pathParams: MagicStaticRoutesDeleteRoutePathParams;
} & FetcherExtraProps;

/**
 * Disable and remove a specific Magic static route.
 */
export const magicStaticRoutesDeleteRoute = (variables: MagicStaticRoutesDeleteRouteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicRouteDeletedResponse,
    MagicStaticRoutesDeleteRouteError,
    undefined,
    {},
    {},
    MagicStaticRoutesDeleteRoutePathParams
  >({ url: '/accounts/{accountId}/magic/routes/{routeId}', method: 'delete', ...variables, signal });

export type MagicStaticRoutesRouteDetailsPathParams = {
  routeId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
};

export type MagicStaticRoutesRouteDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicRouteSingleResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicStaticRoutesRouteDetailsVariables = {
  pathParams: MagicStaticRoutesRouteDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get a specific Magic static route.
 */
export const magicStaticRoutesRouteDetails = (
  variables: MagicStaticRoutesRouteDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicRouteSingleResponse,
    MagicStaticRoutesRouteDetailsError,
    undefined,
    {},
    {},
    MagicStaticRoutesRouteDetailsPathParams
  >({ url: '/accounts/{accountId}/magic/routes/{routeId}', method: 'get', ...variables, signal });

export type MagicStaticRoutesUpdateRoutePathParams = {
  routeId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
};

export type MagicStaticRoutesUpdateRouteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicRouteModifiedResponse & Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicStaticRoutesUpdateRouteVariables = {
  body?: Schemas.MagicRouteUpdateRequest;
  pathParams: MagicStaticRoutesUpdateRoutePathParams;
} & FetcherExtraProps;

/**
 * Update a specific Magic static route. Use `?validate_only=true` as an optional query parameter to run validation only without persisting changes.
 */
export const magicStaticRoutesUpdateRoute = (variables: MagicStaticRoutesUpdateRouteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicRouteModifiedResponse,
    MagicStaticRoutesUpdateRouteError,
    Schemas.MagicRouteUpdateRequest,
    {},
    {},
    MagicStaticRoutesUpdateRoutePathParams
  >({ url: '/accounts/{accountId}/magic/routes/{routeId}', method: 'put', ...variables, signal });

export type MagicSitesListSitesPathParams = {
  accountId: Schemas.MagicIdentifier;
};

export type MagicSitesListSitesQueryParams = {
  connector_identifier?: Schemas.MagicIdentifier;
};

export type MagicSitesListSitesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSitesListSitesVariables = {
  pathParams: MagicSitesListSitesPathParams;
  queryParams?: MagicSitesListSitesQueryParams;
} & FetcherExtraProps;

/**
 * Lists Sites associated with an account. Use connector_identifier query param to return sites where connector_identifier matches either site.ConnectorID or site.SecondaryConnectorID.
 */
export const magicSitesListSites = (variables: MagicSitesListSitesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicSitesCollectionResponse,
    MagicSitesListSitesError,
    undefined,
    {},
    MagicSitesListSitesQueryParams,
    MagicSitesListSitesPathParams
  >({ url: '/accounts/{accountId}/magic/sites', method: 'get', ...variables, signal });

export type MagicSitesCreateSitePathParams = {
  accountId: Schemas.MagicIdentifier;
};

export type MagicSitesCreateSiteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSitesCreateSiteVariables = {
  body: Schemas.MagicSitesAddSingleRequest;
  pathParams: MagicSitesCreateSitePathParams;
} & FetcherExtraProps;

/**
 * Creates a new Site
 */
export const magicSitesCreateSite = (variables: MagicSitesCreateSiteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicSiteSingleResponse,
    MagicSitesCreateSiteError,
    Schemas.MagicSitesAddSingleRequest,
    {},
    {},
    MagicSitesCreateSitePathParams
  >({ url: '/accounts/{accountId}/magic/sites', method: 'post', ...variables, signal });

export type MagicSitesDeleteSitePathParams = {
  siteId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
};

export type MagicSitesDeleteSiteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSitesDeleteSiteVariables = {
  pathParams: MagicSitesDeleteSitePathParams;
} & FetcherExtraProps;

/**
 * Remove a specific Site.
 */
export const magicSitesDeleteSite = (variables: MagicSitesDeleteSiteVariables, signal?: AbortSignal) =>
  fetch<Schemas.MagicSiteDeletedResponse, MagicSitesDeleteSiteError, undefined, {}, {}, MagicSitesDeleteSitePathParams>(
    { url: '/accounts/{accountId}/magic/sites/{siteId}', method: 'delete', ...variables, signal }
  );

export type MagicSitesSiteDetailsPathParams = {
  siteId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
};

export type MagicSitesSiteDetailsHeaders = {
  /**
   * If true, the health check target in the response body will be presented using the new object format. Defaults to false.
   */
  ['x-magic-new-hc-target']?: boolean;
};

export type MagicSitesSiteDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSitesSiteDetailsVariables = {
  headers?: MagicSitesSiteDetailsHeaders;
  pathParams: MagicSitesSiteDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get a specific Site.
 */
export const magicSitesSiteDetails = (variables: MagicSitesSiteDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicSiteSingleResponse,
    MagicSitesSiteDetailsError,
    undefined,
    MagicSitesSiteDetailsHeaders,
    {},
    MagicSitesSiteDetailsPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}', method: 'get', ...variables, signal });

export type MagicSitesPatchSitePathParams = {
  siteId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
};

export type MagicSitesPatchSiteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSitesPatchSiteVariables = {
  body?: Schemas.MagicSiteUpdateRequest;
  pathParams: MagicSitesPatchSitePathParams;
} & FetcherExtraProps;

/**
 * Patch a specific Site.
 */
export const magicSitesPatchSite = (variables: MagicSitesPatchSiteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicSiteModifiedResponse,
    MagicSitesPatchSiteError,
    Schemas.MagicSiteUpdateRequest,
    {},
    {},
    MagicSitesPatchSitePathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}', method: 'patch', ...variables, signal });

export type MagicSitesUpdateSitePathParams = {
  siteId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
};

export type MagicSitesUpdateSiteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSitesUpdateSiteVariables = {
  body?: Schemas.MagicSiteUpdateRequest;
  pathParams: MagicSitesUpdateSitePathParams;
} & FetcherExtraProps;

/**
 * Update a specific Site.
 */
export const magicSitesUpdateSite = (variables: MagicSitesUpdateSiteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicSiteModifiedResponse,
    MagicSitesUpdateSiteError,
    Schemas.MagicSiteUpdateRequest,
    {},
    {},
    MagicSitesUpdateSitePathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}', method: 'put', ...variables, signal });

export type MagicSiteAclsListAclsPathParams = {
  accountId: Schemas.MagicIdentifier;
  siteId: Schemas.MagicIdentifier;
};

export type MagicSiteAclsListAclsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteAclsListAclsVariables = {
  pathParams: MagicSiteAclsListAclsPathParams;
} & FetcherExtraProps;

/**
 * Lists Site ACLs associated with an account.
 */
export const magicSiteAclsListAcls = (variables: MagicSiteAclsListAclsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicAclsCollectionResponse,
    MagicSiteAclsListAclsError,
    undefined,
    {},
    {},
    MagicSiteAclsListAclsPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/acls', method: 'get', ...variables, signal });

export type MagicSiteAclsCreateAclPathParams = {
  accountId: Schemas.MagicIdentifier;
  siteId: Schemas.MagicIdentifier;
};

export type MagicSiteAclsCreateAclError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteAclsCreateAclVariables = {
  body: Schemas.MagicAclsAddSingleRequest;
  pathParams: MagicSiteAclsCreateAclPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Site ACL.
 */
export const magicSiteAclsCreateAcl = (variables: MagicSiteAclsCreateAclVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicAclSingleResponse,
    MagicSiteAclsCreateAclError,
    Schemas.MagicAclsAddSingleRequest,
    {},
    {},
    MagicSiteAclsCreateAclPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/acls', method: 'post', ...variables, signal });

export type MagicSiteAclsDeleteAclPathParams = {
  siteId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
  aclId: Schemas.MagicIdentifier;
};

export type MagicSiteAclsDeleteAclError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteAclsDeleteAclVariables = {
  pathParams: MagicSiteAclsDeleteAclPathParams;
} & FetcherExtraProps;

/**
 * Remove a specific Site ACL.
 */
export const magicSiteAclsDeleteAcl = (variables: MagicSiteAclsDeleteAclVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicAclDeletedResponse,
    MagicSiteAclsDeleteAclError,
    undefined,
    {},
    {},
    MagicSiteAclsDeleteAclPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/acls/{aclId}', method: 'delete', ...variables, signal });

export type MagicSiteAclsAclDetailsPathParams = {
  siteId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
  aclId: Schemas.MagicIdentifier;
};

export type MagicSiteAclsAclDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteAclsAclDetailsVariables = {
  pathParams: MagicSiteAclsAclDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get a specific Site ACL.
 */
export const magicSiteAclsAclDetails = (variables: MagicSiteAclsAclDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicAclSingleResponse,
    MagicSiteAclsAclDetailsError,
    undefined,
    {},
    {},
    MagicSiteAclsAclDetailsPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/acls/{aclId}', method: 'get', ...variables, signal });

export type MagicSiteAclsPatchAclPathParams = {
  siteId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
  aclId: Schemas.MagicIdentifier;
};

export type MagicSiteAclsPatchAclError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteAclsPatchAclVariables = {
  body?: Schemas.MagicAclUpdateRequest;
  pathParams: MagicSiteAclsPatchAclPathParams;
} & FetcherExtraProps;

/**
 * Patch a specific Site ACL.
 */
export const magicSiteAclsPatchAcl = (variables: MagicSiteAclsPatchAclVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicAclModifiedResponse,
    MagicSiteAclsPatchAclError,
    Schemas.MagicAclUpdateRequest,
    {},
    {},
    MagicSiteAclsPatchAclPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/acls/{aclId}', method: 'patch', ...variables, signal });

export type MagicSiteAclsUpdateAclPathParams = {
  siteId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
  aclId: Schemas.MagicIdentifier;
};

export type MagicSiteAclsUpdateAclError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteAclsUpdateAclVariables = {
  body?: Schemas.MagicAclUpdateRequest;
  pathParams: MagicSiteAclsUpdateAclPathParams;
} & FetcherExtraProps;

/**
 * Update a specific Site ACL.
 */
export const magicSiteAclsUpdateAcl = (variables: MagicSiteAclsUpdateAclVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicAclModifiedResponse,
    MagicSiteAclsUpdateAclError,
    Schemas.MagicAclUpdateRequest,
    {},
    {},
    MagicSiteAclsUpdateAclPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/acls/{aclId}', method: 'put', ...variables, signal });

export type MagicSiteAppConfigsListAppConfigsPathParams = {
  accountId: Schemas.MagicIdentifier;
  siteId: Schemas.MagicIdentifier;
};

export type MagicSiteAppConfigsListAppConfigsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteAppConfigsListAppConfigsVariables = {
  pathParams: MagicSiteAppConfigsListAppConfigsPathParams;
} & FetcherExtraProps;

/**
 * Lists App Configs associated with a site.
 */
export const magicSiteAppConfigsListAppConfigs = (
  variables: MagicSiteAppConfigsListAppConfigsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicAppConfigsCollectionResponse,
    MagicSiteAppConfigsListAppConfigsError,
    undefined,
    {},
    {},
    MagicSiteAppConfigsListAppConfigsPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/app_configs', method: 'get', ...variables, signal });

export type MagicSiteAppConfigsAddAppConfigPathParams = {
  accountId: Schemas.MagicIdentifier;
  siteId: Schemas.MagicIdentifier;
};

export type MagicSiteAppConfigsAddAppConfigError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteAppConfigsAddAppConfigVariables = {
  body?: Schemas.MagicAppConfigAddSingleRequest;
  pathParams: MagicSiteAppConfigsAddAppConfigPathParams;
} & FetcherExtraProps;

/**
 * Creates a new App Config for a site
 */
export const magicSiteAppConfigsAddAppConfig = (
  variables: MagicSiteAppConfigsAddAppConfigVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicAppConfigSingleResponse,
    MagicSiteAppConfigsAddAppConfigError,
    Schemas.MagicAppConfigAddSingleRequest,
    {},
    {},
    MagicSiteAppConfigsAddAppConfigPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/app_configs', method: 'post', ...variables, signal });

export type MagicSiteAppConfigsDeleteAppConfigPathParams = {
  accountId: Schemas.MagicIdentifier;
  siteId: Schemas.MagicIdentifier;
  appConfigId: Schemas.MagicIdentifier;
};

export type MagicSiteAppConfigsDeleteAppConfigError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteAppConfigsDeleteAppConfigVariables = {
  pathParams: MagicSiteAppConfigsDeleteAppConfigPathParams;
} & FetcherExtraProps;

/**
 * Deletes specific App Config associated with a site.
 */
export const magicSiteAppConfigsDeleteAppConfig = (
  variables: MagicSiteAppConfigsDeleteAppConfigVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicAppConfigSingleResponse,
    MagicSiteAppConfigsDeleteAppConfigError,
    undefined,
    {},
    {},
    MagicSiteAppConfigsDeleteAppConfigPathParams
  >({
    url: '/accounts/{accountId}/magic/sites/{siteId}/app_configs/{appConfigId}',
    method: 'delete',
    ...variables,
    signal
  });

export type MagicSiteAppConfigsUpdateAppConfigPathParams = {
  accountId: Schemas.MagicIdentifier;
  siteId: Schemas.MagicIdentifier;
  appConfigId: Schemas.MagicIdentifier;
};

export type MagicSiteAppConfigsUpdateAppConfigError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteAppConfigsUpdateAppConfigVariables = {
  body?: Schemas.MagicAppConfigUpdateRequest;
  pathParams: MagicSiteAppConfigsUpdateAppConfigPathParams;
} & FetcherExtraProps;

/**
 * Updates an App Config for a site
 */
export const magicSiteAppConfigsUpdateAppConfig = (
  variables: MagicSiteAppConfigsUpdateAppConfigVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicAppConfigSingleResponse,
    MagicSiteAppConfigsUpdateAppConfigError,
    Schemas.MagicAppConfigUpdateRequest,
    {},
    {},
    MagicSiteAppConfigsUpdateAppConfigPathParams
  >({
    url: '/accounts/{accountId}/magic/sites/{siteId}/app_configs/{appConfigId}',
    method: 'put',
    ...variables,
    signal
  });

export type MagicSiteLansListLansPathParams = {
  accountId: Schemas.MagicIdentifier;
  siteId: Schemas.MagicIdentifier;
};

export type MagicSiteLansListLansError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteLansListLansVariables = {
  pathParams: MagicSiteLansListLansPathParams;
} & FetcherExtraProps;

/**
 * Lists Site LANs associated with an account.
 */
export const magicSiteLansListLans = (variables: MagicSiteLansListLansVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicLansCollectionResponse,
    MagicSiteLansListLansError,
    undefined,
    {},
    {},
    MagicSiteLansListLansPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/lans', method: 'get', ...variables, signal });

export type MagicSiteLansCreateLanPathParams = {
  accountId: Schemas.MagicIdentifier;
  siteId: Schemas.MagicIdentifier;
};

export type MagicSiteLansCreateLanError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteLansCreateLanVariables = {
  body: Schemas.MagicLansAddSingleRequest;
  pathParams: MagicSiteLansCreateLanPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Site LAN. If the site is in high availability mode, static_addressing is required along with secondary and virtual address.
 */
export const magicSiteLansCreateLan = (variables: MagicSiteLansCreateLanVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicLansCollectionResponse,
    MagicSiteLansCreateLanError,
    Schemas.MagicLansAddSingleRequest,
    {},
    {},
    MagicSiteLansCreateLanPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/lans', method: 'post', ...variables, signal });

export type MagicSiteLansDeleteLanPathParams = {
  siteId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
  lanId: Schemas.MagicIdentifier;
};

export type MagicSiteLansDeleteLanError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteLansDeleteLanVariables = {
  pathParams: MagicSiteLansDeleteLanPathParams;
} & FetcherExtraProps;

/**
 * Remove a specific Site LAN.
 */
export const magicSiteLansDeleteLan = (variables: MagicSiteLansDeleteLanVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicLanDeletedResponse,
    MagicSiteLansDeleteLanError,
    undefined,
    {},
    {},
    MagicSiteLansDeleteLanPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/lans/{lanId}', method: 'delete', ...variables, signal });

export type MagicSiteLansLanDetailsPathParams = {
  siteId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
  lanId: Schemas.MagicIdentifier;
};

export type MagicSiteLansLanDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteLansLanDetailsVariables = {
  pathParams: MagicSiteLansLanDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get a specific Site LAN.
 */
export const magicSiteLansLanDetails = (variables: MagicSiteLansLanDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicLanSingleResponse,
    MagicSiteLansLanDetailsError,
    undefined,
    {},
    {},
    MagicSiteLansLanDetailsPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/lans/{lanId}', method: 'get', ...variables, signal });

export type MagicSiteLansPatchLanPathParams = {
  siteId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
  lanId: Schemas.MagicIdentifier;
};

export type MagicSiteLansPatchLanError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteLansPatchLanVariables = {
  body?: Schemas.MagicLanUpdateRequest;
  pathParams: MagicSiteLansPatchLanPathParams;
} & FetcherExtraProps;

/**
 * Patch a specific Site LAN.
 */
export const magicSiteLansPatchLan = (variables: MagicSiteLansPatchLanVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicLanModifiedResponse,
    MagicSiteLansPatchLanError,
    Schemas.MagicLanUpdateRequest,
    {},
    {},
    MagicSiteLansPatchLanPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/lans/{lanId}', method: 'patch', ...variables, signal });

export type MagicSiteLansUpdateLanPathParams = {
  siteId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
  lanId: Schemas.MagicIdentifier;
};

export type MagicSiteLansUpdateLanError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteLansUpdateLanVariables = {
  body?: Schemas.MagicLanUpdateRequest;
  pathParams: MagicSiteLansUpdateLanPathParams;
} & FetcherExtraProps;

/**
 * Update a specific Site LAN.
 */
export const magicSiteLansUpdateLan = (variables: MagicSiteLansUpdateLanVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicLanModifiedResponse,
    MagicSiteLansUpdateLanError,
    Schemas.MagicLanUpdateRequest,
    {},
    {},
    MagicSiteLansUpdateLanPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/lans/{lanId}', method: 'put', ...variables, signal });

export type MagicSiteWansListWansPathParams = {
  accountId: Schemas.MagicIdentifier;
  siteId: Schemas.MagicIdentifier;
};

export type MagicSiteWansListWansError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteWansListWansVariables = {
  pathParams: MagicSiteWansListWansPathParams;
} & FetcherExtraProps;

/**
 * Lists Site WANs associated with an account.
 */
export const magicSiteWansListWans = (variables: MagicSiteWansListWansVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicWansCollectionResponse,
    MagicSiteWansListWansError,
    undefined,
    {},
    {},
    MagicSiteWansListWansPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/wans', method: 'get', ...variables, signal });

export type MagicSiteWansCreateWanPathParams = {
  accountId: Schemas.MagicIdentifier;
  siteId: Schemas.MagicIdentifier;
};

export type MagicSiteWansCreateWanError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteWansCreateWanVariables = {
  body: Schemas.MagicWansAddSingleRequest;
  pathParams: MagicSiteWansCreateWanPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Site WAN.
 */
export const magicSiteWansCreateWan = (variables: MagicSiteWansCreateWanVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicWansCollectionResponse,
    MagicSiteWansCreateWanError,
    Schemas.MagicWansAddSingleRequest,
    {},
    {},
    MagicSiteWansCreateWanPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/wans', method: 'post', ...variables, signal });

export type MagicSiteWansDeleteWanPathParams = {
  siteId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
  wanId: Schemas.MagicIdentifier;
};

export type MagicSiteWansDeleteWanError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteWansDeleteWanVariables = {
  pathParams: MagicSiteWansDeleteWanPathParams;
} & FetcherExtraProps;

/**
 * Remove a specific Site WAN.
 */
export const magicSiteWansDeleteWan = (variables: MagicSiteWansDeleteWanVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicWanDeletedResponse,
    MagicSiteWansDeleteWanError,
    undefined,
    {},
    {},
    MagicSiteWansDeleteWanPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/wans/{wanId}', method: 'delete', ...variables, signal });

export type MagicSiteWansWanDetailsPathParams = {
  siteId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
  wanId: Schemas.MagicIdentifier;
};

export type MagicSiteWansWanDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteWansWanDetailsVariables = {
  pathParams: MagicSiteWansWanDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get a specific Site WAN.
 */
export const magicSiteWansWanDetails = (variables: MagicSiteWansWanDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicWanSingleResponse,
    MagicSiteWansWanDetailsError,
    undefined,
    {},
    {},
    MagicSiteWansWanDetailsPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/wans/{wanId}', method: 'get', ...variables, signal });

export type MagicSiteWansPatchWanPathParams = {
  siteId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
  wanId: Schemas.MagicIdentifier;
};

export type MagicSiteWansPatchWanError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteWansPatchWanVariables = {
  body?: Schemas.MagicWanUpdateRequest;
  pathParams: MagicSiteWansPatchWanPathParams;
} & FetcherExtraProps;

/**
 * Patch a specific Site WAN.
 */
export const magicSiteWansPatchWan = (variables: MagicSiteWansPatchWanVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicWanModifiedResponse,
    MagicSiteWansPatchWanError,
    Schemas.MagicWanUpdateRequest,
    {},
    {},
    MagicSiteWansPatchWanPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/wans/{wanId}', method: 'patch', ...variables, signal });

export type MagicSiteWansUpdateWanPathParams = {
  siteId: Schemas.MagicIdentifier;
  accountId: Schemas.MagicIdentifier;
  wanId: Schemas.MagicIdentifier;
};

export type MagicSiteWansUpdateWanError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicApiResponseCommonFailure;
}>;

export type MagicSiteWansUpdateWanVariables = {
  body?: Schemas.MagicWanUpdateRequest;
  pathParams: MagicSiteWansUpdateWanPathParams;
} & FetcherExtraProps;

/**
 * Update a specific Site WAN.
 */
export const magicSiteWansUpdateWan = (variables: MagicSiteWansUpdateWanVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.MagicWanModifiedResponse,
    MagicSiteWansUpdateWanError,
    Schemas.MagicWanUpdateRequest,
    {},
    {},
    MagicSiteWansUpdateWanPathParams
  >({ url: '/accounts/{accountId}/magic/sites/{siteId}/wans/{wanId}', method: 'put', ...variables, signal });

export type AccountMembersListMembersPathParams = {
  accountId: Schemas.IamAccountIdentifier;
};

export type AccountMembersListMembersQueryParams = {
  /**
   * @example status
   */
  order?: 'user.first_name' | 'user.last_name' | 'user.email' | 'status';
  /**
   * @example accepted
   */
  status?: 'accepted' | 'pending' | 'rejected';
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example desc
   */
  direction?: 'asc' | 'desc';
};

export type AccountMembersListMembersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountMembersListMembersVariables = {
  pathParams: AccountMembersListMembersPathParams;
  queryParams?: AccountMembersListMembersQueryParams;
} & FetcherExtraProps;

/**
 * List all members of an account.
 */
export const accountMembersListMembers = (variables: AccountMembersListMembersVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamCollectionMemberResponseWithPolicies,
    AccountMembersListMembersError,
    undefined,
    {},
    AccountMembersListMembersQueryParams,
    AccountMembersListMembersPathParams
  >({ url: '/accounts/{accountId}/members', method: 'get', ...variables, signal });

export type AccountMembersAddMemberPathParams = {
  accountId: Schemas.IamAccountIdentifier;
};

export type AccountMembersAddMemberError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountMembersAddMemberVariables = {
  body?: Schemas.IamCreateMemberWithRoles | Schemas.IamCreateMemberWithPolicies;
  pathParams: AccountMembersAddMemberPathParams;
} & FetcherExtraProps;

/**
 * Add a user to the list of members for this account.
 */
export const accountMembersAddMember = (variables: AccountMembersAddMemberVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamSingleMemberResponseWithPolicies,
    AccountMembersAddMemberError,
    Schemas.IamCreateMemberWithRoles | Schemas.IamCreateMemberWithPolicies,
    {},
    {},
    AccountMembersAddMemberPathParams
  >({ url: '/accounts/{accountId}/members', method: 'post', ...variables, signal });

export type AccountMembersRemoveMemberPathParams = {
  memberId: Schemas.IamMembershipComponentsSchemasIdentifier;
  accountId: Schemas.IamAccountIdentifier;
};

export type AccountMembersRemoveMemberError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountMembersRemoveMemberVariables = {
  pathParams: AccountMembersRemoveMemberPathParams;
} & FetcherExtraProps;

/**
 * Remove a member from an account.
 */
export const accountMembersRemoveMember = (variables: AccountMembersRemoveMemberVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamApiResponseSingleId,
    AccountMembersRemoveMemberError,
    undefined,
    {},
    {},
    AccountMembersRemoveMemberPathParams
  >({ url: '/accounts/{accountId}/members/{memberId}', method: 'delete', ...variables, signal });

export type AccountMembersMemberDetailsPathParams = {
  memberId: Schemas.IamMembershipComponentsSchemasIdentifier;
  accountId: Schemas.IamAccountIdentifier;
};

export type AccountMembersMemberDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountMembersMemberDetailsVariables = {
  pathParams: AccountMembersMemberDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get information about a specific member of an account.
 */
export const accountMembersMemberDetails = (variables: AccountMembersMemberDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamSingleMemberResponseWithPolicies,
    AccountMembersMemberDetailsError,
    undefined,
    {},
    {},
    AccountMembersMemberDetailsPathParams
  >({ url: '/accounts/{accountId}/members/{memberId}', method: 'get', ...variables, signal });

export type AccountMembersUpdateMemberPathParams = {
  memberId: Schemas.IamMembershipComponentsSchemasIdentifier;
  accountId: Schemas.IamAccountIdentifier;
};

export type AccountMembersUpdateMemberError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountMembersUpdateMemberVariables = {
  body?: Schemas.IamUpdateMemberWithRoles | Schemas.IamUpdateMemberWithPolicies;
  pathParams: AccountMembersUpdateMemberPathParams;
} & FetcherExtraProps;

/**
 * Modify an account member.
 */
export const accountMembersUpdateMember = (variables: AccountMembersUpdateMemberVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamSingleMemberResponseWithPolicies,
    AccountMembersUpdateMemberError,
    Schemas.IamUpdateMemberWithRoles | Schemas.IamUpdateMemberWithPolicies,
    {},
    {},
    AccountMembersUpdateMemberPathParams
  >({ url: '/accounts/{accountId}/members/{memberId}', method: 'put', ...variables, signal });

export type MagicNetworkMonitoringConfigurationDeleteAccountConfigurationPathParams = {
  accountId: Schemas.MagicVisibilityMnmAccountIdentifier;
};

export type MagicNetworkMonitoringConfigurationDeleteAccountConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicVisibilityMnmMnmConfigSingleResponse & Schemas.MagicVisibilityMnmApiResponseCommonFailure;
}>;

export type MagicNetworkMonitoringConfigurationDeleteAccountConfigurationVariables = {
  pathParams: MagicNetworkMonitoringConfigurationDeleteAccountConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Delete an existing network monitoring configuration.
 */
export const magicNetworkMonitoringConfigurationDeleteAccountConfiguration = (
  variables: MagicNetworkMonitoringConfigurationDeleteAccountConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityMnmMnmConfigSingleResponse,
    MagicNetworkMonitoringConfigurationDeleteAccountConfigurationError,
    undefined,
    {},
    {},
    MagicNetworkMonitoringConfigurationDeleteAccountConfigurationPathParams
  >({ url: '/accounts/{accountId}/mnm/config', method: 'delete', ...variables, signal });

export type MagicNetworkMonitoringConfigurationListAccountConfigurationPathParams = {
  accountId: Schemas.MagicVisibilityMnmAccountIdentifier;
};

export type MagicNetworkMonitoringConfigurationListAccountConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicVisibilityMnmMnmConfigSingleResponse & Schemas.MagicVisibilityMnmApiResponseCommonFailure;
}>;

export type MagicNetworkMonitoringConfigurationListAccountConfigurationVariables = {
  pathParams: MagicNetworkMonitoringConfigurationListAccountConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Lists default sampling, router IPs and warp devices for account.
 */
export const magicNetworkMonitoringConfigurationListAccountConfiguration = (
  variables: MagicNetworkMonitoringConfigurationListAccountConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityMnmMnmConfigSingleResponse,
    MagicNetworkMonitoringConfigurationListAccountConfigurationError,
    undefined,
    {},
    {},
    MagicNetworkMonitoringConfigurationListAccountConfigurationPathParams
  >({ url: '/accounts/{accountId}/mnm/config', method: 'get', ...variables, signal });

export type MagicNetworkMonitoringConfigurationUpdateAccountConfigurationFieldsPathParams = {
  accountId: Schemas.MagicVisibilityMnmAccountIdentifier;
};

export type MagicNetworkMonitoringConfigurationUpdateAccountConfigurationFieldsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicVisibilityMnmMnmConfigSingleResponse & Schemas.MagicVisibilityMnmApiResponseCommonFailure;
}>;

export type MagicNetworkMonitoringConfigurationUpdateAccountConfigurationFieldsRequestBody = {
  default_sampling?: Schemas.MagicVisibilityMnmMnmConfigDefaultSampling;
  name?: Schemas.MagicVisibilityMnmMnmConfigName;
  router_ips?: Schemas.MagicVisibilityMnmMnmConfigRouterIps;
  warp_devices?: Schemas.MagicVisibilityMnmMnmConfigWarpDevices;
};

export type MagicNetworkMonitoringConfigurationUpdateAccountConfigurationFieldsVariables = {
  body?: MagicNetworkMonitoringConfigurationUpdateAccountConfigurationFieldsRequestBody;
  pathParams: MagicNetworkMonitoringConfigurationUpdateAccountConfigurationFieldsPathParams;
} & FetcherExtraProps;

/**
 * Update fields in an existing network monitoring configuration.
 */
export const magicNetworkMonitoringConfigurationUpdateAccountConfigurationFields = (
  variables: MagicNetworkMonitoringConfigurationUpdateAccountConfigurationFieldsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityMnmMnmConfigSingleResponse,
    MagicNetworkMonitoringConfigurationUpdateAccountConfigurationFieldsError,
    MagicNetworkMonitoringConfigurationUpdateAccountConfigurationFieldsRequestBody,
    {},
    {},
    MagicNetworkMonitoringConfigurationUpdateAccountConfigurationFieldsPathParams
  >({ url: '/accounts/{accountId}/mnm/config', method: 'patch', ...variables, signal });

export type MagicNetworkMonitoringConfigurationCreateAccountConfigurationPathParams = {
  accountId: Schemas.MagicVisibilityMnmAccountIdentifier;
};

export type MagicNetworkMonitoringConfigurationCreateAccountConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicVisibilityMnmMnmConfigSingleResponse & Schemas.MagicVisibilityMnmApiResponseCommonFailure;
}>;

export type MagicNetworkMonitoringConfigurationCreateAccountConfigurationRequestBody = {
  default_sampling: Schemas.MagicVisibilityMnmMnmConfigDefaultSampling;
  name: Schemas.MagicVisibilityMnmMnmConfigName;
  router_ips?: Schemas.MagicVisibilityMnmMnmConfigRouterIps;
  warp_devices?: Schemas.MagicVisibilityMnmMnmConfigWarpDevices;
};

export type MagicNetworkMonitoringConfigurationCreateAccountConfigurationVariables = {
  body: MagicNetworkMonitoringConfigurationCreateAccountConfigurationRequestBody;
  pathParams: MagicNetworkMonitoringConfigurationCreateAccountConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Create a new network monitoring configuration.
 */
export const magicNetworkMonitoringConfigurationCreateAccountConfiguration = (
  variables: MagicNetworkMonitoringConfigurationCreateAccountConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityMnmMnmConfigSingleResponse,
    MagicNetworkMonitoringConfigurationCreateAccountConfigurationError,
    MagicNetworkMonitoringConfigurationCreateAccountConfigurationRequestBody,
    {},
    {},
    MagicNetworkMonitoringConfigurationCreateAccountConfigurationPathParams
  >({ url: '/accounts/{accountId}/mnm/config', method: 'post', ...variables, signal });

export type MagicNetworkMonitoringConfigurationUpdateAnEntireAccountConfigurationPathParams = {
  accountId: Schemas.MagicVisibilityMnmAccountIdentifier;
};

export type MagicNetworkMonitoringConfigurationUpdateAnEntireAccountConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicVisibilityMnmMnmConfigSingleResponse & Schemas.MagicVisibilityMnmApiResponseCommonFailure;
}>;

export type MagicNetworkMonitoringConfigurationUpdateAnEntireAccountConfigurationRequestBody = {
  default_sampling: Schemas.MagicVisibilityMnmMnmConfigDefaultSampling;
  name: Schemas.MagicVisibilityMnmMnmConfigName;
  router_ips?: Schemas.MagicVisibilityMnmMnmConfigRouterIps;
  warp_devices?: Schemas.MagicVisibilityMnmMnmConfigWarpDevices;
};

export type MagicNetworkMonitoringConfigurationUpdateAnEntireAccountConfigurationVariables = {
  body: MagicNetworkMonitoringConfigurationUpdateAnEntireAccountConfigurationRequestBody;
  pathParams: MagicNetworkMonitoringConfigurationUpdateAnEntireAccountConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Update an existing network monitoring configuration, requires the entire configuration to be updated at once.
 */
export const magicNetworkMonitoringConfigurationUpdateAnEntireAccountConfiguration = (
  variables: MagicNetworkMonitoringConfigurationUpdateAnEntireAccountConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityMnmMnmConfigSingleResponse,
    MagicNetworkMonitoringConfigurationUpdateAnEntireAccountConfigurationError,
    MagicNetworkMonitoringConfigurationUpdateAnEntireAccountConfigurationRequestBody,
    {},
    {},
    MagicNetworkMonitoringConfigurationUpdateAnEntireAccountConfigurationPathParams
  >({ url: '/accounts/{accountId}/mnm/config', method: 'put', ...variables, signal });

export type MagicNetworkMonitoringConfigurationListRulesAndAccountConfigurationPathParams = {
  accountId: Schemas.MagicVisibilityMnmAccountIdentifier;
};

export type MagicNetworkMonitoringConfigurationListRulesAndAccountConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicVisibilityMnmMnmConfigSingleResponse & Schemas.MagicVisibilityMnmApiResponseCommonFailure;
}>;

export type MagicNetworkMonitoringConfigurationListRulesAndAccountConfigurationVariables = {
  pathParams: MagicNetworkMonitoringConfigurationListRulesAndAccountConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Lists default sampling, router IPs, warp devices, and rules for account.
 */
export const magicNetworkMonitoringConfigurationListRulesAndAccountConfiguration = (
  variables: MagicNetworkMonitoringConfigurationListRulesAndAccountConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityMnmMnmConfigSingleResponse,
    MagicNetworkMonitoringConfigurationListRulesAndAccountConfigurationError,
    undefined,
    {},
    {},
    MagicNetworkMonitoringConfigurationListRulesAndAccountConfigurationPathParams
  >({ url: '/accounts/{accountId}/mnm/config/full', method: 'get', ...variables, signal });

export type MagicNetworkMonitoringRulesListRulesPathParams = {
  accountId: Schemas.MagicVisibilityMnmAccountIdentifier;
};

export type MagicNetworkMonitoringRulesListRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicVisibilityMnmMnmRulesCollectionResponse & Schemas.MagicVisibilityMnmApiResponseCommonFailure;
}>;

export type MagicNetworkMonitoringRulesListRulesVariables = {
  pathParams: MagicNetworkMonitoringRulesListRulesPathParams;
} & FetcherExtraProps;

/**
 * Lists network monitoring rules for account.
 */
export const magicNetworkMonitoringRulesListRules = (
  variables: MagicNetworkMonitoringRulesListRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityMnmMnmRulesCollectionResponse,
    MagicNetworkMonitoringRulesListRulesError,
    undefined,
    {},
    {},
    MagicNetworkMonitoringRulesListRulesPathParams
  >({ url: '/accounts/{accountId}/mnm/rules', method: 'get', ...variables, signal });

export type MagicNetworkMonitoringRulesCreateRulesPathParams = {
  accountId: Schemas.MagicVisibilityMnmAccountIdentifier;
};

export type MagicNetworkMonitoringRulesCreateRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicVisibilityMnmMnmRulesSingleResponse & Schemas.MagicVisibilityMnmApiResponseCommonFailure;
}>;

export type MagicNetworkMonitoringRulesCreateRulesRequestBody = {
  automatic_advertisement?: Schemas.MagicVisibilityMnmMnmRuleAutomaticAdvertisement;
  bandwidth?: Schemas.MagicVisibilityMnmMnmRuleBandwidthThreshold;
  duration: Schemas.MagicVisibilityMnmMnmRuleDuration;
  name: Schemas.MagicVisibilityMnmMnmRuleName;
  packet_threshold?: Schemas.MagicVisibilityMnmMnmRulePacketThreshold;
  prefixes?: Schemas.MagicVisibilityMnmMnmRuleIpPrefixes;
};

export type MagicNetworkMonitoringRulesCreateRulesVariables = {
  body: MagicNetworkMonitoringRulesCreateRulesRequestBody;
  pathParams: MagicNetworkMonitoringRulesCreateRulesPathParams;
} & FetcherExtraProps;

/**
 * Create network monitoring rules for account. Currently only supports creating a single rule per API request.
 */
export const magicNetworkMonitoringRulesCreateRules = (
  variables: MagicNetworkMonitoringRulesCreateRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityMnmMnmRulesSingleResponse,
    MagicNetworkMonitoringRulesCreateRulesError,
    MagicNetworkMonitoringRulesCreateRulesRequestBody,
    {},
    {},
    MagicNetworkMonitoringRulesCreateRulesPathParams
  >({ url: '/accounts/{accountId}/mnm/rules', method: 'post', ...variables, signal });

export type MagicNetworkMonitoringRulesUpdateRulesPathParams = {
  accountId: Schemas.MagicVisibilityMnmAccountIdentifier;
};

export type MagicNetworkMonitoringRulesUpdateRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicVisibilityMnmMnmRulesSingleResponse & Schemas.MagicVisibilityMnmApiResponseCommonFailure;
}>;

export type MagicNetworkMonitoringRulesUpdateRulesRequestBody = {
  automatic_advertisement?: Schemas.MagicVisibilityMnmMnmRuleAutomaticAdvertisement;
  bandwidth?: Schemas.MagicVisibilityMnmMnmRuleBandwidthThreshold;
  duration: Schemas.MagicVisibilityMnmMnmRuleDuration;
  id?: Schemas.MagicVisibilityMnmRuleIdentifier;
  name: Schemas.MagicVisibilityMnmMnmRuleName;
  packet_threshold?: Schemas.MagicVisibilityMnmMnmRulePacketThreshold;
  prefixes?: Schemas.MagicVisibilityMnmMnmRuleIpPrefixes;
};

export type MagicNetworkMonitoringRulesUpdateRulesVariables = {
  body: MagicNetworkMonitoringRulesUpdateRulesRequestBody;
  pathParams: MagicNetworkMonitoringRulesUpdateRulesPathParams;
} & FetcherExtraProps;

/**
 * Update network monitoring rules for account.
 */
export const magicNetworkMonitoringRulesUpdateRules = (
  variables: MagicNetworkMonitoringRulesUpdateRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityMnmMnmRulesSingleResponse,
    MagicNetworkMonitoringRulesUpdateRulesError,
    MagicNetworkMonitoringRulesUpdateRulesRequestBody,
    {},
    {},
    MagicNetworkMonitoringRulesUpdateRulesPathParams
  >({ url: '/accounts/{accountId}/mnm/rules', method: 'put', ...variables, signal });

export type MagicNetworkMonitoringRulesDeleteRulePathParams = {
  ruleId: Schemas.MagicVisibilityMnmRuleIdentifier;
  accountId: Schemas.MagicVisibilityMnmAccountIdentifier;
};

export type MagicNetworkMonitoringRulesDeleteRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicVisibilityMnmMnmRulesSingleResponse & Schemas.MagicVisibilityMnmApiResponseCommonFailure;
}>;

export type MagicNetworkMonitoringRulesDeleteRuleVariables = {
  pathParams: MagicNetworkMonitoringRulesDeleteRulePathParams;
} & FetcherExtraProps;

/**
 * Delete a network monitoring rule for account.
 */
export const magicNetworkMonitoringRulesDeleteRule = (
  variables: MagicNetworkMonitoringRulesDeleteRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityMnmMnmRulesSingleResponse,
    MagicNetworkMonitoringRulesDeleteRuleError,
    undefined,
    {},
    {},
    MagicNetworkMonitoringRulesDeleteRulePathParams
  >({ url: '/accounts/{accountId}/mnm/rules/{ruleId}', method: 'delete', ...variables, signal });

export type MagicNetworkMonitoringRulesGetRulePathParams = {
  ruleId: Schemas.MagicVisibilityMnmRuleIdentifier;
  accountId: Schemas.MagicVisibilityMnmAccountIdentifier;
};

export type MagicNetworkMonitoringRulesGetRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicVisibilityMnmMnmRulesSingleResponse & Schemas.MagicVisibilityMnmApiResponseCommonFailure;
}>;

export type MagicNetworkMonitoringRulesGetRuleVariables = {
  pathParams: MagicNetworkMonitoringRulesGetRulePathParams;
} & FetcherExtraProps;

/**
 * List a single network monitoring rule for account.
 */
export const magicNetworkMonitoringRulesGetRule = (
  variables: MagicNetworkMonitoringRulesGetRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityMnmMnmRulesSingleResponse,
    MagicNetworkMonitoringRulesGetRuleError,
    undefined,
    {},
    {},
    MagicNetworkMonitoringRulesGetRulePathParams
  >({ url: '/accounts/{accountId}/mnm/rules/{ruleId}', method: 'get', ...variables, signal });

export type MagicNetworkMonitoringRulesUpdateRulePathParams = {
  ruleId: Schemas.MagicVisibilityMnmRuleIdentifier;
  accountId: Schemas.MagicVisibilityMnmAccountIdentifier;
};

export type MagicNetworkMonitoringRulesUpdateRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicVisibilityMnmMnmRulesSingleResponse & Schemas.MagicVisibilityMnmApiResponseCommonFailure;
}>;

export type MagicNetworkMonitoringRulesUpdateRuleRequestBody = {
  automatic_advertisement?: Schemas.MagicVisibilityMnmMnmRuleAutomaticAdvertisement;
  bandwidth?: Schemas.MagicVisibilityMnmMnmRuleBandwidthThreshold;
  duration?: Schemas.MagicVisibilityMnmMnmRuleDuration;
  name?: Schemas.MagicVisibilityMnmMnmRuleName;
  packet_threshold?: Schemas.MagicVisibilityMnmMnmRulePacketThreshold;
  prefixes?: Schemas.MagicVisibilityMnmMnmRuleIpPrefixes;
};

export type MagicNetworkMonitoringRulesUpdateRuleVariables = {
  body?: MagicNetworkMonitoringRulesUpdateRuleRequestBody;
  pathParams: MagicNetworkMonitoringRulesUpdateRulePathParams;
} & FetcherExtraProps;

/**
 * Update a network monitoring rule for account.
 */
export const magicNetworkMonitoringRulesUpdateRule = (
  variables: MagicNetworkMonitoringRulesUpdateRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityMnmMnmRulesSingleResponse,
    MagicNetworkMonitoringRulesUpdateRuleError,
    MagicNetworkMonitoringRulesUpdateRuleRequestBody,
    {},
    {},
    MagicNetworkMonitoringRulesUpdateRulePathParams
  >({ url: '/accounts/{accountId}/mnm/rules/{ruleId}', method: 'patch', ...variables, signal });

export type MagicNetworkMonitoringRulesUpdateAdvertisementForRulePathParams = {
  ruleId: Schemas.MagicVisibilityMnmRuleIdentifier;
  accountId: Schemas.MagicVisibilityMnmAccountIdentifier;
};

export type MagicNetworkMonitoringRulesUpdateAdvertisementForRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MagicVisibilityMnmMnmRuleAdvertisementSingleResponse &
    Schemas.MagicVisibilityMnmApiResponseCommonFailure;
}>;

export type MagicNetworkMonitoringRulesUpdateAdvertisementForRuleVariables = {
  pathParams: MagicNetworkMonitoringRulesUpdateAdvertisementForRulePathParams;
} & FetcherExtraProps;

/**
 * Update advertisement for rule.
 */
export const magicNetworkMonitoringRulesUpdateAdvertisementForRule = (
  variables: MagicNetworkMonitoringRulesUpdateAdvertisementForRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityMnmMnmRuleAdvertisementSingleResponse,
    MagicNetworkMonitoringRulesUpdateAdvertisementForRuleError,
    undefined,
    {},
    {},
    MagicNetworkMonitoringRulesUpdateAdvertisementForRulePathParams
  >({ url: '/accounts/{accountId}/mnm/rules/{ruleId}/advertisement', method: 'patch', ...variables, signal });

export type MTlsCertificateManagementListMTlsCertificatesPathParams = {
  accountId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type MTlsCertificateManagementListMTlsCertificatesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesMtlsManagementComponentsSchemasCertificateResponseCollection &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type MTlsCertificateManagementListMTlsCertificatesVariables = {
  pathParams: MTlsCertificateManagementListMTlsCertificatesPathParams;
} & FetcherExtraProps;

/**
 * Lists all mTLS certificates.
 */
export const mTlsCertificateManagementListMTlsCertificates = (
  variables: MTlsCertificateManagementListMTlsCertificatesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesMtlsManagementComponentsSchemasCertificateResponseCollection,
    MTlsCertificateManagementListMTlsCertificatesError,
    undefined,
    {},
    {},
    MTlsCertificateManagementListMTlsCertificatesPathParams
  >({ url: '/accounts/{accountId}/mtls_certificates', method: 'get', ...variables, signal });

export type MTlsCertificateManagementUploadMTlsCertificatePathParams = {
  accountId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type MTlsCertificateManagementUploadMTlsCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesCertificateResponseSinglePost &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type MTlsCertificateManagementUploadMTlsCertificateRequestBody = {
  ca: Schemas.TlsCertificatesAndHostnamesCa;
  certificates: Schemas.TlsCertificatesAndHostnamesSchemasCertificates;
  name?: Schemas.TlsCertificatesAndHostnamesSchemasName;
  private_key?: Schemas.TlsCertificatesAndHostnamesComponentsSchemasPrivateKey;
};

export type MTlsCertificateManagementUploadMTlsCertificateVariables = {
  body: MTlsCertificateManagementUploadMTlsCertificateRequestBody;
  pathParams: MTlsCertificateManagementUploadMTlsCertificatePathParams;
} & FetcherExtraProps;

/**
 * Upload a certificate that you want to use with mTLS-enabled Cloudflare services.
 */
export const mTlsCertificateManagementUploadMTlsCertificate = (
  variables: MTlsCertificateManagementUploadMTlsCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesCertificateResponseSinglePost,
    MTlsCertificateManagementUploadMTlsCertificateError,
    MTlsCertificateManagementUploadMTlsCertificateRequestBody,
    {},
    {},
    MTlsCertificateManagementUploadMTlsCertificatePathParams
  >({ url: '/accounts/{accountId}/mtls_certificates', method: 'post', ...variables, signal });

export type MTlsCertificateManagementDeleteMTlsCertificatePathParams = {
  mtlsCertificateId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  accountId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type MTlsCertificateManagementDeleteMTlsCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesMtlsManagementComponentsSchemasCertificateResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type MTlsCertificateManagementDeleteMTlsCertificateVariables = {
  pathParams: MTlsCertificateManagementDeleteMTlsCertificatePathParams;
} & FetcherExtraProps;

/**
 * Deletes the mTLS certificate unless the certificate is in use by one or more Cloudflare services.
 */
export const mTlsCertificateManagementDeleteMTlsCertificate = (
  variables: MTlsCertificateManagementDeleteMTlsCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesMtlsManagementComponentsSchemasCertificateResponseSingle,
    MTlsCertificateManagementDeleteMTlsCertificateError,
    undefined,
    {},
    {},
    MTlsCertificateManagementDeleteMTlsCertificatePathParams
  >({ url: '/accounts/{accountId}/mtls_certificates/{mtlsCertificateId}', method: 'delete', ...variables, signal });

export type MTlsCertificateManagementGetMTlsCertificatePathParams = {
  mtlsCertificateId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  accountId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type MTlsCertificateManagementGetMTlsCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesMtlsManagementComponentsSchemasCertificateResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type MTlsCertificateManagementGetMTlsCertificateVariables = {
  pathParams: MTlsCertificateManagementGetMTlsCertificatePathParams;
} & FetcherExtraProps;

/**
 * Fetches a single mTLS certificate.
 */
export const mTlsCertificateManagementGetMTlsCertificate = (
  variables: MTlsCertificateManagementGetMTlsCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesMtlsManagementComponentsSchemasCertificateResponseSingle,
    MTlsCertificateManagementGetMTlsCertificateError,
    undefined,
    {},
    {},
    MTlsCertificateManagementGetMTlsCertificatePathParams
  >({ url: '/accounts/{accountId}/mtls_certificates/{mtlsCertificateId}', method: 'get', ...variables, signal });

export type MTlsCertificateManagementListMTlsCertificateAssociationsPathParams = {
  mtlsCertificateId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  accountId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type MTlsCertificateManagementListMTlsCertificateAssociationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesAssociationResponseCollection &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type MTlsCertificateManagementListMTlsCertificateAssociationsVariables = {
  pathParams: MTlsCertificateManagementListMTlsCertificateAssociationsPathParams;
} & FetcherExtraProps;

/**
 * Lists all active associations between the certificate and Cloudflare services.
 */
export const mTlsCertificateManagementListMTlsCertificateAssociations = (
  variables: MTlsCertificateManagementListMTlsCertificateAssociationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesAssociationResponseCollection,
    MTlsCertificateManagementListMTlsCertificateAssociationsError,
    undefined,
    {},
    {},
    MTlsCertificateManagementListMTlsCertificateAssociationsPathParams
  >({
    url: '/accounts/{accountId}/mtls_certificates/{mtlsCertificateId}/associations',
    method: 'get',
    ...variables,
    signal
  });

export type PagesProjectGetProjectsPathParams = {
  accountId: Schemas.PagesIdentifier;
};

export type PagesProjectGetProjectsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PagesProjectsResponse & Schemas.PagesApiResponseCommonFailure;
}>;

export type PagesProjectGetProjectsVariables = {
  pathParams: PagesProjectGetProjectsPathParams;
} & FetcherExtraProps;

/**
 * Fetch a list of all user projects.
 */
export const pagesProjectGetProjects = (variables: PagesProjectGetProjectsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.PagesProjectsResponse,
    PagesProjectGetProjectsError,
    undefined,
    {},
    {},
    PagesProjectGetProjectsPathParams
  >({ url: '/accounts/{accountId}/pages/projects', method: 'get', ...variables, signal });

export type PagesProjectCreateProjectPathParams = {
  accountId: Schemas.PagesIdentifier;
};

export type PagesProjectCreateProjectError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PagesProjectResponse & Schemas.PagesApiResponseCommonFailure;
}>;

export type PagesProjectCreateProjectVariables = {
  body?: Schemas.PagesProjectObject;
  pathParams: PagesProjectCreateProjectPathParams;
} & FetcherExtraProps;

/**
 * Create a new project.
 */
export const pagesProjectCreateProject = (variables: PagesProjectCreateProjectVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.PagesProjectResponse,
    PagesProjectCreateProjectError,
    Schemas.PagesProjectObject,
    {},
    {},
    PagesProjectCreateProjectPathParams
  >({ url: '/accounts/{accountId}/pages/projects', method: 'post', ...variables, signal });

export type PagesProjectDeleteProjectPathParams = {
  projectName: Schemas.PagesProjectName;
  accountId: Schemas.PagesIdentifier;
};

export type PagesProjectDeleteProjectError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: void & Schemas.PagesApiResponseCommonFailure;
}>;

export type PagesProjectDeleteProjectResponse = Schemas.PagesApiResponseCommon & {
  result?: Record<string, any> | null;
};

export type PagesProjectDeleteProjectVariables = {
  pathParams: PagesProjectDeleteProjectPathParams;
} & FetcherExtraProps;

/**
 * Delete a project by name.
 */
export const pagesProjectDeleteProject = (variables: PagesProjectDeleteProjectVariables, signal?: AbortSignal) =>
  fetch<
    PagesProjectDeleteProjectResponse,
    PagesProjectDeleteProjectError,
    undefined,
    {},
    {},
    PagesProjectDeleteProjectPathParams
  >({ url: '/accounts/{accountId}/pages/projects/{projectName}', method: 'delete', ...variables, signal });

export type PagesProjectGetProjectPathParams = {
  projectName: Schemas.PagesProjectName;
  accountId: Schemas.PagesIdentifier;
};

export type PagesProjectGetProjectError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PagesProjectResponse & Schemas.PagesApiResponseCommonFailure;
}>;

export type PagesProjectGetProjectVariables = {
  pathParams: PagesProjectGetProjectPathParams;
} & FetcherExtraProps;

/**
 * Fetch a project by name.
 */
export const pagesProjectGetProject = (variables: PagesProjectGetProjectVariables, signal?: AbortSignal) =>
  fetch<Schemas.PagesProjectResponse, PagesProjectGetProjectError, undefined, {}, {}, PagesProjectGetProjectPathParams>(
    { url: '/accounts/{accountId}/pages/projects/{projectName}', method: 'get', ...variables, signal }
  );

export type PagesProjectUpdateProjectPathParams = {
  projectName: Schemas.PagesProjectName;
  accountId: Schemas.PagesIdentifier;
};

export type PagesProjectUpdateProjectError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PagesProjectResponse & Schemas.PagesApiResponseCommonFailure;
}>;

export type PagesProjectUpdateProjectVariables = {
  body?: Schemas.PagesProjectPatch;
  pathParams: PagesProjectUpdateProjectPathParams;
} & FetcherExtraProps;

/**
 * Set new attributes for an existing project. Modify environment variables. To delete an environment variable, set the key to null.
 */
export const pagesProjectUpdateProject = (variables: PagesProjectUpdateProjectVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.PagesProjectResponse,
    PagesProjectUpdateProjectError,
    Schemas.PagesProjectPatch,
    {},
    {},
    PagesProjectUpdateProjectPathParams
  >({ url: '/accounts/{accountId}/pages/projects/{projectName}', method: 'patch', ...variables, signal });

export type PagesDeploymentGetDeploymentsPathParams = {
  projectName: Schemas.PagesProjectName;
  accountId: Schemas.PagesIdentifier;
};

export type PagesDeploymentGetDeploymentsQueryParams = {
  /**
   * @example preview
   */
  env?: 'production' | 'preview';
};

export type PagesDeploymentGetDeploymentsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PagesDeploymentListResponse & Schemas.PagesApiResponseCommonFailure;
}>;

export type PagesDeploymentGetDeploymentsVariables = {
  pathParams: PagesDeploymentGetDeploymentsPathParams;
  queryParams?: PagesDeploymentGetDeploymentsQueryParams;
} & FetcherExtraProps;

/**
 * Fetch a list of project deployments.
 */
export const pagesDeploymentGetDeployments = (
  variables: PagesDeploymentGetDeploymentsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.PagesDeploymentListResponse,
    PagesDeploymentGetDeploymentsError,
    undefined,
    {},
    PagesDeploymentGetDeploymentsQueryParams,
    PagesDeploymentGetDeploymentsPathParams
  >({ url: '/accounts/{accountId}/pages/projects/{projectName}/deployments', method: 'get', ...variables, signal });

export type PagesDeploymentCreateDeploymentPathParams = {
  projectName: Schemas.PagesProjectName;
  accountId: Schemas.PagesIdentifier;
};

export type PagesDeploymentCreateDeploymentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PagesDeploymentNewDeployment & Schemas.PagesApiResponseCommonFailure;
}>;

export type PagesDeploymentCreateDeploymentRequestBody = {
  /**
   * The branch to build the new deployment from. The `HEAD` of the branch will be used. If omitted, the production branch will be used by default.
   *
   * @example staging
   */
  branch?: string;
};

export type PagesDeploymentCreateDeploymentVariables = {
  body?: PagesDeploymentCreateDeploymentRequestBody;
  pathParams: PagesDeploymentCreateDeploymentPathParams;
} & FetcherExtraProps;

/**
 * Start a new deployment from production. The repository and account must have already been authorized on the Cloudflare Pages dashboard.
 */
export const pagesDeploymentCreateDeployment = (
  variables: PagesDeploymentCreateDeploymentVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.PagesDeploymentNewDeployment,
    PagesDeploymentCreateDeploymentError,
    PagesDeploymentCreateDeploymentRequestBody,
    {},
    {},
    PagesDeploymentCreateDeploymentPathParams
  >({ url: '/accounts/{accountId}/pages/projects/{projectName}/deployments', method: 'post', ...variables, signal });

export type PagesDeploymentDeleteDeploymentPathParams = {
  deploymentId: Schemas.PagesIdentifier;
  projectName: Schemas.PagesProjectName;
  accountId: Schemas.PagesIdentifier;
};

export type PagesDeploymentDeleteDeploymentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: void & Schemas.PagesApiResponseCommonFailure;
}>;

export type PagesDeploymentDeleteDeploymentResponse = Schemas.PagesApiResponseCommon & {
  result?: Record<string, any> | null;
};

export type PagesDeploymentDeleteDeploymentVariables = {
  pathParams: PagesDeploymentDeleteDeploymentPathParams;
} & FetcherExtraProps;

/**
 * Delete a deployment.
 */
export const pagesDeploymentDeleteDeployment = (
  variables: PagesDeploymentDeleteDeploymentVariables,
  signal?: AbortSignal
) =>
  fetch<
    PagesDeploymentDeleteDeploymentResponse,
    PagesDeploymentDeleteDeploymentError,
    undefined,
    {},
    {},
    PagesDeploymentDeleteDeploymentPathParams
  >({
    url: '/accounts/{accountId}/pages/projects/{projectName}/deployments/{deploymentId}',
    method: 'delete',
    ...variables,
    signal
  });

export type PagesDeploymentGetDeploymentInfoPathParams = {
  deploymentId: Schemas.PagesIdentifier;
  projectName: Schemas.PagesProjectName;
  accountId: Schemas.PagesIdentifier;
};

export type PagesDeploymentGetDeploymentInfoError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PagesDeploymentResponseDetails & Schemas.PagesApiResponseCommonFailure;
}>;

export type PagesDeploymentGetDeploymentInfoVariables = {
  pathParams: PagesDeploymentGetDeploymentInfoPathParams;
} & FetcherExtraProps;

/**
 * Fetch information about a deployment.
 */
export const pagesDeploymentGetDeploymentInfo = (
  variables: PagesDeploymentGetDeploymentInfoVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.PagesDeploymentResponseDetails,
    PagesDeploymentGetDeploymentInfoError,
    undefined,
    {},
    {},
    PagesDeploymentGetDeploymentInfoPathParams
  >({
    url: '/accounts/{accountId}/pages/projects/{projectName}/deployments/{deploymentId}',
    method: 'get',
    ...variables,
    signal
  });

export type PagesDeploymentGetDeploymentLogsPathParams = {
  deploymentId: Schemas.PagesIdentifier;
  projectName: Schemas.PagesProjectName;
  accountId: Schemas.PagesIdentifier;
};

export type PagesDeploymentGetDeploymentLogsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PagesDeploymentResponseLogs & Schemas.PagesApiResponseCommonFailure;
}>;

export type PagesDeploymentGetDeploymentLogsVariables = {
  pathParams: PagesDeploymentGetDeploymentLogsPathParams;
} & FetcherExtraProps;

/**
 * Fetch deployment logs for a project.
 */
export const pagesDeploymentGetDeploymentLogs = (
  variables: PagesDeploymentGetDeploymentLogsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.PagesDeploymentResponseLogs,
    PagesDeploymentGetDeploymentLogsError,
    undefined,
    {},
    {},
    PagesDeploymentGetDeploymentLogsPathParams
  >({
    url: '/accounts/{accountId}/pages/projects/{projectName}/deployments/{deploymentId}/history/logs',
    method: 'get',
    ...variables,
    signal
  });

export type PagesDeploymentRetryDeploymentPathParams = {
  deploymentId: Schemas.PagesIdentifier;
  projectName: Schemas.PagesProjectName;
  accountId: Schemas.PagesIdentifier;
};

export type PagesDeploymentRetryDeploymentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PagesDeploymentNewDeployment & Schemas.PagesApiResponseCommonFailure;
}>;

export type PagesDeploymentRetryDeploymentVariables = {
  pathParams: PagesDeploymentRetryDeploymentPathParams;
} & FetcherExtraProps;

/**
 * Retry a previous deployment.
 */
export const pagesDeploymentRetryDeployment = (
  variables: PagesDeploymentRetryDeploymentVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.PagesDeploymentNewDeployment,
    PagesDeploymentRetryDeploymentError,
    undefined,
    {},
    {},
    PagesDeploymentRetryDeploymentPathParams
  >({
    url: '/accounts/{accountId}/pages/projects/{projectName}/deployments/{deploymentId}/retry',
    method: 'post',
    ...variables,
    signal
  });

export type PagesDeploymentRollbackDeploymentPathParams = {
  deploymentId: Schemas.PagesIdentifier;
  projectName: Schemas.PagesProjectName;
  accountId: Schemas.PagesIdentifier;
};

export type PagesDeploymentRollbackDeploymentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PagesDeploymentResponseDetails & Schemas.PagesApiResponseCommonFailure;
}>;

export type PagesDeploymentRollbackDeploymentVariables = {
  pathParams: PagesDeploymentRollbackDeploymentPathParams;
} & FetcherExtraProps;

/**
 * Rollback the production deployment to a previous deployment. You can only rollback to succesful builds on production.
 */
export const pagesDeploymentRollbackDeployment = (
  variables: PagesDeploymentRollbackDeploymentVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.PagesDeploymentResponseDetails,
    PagesDeploymentRollbackDeploymentError,
    undefined,
    {},
    {},
    PagesDeploymentRollbackDeploymentPathParams
  >({
    url: '/accounts/{accountId}/pages/projects/{projectName}/deployments/{deploymentId}/rollback',
    method: 'post',
    ...variables,
    signal
  });

export type PagesDomainsGetDomainsPathParams = {
  projectName: Schemas.PagesProjectName;
  accountId: Schemas.PagesIdentifier;
};

export type PagesDomainsGetDomainsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PagesDomainResponseCollection & Schemas.PagesApiResponseCommonFailure;
}>;

export type PagesDomainsGetDomainsVariables = {
  pathParams: PagesDomainsGetDomainsPathParams;
} & FetcherExtraProps;

/**
 * Fetch a list of all domains associated with a Pages project.
 */
export const pagesDomainsGetDomains = (variables: PagesDomainsGetDomainsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.PagesDomainResponseCollection,
    PagesDomainsGetDomainsError,
    undefined,
    {},
    {},
    PagesDomainsGetDomainsPathParams
  >({ url: '/accounts/{accountId}/pages/projects/{projectName}/domains', method: 'get', ...variables, signal });

export type PagesDomainsAddDomainPathParams = {
  projectName: Schemas.PagesProjectName;
  accountId: Schemas.PagesIdentifier;
};

export type PagesDomainsAddDomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PagesDomainResponseSingle & Schemas.PagesApiResponseCommonFailure;
}>;

export type PagesDomainsAddDomainVariables = {
  body?: Schemas.PagesDomainsPost;
  pathParams: PagesDomainsAddDomainPathParams;
} & FetcherExtraProps;

/**
 * Add a new domain for the Pages project.
 */
export const pagesDomainsAddDomain = (variables: PagesDomainsAddDomainVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.PagesDomainResponseSingle,
    PagesDomainsAddDomainError,
    Schemas.PagesDomainsPost,
    {},
    {},
    PagesDomainsAddDomainPathParams
  >({ url: '/accounts/{accountId}/pages/projects/{projectName}/domains', method: 'post', ...variables, signal });

export type PagesDomainsDeleteDomainPathParams = {
  domainName: Schemas.PagesDomainName;
  projectName: Schemas.PagesProjectName;
  accountId: Schemas.PagesIdentifier;
};

export type PagesDomainsDeleteDomainError = Fetcher.ErrorWrapper<{
  status: ClientErrorStatus;
  payload: void & Schemas.PagesApiResponseCommonFailure;
}>;

export type PagesDomainsDeleteDomainResponse = Schemas.PagesApiResponseCommon & {
  result?: Record<string, any> | null;
};

export type PagesDomainsDeleteDomainVariables = {
  pathParams: PagesDomainsDeleteDomainPathParams;
} & FetcherExtraProps;

/**
 * Delete a Pages project's domain.
 */
export const pagesDomainsDeleteDomain = (variables: PagesDomainsDeleteDomainVariables, signal?: AbortSignal) =>
  fetch<
    PagesDomainsDeleteDomainResponse,
    PagesDomainsDeleteDomainError,
    undefined,
    {},
    {},
    PagesDomainsDeleteDomainPathParams
  >({
    url: '/accounts/{accountId}/pages/projects/{projectName}/domains/{domainName}',
    method: 'delete',
    ...variables,
    signal
  });

export type PagesDomainsGetDomainPathParams = {
  domainName: Schemas.PagesDomainName;
  projectName: Schemas.PagesProjectName;
  accountId: Schemas.PagesIdentifier;
};

export type PagesDomainsGetDomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PagesDomainResponseSingle & Schemas.PagesApiResponseCommonFailure;
}>;

export type PagesDomainsGetDomainVariables = {
  pathParams: PagesDomainsGetDomainPathParams;
} & FetcherExtraProps;

/**
 * Fetch a single domain.
 */
export const pagesDomainsGetDomain = (variables: PagesDomainsGetDomainVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.PagesDomainResponseSingle,
    PagesDomainsGetDomainError,
    undefined,
    {},
    {},
    PagesDomainsGetDomainPathParams
  >({
    url: '/accounts/{accountId}/pages/projects/{projectName}/domains/{domainName}',
    method: 'get',
    ...variables,
    signal
  });

export type PagesDomainsPatchDomainPathParams = {
  domainName: Schemas.PagesDomainName;
  projectName: Schemas.PagesProjectName;
  accountId: Schemas.PagesIdentifier;
};

export type PagesDomainsPatchDomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PagesDomainResponseSingle & Schemas.PagesApiResponseCommonFailure;
}>;

export type PagesDomainsPatchDomainVariables = {
  pathParams: PagesDomainsPatchDomainPathParams;
} & FetcherExtraProps;

/**
 * Retry the validation status of a single domain.
 */
export const pagesDomainsPatchDomain = (variables: PagesDomainsPatchDomainVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.PagesDomainResponseSingle,
    PagesDomainsPatchDomainError,
    undefined,
    {},
    {},
    PagesDomainsPatchDomainPathParams
  >({
    url: '/accounts/{accountId}/pages/projects/{projectName}/domains/{domainName}',
    method: 'patch',
    ...variables,
    signal
  });

export type PagesPurgeBuildCachePathParams = {
  projectName: Schemas.PagesProjectName;
  accountId: Schemas.PagesIdentifier;
};

export type PagesPurgeBuildCacheError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PagesApiResponseCommonFailure;
}>;

export type PagesPurgeBuildCacheResponse = Schemas.PagesApiResponseCommon & {
  result?: Record<string, any> | null;
};

export type PagesPurgeBuildCacheVariables = {
  pathParams: PagesPurgeBuildCachePathParams;
} & FetcherExtraProps;

/**
 * Purge all cached build artifacts for a Pages project
 */
export const pagesPurgeBuildCache = (variables: PagesPurgeBuildCacheVariables, signal?: AbortSignal) =>
  fetch<PagesPurgeBuildCacheResponse, PagesPurgeBuildCacheError, undefined, {}, {}, PagesPurgeBuildCachePathParams>({
    url: '/accounts/{accountId}/pages/projects/{projectName}/purge_build_cache',
    method: 'post',
    ...variables,
    signal
  });

export type MagicPcapCollectionListPacketCaptureRequestsPathParams = {
  accountId: Schemas.MagicVisibilityPcapsIdentifier;
};

export type MagicPcapCollectionListPacketCaptureRequestsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.MagicVisibilityPcapsPcapsCollectionResponse | Schemas.MagicVisibilityPcapsApiResponseCommonFailure;
}>;

export type MagicPcapCollectionListPacketCaptureRequestsVariables = {
  pathParams: MagicPcapCollectionListPacketCaptureRequestsPathParams;
} & FetcherExtraProps;

/**
 * Lists all packet capture requests for an account.
 */
export const magicPcapCollectionListPacketCaptureRequests = (
  variables: MagicPcapCollectionListPacketCaptureRequestsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityPcapsPcapsCollectionResponse,
    MagicPcapCollectionListPacketCaptureRequestsError,
    undefined,
    {},
    {},
    MagicPcapCollectionListPacketCaptureRequestsPathParams
  >({ url: '/accounts/{accountId}/pcaps', method: 'get', ...variables, signal });

export type MagicPcapCollectionCreatePcapRequestPathParams = {
  accountId: Schemas.MagicVisibilityPcapsIdentifier;
};

export type MagicPcapCollectionCreatePcapRequestError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.MagicVisibilityPcapsPcapsSingleResponse | Schemas.MagicVisibilityPcapsApiResponseCommonFailure;
}>;

export type MagicPcapCollectionCreatePcapRequestVariables = {
  body?: Schemas.MagicVisibilityPcapsPcapsRequestPcap;
  pathParams: MagicPcapCollectionCreatePcapRequestPathParams;
} & FetcherExtraProps;

/**
 * Create new PCAP request for account.
 */
export const magicPcapCollectionCreatePcapRequest = (
  variables: MagicPcapCollectionCreatePcapRequestVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityPcapsPcapsSingleResponse,
    MagicPcapCollectionCreatePcapRequestError,
    Schemas.MagicVisibilityPcapsPcapsRequestPcap,
    {},
    {},
    MagicPcapCollectionCreatePcapRequestPathParams
  >({ url: '/accounts/{accountId}/pcaps', method: 'post', ...variables, signal });

export type MagicPcapCollectionListPcaPsBucketOwnershipPathParams = {
  accountId: Schemas.MagicVisibilityPcapsIdentifier;
};

export type MagicPcapCollectionListPcaPsBucketOwnershipError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.MagicVisibilityPcapsPcapsOwnershipCollection | Schemas.MagicVisibilityPcapsApiResponseCommonFailure;
}>;

export type MagicPcapCollectionListPcaPsBucketOwnershipVariables = {
  pathParams: MagicPcapCollectionListPcaPsBucketOwnershipPathParams;
} & FetcherExtraProps;

/**
 * List all buckets configured for use with PCAPs API.
 */
export const magicPcapCollectionListPcaPsBucketOwnership = (
  variables: MagicPcapCollectionListPcaPsBucketOwnershipVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityPcapsPcapsOwnershipCollection,
    MagicPcapCollectionListPcaPsBucketOwnershipError,
    undefined,
    {},
    {},
    MagicPcapCollectionListPcaPsBucketOwnershipPathParams
  >({ url: '/accounts/{accountId}/pcaps/ownership', method: 'get', ...variables, signal });

export type MagicPcapCollectionAddBucketsForFullPacketCapturesPathParams = {
  accountId: Schemas.MagicVisibilityPcapsIdentifier;
};

export type MagicPcapCollectionAddBucketsForFullPacketCapturesError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload:
    | Schemas.MagicVisibilityPcapsPcapsOwnershipSingleResponse
    | Schemas.MagicVisibilityPcapsApiResponseCommonFailure;
}>;

export type MagicPcapCollectionAddBucketsForFullPacketCapturesVariables = {
  body: Schemas.MagicVisibilityPcapsPcapsOwnershipRequest;
  pathParams: MagicPcapCollectionAddBucketsForFullPacketCapturesPathParams;
} & FetcherExtraProps;

/**
 * Adds an AWS or GCP bucket to use with full packet captures.
 */
export const magicPcapCollectionAddBucketsForFullPacketCaptures = (
  variables: MagicPcapCollectionAddBucketsForFullPacketCapturesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityPcapsPcapsOwnershipSingleResponse,
    MagicPcapCollectionAddBucketsForFullPacketCapturesError,
    Schemas.MagicVisibilityPcapsPcapsOwnershipRequest,
    {},
    {},
    MagicPcapCollectionAddBucketsForFullPacketCapturesPathParams
  >({ url: '/accounts/{accountId}/pcaps/ownership', method: 'post', ...variables, signal });

export type MagicPcapCollectionValidateBucketsForFullPacketCapturesPathParams = {
  accountId: Schemas.MagicVisibilityPcapsIdentifier;
};

export type MagicPcapCollectionValidateBucketsForFullPacketCapturesError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload:
    | Schemas.MagicVisibilityPcapsPcapsOwnershipSingleResponse
    | Schemas.MagicVisibilityPcapsApiResponseCommonFailure;
}>;

export type MagicPcapCollectionValidateBucketsForFullPacketCapturesVariables = {
  body: Schemas.MagicVisibilityPcapsPcapsOwnershipValidateRequest;
  pathParams: MagicPcapCollectionValidateBucketsForFullPacketCapturesPathParams;
} & FetcherExtraProps;

/**
 * Validates buckets added to the packet captures API.
 */
export const magicPcapCollectionValidateBucketsForFullPacketCaptures = (
  variables: MagicPcapCollectionValidateBucketsForFullPacketCapturesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityPcapsPcapsOwnershipSingleResponse,
    MagicPcapCollectionValidateBucketsForFullPacketCapturesError,
    Schemas.MagicVisibilityPcapsPcapsOwnershipValidateRequest,
    {},
    {},
    MagicPcapCollectionValidateBucketsForFullPacketCapturesPathParams
  >({ url: '/accounts/{accountId}/pcaps/ownership/validate', method: 'post', ...variables, signal });

export type MagicPcapCollectionDeleteBucketsForFullPacketCapturesPathParams = {
  ownershipId: Schemas.MagicVisibilityPcapsIdentifier;
  accountId: Schemas.MagicVisibilityPcapsIdentifier;
};

export type MagicPcapCollectionDeleteBucketsForFullPacketCapturesError = Fetcher.ErrorWrapper<undefined>;

export type MagicPcapCollectionDeleteBucketsForFullPacketCapturesVariables = {
  pathParams: MagicPcapCollectionDeleteBucketsForFullPacketCapturesPathParams;
} & FetcherExtraProps;

/**
 * Deletes buckets added to the packet captures API.
 */
export const magicPcapCollectionDeleteBucketsForFullPacketCaptures = (
  variables: MagicPcapCollectionDeleteBucketsForFullPacketCapturesVariables,
  signal?: AbortSignal
) =>
  fetch<
    undefined,
    MagicPcapCollectionDeleteBucketsForFullPacketCapturesError,
    undefined,
    {},
    {},
    MagicPcapCollectionDeleteBucketsForFullPacketCapturesPathParams
  >({ url: '/accounts/{accountId}/pcaps/ownership/{ownershipId}', method: 'delete', ...variables, signal });

export type MagicPcapCollectionGetPcapRequestPathParams = {
  pcapId: Schemas.MagicVisibilityPcapsIdentifier;
  accountId: Schemas.MagicVisibilityPcapsIdentifier;
};

export type MagicPcapCollectionGetPcapRequestError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.MagicVisibilityPcapsPcapsSingleResponse | Schemas.MagicVisibilityPcapsApiResponseCommonFailure;
}>;

export type MagicPcapCollectionGetPcapRequestVariables = {
  pathParams: MagicPcapCollectionGetPcapRequestPathParams;
} & FetcherExtraProps;

/**
 * Get information for a PCAP request by id.
 */
export const magicPcapCollectionGetPcapRequest = (
  variables: MagicPcapCollectionGetPcapRequestVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.MagicVisibilityPcapsPcapsSingleResponse,
    MagicPcapCollectionGetPcapRequestError,
    undefined,
    {},
    {},
    MagicPcapCollectionGetPcapRequestPathParams
  >({ url: '/accounts/{accountId}/pcaps/{pcapId}', method: 'get', ...variables, signal });

export type MagicPcapCollectionDownloadSimplePcapPathParams = {
  pcapId: Schemas.MagicVisibilityPcapsIdentifier;
  accountId: Schemas.MagicVisibilityPcapsIdentifier;
};

export type MagicPcapCollectionDownloadSimplePcapError = Fetcher.ErrorWrapper<undefined>;

export type MagicPcapCollectionDownloadSimplePcapVariables = {
  pathParams: MagicPcapCollectionDownloadSimplePcapPathParams;
} & FetcherExtraProps;

/**
 * Download PCAP information into a file. Response is a binary PCAP file.
 */
export const magicPcapCollectionDownloadSimplePcap = (
  variables: MagicPcapCollectionDownloadSimplePcapVariables,
  signal?: AbortSignal
) =>
  fetch<
    undefined,
    MagicPcapCollectionDownloadSimplePcapError,
    undefined,
    {},
    {},
    MagicPcapCollectionDownloadSimplePcapPathParams
  >({ url: '/accounts/{accountId}/pcaps/{pcapId}/download', method: 'get', ...variables, signal });

export type QueuesListPathParams = {
  accountId: Schemas.MqIdentifier;
};

export type QueuesListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MqApiV4Failure;
}>;

export type QueuesListResponse = Schemas.MqApiV4Success & {
  result?: Schemas.MqQueue[];
  result_info?: {
    /**
     * Total number of queues
     *
     * @example 1
     */
    count?: number;
    /**
     * Current page within paginated list of queues
     *
     * @example 1
     */
    page?: number;
    /**
     * Number of queues per page
     *
     * @example 20
     */
    per_page?: number;
    /**
     * Total queues available without any search parameters
     *
     * @example 2000
     */
    total_count?: number;
    /**
     * Total pages available without any search parameters
     *
     * @example 100
     */
    total_pages?: number;
  };
};

export type QueuesListVariables = {
  pathParams: QueuesListPathParams;
} & FetcherExtraProps;

/**
 * Returns the queues owned by an account.
 */
export const queuesList = (variables: QueuesListVariables, signal?: AbortSignal) =>
  fetch<QueuesListResponse, QueuesListError, undefined, {}, {}, QueuesListPathParams>({
    url: '/accounts/{accountId}/queues',
    method: 'get',
    ...variables,
    signal
  });

export type QueuesCreatePathParams = {
  accountId: Schemas.MqIdentifier;
};

export type QueuesCreateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MqApiV4Failure;
}>;

export type QueuesCreateResponse = Schemas.MqApiV4Success & {
  result?: Schemas.MqQueue;
};

export type QueuesCreateRequestBody = {
  queue_name: Schemas.MqQueueName;
};

export type QueuesCreateVariables = {
  body: QueuesCreateRequestBody;
  pathParams: QueuesCreatePathParams;
} & FetcherExtraProps;

/**
 * Create a new queue
 */
export const queuesCreate = (variables: QueuesCreateVariables, signal?: AbortSignal) =>
  fetch<QueuesCreateResponse, QueuesCreateError, QueuesCreateRequestBody, {}, {}, QueuesCreatePathParams>({
    url: '/accounts/{accountId}/queues',
    method: 'post',
    ...variables,
    signal
  });

export type QueuesDeletePathParams = {
  queueId: Schemas.MqIdentifier;
  accountId: Schemas.MqIdentifier;
};

export type QueuesDeleteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MqApiV4Failure;
}>;

export type QueuesDeleteVariables = {
  pathParams: QueuesDeletePathParams;
} & FetcherExtraProps;

/**
 * Deletes a queue
 */
export const queuesDelete = (variables: QueuesDeleteVariables, signal?: AbortSignal) =>
  fetch<Schemas.MqApiV4Success, QueuesDeleteError, undefined, {}, {}, QueuesDeletePathParams>({
    url: '/accounts/{accountId}/queues/{queueId}',
    method: 'delete',
    ...variables,
    signal
  });

export type QueuesGetPathParams = {
  queueId: Schemas.MqIdentifier;
  accountId: Schemas.MqIdentifier;
};

export type QueuesGetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MqApiV4Failure;
}>;

export type QueuesGetResponse = Schemas.MqApiV4Success & {
  result?: Schemas.MqQueue;
};

export type QueuesGetVariables = {
  pathParams: QueuesGetPathParams;
} & FetcherExtraProps;

/**
 * Get details about a specific queue.
 */
export const queuesGet = (variables: QueuesGetVariables, signal?: AbortSignal) =>
  fetch<QueuesGetResponse, QueuesGetError, undefined, {}, {}, QueuesGetPathParams>({
    url: '/accounts/{accountId}/queues/{queueId}',
    method: 'get',
    ...variables,
    signal
  });

export type QueuesUpdatePathParams = {
  queueId: Schemas.MqIdentifier;
  accountId: Schemas.MqIdentifier;
};

export type QueuesUpdateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MqApiV4Failure;
}>;

export type QueuesUpdateResponse = Schemas.MqApiV4Success & {
  result?: Schemas.MqQueue;
};

export type QueuesUpdateVariables = {
  body?: Schemas.MqQueue;
  pathParams: QueuesUpdatePathParams;
} & FetcherExtraProps;

/**
 * Updates a Queue. Note that this endpoint does not support partial updates. If successful, the Queue's configuration is overwritten with the supplied configuration.
 */
export const queuesUpdate = (variables: QueuesUpdateVariables, signal?: AbortSignal) =>
  fetch<QueuesUpdateResponse, QueuesUpdateError, Schemas.MqQueue, {}, {}, QueuesUpdatePathParams>({
    url: '/accounts/{accountId}/queues/{queueId}',
    method: 'put',
    ...variables,
    signal
  });

export type QueuesListConsumersPathParams = {
  queueId: Schemas.MqIdentifier;
  accountId: Schemas.MqIdentifier;
};

export type QueuesListConsumersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MqApiV4Failure;
}>;

export type QueuesListConsumersResponse = Schemas.MqApiV4Success & {
  result?: Schemas.MqConsumer[];
};

export type QueuesListConsumersVariables = {
  pathParams: QueuesListConsumersPathParams;
} & FetcherExtraProps;

/**
 * Returns the consumers for a Queue
 */
export const queuesListConsumers = (variables: QueuesListConsumersVariables, signal?: AbortSignal) =>
  fetch<QueuesListConsumersResponse, QueuesListConsumersError, undefined, {}, {}, QueuesListConsumersPathParams>({
    url: '/accounts/{accountId}/queues/{queueId}/consumers',
    method: 'get',
    ...variables,
    signal
  });

export type QueuesCreateConsumerPathParams = {
  queueId: Schemas.MqIdentifier;
  accountId: Schemas.MqIdentifier;
};

export type QueuesCreateConsumerError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MqApiV4Failure;
}>;

export type QueuesCreateConsumerResponse = Schemas.MqApiV4Success & {
  result?: Schemas.MqConsumer;
};

export type QueuesCreateConsumerRequestBody = Schemas.MqConsumer & {
  dead_letter_queue?: Schemas.MqQueueName;
};

export type QueuesCreateConsumerVariables = {
  body?: QueuesCreateConsumerRequestBody;
  pathParams: QueuesCreateConsumerPathParams;
} & FetcherExtraProps;

/**
 * Creates a new consumer for a Queue
 */
export const queuesCreateConsumer = (variables: QueuesCreateConsumerVariables, signal?: AbortSignal) =>
  fetch<
    QueuesCreateConsumerResponse,
    QueuesCreateConsumerError,
    QueuesCreateConsumerRequestBody,
    {},
    {},
    QueuesCreateConsumerPathParams
  >({ url: '/accounts/{accountId}/queues/{queueId}/consumers', method: 'post', ...variables, signal });

export type QueuesDeleteConsumerPathParams = {
  consumerId: Schemas.MqIdentifier;
  queueId: Schemas.MqIdentifier;
  accountId: Schemas.MqIdentifier;
};

export type QueuesDeleteConsumerError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MqApiV4Failure;
}>;

export type QueuesDeleteConsumerVariables = {
  pathParams: QueuesDeleteConsumerPathParams;
} & FetcherExtraProps;

/**
 * Deletes the consumer for a queue.
 */
export const queuesDeleteConsumer = (variables: QueuesDeleteConsumerVariables, signal?: AbortSignal) =>
  fetch<Schemas.MqApiV4Success, QueuesDeleteConsumerError, undefined, {}, {}, QueuesDeleteConsumerPathParams>({
    url: '/accounts/{accountId}/queues/{queueId}/consumers/{consumerId}',
    method: 'delete',
    ...variables,
    signal
  });

export type QueuesUpdateConsumerPathParams = {
  consumerId: Schemas.MqIdentifier;
  queueId: Schemas.MqIdentifier;
  accountId: Schemas.MqIdentifier;
};

export type QueuesUpdateConsumerError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MqApiV4Failure;
}>;

export type QueuesUpdateConsumerResponse = Schemas.MqApiV4Success & {
  result?: Schemas.MqConsumer;
};

export type QueuesUpdateConsumerRequestBody = Schemas.MqConsumer & {
  dead_letter_queue?: Schemas.MqQueueName;
};

export type QueuesUpdateConsumerVariables = {
  body?: QueuesUpdateConsumerRequestBody;
  pathParams: QueuesUpdateConsumerPathParams;
} & FetcherExtraProps;

/**
 * Updates the consumer for a queue, or creates one if it does not exist.
 */
export const queuesUpdateConsumer = (variables: QueuesUpdateConsumerVariables, signal?: AbortSignal) =>
  fetch<
    QueuesUpdateConsumerResponse,
    QueuesUpdateConsumerError,
    QueuesUpdateConsumerRequestBody,
    {},
    {},
    QueuesUpdateConsumerPathParams
  >({ url: '/accounts/{accountId}/queues/{queueId}/consumers/{consumerId}', method: 'put', ...variables, signal });

export type QueuesAckMessagesPathParams = {
  queueId: Schemas.MqIdentifier;
  accountId: Schemas.MqIdentifier;
};

export type QueuesAckMessagesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MqApiV4Failure;
}>;

export type QueuesAckMessagesResponse = Schemas.MqApiV4Success & {
  result?: {
    /**
     * The number of messages that were succesfully acknowledged.
     *
     * @example 5
     */
    ackCount?: number;
    /**
     * The number of messages that were succesfully retried.
     *
     * @example 5
     */
    retryCount?: number;
    warnings?: string[];
  };
};

export type QueuesAckMessagesRequestBody = {
  acks?: {
    lease_id?: Schemas.MqLeaseId;
  }[];
  retries?: {
    delay_seconds?: Schemas.MqRetryDelay;
    lease_id?: Schemas.MqLeaseId;
  }[];
};

export type QueuesAckMessagesVariables = {
  body?: QueuesAckMessagesRequestBody;
  pathParams: QueuesAckMessagesPathParams;
} & FetcherExtraProps;

/**
 * Acknowledge + Retry messages from a Queue
 */
export const queuesAckMessages = (variables: QueuesAckMessagesVariables, signal?: AbortSignal) =>
  fetch<
    QueuesAckMessagesResponse,
    QueuesAckMessagesError,
    QueuesAckMessagesRequestBody,
    {},
    {},
    QueuesAckMessagesPathParams
  >({ url: '/accounts/{accountId}/queues/{queueId}/messages/ack', method: 'post', ...variables, signal });

export type QueuesPullMessagesPathParams = {
  queueId: Schemas.MqIdentifier;
  accountId: Schemas.MqIdentifier;
};

export type QueuesPullMessagesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.MqApiV4Failure;
}>;

export type QueuesPullMessagesResponse = Schemas.MqApiV4Success & {
  result?: Schemas.MqQueueBatch;
};

export type QueuesPullMessagesRequestBody = {
  batch_size?: Schemas.MqBatchSize;
  visibility_timeout_ms?: Schemas.MqVisibilityTimeout;
};

export type QueuesPullMessagesVariables = {
  body?: QueuesPullMessagesRequestBody;
  pathParams: QueuesPullMessagesPathParams;
} & FetcherExtraProps;

/**
 * Pull a batch of messages from a Queue
 */
export const queuesPullMessages = (variables: QueuesPullMessagesVariables, signal?: AbortSignal) =>
  fetch<
    QueuesPullMessagesResponse,
    QueuesPullMessagesError,
    QueuesPullMessagesRequestBody,
    {},
    {},
    QueuesPullMessagesPathParams
  >({ url: '/accounts/{accountId}/queues/{queueId}/messages/pull', method: 'post', ...variables, signal });

export type R2ListBucketsPathParams = {
  accountId: Schemas.R2AccountIdentifier;
};

export type R2ListBucketsQueryParams = {
  /**
   * @example my-bucket
   */
  name_contains?: string;
  /**
   * @example my-bucket
   */
  start_after?: string;
  /**
   * @default 20
   * @maximum 1000
   * @minimum 1
   */
  per_page?: number;
  order?: 'name';
  /**
   * @example desc
   */
  direction?: 'asc' | 'desc';
  cursor?: string;
};

export type R2ListBucketsHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2ListBucketsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2ListBucketsResponse = Schemas.R2V4ResponseList & {
  result?: {
    buckets?: Schemas.R2Bucket[];
  };
};

export type R2ListBucketsVariables = {
  headers?: R2ListBucketsHeaders;
  pathParams: R2ListBucketsPathParams;
  queryParams?: R2ListBucketsQueryParams;
} & FetcherExtraProps;

/**
 * Lists all R2 buckets on your account
 */
export const r2ListBuckets = (variables: R2ListBucketsVariables, signal?: AbortSignal) =>
  fetch<
    R2ListBucketsResponse,
    R2ListBucketsError,
    undefined,
    R2ListBucketsHeaders,
    R2ListBucketsQueryParams,
    R2ListBucketsPathParams
  >({ url: '/accounts/{accountId}/r2/buckets', method: 'get', ...variables, signal });

export type R2CreateBucketPathParams = {
  accountId: Schemas.R2AccountIdentifier;
};

export type R2CreateBucketHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2CreateBucketError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2CreateBucketResponse = {
  errors: Schemas.R2Errors;
  messages: Schemas.R2Messages;
  result: Schemas.R2Bucket;
  /**
   * Whether the API call was successful
   */
  success: true;
};

export type R2CreateBucketRequestBody = {
  locationHint?: Schemas.R2BucketLocation;
  name: Schemas.R2BucketName;
  storageClass?: Schemas.R2StorageClass;
};

export type R2CreateBucketVariables = {
  body: R2CreateBucketRequestBody;
  headers?: R2CreateBucketHeaders;
  pathParams: R2CreateBucketPathParams;
} & FetcherExtraProps;

/**
 * Creates a new R2 bucket.
 */
export const r2CreateBucket = (variables: R2CreateBucketVariables, signal?: AbortSignal) =>
  fetch<
    R2CreateBucketResponse,
    R2CreateBucketError,
    R2CreateBucketRequestBody,
    R2CreateBucketHeaders,
    {},
    R2CreateBucketPathParams
  >({ url: '/accounts/{accountId}/r2/buckets', method: 'post', ...variables, signal });

export type R2DeleteBucketPathParams = {
  bucketName: Schemas.R2BucketName;
  accountId: Schemas.R2AccountIdentifier;
};

export type R2DeleteBucketHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2DeleteBucketError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2DeleteBucketVariables = {
  headers?: R2DeleteBucketHeaders;
  pathParams: R2DeleteBucketPathParams;
} & FetcherExtraProps;

/**
 * Deletes an existing R2 bucket.
 */
export const r2DeleteBucket = (variables: R2DeleteBucketVariables, signal?: AbortSignal) =>
  fetch<Schemas.R2V4Response, R2DeleteBucketError, undefined, R2DeleteBucketHeaders, {}, R2DeleteBucketPathParams>({
    url: '/accounts/{accountId}/r2/buckets/{bucketName}',
    method: 'delete',
    ...variables,
    signal
  });

export type R2GetBucketPathParams = {
  accountId: Schemas.R2AccountIdentifier;
  bucketName: Schemas.R2BucketName;
};

export type R2GetBucketHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2GetBucketError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2GetBucketResponse = {
  errors: Schemas.R2Errors;
  messages: Schemas.R2Messages;
  result: Schemas.R2Bucket;
  /**
   * Whether the API call was successful
   */
  success: true;
};

export type R2GetBucketVariables = {
  headers?: R2GetBucketHeaders;
  pathParams: R2GetBucketPathParams;
} & FetcherExtraProps;

/**
 * Gets metadata for an existing R2 bucket.
 */
export const r2GetBucket = (variables: R2GetBucketVariables, signal?: AbortSignal) =>
  fetch<R2GetBucketResponse, R2GetBucketError, undefined, R2GetBucketHeaders, {}, R2GetBucketPathParams>({
    url: '/accounts/{accountId}/r2/buckets/{bucketName}',
    method: 'get',
    ...variables,
    signal
  });

export type R2DeleteBucketCorsPolicyPathParams = {
  bucketName: Schemas.R2BucketName;
  accountId: Schemas.R2AccountIdentifier;
};

export type R2DeleteBucketCorsPolicyHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2DeleteBucketCorsPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2DeleteBucketCorsPolicyResponse = Schemas.R2V4Response & Record<string, any>;

export type R2DeleteBucketCorsPolicyVariables = {
  headers?: R2DeleteBucketCorsPolicyHeaders;
  pathParams: R2DeleteBucketCorsPolicyPathParams;
} & FetcherExtraProps;

/**
 * Delete the CORS policy for a bucket
 */
export const r2DeleteBucketCorsPolicy = (variables: R2DeleteBucketCorsPolicyVariables, signal?: AbortSignal) =>
  fetch<
    R2DeleteBucketCorsPolicyResponse,
    R2DeleteBucketCorsPolicyError,
    undefined,
    R2DeleteBucketCorsPolicyHeaders,
    {},
    R2DeleteBucketCorsPolicyPathParams
  >({ url: '/accounts/{accountId}/r2/buckets/{bucketName}/cors', method: 'delete', ...variables, signal });

export type R2GetBucketCorsPolicyPathParams = {
  bucketName: Schemas.R2BucketName;
  accountId: Schemas.R2AccountIdentifier;
};

export type R2GetBucketCorsPolicyHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2GetBucketCorsPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2GetBucketCorsPolicyResponse = {
  errors: Schemas.R2Errors;
  messages: Schemas.R2Messages;
  result: {
    rules?: Schemas.R2CorsRule[];
  };
  /**
   * Whether the API call was successful
   */
  success: true;
};

export type R2GetBucketCorsPolicyVariables = {
  headers?: R2GetBucketCorsPolicyHeaders;
  pathParams: R2GetBucketCorsPolicyPathParams;
} & FetcherExtraProps;

/**
 * Get the CORS policy for a bucket
 */
export const r2GetBucketCorsPolicy = (variables: R2GetBucketCorsPolicyVariables, signal?: AbortSignal) =>
  fetch<
    R2GetBucketCorsPolicyResponse,
    R2GetBucketCorsPolicyError,
    undefined,
    R2GetBucketCorsPolicyHeaders,
    {},
    R2GetBucketCorsPolicyPathParams
  >({ url: '/accounts/{accountId}/r2/buckets/{bucketName}/cors', method: 'get', ...variables, signal });

export type R2PutBucketCorsPolicyPathParams = {
  bucketName: Schemas.R2BucketName;
  accountId: Schemas.R2AccountIdentifier;
};

export type R2PutBucketCorsPolicyHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2PutBucketCorsPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2PutBucketCorsPolicyResponse = Schemas.R2V4Response & Record<string, any>;

export type R2PutBucketCorsPolicyRequestBody = {
  rules?: Schemas.R2CorsRule[];
};

export type R2PutBucketCorsPolicyVariables = {
  body?: R2PutBucketCorsPolicyRequestBody;
  headers?: R2PutBucketCorsPolicyHeaders;
  pathParams: R2PutBucketCorsPolicyPathParams;
} & FetcherExtraProps;

/**
 * Set the CORS policy for a bucket
 */
export const r2PutBucketCorsPolicy = (variables: R2PutBucketCorsPolicyVariables, signal?: AbortSignal) =>
  fetch<
    R2PutBucketCorsPolicyResponse,
    R2PutBucketCorsPolicyError,
    R2PutBucketCorsPolicyRequestBody,
    R2PutBucketCorsPolicyHeaders,
    {},
    R2PutBucketCorsPolicyPathParams
  >({ url: '/accounts/{accountId}/r2/buckets/{bucketName}/cors', method: 'put', ...variables, signal });

export type R2ListCustomDomainsPathParams = {
  accountId: Schemas.R2AccountIdentifier;
  bucketName: Schemas.R2BucketName;
};

export type R2ListCustomDomainsHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2ListCustomDomainsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2ListCustomDomainsResponse = {
  errors: Schemas.R2Errors;
  messages: Schemas.R2Messages;
  result: Schemas.R2ListCustomDomainsResponse;
  /**
   * Whether the API call was successful
   */
  success: true;
};

export type R2ListCustomDomainsVariables = {
  headers?: R2ListCustomDomainsHeaders;
  pathParams: R2ListCustomDomainsPathParams;
} & FetcherExtraProps;

/**
 * Gets a list of all custom domains registered with an existing R2 bucket.
 */
export const r2ListCustomDomains = (variables: R2ListCustomDomainsVariables, signal?: AbortSignal) =>
  fetch<
    R2ListCustomDomainsResponse,
    R2ListCustomDomainsError,
    undefined,
    R2ListCustomDomainsHeaders,
    {},
    R2ListCustomDomainsPathParams
  >({ url: '/accounts/{accountId}/r2/buckets/{bucketName}/domains/custom', method: 'get', ...variables, signal });

export type R2AddCustomDomainPathParams = {
  accountId: Schemas.R2AccountIdentifier;
  bucketName: Schemas.R2BucketName;
};

export type R2AddCustomDomainHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2AddCustomDomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2AddCustomDomainResponse = {
  errors: Schemas.R2Errors;
  messages: Schemas.R2Messages;
  result: Schemas.R2AddCustomDomainResponse;
  /**
   * Whether the API call was successful
   */
  success: true;
};

export type R2AddCustomDomainVariables = {
  body: Schemas.R2AddCustomDomainRequest;
  headers?: R2AddCustomDomainHeaders;
  pathParams: R2AddCustomDomainPathParams;
} & FetcherExtraProps;

/**
 * Register a new custom domain for an existing R2 bucket.
 */
export const r2AddCustomDomain = (variables: R2AddCustomDomainVariables, signal?: AbortSignal) =>
  fetch<
    R2AddCustomDomainResponse,
    R2AddCustomDomainError,
    Schemas.R2AddCustomDomainRequest,
    R2AddCustomDomainHeaders,
    {},
    R2AddCustomDomainPathParams
  >({ url: '/accounts/{accountId}/r2/buckets/{bucketName}/domains/custom', method: 'post', ...variables, signal });

export type R2DeleteCustomDomainPathParams = {
  bucketName: Schemas.R2BucketName;
  accountId: Schemas.R2AccountIdentifier;
  domainName: Schemas.R2DomainName;
};

export type R2DeleteCustomDomainHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2DeleteCustomDomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2DeleteCustomDomainResponse = {
  errors: Schemas.R2Errors;
  messages: Schemas.R2Messages;
  result: Schemas.R2RemoveCustomDomainResponse;
  /**
   * Whether the API call was successful
   */
  success: true;
};

export type R2DeleteCustomDomainVariables = {
  headers?: R2DeleteCustomDomainHeaders;
  pathParams: R2DeleteCustomDomainPathParams;
} & FetcherExtraProps;

/**
 * Remove custom domain registration from an existing R2 bucket
 */
export const r2DeleteCustomDomain = (variables: R2DeleteCustomDomainVariables, signal?: AbortSignal) =>
  fetch<
    R2DeleteCustomDomainResponse,
    R2DeleteCustomDomainError,
    undefined,
    R2DeleteCustomDomainHeaders,
    {},
    R2DeleteCustomDomainPathParams
  >({
    url: '/accounts/{accountId}/r2/buckets/{bucketName}/domains/custom/{domainName}',
    method: 'delete',
    ...variables,
    signal
  });

export type R2GetCustomDomainSettingsPathParams = {
  accountId: Schemas.R2AccountIdentifier;
  bucketName: Schemas.R2BucketName;
  domainName: Schemas.R2DomainName;
};

export type R2GetCustomDomainSettingsHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2GetCustomDomainSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2GetCustomDomainSettingsResponse = {
  errors: Schemas.R2Errors;
  messages: Schemas.R2Messages;
  /**
   * @example {"domain":"prefix.example-domain.one.com","enabled":false,"status":{"ownership":"deactivated","ssl":"pending"},"zoneId":"36ca64a6d92827b8a6b90be344bb1bfd","zoneName":"example-domain.one.com"}
   */
  result: Schemas.R2GetCustomDomainResponse;
  /**
   * Whether the API call was successful
   */
  success: true;
};

export type R2GetCustomDomainSettingsVariables = {
  headers?: R2GetCustomDomainSettingsHeaders;
  pathParams: R2GetCustomDomainSettingsPathParams;
} & FetcherExtraProps;

/**
 * Get the configuration for a custom domain on an existing R2 bucket.
 */
export const r2GetCustomDomainSettings = (variables: R2GetCustomDomainSettingsVariables, signal?: AbortSignal) =>
  fetch<
    R2GetCustomDomainSettingsResponse,
    R2GetCustomDomainSettingsError,
    undefined,
    R2GetCustomDomainSettingsHeaders,
    {},
    R2GetCustomDomainSettingsPathParams
  >({
    url: '/accounts/{accountId}/r2/buckets/{bucketName}/domains/custom/{domainName}',
    method: 'get',
    ...variables,
    signal
  });

export type R2EditCustomDomainSettingsPathParams = {
  accountId: Schemas.R2AccountIdentifier;
  bucketName: Schemas.R2BucketName;
  domainName: Schemas.R2DomainName;
};

export type R2EditCustomDomainSettingsHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2EditCustomDomainSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2EditCustomDomainSettingsResponse = {
  errors: Schemas.R2Errors;
  messages: Schemas.R2Messages;
  /**
   * @example {"domain":"example-domain.com","enabled":true}
   */
  result: Schemas.R2EditCustomDomainResponse;
  /**
   * Whether the API call was successful
   */
  success: true;
};

export type R2EditCustomDomainSettingsVariables = {
  body?: Schemas.R2EditCustomDomainRequest;
  headers?: R2EditCustomDomainSettingsHeaders;
  pathParams: R2EditCustomDomainSettingsPathParams;
} & FetcherExtraProps;

/**
 * Edit the configuration for a custom domain on an existing R2 bucket.
 */
export const r2EditCustomDomainSettings = (variables: R2EditCustomDomainSettingsVariables, signal?: AbortSignal) =>
  fetch<
    R2EditCustomDomainSettingsResponse,
    R2EditCustomDomainSettingsError,
    Schemas.R2EditCustomDomainRequest,
    R2EditCustomDomainSettingsHeaders,
    {},
    R2EditCustomDomainSettingsPathParams
  >({
    url: '/accounts/{accountId}/r2/buckets/{bucketName}/domains/custom/{domainName}',
    method: 'put',
    ...variables,
    signal
  });

export type R2GetBucketPublicPolicyPathParams = {
  accountId: Schemas.R2AccountIdentifier;
  bucketName: Schemas.R2BucketName;
};

export type R2GetBucketPublicPolicyHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2GetBucketPublicPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2GetBucketPublicPolicyResponse = {
  errors: Schemas.R2Errors;
  messages: Schemas.R2Messages;
  result: Schemas.R2ManagedDomainResponse;
  /**
   * Whether the API call was successful
   */
  success: true;
};

export type R2GetBucketPublicPolicyVariables = {
  headers?: R2GetBucketPublicPolicyHeaders;
  pathParams: R2GetBucketPublicPolicyPathParams;
} & FetcherExtraProps;

/**
 * Gets state of public access over the bucket's R2-managed (r2.dev) domain.
 */
export const r2GetBucketPublicPolicy = (variables: R2GetBucketPublicPolicyVariables, signal?: AbortSignal) =>
  fetch<
    R2GetBucketPublicPolicyResponse,
    R2GetBucketPublicPolicyError,
    undefined,
    R2GetBucketPublicPolicyHeaders,
    {},
    R2GetBucketPublicPolicyPathParams
  >({ url: '/accounts/{accountId}/r2/buckets/{bucketName}/domains/managed', method: 'get', ...variables, signal });

export type R2PutBucketPublicPolicyPathParams = {
  accountId: Schemas.R2AccountIdentifier;
  bucketName: Schemas.R2BucketName;
};

export type R2PutBucketPublicPolicyHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2PutBucketPublicPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2PutBucketPublicPolicyResponse = {
  errors: Schemas.R2Errors;
  messages: Schemas.R2Messages;
  result: Schemas.R2ManagedDomainResponse;
  /**
   * Whether the API call was successful
   */
  success: true;
};

export type R2PutBucketPublicPolicyVariables = {
  body: Schemas.R2EditManagedDomainRequest;
  headers?: R2PutBucketPublicPolicyHeaders;
  pathParams: R2PutBucketPublicPolicyPathParams;
} & FetcherExtraProps;

/**
 * Updates state of public access over the bucket's R2-managed (r2.dev) domain.
 */
export const r2PutBucketPublicPolicy = (variables: R2PutBucketPublicPolicyVariables, signal?: AbortSignal) =>
  fetch<
    R2PutBucketPublicPolicyResponse,
    R2PutBucketPublicPolicyError,
    Schemas.R2EditManagedDomainRequest,
    R2PutBucketPublicPolicyHeaders,
    {},
    R2PutBucketPublicPolicyPathParams
  >({ url: '/accounts/{accountId}/r2/buckets/{bucketName}/domains/managed', method: 'put', ...variables, signal });

export type R2GetBucketLifecycleConfigurationPathParams = {
  bucketName: Schemas.R2BucketName;
  accountId: Schemas.R2AccountIdentifier;
};

export type R2GetBucketLifecycleConfigurationHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2GetBucketLifecycleConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2GetBucketLifecycleConfigurationResponse = {
  errors: Schemas.R2Errors;
  messages: Schemas.R2Messages;
  result: Schemas.R2LifecycleConfig;
  /**
   * Whether the API call was successful
   */
  success: true;
};

export type R2GetBucketLifecycleConfigurationVariables = {
  headers?: R2GetBucketLifecycleConfigurationHeaders;
  pathParams: R2GetBucketLifecycleConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Get object lifecycle rules for a bucket
 */
export const r2GetBucketLifecycleConfiguration = (
  variables: R2GetBucketLifecycleConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    R2GetBucketLifecycleConfigurationResponse,
    R2GetBucketLifecycleConfigurationError,
    undefined,
    R2GetBucketLifecycleConfigurationHeaders,
    {},
    R2GetBucketLifecycleConfigurationPathParams
  >({ url: '/accounts/{accountId}/r2/buckets/{bucketName}/lifecycle', method: 'get', ...variables, signal });

export type R2PutBucketLifecycleConfigurationPathParams = {
  bucketName: Schemas.R2BucketName;
  accountId: Schemas.R2AccountIdentifier;
};

export type R2PutBucketLifecycleConfigurationHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2PutBucketLifecycleConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2PutBucketLifecycleConfigurationResponse = Schemas.R2V4Response & Record<string, any>;

export type R2PutBucketLifecycleConfigurationRequestBody = {
  rules?: Schemas.R2LifecycleRule[];
};

export type R2PutBucketLifecycleConfigurationVariables = {
  body?: R2PutBucketLifecycleConfigurationRequestBody;
  headers?: R2PutBucketLifecycleConfigurationHeaders;
  pathParams: R2PutBucketLifecycleConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Set the object lifecycle rules for a bucket
 */
export const r2PutBucketLifecycleConfiguration = (
  variables: R2PutBucketLifecycleConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    R2PutBucketLifecycleConfigurationResponse,
    R2PutBucketLifecycleConfigurationError,
    R2PutBucketLifecycleConfigurationRequestBody,
    R2PutBucketLifecycleConfigurationHeaders,
    {},
    R2PutBucketLifecycleConfigurationPathParams
  >({ url: '/accounts/{accountId}/r2/buckets/{bucketName}/lifecycle', method: 'put', ...variables, signal });

export type R2DeleteBucketSippyConfigPathParams = {
  bucketName: Schemas.R2BucketName;
  accountId: Schemas.R2AccountIdentifier;
};

export type R2DeleteBucketSippyConfigHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2DeleteBucketSippyConfigError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2DeleteBucketSippyConfigResponse = {
  errors: Schemas.R2Errors;
  messages: Schemas.R2Messages;
  result: {
    enabled?: false;
  };
  /**
   * Whether the API call was successful
   */
  success: true;
};

export type R2DeleteBucketSippyConfigVariables = {
  headers?: R2DeleteBucketSippyConfigHeaders;
  pathParams: R2DeleteBucketSippyConfigPathParams;
} & FetcherExtraProps;

/**
 * Disables Sippy on this bucket
 */
export const r2DeleteBucketSippyConfig = (variables: R2DeleteBucketSippyConfigVariables, signal?: AbortSignal) =>
  fetch<
    R2DeleteBucketSippyConfigResponse,
    R2DeleteBucketSippyConfigError,
    undefined,
    R2DeleteBucketSippyConfigHeaders,
    {},
    R2DeleteBucketSippyConfigPathParams
  >({ url: '/accounts/{accountId}/r2/buckets/{bucketName}/sippy', method: 'delete', ...variables, signal });

export type R2GetBucketSippyConfigPathParams = {
  accountId: Schemas.R2AccountIdentifier;
  bucketName: Schemas.R2BucketName;
};

export type R2GetBucketSippyConfigHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2GetBucketSippyConfigError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2GetBucketSippyConfigResponse = {
  errors: Schemas.R2Errors;
  messages: Schemas.R2Messages;
  result: Schemas.R2Sippy;
  /**
   * Whether the API call was successful
   */
  success: true;
};

export type R2GetBucketSippyConfigVariables = {
  headers?: R2GetBucketSippyConfigHeaders;
  pathParams: R2GetBucketSippyConfigPathParams;
} & FetcherExtraProps;

/**
 * Gets configuration for Sippy for an existing R2 bucket.
 */
export const r2GetBucketSippyConfig = (variables: R2GetBucketSippyConfigVariables, signal?: AbortSignal) =>
  fetch<
    R2GetBucketSippyConfigResponse,
    R2GetBucketSippyConfigError,
    undefined,
    R2GetBucketSippyConfigHeaders,
    {},
    R2GetBucketSippyConfigPathParams
  >({ url: '/accounts/{accountId}/r2/buckets/{bucketName}/sippy', method: 'get', ...variables, signal });

export type R2PutBucketSippyConfigPathParams = {
  accountId: Schemas.R2AccountIdentifier;
  bucketName: Schemas.R2BucketName;
};

export type R2PutBucketSippyConfigHeaders = {
  /**
   * @default default
   */
  ['cf-r2-jurisdiction']?: 'default' | 'eu' | 'fedramp';
};

export type R2PutBucketSippyConfigError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2PutBucketSippyConfigResponse = {
  errors: Schemas.R2Errors;
  messages: Schemas.R2Messages;
  result: Schemas.R2Sippy;
  /**
   * Whether the API call was successful
   */
  success: true;
};

export type R2PutBucketSippyConfigVariables = {
  body?: Schemas.R2EnableSippyAws | Schemas.R2EnableSippyGcs;
  headers?: R2PutBucketSippyConfigHeaders;
  pathParams: R2PutBucketSippyConfigPathParams;
} & FetcherExtraProps;

/**
 * Sets configuration for Sippy for an existing R2 bucket.
 */
export const r2PutBucketSippyConfig = (variables: R2PutBucketSippyConfigVariables, signal?: AbortSignal) =>
  fetch<
    R2PutBucketSippyConfigResponse,
    R2PutBucketSippyConfigError,
    Schemas.R2EnableSippyAws | Schemas.R2EnableSippyGcs,
    R2PutBucketSippyConfigHeaders,
    {},
    R2PutBucketSippyConfigPathParams
  >({ url: '/accounts/{accountId}/r2/buckets/{bucketName}/sippy', method: 'put', ...variables, signal });

export type R2CreateTempAccessCredentialsPathParams = {
  accountId: Schemas.R2AccountIdentifier;
};

export type R2CreateTempAccessCredentialsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.R2V4ResponseFailure;
}>;

export type R2CreateTempAccessCredentialsResponse = {
  errors: Schemas.R2Errors;
  messages: Schemas.R2Messages;
  result: Schemas.R2TempAccessCredsResponse;
  /**
   * Whether the API call was successful
   */
  success: true;
};

export type R2CreateTempAccessCredentialsVariables = {
  body: Schemas.R2TempAccessCredsRequest;
  pathParams: R2CreateTempAccessCredentialsPathParams;
} & FetcherExtraProps;

/**
 * Creates temporary access credentials on a bucket that can be optionally scoped to prefixes or objects.
 */
export const r2CreateTempAccessCredentials = (
  variables: R2CreateTempAccessCredentialsVariables,
  signal?: AbortSignal
) =>
  fetch<
    R2CreateTempAccessCredentialsResponse,
    R2CreateTempAccessCredentialsError,
    Schemas.R2TempAccessCredsRequest,
    {},
    {},
    R2CreateTempAccessCredentialsPathParams
  >({ url: '/accounts/{accountId}/r2/temp-access-credentials', method: 'post', ...variables, signal });

export type RegistrarDomainsListDomainsPathParams = {
  accountId: Schemas.RegistrarApiIdentifier;
};

export type RegistrarDomainsListDomainsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.RegistrarApiDomainResponseCollection & Schemas.RegistrarApiApiResponseCommonFailure;
}>;

export type RegistrarDomainsListDomainsVariables = {
  pathParams: RegistrarDomainsListDomainsPathParams;
} & FetcherExtraProps;

/**
 * List domains handled by Registrar.
 */
export const registrarDomainsListDomains = (variables: RegistrarDomainsListDomainsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.RegistrarApiDomainResponseCollection,
    RegistrarDomainsListDomainsError,
    undefined,
    {},
    {},
    RegistrarDomainsListDomainsPathParams
  >({ url: '/accounts/{accountId}/registrar/domains', method: 'get', ...variables, signal });

export type RegistrarDomainsGetDomainPathParams = {
  domainName: Schemas.RegistrarApiDomainName;
  accountId: Schemas.RegistrarApiIdentifier;
};

export type RegistrarDomainsGetDomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.RegistrarApiDomainResponseSingle & Schemas.RegistrarApiApiResponseCommonFailure;
}>;

export type RegistrarDomainsGetDomainVariables = {
  pathParams: RegistrarDomainsGetDomainPathParams;
} & FetcherExtraProps;

/**
 * Show individual domain.
 */
export const registrarDomainsGetDomain = (variables: RegistrarDomainsGetDomainVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.RegistrarApiDomainResponseSingle,
    RegistrarDomainsGetDomainError,
    undefined,
    {},
    {},
    RegistrarDomainsGetDomainPathParams
  >({ url: '/accounts/{accountId}/registrar/domains/{domainName}', method: 'get', ...variables, signal });

export type RegistrarDomainsUpdateDomainPathParams = {
  domainName: Schemas.RegistrarApiDomainName;
  accountId: Schemas.RegistrarApiIdentifier;
};

export type RegistrarDomainsUpdateDomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.RegistrarApiDomainResponseSingle & Schemas.RegistrarApiApiResponseCommonFailure;
}>;

export type RegistrarDomainsUpdateDomainRequestBody = Schemas.RegistrarApiDomainUpdateProperties;

export type RegistrarDomainsUpdateDomainVariables = {
  body?: RegistrarDomainsUpdateDomainRequestBody;
  pathParams: RegistrarDomainsUpdateDomainPathParams;
} & FetcherExtraProps;

/**
 * Update individual domain.
 */
export const registrarDomainsUpdateDomain = (variables: RegistrarDomainsUpdateDomainVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.RegistrarApiDomainResponseSingle,
    RegistrarDomainsUpdateDomainError,
    RegistrarDomainsUpdateDomainRequestBody,
    {},
    {},
    RegistrarDomainsUpdateDomainPathParams
  >({ url: '/accounts/{accountId}/registrar/domains/{domainName}', method: 'put', ...variables, signal });

export type AccountRequestTracerRequestTracePathParams = {
  accountId: Schemas.RequestTracerIdentifier;
};

export type AccountRequestTracerRequestTraceError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.RequestTracerApiResponseCommonFailure;
}>;

export type AccountRequestTracerRequestTraceResponse = Schemas.RequestTracerApiResponseCommon & {
  /**
   * Trace result with an origin status code
   */
  result?: {
    /**
     * HTTP Status code of zone response
     */
    status_code?: number;
    trace?: Schemas.RequestTracerTrace;
  };
};

export type AccountRequestTracerRequestTraceRequestBody = {
  body?: {
    /**
     * Base64 encoded request body
     *
     * @example c29tZV9yZXF1ZXN0X2JvZHk=
     */
    base64?: string;
    /**
     * Arbitrary json as request body
     */
    json?: Record<string, any>;
    /**
     * Request body as plain text
     */
    plain_text?: string;
  };
  /**
   * Additional request parameters
   */
  context?: {
    /**
     * Bot score used for evaluating tracing request processing
     */
    bot_score?: number;
    /**
     * Geodata for tracing request
     */
    geoloc?: {
      /**
       * @example London
       */
      city?: string;
      continent?: string;
      is_eu_country?: boolean;
      iso_code?: string;
      latitude?: number;
      longitude?: number;
      postal_code?: string;
      region_code?: string;
      subdivision_2_iso_code?: string;
      timezone?: string;
    };
    /**
     * Whether to skip any challenges for tracing request (e.g.: captcha)
     *
     * @example true
     */
    skip_challenge?: boolean;
    /**
     * Threat score used for evaluating tracing request processing
     */
    threat_score?: number;
  };
  /**
   * Cookies added to tracing request
   *
   * @example {"cookie_name_1":"cookie_value_1","cookie_name_2":"cookie_value_2"}
   */
  cookies?: {
    [key: string]: string;
  };
  /**
   * Headers added to tracing request
   *
   * @example {"header_name_1":"header_value_1","header_name_2":"header_value_2"}
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * HTTP Method of tracing request
   *
   * @example PUT
   */
  method: string;
  /**
   * HTTP Protocol of tracing request
   *
   * @example HTTP/1.1
   */
  protocol?: string;
  /**
   * Skip sending the request to the Origin server after all rules evaluation
   */
  skip_response?: boolean;
  /**
   * URL to which perform tracing request
   *
   * @example https://some.zone/some_path
   */
  url: string;
};

export type AccountRequestTracerRequestTraceVariables = {
  body: AccountRequestTracerRequestTraceRequestBody;
  pathParams: AccountRequestTracerRequestTracePathParams;
} & FetcherExtraProps;

export const accountRequestTracerRequestTrace = (
  variables: AccountRequestTracerRequestTraceVariables,
  signal?: AbortSignal
) =>
  fetch<
    AccountRequestTracerRequestTraceResponse,
    AccountRequestTracerRequestTraceError,
    AccountRequestTracerRequestTraceRequestBody,
    {},
    {},
    AccountRequestTracerRequestTracePathParams
  >({ url: '/accounts/{accountId}/request-tracer/trace', method: 'post', ...variables, signal });

export type AccountRolesListRolesPathParams = {
  accountId: Schemas.IamAccountIdentifier;
};

export type AccountRolesListRolesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountRolesListRolesVariables = {
  pathParams: AccountRolesListRolesPathParams;
} & FetcherExtraProps;

/**
 * Get all available roles for an account.
 */
export const accountRolesListRoles = (variables: AccountRolesListRolesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamCollectionRoleResponse,
    AccountRolesListRolesError,
    undefined,
    {},
    {},
    AccountRolesListRolesPathParams
  >({ url: '/accounts/{accountId}/roles', method: 'get', ...variables, signal });

export type AccountRolesRoleDetailsPathParams = {
  roleId: Schemas.IamRoleComponentsSchemasIdentifier;
  accountId: Schemas.IamAccountIdentifier;
};

export type AccountRolesRoleDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountRolesRoleDetailsVariables = {
  pathParams: AccountRolesRoleDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get information about a specific role for an account.
 */
export const accountRolesRoleDetails = (variables: AccountRolesRoleDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamSingleRoleResponse,
    AccountRolesRoleDetailsError,
    undefined,
    {},
    {},
    AccountRolesRoleDetailsPathParams
  >({ url: '/accounts/{accountId}/roles/{roleId}', method: 'get', ...variables, signal });

export type ListsGetListsPathParams = {
  accountId: Schemas.ListsIdentifier;
};

export type ListsGetListsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ListsListsResponseCollection & Schemas.ListsApiResponseCommonFailure;
}>;

export type ListsGetListsVariables = {
  pathParams: ListsGetListsPathParams;
} & FetcherExtraProps;

/**
 * Fetches all lists in the account.
 */
export const listsGetLists = (variables: ListsGetListsVariables, signal?: AbortSignal) =>
  fetch<Schemas.ListsListsResponseCollection, ListsGetListsError, undefined, {}, {}, ListsGetListsPathParams>({
    url: '/accounts/{accountId}/rules/lists',
    method: 'get',
    ...variables,
    signal
  });

export type ListsCreateAListPathParams = {
  accountId: Schemas.ListsIdentifier;
};

export type ListsCreateAListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ListsListResponseCollection & Schemas.ListsApiResponseCommonFailure;
}>;

export type ListsCreateAListRequestBody = {
  description?: Schemas.ListsDescription;
  kind: Schemas.ListsKind;
  name: Schemas.ListsName;
};

export type ListsCreateAListVariables = {
  body: ListsCreateAListRequestBody;
  pathParams: ListsCreateAListPathParams;
} & FetcherExtraProps;

/**
 * Creates a new list of the specified type.
 */
export const listsCreateAList = (variables: ListsCreateAListVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ListsListResponseCollection,
    ListsCreateAListError,
    ListsCreateAListRequestBody,
    {},
    {},
    ListsCreateAListPathParams
  >({ url: '/accounts/{accountId}/rules/lists', method: 'post', ...variables, signal });

export type ListsDeleteAListPathParams = {
  listId: Schemas.ListsListId;
  accountId: Schemas.ListsIdentifier;
};

export type ListsDeleteAListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ListsListDeleteResponseCollection & Schemas.ListsApiResponseCommonFailure;
}>;

export type ListsDeleteAListVariables = {
  pathParams: ListsDeleteAListPathParams;
} & FetcherExtraProps;

/**
 * Deletes a specific list and all its items.
 */
export const listsDeleteAList = (variables: ListsDeleteAListVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ListsListDeleteResponseCollection,
    ListsDeleteAListError,
    undefined,
    {},
    {},
    ListsDeleteAListPathParams
  >({ url: '/accounts/{accountId}/rules/lists/{listId}', method: 'delete', ...variables, signal });

export type ListsGetAListPathParams = {
  listId: Schemas.ListsListId;
  accountId: Schemas.ListsIdentifier;
};

export type ListsGetAListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ListsListResponseCollection & Schemas.ListsApiResponseCommonFailure;
}>;

export type ListsGetAListVariables = {
  pathParams: ListsGetAListPathParams;
} & FetcherExtraProps;

/**
 * Fetches the details of a list.
 */
export const listsGetAList = (variables: ListsGetAListVariables, signal?: AbortSignal) =>
  fetch<Schemas.ListsListResponseCollection, ListsGetAListError, undefined, {}, {}, ListsGetAListPathParams>({
    url: '/accounts/{accountId}/rules/lists/{listId}',
    method: 'get',
    ...variables,
    signal
  });

export type ListsUpdateAListPathParams = {
  listId: Schemas.ListsListId;
  accountId: Schemas.ListsIdentifier;
};

export type ListsUpdateAListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ListsListResponseCollection & Schemas.ListsApiResponseCommonFailure;
}>;

export type ListsUpdateAListRequestBody = {
  description?: Schemas.ListsDescription;
};

export type ListsUpdateAListVariables = {
  body?: ListsUpdateAListRequestBody;
  pathParams: ListsUpdateAListPathParams;
} & FetcherExtraProps;

/**
 * Updates the description of a list.
 */
export const listsUpdateAList = (variables: ListsUpdateAListVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ListsListResponseCollection,
    ListsUpdateAListError,
    ListsUpdateAListRequestBody,
    {},
    {},
    ListsUpdateAListPathParams
  >({ url: '/accounts/{accountId}/rules/lists/{listId}', method: 'put', ...variables, signal });

export type ListsDeleteListItemsPathParams = {
  listId: Schemas.ListsListId;
  accountId: Schemas.ListsIdentifier;
};

export type ListsDeleteListItemsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ListsListsAsyncResponse & Schemas.ListsApiResponseCommonFailure;
}>;

export type ListsDeleteListItemsRequestBody = {
  /**
   * @minItems 1
   */
  items?: {
    id?: Schemas.ListsItemId;
  }[];
};

export type ListsDeleteListItemsVariables = {
  body?: ListsDeleteListItemsRequestBody;
  pathParams: ListsDeleteListItemsPathParams;
} & FetcherExtraProps;

/**
 * Removes one or more items from a list.
 *
 * This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](/operations/lists-get-bulk-operation-status) endpoint with the returned `operation_id`.
 */
export const listsDeleteListItems = (variables: ListsDeleteListItemsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ListsListsAsyncResponse,
    ListsDeleteListItemsError,
    ListsDeleteListItemsRequestBody,
    {},
    {},
    ListsDeleteListItemsPathParams
  >({ url: '/accounts/{accountId}/rules/lists/{listId}/items', method: 'delete', ...variables, signal });

export type ListsGetListItemsPathParams = {
  listId: Schemas.ListsListId;
  accountId: Schemas.ListsIdentifier;
};

export type ListsGetListItemsQueryParams = {
  /**
   * @example zzz
   */
  cursor?: string;
  /**
   * @maximum 500
   * @minimum 1
   */
  per_page?: number;
  /**
   * @example 1.1.1.
   */
  search?: string;
};

export type ListsGetListItemsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ListsItemsListResponseCollection & Schemas.ListsApiResponseCommonFailure;
}>;

export type ListsGetListItemsVariables = {
  pathParams: ListsGetListItemsPathParams;
  queryParams?: ListsGetListItemsQueryParams;
} & FetcherExtraProps;

/**
 * Fetches all the items in the list.
 */
export const listsGetListItems = (variables: ListsGetListItemsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ListsItemsListResponseCollection,
    ListsGetListItemsError,
    undefined,
    {},
    ListsGetListItemsQueryParams,
    ListsGetListItemsPathParams
  >({ url: '/accounts/{accountId}/rules/lists/{listId}/items', method: 'get', ...variables, signal });

export type ListsCreateListItemsPathParams = {
  listId: Schemas.ListsListId;
  accountId: Schemas.ListsIdentifier;
};

export type ListsCreateListItemsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ListsListsAsyncResponse & Schemas.ListsApiResponseCommonFailure;
}>;

export type ListsCreateListItemsVariables = {
  body?: Schemas.ListsItemsUpdateRequestCollection;
  pathParams: ListsCreateListItemsPathParams;
} & FetcherExtraProps;

/**
 * Appends new items to the list.
 *
 * This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](/operations/lists-get-bulk-operation-status) endpoint with the returned `operation_id`.
 */
export const listsCreateListItems = (variables: ListsCreateListItemsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ListsListsAsyncResponse,
    ListsCreateListItemsError,
    Schemas.ListsItemsUpdateRequestCollection,
    {},
    {},
    ListsCreateListItemsPathParams
  >({ url: '/accounts/{accountId}/rules/lists/{listId}/items', method: 'post', ...variables, signal });

export type ListsUpdateAllListItemsPathParams = {
  listId: Schemas.ListsListId;
  accountId: Schemas.ListsIdentifier;
};

export type ListsUpdateAllListItemsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ListsListsAsyncResponse & Schemas.ListsApiResponseCommonFailure;
}>;

export type ListsUpdateAllListItemsVariables = {
  body?: Schemas.ListsItemsUpdateRequestCollection;
  pathParams: ListsUpdateAllListItemsPathParams;
} & FetcherExtraProps;

/**
 * Removes all existing items from the list and adds the provided items to the list.
 *
 * This operation is asynchronous. To get current the operation status, invoke the [Get bulk operation status](/operations/lists-get-bulk-operation-status) endpoint with the returned `operation_id`.
 */
export const listsUpdateAllListItems = (variables: ListsUpdateAllListItemsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ListsListsAsyncResponse,
    ListsUpdateAllListItemsError,
    Schemas.ListsItemsUpdateRequestCollection,
    {},
    {},
    ListsUpdateAllListItemsPathParams
  >({ url: '/accounts/{accountId}/rules/lists/{listId}/items', method: 'put', ...variables, signal });

export type ListAccountRulesetsPathParams = {
  accountId: Schemas.RulesetsAccountId;
};

export type ListAccountRulesetsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type ListAccountRulesetsVariables = {
  pathParams: ListAccountRulesetsPathParams;
} & FetcherExtraProps;

/**
 * Fetches all rulesets at the account level.
 */
export const listAccountRulesets = (variables: ListAccountRulesetsVariables, signal?: AbortSignal) =>
  fetch<Responses.RulesetsRulesets, ListAccountRulesetsError, undefined, {}, {}, ListAccountRulesetsPathParams>({
    url: '/accounts/{accountId}/rulesets',
    method: 'get',
    ...variables,
    signal
  });

export type CreateAccountRulesetPathParams = {
  accountId: Schemas.RulesetsAccountId;
};

export type CreateAccountRulesetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type CreateAccountRulesetVariables = {
  body?: RequestBodies.RulesetsCreateRuleset;
  pathParams: CreateAccountRulesetPathParams;
} & FetcherExtraProps;

/**
 * Creates a ruleset at the account level.
 */
export const createAccountRuleset = (variables: CreateAccountRulesetVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RulesetsRuleset,
    CreateAccountRulesetError,
    RequestBodies.RulesetsCreateRuleset,
    {},
    {},
    CreateAccountRulesetPathParams
  >({ url: '/accounts/{accountId}/rulesets', method: 'post', ...variables, signal });

export type GetAccountEntrypointRulesetPathParams = {
  rulesetPhase: Schemas.RulesetsRulesetPhase;
  accountId: Schemas.RulesetsAccountId;
};

export type GetAccountEntrypointRulesetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type GetAccountEntrypointRulesetVariables = {
  pathParams: GetAccountEntrypointRulesetPathParams;
} & FetcherExtraProps;

/**
 * Fetches the latest version of the account entry point ruleset for a given phase.
 */
export const getAccountEntrypointRuleset = (variables: GetAccountEntrypointRulesetVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RulesetsRuleset,
    GetAccountEntrypointRulesetError,
    undefined,
    {},
    {},
    GetAccountEntrypointRulesetPathParams
  >({ url: '/accounts/{accountId}/rulesets/phases/{rulesetPhase}/entrypoint', method: 'get', ...variables, signal });

export type UpdateAccountEntrypointRulesetPathParams = {
  rulesetPhase: Schemas.RulesetsRulesetPhase;
  accountId: Schemas.RulesetsAccountId;
};

export type UpdateAccountEntrypointRulesetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type UpdateAccountEntrypointRulesetVariables = {
  body?: RequestBodies.RulesetsUpdateEntrypointRuleset;
  pathParams: UpdateAccountEntrypointRulesetPathParams;
} & FetcherExtraProps;

/**
 * Updates an account entry point ruleset, creating a new version.
 */
export const updateAccountEntrypointRuleset = (
  variables: UpdateAccountEntrypointRulesetVariables,
  signal?: AbortSignal
) =>
  fetch<
    Responses.RulesetsRuleset,
    UpdateAccountEntrypointRulesetError,
    RequestBodies.RulesetsUpdateEntrypointRuleset,
    {},
    {},
    UpdateAccountEntrypointRulesetPathParams
  >({ url: '/accounts/{accountId}/rulesets/phases/{rulesetPhase}/entrypoint', method: 'put', ...variables, signal });

export type ListAccountEntrypointRulesetVersionsPathParams = {
  rulesetPhase: Schemas.RulesetsRulesetPhase;
  accountId: Schemas.RulesetsAccountId;
};

export type ListAccountEntrypointRulesetVersionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type ListAccountEntrypointRulesetVersionsVariables = {
  pathParams: ListAccountEntrypointRulesetVersionsPathParams;
} & FetcherExtraProps;

/**
 * Fetches the versions of an account entry point ruleset.
 */
export const listAccountEntrypointRulesetVersions = (
  variables: ListAccountEntrypointRulesetVersionsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Responses.RulesetsRulesets,
    ListAccountEntrypointRulesetVersionsError,
    undefined,
    {},
    {},
    ListAccountEntrypointRulesetVersionsPathParams
  >({
    url: '/accounts/{accountId}/rulesets/phases/{rulesetPhase}/entrypoint/versions',
    method: 'get',
    ...variables,
    signal
  });

export type GetAccountEntrypointRulesetVersionPathParams = {
  rulesetVersion: Schemas.RulesetsRulesetVersion;
  rulesetPhase: Schemas.RulesetsRulesetPhase;
  accountId: Schemas.RulesetsAccountId;
};

export type GetAccountEntrypointRulesetVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type GetAccountEntrypointRulesetVersionVariables = {
  pathParams: GetAccountEntrypointRulesetVersionPathParams;
} & FetcherExtraProps;

/**
 * Fetches a specific version of an account entry point ruleset.
 */
export const getAccountEntrypointRulesetVersion = (
  variables: GetAccountEntrypointRulesetVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    Responses.RulesetsRuleset,
    GetAccountEntrypointRulesetVersionError,
    undefined,
    {},
    {},
    GetAccountEntrypointRulesetVersionPathParams
  >({
    url: '/accounts/{accountId}/rulesets/phases/{rulesetPhase}/entrypoint/versions/{rulesetVersion}',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteAccountRulesetPathParams = {
  rulesetId: Schemas.RulesetsRulesetId;
  accountId: Schemas.RulesetsAccountId;
};

export type DeleteAccountRulesetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type DeleteAccountRulesetVariables = {
  pathParams: DeleteAccountRulesetPathParams;
} & FetcherExtraProps;

/**
 * Deletes all versions of an existing account ruleset.
 */
export const deleteAccountRuleset = (variables: DeleteAccountRulesetVariables, signal?: AbortSignal) =>
  fetch<Responses.RulesetsEmpty, DeleteAccountRulesetError, undefined, {}, {}, DeleteAccountRulesetPathParams>({
    url: '/accounts/{accountId}/rulesets/{rulesetId}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetAccountRulesetPathParams = {
  rulesetId: Schemas.RulesetsRulesetId;
  accountId: Schemas.RulesetsAccountId;
};

export type GetAccountRulesetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type GetAccountRulesetVariables = {
  pathParams: GetAccountRulesetPathParams;
} & FetcherExtraProps;

/**
 * Fetches the latest version of an account ruleset.
 */
export const getAccountRuleset = (variables: GetAccountRulesetVariables, signal?: AbortSignal) =>
  fetch<Responses.RulesetsRuleset, GetAccountRulesetError, undefined, {}, {}, GetAccountRulesetPathParams>({
    url: '/accounts/{accountId}/rulesets/{rulesetId}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateAccountRulesetPathParams = {
  rulesetId: Schemas.RulesetsRulesetId;
  accountId: Schemas.RulesetsAccountId;
};

export type UpdateAccountRulesetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type UpdateAccountRulesetVariables = {
  body?: RequestBodies.RulesetsUpdateRuleset;
  pathParams: UpdateAccountRulesetPathParams;
} & FetcherExtraProps;

/**
 * Updates an account ruleset, creating a new version.
 */
export const updateAccountRuleset = (variables: UpdateAccountRulesetVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RulesetsRuleset,
    UpdateAccountRulesetError,
    RequestBodies.RulesetsUpdateRuleset,
    {},
    {},
    UpdateAccountRulesetPathParams
  >({ url: '/accounts/{accountId}/rulesets/{rulesetId}', method: 'put', ...variables, signal });

export type CreateAccountRulesetRulePathParams = {
  rulesetId: Schemas.RulesetsRulesetId;
  accountId: Schemas.RulesetsAccountId;
};

export type CreateAccountRulesetRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type CreateAccountRulesetRuleVariables = {
  body?: RequestBodies.RulesetsRule;
  pathParams: CreateAccountRulesetRulePathParams;
} & FetcherExtraProps;

/**
 * Adds a new rule to an account ruleset. The rule will be added to the end of the existing list of rules in the ruleset by default.
 */
export const createAccountRulesetRule = (variables: CreateAccountRulesetRuleVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RulesetsRuleset,
    CreateAccountRulesetRuleError,
    RequestBodies.RulesetsRule,
    {},
    {},
    CreateAccountRulesetRulePathParams
  >({ url: '/accounts/{accountId}/rulesets/{rulesetId}/rules', method: 'post', ...variables, signal });

export type DeleteAccountRulesetRulePathParams = {
  ruleId: Schemas.RulesetsRuleId;
  rulesetId: Schemas.RulesetsRulesetId;
  accountId: Schemas.RulesetsAccountId;
};

export type DeleteAccountRulesetRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type DeleteAccountRulesetRuleVariables = {
  pathParams: DeleteAccountRulesetRulePathParams;
} & FetcherExtraProps;

/**
 * Deletes an existing rule from an account ruleset.
 */
export const deleteAccountRulesetRule = (variables: DeleteAccountRulesetRuleVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RulesetsRuleset,
    DeleteAccountRulesetRuleError,
    undefined,
    {},
    {},
    DeleteAccountRulesetRulePathParams
  >({ url: '/accounts/{accountId}/rulesets/{rulesetId}/rules/{ruleId}', method: 'delete', ...variables, signal });

export type UpdateAccountRulesetRulePathParams = {
  ruleId: Schemas.RulesetsRuleId;
  rulesetId: Schemas.RulesetsRulesetId;
  accountId: Schemas.RulesetsAccountId;
};

export type UpdateAccountRulesetRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type UpdateAccountRulesetRuleVariables = {
  body?: RequestBodies.RulesetsRule;
  pathParams: UpdateAccountRulesetRulePathParams;
} & FetcherExtraProps;

/**
 * Updates an existing rule in an account ruleset.
 */
export const updateAccountRulesetRule = (variables: UpdateAccountRulesetRuleVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RulesetsRuleset,
    UpdateAccountRulesetRuleError,
    RequestBodies.RulesetsRule,
    {},
    {},
    UpdateAccountRulesetRulePathParams
  >({ url: '/accounts/{accountId}/rulesets/{rulesetId}/rules/{ruleId}', method: 'patch', ...variables, signal });

export type ListAccountRulesetVersionsPathParams = {
  rulesetId: Schemas.RulesetsRulesetId;
  accountId: Schemas.RulesetsAccountId;
};

export type ListAccountRulesetVersionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type ListAccountRulesetVersionsVariables = {
  pathParams: ListAccountRulesetVersionsPathParams;
} & FetcherExtraProps;

/**
 * Fetches the versions of an account ruleset.
 */
export const listAccountRulesetVersions = (variables: ListAccountRulesetVersionsVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RulesetsRulesets,
    ListAccountRulesetVersionsError,
    undefined,
    {},
    {},
    ListAccountRulesetVersionsPathParams
  >({ url: '/accounts/{accountId}/rulesets/{rulesetId}/versions', method: 'get', ...variables, signal });

export type DeleteAccountRulesetVersionPathParams = {
  rulesetVersion: Schemas.RulesetsRulesetVersion;
  rulesetId: Schemas.RulesetsRulesetId;
  accountId: Schemas.RulesetsAccountId;
};

export type DeleteAccountRulesetVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type DeleteAccountRulesetVersionVariables = {
  pathParams: DeleteAccountRulesetVersionPathParams;
} & FetcherExtraProps;

/**
 * Deletes an existing version of an account ruleset.
 */
export const deleteAccountRulesetVersion = (variables: DeleteAccountRulesetVersionVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RulesetsEmpty,
    DeleteAccountRulesetVersionError,
    undefined,
    {},
    {},
    DeleteAccountRulesetVersionPathParams
  >({
    url: '/accounts/{accountId}/rulesets/{rulesetId}/versions/{rulesetVersion}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetAccountRulesetVersionPathParams = {
  rulesetVersion: Schemas.RulesetsRulesetVersion;
  rulesetId: Schemas.RulesetsRulesetId;
  accountId: Schemas.RulesetsAccountId;
};

export type GetAccountRulesetVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type GetAccountRulesetVersionVariables = {
  pathParams: GetAccountRulesetVersionPathParams;
} & FetcherExtraProps;

/**
 * Fetches a specific version of an account ruleset.
 */
export const getAccountRulesetVersion = (variables: GetAccountRulesetVersionVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RulesetsRuleset,
    GetAccountRulesetVersionError,
    undefined,
    {},
    {},
    GetAccountRulesetVersionPathParams
  >({
    url: '/accounts/{accountId}/rulesets/{rulesetId}/versions/{rulesetVersion}',
    method: 'get',
    ...variables,
    signal
  });

export type ListAccountRulesetVersionRulesByTagPathParams = {
  ruleTag: Schemas.RulesetsRuleCategory;
  rulesetVersion: Schemas.RulesetsRulesetVersion;
  rulesetId: Schemas.RulesetsRulesetId;
  accountId: Schemas.RulesetsAccountId;
};

export type ListAccountRulesetVersionRulesByTagError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type ListAccountRulesetVersionRulesByTagVariables = {
  pathParams: ListAccountRulesetVersionRulesByTagPathParams;
} & FetcherExtraProps;

/**
 * Fetches the rules of a managed account ruleset version for a given tag.
 */
export const listAccountRulesetVersionRulesByTag = (
  variables: ListAccountRulesetVersionRulesByTagVariables,
  signal?: AbortSignal
) =>
  fetch<
    Responses.RulesetsRuleset,
    ListAccountRulesetVersionRulesByTagError,
    undefined,
    {},
    {},
    ListAccountRulesetVersionRulesByTagPathParams
  >({
    url: '/accounts/{accountId}/rulesets/{rulesetId}/versions/{rulesetVersion}/by_tag/{ruleTag}',
    method: 'get',
    ...variables,
    signal
  });

export type WebAnalyticsCreateSitePathParams = {
  accountId: Schemas.RumIdentifier;
};

export type WebAnalyticsCreateSiteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.RumApiResponseCommonFailure;
}>;

export type WebAnalyticsCreateSiteVariables = {
  body?: Schemas.RumCreateSiteRequest;
  pathParams: WebAnalyticsCreateSitePathParams;
} & FetcherExtraProps;

/**
 * Creates a new Web Analytics site.
 */
export const webAnalyticsCreateSite = (variables: WebAnalyticsCreateSiteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.RumSiteResponseSingle,
    WebAnalyticsCreateSiteError,
    Schemas.RumCreateSiteRequest,
    {},
    {},
    WebAnalyticsCreateSitePathParams
  >({ url: '/accounts/{accountId}/rum/site_info', method: 'post', ...variables, signal });

export type WebAnalyticsListSitesPathParams = {
  accountId: Schemas.RumIdentifier;
};

export type WebAnalyticsListSitesQueryParams = {
  per_page?: Schemas.RumPerPage;
  page?: Schemas.RumPage;
  order_by?: Schemas.RumOrderBy;
};

export type WebAnalyticsListSitesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.RumApiResponseCommonFailure;
}>;

export type WebAnalyticsListSitesVariables = {
  pathParams: WebAnalyticsListSitesPathParams;
  queryParams?: WebAnalyticsListSitesQueryParams;
} & FetcherExtraProps;

/**
 * Lists all Web Analytics sites of an account.
 */
export const webAnalyticsListSites = (variables: WebAnalyticsListSitesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.RumSitesResponseCollection,
    WebAnalyticsListSitesError,
    undefined,
    {},
    WebAnalyticsListSitesQueryParams,
    WebAnalyticsListSitesPathParams
  >({ url: '/accounts/{accountId}/rum/site_info/list', method: 'get', ...variables, signal });

export type WebAnalyticsDeleteSitePathParams = {
  accountId: Schemas.RumIdentifier;
  siteId: Schemas.RumIdentifier;
};

export type WebAnalyticsDeleteSiteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.RumApiResponseCommonFailure;
}>;

export type WebAnalyticsDeleteSiteVariables = {
  pathParams: WebAnalyticsDeleteSitePathParams;
} & FetcherExtraProps;

/**
 * Deletes an existing Web Analytics site.
 */
export const webAnalyticsDeleteSite = (variables: WebAnalyticsDeleteSiteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.RumSiteTagResponseSingle,
    WebAnalyticsDeleteSiteError,
    undefined,
    {},
    {},
    WebAnalyticsDeleteSitePathParams
  >({ url: '/accounts/{accountId}/rum/site_info/{siteId}', method: 'delete', ...variables, signal });

export type WebAnalyticsGetSitePathParams = {
  accountId: Schemas.RumIdentifier;
  siteId: Schemas.RumIdentifier;
};

export type WebAnalyticsGetSiteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.RumApiResponseCommonFailure;
}>;

export type WebAnalyticsGetSiteVariables = {
  pathParams: WebAnalyticsGetSitePathParams;
} & FetcherExtraProps;

/**
 * Retrieves a Web Analytics site.
 */
export const webAnalyticsGetSite = (variables: WebAnalyticsGetSiteVariables, signal?: AbortSignal) =>
  fetch<Schemas.RumSiteResponseSingle, WebAnalyticsGetSiteError, undefined, {}, {}, WebAnalyticsGetSitePathParams>({
    url: '/accounts/{accountId}/rum/site_info/{siteId}',
    method: 'get',
    ...variables,
    signal
  });

export type WebAnalyticsUpdateSitePathParams = {
  accountId: Schemas.RumIdentifier;
  siteId: Schemas.RumIdentifier;
};

export type WebAnalyticsUpdateSiteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.RumApiResponseCommonFailure;
}>;

export type WebAnalyticsUpdateSiteVariables = {
  body?: Schemas.RumCreateSiteRequest;
  pathParams: WebAnalyticsUpdateSitePathParams;
} & FetcherExtraProps;

/**
 * Updates an existing Web Analytics site.
 */
export const webAnalyticsUpdateSite = (variables: WebAnalyticsUpdateSiteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.RumSiteResponseSingle,
    WebAnalyticsUpdateSiteError,
    Schemas.RumCreateSiteRequest,
    {},
    {},
    WebAnalyticsUpdateSitePathParams
  >({ url: '/accounts/{accountId}/rum/site_info/{siteId}', method: 'put', ...variables, signal });

export type WebAnalyticsCreateRulePathParams = {
  accountId: Schemas.RumIdentifier;
  rulesetId: Schemas.RumRulesetIdentifier;
};

export type WebAnalyticsCreateRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.RumApiResponseCommonFailure;
}>;

export type WebAnalyticsCreateRuleVariables = {
  body?: Schemas.RumCreateRuleRequest;
  pathParams: WebAnalyticsCreateRulePathParams;
} & FetcherExtraProps;

/**
 * Creates a new rule in a Web Analytics ruleset.
 */
export const webAnalyticsCreateRule = (variables: WebAnalyticsCreateRuleVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.RumRuleResponseSingle,
    WebAnalyticsCreateRuleError,
    Schemas.RumCreateRuleRequest,
    {},
    {},
    WebAnalyticsCreateRulePathParams
  >({ url: '/accounts/{accountId}/rum/v2/{rulesetId}/rule', method: 'post', ...variables, signal });

export type WebAnalyticsDeleteRulePathParams = {
  accountId: Schemas.RumIdentifier;
  rulesetId: Schemas.RumRulesetIdentifier;
  ruleId: Schemas.RumRuleIdentifier;
};

export type WebAnalyticsDeleteRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.RumApiResponseCommonFailure;
}>;

export type WebAnalyticsDeleteRuleVariables = {
  pathParams: WebAnalyticsDeleteRulePathParams;
} & FetcherExtraProps;

/**
 * Deletes an existing rule from a Web Analytics ruleset.
 */
export const webAnalyticsDeleteRule = (variables: WebAnalyticsDeleteRuleVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.RumRuleIdResponseSingle,
    WebAnalyticsDeleteRuleError,
    undefined,
    {},
    {},
    WebAnalyticsDeleteRulePathParams
  >({ url: '/accounts/{accountId}/rum/v2/{rulesetId}/rule/{ruleId}', method: 'delete', ...variables, signal });

export type WebAnalyticsUpdateRulePathParams = {
  accountId: Schemas.RumIdentifier;
  rulesetId: Schemas.RumRulesetIdentifier;
  ruleId: Schemas.RumRuleIdentifier;
};

export type WebAnalyticsUpdateRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.RumApiResponseCommonFailure;
}>;

export type WebAnalyticsUpdateRuleVariables = {
  body?: Schemas.RumCreateRuleRequest;
  pathParams: WebAnalyticsUpdateRulePathParams;
} & FetcherExtraProps;

/**
 * Updates a rule in a Web Analytics ruleset.
 */
export const webAnalyticsUpdateRule = (variables: WebAnalyticsUpdateRuleVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.RumRuleResponseSingle,
    WebAnalyticsUpdateRuleError,
    Schemas.RumCreateRuleRequest,
    {},
    {},
    WebAnalyticsUpdateRulePathParams
  >({ url: '/accounts/{accountId}/rum/v2/{rulesetId}/rule/{ruleId}', method: 'put', ...variables, signal });

export type WebAnalyticsListRulesPathParams = {
  accountId: Schemas.RumIdentifier;
  rulesetId: Schemas.RumRulesetIdentifier;
};

export type WebAnalyticsListRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.RumApiResponseCommonFailure;
}>;

export type WebAnalyticsListRulesVariables = {
  pathParams: WebAnalyticsListRulesPathParams;
} & FetcherExtraProps;

/**
 * Lists all the rules in a Web Analytics ruleset.
 */
export const webAnalyticsListRules = (variables: WebAnalyticsListRulesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.RumRulesResponseCollection,
    WebAnalyticsListRulesError,
    undefined,
    {},
    {},
    WebAnalyticsListRulesPathParams
  >({ url: '/accounts/{accountId}/rum/v2/{rulesetId}/rules', method: 'get', ...variables, signal });

export type WebAnalyticsModifyRulesPathParams = {
  accountId: Schemas.RumIdentifier;
  rulesetId: Schemas.RumRulesetIdentifier;
};

export type WebAnalyticsModifyRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.RumApiResponseCommonFailure;
}>;

export type WebAnalyticsModifyRulesVariables = {
  body?: Schemas.RumModifyRulesRequest;
  pathParams: WebAnalyticsModifyRulesPathParams;
} & FetcherExtraProps;

/**
 * Modifies one or more rules in a Web Analytics ruleset with a single request.
 */
export const webAnalyticsModifyRules = (variables: WebAnalyticsModifyRulesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.RumRulesResponseCollection,
    WebAnalyticsModifyRulesError,
    Schemas.RumModifyRulesRequest,
    {},
    {},
    WebAnalyticsModifyRulesPathParams
  >({ url: '/accounts/{accountId}/rum/v2/{rulesetId}/rules', method: 'post', ...variables, signal });

export type SecondaryDnsAclListAcLsPathParams = {
  accountId: Schemas.SecondaryDnsAccountIdentifier;
};

export type SecondaryDnsAclListAcLsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsComponentsSchemasResponseCollection & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsAclListAcLsVariables = {
  pathParams: SecondaryDnsAclListAcLsPathParams;
} & FetcherExtraProps;

/**
 * List ACLs.
 */
export const secondaryDnsAclListAcLs = (variables: SecondaryDnsAclListAcLsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SecondaryDnsComponentsSchemasResponseCollection,
    SecondaryDnsAclListAcLsError,
    undefined,
    {},
    {},
    SecondaryDnsAclListAcLsPathParams
  >({ url: '/accounts/{accountId}/secondary_dns/acls', method: 'get', ...variables, signal });

export type SecondaryDnsAclCreateAclPathParams = {
  accountId: Schemas.SecondaryDnsAccountIdentifier;
};

export type SecondaryDnsAclCreateAclError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsComponentsSchemasSingleResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsAclCreateAclRequestBody = {
  ip_range: Schemas.SecondaryDnsIpRange;
  name: Schemas.SecondaryDnsAclComponentsSchemasName;
};

export type SecondaryDnsAclCreateAclVariables = {
  body: SecondaryDnsAclCreateAclRequestBody;
  pathParams: SecondaryDnsAclCreateAclPathParams;
} & FetcherExtraProps;

/**
 * Create ACL.
 */
export const secondaryDnsAclCreateAcl = (variables: SecondaryDnsAclCreateAclVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SecondaryDnsComponentsSchemasSingleResponse,
    SecondaryDnsAclCreateAclError,
    SecondaryDnsAclCreateAclRequestBody,
    {},
    {},
    SecondaryDnsAclCreateAclPathParams
  >({ url: '/accounts/{accountId}/secondary_dns/acls', method: 'post', ...variables, signal });

export type SecondaryDnsAclDeleteAclPathParams = {
  aclId: Schemas.SecondaryDnsComponentsSchemasIdentifier;
  accountId: Schemas.SecondaryDnsAccountIdentifier;
};

export type SecondaryDnsAclDeleteAclError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsComponentsSchemasIdResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsAclDeleteAclVariables = {
  pathParams: SecondaryDnsAclDeleteAclPathParams;
} & FetcherExtraProps;

/**
 * Delete ACL.
 */
export const secondaryDnsAclDeleteAcl = (variables: SecondaryDnsAclDeleteAclVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SecondaryDnsComponentsSchemasIdResponse,
    SecondaryDnsAclDeleteAclError,
    undefined,
    {},
    {},
    SecondaryDnsAclDeleteAclPathParams
  >({ url: '/accounts/{accountId}/secondary_dns/acls/{aclId}', method: 'delete', ...variables, signal });

export type SecondaryDnsAclAclDetailsPathParams = {
  aclId: Schemas.SecondaryDnsComponentsSchemasIdentifier;
  accountId: Schemas.SecondaryDnsAccountIdentifier;
};

export type SecondaryDnsAclAclDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsComponentsSchemasSingleResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsAclAclDetailsVariables = {
  pathParams: SecondaryDnsAclAclDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get ACL.
 */
export const secondaryDnsAclAclDetails = (variables: SecondaryDnsAclAclDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SecondaryDnsComponentsSchemasSingleResponse,
    SecondaryDnsAclAclDetailsError,
    undefined,
    {},
    {},
    SecondaryDnsAclAclDetailsPathParams
  >({ url: '/accounts/{accountId}/secondary_dns/acls/{aclId}', method: 'get', ...variables, signal });

export type SecondaryDnsAclUpdateAclPathParams = {
  aclId: Schemas.SecondaryDnsComponentsSchemasIdentifier;
  accountId: Schemas.SecondaryDnsAccountIdentifier;
};

export type SecondaryDnsAclUpdateAclError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsComponentsSchemasSingleResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsAclUpdateAclVariables = {
  body: Schemas.SecondaryDnsAcl;
  pathParams: SecondaryDnsAclUpdateAclPathParams;
} & FetcherExtraProps;

/**
 * Modify ACL.
 */
export const secondaryDnsAclUpdateAcl = (variables: SecondaryDnsAclUpdateAclVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SecondaryDnsComponentsSchemasSingleResponse,
    SecondaryDnsAclUpdateAclError,
    Schemas.SecondaryDnsAcl,
    {},
    {},
    SecondaryDnsAclUpdateAclPathParams
  >({ url: '/accounts/{accountId}/secondary_dns/acls/{aclId}', method: 'put', ...variables, signal });

export type SecondaryDnsPeerListPeersPathParams = {
  accountId: Schemas.SecondaryDnsAccountIdentifier;
};

export type SecondaryDnsPeerListPeersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsSchemasResponseCollection & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsPeerListPeersVariables = {
  pathParams: SecondaryDnsPeerListPeersPathParams;
} & FetcherExtraProps;

/**
 * List Peers.
 */
export const secondaryDnsPeerListPeers = (variables: SecondaryDnsPeerListPeersVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SecondaryDnsSchemasResponseCollection,
    SecondaryDnsPeerListPeersError,
    undefined,
    {},
    {},
    SecondaryDnsPeerListPeersPathParams
  >({ url: '/accounts/{accountId}/secondary_dns/peers', method: 'get', ...variables, signal });

export type SecondaryDnsPeerCreatePeerPathParams = {
  accountId: Schemas.SecondaryDnsAccountIdentifier;
};

export type SecondaryDnsPeerCreatePeerError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsSchemasSingleResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsPeerCreatePeerRequestBody = {
  name: Schemas.SecondaryDnsComponentsSchemasName;
};

export type SecondaryDnsPeerCreatePeerVariables = {
  body: SecondaryDnsPeerCreatePeerRequestBody;
  pathParams: SecondaryDnsPeerCreatePeerPathParams;
} & FetcherExtraProps;

/**
 * Create Peer.
 */
export const secondaryDnsPeerCreatePeer = (variables: SecondaryDnsPeerCreatePeerVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SecondaryDnsSchemasSingleResponse,
    SecondaryDnsPeerCreatePeerError,
    SecondaryDnsPeerCreatePeerRequestBody,
    {},
    {},
    SecondaryDnsPeerCreatePeerPathParams
  >({ url: '/accounts/{accountId}/secondary_dns/peers', method: 'post', ...variables, signal });

export type SecondaryDnsPeerDeletePeerPathParams = {
  peerId: Schemas.SecondaryDnsComponentsSchemasIdentifier;
  accountId: Schemas.SecondaryDnsAccountIdentifier;
};

export type SecondaryDnsPeerDeletePeerError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsComponentsSchemasIdResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsPeerDeletePeerVariables = {
  pathParams: SecondaryDnsPeerDeletePeerPathParams;
} & FetcherExtraProps;

/**
 * Delete Peer.
 */
export const secondaryDnsPeerDeletePeer = (variables: SecondaryDnsPeerDeletePeerVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SecondaryDnsComponentsSchemasIdResponse,
    SecondaryDnsPeerDeletePeerError,
    undefined,
    {},
    {},
    SecondaryDnsPeerDeletePeerPathParams
  >({ url: '/accounts/{accountId}/secondary_dns/peers/{peerId}', method: 'delete', ...variables, signal });

export type SecondaryDnsPeerPeerDetailsPathParams = {
  peerId: Schemas.SecondaryDnsComponentsSchemasIdentifier;
  accountId: Schemas.SecondaryDnsAccountIdentifier;
};

export type SecondaryDnsPeerPeerDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsSchemasSingleResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsPeerPeerDetailsVariables = {
  pathParams: SecondaryDnsPeerPeerDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get Peer.
 */
export const secondaryDnsPeerPeerDetails = (variables: SecondaryDnsPeerPeerDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SecondaryDnsSchemasSingleResponse,
    SecondaryDnsPeerPeerDetailsError,
    undefined,
    {},
    {},
    SecondaryDnsPeerPeerDetailsPathParams
  >({ url: '/accounts/{accountId}/secondary_dns/peers/{peerId}', method: 'get', ...variables, signal });

export type SecondaryDnsPeerUpdatePeerPathParams = {
  peerId: Schemas.SecondaryDnsComponentsSchemasIdentifier;
  accountId: Schemas.SecondaryDnsAccountIdentifier;
};

export type SecondaryDnsPeerUpdatePeerError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsSchemasSingleResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsPeerUpdatePeerVariables = {
  body: Schemas.SecondaryDnsPeer;
  pathParams: SecondaryDnsPeerUpdatePeerPathParams;
} & FetcherExtraProps;

/**
 * Modify Peer.
 */
export const secondaryDnsPeerUpdatePeer = (variables: SecondaryDnsPeerUpdatePeerVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SecondaryDnsSchemasSingleResponse,
    SecondaryDnsPeerUpdatePeerError,
    Schemas.SecondaryDnsPeer,
    {},
    {},
    SecondaryDnsPeerUpdatePeerPathParams
  >({ url: '/accounts/{accountId}/secondary_dns/peers/{peerId}', method: 'put', ...variables, signal });

export type SecondaryDnsTsigListTsiGsPathParams = {
  accountId: Schemas.SecondaryDnsAccountIdentifier;
};

export type SecondaryDnsTsigListTsiGsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsResponseCollection & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsTsigListTsiGsVariables = {
  pathParams: SecondaryDnsTsigListTsiGsPathParams;
} & FetcherExtraProps;

/**
 * List TSIGs.
 */
export const secondaryDnsTsigListTsiGs = (variables: SecondaryDnsTsigListTsiGsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SecondaryDnsResponseCollection,
    SecondaryDnsTsigListTsiGsError,
    undefined,
    {},
    {},
    SecondaryDnsTsigListTsiGsPathParams
  >({ url: '/accounts/{accountId}/secondary_dns/tsigs', method: 'get', ...variables, signal });

export type SecondaryDnsTsigCreateTsigPathParams = {
  accountId: Schemas.SecondaryDnsAccountIdentifier;
};

export type SecondaryDnsTsigCreateTsigError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsSingleResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsTsigCreateTsigVariables = {
  body: Schemas.SecondaryDnsTsig;
  pathParams: SecondaryDnsTsigCreateTsigPathParams;
} & FetcherExtraProps;

/**
 * Create TSIG.
 */
export const secondaryDnsTsigCreateTsig = (variables: SecondaryDnsTsigCreateTsigVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SecondaryDnsSingleResponse,
    SecondaryDnsTsigCreateTsigError,
    Schemas.SecondaryDnsTsig,
    {},
    {},
    SecondaryDnsTsigCreateTsigPathParams
  >({ url: '/accounts/{accountId}/secondary_dns/tsigs', method: 'post', ...variables, signal });

export type SecondaryDnsTsigDeleteTsigPathParams = {
  tsigId: Schemas.SecondaryDnsSchemasIdentifier;
  accountId: Schemas.SecondaryDnsAccountIdentifier;
};

export type SecondaryDnsTsigDeleteTsigError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsSchemasIdResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsTsigDeleteTsigVariables = {
  pathParams: SecondaryDnsTsigDeleteTsigPathParams;
} & FetcherExtraProps;

/**
 * Delete TSIG.
 */
export const secondaryDnsTsigDeleteTsig = (variables: SecondaryDnsTsigDeleteTsigVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SecondaryDnsSchemasIdResponse,
    SecondaryDnsTsigDeleteTsigError,
    undefined,
    {},
    {},
    SecondaryDnsTsigDeleteTsigPathParams
  >({ url: '/accounts/{accountId}/secondary_dns/tsigs/{tsigId}', method: 'delete', ...variables, signal });

export type SecondaryDnsTsigTsigDetailsPathParams = {
  tsigId: Schemas.SecondaryDnsSchemasIdentifier;
  accountId: Schemas.SecondaryDnsAccountIdentifier;
};

export type SecondaryDnsTsigTsigDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsSingleResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsTsigTsigDetailsVariables = {
  pathParams: SecondaryDnsTsigTsigDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get TSIG.
 */
export const secondaryDnsTsigTsigDetails = (variables: SecondaryDnsTsigTsigDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SecondaryDnsSingleResponse,
    SecondaryDnsTsigTsigDetailsError,
    undefined,
    {},
    {},
    SecondaryDnsTsigTsigDetailsPathParams
  >({ url: '/accounts/{accountId}/secondary_dns/tsigs/{tsigId}', method: 'get', ...variables, signal });

export type SecondaryDnsTsigUpdateTsigPathParams = {
  tsigId: Schemas.SecondaryDnsSchemasIdentifier;
  accountId: Schemas.SecondaryDnsAccountIdentifier;
};

export type SecondaryDnsTsigUpdateTsigError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsSingleResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsTsigUpdateTsigVariables = {
  body: Schemas.SecondaryDnsTsig;
  pathParams: SecondaryDnsTsigUpdateTsigPathParams;
} & FetcherExtraProps;

/**
 * Modify TSIG.
 */
export const secondaryDnsTsigUpdateTsig = (variables: SecondaryDnsTsigUpdateTsigVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SecondaryDnsSingleResponse,
    SecondaryDnsTsigUpdateTsigError,
    Schemas.SecondaryDnsTsig,
    {},
    {},
    SecondaryDnsTsigUpdateTsigPathParams
  >({ url: '/accounts/{accountId}/secondary_dns/tsigs/{tsigId}', method: 'put', ...variables, signal });

export type SharesListPathParams = {
  accountId: Schemas.ResourceSharingAccountId;
};

export type SharesListQueryParams = {
  /**
   * Filter shares by status.
   */
  status?: Schemas.ResourceSharingShareStatus;
  /**
   * Filter shares by kind.
   */
  kind?: Schemas.ResourceSharingShareKind;
  /**
   * Filter shares by target_type.
   */
  target_type?: Schemas.ResourceSharingShareTargetType;
  /**
   * Order shares by values in the given field.
   *
   * @default created
   */
  order?: 'name' | 'created';
  /**
   * Direction to sort objects.
   *
   * @default asc
   */
  direction?: 'asc' | 'desc';
  /**
   * Page number.
   *
   * @example 2
   * @minimum 0
   * @multipleOf 1
   */
  page?: number;
  /**
   * Number of objects to return per page.
   *
   * @example 20
   * @maximum 100
   * @minimum 0
   * @multipleOf 1
   */
  per_page?: number;
};

export type SharesListError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
>;

export type SharesListVariables = {
  pathParams: SharesListPathParams;
  queryParams?: SharesListQueryParams;
} & FetcherExtraProps;

/**
 * Lists all account shares.
 */
export const sharesList = (variables: SharesListVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ResourceSharingShareResponseCollection,
    SharesListError,
    undefined,
    {},
    SharesListQueryParams,
    SharesListPathParams
  >({ url: '/accounts/{accountId}/shares', method: 'get', ...variables, signal });

export type ShareCreatePathParams = {
  accountId: Schemas.ResourceSharingAccountId;
};

export type ShareCreateError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
>;

export type ShareCreateVariables = {
  body: Schemas.ResourceSharingCreateShareRequest;
  pathParams: ShareCreatePathParams;
} & FetcherExtraProps;

export const shareCreate = (variables: ShareCreateVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ResourceSharingShareResponseSingle,
    ShareCreateError,
    Schemas.ResourceSharingCreateShareRequest,
    {},
    {},
    ShareCreatePathParams
  >({ url: '/accounts/{accountId}/shares', method: 'post', ...variables, signal });

export type ShareDeletePathParams = {
  accountId: Schemas.ResourceSharingAccountId;
  shareId: Schemas.ResourceSharingShareId;
};

export type ShareDeleteError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
>;

export type ShareDeleteVariables = {
  pathParams: ShareDeletePathParams;
} & FetcherExtraProps;

/**
 * Deletion is not immediate, an updated share object with a new status will be returned.
 */
export const shareDelete = (variables: ShareDeleteVariables, signal?: AbortSignal) =>
  fetch<Schemas.ResourceSharingShareResponseSingle, ShareDeleteError, undefined, {}, {}, ShareDeletePathParams>({
    url: '/accounts/{accountId}/shares/{shareId}',
    method: 'delete',
    ...variables,
    signal
  });

export type SharesGetByIdPathParams = {
  accountId: Schemas.ResourceSharingAccountId;
  shareId: Schemas.ResourceSharingShareId;
};

export type SharesGetByIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
>;

export type SharesGetByIdVariables = {
  pathParams: SharesGetByIdPathParams;
} & FetcherExtraProps;

/**
 * Fetches share by ID.
 */
export const sharesGetById = (variables: SharesGetByIdVariables, signal?: AbortSignal) =>
  fetch<Schemas.ResourceSharingShareResponseSingle, SharesGetByIdError, undefined, {}, {}, SharesGetByIdPathParams>({
    url: '/accounts/{accountId}/shares/{shareId}',
    method: 'get',
    ...variables,
    signal
  });

export type ShareUpdatePathParams = {
  accountId: Schemas.ResourceSharingAccountId;
  shareId: Schemas.ResourceSharingShareId;
};

export type ShareUpdateError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
>;

export type ShareUpdateVariables = {
  body: Schemas.ResourceSharingUpdateShareRequest;
  pathParams: ShareUpdatePathParams;
} & FetcherExtraProps;

/**
 * Updating is not immediate, an updated share object with a new status will be returned.
 */
export const shareUpdate = (variables: ShareUpdateVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ResourceSharingShareResponseSingle,
    ShareUpdateError,
    Schemas.ResourceSharingUpdateShareRequest,
    {},
    {},
    ShareUpdatePathParams
  >({ url: '/accounts/{accountId}/shares/{shareId}', method: 'put', ...variables, signal });

export type ShareRecipientsListPathParams = {
  accountId: Schemas.ResourceSharingAccountId;
  shareId: Schemas.ResourceSharingShareId;
};

export type ShareRecipientsListQueryParams = {
  /**
   * Page number.
   *
   * @example 2
   * @minimum 0
   * @multipleOf 1
   */
  page?: number;
  /**
   * Number of objects to return per page.
   *
   * @example 20
   * @maximum 100
   * @minimum 0
   * @multipleOf 1
   */
  per_page?: number;
};

export type ShareRecipientsListError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
>;

export type ShareRecipientsListVariables = {
  pathParams: ShareRecipientsListPathParams;
  queryParams?: ShareRecipientsListQueryParams;
} & FetcherExtraProps;

/**
 * List share recipients by share ID.
 */
export const shareRecipientsList = (variables: ShareRecipientsListVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ResourceSharingShareRecipientResponseCollection,
    ShareRecipientsListError,
    undefined,
    {},
    ShareRecipientsListQueryParams,
    ShareRecipientsListPathParams
  >({ url: '/accounts/{accountId}/shares/{shareId}/recipients', method: 'get', ...variables, signal });

export type ShareRecipientCreatePathParams = {
  accountId: Schemas.ResourceSharingAccountId;
  shareId: Schemas.ResourceSharingShareId;
};

export type ShareRecipientCreateError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
>;

export type ShareRecipientCreateVariables = {
  body?: Schemas.ResourceSharingCreateShareRecipientRequest;
  pathParams: ShareRecipientCreatePathParams;
} & FetcherExtraProps;

export const shareRecipientCreate = (variables: ShareRecipientCreateVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ResourceSharingShareRecipientResponseSingle,
    ShareRecipientCreateError,
    Schemas.ResourceSharingCreateShareRecipientRequest,
    {},
    {},
    ShareRecipientCreatePathParams
  >({ url: '/accounts/{accountId}/shares/{shareId}/recipients', method: 'post', ...variables, signal });

export type ShareRecipientDeletePathParams = {
  accountId: Schemas.ResourceSharingAccountId;
  shareId: Schemas.ResourceSharingShareId;
  recipientId: Schemas.ResourceSharingRecipientId;
};

export type ShareRecipientDeleteError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
>;

export type ShareRecipientDeleteVariables = {
  pathParams: ShareRecipientDeletePathParams;
} & FetcherExtraProps;

/**
 * Deletion is not immediate, an updated share recipient object with a new status will be returned.
 */
export const shareRecipientDelete = (variables: ShareRecipientDeleteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ResourceSharingShareRecipientResponseSingle,
    ShareRecipientDeleteError,
    undefined,
    {},
    {},
    ShareRecipientDeletePathParams
  >({ url: '/accounts/{accountId}/shares/{shareId}/recipients/{recipientId}', method: 'delete', ...variables, signal });

export type ShareRecipientsGetByIdPathParams = {
  accountId: Schemas.ResourceSharingAccountId;
  shareId: Schemas.ResourceSharingShareId;
  recipientId: Schemas.ResourceSharingRecipientId;
};

export type ShareRecipientsGetByIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
>;

export type ShareRecipientsGetByIdVariables = {
  pathParams: ShareRecipientsGetByIdPathParams;
} & FetcherExtraProps;

/**
 * Get share recipient by ID.
 */
export const shareRecipientsGetById = (variables: ShareRecipientsGetByIdVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ResourceSharingShareRecipientResponseSingle,
    ShareRecipientsGetByIdError,
    undefined,
    {},
    {},
    ShareRecipientsGetByIdPathParams
  >({ url: '/accounts/{accountId}/shares/{shareId}/recipients/{recipientId}', method: 'get', ...variables, signal });

export type ShareResourcesListPathParams = {
  accountId: Schemas.ResourceSharingAccountId;
  shareId: Schemas.ResourceSharingShareId;
};

export type ShareResourcesListQueryParams = {
  /**
   * Filter share resources by status.
   */
  status?: Schemas.ResourceSharingResourceStatus;
  /**
   * Filter share resources by resource_type.
   */
  resource_type?: Schemas.ResourceSharingResourceType;
  /**
   * Page number.
   *
   * @example 2
   * @minimum 0
   * @multipleOf 1
   */
  page?: number;
  /**
   * Number of objects to return per page.
   *
   * @example 20
   * @maximum 100
   * @minimum 0
   * @multipleOf 1
   */
  per_page?: number;
};

export type ShareResourcesListError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
>;

export type ShareResourcesListVariables = {
  pathParams: ShareResourcesListPathParams;
  queryParams?: ShareResourcesListQueryParams;
} & FetcherExtraProps;

/**
 * List share resources by share ID.
 */
export const shareResourcesList = (variables: ShareResourcesListVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ResourceSharingShareResourceResponseCollection,
    ShareResourcesListError,
    undefined,
    {},
    ShareResourcesListQueryParams,
    ShareResourcesListPathParams
  >({ url: '/accounts/{accountId}/shares/{shareId}/resources', method: 'get', ...variables, signal });

export type ShareResourceCreatePathParams = {
  accountId: Schemas.ResourceSharingAccountId;
  shareId: Schemas.ResourceSharingShareId;
};

export type ShareResourceCreateError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
>;

export type ShareResourceCreateVariables = {
  body: Schemas.ResourceSharingCreateShareResourceRequest;
  pathParams: ShareResourceCreatePathParams;
} & FetcherExtraProps;

export const shareResourceCreate = (variables: ShareResourceCreateVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ResourceSharingShareResourceResponseSingle,
    ShareResourceCreateError,
    Schemas.ResourceSharingCreateShareResourceRequest,
    {},
    {},
    ShareResourceCreatePathParams
  >({ url: '/accounts/{accountId}/shares/{shareId}/resources', method: 'post', ...variables, signal });

export type ShareResourceDeletePathParams = {
  accountId: Schemas.ResourceSharingAccountId;
  shareId: Schemas.ResourceSharingShareId;
  resourceId: Schemas.ResourceSharingResourceId;
};

export type ShareResourceDeleteError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
>;

export type ShareResourceDeleteVariables = {
  pathParams: ShareResourceDeletePathParams;
} & FetcherExtraProps;

/**
 * Deletion is not immediate, an updated share resource object with a new status will be returned.
 */
export const shareResourceDelete = (variables: ShareResourceDeleteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ResourceSharingShareResourceResponseSingle,
    ShareResourceDeleteError,
    undefined,
    {},
    {},
    ShareResourceDeletePathParams
  >({ url: '/accounts/{accountId}/shares/{shareId}/resources/{resourceId}', method: 'delete', ...variables, signal });

export type ShareResourcesGetByIdPathParams = {
  accountId: Schemas.ResourceSharingAccountId;
  shareId: Schemas.ResourceSharingShareId;
  resourceId: Schemas.ResourceSharingResourceId;
};

export type ShareResourcesGetByIdError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
>;

export type ShareResourcesGetByIdVariables = {
  pathParams: ShareResourcesGetByIdPathParams;
} & FetcherExtraProps;

/**
 * Get share resource by ID.
 */
export const shareResourcesGetById = (variables: ShareResourcesGetByIdVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ResourceSharingShareResourceResponseSingle,
    ShareResourcesGetByIdError,
    undefined,
    {},
    {},
    ShareResourcesGetByIdPathParams
  >({ url: '/accounts/{accountId}/shares/{shareId}/resources/{resourceId}', method: 'get', ...variables, signal });

export type ShareResourceUpdatePathParams = {
  accountId: Schemas.ResourceSharingAccountId;
  shareId: Schemas.ResourceSharingShareId;
  resourceId: Schemas.ResourceSharingResourceId;
};

export type ShareResourceUpdateError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
>;

export type ShareResourceUpdateVariables = {
  body: Schemas.ResourceSharingUpdateShareResourceRequest;
  pathParams: ShareResourceUpdatePathParams;
} & FetcherExtraProps;

/**
 * Update is not immediate, an updated share resource object with a new status will be returned.
 */
export const shareResourceUpdate = (variables: ShareResourceUpdateVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ResourceSharingShareResourceResponseSingle,
    ShareResourceUpdateError,
    Schemas.ResourceSharingUpdateShareResourceRequest,
    {},
    {},
    ShareResourceUpdatePathParams
  >({ url: '/accounts/{accountId}/shares/{shareId}/resources/{resourceId}', method: 'put', ...variables, signal });

export type WorkersKvRequestAnalyticsQueryRequestAnalyticsPathParams = {
  accountId: Schemas.WorkersKvIdentifier;
};

export type WorkersKvRequestAnalyticsQueryRequestAnalyticsQueryParams = {
  /**
   * For specifying result metrics.
   */
  query?: {
    /**
     * Can be used to break down the data by given attributes.
     *
     * @default []
     * @example accountId
     * @example responseCode
     */
    dimensions?: ('accountId' | 'responseCode' | 'requestType')[];
    /**
     * Used to filter rows by one or more dimensions. Filters can be combined using OR and AND boolean logic. AND takes precedence over OR in all the expressions. The OR operator is defined using a comma (,) or OR keyword surrounded by whitespace. The AND operator is defined using a semicolon (;) or AND keyword surrounded by whitespace. Note that the semicolon is a reserved character in URLs (rfc1738) and needs to be percent-encoded as %3B. Comparison options are:
     *
     * Operator                  | Name                            | URL Encoded
     * --------------------------|---------------------------------|--------------------------
     * ==                        | Equals                          | %3D%3D
     * !=                        | Does not equals                 | !%3D
     * >                        | Greater Than                    | %3E
     * <                         | Less Than                       | %3C
     * >=                       | Greater than or equal to        | %3E%3D
     * <=                        | Less than or equal to           | %3C%3D     .
     *
     * @default ""
     * @example requestType==read AND responseCode!=200
     */
    filters?: string;
    /**
     * Limit number of returned metrics.
     *
     * @default 10000
     */
    limit?: number;
    /**
     * One or more metrics to compute.
     *
     * @default ["requests"]
     * @example requests
     * @example readKiB
     */
    metrics?: ('requests' | 'writeKiB' | 'readKiB')[];
    /**
     * Start of time interval to query, defaults to 6 hours before request received.
     *
     * @default <6 hours ago>
     * @example 2019-01-02T02:20:00Z
     * @format date-time
     */
    since?: string;
    /**
     * Array of dimensions or metrics to sort by, each dimension/metric may be prefixed by - (descending) or + (ascending).
     *
     * @default []
     * @example +requests
     * @example -responseCode
     */
    sort?: string[];
    /**
     * End of time interval to query, defaults to current time.
     *
     * @default <now>
     * @example 2019-01-02T03:20:00Z
     * @format date-time
     */
    until?: string;
  };
};

export type WorkersKvRequestAnalyticsQueryRequestAnalyticsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.WorkersKvApiResponseCommon & {
    result?: Schemas.WorkersKvResult;
  }) &
    Schemas.WorkersKvApiResponseCommonFailure;
}>;

export type WorkersKvRequestAnalyticsQueryRequestAnalyticsResponse = Schemas.WorkersKvApiResponseCommon & {
  result?: Schemas.WorkersKvSchemasResult;
};

export type WorkersKvRequestAnalyticsQueryRequestAnalyticsVariables = {
  pathParams: WorkersKvRequestAnalyticsQueryRequestAnalyticsPathParams;
  queryParams?: WorkersKvRequestAnalyticsQueryRequestAnalyticsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves Workers KV request metrics for the given account.
 */
export const workersKvRequestAnalyticsQueryRequestAnalytics = (
  variables: WorkersKvRequestAnalyticsQueryRequestAnalyticsVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersKvRequestAnalyticsQueryRequestAnalyticsResponse,
    WorkersKvRequestAnalyticsQueryRequestAnalyticsError,
    undefined,
    {},
    WorkersKvRequestAnalyticsQueryRequestAnalyticsQueryParams,
    WorkersKvRequestAnalyticsQueryRequestAnalyticsPathParams
  >({ url: '/accounts/{accountId}/storage/analytics', method: 'get', ...variables, signal });

export type WorkersKvStoredDataAnalyticsQueryStoredDataAnalyticsPathParams = {
  accountId: Schemas.WorkersKvIdentifier;
};

export type WorkersKvStoredDataAnalyticsQueryStoredDataAnalyticsQueryParams = {
  /**
   * For specifying result metrics.
   */
  query?: {
    /**
     * Can be used to break down the data by given attributes.
     *
     * @default []
     * @example namespaceId
     */
    dimensions?: 'namespaceId'[];
    /**
     * Used to filter rows by one or more dimensions. Filters can be combined using OR and AND boolean logic. AND takes precedence over OR in all the expressions. The OR operator is defined using a comma (,) or OR keyword surrounded by whitespace. The AND operator is defined using a semicolon (;) or AND keyword surrounded by whitespace. Note that the semicolon is a reserved character in URLs (rfc1738) and needs to be percent-encoded as %3B. Comparison options are:
     *
     * Operator                  | Name                            | URL Encoded
     * --------------------------|---------------------------------|--------------------------
     * ==                        | Equals                          | %3D%3D
     * !=                        | Does not equals                 | !%3D
     * >                        | Greater Than                    | %3E
     * <                         | Less Than                       | %3C
     * >=                       | Greater than or equal to        | %3E%3D
     * <=                        | Less than or equal to           | %3C%3D     .
     *
     * @default ""
     * @example namespaceId==a4e8cbb7-1b58-4990-925e-e026d40c4c64
     */
    filters?: string;
    /**
     * Limit number of returned metrics.
     *
     * @default 10000
     */
    limit?: number;
    /**
     * One or more metrics to compute.
     *
     * @default ["storedBytes"]
     * @example storedBytes
     * @example storedKeys
     */
    metrics?: ('storedBytes' | 'storedKeys')[];
    /**
     * Start of time interval to query, defaults to 6 hours before request received.
     *
     * @default <6 hours ago>
     * @example 2019-01-02T02:20:00Z
     * @format date-time
     */
    since?: string;
    /**
     * Array of dimensions or metrics to sort by, each dimension/metric may be prefixed by - (descending) or + (ascending).
     *
     * @default []
     * @example +storedBytes
     * @example -namespaceId
     */
    sort?: string[];
    /**
     * End of time interval to query, defaults to current time.
     *
     * @default <now>
     * @example 2019-01-02T03:20:00Z
     * @format date-time
     */
    until?: string;
  };
};

export type WorkersKvStoredDataAnalyticsQueryStoredDataAnalyticsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.WorkersKvApiResponseCommon & {
    result?: Schemas.WorkersKvResult;
  }) &
    Schemas.WorkersKvApiResponseCommonFailure;
}>;

export type WorkersKvStoredDataAnalyticsQueryStoredDataAnalyticsResponse = Schemas.WorkersKvApiResponseCommon & {
  result?: Schemas.WorkersKvComponentsSchemasResult;
};

export type WorkersKvStoredDataAnalyticsQueryStoredDataAnalyticsVariables = {
  pathParams: WorkersKvStoredDataAnalyticsQueryStoredDataAnalyticsPathParams;
  queryParams?: WorkersKvStoredDataAnalyticsQueryStoredDataAnalyticsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves Workers KV stored data metrics for the given account.
 */
export const workersKvStoredDataAnalyticsQueryStoredDataAnalytics = (
  variables: WorkersKvStoredDataAnalyticsQueryStoredDataAnalyticsVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersKvStoredDataAnalyticsQueryStoredDataAnalyticsResponse,
    WorkersKvStoredDataAnalyticsQueryStoredDataAnalyticsError,
    undefined,
    {},
    WorkersKvStoredDataAnalyticsQueryStoredDataAnalyticsQueryParams,
    WorkersKvStoredDataAnalyticsQueryStoredDataAnalyticsPathParams
  >({ url: '/accounts/{accountId}/storage/analytics/stored', method: 'get', ...variables, signal });

export type WorkersKvNamespaceListNamespacesPathParams = {
  accountId: Schemas.WorkersKvIdentifier;
};

export type WorkersKvNamespaceListNamespacesQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 100
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example id
   */
  order?: 'id' | 'title';
  /**
   * @example asc
   */
  direction?: 'asc' | 'desc';
};

export type WorkersKvNamespaceListNamespacesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersKvApiResponseCommonFailure;
}>;

export type WorkersKvNamespaceListNamespacesResponse = Schemas.WorkersKvApiResponseCollection & {
  result?: Schemas.WorkersKvNamespace[];
};

export type WorkersKvNamespaceListNamespacesVariables = {
  pathParams: WorkersKvNamespaceListNamespacesPathParams;
  queryParams?: WorkersKvNamespaceListNamespacesQueryParams;
} & FetcherExtraProps;

/**
 * Returns the namespaces owned by an account.
 */
export const workersKvNamespaceListNamespaces = (
  variables: WorkersKvNamespaceListNamespacesVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersKvNamespaceListNamespacesResponse,
    WorkersKvNamespaceListNamespacesError,
    undefined,
    {},
    WorkersKvNamespaceListNamespacesQueryParams,
    WorkersKvNamespaceListNamespacesPathParams
  >({ url: '/accounts/{accountId}/storage/kv/namespaces', method: 'get', ...variables, signal });

export type WorkersKvNamespaceCreateANamespacePathParams = {
  accountId: Schemas.WorkersKvIdentifier;
};

export type WorkersKvNamespaceCreateANamespaceError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersKvApiResponseCommonFailure;
}>;

export type WorkersKvNamespaceCreateANamespaceResponse = Schemas.WorkersKvApiResponseCommon & {
  result?: Schemas.WorkersKvNamespace;
};

export type WorkersKvNamespaceCreateANamespaceVariables = {
  body: Schemas.WorkersKvCreateRenameNamespaceBody;
  pathParams: WorkersKvNamespaceCreateANamespacePathParams;
} & FetcherExtraProps;

/**
 * Creates a namespace under the given title. A `400` is returned if the account already owns a namespace with this title. A namespace must be explicitly deleted to be replaced.
 */
export const workersKvNamespaceCreateANamespace = (
  variables: WorkersKvNamespaceCreateANamespaceVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersKvNamespaceCreateANamespaceResponse,
    WorkersKvNamespaceCreateANamespaceError,
    Schemas.WorkersKvCreateRenameNamespaceBody,
    {},
    {},
    WorkersKvNamespaceCreateANamespacePathParams
  >({ url: '/accounts/{accountId}/storage/kv/namespaces', method: 'post', ...variables, signal });

export type WorkersKvNamespaceRemoveANamespacePathParams = {
  namespaceId: Schemas.WorkersKvNamespaceIdentifier;
  accountId: Schemas.WorkersKvIdentifier;
};

export type WorkersKvNamespaceRemoveANamespaceError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersKvApiResponseCommonFailure;
}>;

export type WorkersKvNamespaceRemoveANamespaceVariables = {
  pathParams: WorkersKvNamespaceRemoveANamespacePathParams;
} & FetcherExtraProps;

/**
 * Deletes the namespace corresponding to the given ID.
 */
export const workersKvNamespaceRemoveANamespace = (
  variables: WorkersKvNamespaceRemoveANamespaceVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersKvApiResponseCommonNoResult,
    WorkersKvNamespaceRemoveANamespaceError,
    undefined,
    {},
    {},
    WorkersKvNamespaceRemoveANamespacePathParams
  >({ url: '/accounts/{accountId}/storage/kv/namespaces/{namespaceId}', method: 'delete', ...variables, signal });

export type WorkersKvNamespaceGetANamespacePathParams = {
  namespaceId: Schemas.WorkersKvNamespaceIdentifier;
  accountId: Schemas.WorkersKvIdentifier;
};

export type WorkersKvNamespaceGetANamespaceError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersKvApiResponseCommonFailure;
}>;

export type WorkersKvNamespaceGetANamespaceResponse = Schemas.WorkersKvApiResponseCommon & {
  result?: Schemas.WorkersKvNamespace;
};

export type WorkersKvNamespaceGetANamespaceVariables = {
  pathParams: WorkersKvNamespaceGetANamespacePathParams;
} & FetcherExtraProps;

/**
 * Get the namespace corresponding to the given ID.
 */
export const workersKvNamespaceGetANamespace = (
  variables: WorkersKvNamespaceGetANamespaceVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersKvNamespaceGetANamespaceResponse,
    WorkersKvNamespaceGetANamespaceError,
    undefined,
    {},
    {},
    WorkersKvNamespaceGetANamespacePathParams
  >({ url: '/accounts/{accountId}/storage/kv/namespaces/{namespaceId}', method: 'get', ...variables, signal });

export type WorkersKvNamespaceRenameANamespacePathParams = {
  namespaceId: Schemas.WorkersKvNamespaceIdentifier;
  accountId: Schemas.WorkersKvIdentifier;
};

export type WorkersKvNamespaceRenameANamespaceError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersKvApiResponseCommonFailure;
}>;

export type WorkersKvNamespaceRenameANamespaceVariables = {
  body: Schemas.WorkersKvCreateRenameNamespaceBody;
  pathParams: WorkersKvNamespaceRenameANamespacePathParams;
} & FetcherExtraProps;

/**
 * Modifies a namespace's title.
 */
export const workersKvNamespaceRenameANamespace = (
  variables: WorkersKvNamespaceRenameANamespaceVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersKvApiResponseCommonNoResult,
    WorkersKvNamespaceRenameANamespaceError,
    Schemas.WorkersKvCreateRenameNamespaceBody,
    {},
    {},
    WorkersKvNamespaceRenameANamespacePathParams
  >({ url: '/accounts/{accountId}/storage/kv/namespaces/{namespaceId}', method: 'put', ...variables, signal });

export type WorkersKvNamespaceDeleteMultipleKeyValuePairsDeprecatedPathParams = {
  namespaceId: Schemas.WorkersKvNamespaceIdentifier;
  accountId: Schemas.WorkersKvIdentifier;
};

export type WorkersKvNamespaceDeleteMultipleKeyValuePairsDeprecatedError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersKvApiResponseCommonNoResult & {
    result?: Schemas.WorkersKvBulkResult;
  };
}>;

export type WorkersKvNamespaceDeleteMultipleKeyValuePairsDeprecatedResponse =
  Schemas.WorkersKvApiResponseCommonNoResult & {
    result?: Schemas.WorkersKvBulkResult;
  };

export type WorkersKvNamespaceDeleteMultipleKeyValuePairsDeprecatedVariables = {
  body?: Schemas.WorkersKvBulkDelete;
  pathParams: WorkersKvNamespaceDeleteMultipleKeyValuePairsDeprecatedPathParams;
} & FetcherExtraProps;

/**
 * Remove multiple KV pairs from the namespace. Body should be an array of up to 10,000 keys to be removed.
 */
export const workersKvNamespaceDeleteMultipleKeyValuePairsDeprecated = (
  variables: WorkersKvNamespaceDeleteMultipleKeyValuePairsDeprecatedVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersKvNamespaceDeleteMultipleKeyValuePairsDeprecatedResponse,
    WorkersKvNamespaceDeleteMultipleKeyValuePairsDeprecatedError,
    Schemas.WorkersKvBulkDelete,
    {},
    {},
    WorkersKvNamespaceDeleteMultipleKeyValuePairsDeprecatedPathParams
  >({ url: '/accounts/{accountId}/storage/kv/namespaces/{namespaceId}/bulk', method: 'delete', ...variables, signal });

export type WorkersKvNamespaceWriteMultipleKeyValuePairsPathParams = {
  namespaceId: Schemas.WorkersKvNamespaceIdentifier;
  accountId: Schemas.WorkersKvIdentifier;
};

export type WorkersKvNamespaceWriteMultipleKeyValuePairsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersKvApiResponseCommonNoResult & {
    result?: Schemas.WorkersKvBulkResult;
  };
}>;

export type WorkersKvNamespaceWriteMultipleKeyValuePairsResponse = Schemas.WorkersKvApiResponseCommonNoResult & {
  result?: Schemas.WorkersKvBulkResult;
};

export type WorkersKvNamespaceWriteMultipleKeyValuePairsVariables = {
  body: Schemas.WorkersKvBulkWrite;
  pathParams: WorkersKvNamespaceWriteMultipleKeyValuePairsPathParams;
} & FetcherExtraProps;

/**
 * Write multiple keys and values at once. Body should be an array of up to 10,000 key-value pairs to be stored, along with optional expiration information. Existing values and expirations will be overwritten. If neither `expiration` nor `expiration_ttl` is specified, the key-value pair will never expire. If both are set, `expiration_ttl` is used and `expiration` is ignored. The entire request size must be 100 megabytes or less.
 */
export const workersKvNamespaceWriteMultipleKeyValuePairs = (
  variables: WorkersKvNamespaceWriteMultipleKeyValuePairsVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersKvNamespaceWriteMultipleKeyValuePairsResponse,
    WorkersKvNamespaceWriteMultipleKeyValuePairsError,
    Schemas.WorkersKvBulkWrite,
    {},
    {},
    WorkersKvNamespaceWriteMultipleKeyValuePairsPathParams
  >({ url: '/accounts/{accountId}/storage/kv/namespaces/{namespaceId}/bulk', method: 'put', ...variables, signal });

export type WorkersKvNamespaceDeleteMultipleKeyValuePairsPathParams = {
  namespaceId: Schemas.WorkersKvNamespaceIdentifier;
  accountId: Schemas.WorkersKvIdentifier;
};

export type WorkersKvNamespaceDeleteMultipleKeyValuePairsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersKvApiResponseCommonNoResult & {
    result?: Schemas.WorkersKvBulkResult;
  };
}>;

export type WorkersKvNamespaceDeleteMultipleKeyValuePairsResponse = Schemas.WorkersKvApiResponseCommonNoResult & {
  result?: Schemas.WorkersKvBulkResult;
};

export type WorkersKvNamespaceDeleteMultipleKeyValuePairsVariables = {
  body?: Schemas.WorkersKvBulkDelete;
  pathParams: WorkersKvNamespaceDeleteMultipleKeyValuePairsPathParams;
} & FetcherExtraProps;

/**
 * Remove multiple KV pairs from the namespace. Body should be an array of up to 10,000 keys to be removed.
 */
export const workersKvNamespaceDeleteMultipleKeyValuePairs = (
  variables: WorkersKvNamespaceDeleteMultipleKeyValuePairsVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersKvNamespaceDeleteMultipleKeyValuePairsResponse,
    WorkersKvNamespaceDeleteMultipleKeyValuePairsError,
    Schemas.WorkersKvBulkDelete,
    {},
    {},
    WorkersKvNamespaceDeleteMultipleKeyValuePairsPathParams
  >({
    url: '/accounts/{accountId}/storage/kv/namespaces/{namespaceId}/bulk/delete',
    method: 'post',
    ...variables,
    signal
  });

export type WorkersKvNamespaceListANamespaceSKeysPathParams = {
  namespaceId: Schemas.WorkersKvNamespaceIdentifier;
  accountId: Schemas.WorkersKvIdentifier;
};

export type WorkersKvNamespaceListANamespaceSKeysQueryParams = {
  /**
   * @default 1000
   * @maximum 1000
   * @minimum 10
   */
  limit?: number;
  /**
   * @example My-Prefix
   */
  prefix?: string;
  /**
   * @example 6Ck1la0VxJ0djhidm1MdX2FyDGxLKVeeHZZmORS_8XeSuhz9SjIJRaSa2lnsF01tQOHrfTGAP3R5X1Kv5iVUuMbNKhWNAXHOl6ePB0TUL8nw
   */
  cursor?: string;
};

export type WorkersKvNamespaceListANamespaceSKeysError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersKvApiResponseCommonFailure;
}>;

export type WorkersKvNamespaceListANamespaceSKeysResponse = Schemas.WorkersKvApiResponseCommon & {
  result?: Schemas.WorkersKvKey[];
  result_info?: {
    /**
     * Total results returned based on your list parameters.
     *
     * @example 1
     */
    count?: number;
    cursor?: Schemas.WorkersKvCursor;
  };
};

export type WorkersKvNamespaceListANamespaceSKeysVariables = {
  pathParams: WorkersKvNamespaceListANamespaceSKeysPathParams;
  queryParams?: WorkersKvNamespaceListANamespaceSKeysQueryParams;
} & FetcherExtraProps;

/**
 * Lists a namespace's keys.
 */
export const workersKvNamespaceListANamespaceSKeys = (
  variables: WorkersKvNamespaceListANamespaceSKeysVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersKvNamespaceListANamespaceSKeysResponse,
    WorkersKvNamespaceListANamespaceSKeysError,
    undefined,
    {},
    WorkersKvNamespaceListANamespaceSKeysQueryParams,
    WorkersKvNamespaceListANamespaceSKeysPathParams
  >({ url: '/accounts/{accountId}/storage/kv/namespaces/{namespaceId}/keys', method: 'get', ...variables, signal });

export type WorkersKvNamespaceReadTheMetadataForAKeyPathParams = {
  keyName: Schemas.WorkersKvKeyName;
  namespaceId: Schemas.WorkersKvNamespaceIdentifier;
  accountId: Schemas.WorkersKvIdentifier;
};

export type WorkersKvNamespaceReadTheMetadataForAKeyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersKvApiResponseCommonFailure;
}>;

export type WorkersKvNamespaceReadTheMetadataForAKeyResponse = Schemas.WorkersKvApiResponseCommon & {
  result?: Schemas.WorkersKvListMetadata;
};

export type WorkersKvNamespaceReadTheMetadataForAKeyVariables = {
  pathParams: WorkersKvNamespaceReadTheMetadataForAKeyPathParams;
} & FetcherExtraProps;

/**
 * Returns the metadata associated with the given key in the given namespace. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name.
 */
export const workersKvNamespaceReadTheMetadataForAKey = (
  variables: WorkersKvNamespaceReadTheMetadataForAKeyVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkersKvNamespaceReadTheMetadataForAKeyResponse,
    WorkersKvNamespaceReadTheMetadataForAKeyError,
    undefined,
    {},
    {},
    WorkersKvNamespaceReadTheMetadataForAKeyPathParams
  >({
    url: '/accounts/{accountId}/storage/kv/namespaces/{namespaceId}/metadata/{keyName}',
    method: 'get',
    ...variables,
    signal
  });

export type WorkersKvNamespaceDeleteKeyValuePairPathParams = {
  keyName: Schemas.WorkersKvKeyName;
  namespaceId: Schemas.WorkersKvNamespaceIdentifier;
  accountId: Schemas.WorkersKvIdentifier;
};

export type WorkersKvNamespaceDeleteKeyValuePairError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersKvApiResponseCommonFailure;
}>;

export type WorkersKvNamespaceDeleteKeyValuePairVariables = {
  pathParams: WorkersKvNamespaceDeleteKeyValuePairPathParams;
} & FetcherExtraProps;

/**
 * Remove a KV pair from the namespace. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name.
 */
export const workersKvNamespaceDeleteKeyValuePair = (
  variables: WorkersKvNamespaceDeleteKeyValuePairVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersKvApiResponseCommonNoResult,
    WorkersKvNamespaceDeleteKeyValuePairError,
    undefined,
    {},
    {},
    WorkersKvNamespaceDeleteKeyValuePairPathParams
  >({
    url: '/accounts/{accountId}/storage/kv/namespaces/{namespaceId}/values/{keyName}',
    method: 'delete',
    ...variables,
    signal
  });

export type WorkersKvNamespaceReadKeyValuePairPathParams = {
  keyName: Schemas.WorkersKvKeyName;
  namespaceId: Schemas.WorkersKvNamespaceIdentifier;
  accountId: Schemas.WorkersKvIdentifier;
};

export type WorkersKvNamespaceReadKeyValuePairError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersKvApiResponseCommonFailure;
}>;

export type WorkersKvNamespaceReadKeyValuePairVariables = {
  pathParams: WorkersKvNamespaceReadKeyValuePairPathParams;
} & FetcherExtraProps;

/**
 * Returns the value associated with the given key in the given namespace. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name. If the KV-pair is set to expire at some point, the expiration time as measured in seconds since the UNIX epoch will be returned in the `expiration` response header.
 */
export const workersKvNamespaceReadKeyValuePair = (
  variables: WorkersKvNamespaceReadKeyValuePairVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersKvValue,
    WorkersKvNamespaceReadKeyValuePairError,
    undefined,
    {},
    {},
    WorkersKvNamespaceReadKeyValuePairPathParams
  >({
    url: '/accounts/{accountId}/storage/kv/namespaces/{namespaceId}/values/{keyName}',
    method: 'get',
    ...variables,
    signal
  });

export type WorkersKvNamespaceWriteKeyValuePairWithMetadataPathParams = {
  keyName: Schemas.WorkersKvKeyName;
  namespaceId: Schemas.WorkersKvNamespaceIdentifier;
  accountId: Schemas.WorkersKvIdentifier;
};

export type WorkersKvNamespaceWriteKeyValuePairWithMetadataQueryParams = {
  expiration?: Schemas.WorkersKvExpiration;
  expiration_ttl?: Schemas.WorkersKvExpirationTtl;
};

export type WorkersKvNamespaceWriteKeyValuePairWithMetadataError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersKvApiResponseCommonFailure;
}>;

export type WorkersKvNamespaceWriteKeyValuePairWithMetadataVariables = {
  body?: Schemas.WorkersKvValue;
  pathParams: WorkersKvNamespaceWriteKeyValuePairWithMetadataPathParams;
  queryParams?: WorkersKvNamespaceWriteKeyValuePairWithMetadataQueryParams;
} & FetcherExtraProps;

/**
 * Write a value identified by a key. Use URL-encoding to use special characters (for example, `:`, `!`, `%`) in the key name. Body should be the value to be stored. If JSON metadata to be associated with the key/value pair is needed, use `multipart/form-data` content type for your PUT request (see dropdown below in `REQUEST BODY SCHEMA`). Existing values, expirations, and metadata will be overwritten. If neither `expiration` nor `expiration_ttl` is specified, the key-value pair will never expire. If both are set, `expiration_ttl` is used and `expiration` is ignored.
 */
export const workersKvNamespaceWriteKeyValuePairWithMetadata = (
  variables: WorkersKvNamespaceWriteKeyValuePairWithMetadataVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersKvApiResponseCommonNoResult,
    WorkersKvNamespaceWriteKeyValuePairWithMetadataError,
    Schemas.WorkersKvValue,
    {},
    WorkersKvNamespaceWriteKeyValuePairWithMetadataQueryParams,
    WorkersKvNamespaceWriteKeyValuePairWithMetadataPathParams
  >({
    url: '/accounts/{accountId}/storage/kv/namespaces/{namespaceId}/values/{keyName}',
    method: 'put',
    ...variables,
    signal
  });

export type StreamVideosListVideosPathParams = {
  accountId: Schemas.StreamAccountIdentifier;
};

export type StreamVideosListVideosQueryParams = {
  status?: Schemas.StreamMediaState;
  creator?: Schemas.StreamCreator;
  type?: Schemas.StreamType;
  asc?: Schemas.StreamAsc;
  search?: Schemas.StreamSearch;
  start?: Schemas.StreamStart;
  end?: Schemas.StreamEnd;
  include_counts?: Schemas.StreamIncludeCounts;
};

export type StreamVideosListVideosError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamVideosListVideosVariables = {
  pathParams: StreamVideosListVideosPathParams;
  queryParams?: StreamVideosListVideosQueryParams;
} & FetcherExtraProps;

/**
 * Lists up to 1000 videos from a single request. For a specific range, refer to the optional parameters.
 */
export const streamVideosListVideos = (variables: StreamVideosListVideosVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.StreamVideoResponseCollection,
    StreamVideosListVideosError,
    undefined,
    {},
    StreamVideosListVideosQueryParams,
    StreamVideosListVideosPathParams
  >({ url: '/accounts/{accountId}/stream', method: 'get', ...variables, signal });

export type StreamVideosInitiateVideoUploadsUsingTusPathParams = {
  accountId: Schemas.StreamAccountIdentifier;
};

export type StreamVideosInitiateVideoUploadsUsingTusHeaders = {
  ['Tus-Resumable']: Schemas.StreamTusResumable;
  ['Upload-Creator']?: Schemas.StreamCreator;
  ['Upload-Length']: Schemas.StreamUploadLength;
  ['Upload-Metadata']?: Schemas.StreamUploadMetadata;
};

export type StreamVideosInitiateVideoUploadsUsingTusError = Fetcher.ErrorWrapper<undefined>;

export type StreamVideosInitiateVideoUploadsUsingTusVariables = {
  headers: StreamVideosInitiateVideoUploadsUsingTusHeaders;
  pathParams: StreamVideosInitiateVideoUploadsUsingTusPathParams;
} & FetcherExtraProps;

/**
 * Initiates a video upload using the TUS protocol. On success, the server responds with a status code 201 (created) and includes a `location` header to indicate where the content should be uploaded. Refer to https://tus.io for protocol details.
 */
export const streamVideosInitiateVideoUploadsUsingTus = (
  variables: StreamVideosInitiateVideoUploadsUsingTusVariables,
  signal?: AbortSignal
) =>
  fetch<
    undefined,
    StreamVideosInitiateVideoUploadsUsingTusError,
    undefined,
    StreamVideosInitiateVideoUploadsUsingTusHeaders,
    {},
    StreamVideosInitiateVideoUploadsUsingTusPathParams
  >({ url: '/accounts/{accountId}/stream', method: 'post', ...variables, signal });

export type StreamVideoClippingClipVideosGivenAStartAndEndTimePathParams = {
  accountId: Schemas.StreamAccountIdentifier;
};

export type StreamVideoClippingClipVideosGivenAStartAndEndTimeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamVideoClippingClipVideosGivenAStartAndEndTimeVariables = {
  body: Schemas.StreamVideoClipStandard;
  pathParams: StreamVideoClippingClipVideosGivenAStartAndEndTimePathParams;
} & FetcherExtraProps;

/**
 * Clips a video based on the specified start and end times provided in seconds.
 */
export const streamVideoClippingClipVideosGivenAStartAndEndTime = (
  variables: StreamVideoClippingClipVideosGivenAStartAndEndTimeVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamClipResponseSingle,
    StreamVideoClippingClipVideosGivenAStartAndEndTimeError,
    Schemas.StreamVideoClipStandard,
    {},
    {},
    StreamVideoClippingClipVideosGivenAStartAndEndTimePathParams
  >({ url: '/accounts/{accountId}/stream/clip', method: 'post', ...variables, signal });

export type StreamVideosUploadVideosFromAUrlPathParams = {
  accountId: Schemas.StreamAccountIdentifier;
};

export type StreamVideosUploadVideosFromAUrlHeaders = {
  ['Upload-Creator']?: Schemas.StreamCreator;
  ['Upload-Metadata']?: Schemas.StreamUploadMetadata;
};

export type StreamVideosUploadVideosFromAUrlError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamVideosUploadVideosFromAUrlVariables = {
  body: Schemas.StreamVideoCopyRequest;
  headers?: StreamVideosUploadVideosFromAUrlHeaders;
  pathParams: StreamVideosUploadVideosFromAUrlPathParams;
} & FetcherExtraProps;

/**
 * Uploads a video to Stream from a provided URL.
 */
export const streamVideosUploadVideosFromAUrl = (
  variables: StreamVideosUploadVideosFromAUrlVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamVideoResponseSingle,
    StreamVideosUploadVideosFromAUrlError,
    Schemas.StreamVideoCopyRequest,
    StreamVideosUploadVideosFromAUrlHeaders,
    {},
    StreamVideosUploadVideosFromAUrlPathParams
  >({ url: '/accounts/{accountId}/stream/copy', method: 'post', ...variables, signal });

export type StreamVideosUploadVideosViaDirectUploadUrLsPathParams = {
  accountId: Schemas.StreamAccountIdentifier;
};

export type StreamVideosUploadVideosViaDirectUploadUrLsHeaders = {
  ['Upload-Creator']?: Schemas.StreamCreator;
};

export type StreamVideosUploadVideosViaDirectUploadUrLsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamVideosUploadVideosViaDirectUploadUrLsVariables = {
  body: Schemas.StreamDirectUploadRequest;
  headers?: StreamVideosUploadVideosViaDirectUploadUrLsHeaders;
  pathParams: StreamVideosUploadVideosViaDirectUploadUrLsPathParams;
} & FetcherExtraProps;

/**
 * Creates a direct upload that allows video uploads without an API key.
 */
export const streamVideosUploadVideosViaDirectUploadUrLs = (
  variables: StreamVideosUploadVideosViaDirectUploadUrLsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamDirectUploadResponse,
    StreamVideosUploadVideosViaDirectUploadUrLsError,
    Schemas.StreamDirectUploadRequest,
    StreamVideosUploadVideosViaDirectUploadUrLsHeaders,
    {},
    StreamVideosUploadVideosViaDirectUploadUrLsPathParams
  >({ url: '/accounts/{accountId}/stream/direct_upload', method: 'post', ...variables, signal });

export type StreamSigningKeysListSigningKeysPathParams = {
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamSigningKeysListSigningKeysError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamSigningKeysListSigningKeysVariables = {
  pathParams: StreamSigningKeysListSigningKeysPathParams;
} & FetcherExtraProps;

/**
 * Lists the video ID and creation date and time when a signing key was created.
 */
export const streamSigningKeysListSigningKeys = (
  variables: StreamSigningKeysListSigningKeysVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamKeyResponseCollection,
    StreamSigningKeysListSigningKeysError,
    undefined,
    {},
    {},
    StreamSigningKeysListSigningKeysPathParams
  >({ url: '/accounts/{accountId}/stream/keys', method: 'get', ...variables, signal });

export type StreamSigningKeysCreateSigningKeysPathParams = {
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamSigningKeysCreateSigningKeysError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamSigningKeysCreateSigningKeysVariables = {
  pathParams: StreamSigningKeysCreateSigningKeysPathParams;
} & FetcherExtraProps;

/**
 * Creates an RSA private key in PEM and JWK formats. Key files are only displayed once after creation. Keys are created, used, and deleted independently of videos, and every key can sign any video.
 */
export const streamSigningKeysCreateSigningKeys = (
  variables: StreamSigningKeysCreateSigningKeysVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamKeyGenerationResponse,
    StreamSigningKeysCreateSigningKeysError,
    undefined,
    {},
    {},
    StreamSigningKeysCreateSigningKeysPathParams
  >({ url: '/accounts/{accountId}/stream/keys', method: 'post', ...variables, signal });

export type StreamSigningKeysDeleteSigningKeysPathParams = {
  identifier: Schemas.StreamSchemasIdentifier;
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamSigningKeysDeleteSigningKeysError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamSigningKeysDeleteSigningKeysVariables = {
  pathParams: StreamSigningKeysDeleteSigningKeysPathParams;
} & FetcherExtraProps;

/**
 * Deletes signing keys and revokes all signed URLs generated with the key.
 */
export const streamSigningKeysDeleteSigningKeys = (
  variables: StreamSigningKeysDeleteSigningKeysVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamDeletedResponse,
    StreamSigningKeysDeleteSigningKeysError,
    undefined,
    {},
    {},
    StreamSigningKeysDeleteSigningKeysPathParams
  >({ url: '/accounts/{accountId}/stream/keys/{identifier}', method: 'delete', ...variables, signal });

export type StreamLiveInputsListLiveInputsPathParams = {
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamLiveInputsListLiveInputsQueryParams = {
  include_counts?: Schemas.StreamIncludeCounts;
};

export type StreamLiveInputsListLiveInputsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamLiveInputsListLiveInputsVariables = {
  pathParams: StreamLiveInputsListLiveInputsPathParams;
  queryParams?: StreamLiveInputsListLiveInputsQueryParams;
} & FetcherExtraProps;

/**
 * Lists the live inputs created for an account. To get the credentials needed to stream to a specific live input, request a single live input.
 */
export const streamLiveInputsListLiveInputs = (
  variables: StreamLiveInputsListLiveInputsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamLiveInputResponseCollection,
    StreamLiveInputsListLiveInputsError,
    undefined,
    {},
    StreamLiveInputsListLiveInputsQueryParams,
    StreamLiveInputsListLiveInputsPathParams
  >({ url: '/accounts/{accountId}/stream/live_inputs', method: 'get', ...variables, signal });

export type StreamLiveInputsCreateALiveInputPathParams = {
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamLiveInputsCreateALiveInputError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamLiveInputsCreateALiveInputVariables = {
  body?: Schemas.StreamCreateInputRequest;
  pathParams: StreamLiveInputsCreateALiveInputPathParams;
} & FetcherExtraProps;

/**
 * Creates a live input, and returns credentials that you or your users can use to stream live video to Cloudflare Stream.
 */
export const streamLiveInputsCreateALiveInput = (
  variables: StreamLiveInputsCreateALiveInputVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamLiveInputResponseSingle,
    StreamLiveInputsCreateALiveInputError,
    Schemas.StreamCreateInputRequest,
    {},
    {},
    StreamLiveInputsCreateALiveInputPathParams
  >({ url: '/accounts/{accountId}/stream/live_inputs', method: 'post', ...variables, signal });

export type StreamLiveInputsDeleteALiveInputPathParams = {
  liveInputIdentifier: Schemas.StreamLiveInputIdentifier;
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamLiveInputsDeleteALiveInputError = Fetcher.ErrorWrapper<undefined>;

export type StreamLiveInputsDeleteALiveInputVariables = {
  pathParams: StreamLiveInputsDeleteALiveInputPathParams;
} & FetcherExtraProps;

/**
 * Prevents a live input from being streamed to and makes the live input inaccessible to any future API calls.
 */
export const streamLiveInputsDeleteALiveInput = (
  variables: StreamLiveInputsDeleteALiveInputVariables,
  signal?: AbortSignal
) =>
  fetch<
    undefined,
    StreamLiveInputsDeleteALiveInputError,
    undefined,
    {},
    {},
    StreamLiveInputsDeleteALiveInputPathParams
  >({ url: '/accounts/{accountId}/stream/live_inputs/{liveInputIdentifier}', method: 'delete', ...variables, signal });

export type StreamLiveInputsRetrieveALiveInputPathParams = {
  liveInputIdentifier: Schemas.StreamLiveInputIdentifier;
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamLiveInputsRetrieveALiveInputError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamLiveInputsRetrieveALiveInputVariables = {
  pathParams: StreamLiveInputsRetrieveALiveInputPathParams;
} & FetcherExtraProps;

/**
 * Retrieves details of an existing live input.
 */
export const streamLiveInputsRetrieveALiveInput = (
  variables: StreamLiveInputsRetrieveALiveInputVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamLiveInputResponseSingle,
    StreamLiveInputsRetrieveALiveInputError,
    undefined,
    {},
    {},
    StreamLiveInputsRetrieveALiveInputPathParams
  >({ url: '/accounts/{accountId}/stream/live_inputs/{liveInputIdentifier}', method: 'get', ...variables, signal });

export type StreamLiveInputsUpdateALiveInputPathParams = {
  liveInputIdentifier: Schemas.StreamLiveInputIdentifier;
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamLiveInputsUpdateALiveInputError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamLiveInputsUpdateALiveInputVariables = {
  body?: Schemas.StreamUpdateInputRequest;
  pathParams: StreamLiveInputsUpdateALiveInputPathParams;
} & FetcherExtraProps;

/**
 * Updates a specified live input.
 */
export const streamLiveInputsUpdateALiveInput = (
  variables: StreamLiveInputsUpdateALiveInputVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamLiveInputResponseSingle,
    StreamLiveInputsUpdateALiveInputError,
    Schemas.StreamUpdateInputRequest,
    {},
    {},
    StreamLiveInputsUpdateALiveInputPathParams
  >({ url: '/accounts/{accountId}/stream/live_inputs/{liveInputIdentifier}', method: 'put', ...variables, signal });

export type StreamLiveInputsListAllOutputsAssociatedWithASpecifiedLiveInputPathParams = {
  liveInputIdentifier: Schemas.StreamLiveInputIdentifier;
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamLiveInputsListAllOutputsAssociatedWithASpecifiedLiveInputError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamLiveInputsListAllOutputsAssociatedWithASpecifiedLiveInputVariables = {
  pathParams: StreamLiveInputsListAllOutputsAssociatedWithASpecifiedLiveInputPathParams;
} & FetcherExtraProps;

/**
 * Retrieves all outputs associated with a specified live input.
 */
export const streamLiveInputsListAllOutputsAssociatedWithASpecifiedLiveInput = (
  variables: StreamLiveInputsListAllOutputsAssociatedWithASpecifiedLiveInputVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamOutputResponseCollection,
    StreamLiveInputsListAllOutputsAssociatedWithASpecifiedLiveInputError,
    undefined,
    {},
    {},
    StreamLiveInputsListAllOutputsAssociatedWithASpecifiedLiveInputPathParams
  >({
    url: '/accounts/{accountId}/stream/live_inputs/{liveInputIdentifier}/outputs',
    method: 'get',
    ...variables,
    signal
  });

export type StreamLiveInputsCreateANewOutputConnectedToALiveInputPathParams = {
  liveInputIdentifier: Schemas.StreamLiveInputIdentifier;
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamLiveInputsCreateANewOutputConnectedToALiveInputError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamLiveInputsCreateANewOutputConnectedToALiveInputVariables = {
  body: Schemas.StreamCreateOutputRequest;
  pathParams: StreamLiveInputsCreateANewOutputConnectedToALiveInputPathParams;
} & FetcherExtraProps;

/**
 * Creates a new output that can be used to simulcast or restream live video to other RTMP or SRT destinations. Outputs are always linked to a specific live input — one live input can have many outputs.
 */
export const streamLiveInputsCreateANewOutputConnectedToALiveInput = (
  variables: StreamLiveInputsCreateANewOutputConnectedToALiveInputVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamOutputResponseSingle,
    StreamLiveInputsCreateANewOutputConnectedToALiveInputError,
    Schemas.StreamCreateOutputRequest,
    {},
    {},
    StreamLiveInputsCreateANewOutputConnectedToALiveInputPathParams
  >({
    url: '/accounts/{accountId}/stream/live_inputs/{liveInputIdentifier}/outputs',
    method: 'post',
    ...variables,
    signal
  });

export type StreamLiveInputsDeleteAnOutputPathParams = {
  outputIdentifier: Schemas.StreamOutputIdentifier;
  liveInputIdentifier: Schemas.StreamLiveInputIdentifier;
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamLiveInputsDeleteAnOutputError = Fetcher.ErrorWrapper<undefined>;

export type StreamLiveInputsDeleteAnOutputVariables = {
  pathParams: StreamLiveInputsDeleteAnOutputPathParams;
} & FetcherExtraProps;

/**
 * Deletes an output and removes it from the associated live input.
 */
export const streamLiveInputsDeleteAnOutput = (
  variables: StreamLiveInputsDeleteAnOutputVariables,
  signal?: AbortSignal
) =>
  fetch<undefined, StreamLiveInputsDeleteAnOutputError, undefined, {}, {}, StreamLiveInputsDeleteAnOutputPathParams>({
    url: '/accounts/{accountId}/stream/live_inputs/{liveInputIdentifier}/outputs/{outputIdentifier}',
    method: 'delete',
    ...variables,
    signal
  });

export type StreamLiveInputsUpdateAnOutputPathParams = {
  outputIdentifier: Schemas.StreamOutputIdentifier;
  liveInputIdentifier: Schemas.StreamLiveInputIdentifier;
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamLiveInputsUpdateAnOutputError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamLiveInputsUpdateAnOutputVariables = {
  body: Schemas.StreamUpdateOutputRequest;
  pathParams: StreamLiveInputsUpdateAnOutputPathParams;
} & FetcherExtraProps;

/**
 * Updates the state of an output.
 */
export const streamLiveInputsUpdateAnOutput = (
  variables: StreamLiveInputsUpdateAnOutputVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamOutputResponseSingle,
    StreamLiveInputsUpdateAnOutputError,
    Schemas.StreamUpdateOutputRequest,
    {},
    {},
    StreamLiveInputsUpdateAnOutputPathParams
  >({
    url: '/accounts/{accountId}/stream/live_inputs/{liveInputIdentifier}/outputs/{outputIdentifier}',
    method: 'put',
    ...variables,
    signal
  });

export type StreamVideosStorageUsagePathParams = {
  accountId: Schemas.StreamAccountIdentifier;
};

export type StreamVideosStorageUsageQueryParams = {
  creator?: Schemas.StreamCreator;
};

export type StreamVideosStorageUsageError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamVideosStorageUsageVariables = {
  pathParams: StreamVideosStorageUsagePathParams;
  queryParams?: StreamVideosStorageUsageQueryParams;
} & FetcherExtraProps;

/**
 * Returns information about an account's storage use.
 */
export const streamVideosStorageUsage = (variables: StreamVideosStorageUsageVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.StreamStorageUseResponse,
    StreamVideosStorageUsageError,
    undefined,
    {},
    StreamVideosStorageUsageQueryParams,
    StreamVideosStorageUsagePathParams
  >({ url: '/accounts/{accountId}/stream/storage-usage', method: 'get', ...variables, signal });

export type StreamWatermarkProfileListWatermarkProfilesPathParams = {
  accountId: Schemas.StreamAccountIdentifier;
};

export type StreamWatermarkProfileListWatermarkProfilesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamWatermarkProfileListWatermarkProfilesVariables = {
  pathParams: StreamWatermarkProfileListWatermarkProfilesPathParams;
} & FetcherExtraProps;

/**
 * Lists all watermark profiles for an account.
 */
export const streamWatermarkProfileListWatermarkProfiles = (
  variables: StreamWatermarkProfileListWatermarkProfilesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamWatermarkResponseCollection,
    StreamWatermarkProfileListWatermarkProfilesError,
    undefined,
    {},
    {},
    StreamWatermarkProfileListWatermarkProfilesPathParams
  >({ url: '/accounts/{accountId}/stream/watermarks', method: 'get', ...variables, signal });

export type StreamWatermarkProfileCreateWatermarkProfilesViaBasicUploadPathParams = {
  accountId: Schemas.StreamAccountIdentifier;
};

export type StreamWatermarkProfileCreateWatermarkProfilesViaBasicUploadError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamWatermarkProfileCreateWatermarkProfilesViaBasicUploadVariables = {
  body: Schemas.StreamWatermarkBasicUpload;
  pathParams: StreamWatermarkProfileCreateWatermarkProfilesViaBasicUploadPathParams;
} & FetcherExtraProps;

/**
 * Creates watermark profiles using a single `HTTP POST multipart/form-data` request.
 */
export const streamWatermarkProfileCreateWatermarkProfilesViaBasicUpload = (
  variables: StreamWatermarkProfileCreateWatermarkProfilesViaBasicUploadVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamWatermarkResponseSingle,
    StreamWatermarkProfileCreateWatermarkProfilesViaBasicUploadError,
    Schemas.StreamWatermarkBasicUpload,
    {},
    {},
    StreamWatermarkProfileCreateWatermarkProfilesViaBasicUploadPathParams
  >({ url: '/accounts/{accountId}/stream/watermarks', method: 'post', ...variables, signal });

export type StreamWatermarkProfileDeleteWatermarkProfilesPathParams = {
  identifier: Schemas.StreamWatermarkIdentifier;
  accountId: Schemas.StreamAccountIdentifier;
};

export type StreamWatermarkProfileDeleteWatermarkProfilesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamWatermarkProfileDeleteWatermarkProfilesResponse = Schemas.StreamApiResponseSingle & {
  /**
   * @example
   */
  result?: string;
};

export type StreamWatermarkProfileDeleteWatermarkProfilesVariables = {
  pathParams: StreamWatermarkProfileDeleteWatermarkProfilesPathParams;
} & FetcherExtraProps;

/**
 * Deletes a watermark profile.
 */
export const streamWatermarkProfileDeleteWatermarkProfiles = (
  variables: StreamWatermarkProfileDeleteWatermarkProfilesVariables,
  signal?: AbortSignal
) =>
  fetch<
    StreamWatermarkProfileDeleteWatermarkProfilesResponse,
    StreamWatermarkProfileDeleteWatermarkProfilesError,
    undefined,
    {},
    {},
    StreamWatermarkProfileDeleteWatermarkProfilesPathParams
  >({ url: '/accounts/{accountId}/stream/watermarks/{identifier}', method: 'delete', ...variables, signal });

export type StreamWatermarkProfileWatermarkProfileDetailsPathParams = {
  identifier: Schemas.StreamWatermarkIdentifier;
  accountId: Schemas.StreamAccountIdentifier;
};

export type StreamWatermarkProfileWatermarkProfileDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamWatermarkProfileWatermarkProfileDetailsVariables = {
  pathParams: StreamWatermarkProfileWatermarkProfileDetailsPathParams;
} & FetcherExtraProps;

/**
 * Retrieves details for a single watermark profile.
 */
export const streamWatermarkProfileWatermarkProfileDetails = (
  variables: StreamWatermarkProfileWatermarkProfileDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamWatermarkResponseSingle,
    StreamWatermarkProfileWatermarkProfileDetailsError,
    undefined,
    {},
    {},
    StreamWatermarkProfileWatermarkProfileDetailsPathParams
  >({ url: '/accounts/{accountId}/stream/watermarks/{identifier}', method: 'get', ...variables, signal });

export type StreamWebhookDeleteWebhooksPathParams = {
  accountId: Schemas.StreamAccountIdentifier;
};

export type StreamWebhookDeleteWebhooksError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamWebhookDeleteWebhooksVariables = {
  pathParams: StreamWebhookDeleteWebhooksPathParams;
} & FetcherExtraProps;

/**
 * Deletes a webhook.
 */
export const streamWebhookDeleteWebhooks = (variables: StreamWebhookDeleteWebhooksVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.StreamDeletedResponse,
    StreamWebhookDeleteWebhooksError,
    undefined,
    {},
    {},
    StreamWebhookDeleteWebhooksPathParams
  >({ url: '/accounts/{accountId}/stream/webhook', method: 'delete', ...variables, signal });

export type StreamWebhookViewWebhooksPathParams = {
  accountId: Schemas.StreamAccountIdentifier;
};

export type StreamWebhookViewWebhooksError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamWebhookViewWebhooksVariables = {
  pathParams: StreamWebhookViewWebhooksPathParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of webhooks.
 */
export const streamWebhookViewWebhooks = (variables: StreamWebhookViewWebhooksVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.StreamWebhookResponseSingle,
    StreamWebhookViewWebhooksError,
    undefined,
    {},
    {},
    StreamWebhookViewWebhooksPathParams
  >({ url: '/accounts/{accountId}/stream/webhook', method: 'get', ...variables, signal });

export type StreamWebhookCreateWebhooksPathParams = {
  accountId: Schemas.StreamAccountIdentifier;
};

export type StreamWebhookCreateWebhooksError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamWebhookCreateWebhooksVariables = {
  body: Schemas.StreamWebhookRequest;
  pathParams: StreamWebhookCreateWebhooksPathParams;
} & FetcherExtraProps;

/**
 * Creates a webhook notification.
 */
export const streamWebhookCreateWebhooks = (variables: StreamWebhookCreateWebhooksVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.StreamWebhookResponseSingle,
    StreamWebhookCreateWebhooksError,
    Schemas.StreamWebhookRequest,
    {},
    {},
    StreamWebhookCreateWebhooksPathParams
  >({ url: '/accounts/{accountId}/stream/webhook', method: 'put', ...variables, signal });

export type StreamVideosDeleteVideoPathParams = {
  identifier: Schemas.StreamIdentifier;
  accountId: Schemas.StreamAccountIdentifier;
};

export type StreamVideosDeleteVideoError = Fetcher.ErrorWrapper<undefined>;

export type StreamVideosDeleteVideoVariables = {
  pathParams: StreamVideosDeleteVideoPathParams;
} & FetcherExtraProps;

/**
 * Deletes a video and its copies from Cloudflare Stream.
 */
export const streamVideosDeleteVideo = (variables: StreamVideosDeleteVideoVariables, signal?: AbortSignal) =>
  fetch<undefined, StreamVideosDeleteVideoError, undefined, {}, {}, StreamVideosDeleteVideoPathParams>({
    url: '/accounts/{accountId}/stream/{identifier}',
    method: 'delete',
    ...variables,
    signal
  });

export type StreamVideosRetrieveVideoDetailsPathParams = {
  identifier: Schemas.StreamIdentifier;
  accountId: Schemas.StreamAccountIdentifier;
};

export type StreamVideosRetrieveVideoDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamVideosRetrieveVideoDetailsVariables = {
  pathParams: StreamVideosRetrieveVideoDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetches details for a single video.
 */
export const streamVideosRetrieveVideoDetails = (
  variables: StreamVideosRetrieveVideoDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamVideoResponseSingle,
    StreamVideosRetrieveVideoDetailsError,
    undefined,
    {},
    {},
    StreamVideosRetrieveVideoDetailsPathParams
  >({ url: '/accounts/{accountId}/stream/{identifier}', method: 'get', ...variables, signal });

export type StreamVideosUpdateVideoDetailsPathParams = {
  identifier: Schemas.StreamIdentifier;
  accountId: Schemas.StreamAccountIdentifier;
};

export type StreamVideosUpdateVideoDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamVideosUpdateVideoDetailsVariables = {
  body?: Schemas.StreamVideoUpdate;
  pathParams: StreamVideosUpdateVideoDetailsPathParams;
} & FetcherExtraProps;

/**
 * Edit details for a single video.
 */
export const streamVideosUpdateVideoDetails = (
  variables: StreamVideosUpdateVideoDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamVideoResponseSingle,
    StreamVideosUpdateVideoDetailsError,
    Schemas.StreamVideoUpdate,
    {},
    {},
    StreamVideosUpdateVideoDetailsPathParams
  >({ url: '/accounts/{accountId}/stream/{identifier}', method: 'post', ...variables, signal });

export type ListAudioTracksPathParams = {
  accountId: Schemas.StreamAccountIdentifier;
  identifier: Schemas.StreamIdentifier;
};

export type ListAudioTracksError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type ListAudioTracksVariables = {
  pathParams: ListAudioTracksPathParams;
} & FetcherExtraProps;

/**
 * Lists additional audio tracks on a video. Note this API will not return information for audio attached to the video upload.
 */
export const listAudioTracks = (variables: ListAudioTracksVariables, signal?: AbortSignal) =>
  fetch<Schemas.StreamListAudioTrackResponse, ListAudioTracksError, undefined, {}, {}, ListAudioTracksPathParams>({
    url: '/accounts/{accountId}/stream/{identifier}/audio',
    method: 'get',
    ...variables,
    signal
  });

export type AddAudioTrackPathParams = {
  accountId: Schemas.StreamAccountIdentifier;
  identifier: Schemas.StreamIdentifier;
};

export type AddAudioTrackError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type AddAudioTrackVariables = {
  body: Schemas.StreamCopyAudioTrack;
  pathParams: AddAudioTrackPathParams;
} & FetcherExtraProps;

/**
 * Adds an additional audio track to a video using the provided audio track URL.
 */
export const addAudioTrack = (variables: AddAudioTrackVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.StreamAddAudioTrackResponse,
    AddAudioTrackError,
    Schemas.StreamCopyAudioTrack,
    {},
    {},
    AddAudioTrackPathParams
  >({ url: '/accounts/{accountId}/stream/{identifier}/audio/copy', method: 'post', ...variables, signal });

export type DeleteAudioTracksPathParams = {
  accountId: Schemas.StreamAccountIdentifier;
  identifier: Schemas.StreamIdentifier;
  audioIdentifier: Schemas.StreamAudioIdentifier;
};

export type DeleteAudioTracksError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamDeletedResponse;
}>;

export type DeleteAudioTracksVariables = {
  pathParams: DeleteAudioTracksPathParams;
} & FetcherExtraProps;

/**
 * Deletes additional audio tracks on a video. Deleting a default audio track is not allowed. You must assign another audio track as default prior to deletion.
 */
export const deleteAudioTracks = (variables: DeleteAudioTracksVariables, signal?: AbortSignal) =>
  fetch<Schemas.StreamDeletedResponse, DeleteAudioTracksError, undefined, {}, {}, DeleteAudioTracksPathParams>({
    url: '/accounts/{accountId}/stream/{identifier}/audio/{audioIdentifier}',
    method: 'delete',
    ...variables,
    signal
  });

export type EditAudioTracksPathParams = {
  accountId: Schemas.StreamAccountIdentifier;
  identifier: Schemas.StreamIdentifier;
  audioIdentifier: Schemas.StreamAudioIdentifier;
};

export type EditAudioTracksError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type EditAudioTracksVariables = {
  body?: Schemas.StreamEditAudioTrack;
  pathParams: EditAudioTracksPathParams;
} & FetcherExtraProps;

/**
 * Edits additional audio tracks on a video. Editing the default status of an audio track to `true` will mark all other audio tracks on the video default status to `false`.
 */
export const editAudioTracks = (variables: EditAudioTracksVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.StreamAddAudioTrackResponse,
    EditAudioTracksError,
    Schemas.StreamEditAudioTrack,
    {},
    {},
    EditAudioTracksPathParams
  >({
    url: '/accounts/{accountId}/stream/{identifier}/audio/{audioIdentifier}',
    method: 'patch',
    ...variables,
    signal
  });

export type StreamSubtitlesCaptionsListCaptionsOrSubtitlesPathParams = {
  identifier: Schemas.StreamIdentifier;
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamSubtitlesCaptionsListCaptionsOrSubtitlesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamSubtitlesCaptionsListCaptionsOrSubtitlesVariables = {
  pathParams: StreamSubtitlesCaptionsListCaptionsOrSubtitlesPathParams;
} & FetcherExtraProps;

/**
 * Lists the available captions or subtitles for a specific video.
 */
export const streamSubtitlesCaptionsListCaptionsOrSubtitles = (
  variables: StreamSubtitlesCaptionsListCaptionsOrSubtitlesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamLanguageResponseCollection,
    StreamSubtitlesCaptionsListCaptionsOrSubtitlesError,
    undefined,
    {},
    {},
    StreamSubtitlesCaptionsListCaptionsOrSubtitlesPathParams
  >({ url: '/accounts/{accountId}/stream/{identifier}/captions', method: 'get', ...variables, signal });

export type StreamSubtitlesCaptionsDeleteCaptionsOrSubtitlesPathParams = {
  language: Schemas.StreamLanguage;
  identifier: Schemas.StreamIdentifier;
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamSubtitlesCaptionsDeleteCaptionsOrSubtitlesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamSubtitlesCaptionsDeleteCaptionsOrSubtitlesResponse = Schemas.StreamApiResponseCommon & {
  /**
   * @example
   */
  result?: string;
};

export type StreamSubtitlesCaptionsDeleteCaptionsOrSubtitlesVariables = {
  pathParams: StreamSubtitlesCaptionsDeleteCaptionsOrSubtitlesPathParams;
} & FetcherExtraProps;

/**
 * Removes the captions or subtitles from a video.
 */
export const streamSubtitlesCaptionsDeleteCaptionsOrSubtitles = (
  variables: StreamSubtitlesCaptionsDeleteCaptionsOrSubtitlesVariables,
  signal?: AbortSignal
) =>
  fetch<
    StreamSubtitlesCaptionsDeleteCaptionsOrSubtitlesResponse,
    StreamSubtitlesCaptionsDeleteCaptionsOrSubtitlesError,
    undefined,
    {},
    {},
    StreamSubtitlesCaptionsDeleteCaptionsOrSubtitlesPathParams
  >({ url: '/accounts/{accountId}/stream/{identifier}/captions/{language}', method: 'delete', ...variables, signal });

export type StreamSubtitlesCaptionsGetCaptionOrSubtitleForLanguagePathParams = {
  language: Schemas.StreamLanguage;
  identifier: Schemas.StreamIdentifier;
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamSubtitlesCaptionsGetCaptionOrSubtitleForLanguageError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamSubtitlesCaptionsGetCaptionOrSubtitleForLanguageVariables = {
  pathParams: StreamSubtitlesCaptionsGetCaptionOrSubtitleForLanguagePathParams;
} & FetcherExtraProps;

/**
 * Lists the captions or subtitles for provided language.
 */
export const streamSubtitlesCaptionsGetCaptionOrSubtitleForLanguage = (
  variables: StreamSubtitlesCaptionsGetCaptionOrSubtitleForLanguageVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamLanguageResponseSingle,
    StreamSubtitlesCaptionsGetCaptionOrSubtitleForLanguageError,
    undefined,
    {},
    {},
    StreamSubtitlesCaptionsGetCaptionOrSubtitleForLanguagePathParams
  >({ url: '/accounts/{accountId}/stream/{identifier}/captions/{language}', method: 'get', ...variables, signal });

export type StreamSubtitlesCaptionsUploadCaptionsOrSubtitlesPathParams = {
  language: Schemas.StreamLanguage;
  identifier: Schemas.StreamIdentifier;
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamSubtitlesCaptionsUploadCaptionsOrSubtitlesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamSubtitlesCaptionsUploadCaptionsOrSubtitlesVariables = {
  body: Schemas.StreamCaptionBasicUpload;
  pathParams: StreamSubtitlesCaptionsUploadCaptionsOrSubtitlesPathParams;
} & FetcherExtraProps;

/**
 * Uploads the caption or subtitle file to the endpoint for a specific BCP47 language. One caption or subtitle file per language is allowed.
 */
export const streamSubtitlesCaptionsUploadCaptionsOrSubtitles = (
  variables: StreamSubtitlesCaptionsUploadCaptionsOrSubtitlesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamLanguageResponseSingle,
    StreamSubtitlesCaptionsUploadCaptionsOrSubtitlesError,
    Schemas.StreamCaptionBasicUpload,
    {},
    {},
    StreamSubtitlesCaptionsUploadCaptionsOrSubtitlesPathParams
  >({ url: '/accounts/{accountId}/stream/{identifier}/captions/{language}', method: 'put', ...variables, signal });

export type StreamSubtitlesCaptionsGenerateCaptionOrSubtitleForLanguagePathParams = {
  language: Schemas.StreamLanguage;
  identifier: Schemas.StreamIdentifier;
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamSubtitlesCaptionsGenerateCaptionOrSubtitleForLanguageError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamSubtitlesCaptionsGenerateCaptionOrSubtitleForLanguageVariables = {
  pathParams: StreamSubtitlesCaptionsGenerateCaptionOrSubtitleForLanguagePathParams;
} & FetcherExtraProps;

/**
 * Generate captions or subtitles for provided language via AI.
 */
export const streamSubtitlesCaptionsGenerateCaptionOrSubtitleForLanguage = (
  variables: StreamSubtitlesCaptionsGenerateCaptionOrSubtitleForLanguageVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamLanguageResponseSingle,
    StreamSubtitlesCaptionsGenerateCaptionOrSubtitleForLanguageError,
    undefined,
    {},
    {},
    StreamSubtitlesCaptionsGenerateCaptionOrSubtitleForLanguagePathParams
  >({
    url: '/accounts/{accountId}/stream/{identifier}/captions/{language}/generate',
    method: 'post',
    ...variables,
    signal
  });

export type StreamSubtitlesCaptionsGetVttCaptionOrSubtitlePathParams = {
  language: Schemas.StreamLanguage;
  identifier: Schemas.StreamIdentifier;
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamSubtitlesCaptionsGetVttCaptionOrSubtitleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamSubtitlesCaptionsGetVttCaptionOrSubtitleVariables = {
  pathParams: StreamSubtitlesCaptionsGetVttCaptionOrSubtitlePathParams;
} & FetcherExtraProps;

/**
 * Return WebVTT captions for a provided language.
 */
export const streamSubtitlesCaptionsGetVttCaptionOrSubtitle = (
  variables: StreamSubtitlesCaptionsGetVttCaptionOrSubtitleVariables,
  signal?: AbortSignal
) =>
  fetch<
    undefined,
    StreamSubtitlesCaptionsGetVttCaptionOrSubtitleError,
    undefined,
    {},
    {},
    StreamSubtitlesCaptionsGetVttCaptionOrSubtitlePathParams
  >({ url: '/accounts/{accountId}/stream/{identifier}/captions/{language}/vtt', method: 'get', ...variables, signal });

export type StreamMP4DownloadsDeleteDownloadsPathParams = {
  identifier: Schemas.StreamIdentifier;
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamMP4DownloadsDeleteDownloadsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamMP4DownloadsDeleteDownloadsVariables = {
  pathParams: StreamMP4DownloadsDeleteDownloadsPathParams;
} & FetcherExtraProps;

/**
 * Delete the downloads for a video.
 */
export const streamMP4DownloadsDeleteDownloads = (
  variables: StreamMP4DownloadsDeleteDownloadsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamDeletedResponse,
    StreamMP4DownloadsDeleteDownloadsError,
    undefined,
    {},
    {},
    StreamMP4DownloadsDeleteDownloadsPathParams
  >({ url: '/accounts/{accountId}/stream/{identifier}/downloads', method: 'delete', ...variables, signal });

export type StreamMP4DownloadsListDownloadsPathParams = {
  identifier: Schemas.StreamIdentifier;
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamMP4DownloadsListDownloadsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamMP4DownloadsListDownloadsVariables = {
  pathParams: StreamMP4DownloadsListDownloadsPathParams;
} & FetcherExtraProps;

/**
 * Lists the downloads created for a video.
 */
export const streamMP4DownloadsListDownloads = (
  variables: StreamMP4DownloadsListDownloadsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamDownloadsResponse,
    StreamMP4DownloadsListDownloadsError,
    undefined,
    {},
    {},
    StreamMP4DownloadsListDownloadsPathParams
  >({ url: '/accounts/{accountId}/stream/{identifier}/downloads', method: 'get', ...variables, signal });

export type StreamMP4DownloadsCreateDownloadsPathParams = {
  identifier: Schemas.StreamIdentifier;
  accountId: Schemas.StreamSchemasIdentifier;
};

export type StreamMP4DownloadsCreateDownloadsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamMP4DownloadsCreateDownloadsVariables = {
  pathParams: StreamMP4DownloadsCreateDownloadsPathParams;
} & FetcherExtraProps;

/**
 * Creates a download for a video when a video is ready to view.
 */
export const streamMP4DownloadsCreateDownloads = (
  variables: StreamMP4DownloadsCreateDownloadsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamDownloadsResponse,
    StreamMP4DownloadsCreateDownloadsError,
    undefined,
    {},
    {},
    StreamMP4DownloadsCreateDownloadsPathParams
  >({ url: '/accounts/{accountId}/stream/{identifier}/downloads', method: 'post', ...variables, signal });

export type StreamVideosRetreieveEmbedCodeHtmlPathParams = {
  identifier: Schemas.StreamIdentifier;
  accountId: Schemas.StreamAccountIdentifier;
};

export type StreamVideosRetreieveEmbedCodeHtmlError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamVideosRetreieveEmbedCodeHtmlVariables = {
  pathParams: StreamVideosRetreieveEmbedCodeHtmlPathParams;
} & FetcherExtraProps;

/**
 * Fetches an HTML code snippet to embed a video in a web page delivered through Cloudflare. On success, returns an HTML fragment for use on web pages to display a video. On failure, returns a JSON response body.
 */
export const streamVideosRetreieveEmbedCodeHtml = (
  variables: StreamVideosRetreieveEmbedCodeHtmlVariables,
  signal?: AbortSignal
) =>
  fetch<void, StreamVideosRetreieveEmbedCodeHtmlError, undefined, {}, {}, StreamVideosRetreieveEmbedCodeHtmlPathParams>(
    { url: '/accounts/{accountId}/stream/{identifier}/embed', method: 'get', ...variables, signal }
  );

export type StreamVideosCreateSignedUrlTokensForVideosPathParams = {
  identifier: Schemas.StreamIdentifier;
  accountId: Schemas.StreamAccountIdentifier;
};

export type StreamVideosCreateSignedUrlTokensForVideosError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.StreamApiResponseCommonFailure;
}>;

export type StreamVideosCreateSignedUrlTokensForVideosVariables = {
  body?: Schemas.StreamSignedTokenRequest;
  pathParams: StreamVideosCreateSignedUrlTokensForVideosPathParams;
} & FetcherExtraProps;

/**
 * Creates a signed URL token for a video. If a body is not provided in the request, a token is created with default values.
 */
export const streamVideosCreateSignedUrlTokensForVideos = (
  variables: StreamVideosCreateSignedUrlTokensForVideosVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.StreamSignedTokenResponse,
    StreamVideosCreateSignedUrlTokensForVideosError,
    Schemas.StreamSignedTokenRequest,
    {},
    {},
    StreamVideosCreateSignedUrlTokensForVideosPathParams
  >({ url: '/accounts/{accountId}/stream/{identifier}/token', method: 'post', ...variables, signal });

export type AccountSubscriptionsListSubscriptionsPathParams = {
  accountId: Schemas.BillSubsApiIdentifier;
};

export type AccountSubscriptionsListSubscriptionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.BillSubsApiAccountSubscriptionResponseCollection & Schemas.BillSubsApiApiResponseCommonFailure;
}>;

export type AccountSubscriptionsListSubscriptionsVariables = {
  pathParams: AccountSubscriptionsListSubscriptionsPathParams;
} & FetcherExtraProps;

/**
 * Lists all of an account's subscriptions.
 */
export const accountSubscriptionsListSubscriptions = (
  variables: AccountSubscriptionsListSubscriptionsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.BillSubsApiAccountSubscriptionResponseCollection,
    AccountSubscriptionsListSubscriptionsError,
    undefined,
    {},
    {},
    AccountSubscriptionsListSubscriptionsPathParams
  >({ url: '/accounts/{accountId}/subscriptions', method: 'get', ...variables, signal });

export type AccountSubscriptionsCreateSubscriptionPathParams = {
  accountId: Schemas.BillSubsApiIdentifier;
};

export type AccountSubscriptionsCreateSubscriptionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.BillSubsApiAccountSubscriptionResponseSingle & Schemas.BillSubsApiApiResponseCommonFailure;
}>;

export type AccountSubscriptionsCreateSubscriptionVariables = {
  body?: Schemas.BillSubsApiSubscriptionV2;
  pathParams: AccountSubscriptionsCreateSubscriptionPathParams;
} & FetcherExtraProps;

/**
 * Creates an account subscription.
 */
export const accountSubscriptionsCreateSubscription = (
  variables: AccountSubscriptionsCreateSubscriptionVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.BillSubsApiAccountSubscriptionResponseSingle,
    AccountSubscriptionsCreateSubscriptionError,
    Schemas.BillSubsApiSubscriptionV2,
    {},
    {},
    AccountSubscriptionsCreateSubscriptionPathParams
  >({ url: '/accounts/{accountId}/subscriptions', method: 'post', ...variables, signal });

export type AccountSubscriptionsDeleteSubscriptionPathParams = {
  subscriptionIdentifier: Schemas.BillSubsApiSchemasIdentifier;
  accountId: Schemas.BillSubsApiIdentifier;
};

export type AccountSubscriptionsDeleteSubscriptionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.BillSubsApiApiResponseSingle & {
    result?: {
      subscription_id?: Schemas.BillSubsApiSchemasIdentifier;
    };
  }) &
    Schemas.BillSubsApiApiResponseCommonFailure;
}>;

export type AccountSubscriptionsDeleteSubscriptionResponse = Schemas.BillSubsApiApiResponseSingle & {
  result?: {
    subscription_id?: Schemas.BillSubsApiSchemasIdentifier;
  };
};

export type AccountSubscriptionsDeleteSubscriptionVariables = {
  pathParams: AccountSubscriptionsDeleteSubscriptionPathParams;
} & FetcherExtraProps;

/**
 * Deletes an account's subscription.
 */
export const accountSubscriptionsDeleteSubscription = (
  variables: AccountSubscriptionsDeleteSubscriptionVariables,
  signal?: AbortSignal
) =>
  fetch<
    AccountSubscriptionsDeleteSubscriptionResponse,
    AccountSubscriptionsDeleteSubscriptionError,
    undefined,
    {},
    {},
    AccountSubscriptionsDeleteSubscriptionPathParams
  >({ url: '/accounts/{accountId}/subscriptions/{subscriptionIdentifier}', method: 'delete', ...variables, signal });

export type AccountSubscriptionsUpdateSubscriptionPathParams = {
  subscriptionIdentifier: Schemas.BillSubsApiSchemasIdentifier;
  accountId: Schemas.BillSubsApiIdentifier;
};

export type AccountSubscriptionsUpdateSubscriptionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.BillSubsApiAccountSubscriptionResponseSingle & Schemas.BillSubsApiApiResponseCommonFailure;
}>;

export type AccountSubscriptionsUpdateSubscriptionVariables = {
  body?: Schemas.BillSubsApiSubscriptionV2;
  pathParams: AccountSubscriptionsUpdateSubscriptionPathParams;
} & FetcherExtraProps;

/**
 * Updates an account subscription.
 */
export const accountSubscriptionsUpdateSubscription = (
  variables: AccountSubscriptionsUpdateSubscriptionVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.BillSubsApiAccountSubscriptionResponseSingle,
    AccountSubscriptionsUpdateSubscriptionError,
    Schemas.BillSubsApiSubscriptionV2,
    {},
    {},
    AccountSubscriptionsUpdateSubscriptionPathParams
  >({ url: '/accounts/{accountId}/subscriptions/{subscriptionIdentifier}', method: 'put', ...variables, signal });

export type TunnelRouteListTunnelRoutesPathParams = {
  accountId: Schemas.TunnelAccountId;
};

export type TunnelRouteListTunnelRoutesQueryParams = {
  comment?: Schemas.TunnelComment;
  is_deleted?: boolean;
  /**
   * The private IPv4 or IPv6 range connected by the route, in CIDR notation.
   *
   * @example 172.16.0.0/16
   */
  network_subset?: Schemas.TunnelIpNetwork;
  /**
   * The private IPv4 or IPv6 range connected by the route, in CIDR notation.
   *
   * @example 172.16.0.0/16
   */
  network_superset?: Schemas.TunnelIpNetwork;
  existed_at?: Schemas.TunnelExistedAt;
  tunnel_id?: Schemas.TunnelTunnelId;
  route_id?: Schemas.TunnelRouteId;
  tun_types?: Schemas.TunnelTunnelTypes;
  virtual_network_id?: Schemas.TunnelVirtualNetworkId;
  per_page?: Schemas.TunnelPerPage;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
};

export type TunnelRouteListTunnelRoutesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelTeamnetResponseCollection & Schemas.TunnelApiResponseCommonFailure;
}>;

export type TunnelRouteListTunnelRoutesVariables = {
  pathParams: TunnelRouteListTunnelRoutesPathParams;
  queryParams?: TunnelRouteListTunnelRoutesQueryParams;
} & FetcherExtraProps;

/**
 * Lists and filters private network routes in an account.
 */
export const tunnelRouteListTunnelRoutes = (variables: TunnelRouteListTunnelRoutesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.TunnelTeamnetResponseCollection,
    TunnelRouteListTunnelRoutesError,
    undefined,
    {},
    TunnelRouteListTunnelRoutesQueryParams,
    TunnelRouteListTunnelRoutesPathParams
  >({ url: '/accounts/{accountId}/teamnet/routes', method: 'get', ...variables, signal });

export type TunnelRouteCreateATunnelRoutePathParams = {
  accountId: Schemas.TunnelAccountId;
};

export type TunnelRouteCreateATunnelRouteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelRouteResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type TunnelRouteCreateATunnelRouteRequestBody = {
  comment?: Schemas.TunnelComment;
  network: Schemas.TunnelIpNetwork;
  tunnel_id: Schemas.TunnelTunnelId;
  virtual_network_id?: Schemas.TunnelVirtualNetworkId;
};

export type TunnelRouteCreateATunnelRouteVariables = {
  body: TunnelRouteCreateATunnelRouteRequestBody;
  pathParams: TunnelRouteCreateATunnelRoutePathParams;
} & FetcherExtraProps;

/**
 * Routes a private network through a Cloudflare Tunnel.
 */
export const tunnelRouteCreateATunnelRoute = (
  variables: TunnelRouteCreateATunnelRouteVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelRouteResponseSingle,
    TunnelRouteCreateATunnelRouteError,
    TunnelRouteCreateATunnelRouteRequestBody,
    {},
    {},
    TunnelRouteCreateATunnelRoutePathParams
  >({ url: '/accounts/{accountId}/teamnet/routes', method: 'post', ...variables, signal });

export type TunnelRouteGetTunnelRouteByIpPathParams = {
  ip: Schemas.TunnelIp;
  accountId: Schemas.TunnelAccountId;
};

export type TunnelRouteGetTunnelRouteByIpQueryParams = {
  virtual_network_id?: Schemas.TunnelVirtualNetworkId;
};

export type TunnelRouteGetTunnelRouteByIpError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelTeamnetResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type TunnelRouteGetTunnelRouteByIpVariables = {
  pathParams: TunnelRouteGetTunnelRouteByIpPathParams;
  queryParams?: TunnelRouteGetTunnelRouteByIpQueryParams;
} & FetcherExtraProps;

/**
 * Fetches routes that contain the given IP address.
 */
export const tunnelRouteGetTunnelRouteByIp = (
  variables: TunnelRouteGetTunnelRouteByIpVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelTeamnetResponseSingle,
    TunnelRouteGetTunnelRouteByIpError,
    undefined,
    {},
    TunnelRouteGetTunnelRouteByIpQueryParams,
    TunnelRouteGetTunnelRouteByIpPathParams
  >({ url: '/accounts/{accountId}/teamnet/routes/ip/{ip}', method: 'get', ...variables, signal });

export type TunnelRouteDeleteATunnelRouteWithCidrPathParams = {
  ipNetworkEncoded: Schemas.TunnelIpNetworkEncoded;
  accountId: Schemas.TunnelAccountId;
};

export type TunnelRouteDeleteATunnelRouteWithCidrQueryParams = {
  virtual_network_id?: Schemas.TunnelVirtualNetworkId;
  tun_type?: Schemas.TunnelTunnelType;
  tunnel_id?: Schemas.TunnelTunnelId;
};

export type TunnelRouteDeleteATunnelRouteWithCidrError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelRouteResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type TunnelRouteDeleteATunnelRouteWithCidrVariables = {
  pathParams: TunnelRouteDeleteATunnelRouteWithCidrPathParams;
  queryParams?: TunnelRouteDeleteATunnelRouteWithCidrQueryParams;
} & FetcherExtraProps;

/**
 * Deletes a private network route from an account. The CIDR in `ip_network_encoded` must be written in URL-encoded format. If no virtual_network_id is provided it will delete the route from the default vnet. If no tun_type is provided it will fetch the type from the tunnel_id or if that is missing it will assume Cloudflare Tunnel as default. If tunnel_id is provided it will delete the route from that tunnel, otherwise it will delete the route based on the vnet and tun_type.
 */
export const tunnelRouteDeleteATunnelRouteWithCidr = (
  variables: TunnelRouteDeleteATunnelRouteWithCidrVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelRouteResponseSingle,
    TunnelRouteDeleteATunnelRouteWithCidrError,
    undefined,
    {},
    TunnelRouteDeleteATunnelRouteWithCidrQueryParams,
    TunnelRouteDeleteATunnelRouteWithCidrPathParams
  >({ url: '/accounts/{accountId}/teamnet/routes/network/{ipNetworkEncoded}', method: 'delete', ...variables, signal });

export type TunnelRouteUpdateATunnelRouteWithCidrPathParams = {
  ipNetworkEncoded: Schemas.TunnelIpNetworkEncoded;
  accountId: Schemas.TunnelAccountId;
};

export type TunnelRouteUpdateATunnelRouteWithCidrError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelRouteResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type TunnelRouteUpdateATunnelRouteWithCidrVariables = {
  pathParams: TunnelRouteUpdateATunnelRouteWithCidrPathParams;
} & FetcherExtraProps;

/**
 * Updates an existing private network route in an account. The CIDR in `ip_network_encoded` must be written in URL-encoded format.
 */
export const tunnelRouteUpdateATunnelRouteWithCidr = (
  variables: TunnelRouteUpdateATunnelRouteWithCidrVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelRouteResponseSingle,
    TunnelRouteUpdateATunnelRouteWithCidrError,
    undefined,
    {},
    {},
    TunnelRouteUpdateATunnelRouteWithCidrPathParams
  >({ url: '/accounts/{accountId}/teamnet/routes/network/{ipNetworkEncoded}', method: 'patch', ...variables, signal });

export type TunnelRouteCreateATunnelRouteWithCidrPathParams = {
  ipNetworkEncoded: Schemas.TunnelIpNetworkEncoded;
  accountId: Schemas.TunnelAccountId;
};

export type TunnelRouteCreateATunnelRouteWithCidrError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelRouteResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type TunnelRouteCreateATunnelRouteWithCidrRequestBody = {
  comment?: Schemas.TunnelComment;
  tunnel_id: Schemas.TunnelTunnelId;
  virtual_network_id?: Schemas.TunnelVirtualNetworkId;
};

export type TunnelRouteCreateATunnelRouteWithCidrVariables = {
  body: TunnelRouteCreateATunnelRouteWithCidrRequestBody;
  pathParams: TunnelRouteCreateATunnelRouteWithCidrPathParams;
} & FetcherExtraProps;

/**
 * Routes a private network through a Cloudflare Tunnel. The CIDR in `ip_network_encoded` must be written in URL-encoded format.
 */
export const tunnelRouteCreateATunnelRouteWithCidr = (
  variables: TunnelRouteCreateATunnelRouteWithCidrVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelRouteResponseSingle,
    TunnelRouteCreateATunnelRouteWithCidrError,
    TunnelRouteCreateATunnelRouteWithCidrRequestBody,
    {},
    {},
    TunnelRouteCreateATunnelRouteWithCidrPathParams
  >({ url: '/accounts/{accountId}/teamnet/routes/network/{ipNetworkEncoded}', method: 'post', ...variables, signal });

export type TunnelRouteDeleteATunnelRoutePathParams = {
  routeId: Schemas.TunnelRouteId;
  accountId: Schemas.TunnelAccountId;
};

export type TunnelRouteDeleteATunnelRouteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelRouteResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type TunnelRouteDeleteATunnelRouteVariables = {
  pathParams: TunnelRouteDeleteATunnelRoutePathParams;
} & FetcherExtraProps;

/**
 * Deletes a private network route from an account.
 */
export const tunnelRouteDeleteATunnelRoute = (
  variables: TunnelRouteDeleteATunnelRouteVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelRouteResponseSingle,
    TunnelRouteDeleteATunnelRouteError,
    undefined,
    {},
    {},
    TunnelRouteDeleteATunnelRoutePathParams
  >({ url: '/accounts/{accountId}/teamnet/routes/{routeId}', method: 'delete', ...variables, signal });

export type TunnelRouteGetTunnelRoutePathParams = {
  accountId: Schemas.TunnelAccountId;
  routeId: Schemas.TunnelRouteId;
};

export type TunnelRouteGetTunnelRouteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelRouteResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type TunnelRouteGetTunnelRouteVariables = {
  pathParams: TunnelRouteGetTunnelRoutePathParams;
} & FetcherExtraProps;

/**
 * Get a private network route in an account.
 */
export const tunnelRouteGetTunnelRoute = (variables: TunnelRouteGetTunnelRouteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.TunnelRouteResponseSingle,
    TunnelRouteGetTunnelRouteError,
    undefined,
    {},
    {},
    TunnelRouteGetTunnelRoutePathParams
  >({ url: '/accounts/{accountId}/teamnet/routes/{routeId}', method: 'get', ...variables, signal });

export type TunnelRouteUpdateATunnelRoutePathParams = {
  routeId: Schemas.TunnelRouteId;
  accountId: Schemas.TunnelAccountId;
};

export type TunnelRouteUpdateATunnelRouteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelRouteResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type TunnelRouteUpdateATunnelRouteRequestBody = {
  comment?: Schemas.TunnelComment;
  network?: Schemas.TunnelIpNetwork;
  tunnel_id?: Schemas.TunnelTunnelId;
  virtual_network_id?: Schemas.TunnelVirtualNetworkId;
};

export type TunnelRouteUpdateATunnelRouteVariables = {
  body?: TunnelRouteUpdateATunnelRouteRequestBody;
  pathParams: TunnelRouteUpdateATunnelRoutePathParams;
} & FetcherExtraProps;

/**
 * Updates an existing private network route in an account. The fields that are meant to be updated should be provided in the body of the request.
 */
export const tunnelRouteUpdateATunnelRoute = (
  variables: TunnelRouteUpdateATunnelRouteVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelRouteResponseSingle,
    TunnelRouteUpdateATunnelRouteError,
    TunnelRouteUpdateATunnelRouteRequestBody,
    {},
    {},
    TunnelRouteUpdateATunnelRoutePathParams
  >({ url: '/accounts/{accountId}/teamnet/routes/{routeId}', method: 'patch', ...variables, signal });

export type TunnelVirtualNetworkListVirtualNetworksPathParams = {
  accountId: Schemas.TunnelAccountId;
};

export type TunnelVirtualNetworkListVirtualNetworksQueryParams = {
  id?: Schemas.TunnelVirtualNetworkId;
  name?: Schemas.TunnelVirtualNetworkName;
  is_default?: boolean;
  is_deleted?: boolean;
};

export type TunnelVirtualNetworkListVirtualNetworksError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelVnetResponseCollection & Schemas.TunnelApiResponseCommonFailure;
}>;

export type TunnelVirtualNetworkListVirtualNetworksVariables = {
  pathParams: TunnelVirtualNetworkListVirtualNetworksPathParams;
  queryParams?: TunnelVirtualNetworkListVirtualNetworksQueryParams;
} & FetcherExtraProps;

/**
 * Lists and filters virtual networks in an account.
 */
export const tunnelVirtualNetworkListVirtualNetworks = (
  variables: TunnelVirtualNetworkListVirtualNetworksVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelVnetResponseCollection,
    TunnelVirtualNetworkListVirtualNetworksError,
    undefined,
    {},
    TunnelVirtualNetworkListVirtualNetworksQueryParams,
    TunnelVirtualNetworkListVirtualNetworksPathParams
  >({ url: '/accounts/{accountId}/teamnet/virtual_networks', method: 'get', ...variables, signal });

export type TunnelVirtualNetworkCreateAVirtualNetworkPathParams = {
  accountId: Schemas.TunnelAccountId;
};

export type TunnelVirtualNetworkCreateAVirtualNetworkError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelVnetResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type TunnelVirtualNetworkCreateAVirtualNetworkRequestBody = {
  comment?: Schemas.TunnelVirtualNetworkComment;
  is_default?: Schemas.TunnelIsDefaultNetwork;
  name: Schemas.TunnelVirtualNetworkName;
};

export type TunnelVirtualNetworkCreateAVirtualNetworkVariables = {
  body: TunnelVirtualNetworkCreateAVirtualNetworkRequestBody;
  pathParams: TunnelVirtualNetworkCreateAVirtualNetworkPathParams;
} & FetcherExtraProps;

/**
 * Adds a new virtual network to an account.
 */
export const tunnelVirtualNetworkCreateAVirtualNetwork = (
  variables: TunnelVirtualNetworkCreateAVirtualNetworkVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelVnetResponseSingle,
    TunnelVirtualNetworkCreateAVirtualNetworkError,
    TunnelVirtualNetworkCreateAVirtualNetworkRequestBody,
    {},
    {},
    TunnelVirtualNetworkCreateAVirtualNetworkPathParams
  >({ url: '/accounts/{accountId}/teamnet/virtual_networks', method: 'post', ...variables, signal });

export type TunnelVirtualNetworkDeletePathParams = {
  virtualNetworkId: Schemas.TunnelVirtualNetworkId;
  accountId: Schemas.TunnelAccountId;
};

export type TunnelVirtualNetworkDeleteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelVnetResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type TunnelVirtualNetworkDeleteVariables = {
  pathParams: TunnelVirtualNetworkDeletePathParams;
} & FetcherExtraProps;

/**
 * Deletes an existing virtual network.
 */
export const tunnelVirtualNetworkDelete = (variables: TunnelVirtualNetworkDeleteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.TunnelVnetResponseSingle,
    TunnelVirtualNetworkDeleteError,
    undefined,
    {},
    {},
    TunnelVirtualNetworkDeletePathParams
  >({
    url: '/accounts/{accountId}/teamnet/virtual_networks/{virtualNetworkId}',
    method: 'delete',
    ...variables,
    signal
  });

export type TunnelVirtualNetworkGetPathParams = {
  accountId: Schemas.TunnelAccountId;
  virtualNetworkId: Schemas.TunnelVirtualNetworkId;
};

export type TunnelVirtualNetworkGetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelVnetResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type TunnelVirtualNetworkGetRequestBody = {
  comment?: Schemas.TunnelVirtualNetworkComment;
  is_default_network?: Schemas.TunnelIsDefaultNetwork;
  name?: Schemas.TunnelVirtualNetworkName;
};

export type TunnelVirtualNetworkGetVariables = {
  body?: TunnelVirtualNetworkGetRequestBody;
  pathParams: TunnelVirtualNetworkGetPathParams;
} & FetcherExtraProps;

/**
 * Get a virtual network.
 */
export const tunnelVirtualNetworkGet = (variables: TunnelVirtualNetworkGetVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.TunnelVnetResponseSingle,
    TunnelVirtualNetworkGetError,
    TunnelVirtualNetworkGetRequestBody,
    {},
    {},
    TunnelVirtualNetworkGetPathParams
  >({ url: '/accounts/{accountId}/teamnet/virtual_networks/{virtualNetworkId}', method: 'get', ...variables, signal });

export type TunnelVirtualNetworkUpdatePathParams = {
  accountId: Schemas.TunnelAccountId;
  virtualNetworkId: Schemas.TunnelVirtualNetworkId;
};

export type TunnelVirtualNetworkUpdateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelVnetResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type TunnelVirtualNetworkUpdateRequestBody = {
  comment?: Schemas.TunnelVirtualNetworkComment;
  is_default_network?: Schemas.TunnelIsDefaultNetwork;
  name?: Schemas.TunnelVirtualNetworkName;
};

export type TunnelVirtualNetworkUpdateVariables = {
  body?: TunnelVirtualNetworkUpdateRequestBody;
  pathParams: TunnelVirtualNetworkUpdatePathParams;
} & FetcherExtraProps;

/**
 * Updates an existing virtual network.
 */
export const tunnelVirtualNetworkUpdate = (variables: TunnelVirtualNetworkUpdateVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.TunnelVnetResponseSingle,
    TunnelVirtualNetworkUpdateError,
    TunnelVirtualNetworkUpdateRequestBody,
    {},
    {},
    TunnelVirtualNetworkUpdatePathParams
  >({
    url: '/accounts/{accountId}/teamnet/virtual_networks/{virtualNetworkId}',
    method: 'patch',
    ...variables,
    signal
  });

export type AccountApiTokensListTokensPathParams = {
  accountId: Schemas.IamAccountIdentifier;
};

export type AccountApiTokensListTokensQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example desc
   */
  direction?: 'asc' | 'desc';
};

export type AccountApiTokensListTokensError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountApiTokensListTokensVariables = {
  pathParams: AccountApiTokensListTokensPathParams;
  queryParams?: AccountApiTokensListTokensQueryParams;
} & FetcherExtraProps;

/**
 * List all Account Owned API tokens created for this account.
 */
export const accountApiTokensListTokens = (variables: AccountApiTokensListTokensVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamCollectionTokensResponse,
    AccountApiTokensListTokensError,
    undefined,
    {},
    AccountApiTokensListTokensQueryParams,
    AccountApiTokensListTokensPathParams
  >({ url: '/accounts/{accountId}/tokens', method: 'get', ...variables, signal });

export type AccountApiTokensCreateTokenPathParams = {
  accountId: Schemas.IamAccountIdentifier;
};

export type AccountApiTokensCreateTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountApiTokensCreateTokenVariables = {
  body: Schemas.IamCreatePayload;
  pathParams: AccountApiTokensCreateTokenPathParams;
} & FetcherExtraProps;

/**
 * Create a new Account Owned API token.
 */
export const accountApiTokensCreateToken = (variables: AccountApiTokensCreateTokenVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamSingleTokenCreateResponse,
    AccountApiTokensCreateTokenError,
    Schemas.IamCreatePayload,
    {},
    {},
    AccountApiTokensCreateTokenPathParams
  >({ url: '/accounts/{accountId}/tokens', method: 'post', ...variables, signal });

export type AccountApiTokensListPermissionGroupsPathParams = {
  accountId: Schemas.IamAccountIdentifier;
};

export type AccountApiTokensListPermissionGroupsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountApiTokensListPermissionGroupsVariables = {
  pathParams: AccountApiTokensListPermissionGroupsPathParams;
} & FetcherExtraProps;

/**
 * Find all available permission groups for Account Owned API Tokens
 */
export const accountApiTokensListPermissionGroups = (
  variables: AccountApiTokensListPermissionGroupsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.IamSchemasResponseCollection,
    AccountApiTokensListPermissionGroupsError,
    undefined,
    {},
    {},
    AccountApiTokensListPermissionGroupsPathParams
  >({ url: '/accounts/{accountId}/tokens/permission_groups', method: 'get', ...variables, signal });

export type AccountApiTokensVerifyTokenPathParams = {
  accountId: Schemas.IamAccountIdentifier;
};

export type AccountApiTokensVerifyTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountApiTokensVerifyTokenVariables = {
  pathParams: AccountApiTokensVerifyTokenPathParams;
} & FetcherExtraProps;

/**
 * Test whether a token works.
 */
export const accountApiTokensVerifyToken = (variables: AccountApiTokensVerifyTokenVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamResponseSingleSegment,
    AccountApiTokensVerifyTokenError,
    undefined,
    {},
    {},
    AccountApiTokensVerifyTokenPathParams
  >({ url: '/accounts/{accountId}/tokens/verify', method: 'get', ...variables, signal });

export type AccountApiTokensDeleteTokenPathParams = {
  accountId: Schemas.IamAccountIdentifier;
  tokenId: Schemas.IamTokenIdentifier;
};

export type AccountApiTokensDeleteTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountApiTokensDeleteTokenVariables = {
  pathParams: AccountApiTokensDeleteTokenPathParams;
} & FetcherExtraProps;

/**
 * Destroy an Account Owned API token.
 */
export const accountApiTokensDeleteToken = (variables: AccountApiTokensDeleteTokenVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamApiResponseSingleId,
    AccountApiTokensDeleteTokenError,
    undefined,
    {},
    {},
    AccountApiTokensDeleteTokenPathParams
  >({ url: '/accounts/{accountId}/tokens/{tokenId}', method: 'delete', ...variables, signal });

export type AccountApiTokensTokenDetailsPathParams = {
  accountId: Schemas.IamAccountIdentifier;
  tokenId: Schemas.IamTokenIdentifier;
};

export type AccountApiTokensTokenDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountApiTokensTokenDetailsVariables = {
  pathParams: AccountApiTokensTokenDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get information about a specific Account Owned API token.
 */
export const accountApiTokensTokenDetails = (variables: AccountApiTokensTokenDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamSingleTokenResponse,
    AccountApiTokensTokenDetailsError,
    undefined,
    {},
    {},
    AccountApiTokensTokenDetailsPathParams
  >({ url: '/accounts/{accountId}/tokens/{tokenId}', method: 'get', ...variables, signal });

export type AccountApiTokensUpdateTokenPathParams = {
  accountId: Schemas.IamAccountIdentifier;
  tokenId: Schemas.IamTokenIdentifier;
};

export type AccountApiTokensUpdateTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountApiTokensUpdateTokenVariables = {
  body?: Schemas.IamTokenBody;
  pathParams: AccountApiTokensUpdateTokenPathParams;
} & FetcherExtraProps;

/**
 * Update an existing token.
 */
export const accountApiTokensUpdateToken = (variables: AccountApiTokensUpdateTokenVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamSingleTokenResponse,
    AccountApiTokensUpdateTokenError,
    Schemas.IamTokenBody,
    {},
    {},
    AccountApiTokensUpdateTokenPathParams
  >({ url: '/accounts/{accountId}/tokens/{tokenId}', method: 'put', ...variables, signal });

export type AccountApiTokensRollTokenPathParams = {
  accountId: Schemas.IamAccountIdentifier;
  tokenId: Schemas.IamTokenIdentifier;
};

export type AccountApiTokensRollTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type AccountApiTokensRollTokenVariables = {
  body?: Record<string, any>;
  pathParams: AccountApiTokensRollTokenPathParams;
} & FetcherExtraProps;

/**
 * Roll the Account Owned API token secret.
 */
export const accountApiTokensRollToken = (variables: AccountApiTokensRollTokenVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamResponseSingleValue,
    AccountApiTokensRollTokenError,
    Record<string, any>,
    {},
    {},
    AccountApiTokensRollTokenPathParams
  >({ url: '/accounts/{accountId}/tokens/{tokenId}/value', method: 'put', ...variables, signal });

export type CloudflareTunnelListAllTunnelsPathParams = {
  accountId: Schemas.TunnelAccountId;
};

export type CloudflareTunnelListAllTunnelsQueryParams = {
  /**
   * @example blog
   */
  name?: string;
  /**
   * @example true
   */
  is_deleted?: boolean;
  existed_at?: Schemas.TunnelExistedAt;
  uuid?: Schemas.TunnelTunnelId;
  /**
   * @example 2009-11-10T23:00:00Z
   * @format date-time
   */
  was_active_at?: string;
  /**
   * @example 2009-11-10T23:00:00Z
   * @format date-time
   */
  was_inactive_at?: string;
  /**
   * @example vpc1-
   */
  include_prefix?: string;
  /**
   * @example vpc1-
   */
  exclude_prefix?: string;
  tun_types?: Schemas.TunnelTunnelTypes;
  status?: Schemas.TunnelStatus;
  per_page?: Schemas.TunnelPerPage;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
};

export type CloudflareTunnelListAllTunnelsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelTunnelResponseCollection & Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelListAllTunnelsVariables = {
  pathParams: CloudflareTunnelListAllTunnelsPathParams;
  queryParams?: CloudflareTunnelListAllTunnelsQueryParams;
} & FetcherExtraProps;

/**
 * Lists and filters all types of Tunnels in an account.
 */
export const cloudflareTunnelListAllTunnels = (
  variables: CloudflareTunnelListAllTunnelsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelTunnelResponseCollection,
    CloudflareTunnelListAllTunnelsError,
    undefined,
    {},
    CloudflareTunnelListAllTunnelsQueryParams,
    CloudflareTunnelListAllTunnelsPathParams
  >({ url: '/accounts/{accountId}/tunnels', method: 'get', ...variables, signal });

export type UrlscannerGetResponseTextPathParams = {
  /**
   * Response hash.
   */
  responseId: string;
  /**
   * Account ID.
   */
  accountId: string;
};

export type UrlscannerGetResponseTextError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          /**
           * @example Scan ID is not a valid UUID.
           */
          message: string;
        }[];
        messages: {
          message: string;
        }[];
        /**
         * Whether request was successful or not
         */
        success: boolean;
      };
    }
  | {
      status: 404;
      payload: {
        errors: {
          /**
           * @example Scan not found.
           */
          message: string;
        }[];
        messages: {
          message: string;
        }[];
        /**
         * Whether request was successful or not
         */
        success: boolean;
      };
    }
>;

export type UrlscannerGetResponseTextVariables = {
  pathParams: UrlscannerGetResponseTextPathParams;
} & FetcherExtraProps;

/**
 * Returns the plain response of the network request.
 */
export const urlscannerGetResponseText = (variables: UrlscannerGetResponseTextVariables, signal?: AbortSignal) =>
  fetch<undefined, UrlscannerGetResponseTextError, undefined, {}, {}, UrlscannerGetResponseTextPathParams>({
    url: '/accounts/{accountId}/urlscanner/response/{responseId}',
    method: 'get',
    ...variables,
    signal
  });

export type UrlscannerSearchScansPathParams = {
  /**
   * Account ID.
   */
  accountId: string;
};

export type UrlscannerSearchScansQueryParams = {
  /**
   * Scan UUID.
   *
   * @format uuid
   */
  scan_id?: string;
  /**
   * Limit the number of objects in the response.
   *
   * @example 100
   */
  limit?: number;
  /**
   * Pagination cursor to get the next set of results.
   */
  next_cursor?: string;
  /**
   * Filter scans requested after date (inclusive).
   *
   * @format date-time
   */
  date_start?: string;
  /**
   * Filter scans requested before date (inclusive).
   *
   * @format date-time
   */
  date_end?: string;
  /**
   * Filter scans by URL of _any_ request made by the webpage
   *
   * @example https://example.com/?hello
   */
  url?: string;
  /**
   * Filter scans by hostname of _any_ request made by the webpage.
   *
   * @example example.com
   */
  hostname?: string;
  /**
   * Filter scans by url path of _any_ request made by the webpage.
   *
   * @example /samples/subresource-integrity/
   */
  path?: string;
  /**
   * Filter scans by IP address (IPv4 or IPv6) of _any_ request made by the webpage.
   *
   * @example 1.1.1.1
   */
  ip?: string;
  /**
   * Filter scans by Autonomous System Number (ASN) of _any_ request made by the webpage.
   *
   * @example 13335
   */
  asn?: string;
  /**
   * Filter scans by hash of any html/js/css request made by the webpage.
   */
  hash?: string;
  /**
   * Filter scans by submitted or scanned URL
   */
  page_url?: string;
  /**
   * Filter scans by main page hostname (domain of effective URL).
   */
  page_hostname?: string;
  /**
   * Filter scans by exact match of effective URL path (also supports suffix search).
   */
  page_path?: string;
  /**
   * Filter scans by main page Autonomous System Number (ASN).
   */
  page_asn?: string;
  /**
   * Filter scans by  main page IP address (IPv4 or IPv6).
   */
  page_ip?: string;
  /**
   * Return only scans created by account.
   */
  account_scans?: boolean;
  /**
   * Filter scans by malicious verdict.
   */
  is_malicious?: boolean;
};

export type UrlscannerSearchScansError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      /**
       * @example Scan ID is not a valid UUID.
       */
      message: string;
    }[];
    messages: {
      message: string;
    }[];
    /**
     * Whether request was successful or not
     */
    success: boolean;
  };
}>;

export type UrlscannerSearchScansResponse = {
  errors: {
    /**
     * @example Error
     */
    message: string;
  }[];
  messages: {
    /**
     * @example OK
     */
    message: string;
  }[];
  result: {
    tasks: {
      /**
       * Alpha-2 country code
       */
      country: string;
      /**
       * Whether scan was successful or not
       */
      success: boolean;
      /**
       * When scan was submitted (UTC)
       *
       * @format date-time
       */
      time: string;
      /**
       * Scan url (after redirects)
       *
       * @example https://www.example.com/
       */
      url: string;
      /**
       * Scan id
       *
       * @format uuid
       */
      uuid: string;
      /**
       * Visibility status.
       *
       * @example public
       */
      visibility: string;
    }[];
  };
  /**
   * Whether search request was successful or not
   */
  success: boolean;
};

export type UrlscannerSearchScansVariables = {
  pathParams: UrlscannerSearchScansPathParams;
  queryParams?: UrlscannerSearchScansQueryParams;
} & FetcherExtraProps;

/**
 * Search scans by date and webpages' requests, including full URL (after redirects), hostname, and path. <br/> A successful scan will appear in search results a few minutes after finishing but may take much longer if the system in under load. By default, only successfully completed scans will appear in search results, unless searching by `scanId`. Please take into account that older scans may be removed from the search index at an unspecified time.
 */
export const urlscannerSearchScans = (variables: UrlscannerSearchScansVariables, signal?: AbortSignal) =>
  fetch<
    UrlscannerSearchScansResponse,
    UrlscannerSearchScansError,
    undefined,
    {},
    UrlscannerSearchScansQueryParams,
    UrlscannerSearchScansPathParams
  >({ url: '/accounts/{accountId}/urlscanner/scan', method: 'get', ...variables, signal });

export type UrlscannerCreateScanPathParams = {
  /**
   * Account ID.
   */
  accountId: string;
};

export type UrlscannerCreateScanError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          /**
           * @example Scan ID is not a valid UUID.
           */
          message: string;
        }[];
        messages: {
          message: string;
        }[];
        /**
         * Whether request was successful or not
         */
        success: boolean;
      };
    }
  | {
      status: 409;
      payload: {
        errors: {
          /**
           * @example Submission unsuccessful
           */
          message: string;
        }[];
        messages: {
          message: string;
        }[];
        result: {
          tasks: {
            /**
             * Submitter location
             *
             * @example PT
             */
            clientLocation: string;
            clientType: 'Site' | 'Automatic' | 'Api';
            /**
             * URL of the primary request, after all HTTP redirects
             *
             * @example http://example.com/
             */
            effectiveUrl: string;
            errors: {
              message: string;
            }[];
            scannedFrom: {
              /**
               * IATA code of Cloudflare datacenter
               *
               * @example MAD
               */
              colo: string;
            };
            status: 'Queued' | 'InProgress' | 'InPostProcessing' | 'Finished';
            /**
             * @example true
             */
            success: boolean;
            /**
             * @example 2023-05-03T17:05:04.843Z
             */
            time: string;
            /**
             * @example 2023-05-03T17:05:19.374Z
             */
            timeEnd: string;
            /**
             * Submitted URL
             *
             * @example http://example.com
             */
            url: string;
            /**
             * Scan ID
             *
             * @example 2ee568d0-bf70-4827-b922-b7088c0f056f
             */
            uuid: string;
            visibility: 'Public' | 'Unlisted';
          }[];
        };
        /**
         * @example true
         */
        success: boolean;
      };
    }
  | {
      status: 429;
      payload: {
        errors: {
          /**
           * @example Submission unsuccessful
           */
          message: string;
        }[];
        messages: {
          message: string;
        }[];
        /**
         * @example true
         */
        success: boolean;
      };
    }
>;

export type UrlscannerCreateScanResponse = {
  errors: {
    /**
     * @example Submission unsuccessful
     */
    message: string;
  }[];
  messages: {
    /**
     * @example Submission successful
     */
    message: string;
  }[];
  result: {
    /**
     * Time when url was submitted for scanning.
     *
     * @format date-time
     */
    time: string;
    /**
     * Canonical form of submitted URL. Use this if you want to later search by URL.
     */
    url: string;
    /**
     * Scan ID.
     *
     * @format uuid
     */
    uuid: string;
    /**
     * Submitted visibility status.
     *
     * @example Public
     */
    visibility: string;
  };
  success: boolean;
};

export type UrlscannerCreateScanRequestBody = {
  /**
   * Set custom headers.
   */
  customHeaders?: {
    [key: string]: string;
  };
  /**
   * Take multiple screenshots targeting different device types.
   *
   * @default desktop
   */
  screenshotsResolutions?: ('desktop' | 'mobile' | 'tablet')[];
  /**
   * @example https://www.example.com
   */
  url: string;
  /**
   * The option `Public` means it will be included in listings like recent scans and search results. `Unlisted` means it will not be included in the aforementioned listings, users will need to have the scan's ID to access it. A a scan will be automatically marked as unlisted if it fails, if it contains potential PII or other sensitive material.
   *
   * @default Public
   */
  visibility?: 'Public' | 'Unlisted';
};

export type UrlscannerCreateScanVariables = {
  body: UrlscannerCreateScanRequestBody;
  pathParams: UrlscannerCreateScanPathParams;
} & FetcherExtraProps;

/**
 * Submit a URL to scan. You can also set some options, like the visibility level and custom headers. Check limits at https://developers.cloudflare.com/security-center/investigate/scan-limits/.
 */
export const urlscannerCreateScan = (variables: UrlscannerCreateScanVariables, signal?: AbortSignal) =>
  fetch<
    UrlscannerCreateScanResponse,
    UrlscannerCreateScanError,
    UrlscannerCreateScanRequestBody,
    {},
    {},
    UrlscannerCreateScanPathParams
  >({ url: '/accounts/{accountId}/urlscanner/scan', method: 'post', ...variables, signal });

export type UrlscannerGetScanPathParams = {
  /**
   * Scan UUID.
   *
   * @format uuid
   */
  scanId: string;
  /**
   * Account ID.
   */
  accountId: string;
};

export type UrlscannerGetScanQueryParams = {
  /**
   * Whether to return full report (scan summary and network log).
   */
  full?: boolean;
};

export type UrlscannerGetScanError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          /**
           * @example Scan ID is not a valid UUID.
           */
          message: string;
        }[];
        messages: {
          message: string;
        }[];
        /**
         * Whether request was successful or not
         */
        success: boolean;
      };
    }
  | {
      status: 404;
      payload: {
        errors: {
          /**
           * @example Scan not found.
           */
          message: string;
        }[];
        messages: {
          message: string;
        }[];
        /**
         * Whether request was successful or not
         */
        success: boolean;
      };
    }
>;

export type UrlscannerGetScanVariables = {
  pathParams: UrlscannerGetScanPathParams;
  queryParams?: UrlscannerGetScanQueryParams;
} & FetcherExtraProps;

/**
 * Get URL scan by uuid
 */
export const urlscannerGetScan = (variables: UrlscannerGetScanVariables, signal?: AbortSignal) =>
  fetch<
    | {
        errors: {
          /**
           * @example Error
           */
          message: string;
        }[];
        messages: {
          /**
           * @example OK
           */
          message: string;
        }[];
        result: {
          scan: {
            /**
             * Dictionary of Autonomous System Numbers where ASN's are the keys
             */
            asns?: {
              /**
               * ASN's contacted
               */
              asn?: {
                /**
                 * @example 15133
                 */
                asn: string;
                /**
                 * @example EDGECAST
                 */
                description: string;
                /**
                 * @example US
                 */
                location_alpha2: string;
                /**
                 * @example EDGECAST
                 */
                name: string;
                /**
                 * @example Edgecast Inc.
                 */
                org_name: string;
              };
            };
            certificates: {
              issuer: string;
              /**
               * @example rkmod.somee.com
               */
              subjectName: string;
              /**
               * @example 1682684400
               */
              validFrom: number;
              /**
               * @example 1696698000
               */
              validTo: number;
            }[];
            domains?: {
              ['example.com']?: {
                categories: {
                  content?: {
                    id: number;
                    /**
                     * @example Technology
                     */
                    name: string;
                    super_category_id?: number;
                  }[];
                  inherited: {
                    content?: {
                      id: number;
                      /**
                       * @example Technology
                       */
                      name: string;
                      super_category_id?: number;
                    }[];
                    /**
                     * @example example.com
                     */
                    from?: string;
                    risks?: {
                      id: number;
                      /**
                       * @example Technology
                       */
                      name: string;
                      super_category_id?: number;
                    }[];
                  };
                  risks?: {
                    id: number;
                    /**
                     * @example Technology
                     */
                    name: string;
                    super_category_id?: number;
                  }[];
                };
                dns: {
                  /**
                   * @example 93.184.216.34
                   */
                  address: string;
                  dnssec_valid: boolean;
                  /**
                   * @example example.com
                   */
                  name: string;
                  /**
                   * @example A
                   */
                  type: string;
                }[];
                /**
                 * @example example.com
                 */
                name: string;
                rank: {
                  /**
                   * @example 500
                   */
                  bucket: string;
                  /**
                   * @example example.com
                   */
                  name: string;
                  /**
                   * Rank in the Global Radar Rank, if set. See more at https://blog.cloudflare.com/radar-domain-rankings/
                   */
                  rank?: number;
                };
                /**
                 * @example Apex domain
                 */
                type: string;
              };
            };
            geo: {
              /**
               * GeoIP continent location
               */
              continents: string[];
              /**
               * GeoIP country location
               */
              locations: string[];
            };
            ips?: {
              ip?: {
                /**
                 * @example 15133
                 */
                asn: string;
                /**
                 * @example EDGECAST
                 */
                asnDescription: string;
                /**
                 * @example US
                 */
                asnLocationAlpha2: string;
                /**
                 * @example EDGECAST
                 */
                asnName: string;
                /**
                 * @example Edgecast Inc.
                 */
                asnOrgName: string;
                /**
                 * @example North America
                 */
                continent: string;
                /**
                 * @example 6252001
                 */
                geonameId: string;
                /**
                 * @example 2606:2800:220:1:248:1893:25c8:1946
                 */
                ip: string;
                /**
                 * @example IPv6
                 */
                ipVersion: string;
                /**
                 * @example 39.76
                 */
                latitude: string;
                /**
                 * @example US
                 */
                locationAlpha2: string;
                /**
                 * @example United States
                 */
                locationName: string;
                /**
                 * @example -98.5
                 */
                longitude: string;
                subdivision1Name: string;
                subdivision2Name: string;
              };
            };
            links?: {
              link?: {
                /**
                 * Outgoing link detected in the DOM
                 *
                 * @example https://www.iana.org/domains/example
                 */
                href: string;
                /**
                 * @example More information...
                 */
                text: string;
              };
            };
            meta: {
              processors: {
                categories: {
                  content: {
                    /**
                     * @example 155
                     */
                    id: number;
                    /**
                     * @example Technology
                     */
                    name: string;
                    super_category_id?: number;
                  }[];
                  risks: {
                    /**
                     * @example 17
                     */
                    id: number;
                    /**
                     * @example Newly Seen Domains
                     */
                    name: string;
                    /**
                     * @example 32
                     */
                    super_category_id: number;
                  }[];
                };
                phishing: string[];
                rank: {
                  /**
                   * @example 500
                   */
                  bucket: string;
                  /**
                   * @example example.com
                   */
                  name: string;
                  /**
                   * Rank in the Global Radar Rank, if set. See more at https://blog.cloudflare.com/radar-domain-rankings/
                   */
                  rank?: number;
                };
                tech: {
                  categories: {
                    groups: number[];
                    /**
                     * @example 63
                     */
                    id: number;
                    /**
                     * @example IAAS
                     */
                    name: string;
                    /**
                     * @example 8
                     */
                    priority: number;
                    /**
                     * @example iaas
                     */
                    slug: string;
                  }[];
                  /**
                   * @example 100
                   */
                  confidence: number;
                  description?: string;
                  evidence: {
                    impliedBy: string[];
                    patterns: {
                      /**
                       * @example 100
                       */
                      confidence: number;
                      excludes: string[];
                      implies: string[];
                      /**
                       * @example ECS
                       */
                      match: string;
                      /**
                       * Header or Cookie name when set
                       *
                       * @example server
                       */
                      name: string;
                      /**
                       * @example ^ECS
                       */
                      regex: string;
                      /**
                       * @example headers
                       */
                      type: string;
                      /**
                       * @example ECS (dcb/7EEE)
                       */
                      value: string;
                      version: string;
                    }[];
                  };
                  /**
                   * @example Amazon ECS.svg
                   */
                  icon: string;
                  /**
                   * @example Amazon ECS
                   */
                  name: string;
                  /**
                   * @example amazon-ecs
                   */
                  slug: string;
                  /**
                   * @example https://aws.amazon.com/ecs/
                   */
                  website: string;
                }[];
              };
            };
            page: {
              /**
               * @example 15133
               */
              asn: string;
              /**
               * @example US
               */
              asnLocationAlpha2: string;
              /**
               * @example EDGECAST
               */
              asnname: string;
              console: {
                /**
                 * @example network
                 */
                category: string;
                /**
                 * @example Failed to load resource: the server responded with a status of 404 (Not Found)
                 */
                text: string;
                /**
                 * @example error
                 */
                type: string;
                /**
                 * @example http://example.com/favicon.ico
                 */
                url?: string;
              }[];
              cookies: {
                /**
                 * @example rkmod.somee.com
                 */
                domain: string;
                /**
                 * @example -1
                 */
                expires: number;
                httpOnly: boolean;
                /**
                 * @example b
                 */
                name: string;
                /**
                 * @example /
                 */
                path: string;
                /**
                 * @example Medium
                 */
                priority?: string;
                sameParty: boolean;
                secure: boolean;
                /**
                 * @example true
                 */
                session: boolean;
                /**
                 * @example 2
                 */
                size: number;
                /**
                 * @example 443
                 */
                sourcePort: number;
                /**
                 * @example Secure
                 */
                sourceScheme: string;
                /**
                 * @example b
                 */
                value: string;
              }[];
              /**
               * @example United States
               */
              country: string;
              /**
               * @example US
               */
              countryLocationAlpha2: string;
              /**
               * @example example.com
               */
              domain: string;
              headers: {
                /**
                 * @example Content-Length
                 */
                name: string;
                /**
                 * @example 648
                 */
                value: string;
              }[];
              /**
               * @example 2606:2800:220:1:248:1893:25c8:1946
               */
              ip: string;
              js: {
                variables: {
                  /**
                   * @example checkFrame
                   */
                  name: string;
                  /**
                   * @example string
                   */
                  type: string;
                }[];
              };
              securityViolations: {
                /**
                 * @example csp
                 */
                category: string;
                /**
                 * @example [Report Only] Refused to load the stylesheet 'https://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css' because it violates the following Content Security Policy directive: ...
                 */
                text: string;
                /**
                 * @example http://example.com/
                 */
                url: string;
              }[];
              /**
               * @example 200
               */
              status: number;
              subdivision1Name: string;
              subdivision2name: string;
              /**
               * @example http://example.com/
               */
              url: string;
            };
            performance: {
              /**
               * @example 82.59999999403954
               */
              connectEnd: number;
              /**
               * @example 72.79999999701977
               */
              connectStart: number;
              /**
               * @example 1256
               */
              decodedBodySize: number;
              /**
               * @example 306
               */
              domComplete: number;
              /**
               * @example 305.8999999910593
               */
              domContentLoadedEventEnd: number;
              /**
               * @example 305.8999999910593
               */
              domContentLoadedEventStart: number;
              /**
               * @example 305.8999999910593
               */
              domInteractive: number;
              /**
               * @example 72.79999999701977
               */
              domainLookupEnd: number;
              /**
               * @example 2.199999988079071
               */
              domainLookupStart: number;
              /**
               * @example 306
               */
              duration: number;
              /**
               * @example 648
               */
              encodedBodySize: number;
              /**
               * @example navigation
               */
              entryType: string;
              /**
               * @example 0.8999999910593033
               */
              fetchStart: number;
              /**
               * @example navigation
               */
              initiatorType: string;
              /**
               * @example 306
               */
              loadEventEnd: number;
              /**
               * @example 306
               */
              loadEventStart: number;
              /**
               * @example http://example.com/
               */
              name: string;
              /**
               * @example http/1.1
               */
              nextHopProtocol: string;
              redirectCount: number;
              redirectEnd: number;
              redirectStart: number;
              /**
               * @example 82.69999998807907
               */
              requestStart: number;
              /**
               * @example 270.8999999910593
               */
              responseEnd: number;
              /**
               * @example 265.69999998807907
               */
              responseStart: number;
              secureConnectionStart: number;
              startTime: number;
              /**
               * @example 948
               */
              transferSize: number;
              /**
               * @example navigate
               */
              type: string;
              unloadEventEnd: number;
              unloadEventStart: number;
              workerStart: number;
            }[];
            task: {
              /**
               * Submitter location
               *
               * @example PT
               */
              clientLocation: string;
              clientType: 'Site' | 'Automatic' | 'Api';
              /**
               * URL of the primary request, after all HTTP redirects
               *
               * @example http://example.com/
               */
              effectiveUrl: string;
              errors: {
                message: string;
              }[];
              scannedFrom: {
                /**
                 * IATA code of Cloudflare datacenter
                 *
                 * @example MAD
                 */
                colo: string;
              };
              status: 'Queued' | 'InProgress' | 'InPostProcessing' | 'Finished';
              /**
               * @example true
               */
              success: boolean;
              /**
               * @example 2023-05-03T17:05:04.843Z
               */
              time: string;
              /**
               * @example 2023-05-03T17:05:19.374Z
               */
              timeEnd: string;
              /**
               * Submitted URL
               *
               * @example http://example.com
               */
              url: string;
              /**
               * Scan ID
               *
               * @example 2ee568d0-bf70-4827-b922-b7088c0f056f
               */
              uuid: string;
              visibility: 'Public' | 'Unlisted';
            };
            verdicts: {
              overall: {
                categories: {
                  /**
                   * @example 117
                   */
                  id: number;
                  /**
                   * @example Malware
                   */
                  name: string;
                  /**
                   * @example 32
                   */
                  super_category_id: number;
                }[];
                /**
                 * At least one of our subsystems marked the site as potentially malicious at the time of the scan.
                 *
                 * @example true
                 */
                malicious: boolean;
                phishing: string[];
              };
            };
          };
        };
        /**
         * Whether request was successful or not
         */
        success: boolean;
      }
    | {
        errors: {
          message: string;
        }[];
        messages: {
          /**
           * @example In Progress
           */
          message: string;
        }[];
        result: {
          scan: {
            task: {
              /**
               * @example http://example.com/
               */
              effectiveUrl: string;
              errors: {
                message: string;
              }[];
              /**
               * @example PT
               */
              location: string;
              /**
               * @example enam
               */
              region: string;
              /**
               * @example InProgress
               */
              status: string;
              /**
               * @example true
               */
              success: boolean;
              /**
               * @example 2023-05-03T17:05:04.843Z
               */
              time: string;
              /**
               * @example http://example.com
               */
              url: string;
              /**
               * @example 2ee568d0-bf70-4827-b922-b7088c0f056f
               */
              uuid: string;
              /**
               * @example Public
               */
              visibility: string;
            };
          };
        };
        /**
         * Whether request was successful or not
         */
        success: boolean;
      },
    UrlscannerGetScanError,
    undefined,
    {},
    UrlscannerGetScanQueryParams,
    UrlscannerGetScanPathParams
  >({ url: '/accounts/{accountId}/urlscanner/scan/{scanId}', method: 'get', ...variables, signal });

export type UrlscannerGetScanHarPathParams = {
  /**
   * Scan UUID.
   *
   * @format uuid
   */
  scanId: string;
  /**
   * Account ID.
   */
  accountId: string;
};

export type UrlscannerGetScanHarError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          /**
           * @example Scan ID is not a valid UUID.
           */
          message: string;
        }[];
        messages: {
          message: string;
        }[];
        /**
         * Whether request was successful or not
         */
        success: boolean;
      };
    }
  | {
      status: 404;
      payload: {
        errors: {
          /**
           * @example Scan not found.
           */
          message: string;
        }[];
        messages: {
          message: string;
        }[];
        /**
         * Whether request was successful or not
         */
        success: boolean;
      };
    }
>;

export type UrlscannerGetScanHarVariables = {
  pathParams: UrlscannerGetScanHarPathParams;
} & FetcherExtraProps;

/**
 * Get a URL scan's HAR file. See HAR spec at http://www.softwareishard.com/blog/har-12-spec/.
 */
export const urlscannerGetScanHar = (variables: UrlscannerGetScanHarVariables, signal?: AbortSignal) =>
  fetch<
    | {
        errors: {
          /**
           * @example Error
           */
          message: string;
        }[];
        messages: {
          /**
           * @example OK
           */
          message: string;
        }[];
        result: {
          har: {
            log: {
              creator: {
                /**
                 * @example https://github.com/sitespeedio/chrome-har
                 */
                comment: string;
                /**
                 * @example chrome-har
                 */
                name: string;
                /**
                 * @example 0.13.1
                 */
                version: string;
              };
              entries: {
                /**
                 * @example VeryHigh
                 */
                _initialPriority: string;
                /**
                 * @example other
                 */
                _initiator_type: string;
                /**
                 * @example VeryHigh
                 */
                _priority: string;
                /**
                 * @example DDC779F0CB3746BAF283EC1A51B0F2F8
                 */
                _requestId: string;
                /**
                 * @example 114135.331081
                 */
                _requestTime: number;
                /**
                 * @example document
                 */
                _resourceType: string;
                cache: Record<string, any>;
                /**
                 * @example 33
                 */
                connection: string;
                /**
                 * @example page_1
                 */
                pageref: string;
                request: {
                  bodySize: number;
                  headers: {
                    /**
                     * @example Upgrade-Insecure-Requests
                     */
                    name: string;
                    /**
                     * @example 1
                     */
                    value: string;
                  }[];
                  /**
                   * @example 197
                   */
                  headersSize: number;
                  /**
                   * @example http/1.1
                   */
                  httpVersion: string;
                  /**
                   * @example GET
                   */
                  method: string;
                  /**
                   * @example http://example.com/
                   */
                  url: string;
                };
                response: {
                  /**
                   * @example 1071
                   */
                  _transferSize: number;
                  /**
                   * @example 648
                   */
                  bodySize: number;
                  content: {
                    /**
                     * @example 608
                     */
                    compression?: number;
                    /**
                     * @example text/html
                     */
                    mimeType: string;
                    /**
                     * @example 1256
                     */
                    size: number;
                  };
                  headers: {
                    /**
                     * @example Content-Encoding
                     */
                    name: string;
                    /**
                     * @example gzip
                     */
                    value: string;
                  }[];
                  /**
                   * @example 423
                   */
                  headersSize: number;
                  /**
                   * @example http/1.1
                   */
                  httpVersion: string;
                  redirectURL: string;
                  /**
                   * @example 200
                   */
                  status: number;
                  /**
                   * @example OK
                   */
                  statusText: string;
                };
                /**
                 * @example 2606:2800:220:1:248:1893:25c8:1946
                 */
                serverIPAddress: string;
                /**
                 * @example 2023-05-03T17:05:13.196Z
                 */
                startedDateTime: string;
                /**
                 * @example 268.64
                 */
                time: number;
              }[];
              pages: {
                /**
                 * @example page_1
                 */
                id: string;
                pageTimings: {
                  /**
                   * @example 305.408
                   */
                  onContentLoad: number;
                  /**
                   * @example 305.169
                   */
                  onLoad: number;
                };
                /**
                 * @example 2023-05-03T17:05:13.195Z
                 */
                startedDateTime: string;
                /**
                 * @example http://example.com/
                 */
                title: string;
              }[];
              /**
               * @example 1.2
               */
              version: string;
            };
          };
        };
        /**
         * Whether search request was successful or not
         */
        success: boolean;
      }
    | {
        errors: {
          message: string;
        }[];
        messages: {
          /**
           * @example In Progress
           */
          message: string;
        }[];
        result: {
          scan: {
            task: {
              /**
               * @example http://example.com/
               */
              effectiveUrl: string;
              errors: {
                message: string;
              }[];
              /**
               * @example PT
               */
              location: string;
              /**
               * @example enam
               */
              region: string;
              /**
               * @example InProgress
               */
              status: string;
              /**
               * @example true
               */
              success: boolean;
              /**
               * @example 2023-05-03T17:05:04.843Z
               */
              time: string;
              /**
               * @example http://example.com
               */
              url: string;
              /**
               * @example 2ee568d0-bf70-4827-b922-b7088c0f056f
               */
              uuid: string;
              /**
               * @example Public
               */
              visibility: string;
            };
          };
        };
        /**
         * Whether request was successful or not
         */
        success: boolean;
      },
    UrlscannerGetScanHarError,
    undefined,
    {},
    {},
    UrlscannerGetScanHarPathParams
  >({ url: '/accounts/{accountId}/urlscanner/scan/{scanId}/har', method: 'get', ...variables, signal });

export type UrlscannerGetScanScreenshotPathParams = {
  /**
   * Scan UUID.
   *
   * @format uuid
   */
  scanId: string;
  /**
   * Account ID.
   */
  accountId: string;
};

export type UrlscannerGetScanScreenshotQueryParams = {
  /**
   * Target device type.
   *
   * @default desktop
   */
  resolution?: 'desktop' | 'mobile' | 'tablet';
};

export type UrlscannerGetScanScreenshotError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          /**
           * @example Scan ID is not a valid UUID.
           */
          message: string;
        }[];
        messages: {
          message: string;
        }[];
        /**
         * Whether request was successful or not
         */
        success: boolean;
      };
    }
  | {
      status: 404;
      payload: {
        errors: {
          /**
           * @example Scan not found.
           */
          message: string;
        }[];
        messages: {
          message: string;
        }[];
        /**
         * Whether request was successful or not
         */
        success: boolean;
      };
    }
>;

export type UrlscannerGetScanScreenshotResponse = {
  errors: {
    message: string;
  }[];
  messages: {
    /**
     * @example In Progress
     */
    message: string;
  }[];
  result: {
    scan: {
      task: {
        /**
         * @example http://example.com/
         */
        effectiveUrl: string;
        errors: {
          message: string;
        }[];
        /**
         * @example PT
         */
        location: string;
        /**
         * @example enam
         */
        region: string;
        /**
         * @example InProgress
         */
        status: string;
        /**
         * @example true
         */
        success: boolean;
        /**
         * @example 2023-05-03T17:05:04.843Z
         */
        time: string;
        /**
         * @example http://example.com
         */
        url: string;
        /**
         * @example 2ee568d0-bf70-4827-b922-b7088c0f056f
         */
        uuid: string;
        /**
         * @example Public
         */
        visibility: string;
      };
    };
  };
  /**
   * Whether request was successful or not
   */
  success: boolean;
};

export type UrlscannerGetScanScreenshotVariables = {
  pathParams: UrlscannerGetScanScreenshotPathParams;
  queryParams?: UrlscannerGetScanScreenshotQueryParams;
} & FetcherExtraProps;

/**
 * Get scan's screenshot by resolution (desktop/mobile/tablet).
 */
export const urlscannerGetScanScreenshot = (variables: UrlscannerGetScanScreenshotVariables, signal?: AbortSignal) =>
  fetch<
    UrlscannerGetScanScreenshotResponse,
    UrlscannerGetScanScreenshotError,
    undefined,
    {},
    UrlscannerGetScanScreenshotQueryParams,
    UrlscannerGetScanScreenshotPathParams
  >({ url: '/accounts/{accountId}/urlscanner/scan/{scanId}/screenshot', method: 'get', ...variables, signal });

export type UrlscannerCreateScanBulkV2PathParams = {
  /**
   * Account ID.
   */
  accountId: string;
};

export type UrlscannerCreateScanBulkV2Error = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          detail: string;
          /**
           * Status code.
           *
           * @example 400
           */
          status: number;
          /**
           * @example Invalid url
           */
          title: string;
        }[];
        message: string;
        /**
         * Status code.
         *
         * @example 400
         */
        status: number;
      };
    }
  | {
      status: 429;
      payload: {
        description?: string;
        errors: {
          /**
           * @example DNS Error - Could not resolve domain.
           */
          detail: string;
          status: Record<string, any>;
          /**
           * @example DNS Error - Could not resolve domain.
           */
          title: string;
        }[];
        message: string;
        status: Record<string, any>;
      };
    }
>;

export type UrlscannerCreateScanBulkV2Response = {
  /**
   * URL to api report.
   */
  api: string;
  options?: {
    useragent?: string;
  };
  /**
   * URL to report.
   */
  result: string;
  /**
   * Submitted URL
   */
  url: string;
  /**
   * Scan ID.
   *
   * @format uuid
   */
  uuid: string;
  /**
   * Submitted visibility status.
   *
   * @example Public
   */
  visibility: string;
}[];

export type UrlscannerCreateScanBulkV2RequestBody = {
  /**
   * Set custom headers.
   */
  customHeaders?: {
    [key: string]: string;
  };
  /**
   * @maxLength 4096
   */
  customagent?: string;
  /**
   * @maxLength 4096
   */
  referer?: string;
  /**
   * Take multiple screenshots targeting different device types.
   *
   * @default desktop
   */
  screenshotsResolutions?: ('desktop' | 'mobile' | 'tablet')[];
  /**
   * @example https://www.example.com
   */
  url: string;
  /**
   * The option `Public` means it will be included in listings like recent scans and search results. `Unlisted` means it will not be included in the aforementioned listings, users will need to have the scan's ID to access it. A a scan will be automatically marked as unlisted if it fails, if it contains potential PII or other sensitive material.
   *
   * @default Public
   */
  visibility?: 'Public' | 'Unlisted';
}[];

export type UrlscannerCreateScanBulkV2Variables = {
  body?: UrlscannerCreateScanBulkV2RequestBody;
  pathParams: UrlscannerCreateScanBulkV2PathParams;
} & FetcherExtraProps;

/**
 * Submit URLs to scan. Check limits at https://developers.cloudflare.com/security-center/investigate/scan-limits/ and take into account scans submitted in bulk have lower priority and may take longer to finish.
 */
export const urlscannerCreateScanBulkV2 = (variables: UrlscannerCreateScanBulkV2Variables, signal?: AbortSignal) =>
  fetch<
    UrlscannerCreateScanBulkV2Response,
    UrlscannerCreateScanBulkV2Error,
    UrlscannerCreateScanBulkV2RequestBody,
    {},
    {},
    UrlscannerCreateScanBulkV2PathParams
  >({ url: '/accounts/{accountId}/urlscanner/v2/bulk', method: 'post', ...variables, signal });

export type UrlscannerGetScanDomV2PathParams = {
  /**
   * Scan UUID.
   *
   * @format uuid
   */
  scanId: string;
  /**
   * Account ID.
   */
  accountId: string;
};

export type UrlscannerGetScanDomV2Error = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          detail: string;
          /**
           * Status code.
           *
           * @example 400
           */
          status: number;
          /**
           * @example Invalid url
           */
          title: string;
        }[];
        message: string;
        /**
         * Status code.
         *
         * @example 400
         */
        status: number;
      };
    }
  | {
      status: 404;
      payload: {
        errors: {
          /**
           * @example Queued
           */
          detail: string;
          /**
           * Status code.
           *
           * @example 404
           */
          status: number;
          /**
           * @example Scan is not finished yet.
           */
          title: string;
        }[];
        /**
         * Scan not found or in progress.
         *
         * @example Scan is not finished yet.
         */
        message: string;
        /**
         * Status code.
         *
         * @example 404
         */
        status: number;
        task: {
          /**
           * @example Queued
           */
          status: string;
          time: string;
          url: string;
          uuid: string;
          /**
           * @example public
           */
          visibility: string;
        };
      };
    }
>;

export type UrlscannerGetScanDomV2Variables = {
  pathParams: UrlscannerGetScanDomV2PathParams;
} & FetcherExtraProps;

/**
 * Returns a plain text response, with the scan's DOM content as rendered by Chrome.
 */
export const urlscannerGetScanDomV2 = (variables: UrlscannerGetScanDomV2Variables, signal?: AbortSignal) =>
  fetch<undefined, UrlscannerGetScanDomV2Error, undefined, {}, {}, UrlscannerGetScanDomV2PathParams>({
    url: '/accounts/{accountId}/urlscanner/v2/dom/{scanId}',
    method: 'get',
    ...variables,
    signal
  });

export type UrlscannerGetScanHarV2PathParams = {
  /**
   * Scan UUID.
   *
   * @format uuid
   */
  scanId: string;
  /**
   * Account ID.
   */
  accountId: string;
};

export type UrlscannerGetScanHarV2Error = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          detail: string;
          /**
           * Status code.
           *
           * @example 400
           */
          status: number;
          /**
           * @example Invalid url
           */
          title: string;
        }[];
        message: string;
        /**
         * Status code.
         *
         * @example 400
         */
        status: number;
      };
    }
  | {
      status: 404;
      payload: {
        errors: {
          /**
           * @example Queued
           */
          detail: string;
          /**
           * Status code.
           *
           * @example 404
           */
          status: number;
          /**
           * @example Scan is not finished yet.
           */
          title: string;
        }[];
        /**
         * Scan not found or in progress.
         *
         * @example Scan is not finished yet.
         */
        message: string;
        /**
         * Status code.
         *
         * @example 404
         */
        status: number;
        task: {
          /**
           * @example Queued
           */
          status: string;
          time: string;
          url: string;
          uuid: string;
          /**
           * @example public
           */
          visibility: string;
        };
      };
    }
>;

export type UrlscannerGetScanHarV2Response = {
  log: {
    creator: {
      /**
       * @example https://github.com/sitespeedio/chrome-har
       */
      comment: string;
      /**
       * @example chrome-har
       */
      name: string;
      /**
       * @example 0.13.1
       */
      version: string;
    };
    entries: {
      /**
       * @example VeryHigh
       */
      _initialPriority: string;
      /**
       * @example other
       */
      _initiator_type: string;
      /**
       * @example VeryHigh
       */
      _priority: string;
      /**
       * @example DDC779F0CB3746BAF283EC1A51B0F2F8
       */
      _requestId: string;
      /**
       * @example 114135.331081
       */
      _requestTime: number;
      /**
       * @example document
       */
      _resourceType: string;
      cache: Record<string, any>;
      /**
       * @example 33
       */
      connection: string;
      /**
       * @example page_1
       */
      pageref: string;
      request: {
        bodySize: number;
        headers: {
          /**
           * @example Upgrade-Insecure-Requests
           */
          name: string;
          /**
           * @example 1
           */
          value: string;
        }[];
        /**
         * @example 197
         */
        headersSize: number;
        /**
         * @example http/1.1
         */
        httpVersion: string;
        /**
         * @example GET
         */
        method: string;
        /**
         * @example http://example.com/
         */
        url: string;
      };
      response: {
        /**
         * @example 1071
         */
        _transferSize: number;
        /**
         * @example 648
         */
        bodySize: number;
        content: {
          /**
           * @example 608
           */
          compression?: number;
          /**
           * @example text/html
           */
          mimeType: string;
          /**
           * @example 1256
           */
          size: number;
        };
        headers: {
          /**
           * @example Content-Encoding
           */
          name: string;
          /**
           * @example gzip
           */
          value: string;
        }[];
        /**
         * @example 423
         */
        headersSize: number;
        /**
         * @example http/1.1
         */
        httpVersion: string;
        redirectURL: string;
        /**
         * @example 200
         */
        status: number;
        /**
         * @example OK
         */
        statusText: string;
      };
      /**
       * @example 2606:2800:220:1:248:1893:25c8:1946
       */
      serverIPAddress: string;
      /**
       * @example 2023-05-03T17:05:13.196Z
       */
      startedDateTime: string;
      /**
       * @example 268.64
       */
      time: number;
    }[];
    pages: {
      /**
       * @example page_1
       */
      id: string;
      pageTimings: {
        /**
         * @example 305.408
         */
        onContentLoad: number;
        /**
         * @example 305.169
         */
        onLoad: number;
      };
      /**
       * @example 2023-05-03T17:05:13.195Z
       */
      startedDateTime: string;
      /**
       * @example http://example.com/
       */
      title: string;
    }[];
    /**
     * @example 1.2
     */
    version: string;
  };
};

export type UrlscannerGetScanHarV2Variables = {
  pathParams: UrlscannerGetScanHarV2PathParams;
} & FetcherExtraProps;

/**
 * Get a URL scan's HAR file. See HAR spec at http://www.softwareishard.com/blog/har-12-spec/.
 */
export const urlscannerGetScanHarV2 = (variables: UrlscannerGetScanHarV2Variables, signal?: AbortSignal) =>
  fetch<
    UrlscannerGetScanHarV2Response,
    UrlscannerGetScanHarV2Error,
    undefined,
    {},
    {},
    UrlscannerGetScanHarV2PathParams
  >({ url: '/accounts/{accountId}/urlscanner/v2/har/{scanId}', method: 'get', ...variables, signal });

export type UrlscannerGetResponseV2PathParams = {
  /**
   * Response hash.
   */
  responseId: string;
  /**
   * Account ID.
   */
  accountId: string;
};

export type UrlscannerGetResponseV2Error = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      detail: string;
      /**
       * Status code.
       *
       * @example 400
       */
      status: number;
      /**
       * @example Invalid url
       */
      title: string;
    }[];
    message: string;
    /**
     * Status code.
     *
     * @example 400
     */
    status: number;
  };
}>;

export type UrlscannerGetResponseV2Variables = {
  pathParams: UrlscannerGetResponseV2PathParams;
} & FetcherExtraProps;

/**
 * Returns the raw response of the network request. If HTML, a plain text response will be returned.
 */
export const urlscannerGetResponseV2 = (variables: UrlscannerGetResponseV2Variables, signal?: AbortSignal) =>
  fetch<undefined, UrlscannerGetResponseV2Error, undefined, {}, {}, UrlscannerGetResponseV2PathParams>({
    url: '/accounts/{accountId}/urlscanner/v2/responses/{responseId}',
    method: 'get',
    ...variables,
    signal
  });

export type UrlscannerGetScanV2PathParams = {
  /**
   * Scan UUID.
   *
   * @format uuid
   */
  scanId: string;
  /**
   * Account ID.
   */
  accountId: string;
};

export type UrlscannerGetScanV2Error = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          detail: string;
          /**
           * Status code.
           *
           * @example 400
           */
          status: number;
          /**
           * @example Invalid url
           */
          title: string;
        }[];
        message: string;
        /**
         * Status code.
         *
         * @example 400
         */
        status: number;
      };
    }
  | {
      status: 404;
      payload: {
        errors: {
          /**
           * @example Queued
           */
          detail: string;
          /**
           * Status code.
           *
           * @example 404
           */
          status: number;
          /**
           * @example Scan is not finished yet.
           */
          title: string;
        }[];
        /**
         * Scan not found or in progress.
         *
         * @example Scan is not finished yet.
         */
        message: string;
        /**
         * Status code.
         *
         * @example 404
         */
        status: number;
        task: {
          /**
           * @example Queued
           */
          status: string;
          time: string;
          url: string;
          uuid: string;
          /**
           * @example public
           */
          visibility: string;
        };
      };
    }
>;

export type UrlscannerGetScanV2Response = {
  data: {
    console: {
      message: {
        level: string;
        source: string;
        text: string;
        url: string;
      };
    }[];
    cookies: {
      domain: string;
      expires: number;
      httpOnly: boolean;
      name: string;
      path: string;
      priority: string;
      sameParty: boolean;
      secure: boolean;
      session: boolean;
      size: number;
      sourcePort: number;
      sourceScheme: string;
      value: string;
    }[];
    globals: {
      prop: string;
      type: string;
    }[];
    links: {
      href: string;
      text: string;
    }[];
    performance: {
      duration: number;
      entryType: string;
      name: string;
      startTime: number;
    }[];
    requests: {
      request: {
        documentURL: string;
        frameId?: string;
        hasUserGesture: boolean;
        initiator: {
          host: string;
          type: string;
          url: string;
        };
        loaderId?: string;
        primaryRequest?: boolean;
        redirectHasExtraInfo: boolean;
        redirectResponse?: {
          charset: string;
          headers?: Record<string, any>;
          mimeType: string;
          protocol: string;
          remoteIPAddress: string;
          remotePort: number;
          securityHeaders: {
            name: string;
            value: string;
          }[];
          securityState: string;
          status: number;
          statusText: string;
          url: string;
        };
        request: {
          headers?: Record<string, any>;
          initialPriority: string;
          isSameSite: boolean;
          method: string;
          mixedContentType: string;
          referrerPolicy: string;
          url: string;
        };
        requestId: string;
        type: string;
        wallTime: number;
      };
      requests?: {
        documentURL: string;
        frameId: string;
        hasUserGesture: boolean;
        initiator: {
          type: string;
        };
        loaderId: string;
        redirectHasExtraInfo: boolean;
        request: {
          headers: {
            name: string;
          };
          initialPriority: string;
          isSameSite: boolean;
          method: string;
          mixedContentType: string;
          referrerPolicy: string;
          url: string;
        };
        requestId: string;
        type: string;
        wallTime: number;
      }[];
      response: {
        asn: {
          asn: string;
          country: string;
          description: string;
          ip: string;
          name: string;
          org: string;
        };
        contentAvailable?: boolean;
        dataLength: number;
        encodedDataLength: number;
        geoip: {
          city: string;
          country: string;
          country_name: string;
          geonameId: string;
          ll: Record<string, any>[];
          region: string;
        };
        hasExtraInfo: boolean;
        hash?: string;
        requestId: string;
        response: {
          charset: string;
          headers?: Record<string, any>;
          mimeType: string;
          protocol: string;
          remoteIPAddress: string;
          remotePort: number;
          securityDetails: {
            certificateId: number;
            certificateTransparencyCompliance: string;
            cipher: string;
            encryptedClientHello: boolean;
            issuer: string;
            keyExchange: string;
            keyExchangeGroup: string;
            protocol: string;
            sanList: string[];
            serverSignatureAlgorithm: number;
            subjectName: string;
            validFrom: number;
            validTo: number;
          };
          securityHeaders: {
            name: string;
            value: string;
          }[];
          securityState: string;
          status: number;
          statusText: string;
          url: string;
        };
        size: number;
        type: string;
      };
    }[];
  };
  lists: {
    asns: string[];
    certificates: {
      issuer: string;
      subjectName: string;
      validFrom: number;
      validTo: number;
    }[];
    continents: string[];
    countries: string[];
    domains: string[];
    hashes: string[];
    ips: string[];
    linkDomains: string[];
    servers: string[];
    urls: string[];
  };
  meta: {
    processors: {
      asn: {
        data: {
          asn: string;
          country: string;
          description: string;
          ip: string;
          name: string;
        }[];
      };
      dns: {
        data: {
          address: string;
          dnssec_valid: boolean;
          name: string;
          type: string;
        }[];
      };
      domainCategories: {
        data: {
          inherited: Record<string, any>;
          isPrimary: boolean;
          name: string;
        }[];
      };
      geoip: {
        data: {
          geoip: {
            city: string;
            country: string;
            country_name: string;
            ll: number[];
            region: string;
          };
          ip: string;
        }[];
      };
      phishing: {
        data: string[];
      };
      radarRank: {
        data: {
          bucket: string;
          hostname: string;
          rank?: number;
        }[];
      };
      urlCategories?: {
        data: {
          content: {
            id: number;
            name: string;
            super_category_id: number;
          }[];
          inherited: {
            content: {
              id: number;
              name: string;
              super_category_id: number;
            }[];
            from: string;
            risks: {
              id: number;
              name: string;
              super_category_id: number;
            }[];
          };
          name: string;
          risks: {
            id: number;
            name: string;
            super_category_id: number;
          }[];
        }[];
      };
      wappa: {
        data: {
          app: string;
          categories: {
            name: string;
            priority: number;
          }[];
          confidence: {
            confidence: number;
            name: string;
            pattern: string;
            patternType: string;
          }[];
          confidenceTotal: number;
          icon: string;
          website: string;
        }[];
      };
    };
  };
  page: {
    apexDomain: string;
    asn: string;
    asnname: string;
    city: string;
    country: string;
    domain: string;
    ip: string;
    mimeType: string;
    screenshot?: {
      dhash: string;
      mm3Hash: number;
      name: string;
      phash: string;
    };
    server: string;
    /**
     * @example 200
     */
    status: string;
    title: string;
    tlsAgeDays: number;
    tlsIssuer: string;
    tlsValidDays: number;
    tlsValidFrom: string;
    url: string;
  };
  scanner: {
    colo: string;
    country: string;
  };
  stats: {
    IPv6Percentage: number;
    domainStats: {
      count: number;
      countries: string[];
      domain: string;
      encodedSize: number;
      index: number;
      initiators: string[];
      ips: string[];
      redirects: number;
      size: number;
    }[];
    ipStats: {
      asn: {
        asn: string;
        country: string;
        description: string;
        ip: string;
        name: string;
        org: string;
      };
      count?: number;
      countries: string[];
      domains: string[];
      encodedSize: number;
      geoip: {
        city: string;
        country: string;
        country_name: string;
        ll: number[];
        region: string;
      };
      index: number;
      ip: string;
      ipv6: boolean;
      redirects: number;
      requests: number;
      size: number;
    }[];
    malicious: number;
    protocolStats: {
      count: number;
      countries: string[];
      encodedSize: number;
      ips: string[];
      protocol: string;
      size: number;
    }[];
    resourceStats: {
      compression: number;
      count: number;
      countries: string[];
      encodedSize: number;
      ips: string[];
      percentage: number;
      size: number;
      type: string;
    }[];
    securePercentage: number;
    secureRequests: number;
    serverStats: {
      count: number;
      countries: string[];
      encodedSize: number;
      ips: string[];
      server: string;
      size: number;
    }[];
    tlsStats: {
      count: number;
      countries: string[];
      encodedSize: number;
      ips: string[];
      protocols: {
        ['TLS 1.3 / AES_128_GCM']: number;
      };
      securityState: string;
      size: number;
    }[];
    totalLinks: number;
    uniqASNs: number;
    uniqCountries: number;
  };
  task: {
    apexDomain: string;
    domURL: string;
    domain: string;
    method: string;
    options: {
      /**
       * Custom headers set.
       */
      customHeaders?: Record<string, any>;
      screenshotsResolutions?: string[];
    };
    reportURL: string;
    screenshotURL: string;
    source: string;
    success: boolean;
    time: string;
    url: string;
    uuid: string;
    visibility: string;
  };
  verdicts: {
    overall: {
      categories: string[];
      hasVerdicts: boolean;
      malicious: boolean;
      tags: string[];
    };
  };
};

export type UrlscannerGetScanV2Variables = {
  pathParams: UrlscannerGetScanV2PathParams;
} & FetcherExtraProps;

/**
 * Get URL scan by uuid
 */
export const urlscannerGetScanV2 = (variables: UrlscannerGetScanV2Variables, signal?: AbortSignal) =>
  fetch<UrlscannerGetScanV2Response, UrlscannerGetScanV2Error, undefined, {}, {}, UrlscannerGetScanV2PathParams>({
    url: '/accounts/{accountId}/urlscanner/v2/result/{scanId}',
    method: 'get',
    ...variables,
    signal
  });

export type UrlscannerCreateScanV2PathParams = {
  /**
   * Account ID.
   */
  accountId: string;
};

export type UrlscannerCreateScanV2Error = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          detail: string;
          /**
           * Status code.
           *
           * @example 400
           */
          status: number;
          /**
           * @example Invalid url
           */
          title: string;
        }[];
        message: string;
        /**
         * Status code.
         *
         * @example 400
         */
        status: number;
      };
    }
  | {
      status: 409;
      payload: {
        /**
         * @example Scan request denied: hostname was recently scanned
         */
        description?: string;
        errors: {
          /**
           * @example DNS Error - Could not resolve domain.
           */
          detail: string;
          status: Record<string, any>;
          /**
           * @example DNS Error - Could not resolve domain.
           */
          title: string;
        }[];
        /**
         * @example Scan prevented ...
         */
        message: string;
        status: Record<string, any>;
      };
    }
  | {
      status: 429;
      payload: {
        description?: string;
        errors: {
          /**
           * @example DNS Error - Could not resolve domain.
           */
          detail: string;
          status: Record<string, any>;
          /**
           * @example DNS Error - Could not resolve domain.
           */
          title: string;
        }[];
        message: string;
        status: Record<string, any>;
      };
    }
>;

export type UrlscannerCreateScanV2Response = {
  /**
   * URL to api report.
   */
  api: string;
  /**
   * @example Submission successful
   */
  message: string;
  options?: {
    useragent?: string;
  };
  /**
   * URL to report.
   */
  result: string;
  /**
   * Canonical form of submitted URL. Use this if you want to later search by URL.
   */
  url: string;
  /**
   * Scan ID.
   *
   * @format uuid
   */
  uuid: string;
  /**
   * Submitted visibility status.
   *
   * @example Public
   */
  visibility: string;
};

export type UrlscannerCreateScanV2RequestBody = {
  /**
   * Set custom headers.
   */
  customHeaders?: {
    [key: string]: string;
  };
  /**
   * @maxLength 4096
   */
  customagent?: string;
  /**
   * @maxLength 4096
   */
  referer?: string;
  /**
   * Take multiple screenshots targeting different device types.
   *
   * @default desktop
   */
  screenshotsResolutions?: ('desktop' | 'mobile' | 'tablet')[];
  /**
   * @example https://www.example.com
   */
  url: string;
  /**
   * The option `Public` means it will be included in listings like recent scans and search results. `Unlisted` means it will not be included in the aforementioned listings, users will need to have the scan's ID to access it. A a scan will be automatically marked as unlisted if it fails, if it contains potential PII or other sensitive material.
   *
   * @default Public
   */
  visibility?: 'Public' | 'Unlisted';
};

export type UrlscannerCreateScanV2Variables = {
  body: UrlscannerCreateScanV2RequestBody;
  pathParams: UrlscannerCreateScanV2PathParams;
} & FetcherExtraProps;

/**
 * Submit a URL to scan. Check limits at https://developers.cloudflare.com/security-center/investigate/scan-limits/.
 */
export const urlscannerCreateScanV2 = (variables: UrlscannerCreateScanV2Variables, signal?: AbortSignal) =>
  fetch<
    UrlscannerCreateScanV2Response,
    UrlscannerCreateScanV2Error,
    UrlscannerCreateScanV2RequestBody,
    {},
    {},
    UrlscannerCreateScanV2PathParams
  >({ url: '/accounts/{accountId}/urlscanner/v2/scan', method: 'post', ...variables, signal });

export type UrlscannerGetScanScreenshotV2PathParams = {
  /**
   * Scan UUID.
   *
   * @format uuid
   */
  scanId: string;
  /**
   * Account ID.
   */
  accountId: string;
};

export type UrlscannerGetScanScreenshotV2QueryParams = {
  /**
   * Target device type.
   *
   * @default desktop
   */
  resolution?: 'desktop' | 'mobile' | 'tablet';
};

export type UrlscannerGetScanScreenshotV2Error = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          detail: string;
          /**
           * Status code.
           *
           * @example 400
           */
          status: number;
          /**
           * @example Invalid url
           */
          title: string;
        }[];
        message: string;
        /**
         * Status code.
         *
         * @example 400
         */
        status: number;
      };
    }
  | {
      status: 404;
      payload: {
        errors: {
          /**
           * @example Queued
           */
          detail: string;
          /**
           * Status code.
           *
           * @example 404
           */
          status: number;
          /**
           * @example Scan is not finished yet.
           */
          title: string;
        }[];
        /**
         * Scan not found or in progress.
         *
         * @example Scan is not finished yet.
         */
        message: string;
        /**
         * Status code.
         *
         * @example 404
         */
        status: number;
        task: {
          /**
           * @example Queued
           */
          status: string;
          time: string;
          url: string;
          uuid: string;
          /**
           * @example public
           */
          visibility: string;
        };
      };
    }
>;

export type UrlscannerGetScanScreenshotV2Variables = {
  pathParams: UrlscannerGetScanScreenshotV2PathParams;
  queryParams?: UrlscannerGetScanScreenshotV2QueryParams;
} & FetcherExtraProps;

/**
 * Get scan's screenshot by resolution (desktop/mobile/tablet).
 */
export const urlscannerGetScanScreenshotV2 = (
  variables: UrlscannerGetScanScreenshotV2Variables,
  signal?: AbortSignal
) =>
  fetch<
    undefined,
    UrlscannerGetScanScreenshotV2Error,
    undefined,
    {},
    UrlscannerGetScanScreenshotV2QueryParams,
    UrlscannerGetScanScreenshotV2PathParams
  >({ url: '/accounts/{accountId}/urlscanner/v2/screenshots/{scanId}.png', method: 'get', ...variables, signal });

export type UrlscannerSearchScansV2PathParams = {
  /**
   * Account ID.
   */
  accountId: string;
};

export type UrlscannerSearchScansV2QueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 100
   */
  size?: number;
  /**
   * Filter scans
   */
  q?: string;
};

export type UrlscannerSearchScansV2Error = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      detail: string;
      /**
       * Status code.
       *
       * @example 400
       */
      status: number;
      /**
       * @example Invalid url
       */
      title: string;
    }[];
    message: string;
    /**
     * Status code.
     *
     * @example 400
     */
    status: number;
  };
}>;

export type UrlscannerSearchScansV2Response = {
  results: {
    /**
     * @example 9626f773-9ffb-4cfb-89d3-30b120fc8011
     */
    _id: string;
    page: {
      /**
       * @example AS15133
       */
      asn: string;
      /**
       * @example US
       */
      country: string;
      /**
       * @example 93.184.215.14
       */
      ip: string;
      /**
       * @example https://example.com
       */
      url: string;
    };
    /**
     * @example https://radar.clouflare.com/scan/9626f773-9ffb-4cfb-89d3-30b120fc8011
     */
    result: string;
    stats: {
      /**
       * @example 2512
       */
      dataLength: number;
      /**
       * @example 2
       */
      requests: number;
      /**
       * @example 1
       */
      uniqCountries: number;
      /**
       * @example 1
       */
      uniqIPs: number;
    };
    task: {
      /**
       * @example 2024-09-30T23:54:02.881000+00:00
       */
      time: string;
      /**
       * @example https://example.com
       */
      url: string;
      /**
       * @example 9626f773-9ffb-4cfb-89d3-30b120fc8011
       */
      uuid: string;
      /**
       * @example public
       */
      visibility: string;
    };
    verdicts: {
      malicious: boolean;
    };
  }[];
};

export type UrlscannerSearchScansV2Variables = {
  pathParams: UrlscannerSearchScansV2PathParams;
  queryParams?: UrlscannerSearchScansV2QueryParams;
} & FetcherExtraProps;

/**
 * Use a subset of ElasticSearch Query syntax to filter scans. Some example queries:<br/> <br/>- 'page.domain:microsoft AND verdicts.malicious:true AND NOT page.domain:microsoft.com': malicious scans whose hostname starts with "microsoft".<br/>- 'apikey:me AND date:[2024-01 TO 2024-10]': my scans from 2024 January to 2024 October.<br/>- 'page.domain:(blogspot OR www.blogspot)': Searches for scans whose main domain starts with "blogspot" or with "www.blogspot"<br/>- 'date:>now-7d AND path:okta-sign-in.min.js: scans from the last 7 days with any request path that ends with "okta-sign-in.min.js"<br/>- 'page.asn:AS24940 AND hash:xxx': Websites hosted in AS24940 where a resource with the given hash was downloaded.
 */
export const urlscannerSearchScansV2 = (variables: UrlscannerSearchScansV2Variables, signal?: AbortSignal) =>
  fetch<
    UrlscannerSearchScansV2Response,
    UrlscannerSearchScansV2Error,
    undefined,
    {},
    UrlscannerSearchScansV2QueryParams,
    UrlscannerSearchScansV2PathParams
  >({ url: '/accounts/{accountId}/urlscanner/v2/search', method: 'get', ...variables, signal });

export type VectorizeDeprecatedListVectorizeIndexesPathParams = {
  accountId: Schemas.VectorizeIdentifier;
};

export type VectorizeDeprecatedListVectorizeIndexesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeDeprecatedListVectorizeIndexesResponse = {
  errors: Schemas.VectorizeMessages;
  messages: Schemas.VectorizeMessages;
  result: Record<string, any> | any[] | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type VectorizeDeprecatedListVectorizeIndexesVariables = {
  pathParams: VectorizeDeprecatedListVectorizeIndexesPathParams;
} & FetcherExtraProps;

/**
 * Returns a list of Vectorize Indexes
 */
export const vectorizeDeprecatedListVectorizeIndexes = (
  variables: VectorizeDeprecatedListVectorizeIndexesVariables,
  signal?: AbortSignal
) =>
  fetch<
    VectorizeDeprecatedListVectorizeIndexesResponse,
    VectorizeDeprecatedListVectorizeIndexesError,
    undefined,
    {},
    {},
    VectorizeDeprecatedListVectorizeIndexesPathParams
  >({ url: '/accounts/{accountId}/vectorize/indexes', method: 'get', ...variables, signal });

export type VectorizeDeprecatedCreateVectorizeIndexPathParams = {
  accountId: Schemas.VectorizeIdentifier;
};

export type VectorizeDeprecatedCreateVectorizeIndexError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeDeprecatedCreateVectorizeIndexResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeCreateIndexResponse;
};

export type VectorizeDeprecatedCreateVectorizeIndexVariables = {
  body: Schemas.VectorizeCreateIndexRequest;
  pathParams: VectorizeDeprecatedCreateVectorizeIndexPathParams;
} & FetcherExtraProps;

/**
 * Creates and returns a new Vectorize Index.
 */
export const vectorizeDeprecatedCreateVectorizeIndex = (
  variables: VectorizeDeprecatedCreateVectorizeIndexVariables,
  signal?: AbortSignal
) =>
  fetch<
    VectorizeDeprecatedCreateVectorizeIndexResponse,
    VectorizeDeprecatedCreateVectorizeIndexError,
    Schemas.VectorizeCreateIndexRequest,
    {},
    {},
    VectorizeDeprecatedCreateVectorizeIndexPathParams
  >({ url: '/accounts/{accountId}/vectorize/indexes', method: 'post', ...variables, signal });

export type VectorizeDeprecatedDeleteVectorizeIndexPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeDeprecatedDeleteVectorizeIndexError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeDeprecatedDeleteVectorizeIndexResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Record<string, any> | null;
};

export type VectorizeDeprecatedDeleteVectorizeIndexVariables = {
  pathParams: VectorizeDeprecatedDeleteVectorizeIndexPathParams;
} & FetcherExtraProps;

/**
 * Deletes the specified Vectorize Index.
 */
export const vectorizeDeprecatedDeleteVectorizeIndex = (
  variables: VectorizeDeprecatedDeleteVectorizeIndexVariables,
  signal?: AbortSignal
) =>
  fetch<
    VectorizeDeprecatedDeleteVectorizeIndexResponse,
    VectorizeDeprecatedDeleteVectorizeIndexError,
    undefined,
    {},
    {},
    VectorizeDeprecatedDeleteVectorizeIndexPathParams
  >({ url: '/accounts/{accountId}/vectorize/indexes/{indexName}', method: 'delete', ...variables, signal });

export type VectorizeDeprecatedGetVectorizeIndexPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeDeprecatedGetVectorizeIndexError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeDeprecatedGetVectorizeIndexResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeCreateIndexResponse;
};

export type VectorizeDeprecatedGetVectorizeIndexVariables = {
  pathParams: VectorizeDeprecatedGetVectorizeIndexPathParams;
} & FetcherExtraProps;

/**
 * Returns the specified Vectorize Index.
 */
export const vectorizeDeprecatedGetVectorizeIndex = (
  variables: VectorizeDeprecatedGetVectorizeIndexVariables,
  signal?: AbortSignal
) =>
  fetch<
    VectorizeDeprecatedGetVectorizeIndexResponse,
    VectorizeDeprecatedGetVectorizeIndexError,
    undefined,
    {},
    {},
    VectorizeDeprecatedGetVectorizeIndexPathParams
  >({ url: '/accounts/{accountId}/vectorize/indexes/{indexName}', method: 'get', ...variables, signal });

export type VectorizeDeprecatedUpdateVectorizeIndexPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeDeprecatedUpdateVectorizeIndexError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeDeprecatedUpdateVectorizeIndexResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeCreateIndexResponse;
};

export type VectorizeDeprecatedUpdateVectorizeIndexVariables = {
  body: Schemas.VectorizeUpdateIndexRequest;
  pathParams: VectorizeDeprecatedUpdateVectorizeIndexPathParams;
} & FetcherExtraProps;

/**
 * Updates and returns the specified Vectorize Index.
 */
export const vectorizeDeprecatedUpdateVectorizeIndex = (
  variables: VectorizeDeprecatedUpdateVectorizeIndexVariables,
  signal?: AbortSignal
) =>
  fetch<
    VectorizeDeprecatedUpdateVectorizeIndexResponse,
    VectorizeDeprecatedUpdateVectorizeIndexError,
    Schemas.VectorizeUpdateIndexRequest,
    {},
    {},
    VectorizeDeprecatedUpdateVectorizeIndexPathParams
  >({ url: '/accounts/{accountId}/vectorize/indexes/{indexName}', method: 'put', ...variables, signal });

export type VectorizeDeprecatedDeleteVectorsByIdPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeDeprecatedDeleteVectorsByIdError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeDeprecatedDeleteVectorsByIdResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeIndexDeleteVectorsByIdResponse;
};

export type VectorizeDeprecatedDeleteVectorsByIdVariables = {
  body?: Schemas.VectorizeIndexDeleteVectorsByIdRequest;
  pathParams: VectorizeDeprecatedDeleteVectorsByIdPathParams;
} & FetcherExtraProps;

/**
 * Delete a set of vectors from an index by their vector identifiers.
 */
export const vectorizeDeprecatedDeleteVectorsById = (
  variables: VectorizeDeprecatedDeleteVectorsByIdVariables,
  signal?: AbortSignal
) =>
  fetch<
    VectorizeDeprecatedDeleteVectorsByIdResponse,
    VectorizeDeprecatedDeleteVectorsByIdError,
    Schemas.VectorizeIndexDeleteVectorsByIdRequest,
    {},
    {},
    VectorizeDeprecatedDeleteVectorsByIdPathParams
  >({ url: '/accounts/{accountId}/vectorize/indexes/{indexName}/delete-by-ids', method: 'post', ...variables, signal });

export type VectorizeDeprecatedGetVectorsByIdPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeDeprecatedGetVectorsByIdError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeDeprecatedGetVectorsByIdResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeIndexGetVectorsByIdResponse;
};

export type VectorizeDeprecatedGetVectorsByIdVariables = {
  body?: Schemas.VectorizeIndexGetVectorsByIdRequest;
  pathParams: VectorizeDeprecatedGetVectorsByIdPathParams;
} & FetcherExtraProps;

/**
 * Get a set of vectors from an index by their vector identifiers.
 */
export const vectorizeDeprecatedGetVectorsById = (
  variables: VectorizeDeprecatedGetVectorsByIdVariables,
  signal?: AbortSignal
) =>
  fetch<
    VectorizeDeprecatedGetVectorsByIdResponse,
    VectorizeDeprecatedGetVectorsByIdError,
    Schemas.VectorizeIndexGetVectorsByIdRequest,
    {},
    {},
    VectorizeDeprecatedGetVectorsByIdPathParams
  >({ url: '/accounts/{accountId}/vectorize/indexes/{indexName}/get-by-ids', method: 'post', ...variables, signal });

export type VectorizeDeprecatedInsertVectorPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeDeprecatedInsertVectorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeDeprecatedInsertVectorResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeIndexInsertResponse;
};

export type VectorizeDeprecatedInsertVectorVariables = {
  pathParams: VectorizeDeprecatedInsertVectorPathParams;
} & FetcherExtraProps;

/**
 * Inserts vectors into the specified index and returns the count of the vectors successfully inserted.
 */
export const vectorizeDeprecatedInsertVector = (
  variables: VectorizeDeprecatedInsertVectorVariables,
  signal?: AbortSignal
) =>
  fetch<
    VectorizeDeprecatedInsertVectorResponse,
    VectorizeDeprecatedInsertVectorError,
    undefined,
    {},
    {},
    VectorizeDeprecatedInsertVectorPathParams
  >({ url: '/accounts/{accountId}/vectorize/indexes/{indexName}/insert', method: 'post', ...variables, signal });

export type VectorizeDeprecatedQueryVectorPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeDeprecatedQueryVectorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeDeprecatedQueryVectorResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeIndexQueryResponse;
};

export type VectorizeDeprecatedQueryVectorVariables = {
  body: Schemas.VectorizeIndexQueryRequest;
  pathParams: VectorizeDeprecatedQueryVectorPathParams;
} & FetcherExtraProps;

/**
 * Finds vectors closest to a given vector in an index.
 */
export const vectorizeDeprecatedQueryVector = (
  variables: VectorizeDeprecatedQueryVectorVariables,
  signal?: AbortSignal
) =>
  fetch<
    VectorizeDeprecatedQueryVectorResponse,
    VectorizeDeprecatedQueryVectorError,
    Schemas.VectorizeIndexQueryRequest,
    {},
    {},
    VectorizeDeprecatedQueryVectorPathParams
  >({ url: '/accounts/{accountId}/vectorize/indexes/{indexName}/query', method: 'post', ...variables, signal });

export type VectorizeDeprecatedUpsertVectorPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeDeprecatedUpsertVectorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeDeprecatedUpsertVectorResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeIndexUpsertResponse;
};

export type VectorizeDeprecatedUpsertVectorVariables = {
  pathParams: VectorizeDeprecatedUpsertVectorPathParams;
} & FetcherExtraProps;

/**
 * Upserts vectors into the specified index, creating them if they do not exist and returns the count of values and ids successfully inserted.
 */
export const vectorizeDeprecatedUpsertVector = (
  variables: VectorizeDeprecatedUpsertVectorVariables,
  signal?: AbortSignal
) =>
  fetch<
    VectorizeDeprecatedUpsertVectorResponse,
    VectorizeDeprecatedUpsertVectorError,
    undefined,
    {},
    {},
    VectorizeDeprecatedUpsertVectorPathParams
  >({ url: '/accounts/{accountId}/vectorize/indexes/{indexName}/upsert', method: 'post', ...variables, signal });

export type VectorizeListVectorizeIndexesPathParams = {
  accountId: Schemas.VectorizeIdentifier;
};

export type VectorizeListVectorizeIndexesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeListVectorizeIndexesResponse = {
  errors: Schemas.VectorizeMessages;
  messages: Schemas.VectorizeMessages;
  result: Record<string, any> | any[] | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type VectorizeListVectorizeIndexesVariables = {
  pathParams: VectorizeListVectorizeIndexesPathParams;
} & FetcherExtraProps;

/**
 * Returns a list of Vectorize Indexes
 */
export const vectorizeListVectorizeIndexes = (
  variables: VectorizeListVectorizeIndexesVariables,
  signal?: AbortSignal
) =>
  fetch<
    VectorizeListVectorizeIndexesResponse,
    VectorizeListVectorizeIndexesError,
    undefined,
    {},
    {},
    VectorizeListVectorizeIndexesPathParams
  >({ url: '/accounts/{accountId}/vectorize/v2/indexes', method: 'get', ...variables, signal });

export type VectorizeCreateVectorizeIndexPathParams = {
  accountId: Schemas.VectorizeIdentifier;
};

export type VectorizeCreateVectorizeIndexError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeCreateVectorizeIndexResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeCreateIndexResponse;
};

export type VectorizeCreateVectorizeIndexVariables = {
  body: Schemas.VectorizeCreateIndexRequest;
  pathParams: VectorizeCreateVectorizeIndexPathParams;
} & FetcherExtraProps;

/**
 * Creates and returns a new Vectorize Index.
 */
export const vectorizeCreateVectorizeIndex = (
  variables: VectorizeCreateVectorizeIndexVariables,
  signal?: AbortSignal
) =>
  fetch<
    VectorizeCreateVectorizeIndexResponse,
    VectorizeCreateVectorizeIndexError,
    Schemas.VectorizeCreateIndexRequest,
    {},
    {},
    VectorizeCreateVectorizeIndexPathParams
  >({ url: '/accounts/{accountId}/vectorize/v2/indexes', method: 'post', ...variables, signal });

export type VectorizeDeleteVectorizeIndexPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeDeleteVectorizeIndexError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeDeleteVectorizeIndexResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Record<string, any> | null;
};

export type VectorizeDeleteVectorizeIndexVariables = {
  pathParams: VectorizeDeleteVectorizeIndexPathParams;
} & FetcherExtraProps;

/**
 * Deletes the specified Vectorize Index.
 */
export const vectorizeDeleteVectorizeIndex = (
  variables: VectorizeDeleteVectorizeIndexVariables,
  signal?: AbortSignal
) =>
  fetch<
    VectorizeDeleteVectorizeIndexResponse,
    VectorizeDeleteVectorizeIndexError,
    undefined,
    {},
    {},
    VectorizeDeleteVectorizeIndexPathParams
  >({ url: '/accounts/{accountId}/vectorize/v2/indexes/{indexName}', method: 'delete', ...variables, signal });

export type VectorizeGetVectorizeIndexPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeGetVectorizeIndexError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeGetVectorizeIndexResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeCreateIndexResponse;
};

export type VectorizeGetVectorizeIndexVariables = {
  pathParams: VectorizeGetVectorizeIndexPathParams;
} & FetcherExtraProps;

/**
 * Returns the specified Vectorize Index.
 */
export const vectorizeGetVectorizeIndex = (variables: VectorizeGetVectorizeIndexVariables, signal?: AbortSignal) =>
  fetch<
    VectorizeGetVectorizeIndexResponse,
    VectorizeGetVectorizeIndexError,
    undefined,
    {},
    {},
    VectorizeGetVectorizeIndexPathParams
  >({ url: '/accounts/{accountId}/vectorize/v2/indexes/{indexName}', method: 'get', ...variables, signal });

export type VectorizeDeleteVectorsByIdPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeDeleteVectorsByIdError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeDeleteVectorsByIdResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeIndexDeleteVectorsByIdV2Response;
};

export type VectorizeDeleteVectorsByIdVariables = {
  body?: Schemas.VectorizeIndexDeleteVectorsByIdRequest;
  pathParams: VectorizeDeleteVectorsByIdPathParams;
} & FetcherExtraProps;

/**
 * Delete a set of vectors from an index by their vector identifiers.
 */
export const vectorizeDeleteVectorsById = (variables: VectorizeDeleteVectorsByIdVariables, signal?: AbortSignal) =>
  fetch<
    VectorizeDeleteVectorsByIdResponse,
    VectorizeDeleteVectorsByIdError,
    Schemas.VectorizeIndexDeleteVectorsByIdRequest,
    {},
    {},
    VectorizeDeleteVectorsByIdPathParams
  >({
    url: '/accounts/{accountId}/vectorize/v2/indexes/{indexName}/delete_by_ids',
    method: 'post',
    ...variables,
    signal
  });

export type VectorizeGetVectorsByIdPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeGetVectorsByIdError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeGetVectorsByIdResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeIndexGetVectorsByIdResponse;
};

export type VectorizeGetVectorsByIdVariables = {
  body?: Schemas.VectorizeIndexGetVectorsByIdRequest;
  pathParams: VectorizeGetVectorsByIdPathParams;
} & FetcherExtraProps;

/**
 * Get a set of vectors from an index by their vector identifiers.
 */
export const vectorizeGetVectorsById = (variables: VectorizeGetVectorsByIdVariables, signal?: AbortSignal) =>
  fetch<
    VectorizeGetVectorsByIdResponse,
    VectorizeGetVectorsByIdError,
    Schemas.VectorizeIndexGetVectorsByIdRequest,
    {},
    {},
    VectorizeGetVectorsByIdPathParams
  >({ url: '/accounts/{accountId}/vectorize/v2/indexes/{indexName}/get_by_ids', method: 'post', ...variables, signal });

export type VectorizeIndexInfoPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeIndexInfoError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeIndexInfoResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeIndexInfoResponse;
};

export type VectorizeIndexInfoVariables = {
  pathParams: VectorizeIndexInfoPathParams;
} & FetcherExtraProps;

/**
 * Get information about a vectorize index.
 */
export const vectorizeIndexInfo = (variables: VectorizeIndexInfoVariables, signal?: AbortSignal) =>
  fetch<VectorizeIndexInfoResponse, VectorizeIndexInfoError, undefined, {}, {}, VectorizeIndexInfoPathParams>({
    url: '/accounts/{accountId}/vectorize/v2/indexes/{indexName}/info',
    method: 'get',
    ...variables,
    signal
  });

export type VectorizeInsertVectorPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeInsertVectorQueryParams = {
  ['unparsable-behavior']?: 'error' | 'discard';
};

export type VectorizeInsertVectorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeInsertVectorResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeIndexInsertV2Response;
};

export type VectorizeInsertVectorVariables = {
  pathParams: VectorizeInsertVectorPathParams;
  queryParams?: VectorizeInsertVectorQueryParams;
} & FetcherExtraProps;

/**
 * Inserts vectors into the specified index and returns a mutation id corresponding to the vectors enqueued for insertion.
 */
export const vectorizeInsertVector = (variables: VectorizeInsertVectorVariables, signal?: AbortSignal) =>
  fetch<
    VectorizeInsertVectorResponse,
    VectorizeInsertVectorError,
    undefined,
    {},
    VectorizeInsertVectorQueryParams,
    VectorizeInsertVectorPathParams
  >({ url: '/accounts/{accountId}/vectorize/v2/indexes/{indexName}/insert', method: 'post', ...variables, signal });

export type VectorizeCreateMetadataIndexPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeCreateMetadataIndexError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeCreateMetadataIndexResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeCreateMetadataIndexResponse;
};

export type VectorizeCreateMetadataIndexVariables = {
  body: Schemas.VectorizeCreateMetadataIndexRequest;
  pathParams: VectorizeCreateMetadataIndexPathParams;
} & FetcherExtraProps;

/**
 * Enable metadata filtering based on metadata property. Limited to 10 properties.
 */
export const vectorizeCreateMetadataIndex = (variables: VectorizeCreateMetadataIndexVariables, signal?: AbortSignal) =>
  fetch<
    VectorizeCreateMetadataIndexResponse,
    VectorizeCreateMetadataIndexError,
    Schemas.VectorizeCreateMetadataIndexRequest,
    {},
    {},
    VectorizeCreateMetadataIndexPathParams
  >({
    url: '/accounts/{accountId}/vectorize/v2/indexes/{indexName}/metadata_index/create',
    method: 'post',
    ...variables,
    signal
  });

export type VectorizeDeleteMetadataIndexPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeDeleteMetadataIndexError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeDeleteMetadataIndexResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeDeleteMetadataIndexResponse;
};

export type VectorizeDeleteMetadataIndexVariables = {
  body: Schemas.VectorizeDeleteMetadataIndexRequest;
  pathParams: VectorizeDeleteMetadataIndexPathParams;
} & FetcherExtraProps;

/**
 * Allow Vectorize to delete the specified metadata index.
 */
export const vectorizeDeleteMetadataIndex = (variables: VectorizeDeleteMetadataIndexVariables, signal?: AbortSignal) =>
  fetch<
    VectorizeDeleteMetadataIndexResponse,
    VectorizeDeleteMetadataIndexError,
    Schemas.VectorizeDeleteMetadataIndexRequest,
    {},
    {},
    VectorizeDeleteMetadataIndexPathParams
  >({
    url: '/accounts/{accountId}/vectorize/v2/indexes/{indexName}/metadata_index/delete',
    method: 'post',
    ...variables,
    signal
  });

export type VectorizeListMetadataIndexesPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeListMetadataIndexesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeListMetadataIndexesResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeListMetadataIndexResponse;
};

export type VectorizeListMetadataIndexesVariables = {
  pathParams: VectorizeListMetadataIndexesPathParams;
} & FetcherExtraProps;

/**
 * List Metadata Indexes for the specified Vectorize Index.
 */
export const vectorizeListMetadataIndexes = (variables: VectorizeListMetadataIndexesVariables, signal?: AbortSignal) =>
  fetch<
    VectorizeListMetadataIndexesResponse,
    VectorizeListMetadataIndexesError,
    undefined,
    {},
    {},
    VectorizeListMetadataIndexesPathParams
  >({
    url: '/accounts/{accountId}/vectorize/v2/indexes/{indexName}/metadata_index/list',
    method: 'get',
    ...variables,
    signal
  });

export type VectorizeQueryVectorPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeQueryVectorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeQueryVectorResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeIndexQueryV2Response;
};

export type VectorizeQueryVectorVariables = {
  body: Schemas.VectorizeIndexQueryV2Request;
  pathParams: VectorizeQueryVectorPathParams;
} & FetcherExtraProps;

/**
 * Finds vectors closest to a given vector in an index.
 */
export const vectorizeQueryVector = (variables: VectorizeQueryVectorVariables, signal?: AbortSignal) =>
  fetch<
    VectorizeQueryVectorResponse,
    VectorizeQueryVectorError,
    Schemas.VectorizeIndexQueryV2Request,
    {},
    {},
    VectorizeQueryVectorPathParams
  >({ url: '/accounts/{accountId}/vectorize/v2/indexes/{indexName}/query', method: 'post', ...variables, signal });

export type VectorizeUpsertVectorPathParams = {
  accountId: Schemas.VectorizeIdentifier;
  indexName: Schemas.VectorizeIndexName;
};

export type VectorizeUpsertVectorQueryParams = {
  ['unparsable-behavior']?: 'error' | 'discard';
};

export type VectorizeUpsertVectorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.VectorizeApiResponseSingle & {
    result?: Record<string, any> | null;
  }) &
    Schemas.VectorizeApiResponseCommonFailure;
}>;

export type VectorizeUpsertVectorResponse = Schemas.VectorizeApiResponseSingle & {
  result?: Schemas.VectorizeIndexUpsertV2Response;
};

export type VectorizeUpsertVectorVariables = {
  pathParams: VectorizeUpsertVectorPathParams;
  queryParams?: VectorizeUpsertVectorQueryParams;
} & FetcherExtraProps;

/**
 * Upserts vectors into the specified index, creating them if they do not exist and returns a mutation id corresponding to the vectors enqueued for upsertion.
 */
export const vectorizeUpsertVector = (variables: VectorizeUpsertVectorVariables, signal?: AbortSignal) =>
  fetch<
    VectorizeUpsertVectorResponse,
    VectorizeUpsertVectorError,
    undefined,
    {},
    VectorizeUpsertVectorQueryParams,
    VectorizeUpsertVectorPathParams
  >({ url: '/accounts/{accountId}/vectorize/v2/indexes/{indexName}/upsert', method: 'post', ...variables, signal });

export type CloudflareTunnelListWarpConnectorTunnelsPathParams = {
  accountId: Schemas.TunnelAccountId;
};

export type CloudflareTunnelListWarpConnectorTunnelsQueryParams = {
  /**
   * @example blog
   */
  name?: string;
  /**
   * @example true
   */
  is_deleted?: boolean;
  existed_at?: Schemas.TunnelExistedAt;
  uuid?: Schemas.TunnelTunnelId;
  /**
   * @example 2009-11-10T23:00:00Z
   * @format date-time
   */
  was_active_at?: string;
  /**
   * @example 2009-11-10T23:00:00Z
   * @format date-time
   */
  was_inactive_at?: string;
  /**
   * @example vpc1-
   */
  include_prefix?: string;
  /**
   * @example vpc1-
   */
  exclude_prefix?: string;
  status?: Schemas.TunnelStatus;
  per_page?: Schemas.TunnelPerPage;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
};

export type CloudflareTunnelListWarpConnectorTunnelsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelTunnelResponseCollection & Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelListWarpConnectorTunnelsVariables = {
  pathParams: CloudflareTunnelListWarpConnectorTunnelsPathParams;
  queryParams?: CloudflareTunnelListWarpConnectorTunnelsQueryParams;
} & FetcherExtraProps;

/**
 * Lists and filters Warp Connector Tunnels in an account.
 */
export const cloudflareTunnelListWarpConnectorTunnels = (
  variables: CloudflareTunnelListWarpConnectorTunnelsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelTunnelResponseCollection,
    CloudflareTunnelListWarpConnectorTunnelsError,
    undefined,
    {},
    CloudflareTunnelListWarpConnectorTunnelsQueryParams,
    CloudflareTunnelListWarpConnectorTunnelsPathParams
  >({ url: '/accounts/{accountId}/warp_connector', method: 'get', ...variables, signal });

export type CloudflareTunnelCreateAWarpConnectorTunnelPathParams = {
  accountId: Schemas.TunnelAccountId;
};

export type CloudflareTunnelCreateAWarpConnectorTunnelError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelTunnelResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelCreateAWarpConnectorTunnelRequestBody = {
  name: Schemas.TunnelTunnelName;
};

export type CloudflareTunnelCreateAWarpConnectorTunnelVariables = {
  body: CloudflareTunnelCreateAWarpConnectorTunnelRequestBody;
  pathParams: CloudflareTunnelCreateAWarpConnectorTunnelPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Warp Connector Tunnel in an account.
 */
export const cloudflareTunnelCreateAWarpConnectorTunnel = (
  variables: CloudflareTunnelCreateAWarpConnectorTunnelVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelTunnelResponseSingle,
    CloudflareTunnelCreateAWarpConnectorTunnelError,
    CloudflareTunnelCreateAWarpConnectorTunnelRequestBody,
    {},
    {},
    CloudflareTunnelCreateAWarpConnectorTunnelPathParams
  >({ url: '/accounts/{accountId}/warp_connector', method: 'post', ...variables, signal });

export type CloudflareTunnelDeleteAWarpConnectorTunnelPathParams = {
  accountId: Schemas.TunnelAccountId;
  tunnelId: Schemas.TunnelTunnelId;
};

export type CloudflareTunnelDeleteAWarpConnectorTunnelError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelTunnelResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelDeleteAWarpConnectorTunnelVariables = {
  body?: Record<string, any>;
  pathParams: CloudflareTunnelDeleteAWarpConnectorTunnelPathParams;
} & FetcherExtraProps;

/**
 * Deletes a Warp Connector Tunnel from an account.
 */
export const cloudflareTunnelDeleteAWarpConnectorTunnel = (
  variables: CloudflareTunnelDeleteAWarpConnectorTunnelVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelTunnelResponseSingle,
    CloudflareTunnelDeleteAWarpConnectorTunnelError,
    Record<string, any>,
    {},
    {},
    CloudflareTunnelDeleteAWarpConnectorTunnelPathParams
  >({ url: '/accounts/{accountId}/warp_connector/{tunnelId}', method: 'delete', ...variables, signal });

export type CloudflareTunnelGetAWarpConnectorTunnelPathParams = {
  accountId: Schemas.TunnelAccountId;
  tunnelId: Schemas.TunnelTunnelId;
};

export type CloudflareTunnelGetAWarpConnectorTunnelError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelTunnelResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelGetAWarpConnectorTunnelVariables = {
  pathParams: CloudflareTunnelGetAWarpConnectorTunnelPathParams;
} & FetcherExtraProps;

/**
 * Fetches a single Warp Connector Tunnel.
 */
export const cloudflareTunnelGetAWarpConnectorTunnel = (
  variables: CloudflareTunnelGetAWarpConnectorTunnelVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelTunnelResponseSingle,
    CloudflareTunnelGetAWarpConnectorTunnelError,
    undefined,
    {},
    {},
    CloudflareTunnelGetAWarpConnectorTunnelPathParams
  >({ url: '/accounts/{accountId}/warp_connector/{tunnelId}', method: 'get', ...variables, signal });

export type CloudflareTunnelUpdateAWarpConnectorTunnelPathParams = {
  accountId: Schemas.TunnelAccountId;
  tunnelId: Schemas.TunnelTunnelId;
};

export type CloudflareTunnelUpdateAWarpConnectorTunnelError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelTunnelResponseSingle & Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelUpdateAWarpConnectorTunnelRequestBody = {
  name?: Schemas.TunnelTunnelName;
  tunnel_secret?: Schemas.TunnelTunnelSecret;
};

export type CloudflareTunnelUpdateAWarpConnectorTunnelVariables = {
  body?: CloudflareTunnelUpdateAWarpConnectorTunnelRequestBody;
  pathParams: CloudflareTunnelUpdateAWarpConnectorTunnelPathParams;
} & FetcherExtraProps;

/**
 * Updates an existing Warp Connector Tunnel.
 */
export const cloudflareTunnelUpdateAWarpConnectorTunnel = (
  variables: CloudflareTunnelUpdateAWarpConnectorTunnelVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelTunnelResponseSingle,
    CloudflareTunnelUpdateAWarpConnectorTunnelError,
    CloudflareTunnelUpdateAWarpConnectorTunnelRequestBody,
    {},
    {},
    CloudflareTunnelUpdateAWarpConnectorTunnelPathParams
  >({ url: '/accounts/{accountId}/warp_connector/{tunnelId}', method: 'patch', ...variables, signal });

export type CloudflareTunnelGetAWarpConnectorTunnelTokenPathParams = {
  accountId: Schemas.TunnelAccountId;
  tunnelId: Schemas.TunnelTunnelId;
};

export type CloudflareTunnelGetAWarpConnectorTunnelTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelTunnelResponseToken & Schemas.TunnelApiResponseCommonFailure;
}>;

export type CloudflareTunnelGetAWarpConnectorTunnelTokenVariables = {
  pathParams: CloudflareTunnelGetAWarpConnectorTunnelTokenPathParams;
} & FetcherExtraProps;

/**
 * Gets the token used to associate warp device with a specific Warp Connector tunnel.
 */
export const cloudflareTunnelGetAWarpConnectorTunnelToken = (
  variables: CloudflareTunnelGetAWarpConnectorTunnelTokenVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelTunnelResponseToken,
    CloudflareTunnelGetAWarpConnectorTunnelTokenError,
    undefined,
    {},
    {},
    CloudflareTunnelGetAWarpConnectorTunnelTokenPathParams
  >({ url: '/accounts/{accountId}/warp_connector/{tunnelId}/token', method: 'get', ...variables, signal });

export type WorkerAccountSettingsFetchWorkerAccountSettingsPathParams = {
  accountId: Schemas.WorkersIdentifier;
};

export type WorkerAccountSettingsFetchWorkerAccountSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersAccountSettingsResponse & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerAccountSettingsFetchWorkerAccountSettingsVariables = {
  pathParams: WorkerAccountSettingsFetchWorkerAccountSettingsPathParams;
} & FetcherExtraProps;

/**
 * Fetches Worker account settings for an account.
 */
export const workerAccountSettingsFetchWorkerAccountSettings = (
  variables: WorkerAccountSettingsFetchWorkerAccountSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersAccountSettingsResponse,
    WorkerAccountSettingsFetchWorkerAccountSettingsError,
    undefined,
    {},
    {},
    WorkerAccountSettingsFetchWorkerAccountSettingsPathParams
  >({ url: '/accounts/{accountId}/workers/account-settings', method: 'get', ...variables, signal });

export type WorkerAccountSettingsCreateWorkerAccountSettingsPathParams = {
  accountId: Schemas.WorkersIdentifier;
};

export type WorkerAccountSettingsCreateWorkerAccountSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersAccountSettingsResponse & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerAccountSettingsCreateWorkerAccountSettingsVariables = {
  body?: Schemas.WorkersAccountSettings;
  pathParams: WorkerAccountSettingsCreateWorkerAccountSettingsPathParams;
} & FetcherExtraProps;

/**
 * Creates Worker account settings for an account.
 */
export const workerAccountSettingsCreateWorkerAccountSettings = (
  variables: WorkerAccountSettingsCreateWorkerAccountSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersAccountSettingsResponse,
    WorkerAccountSettingsCreateWorkerAccountSettingsError,
    Schemas.WorkersAccountSettings,
    {},
    {},
    WorkerAccountSettingsCreateWorkerAccountSettingsPathParams
  >({ url: '/accounts/{accountId}/workers/account-settings', method: 'put', ...variables, signal });

export type WorkerAssetsUploadPathParams = {
  accountId: Schemas.WorkersIdentifier;
};

export type WorkerAssetsUploadQueryParams = {
  base64: true;
};

export type WorkerAssetsUploadError = Fetcher.ErrorWrapper<undefined>;

export type WorkerAssetsUploadRequestBody = {
  /**
   * Base-64 encoded contents of the file. The content type of the file should be included to ensure a valid "Content-Type" header is included in asset responses.
   */
  ['<any file hash>']?: string[];
};

export type WorkerAssetsUploadVariables = {
  body?: WorkerAssetsUploadRequestBody;
  pathParams: WorkerAssetsUploadPathParams;
  queryParams: WorkerAssetsUploadQueryParams;
} & FetcherExtraProps;

/**
 * Upload assets ahead of creating a Worker version.  To learn more about the direct uploads of assets, see https://developers.cloudflare.com/workers/static-assets/direct-upload/
 */
export const workerAssetsUpload = (variables: WorkerAssetsUploadVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersCompletedUploadAssetsResponse | Schemas.WorkersUploadAssetsResponse,
    WorkerAssetsUploadError,
    WorkerAssetsUploadRequestBody,
    {},
    WorkerAssetsUploadQueryParams,
    WorkerAssetsUploadPathParams
  >({ url: '/accounts/{accountId}/workers/assets/upload', method: 'post', ...variables, signal });

export type NamespaceWorkerListPathParams = {
  accountId: Schemas.WorkersIdentifier;
};

export type NamespaceWorkerListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type NamespaceWorkerListVariables = {
  pathParams: NamespaceWorkerListPathParams;
} & FetcherExtraProps;

/**
 * Fetch a list of Workers for Platforms namespaces.
 */
export const namespaceWorkerList = (variables: NamespaceWorkerListVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersNamespaceListResponse,
    NamespaceWorkerListError,
    undefined,
    {},
    {},
    NamespaceWorkerListPathParams
  >({ url: '/accounts/{accountId}/workers/dispatch/namespaces', method: 'get', ...variables, signal });

export type NamespaceWorkerCreatePathParams = {
  accountId: Schemas.WorkersIdentifier;
};

export type NamespaceWorkerCreateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type NamespaceWorkerCreateRequestBody = {
  /**
   * The name of the dispatch namespace
   *
   * @example my-dispatch-namespace
   */
  name?: string;
};

export type NamespaceWorkerCreateVariables = {
  body?: NamespaceWorkerCreateRequestBody;
  pathParams: NamespaceWorkerCreatePathParams;
} & FetcherExtraProps;

/**
 * Create a new Workers for Platforms namespace.
 */
export const namespaceWorkerCreate = (variables: NamespaceWorkerCreateVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersNamespaceSingleResponse,
    NamespaceWorkerCreateError,
    NamespaceWorkerCreateRequestBody,
    {},
    {},
    NamespaceWorkerCreatePathParams
  >({ url: '/accounts/{accountId}/workers/dispatch/namespaces', method: 'post', ...variables, signal });

export type NamespaceWorkerDeleteNamespacePathParams = {
  accountId: Schemas.WorkersIdentifier;
  dispatchNamespace: Schemas.WorkersDispatchNamespaceName;
};

export type NamespaceWorkerDeleteNamespaceError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type NamespaceWorkerDeleteNamespaceVariables = {
  pathParams: NamespaceWorkerDeleteNamespacePathParams;
} & FetcherExtraProps;

/**
 * Delete a Workers for Platforms namespace.
 */
export const namespaceWorkerDeleteNamespace = (
  variables: NamespaceWorkerDeleteNamespaceVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersNamespaceDeleteResponse,
    NamespaceWorkerDeleteNamespaceError,
    undefined,
    {},
    {},
    NamespaceWorkerDeleteNamespacePathParams
  >({
    url: '/accounts/{accountId}/workers/dispatch/namespaces/{dispatchNamespace}',
    method: 'delete',
    ...variables,
    signal
  });

export type NamespaceWorkerGetNamespacePathParams = {
  accountId: Schemas.WorkersIdentifier;
  dispatchNamespace: Schemas.WorkersDispatchNamespaceName;
};

export type NamespaceWorkerGetNamespaceError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type NamespaceWorkerGetNamespaceVariables = {
  pathParams: NamespaceWorkerGetNamespacePathParams;
} & FetcherExtraProps;

/**
 * Get a Workers for Platforms namespace.
 */
export const namespaceWorkerGetNamespace = (variables: NamespaceWorkerGetNamespaceVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersNamespaceSingleResponse,
    NamespaceWorkerGetNamespaceError,
    undefined,
    {},
    {},
    NamespaceWorkerGetNamespacePathParams
  >({
    url: '/accounts/{accountId}/workers/dispatch/namespaces/{dispatchNamespace}',
    method: 'get',
    ...variables,
    signal
  });

export type NamespaceWorkerScriptDeleteWorkerPathParams = {
  accountId: Schemas.WorkersIdentifier;
  dispatchNamespace: Schemas.WorkersDispatchNamespaceName;
  scriptName: Schemas.WorkersScriptName;
};

export type NamespaceWorkerScriptDeleteWorkerQueryParams = {
  /**
   * If set to true, delete will not be stopped by associated service binding, durable object, or other binding. Any of these associated bindings/durable objects will be deleted along with the script.
   */
  force?: boolean;
};

export type NamespaceWorkerScriptDeleteWorkerError = Fetcher.ErrorWrapper<undefined>;

export type NamespaceWorkerScriptDeleteWorkerVariables = {
  pathParams: NamespaceWorkerScriptDeleteWorkerPathParams;
  queryParams?: NamespaceWorkerScriptDeleteWorkerQueryParams;
} & FetcherExtraProps;

/**
 * Delete a worker from a Workers for Platforms namespace. This call has no response body on a successful delete.
 */
export const namespaceWorkerScriptDeleteWorker = (
  variables: NamespaceWorkerScriptDeleteWorkerVariables,
  signal?: AbortSignal
) =>
  fetch<
    undefined,
    NamespaceWorkerScriptDeleteWorkerError,
    undefined,
    {},
    NamespaceWorkerScriptDeleteWorkerQueryParams,
    NamespaceWorkerScriptDeleteWorkerPathParams
  >({
    url: '/accounts/{accountId}/workers/dispatch/namespaces/{dispatchNamespace}/scripts/{scriptName}',
    method: 'delete',
    ...variables,
    signal
  });

export type NamespaceWorkerScriptWorkerDetailsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  dispatchNamespace: Schemas.WorkersDispatchNamespaceName;
  scriptName: Schemas.WorkersScriptName;
};

export type NamespaceWorkerScriptWorkerDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type NamespaceWorkerScriptWorkerDetailsVariables = {
  pathParams: NamespaceWorkerScriptWorkerDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetch information about a script uploaded to a Workers for Platforms namespace.
 */
export const namespaceWorkerScriptWorkerDetails = (
  variables: NamespaceWorkerScriptWorkerDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersNamespaceScriptResponseSingle,
    NamespaceWorkerScriptWorkerDetailsError,
    undefined,
    {},
    {},
    NamespaceWorkerScriptWorkerDetailsPathParams
  >({
    url: '/accounts/{accountId}/workers/dispatch/namespaces/{dispatchNamespace}/scripts/{scriptName}',
    method: 'get',
    ...variables,
    signal
  });

export type NamespaceWorkerScriptUploadWorkerModulePathParams = {
  accountId: Schemas.WorkersIdentifier;
  dispatchNamespace: Schemas.WorkersDispatchNamespaceName;
  scriptName: Schemas.WorkersScriptName;
};

export type NamespaceWorkerScriptUploadWorkerModuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.Workers4XX;
}>;

export type NamespaceWorkerScriptUploadWorkerModuleVariables = {
  body: RequestBodies.WorkersScriptUpload;
  pathParams: NamespaceWorkerScriptUploadWorkerModulePathParams;
} & FetcherExtraProps;

/**
 * Upload a worker module to a Workers for Platforms namespace. You can find more about the multipart metadata on our docs: https://developers.cloudflare.com/workers/configuration/multipart-upload-metadata/.
 */
export const namespaceWorkerScriptUploadWorkerModule = (
  variables: NamespaceWorkerScriptUploadWorkerModuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Responses.Workers200,
    NamespaceWorkerScriptUploadWorkerModuleError,
    RequestBodies.WorkersScriptUpload,
    {},
    {},
    NamespaceWorkerScriptUploadWorkerModulePathParams
  >({
    url: '/accounts/{accountId}/workers/dispatch/namespaces/{dispatchNamespace}/scripts/{scriptName}',
    method: 'put',
    ...variables,
    signal
  });

export type NamespaceWorkerScriptUpdateCreateAssetsUploadSessionPathParams = {
  accountId: Schemas.WorkersIdentifier;
  dispatchNamespace: Schemas.WorkersDispatchNamespaceName;
  scriptName: Schemas.WorkersScriptName;
};

export type NamespaceWorkerScriptUpdateCreateAssetsUploadSessionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersCreateAssetsUploadSessionResponse & Schemas.WorkersApiResponseCommonFailure;
}>;

export type NamespaceWorkerScriptUpdateCreateAssetsUploadSessionVariables = {
  body?: Schemas.WorkersCreateAssetsUploadSessionObject;
  pathParams: NamespaceWorkerScriptUpdateCreateAssetsUploadSessionPathParams;
} & FetcherExtraProps;

/**
 * Start uploading a collection of assets for use in a Worker version. To learn more about the direct uploads of assets, see https://developers.cloudflare.com/workers/static-assets/direct-upload/
 */
export const namespaceWorkerScriptUpdateCreateAssetsUploadSession = (
  variables: NamespaceWorkerScriptUpdateCreateAssetsUploadSessionVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersCreateAssetsUploadSessionResponse,
    NamespaceWorkerScriptUpdateCreateAssetsUploadSessionError,
    Schemas.WorkersCreateAssetsUploadSessionObject,
    {},
    {},
    NamespaceWorkerScriptUpdateCreateAssetsUploadSessionPathParams
  >({
    url: '/accounts/{accountId}/workers/dispatch/namespaces/{dispatchNamespace}/scripts/{scriptName}/assets-upload-session',
    method: 'post',
    ...variables,
    signal
  });

export type NamespaceWorkerGetScriptBindingsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  dispatchNamespace: Schemas.WorkersDispatchNamespaceName;
  scriptName: Schemas.WorkersScriptName;
};

export type NamespaceWorkerGetScriptBindingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type NamespaceWorkerGetScriptBindingsResponse = Schemas.WorkersApiResponseCommon & {
  result?: Schemas.WorkersBindings;
};

export type NamespaceWorkerGetScriptBindingsVariables = {
  pathParams: NamespaceWorkerGetScriptBindingsPathParams;
} & FetcherExtraProps;

/**
 * Fetch script bindings from a script uploaded to a Workers for Platforms namespace.
 */
export const namespaceWorkerGetScriptBindings = (
  variables: NamespaceWorkerGetScriptBindingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    NamespaceWorkerGetScriptBindingsResponse,
    NamespaceWorkerGetScriptBindingsError,
    undefined,
    {},
    {},
    NamespaceWorkerGetScriptBindingsPathParams
  >({
    url: '/accounts/{accountId}/workers/dispatch/namespaces/{dispatchNamespace}/scripts/{scriptName}/bindings',
    method: 'get',
    ...variables,
    signal
  });

export type NamespaceWorkerGetScriptContentPathParams = {
  accountId: Schemas.WorkersIdentifier;
  dispatchNamespace: Schemas.WorkersDispatchNamespaceName;
  scriptName: Schemas.WorkersScriptName;
};

export type NamespaceWorkerGetScriptContentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type NamespaceWorkerGetScriptContentVariables = {
  pathParams: NamespaceWorkerGetScriptContentPathParams;
} & FetcherExtraProps;

/**
 * Fetch script content from a script uploaded to a Workers for Platforms namespace.
 */
export const namespaceWorkerGetScriptContent = (
  variables: NamespaceWorkerGetScriptContentVariables,
  signal?: AbortSignal
) =>
  fetch<undefined, NamespaceWorkerGetScriptContentError, undefined, {}, {}, NamespaceWorkerGetScriptContentPathParams>({
    url: '/accounts/{accountId}/workers/dispatch/namespaces/{dispatchNamespace}/scripts/{scriptName}/content',
    method: 'get',
    ...variables,
    signal
  });

export type NamespaceWorkerPutScriptContentPathParams = {
  accountId: Schemas.WorkersIdentifier;
  dispatchNamespace: Schemas.WorkersDispatchNamespaceName;
  scriptName: Schemas.WorkersScriptName;
};

export type NamespaceWorkerPutScriptContentHeaders = {
  /**
   * The multipart name of a script upload part containing script content in service worker format. Alternative to including in a metadata part.
   */
  ['CF-WORKER-BODY-PART']?: string;
  /**
   * The multipart name of a script upload part containing script content in es module format. Alternative to including in a metadata part.
   */
  ['CF-WORKER-MAIN-MODULE-PART']?: string;
};

export type NamespaceWorkerPutScriptContentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type NamespaceWorkerPutScriptContentRequestBody = {
  /**
   * JSON encoded metadata about the uploaded parts and Worker configuration.
   */
  metadata: {
    /**
     * Name of the part in the multipart request that contains the script (e.g. the file adding a listener to the `fetch` event). Indicates a `service worker syntax` Worker.
     *
     * @example worker.js
     */
    body_part?: string;
    /**
     * Name of the part in the multipart request that contains the main module (e.g. the file exporting a `fetch` handler). Indicates a `module syntax` Worker.
     *
     * @example worker.js
     */
    main_module?: string;
  };
} & {
  [key: string]: Blob[];
};

export type NamespaceWorkerPutScriptContentVariables = {
  body: NamespaceWorkerPutScriptContentRequestBody;
  headers?: NamespaceWorkerPutScriptContentHeaders;
  pathParams: NamespaceWorkerPutScriptContentPathParams;
} & FetcherExtraProps;

/**
 * Put script content for a script uploaded to a Workers for Platforms namespace.
 */
export const namespaceWorkerPutScriptContent = (
  variables: NamespaceWorkerPutScriptContentVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersScriptResponseSingle,
    NamespaceWorkerPutScriptContentError,
    NamespaceWorkerPutScriptContentRequestBody,
    NamespaceWorkerPutScriptContentHeaders,
    {},
    NamespaceWorkerPutScriptContentPathParams
  >({
    url: '/accounts/{accountId}/workers/dispatch/namespaces/{dispatchNamespace}/scripts/{scriptName}/content',
    method: 'put',
    ...variables,
    signal
  });

export type NamespaceWorkerListScriptSecretsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  dispatchNamespace: Schemas.WorkersDispatchNamespaceName;
  scriptName: Schemas.WorkersScriptName;
};

export type NamespaceWorkerListScriptSecretsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type NamespaceWorkerListScriptSecretsResponse = Schemas.WorkersApiResponseCommon & {
  result?: Schemas.WorkersSecretResponse[];
};

export type NamespaceWorkerListScriptSecretsVariables = {
  pathParams: NamespaceWorkerListScriptSecretsPathParams;
} & FetcherExtraProps;

/**
 * List secrets from a script uploaded to a Workers for Platforms namespace.
 */
export const namespaceWorkerListScriptSecrets = (
  variables: NamespaceWorkerListScriptSecretsVariables,
  signal?: AbortSignal
) =>
  fetch<
    NamespaceWorkerListScriptSecretsResponse,
    NamespaceWorkerListScriptSecretsError,
    undefined,
    {},
    {},
    NamespaceWorkerListScriptSecretsPathParams
  >({
    url: '/accounts/{accountId}/workers/dispatch/namespaces/{dispatchNamespace}/scripts/{scriptName}/secrets',
    method: 'get',
    ...variables,
    signal
  });

export type NamespaceWorkerPutScriptSecretsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  dispatchNamespace: Schemas.WorkersDispatchNamespaceName;
  scriptName: Schemas.WorkersScriptName;
};

export type NamespaceWorkerPutScriptSecretsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type NamespaceWorkerPutScriptSecretsResponse = Schemas.WorkersApiResponseCommon & {
  result?: Schemas.WorkersSecretResponse;
};

export type NamespaceWorkerPutScriptSecretsVariables = {
  body?: Schemas.WorkersSecret;
  pathParams: NamespaceWorkerPutScriptSecretsPathParams;
} & FetcherExtraProps;

/**
 * Put secrets to a script uploaded to a Workers for Platforms namespace.
 */
export const namespaceWorkerPutScriptSecrets = (
  variables: NamespaceWorkerPutScriptSecretsVariables,
  signal?: AbortSignal
) =>
  fetch<
    NamespaceWorkerPutScriptSecretsResponse,
    NamespaceWorkerPutScriptSecretsError,
    Schemas.WorkersSecret,
    {},
    {},
    NamespaceWorkerPutScriptSecretsPathParams
  >({
    url: '/accounts/{accountId}/workers/dispatch/namespaces/{dispatchNamespace}/scripts/{scriptName}/secrets',
    method: 'put',
    ...variables,
    signal
  });

export type NamespaceWorkerGetScriptSecretsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  dispatchNamespace: Schemas.WorkersDispatchNamespaceName;
  scriptName: Schemas.WorkersScriptName;
  secretName: Schemas.WorkersSecretName;
};

export type NamespaceWorkerGetScriptSecretsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type NamespaceWorkerGetScriptSecretsResponse = Schemas.WorkersApiResponseCommon & {
  result?: Schemas.WorkersSecretResponse;
};

export type NamespaceWorkerGetScriptSecretsVariables = {
  pathParams: NamespaceWorkerGetScriptSecretsPathParams;
} & FetcherExtraProps;

/**
 * Get secret from a script uploaded to a Workers for Platforms namespace.
 */
export const namespaceWorkerGetScriptSecrets = (
  variables: NamespaceWorkerGetScriptSecretsVariables,
  signal?: AbortSignal
) =>
  fetch<
    NamespaceWorkerGetScriptSecretsResponse,
    NamespaceWorkerGetScriptSecretsError,
    undefined,
    {},
    {},
    NamespaceWorkerGetScriptSecretsPathParams
  >({
    url: '/accounts/{accountId}/workers/dispatch/namespaces/{dispatchNamespace}/scripts/{scriptName}/secrets/{secretName}',
    method: 'get',
    ...variables,
    signal
  });

export type NamespaceWorkerGetScriptSettingsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  dispatchNamespace: Schemas.WorkersDispatchNamespaceName;
  scriptName: Schemas.WorkersScriptName;
};

export type NamespaceWorkerGetScriptSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type NamespaceWorkerGetScriptSettingsResponse = Schemas.WorkersApiResponseCommon & {
  result?: Schemas.WorkersScriptAndVersionSettingsItem;
};

export type NamespaceWorkerGetScriptSettingsVariables = {
  pathParams: NamespaceWorkerGetScriptSettingsPathParams;
} & FetcherExtraProps;

/**
 * Get script settings from a script uploaded to a Workers for Platforms namespace.
 */
export const namespaceWorkerGetScriptSettings = (
  variables: NamespaceWorkerGetScriptSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    NamespaceWorkerGetScriptSettingsResponse,
    NamespaceWorkerGetScriptSettingsError,
    undefined,
    {},
    {},
    NamespaceWorkerGetScriptSettingsPathParams
  >({
    url: '/accounts/{accountId}/workers/dispatch/namespaces/{dispatchNamespace}/scripts/{scriptName}/settings',
    method: 'get',
    ...variables,
    signal
  });

export type NamespaceWorkerPatchScriptSettingsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  dispatchNamespace: Schemas.WorkersDispatchNamespaceName;
  scriptName: Schemas.WorkersScriptName;
};

export type NamespaceWorkerPatchScriptSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type NamespaceWorkerPatchScriptSettingsResponse = Schemas.WorkersApiResponseCommon & {
  result?: Schemas.WorkersScriptAndVersionSettingsItem;
};

export type NamespaceWorkerPatchScriptSettingsRequestBody = {
  settings?: Schemas.WorkersScriptAndVersionSettingsItem;
};

export type NamespaceWorkerPatchScriptSettingsVariables = {
  body?: NamespaceWorkerPatchScriptSettingsRequestBody;
  pathParams: NamespaceWorkerPatchScriptSettingsPathParams;
} & FetcherExtraProps;

/**
 * Patch script metadata, such as bindings
 */
export const namespaceWorkerPatchScriptSettings = (
  variables: NamespaceWorkerPatchScriptSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    NamespaceWorkerPatchScriptSettingsResponse,
    NamespaceWorkerPatchScriptSettingsError,
    NamespaceWorkerPatchScriptSettingsRequestBody,
    {},
    {},
    NamespaceWorkerPatchScriptSettingsPathParams
  >({
    url: '/accounts/{accountId}/workers/dispatch/namespaces/{dispatchNamespace}/scripts/{scriptName}/settings',
    method: 'patch',
    ...variables,
    signal
  });

export type NamespaceWorkerGetScriptTagsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  dispatchNamespace: Schemas.WorkersDispatchNamespaceName;
  scriptName: Schemas.WorkersScriptName;
};

export type NamespaceWorkerGetScriptTagsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type NamespaceWorkerGetScriptTagsResponse = Schemas.WorkersApiResponseCommon & {
  /**
   * @example free
   * @example customer
   */
  result?: Schemas.WorkersTag[];
};

export type NamespaceWorkerGetScriptTagsVariables = {
  pathParams: NamespaceWorkerGetScriptTagsPathParams;
} & FetcherExtraProps;

/**
 * Fetch tags from a script uploaded to a Workers for Platforms namespace.
 */
export const namespaceWorkerGetScriptTags = (variables: NamespaceWorkerGetScriptTagsVariables, signal?: AbortSignal) =>
  fetch<
    NamespaceWorkerGetScriptTagsResponse,
    NamespaceWorkerGetScriptTagsError,
    undefined,
    {},
    {},
    NamespaceWorkerGetScriptTagsPathParams
  >({
    url: '/accounts/{accountId}/workers/dispatch/namespaces/{dispatchNamespace}/scripts/{scriptName}/tags',
    method: 'get',
    ...variables,
    signal
  });

export type NamespaceWorkerPutScriptTagsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  dispatchNamespace: Schemas.WorkersDispatchNamespaceName;
  scriptName: Schemas.WorkersScriptName;
};

export type NamespaceWorkerPutScriptTagsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type NamespaceWorkerPutScriptTagsResponse = Schemas.WorkersApiResponseCommon & {
  /**
   * @example my-tag
   */
  result?: Schemas.WorkersTag[];
};

export type NamespaceWorkerPutScriptTagsVariables = {
  body?: Schemas.WorkersTags;
  pathParams: NamespaceWorkerPutScriptTagsPathParams;
} & FetcherExtraProps;

/**
 * Put script tags for a script uploaded to a Workers for Platforms namespace.
 */
export const namespaceWorkerPutScriptTags = (variables: NamespaceWorkerPutScriptTagsVariables, signal?: AbortSignal) =>
  fetch<
    NamespaceWorkerPutScriptTagsResponse,
    NamespaceWorkerPutScriptTagsError,
    Schemas.WorkersTags,
    {},
    {},
    NamespaceWorkerPutScriptTagsPathParams
  >({
    url: '/accounts/{accountId}/workers/dispatch/namespaces/{dispatchNamespace}/scripts/{scriptName}/tags',
    method: 'put',
    ...variables,
    signal
  });

export type NamespaceWorkerDeleteScriptTagPathParams = {
  accountId: Schemas.WorkersIdentifier;
  dispatchNamespace: Schemas.WorkersDispatchNamespaceName;
  scriptName: Schemas.WorkersScriptName;
  tag: Schemas.WorkersTag;
};

export type NamespaceWorkerDeleteScriptTagError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type NamespaceWorkerDeleteScriptTagResponse = Schemas.WorkersApiResponseCommon & {
  result?: any | null;
};

export type NamespaceWorkerDeleteScriptTagVariables = {
  pathParams: NamespaceWorkerDeleteScriptTagPathParams;
} & FetcherExtraProps;

/**
 * Delete script tag for a script uploaded to a Workers for Platforms namespace.
 */
export const namespaceWorkerDeleteScriptTag = (
  variables: NamespaceWorkerDeleteScriptTagVariables,
  signal?: AbortSignal
) =>
  fetch<
    NamespaceWorkerDeleteScriptTagResponse,
    NamespaceWorkerDeleteScriptTagError,
    undefined,
    {},
    {},
    NamespaceWorkerDeleteScriptTagPathParams
  >({
    url: '/accounts/{accountId}/workers/dispatch/namespaces/{dispatchNamespace}/scripts/{scriptName}/tags/{tag}',
    method: 'delete',
    ...variables,
    signal
  });

export type NamespaceWorkerPutScriptTagPathParams = {
  accountId: Schemas.WorkersIdentifier;
  dispatchNamespace: Schemas.WorkersDispatchNamespaceName;
  scriptName: Schemas.WorkersScriptName;
  tag: Schemas.WorkersTag;
};

export type NamespaceWorkerPutScriptTagError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type NamespaceWorkerPutScriptTagResponse = Schemas.WorkersApiResponseCommon & {
  result?: any | null;
};

export type NamespaceWorkerPutScriptTagVariables = {
  pathParams: NamespaceWorkerPutScriptTagPathParams;
} & FetcherExtraProps;

/**
 * Put a single tag on a script uploaded to a Workers for Platforms namespace.
 */
export const namespaceWorkerPutScriptTag = (variables: NamespaceWorkerPutScriptTagVariables, signal?: AbortSignal) =>
  fetch<
    NamespaceWorkerPutScriptTagResponse,
    NamespaceWorkerPutScriptTagError,
    undefined,
    {},
    {},
    NamespaceWorkerPutScriptTagPathParams
  >({
    url: '/accounts/{accountId}/workers/dispatch/namespaces/{dispatchNamespace}/scripts/{scriptName}/tags/{tag}',
    method: 'put',
    ...variables,
    signal
  });

export type WorkerDomainListDomainsPathParams = {
  accountId: Schemas.WorkersAccountIdentifier;
};

export type WorkerDomainListDomainsQueryParams = {
  zone_name?: Schemas.WorkersZoneName;
  service?: Schemas.WorkersSchemasService;
  zone_id?: Schemas.WorkersZoneIdentifier;
  /**
   * @example foo.example.com
   */
  hostname?: string;
  /**
   * @example production
   */
  environment?: string;
};

export type WorkerDomainListDomainsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersDomainResponseCollection & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerDomainListDomainsVariables = {
  pathParams: WorkerDomainListDomainsPathParams;
  queryParams?: WorkerDomainListDomainsQueryParams;
} & FetcherExtraProps;

/**
 * Lists all Worker Domains for an account.
 */
export const workerDomainListDomains = (variables: WorkerDomainListDomainsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersDomainResponseCollection,
    WorkerDomainListDomainsError,
    undefined,
    {},
    WorkerDomainListDomainsQueryParams,
    WorkerDomainListDomainsPathParams
  >({ url: '/accounts/{accountId}/workers/domains', method: 'get', ...variables, signal });

export type WorkerDomainAttachToDomainPathParams = {
  accountId: Schemas.WorkersAccountIdentifier;
};

export type WorkerDomainAttachToDomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersDomainResponseSingle & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerDomainAttachToDomainRequestBody = {
  environment: Schemas.WorkersSchemasEnvironment;
  hostname: Schemas.WorkersHostname;
  service: Schemas.WorkersSchemasService;
  zone_id: Schemas.WorkersZoneIdentifier;
};

export type WorkerDomainAttachToDomainVariables = {
  body: WorkerDomainAttachToDomainRequestBody;
  pathParams: WorkerDomainAttachToDomainPathParams;
} & FetcherExtraProps;

/**
 * Attaches a Worker to a zone and hostname.
 */
export const workerDomainAttachToDomain = (variables: WorkerDomainAttachToDomainVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersDomainResponseSingle,
    WorkerDomainAttachToDomainError,
    WorkerDomainAttachToDomainRequestBody,
    {},
    {},
    WorkerDomainAttachToDomainPathParams
  >({ url: '/accounts/{accountId}/workers/domains', method: 'put', ...variables, signal });

export type WorkerDomainDetachFromDomainPathParams = {
  accountId: Schemas.WorkersAccountIdentifier;
  domainId: Schemas.WorkersDomainIdentifier;
};

export type WorkerDomainDetachFromDomainError = Fetcher.ErrorWrapper<undefined>;

export type WorkerDomainDetachFromDomainVariables = {
  pathParams: WorkerDomainDetachFromDomainPathParams;
} & FetcherExtraProps;

/**
 * Detaches a Worker from a zone and hostname.
 */
export const workerDomainDetachFromDomain = (variables: WorkerDomainDetachFromDomainVariables, signal?: AbortSignal) =>
  fetch<undefined, WorkerDomainDetachFromDomainError, undefined, {}, {}, WorkerDomainDetachFromDomainPathParams>({
    url: '/accounts/{accountId}/workers/domains/{domainId}',
    method: 'delete',
    ...variables,
    signal
  });

export type WorkerDomainGetADomainPathParams = {
  accountId: Schemas.WorkersAccountIdentifier;
  domainId: Schemas.WorkersDomainIdentifier;
};

export type WorkerDomainGetADomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersDomainResponseSingle & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerDomainGetADomainVariables = {
  pathParams: WorkerDomainGetADomainPathParams;
} & FetcherExtraProps;

/**
 * Gets a Worker domain.
 */
export const workerDomainGetADomain = (variables: WorkerDomainGetADomainVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersDomainResponseSingle,
    WorkerDomainGetADomainError,
    undefined,
    {},
    {},
    WorkerDomainGetADomainPathParams
  >({ url: '/accounts/{accountId}/workers/domains/{domainId}', method: 'get', ...variables, signal });

export type DurableObjectsNamespaceListNamespacesPathParams = {
  accountId: Schemas.WorkersIdentifier;
};

export type DurableObjectsNamespaceListNamespacesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.WorkersApiResponseCollection & {
    result?: Schemas.WorkersNamespace[];
  }) &
    Schemas.WorkersApiResponseCommonFailure;
}>;

export type DurableObjectsNamespaceListNamespacesResponse = Schemas.WorkersApiResponseCollection & {
  result?: Schemas.WorkersNamespace[];
};

export type DurableObjectsNamespaceListNamespacesVariables = {
  pathParams: DurableObjectsNamespaceListNamespacesPathParams;
} & FetcherExtraProps;

/**
 * Returns the Durable Object namespaces owned by an account.
 */
export const durableObjectsNamespaceListNamespaces = (
  variables: DurableObjectsNamespaceListNamespacesVariables,
  signal?: AbortSignal
) =>
  fetch<
    DurableObjectsNamespaceListNamespacesResponse,
    DurableObjectsNamespaceListNamespacesError,
    undefined,
    {},
    {},
    DurableObjectsNamespaceListNamespacesPathParams
  >({ url: '/accounts/{accountId}/workers/durable_objects/namespaces', method: 'get', ...variables, signal });

export type DurableObjectsNamespaceListObjectsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  id: Schemas.WorkersSchemasId;
};

export type DurableObjectsNamespaceListObjectsQueryParams = {
  /**
   * @default 1000
   * @maximum 10000
   * @minimum 10
   */
  limit?: number;
  /**
   * @example AAAAANuhDN7SjacTnSVsDu3WW1Lvst6dxJGTjRY5BhxPXdf6L6uTcpd_NVtjhn11OUYRsVEykxoUwF-JQU4dn6QylZSKTOJuG0indrdn_MlHpMRtsxgXjs-RPdHYIVm3odE_uvEQ_dTQGFm8oikZMohns34DLBgrQpc
   */
  cursor?: string;
};

export type DurableObjectsNamespaceListObjectsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.WorkersApiResponseCollection & {
    result?: Schemas.WorkersObject[];
    result_info?: {
      /**
       * Total results returned based on your list parameters.
       *
       * @example 1
       */
      count?: number;
      cursor?: Schemas.WorkersCursor;
    };
  }) &
    Schemas.WorkersApiResponseCommonFailure;
}>;

export type DurableObjectsNamespaceListObjectsResponse = Schemas.WorkersApiResponseCollection & {
  result?: Schemas.WorkersObject[];
  result_info?: {
    /**
     * Total results returned based on your list parameters.
     *
     * @example 1
     */
    count?: number;
    cursor?: Schemas.WorkersCursor;
  };
};

export type DurableObjectsNamespaceListObjectsVariables = {
  pathParams: DurableObjectsNamespaceListObjectsPathParams;
  queryParams?: DurableObjectsNamespaceListObjectsQueryParams;
} & FetcherExtraProps;

/**
 * Returns the Durable Objects in a given namespace.
 */
export const durableObjectsNamespaceListObjects = (
  variables: DurableObjectsNamespaceListObjectsVariables,
  signal?: AbortSignal
) =>
  fetch<
    DurableObjectsNamespaceListObjectsResponse,
    DurableObjectsNamespaceListObjectsError,
    undefined,
    {},
    DurableObjectsNamespaceListObjectsQueryParams,
    DurableObjectsNamespaceListObjectsPathParams
  >({
    url: '/accounts/{accountId}/workers/durable_objects/namespaces/{id}/objects',
    method: 'get',
    ...variables,
    signal
  });

export type WorkerScriptListWorkersPathParams = {
  accountId: Schemas.WorkersIdentifier;
};

export type WorkerScriptListWorkersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersScriptResponseCollection & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerScriptListWorkersVariables = {
  pathParams: WorkerScriptListWorkersPathParams;
} & FetcherExtraProps;

/**
 * Fetch a list of uploaded workers.
 */
export const workerScriptListWorkers = (variables: WorkerScriptListWorkersVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersScriptResponseCollection,
    WorkerScriptListWorkersError,
    undefined,
    {},
    {},
    WorkerScriptListWorkersPathParams
  >({ url: '/accounts/{accountId}/workers/scripts', method: 'get', ...variables, signal });

export type WorkerScriptDeleteWorkerPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
};

export type WorkerScriptDeleteWorkerQueryParams = {
  /**
   * If set to true, delete will not be stopped by associated service binding, durable object, or other binding. Any of these associated bindings/durable objects will be deleted along with the script.
   */
  force?: boolean;
};

export type WorkerScriptDeleteWorkerError = Fetcher.ErrorWrapper<undefined>;

export type WorkerScriptDeleteWorkerVariables = {
  pathParams: WorkerScriptDeleteWorkerPathParams;
  queryParams?: WorkerScriptDeleteWorkerQueryParams;
} & FetcherExtraProps;

/**
 * Delete your worker. This call has no response body on a successful delete.
 */
export const workerScriptDeleteWorker = (variables: WorkerScriptDeleteWorkerVariables, signal?: AbortSignal) =>
  fetch<
    undefined,
    WorkerScriptDeleteWorkerError,
    undefined,
    {},
    WorkerScriptDeleteWorkerQueryParams,
    WorkerScriptDeleteWorkerPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}', method: 'delete', ...variables, signal });

export type WorkerScriptDownloadWorkerPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
};

export type WorkerScriptDownloadWorkerError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerScriptDownloadWorkerVariables = {
  pathParams: WorkerScriptDownloadWorkerPathParams;
} & FetcherExtraProps;

/**
 * Fetch raw script content for your worker. Note this is the original script content, not JSON encoded.
 */
export const workerScriptDownloadWorker = (variables: WorkerScriptDownloadWorkerVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersMultipartScript,
    WorkerScriptDownloadWorkerError,
    undefined,
    {},
    {},
    WorkerScriptDownloadWorkerPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}', method: 'get', ...variables, signal });

export type WorkerScriptUploadWorkerModulePathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
};

export type WorkerScriptUploadWorkerModuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: void & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerScriptUploadWorkerModuleResponse = Schemas.WorkersScriptResponseUploadSingle & void;

export type WorkerScriptUploadWorkerModuleVariables = {
  body: RequestBodies.WorkersScriptUpload;
  pathParams: WorkerScriptUploadWorkerModulePathParams;
} & FetcherExtraProps;

/**
 * Upload a worker module. You can find more about the multipart metadata on our docs: https://developers.cloudflare.com/workers/configuration/multipart-upload-metadata/.
 */
export const workerScriptUploadWorkerModule = (
  variables: WorkerScriptUploadWorkerModuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorkerScriptUploadWorkerModuleResponse,
    WorkerScriptUploadWorkerModuleError,
    RequestBodies.WorkersScriptUpload,
    {},
    {},
    WorkerScriptUploadWorkerModulePathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}', method: 'put', ...variables, signal });

export type WorkerScriptUpdateCreateAssetsUploadSessionPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
};

export type WorkerScriptUpdateCreateAssetsUploadSessionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersCreateAssetsUploadSessionResponse & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerScriptUpdateCreateAssetsUploadSessionVariables = {
  body?: Schemas.WorkersCreateAssetsUploadSessionObject;
  pathParams: WorkerScriptUpdateCreateAssetsUploadSessionPathParams;
} & FetcherExtraProps;

/**
 * Start uploading a collection of assets for use in a Worker version. To learn more about the direct uploads of assets, see https://developers.cloudflare.com/workers/static-assets/direct-upload/
 */
export const workerScriptUpdateCreateAssetsUploadSession = (
  variables: WorkerScriptUpdateCreateAssetsUploadSessionVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersCreateAssetsUploadSessionResponse,
    WorkerScriptUpdateCreateAssetsUploadSessionError,
    Schemas.WorkersCreateAssetsUploadSessionObject,
    {},
    {},
    WorkerScriptUpdateCreateAssetsUploadSessionPathParams
  >({
    url: '/accounts/{accountId}/workers/scripts/{scriptName}/assets-upload-session',
    method: 'post',
    ...variables,
    signal
  });

export type WorkerScriptPutContentPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
};

export type WorkerScriptPutContentHeaders = {
  /**
   * The multipart name of a script upload part containing script content in service worker format. Alternative to including in a metadata part.
   */
  ['CF-WORKER-BODY-PART']?: string;
  /**
   * The multipart name of a script upload part containing script content in es module format. Alternative to including in a metadata part.
   */
  ['CF-WORKER-MAIN-MODULE-PART']?: string;
};

export type WorkerScriptPutContentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerScriptPutContentRequestBody = {
  /**
   * JSON encoded metadata about the uploaded parts and Worker configuration.
   */
  metadata: {
    /**
     * Name of the part in the multipart request that contains the script (e.g. the file adding a listener to the `fetch` event). Indicates a `service worker syntax` Worker.
     *
     * @example worker.js
     */
    body_part?: string;
    /**
     * Name of the part in the multipart request that contains the main module (e.g. the file exporting a `fetch` handler). Indicates a `module syntax` Worker.
     *
     * @example worker.js
     */
    main_module?: string;
  };
} & {
  [key: string]: Blob[];
};

export type WorkerScriptPutContentVariables = {
  body: WorkerScriptPutContentRequestBody;
  headers?: WorkerScriptPutContentHeaders;
  pathParams: WorkerScriptPutContentPathParams;
} & FetcherExtraProps;

/**
 * Put script content without touching config or metadata
 */
export const workerScriptPutContent = (variables: WorkerScriptPutContentVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersScriptResponseSingle,
    WorkerScriptPutContentError,
    WorkerScriptPutContentRequestBody,
    WorkerScriptPutContentHeaders,
    {},
    WorkerScriptPutContentPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}/content', method: 'put', ...variables, signal });

export type WorkerScriptGetContentPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
};

export type WorkerScriptGetContentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type WorkerScriptGetContentVariables = {
  pathParams: WorkerScriptGetContentPathParams;
} & FetcherExtraProps;

/**
 * Fetch script content only
 */
export const workerScriptGetContent = (variables: WorkerScriptGetContentVariables, signal?: AbortSignal) =>
  fetch<undefined, WorkerScriptGetContentError, undefined, {}, {}, WorkerScriptGetContentPathParams>({
    url: '/accounts/{accountId}/workers/scripts/{scriptName}/content/v2',
    method: 'get',
    ...variables,
    signal
  });

export type WorkerDeploymentsListDeploymentsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersSchemasScriptName;
};

export type WorkerDeploymentsListDeploymentsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersDeploymentsListResponse & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerDeploymentsListDeploymentsVariables = {
  pathParams: WorkerDeploymentsListDeploymentsPathParams;
} & FetcherExtraProps;

/**
 * List of Worker Deployments. The first deployment in the list is the latest deployment actively serving traffic.
 */
export const workerDeploymentsListDeployments = (
  variables: WorkerDeploymentsListDeploymentsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersDeploymentsListResponse,
    WorkerDeploymentsListDeploymentsError,
    undefined,
    {},
    {},
    WorkerDeploymentsListDeploymentsPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}/deployments', method: 'get', ...variables, signal });

export type WorkerDeploymentsCreateDeploymentPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersSchemasScriptName;
};

export type WorkerDeploymentsCreateDeploymentQueryParams = {
  /**
   * If set to true, the deployment will be created even if normally blocked by something such rolling back to an older version when a secret has changed.
   */
  force?: boolean;
};

export type WorkerDeploymentsCreateDeploymentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersDeploymentsSingleResponse & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerDeploymentsCreateDeploymentVariables = {
  body?: Schemas.WorkersDeploymentsCreateBody;
  pathParams: WorkerDeploymentsCreateDeploymentPathParams;
  queryParams?: WorkerDeploymentsCreateDeploymentQueryParams;
} & FetcherExtraProps;

/**
 * Deployments configure how [Worker Versions](https://developers.cloudflare.com/api/operations/worker-versions-list-versions) are deployed to traffic. A deployment can consist of one or two versions of a Worker.
 */
export const workerDeploymentsCreateDeployment = (
  variables: WorkerDeploymentsCreateDeploymentVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersDeploymentsSingleResponse,
    WorkerDeploymentsCreateDeploymentError,
    Schemas.WorkersDeploymentsCreateBody,
    {},
    WorkerDeploymentsCreateDeploymentQueryParams,
    WorkerDeploymentsCreateDeploymentPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}/deployments', method: 'post', ...variables, signal });

export type WorkerCronTriggerGetCronTriggersPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
};

export type WorkerCronTriggerGetCronTriggersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersCronTriggerResponseCollection & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerCronTriggerGetCronTriggersVariables = {
  pathParams: WorkerCronTriggerGetCronTriggersPathParams;
} & FetcherExtraProps;

/**
 * Fetches Cron Triggers for a Worker.
 */
export const workerCronTriggerGetCronTriggers = (
  variables: WorkerCronTriggerGetCronTriggersVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersCronTriggerResponseCollection,
    WorkerCronTriggerGetCronTriggersError,
    undefined,
    {},
    {},
    WorkerCronTriggerGetCronTriggersPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}/schedules', method: 'get', ...variables, signal });

export type WorkerCronTriggerUpdateCronTriggersPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
};

export type WorkerCronTriggerUpdateCronTriggersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersCronTriggerResponseCollection & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerCronTriggerUpdateCronTriggersRequestBody = Schemas.WorkersCronObject[];

export type WorkerCronTriggerUpdateCronTriggersVariables = {
  body?: WorkerCronTriggerUpdateCronTriggersRequestBody;
  pathParams: WorkerCronTriggerUpdateCronTriggersPathParams;
} & FetcherExtraProps;

/**
 * Updates Cron Triggers for a Worker.
 */
export const workerCronTriggerUpdateCronTriggers = (
  variables: WorkerCronTriggerUpdateCronTriggersVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersCronTriggerResponseCollection,
    WorkerCronTriggerUpdateCronTriggersError,
    WorkerCronTriggerUpdateCronTriggersRequestBody,
    {},
    {},
    WorkerCronTriggerUpdateCronTriggersPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}/schedules', method: 'put', ...variables, signal });

export type WorkerScriptSettingsGetSettingsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
};

export type WorkerScriptSettingsGetSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type WorkerScriptSettingsGetSettingsVariables = {
  pathParams: WorkerScriptSettingsGetSettingsPathParams;
} & FetcherExtraProps;

/**
 * Get script-level settings when using [Worker Versions](https://developers.cloudflare.com/api/operations/worker-versions-list-versions). Includes Logpush and Tail Consumers.
 */
export const workerScriptSettingsGetSettings = (
  variables: WorkerScriptSettingsGetSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersScriptSettingsResponse,
    WorkerScriptSettingsGetSettingsError,
    undefined,
    {},
    {},
    WorkerScriptSettingsGetSettingsPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}/script-settings', method: 'get', ...variables, signal });

export type WorkerScriptSettingsPatchSettingsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
};

export type WorkerScriptSettingsPatchSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type WorkerScriptSettingsPatchSettingsVariables = {
  body?: Schemas.WorkersScriptSettingsItem;
  pathParams: WorkerScriptSettingsPatchSettingsPathParams;
} & FetcherExtraProps;

/**
 * Patch script-level settings when using [Worker Versions](https://developers.cloudflare.com/api/operations/worker-versions-list-versions). Including but not limited to Logpush and Tail Consumers.
 */
export const workerScriptSettingsPatchSettings = (
  variables: WorkerScriptSettingsPatchSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersScriptSettingsResponse,
    WorkerScriptSettingsPatchSettingsError,
    Schemas.WorkersScriptSettingsItem,
    {},
    {},
    WorkerScriptSettingsPatchSettingsPathParams
  >({
    url: '/accounts/{accountId}/workers/scripts/{scriptName}/script-settings',
    method: 'patch',
    ...variables,
    signal
  });

export type WorkerScriptGetSettingsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
};

export type WorkerScriptGetSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type WorkerScriptGetSettingsVariables = {
  pathParams: WorkerScriptGetSettingsPathParams;
} & FetcherExtraProps;

/**
 * Get metadata and config, such as bindings or usage model
 */
export const workerScriptGetSettings = (variables: WorkerScriptGetSettingsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersScriptAndVersionSettingsResponse,
    WorkerScriptGetSettingsError,
    undefined,
    {},
    {},
    WorkerScriptGetSettingsPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}/settings', method: 'get', ...variables, signal });

export type WorkerScriptPatchSettingsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
};

export type WorkerScriptPatchSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type WorkerScriptPatchSettingsRequestBody = {
  settings?: Schemas.WorkersScriptAndVersionSettingsItem;
};

export type WorkerScriptPatchSettingsVariables = {
  body?: WorkerScriptPatchSettingsRequestBody;
  pathParams: WorkerScriptPatchSettingsPathParams;
} & FetcherExtraProps;

/**
 * Patch metadata or config, such as bindings or usage model
 */
export const workerScriptPatchSettings = (variables: WorkerScriptPatchSettingsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersScriptAndVersionSettingsResponse,
    WorkerScriptPatchSettingsError,
    WorkerScriptPatchSettingsRequestBody,
    {},
    {},
    WorkerScriptPatchSettingsPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}/settings', method: 'patch', ...variables, signal });

export type WorkerScriptGetSubdomainPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
};

export type WorkerScriptGetSubdomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type WorkerScriptGetSubdomainResponse = {
  /**
   * Whether the Worker is available on the workers.dev subdomain.
   *
   * @example true
   */
  enabled?: boolean;
  /**
   * Whether the Worker's Preview URLs should be available on the workers.dev subdomain.
   *
   * @example true
   */
  previews_enabled?: boolean;
};

export type WorkerScriptGetSubdomainVariables = {
  pathParams: WorkerScriptGetSubdomainPathParams;
} & FetcherExtraProps;

/**
 * Get if the Worker is available on the workers.dev subdomain.
 */
export const workerScriptGetSubdomain = (variables: WorkerScriptGetSubdomainVariables, signal?: AbortSignal) =>
  fetch<
    WorkerScriptGetSubdomainResponse,
    WorkerScriptGetSubdomainError,
    undefined,
    {},
    {},
    WorkerScriptGetSubdomainPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}/subdomain', method: 'get', ...variables, signal });

export type WorkerScriptPostSubdomainPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
};

export type WorkerScriptPostSubdomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type WorkerScriptPostSubdomainResponse = {
  /**
   * Whether the Worker is available on the workers.dev subdomain.
   *
   * @example true
   */
  enabled?: boolean;
  /**
   * Whether the Worker's Preview URLs should be available on the workers.dev subdomain.
   *
   * @example true
   */
  previews_enabled?: boolean;
};

export type WorkerScriptPostSubdomainRequestBody = {
  /**
   * Whether the Worker should be available on the workers.dev subdomain.
   *
   * @example true
   */
  enabled: boolean;
  /**
   * Whether the Worker's Preview URLs should be available on the workers.dev subdomain.
   *
   * @example true
   */
  previews_enabled?: boolean;
};

export type WorkerScriptPostSubdomainVariables = {
  body: WorkerScriptPostSubdomainRequestBody;
  pathParams: WorkerScriptPostSubdomainPathParams;
} & FetcherExtraProps;

/**
 * Enable or disable the Worker on the workers.dev subdomain.
 */
export const workerScriptPostSubdomain = (variables: WorkerScriptPostSubdomainVariables, signal?: AbortSignal) =>
  fetch<
    WorkerScriptPostSubdomainResponse,
    WorkerScriptPostSubdomainError,
    WorkerScriptPostSubdomainRequestBody,
    {},
    {},
    WorkerScriptPostSubdomainPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}/subdomain', method: 'post', ...variables, signal });

export type GetAccountsAccountIdWorkersScriptsScriptNameTailsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
};

export type GetAccountsAccountIdWorkersScriptsScriptNameTailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersTailResponse & Schemas.WorkersApiResponseCommonFailure;
}>;

export type GetAccountsAccountIdWorkersScriptsScriptNameTailsVariables = {
  pathParams: GetAccountsAccountIdWorkersScriptsScriptNameTailsPathParams;
} & FetcherExtraProps;

/**
 * Get list of tails currently deployed on a Worker.
 */
export const getAccountsAccountIdWorkersScriptsScriptNameTails = (
  variables: GetAccountsAccountIdWorkersScriptsScriptNameTailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersTailResponse,
    GetAccountsAccountIdWorkersScriptsScriptNameTailsError,
    undefined,
    {},
    {},
    GetAccountsAccountIdWorkersScriptsScriptNameTailsPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}/tails', method: 'get', ...variables, signal });

export type WorkerTailLogsStartTailPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
};

export type WorkerTailLogsStartTailError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersTailResponse & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerTailLogsStartTailVariables = {
  pathParams: WorkerTailLogsStartTailPathParams;
} & FetcherExtraProps;

/**
 * Starts a tail that receives logs and exception from a Worker.
 */
export const workerTailLogsStartTail = (variables: WorkerTailLogsStartTailVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersTailResponse,
    WorkerTailLogsStartTailError,
    undefined,
    {},
    {},
    WorkerTailLogsStartTailPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}/tails', method: 'post', ...variables, signal });

export type WorkerTailLogsDeleteTailPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
  id: Schemas.WorkersId;
};

export type WorkerTailLogsDeleteTailError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    /**
     * @example {"code":7003,"message":"No route for the URI"}
     * @minLength 1
     */
    errors: Schemas.WorkersMessages;
    messages: Schemas.WorkersMessages;
    /**
     * Whether the API call was successful
     *
     * @example false
     */
    success: false;
    result: any | null;
  };
}>;

export type WorkerTailLogsDeleteTailVariables = {
  pathParams: WorkerTailLogsDeleteTailPathParams;
} & FetcherExtraProps;

/**
 * Deletes a tail from a Worker.
 */
export const workerTailLogsDeleteTail = (variables: WorkerTailLogsDeleteTailVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersApiResponseCommon,
    WorkerTailLogsDeleteTailError,
    undefined,
    {},
    {},
    WorkerTailLogsDeleteTailPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}/tails/{id}', method: 'delete', ...variables, signal });

export type WorkerScriptFetchUsageModelPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
};

export type WorkerScriptFetchUsageModelError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersUsageModelResponse & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerScriptFetchUsageModelVariables = {
  pathParams: WorkerScriptFetchUsageModelPathParams;
} & FetcherExtraProps;

/**
 * Fetches the Usage Model for a given Worker.
 */
export const workerScriptFetchUsageModel = (variables: WorkerScriptFetchUsageModelVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersUsageModelResponse,
    WorkerScriptFetchUsageModelError,
    undefined,
    {},
    {},
    WorkerScriptFetchUsageModelPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}/usage-model', method: 'get', ...variables, signal });

export type WorkerScriptUpdateUsageModelPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersScriptName;
};

export type WorkerScriptUpdateUsageModelError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersUsageModelResponse & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerScriptUpdateUsageModelVariables = {
  body?: Schemas.WorkersUsageModelObject;
  pathParams: WorkerScriptUpdateUsageModelPathParams;
} & FetcherExtraProps;

/**
 * Updates the Usage Model for a given Worker. Requires a Workers Paid subscription.
 */
export const workerScriptUpdateUsageModel = (variables: WorkerScriptUpdateUsageModelVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersUsageModelResponse,
    WorkerScriptUpdateUsageModelError,
    Schemas.WorkersUsageModelObject,
    {},
    {},
    WorkerScriptUpdateUsageModelPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}/usage-model', method: 'put', ...variables, signal });

export type WorkerVersionsListVersionsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersSchemasScriptName;
};

export type WorkerVersionsListVersionsQueryParams = {
  /**
   * Only return versions that can be used in a deployment. Ignores pagination.
   *
   * @default false
   */
  deployable?: boolean;
  /**
   * Current page.
   *
   * @default 1
   */
  page?: number;
  /**
   * Items per-page.
   */
  per_page?: number;
};

export type WorkerVersionsListVersionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersVersionsListResponse & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerVersionsListVersionsVariables = {
  pathParams: WorkerVersionsListVersionsPathParams;
  queryParams?: WorkerVersionsListVersionsQueryParams;
} & FetcherExtraProps;

/**
 * List of Worker Versions. The first version in the list is the latest version.
 */
export const workerVersionsListVersions = (variables: WorkerVersionsListVersionsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersVersionsListResponse,
    WorkerVersionsListVersionsError,
    undefined,
    {},
    WorkerVersionsListVersionsQueryParams,
    WorkerVersionsListVersionsPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}/versions', method: 'get', ...variables, signal });

export type WorkerVersionsUploadVersionPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersSchemasScriptName;
};

export type WorkerVersionsUploadVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersVersionsUploadResponse & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerVersionsUploadVersionVariables = {
  body: RequestBodies.WorkersVersionPost;
  pathParams: WorkerVersionsUploadVersionPathParams;
} & FetcherExtraProps;

/**
 * Upload a Worker Version without deploying to Cloudflare's network. You can find more about the multipart metadata on our docs: https://developers.cloudflare.com/workers/configuration/multipart-upload-metadata/.
 */
export const workerVersionsUploadVersion = (variables: WorkerVersionsUploadVersionVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersVersionsUploadResponse,
    WorkerVersionsUploadVersionError,
    RequestBodies.WorkersVersionPost,
    {},
    {},
    WorkerVersionsUploadVersionPathParams
  >({ url: '/accounts/{accountId}/workers/scripts/{scriptName}/versions', method: 'post', ...variables, signal });

export type WorkerVersionsGetVersionDetailPathParams = {
  accountId: Schemas.WorkersIdentifier;
  scriptName: Schemas.WorkersSchemasScriptName;
  versionId: Schemas.WorkersVersionIdentifier;
};

export type WorkerVersionsGetVersionDetailError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersVersionsSingleResponse & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerVersionsGetVersionDetailVariables = {
  pathParams: WorkerVersionsGetVersionDetailPathParams;
} & FetcherExtraProps;

export const workerVersionsGetVersionDetail = (
  variables: WorkerVersionsGetVersionDetailVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersVersionsSingleResponse,
    WorkerVersionsGetVersionDetailError,
    undefined,
    {},
    {},
    WorkerVersionsGetVersionDetailPathParams
  >({
    url: '/accounts/{accountId}/workers/scripts/{scriptName}/versions/{versionId}',
    method: 'get',
    ...variables,
    signal
  });

export type WorkerEnvironmentGetScriptContentPathParams = {
  accountId: Schemas.WorkersIdentifier;
  serviceName: Schemas.WorkersService;
  environmentName: Schemas.WorkersEnvironment;
};

export type WorkerEnvironmentGetScriptContentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerEnvironmentGetScriptContentVariables = {
  pathParams: WorkerEnvironmentGetScriptContentPathParams;
} & FetcherExtraProps;

/**
 * Get script content from a worker with an environment
 */
export const workerEnvironmentGetScriptContent = (
  variables: WorkerEnvironmentGetScriptContentVariables,
  signal?: AbortSignal
) =>
  fetch<
    undefined,
    WorkerEnvironmentGetScriptContentError,
    undefined,
    {},
    {},
    WorkerEnvironmentGetScriptContentPathParams
  >({
    url: '/accounts/{accountId}/workers/services/{serviceName}/environments/{environmentName}/content',
    method: 'get',
    ...variables,
    signal
  });

export type WorkerEnvironmentPutScriptContentPathParams = {
  accountId: Schemas.WorkersIdentifier;
  serviceName: Schemas.WorkersService;
  environmentName: Schemas.WorkersEnvironment;
};

export type WorkerEnvironmentPutScriptContentHeaders = {
  /**
   * The multipart name of a script upload part containing script content in service worker format. Alternative to including in a metadata part.
   */
  ['CF-WORKER-BODY-PART']?: string;
  /**
   * The multipart name of a script upload part containing script content in es module format. Alternative to including in a metadata part.
   */
  ['CF-WORKER-MAIN-MODULE-PART']?: string;
};

export type WorkerEnvironmentPutScriptContentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerEnvironmentPutScriptContentRequestBody = {
  /**
   * JSON encoded metadata about the uploaded parts and Worker configuration.
   */
  metadata: {
    /**
     * Name of the part in the multipart request that contains the script (e.g. the file adding a listener to the `fetch` event). Indicates a `service worker syntax` Worker.
     *
     * @example worker.js
     */
    body_part?: string;
    /**
     * Name of the part in the multipart request that contains the main module (e.g. the file exporting a `fetch` handler). Indicates a `module syntax` Worker.
     *
     * @example worker.js
     */
    main_module?: string;
  };
} & {
  [key: string]: Blob[];
};

export type WorkerEnvironmentPutScriptContentVariables = {
  body: WorkerEnvironmentPutScriptContentRequestBody;
  headers?: WorkerEnvironmentPutScriptContentHeaders;
  pathParams: WorkerEnvironmentPutScriptContentPathParams;
} & FetcherExtraProps;

/**
 * Put script content from a worker with an environment
 */
export const workerEnvironmentPutScriptContent = (
  variables: WorkerEnvironmentPutScriptContentVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersScriptResponseSingle,
    WorkerEnvironmentPutScriptContentError,
    WorkerEnvironmentPutScriptContentRequestBody,
    WorkerEnvironmentPutScriptContentHeaders,
    {},
    WorkerEnvironmentPutScriptContentPathParams
  >({
    url: '/accounts/{accountId}/workers/services/{serviceName}/environments/{environmentName}/content',
    method: 'put',
    ...variables,
    signal
  });

export type WorkerScriptEnvironmentGetSettingsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  serviceName: Schemas.WorkersService;
  environmentName: Schemas.WorkersEnvironment;
};

export type WorkerScriptEnvironmentGetSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type WorkerScriptEnvironmentGetSettingsVariables = {
  pathParams: WorkerScriptEnvironmentGetSettingsPathParams;
} & FetcherExtraProps;

/**
 * Get script settings from a worker with an environment
 */
export const workerScriptEnvironmentGetSettings = (
  variables: WorkerScriptEnvironmentGetSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersScriptSettingsResponse,
    WorkerScriptEnvironmentGetSettingsError,
    undefined,
    {},
    {},
    WorkerScriptEnvironmentGetSettingsPathParams
  >({
    url: '/accounts/{accountId}/workers/services/{serviceName}/environments/{environmentName}/settings',
    method: 'get',
    ...variables,
    signal
  });

export type WorkerScriptEnvironmentPatchSettingsPathParams = {
  accountId: Schemas.WorkersIdentifier;
  serviceName: Schemas.WorkersService;
  environmentName: Schemas.WorkersEnvironment;
};

export type WorkerScriptEnvironmentPatchSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseCommon;
}>;

export type WorkerScriptEnvironmentPatchSettingsVariables = {
  body?: Schemas.WorkersScriptSettingsResponse;
  pathParams: WorkerScriptEnvironmentPatchSettingsPathParams;
} & FetcherExtraProps;

/**
 * Patch script metadata, such as bindings
 */
export const workerScriptEnvironmentPatchSettings = (
  variables: WorkerScriptEnvironmentPatchSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersScriptSettingsResponse,
    WorkerScriptEnvironmentPatchSettingsError,
    Schemas.WorkersScriptSettingsResponse,
    {},
    {},
    WorkerScriptEnvironmentPatchSettingsPathParams
  >({
    url: '/accounts/{accountId}/workers/services/{serviceName}/environments/{environmentName}/settings',
    method: 'patch',
    ...variables,
    signal
  });

export type WorkerSubdomainGetSubdomainPathParams = {
  accountId: Schemas.WorkersIdentifier;
};

export type WorkerSubdomainGetSubdomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersSubdomainResponse & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerSubdomainGetSubdomainVariables = {
  pathParams: WorkerSubdomainGetSubdomainPathParams;
} & FetcherExtraProps;

/**
 * Returns a Workers subdomain for an account.
 */
export const workerSubdomainGetSubdomain = (variables: WorkerSubdomainGetSubdomainVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersSubdomainResponse,
    WorkerSubdomainGetSubdomainError,
    undefined,
    {},
    {},
    WorkerSubdomainGetSubdomainPathParams
  >({ url: '/accounts/{accountId}/workers/subdomain', method: 'get', ...variables, signal });

export type WorkerSubdomainCreateSubdomainPathParams = {
  accountId: Schemas.WorkersIdentifier;
};

export type WorkerSubdomainCreateSubdomainError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersSubdomainResponse & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerSubdomainCreateSubdomainVariables = {
  body?: Schemas.WorkersSubdomainObject;
  pathParams: WorkerSubdomainCreateSubdomainPathParams;
} & FetcherExtraProps;

/**
 * Creates a Workers subdomain for an account.
 */
export const workerSubdomainCreateSubdomain = (
  variables: WorkerSubdomainCreateSubdomainVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WorkersSubdomainResponse,
    WorkerSubdomainCreateSubdomainError,
    Schemas.WorkersSubdomainObject,
    {},
    {},
    WorkerSubdomainCreateSubdomainPathParams
  >({ url: '/accounts/{accountId}/workers/subdomain', method: 'put', ...variables, signal });

export type WorListWorkflowsPathParams = {
  accountId: string;
};

export type WorListWorkflowsQueryParams = {
  /**
   * @default 10
   * @maximum 100
   * @minimum 1
   */
  per_page?: number;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
};

export type WorListWorkflowsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      code: number;
      message: string;
    }[];
    messages: string[];
    result: any | null;
    success: false;
  };
}>;

export type WorListWorkflowsResponse = {
  errors: {
    code: number;
    message: string;
  }[];
  messages: {
    code: number;
    message: string;
  }[];
  result: {
    class_name: string;
    /**
     * @format date-time
     */
    created_on: string;
    /**
     * @format uuid
     */
    id: string;
    instances: {
      complete?: number;
      errored?: number;
      paused?: number;
      queued?: number;
      running?: number;
      terminated?: number;
      unknown?: number;
      waiting?: number;
      waitingForPause?: number;
    };
    /**
     * @format date-time
     */
    modified_on: string;
    /**
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-zA-Z0-9_][a-zA-Z0-9-_]*$
     */
    name: string;
    script_name: string;
    /**
     * @format date-time
     */
    triggered_on: string | null;
  }[];
  result_info?: {
    count: number;
    page: number;
    per_page: number;
    total_count: number;
  };
  success: true;
};

export type WorListWorkflowsVariables = {
  pathParams: WorListWorkflowsPathParams;
  queryParams?: WorListWorkflowsQueryParams;
} & FetcherExtraProps;

export const worListWorkflows = (variables: WorListWorkflowsVariables, signal?: AbortSignal) =>
  fetch<
    WorListWorkflowsResponse,
    WorListWorkflowsError,
    undefined,
    {},
    WorListWorkflowsQueryParams,
    WorListWorkflowsPathParams
  >({ url: '/accounts/{accountId}/workflows', method: 'get', ...variables, signal });

export type WorGetWorkflowDetailsPathParams = {
  /**
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-zA-Z0-9_][a-zA-Z0-9-_]*$
   */
  workflowName: string;
  accountId: string;
};

export type WorGetWorkflowDetailsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          code: number;
          message: string;
        }[];
        messages: string[];
        result: any | null;
        success: false;
      };
    }
  | {
      status: 404;
      payload: {
        errors: {
          code: number;
          message: string;
        }[];
        messages: string[];
        result: any | null;
        success: false;
      };
    }
>;

export type WorGetWorkflowDetailsResponse = {
  errors: {
    code: number;
    message: string;
  }[];
  messages: {
    code: number;
    message: string;
  }[];
  result: {
    class_name: string;
    /**
     * @format date-time
     */
    created_on: string;
    /**
     * @format uuid
     */
    id: string;
    instances: {
      complete?: number;
      errored?: number;
      paused?: number;
      queued?: number;
      running?: number;
      terminated?: number;
      unknown?: number;
      waiting?: number;
      waitingForPause?: number;
    };
    /**
     * @format date-time
     */
    modified_on: string;
    /**
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-zA-Z0-9_][a-zA-Z0-9-_]*$
     */
    name: string;
    script_name: string;
    /**
     * @format date-time
     */
    triggered_on: string | null;
  };
  result_info?: {
    count: number;
    page: number;
    per_page: number;
    total_count: number;
  };
  success: true;
};

export type WorGetWorkflowDetailsVariables = {
  pathParams: WorGetWorkflowDetailsPathParams;
} & FetcherExtraProps;

export const worGetWorkflowDetails = (variables: WorGetWorkflowDetailsVariables, signal?: AbortSignal) =>
  fetch<WorGetWorkflowDetailsResponse, WorGetWorkflowDetailsError, undefined, {}, {}, WorGetWorkflowDetailsPathParams>({
    url: '/accounts/{accountId}/workflows/{workflowName}',
    method: 'get',
    ...variables,
    signal
  });

export type WorCreateOrModifyWorkflowPathParams = {
  /**
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-zA-Z0-9_][a-zA-Z0-9-_]*$
   */
  workflowName: string;
  accountId: string;
};

export type WorCreateOrModifyWorkflowError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      code: number;
      message: string;
    }[];
    messages: string[];
    result: any | null;
    success: false;
  };
}>;

export type WorCreateOrModifyWorkflowResponse = {
  errors: {
    code: number;
    message: string;
  }[];
  messages: {
    code: number;
    message: string;
  }[];
  result: {
    class_name: string;
    /**
     * @format date-time
     */
    created_on: string;
    /**
     * @format uuid
     */
    id: string;
    /**
     * @format date-time
     */
    modified_on: string;
    /**
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-zA-Z0-9_][a-zA-Z0-9-_]*$
     */
    name: string;
    script_name: string;
    /**
     * @format date-time
     */
    triggered_on: string | null;
    /**
     * @format uuid
     */
    version_id: string;
  };
  result_info?: {
    count: number;
    page: number;
    per_page: number;
    total_count: number;
  };
  success: true;
};

export type WorCreateOrModifyWorkflowRequestBody = {
  /**
   * @maxLength 255
   * @minLength 1
   */
  class_name: string;
  /**
   * @maxLength 255
   * @minLength 1
   */
  script_name: string;
};

export type WorCreateOrModifyWorkflowVariables = {
  body: WorCreateOrModifyWorkflowRequestBody;
  pathParams: WorCreateOrModifyWorkflowPathParams;
} & FetcherExtraProps;

export const worCreateOrModifyWorkflow = (variables: WorCreateOrModifyWorkflowVariables, signal?: AbortSignal) =>
  fetch<
    WorCreateOrModifyWorkflowResponse,
    WorCreateOrModifyWorkflowError,
    WorCreateOrModifyWorkflowRequestBody,
    {},
    {},
    WorCreateOrModifyWorkflowPathParams
  >({ url: '/accounts/{accountId}/workflows/{workflowName}', method: 'put', ...variables, signal });

export type WorListWorkflowInstancesPathParams = {
  /**
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-zA-Z0-9_][a-zA-Z0-9-_]*$
   */
  workflowName: string;
  accountId: string;
};

export type WorListWorkflowInstancesQueryParams = {
  /**
   * @default 50
   * @maximum 100
   * @minimum 1
   */
  per_page?: number;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  status?:
    | 'queued'
    | 'running'
    | 'paused'
    | 'errored'
    | 'terminated'
    | 'complete'
    | 'waitingForPause'
    | 'waiting'
    | 'unknown';
  /**
   * In ISO 8601 with no timezone offsets and in UTC.
   *
   * @format date-time
   */
  date_start?: string;
  /**
   * In ISO 8601 with no timezone offsets and in UTC.
   *
   * @format date-time
   */
  date_end?: string;
};

export type WorListWorkflowInstancesError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          code: number;
          message: string;
        }[];
        messages: string[];
        result: any | null;
        success: false;
      };
    }
  | {
      status: 404;
      payload: {
        errors: {
          code: number;
          message: string;
        }[];
        messages: string[];
        result: any | null;
        success: false;
      };
    }
>;

export type WorListWorkflowInstancesResponse = {
  errors: {
    code: number;
    message: string;
  }[];
  messages: {
    code: number;
    message: string;
  }[];
  result: {
    /**
     * @format date-time
     */
    created_on: string;
    /**
     * @format date-time
     */
    ended_on: string | null;
    /**
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-zA-Z0-9_][a-zA-Z0-9-_]*$
     */
    id: string;
    /**
     * @format date-time
     */
    modified_on: string;
    /**
     * @format date-time
     */
    started_on: string | null;
    status:
      | 'queued'
      | 'running'
      | 'paused'
      | 'errored'
      | 'terminated'
      | 'complete'
      | 'waitingForPause'
      | 'waiting'
      | 'unknown';
    /**
     * @format uuid
     */
    version_id: string;
    /**
     * @format uuid
     */
    workflow_id: string;
  }[];
  result_info?: {
    count: number;
    page: number;
    per_page: number;
    total_count: number;
  };
  success: true;
};

export type WorListWorkflowInstancesVariables = {
  pathParams: WorListWorkflowInstancesPathParams;
  queryParams?: WorListWorkflowInstancesQueryParams;
} & FetcherExtraProps;

export const worListWorkflowInstances = (variables: WorListWorkflowInstancesVariables, signal?: AbortSignal) =>
  fetch<
    WorListWorkflowInstancesResponse,
    WorListWorkflowInstancesError,
    undefined,
    {},
    WorListWorkflowInstancesQueryParams,
    WorListWorkflowInstancesPathParams
  >({ url: '/accounts/{accountId}/workflows/{workflowName}/instances', method: 'get', ...variables, signal });

export type WorCreateNewWorkflowInstancePathParams = {
  /**
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-zA-Z0-9_][a-zA-Z0-9-_]*$
   */
  workflowName: string;
  accountId: string;
};

export type WorCreateNewWorkflowInstanceError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          code: number;
          message: string;
        }[];
        messages: string[];
        result: any | null;
        success: false;
      };
    }
  | {
      status: 404;
      payload: {
        errors: {
          code: number;
          message: string;
        }[];
        messages: string[];
        result: any | null;
        success: false;
      };
    }
>;

export type WorCreateNewWorkflowInstanceResponse = {
  errors: {
    code: number;
    message: string;
  }[];
  messages: {
    code: number;
    message: string;
  }[];
  result: {
    /**
     * @maxLength 64
     * @minLength 1
     * @pattern ^[a-zA-Z0-9_][a-zA-Z0-9-_]*$
     */
    id: string;
    status:
      | 'queued'
      | 'running'
      | 'paused'
      | 'errored'
      | 'terminated'
      | 'complete'
      | 'waitingForPause'
      | 'waiting'
      | 'unknown';
    /**
     * @format uuid
     */
    version_id: string;
    /**
     * @format uuid
     */
    workflow_id: string;
  };
  result_info?: {
    count: number;
    page: number;
    per_page: number;
    total_count: number;
  };
  success: true;
};

export type WorCreateNewWorkflowInstanceRequestBody = {
  /**
   * @maxLength 64
   * @pattern ^[a-zA-Z0-9_][a-zA-Z0-9-_]*$
   */
  instance_id?: string;
  params?: Record<string, any>;
};

export type WorCreateNewWorkflowInstanceVariables = {
  body?: WorCreateNewWorkflowInstanceRequestBody;
  pathParams: WorCreateNewWorkflowInstancePathParams;
} & FetcherExtraProps;

export const worCreateNewWorkflowInstance = (variables: WorCreateNewWorkflowInstanceVariables, signal?: AbortSignal) =>
  fetch<
    WorCreateNewWorkflowInstanceResponse,
    WorCreateNewWorkflowInstanceError,
    WorCreateNewWorkflowInstanceRequestBody,
    {},
    {},
    WorCreateNewWorkflowInstancePathParams
  >({ url: '/accounts/{accountId}/workflows/{workflowName}/instances', method: 'post', ...variables, signal });

export type WorDescribeWorkflowInstancePathParams = {
  /**
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-zA-Z0-9_][a-zA-Z0-9-_]*$
   */
  workflowName: string;
  /**
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-zA-Z0-9_][a-zA-Z0-9-_]*$
   */
  instanceId: string;
  accountId: string;
};

export type WorDescribeWorkflowInstanceError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          code: number;
          message: string;
        }[];
        messages: string[];
        result: any | null;
        success: false;
      };
    }
  | {
      status: 404;
      payload: {
        errors: {
          code: number;
          message: string;
        }[];
        messages: string[];
        result: any | null;
        success: false;
      };
    }
>;

export type WorDescribeWorkflowInstanceResponse = {
  errors: {
    code: number;
    message: string;
  }[];
  messages: {
    code: number;
    message: string;
  }[];
  result: {
    /**
     * @format date-time
     */
    end: string | null;
    error: {
      message: string;
      name: string;
    } | null;
    output: string | number;
    params: Record<string, any>;
    /**
     * @format date-time
     */
    queued: string;
    /**
     * @format date-time
     */
    start: string | null;
    status:
      | 'queued'
      | 'running'
      | 'paused'
      | 'errored'
      | 'terminated'
      | 'complete'
      | 'waitingForPause'
      | 'waiting'
      | 'unknown';
    steps: (
      | {
          attempts: {
            /**
             * @format date-time
             */
            end: string | null;
            error: {
              message: string;
              name: string;
            } | null;
            /**
             * @format date-time
             */
            start: string;
            success: boolean | null;
          }[];
          config: {
            retries: {
              backoff?: 'constant' | 'linear' | 'exponential';
              delay: string | number;
              limit: number;
            };
            timeout: string | number;
          };
          /**
           * @format date-time
           */
          end: string | null;
          name: string;
          output: Record<string, any>;
          /**
           * @format date-time
           */
          start: string;
          success: boolean | null;
          type: 'step';
        }
      | {
          /**
           * @format date-time
           */
          end: string;
          error: {
            message: string;
            name: string;
          } | null;
          finished: boolean;
          name: string;
          /**
           * @format date-time
           */
          start: string;
          type: 'sleep';
        }
      | {
          trigger: {
            source: string;
          };
          type: 'termination';
        }
    )[];
    success: boolean | null;
    trigger: {
      source: 'unknown' | 'api' | 'binding' | 'event' | 'cron';
    };
    /**
     * @format uuid
     */
    versionId: string;
  };
  result_info?: {
    count: number;
    page: number;
    per_page: number;
    total_count: number;
  };
  success: true;
};

export type WorDescribeWorkflowInstanceVariables = {
  pathParams: WorDescribeWorkflowInstancePathParams;
} & FetcherExtraProps;

export const worDescribeWorkflowInstance = (variables: WorDescribeWorkflowInstanceVariables, signal?: AbortSignal) =>
  fetch<
    WorDescribeWorkflowInstanceResponse,
    WorDescribeWorkflowInstanceError,
    undefined,
    {},
    {},
    WorDescribeWorkflowInstancePathParams
  >({
    url: '/accounts/{accountId}/workflows/{workflowName}/instances/{instanceId}',
    method: 'get',
    ...variables,
    signal
  });

export type WorChangeStatusWorkflowInstancePathParams = {
  /**
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-zA-Z0-9_][a-zA-Z0-9-_]*$
   */
  workflowName: string;
  /**
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-zA-Z0-9_][a-zA-Z0-9-_]*$
   */
  instanceId: string;
  accountId: string;
};

export type WorChangeStatusWorkflowInstanceError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          code: number;
          message: string;
        }[];
        messages: string[];
        result: any | null;
        success: false;
      };
    }
  | {
      status: 404;
      payload: {
        errors: {
          code: number;
          message: string;
        }[];
        messages: string[];
        result: any | null;
        success: false;
      };
    }
  | {
      status: 409;
      payload: {
        errors: {
          code: number;
          message: string;
        }[];
        messages: string[];
        result: any | null;
        success: false;
      };
    }
>;

export type WorChangeStatusWorkflowInstanceResponse = {
  errors: {
    code: number;
    message: string;
  }[];
  messages: {
    code: number;
    message: string;
  }[];
  result: {
    status:
      | 'queued'
      | 'running'
      | 'paused'
      | 'errored'
      | 'terminated'
      | 'complete'
      | 'waitingForPause'
      | 'waiting'
      | 'unknown';
    /**
     * In ISO 8601 with no timezone offsets and in UTC.
     *
     * @format date-time
     */
    timestamp: string;
  };
  result_info?: {
    count: number;
    page: number;
    per_page: number;
    total_count: number;
  };
  success: true;
};

export type WorChangeStatusWorkflowInstanceRequestBody = {
  /**
   * Possible actions to apply to instance
   */
  status: 'resume' | 'pause' | 'terminate';
};

export type WorChangeStatusWorkflowInstanceVariables = {
  body: WorChangeStatusWorkflowInstanceRequestBody;
  pathParams: WorChangeStatusWorkflowInstancePathParams;
} & FetcherExtraProps;

export const worChangeStatusWorkflowInstance = (
  variables: WorChangeStatusWorkflowInstanceVariables,
  signal?: AbortSignal
) =>
  fetch<
    WorChangeStatusWorkflowInstanceResponse,
    WorChangeStatusWorkflowInstanceError,
    WorChangeStatusWorkflowInstanceRequestBody,
    {},
    {},
    WorChangeStatusWorkflowInstancePathParams
  >({
    url: '/accounts/{accountId}/workflows/{workflowName}/instances/{instanceId}/status',
    method: 'patch',
    ...variables,
    signal
  });

export type WorListWorkflowVersionsPathParams = {
  /**
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-zA-Z0-9_][a-zA-Z0-9-_]*$
   */
  workflowName: string;
  accountId: string;
};

export type WorListWorkflowVersionsQueryParams = {
  /**
   * @default 50
   * @maximum 100
   * @minimum 1
   */
  per_page?: number;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
};

export type WorListWorkflowVersionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      code: number;
      message: string;
    }[];
    messages: string[];
    result: any | null;
    success: false;
  };
}>;

export type WorListWorkflowVersionsResponse = {
  errors: {
    code: number;
    message: string;
  }[];
  messages: {
    code: number;
    message: string;
  }[];
  result: {
    class_name: string;
    /**
     * @format date-time
     */
    created_on: string;
    /**
     * @format uuid
     */
    id: string;
    /**
     * @format date-time
     */
    modified_on: string;
    /**
     * @format uuid
     */
    workflow_id: string;
  }[];
  result_info?: {
    count: number;
    page: number;
    per_page: number;
    total_count: number;
  };
  success: true;
};

export type WorListWorkflowVersionsVariables = {
  pathParams: WorListWorkflowVersionsPathParams;
  queryParams?: WorListWorkflowVersionsQueryParams;
} & FetcherExtraProps;

export const worListWorkflowVersions = (variables: WorListWorkflowVersionsVariables, signal?: AbortSignal) =>
  fetch<
    WorListWorkflowVersionsResponse,
    WorListWorkflowVersionsError,
    undefined,
    {},
    WorListWorkflowVersionsQueryParams,
    WorListWorkflowVersionsPathParams
  >({ url: '/accounts/{accountId}/workflows/{workflowName}/versions', method: 'get', ...variables, signal });

export type WorDescribeWorkflowVersionsPathParams = {
  /**
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-zA-Z0-9_][a-zA-Z0-9-_]*$
   */
  workflowName: string;
  /**
   * @format uuid
   */
  versionId: string;
  accountId: string;
};

export type WorDescribeWorkflowVersionsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: {
        errors: {
          code: number;
          message: string;
        }[];
        messages: string[];
        result: any | null;
        success: false;
      };
    }
  | {
      status: 404;
      payload: {
        errors: {
          code: number;
          message: string;
        }[];
        messages: string[];
        result: any | null;
        success: false;
      };
    }
>;

export type WorDescribeWorkflowVersionsResponse = {
  errors: {
    code: number;
    message: string;
  }[];
  messages: {
    code: number;
    message: string;
  }[];
  result: {
    class_name: string;
    /**
     * @format date-time
     */
    created_on: string;
    /**
     * @format uuid
     */
    id: string;
    /**
     * @format date-time
     */
    modified_on: string;
    /**
     * @format uuid
     */
    workflow_id: string;
  };
  result_info?: {
    count: number;
    page: number;
    per_page: number;
    total_count: number;
  };
  success: true;
};

export type WorDescribeWorkflowVersionsVariables = {
  pathParams: WorDescribeWorkflowVersionsPathParams;
} & FetcherExtraProps;

export const worDescribeWorkflowVersions = (variables: WorDescribeWorkflowVersionsVariables, signal?: AbortSignal) =>
  fetch<
    WorDescribeWorkflowVersionsResponse,
    WorDescribeWorkflowVersionsError,
    undefined,
    {},
    {},
    WorDescribeWorkflowVersionsPathParams
  >({
    url: '/accounts/{accountId}/workflows/{workflowName}/versions/{versionId}',
    method: 'get',
    ...variables,
    signal
  });

export type ZeroTrustAccountsGetConnectivitySettingsPathParams = {
  accountId: Schemas.TunnelAccountId;
};

export type ZeroTrustAccountsGetConnectivitySettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelApiResponseCommonFailure;
}>;

export type ZeroTrustAccountsGetConnectivitySettingsVariables = {
  pathParams: ZeroTrustAccountsGetConnectivitySettingsPathParams;
} & FetcherExtraProps;

/**
 * Gets the Zero Trust Connectivity Settings for the given account.
 */
export const zeroTrustAccountsGetConnectivitySettings = (
  variables: ZeroTrustAccountsGetConnectivitySettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelZeroTrustConnectivitySettingsResponse,
    ZeroTrustAccountsGetConnectivitySettingsError,
    undefined,
    {},
    {},
    ZeroTrustAccountsGetConnectivitySettingsPathParams
  >({ url: '/accounts/{accountId}/zerotrust/connectivity_settings', method: 'get', ...variables, signal });

export type ZeroTrustAccountsPatchConnectivitySettingsPathParams = {
  accountId: Schemas.TunnelAccountId;
};

export type ZeroTrustAccountsPatchConnectivitySettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TunnelApiResponseCommonFailure;
}>;

export type ZeroTrustAccountsPatchConnectivitySettingsRequestBody = {
  icmp_proxy_enabled?: Schemas.TunnelIcmpProxyEnabled;
  offramp_warp_enabled?: Schemas.TunnelOfframpWarpEnabled;
};

export type ZeroTrustAccountsPatchConnectivitySettingsVariables = {
  body?: ZeroTrustAccountsPatchConnectivitySettingsRequestBody;
  pathParams: ZeroTrustAccountsPatchConnectivitySettingsPathParams;
} & FetcherExtraProps;

/**
 * Updates the Zero Trust Connectivity Settings for the given account.
 */
export const zeroTrustAccountsPatchConnectivitySettings = (
  variables: ZeroTrustAccountsPatchConnectivitySettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TunnelZeroTrustConnectivitySettingsResponse,
    ZeroTrustAccountsPatchConnectivitySettingsError,
    ZeroTrustAccountsPatchConnectivitySettingsRequestBody,
    {},
    {},
    ZeroTrustAccountsPatchConnectivitySettingsPathParams
  >({ url: '/accounts/{accountId}/zerotrust/connectivity_settings', method: 'patch', ...variables, signal });

export type DlpRiskScoreBehaviorsGetPathParams = {
  accountId: string;
};

export type DlpRiskScoreBehaviorsGetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpRiskScoreBehaviorsGetResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpBehaviors;
};

export type DlpRiskScoreBehaviorsGetVariables = {
  pathParams: DlpRiskScoreBehaviorsGetPathParams;
} & FetcherExtraProps;

export const dlpRiskScoreBehaviorsGet = (variables: DlpRiskScoreBehaviorsGetVariables, signal?: AbortSignal) =>
  fetch<
    DlpRiskScoreBehaviorsGetResponse,
    DlpRiskScoreBehaviorsGetError,
    undefined,
    {},
    {},
    DlpRiskScoreBehaviorsGetPathParams
  >({ url: '/accounts/{accountId}/zt_risk_scoring/behaviors', method: 'get', ...variables, signal });

export type DlpRiskScoreBehaviorsPutPathParams = {
  /**
   * Account ID
   */
  accountId: string;
};

export type DlpRiskScoreBehaviorsPutError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpRiskScoreBehaviorsPutResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpUpdateBehaviors;
};

export type DlpRiskScoreBehaviorsPutVariables = {
  body: Schemas.DlpUpdateBehaviors;
  pathParams: DlpRiskScoreBehaviorsPutPathParams;
} & FetcherExtraProps;

export const dlpRiskScoreBehaviorsPut = (variables: DlpRiskScoreBehaviorsPutVariables, signal?: AbortSignal) =>
  fetch<
    DlpRiskScoreBehaviorsPutResponse,
    DlpRiskScoreBehaviorsPutError,
    Schemas.DlpUpdateBehaviors,
    {},
    {},
    DlpRiskScoreBehaviorsPutPathParams
  >({ url: '/accounts/{accountId}/zt_risk_scoring/behaviors', method: 'put', ...variables, signal });

export type DlpZtRiskScoreIntegrationListPathParams = {
  accountId: string;
};

export type DlpZtRiskScoreIntegrationListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpZtRiskScoreIntegrationListResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpRiskScoreIntegrationArray;
};

export type DlpZtRiskScoreIntegrationListVariables = {
  pathParams: DlpZtRiskScoreIntegrationListPathParams;
} & FetcherExtraProps;

export const dlpZtRiskScoreIntegrationList = (
  variables: DlpZtRiskScoreIntegrationListVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlpZtRiskScoreIntegrationListResponse,
    DlpZtRiskScoreIntegrationListError,
    undefined,
    {},
    {},
    DlpZtRiskScoreIntegrationListPathParams
  >({ url: '/accounts/{accountId}/zt_risk_scoring/integrations', method: 'get', ...variables, signal });

export type DlpZtRiskScoreIntegrationCreatePathParams = {
  accountId: string;
};

export type DlpZtRiskScoreIntegrationCreateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpZtRiskScoreIntegrationCreateResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpRiskScoreIntegration;
};

export type DlpZtRiskScoreIntegrationCreateVariables = {
  body: Schemas.DlpCreateIntegrationBody;
  pathParams: DlpZtRiskScoreIntegrationCreatePathParams;
} & FetcherExtraProps;

export const dlpZtRiskScoreIntegrationCreate = (
  variables: DlpZtRiskScoreIntegrationCreateVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlpZtRiskScoreIntegrationCreateResponse,
    DlpZtRiskScoreIntegrationCreateError,
    Schemas.DlpCreateIntegrationBody,
    {},
    {},
    DlpZtRiskScoreIntegrationCreatePathParams
  >({ url: '/accounts/{accountId}/zt_risk_scoring/integrations', method: 'post', ...variables, signal });

export type DlpZtRiskScoreIntegrationGetByReferenceIdPathParams = {
  accountId: string;
  referenceId: string;
};

export type DlpZtRiskScoreIntegrationGetByReferenceIdError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpZtRiskScoreIntegrationGetByReferenceIdResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpRiskScoreIntegration;
};

export type DlpZtRiskScoreIntegrationGetByReferenceIdVariables = {
  pathParams: DlpZtRiskScoreIntegrationGetByReferenceIdPathParams;
} & FetcherExtraProps;

export const dlpZtRiskScoreIntegrationGetByReferenceId = (
  variables: DlpZtRiskScoreIntegrationGetByReferenceIdVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlpZtRiskScoreIntegrationGetByReferenceIdResponse,
    DlpZtRiskScoreIntegrationGetByReferenceIdError,
    undefined,
    {},
    {},
    DlpZtRiskScoreIntegrationGetByReferenceIdPathParams
  >({
    url: '/accounts/{accountId}/zt_risk_scoring/integrations/reference_id/{referenceId}',
    method: 'get',
    ...variables,
    signal
  });

export type DlpZtRiskScoreIntegrationDeletePathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  integrationId: string;
};

export type DlpZtRiskScoreIntegrationDeleteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpZtRiskScoreIntegrationDeleteResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpEmpty;
};

export type DlpZtRiskScoreIntegrationDeleteVariables = {
  pathParams: DlpZtRiskScoreIntegrationDeletePathParams;
} & FetcherExtraProps;

export const dlpZtRiskScoreIntegrationDelete = (
  variables: DlpZtRiskScoreIntegrationDeleteVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlpZtRiskScoreIntegrationDeleteResponse,
    DlpZtRiskScoreIntegrationDeleteError,
    undefined,
    {},
    {},
    DlpZtRiskScoreIntegrationDeletePathParams
  >({
    url: '/accounts/{accountId}/zt_risk_scoring/integrations/{integrationId}',
    method: 'delete',
    ...variables,
    signal
  });

export type DlpZtRiskScoreIntegrationGetPathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  integrationId: string;
};

export type DlpZtRiskScoreIntegrationGetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpZtRiskScoreIntegrationGetResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpRiskScoreIntegration;
};

export type DlpZtRiskScoreIntegrationGetVariables = {
  pathParams: DlpZtRiskScoreIntegrationGetPathParams;
} & FetcherExtraProps;

export const dlpZtRiskScoreIntegrationGet = (variables: DlpZtRiskScoreIntegrationGetVariables, signal?: AbortSignal) =>
  fetch<
    DlpZtRiskScoreIntegrationGetResponse,
    DlpZtRiskScoreIntegrationGetError,
    undefined,
    {},
    {},
    DlpZtRiskScoreIntegrationGetPathParams
  >({ url: '/accounts/{accountId}/zt_risk_scoring/integrations/{integrationId}', method: 'get', ...variables, signal });

export type DlpZtRiskScoreIntegrationUpdatePathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  integrationId: string;
};

export type DlpZtRiskScoreIntegrationUpdateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpZtRiskScoreIntegrationUpdateResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpRiskScoreIntegration;
};

export type DlpZtRiskScoreIntegrationUpdateVariables = {
  body: Schemas.DlpUpdateIntegrationBody;
  pathParams: DlpZtRiskScoreIntegrationUpdatePathParams;
} & FetcherExtraProps;

/**
 * Overwrite the reference_id, tenant_url, and active values with the ones provided
 */
export const dlpZtRiskScoreIntegrationUpdate = (
  variables: DlpZtRiskScoreIntegrationUpdateVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlpZtRiskScoreIntegrationUpdateResponse,
    DlpZtRiskScoreIntegrationUpdateError,
    Schemas.DlpUpdateIntegrationBody,
    {},
    {},
    DlpZtRiskScoreIntegrationUpdatePathParams
  >({ url: '/accounts/{accountId}/zt_risk_scoring/integrations/{integrationId}', method: 'put', ...variables, signal });

export type DlpRiskScoreSummaryGetPathParams = {
  accountId: string;
};

export type DlpRiskScoreSummaryGetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpRiskScoreSummaryGetResponse = Schemas.DlpApiResponseCollection & {
  result?: Schemas.DlpRiskSummary;
};

export type DlpRiskScoreSummaryGetVariables = {
  pathParams: DlpRiskScoreSummaryGetPathParams;
} & FetcherExtraProps;

export const dlpRiskScoreSummaryGet = (variables: DlpRiskScoreSummaryGetVariables, signal?: AbortSignal) =>
  fetch<
    DlpRiskScoreSummaryGetResponse,
    DlpRiskScoreSummaryGetError,
    undefined,
    {},
    {},
    DlpRiskScoreSummaryGetPathParams
  >({ url: '/accounts/{accountId}/zt_risk_scoring/summary', method: 'get', ...variables, signal });

export type DlpRiskScoreSummaryGetForUserPathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  userId: string;
};

export type DlpRiskScoreSummaryGetForUserError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpRiskScoreSummaryGetForUserResponse = Schemas.DlpApiResponseCollection & {
  result?: Schemas.DlpRiskEvents;
};

export type DlpRiskScoreSummaryGetForUserVariables = {
  pathParams: DlpRiskScoreSummaryGetForUserPathParams;
} & FetcherExtraProps;

export const dlpRiskScoreSummaryGetForUser = (
  variables: DlpRiskScoreSummaryGetForUserVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlpRiskScoreSummaryGetForUserResponse,
    DlpRiskScoreSummaryGetForUserError,
    undefined,
    {},
    {},
    DlpRiskScoreSummaryGetForUserPathParams
  >({ url: '/accounts/{accountId}/zt_risk_scoring/{userId}', method: 'get', ...variables, signal });

export type DlpRiskScoreResetPostPathParams = {
  accountId: string;
  /**
   * @format uuid
   */
  userId: string;
};

export type DlpRiskScoreResetPostError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlpApiResponseCommonFailure;
}>;

export type DlpRiskScoreResetPostResponse = Schemas.DlpApiResponseSingle & {
  result?: Schemas.DlpEmpty;
};

export type DlpRiskScoreResetPostVariables = {
  pathParams: DlpRiskScoreResetPostPathParams;
} & FetcherExtraProps;

export const dlpRiskScoreResetPost = (variables: DlpRiskScoreResetPostVariables, signal?: AbortSignal) =>
  fetch<DlpRiskScoreResetPostResponse, DlpRiskScoreResetPostError, undefined, {}, {}, DlpRiskScoreResetPostPathParams>({
    url: '/accounts/{accountId}/zt_risk_scoring/{userId}/reset',
    method: 'post',
    ...variables,
    signal
  });

export type OriginCaListCertificatesQueryParams = {
  zone_id?: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type OriginCaListCertificatesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesSchemasCertificateResponseCollection &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type OriginCaListCertificatesVariables = {
  queryParams?: OriginCaListCertificatesQueryParams;
} & FetcherExtraProps;

/**
 * List all existing Origin CA certificates for a given zone. You can use an Origin CA Key as your User Service Key or an API token when calling this endpoint ([see above](#requests)).
 */
export const originCaListCertificates = (variables: OriginCaListCertificatesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesSchemasCertificateResponseCollection,
    OriginCaListCertificatesError,
    undefined,
    {},
    OriginCaListCertificatesQueryParams,
    {}
  >({ url: '/certificates', method: 'get', ...variables, signal });

export type OriginCaCreateCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesSchemasCertificateResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type OriginCaCreateCertificateRequestBody = {
  csr?: Schemas.TlsCertificatesAndHostnamesCsr;
  hostnames?: Schemas.TlsCertificatesAndHostnamesHostnames;
  request_type?: Schemas.TlsCertificatesAndHostnamesRequestType;
  requested_validity?: Schemas.TlsCertificatesAndHostnamesRequestedValidity;
};

export type OriginCaCreateCertificateVariables = {
  body?: OriginCaCreateCertificateRequestBody;
} & FetcherExtraProps;

/**
 * Create an Origin CA certificate. You can use an Origin CA Key as your User Service Key or an API token when calling this endpoint ([see above](#requests)).
 */
export const originCaCreateCertificate = (variables: OriginCaCreateCertificateVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesSchemasCertificateResponseSingle,
    OriginCaCreateCertificateError,
    OriginCaCreateCertificateRequestBody,
    {},
    {},
    {}
  >({ url: '/certificates', method: 'post', ...variables, signal });

export type OriginCaRevokeCertificatePathParams = {
  certificateId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type OriginCaRevokeCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesCertificateRevokeResponse &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type OriginCaRevokeCertificateVariables = {
  pathParams: OriginCaRevokeCertificatePathParams;
} & FetcherExtraProps;

/**
 * Revoke an existing Origin CA certificate by its serial number. You can use an Origin CA Key as your User Service Key or an API token when calling this endpoint ([see above](#requests)).
 */
export const originCaRevokeCertificate = (variables: OriginCaRevokeCertificateVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesCertificateRevokeResponse,
    OriginCaRevokeCertificateError,
    undefined,
    {},
    {},
    OriginCaRevokeCertificatePathParams
  >({ url: '/certificates/{certificateId}', method: 'delete', ...variables, signal });

export type OriginCaGetCertificatePathParams = {
  certificateId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type OriginCaGetCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesSchemasCertificateResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type OriginCaGetCertificateVariables = {
  pathParams: OriginCaGetCertificatePathParams;
} & FetcherExtraProps;

/**
 * Get an existing Origin CA certificate by its serial number. You can use an Origin CA Key as your User Service Key or an API token when calling this endpoint ([see above](#requests)).
 */
export const originCaGetCertificate = (variables: OriginCaGetCertificateVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesSchemasCertificateResponseSingle,
    OriginCaGetCertificateError,
    undefined,
    {},
    {},
    OriginCaGetCertificatePathParams
  >({ url: '/certificates/{certificateId}', method: 'get', ...variables, signal });

export type CloudflareIPsCloudflareIpDetailsQueryParams = {
  /**
   * Specified as `jdcloud` to list IPs used by JD Cloud data centers.
   */
  networks?: string;
};

export type CloudflareIPsCloudflareIpDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.AddressingApiResponseSingle & {
    result?: Schemas.AddressingIps | Schemas.AddressingIpsJdcloud;
  }) &
    Schemas.AddressingApiResponseCommonFailure;
}>;

export type CloudflareIPsCloudflareIpDetailsResponse = Schemas.AddressingApiResponseSingle & {
  result?: Schemas.AddressingIps | Schemas.AddressingIpsJdcloud;
};

export type CloudflareIPsCloudflareIpDetailsVariables = {
  queryParams?: CloudflareIPsCloudflareIpDetailsQueryParams;
} & FetcherExtraProps;

/**
 * Get IPs used on the Cloudflare/JD Cloud network, see https://www.cloudflare.com/ips for Cloudflare IPs or https://developers.cloudflare.com/china-network/reference/infrastructure/ for JD Cloud IPs.
 */
export const cloudflareIPsCloudflareIpDetails = (
  variables: CloudflareIPsCloudflareIpDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    CloudflareIPsCloudflareIpDetailsResponse,
    CloudflareIPsCloudflareIpDetailsError,
    undefined,
    {},
    CloudflareIPsCloudflareIpDetailsQueryParams,
    {}
  >({ url: '/ips', method: 'get', ...variables, signal });

export type UserSAccountMembershipsListMembershipsQueryParams = {
  ['account.name']?: Schemas.IamPropertiesName;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example status
   */
  order?: 'id' | 'account.name' | 'status';
  /**
   * @example desc
   */
  direction?: 'asc' | 'desc';
  name?: Schemas.IamPropertiesName;
  /**
   * @example accepted
   */
  status?: 'accepted' | 'pending' | 'rejected';
};

export type UserSAccountMembershipsListMembershipsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserSAccountMembershipsListMembershipsVariables = {
  queryParams?: UserSAccountMembershipsListMembershipsQueryParams;
} & FetcherExtraProps;

/**
 * List memberships of accounts the user can access.
 */
export const userSAccountMembershipsListMemberships = (
  variables: UserSAccountMembershipsListMembershipsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.IamCollectionMembershipResponse | Schemas.IamCollectionMembershipResponseWithPolicies,
    UserSAccountMembershipsListMembershipsError,
    undefined,
    {},
    UserSAccountMembershipsListMembershipsQueryParams,
    {}
  >({ url: '/memberships', method: 'get', ...variables, signal });

export type UserSAccountMembershipsDeleteMembershipPathParams = {
  membershipId: Schemas.IamMembershipComponentsSchemasIdentifier;
};

export type UserSAccountMembershipsDeleteMembershipError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserSAccountMembershipsDeleteMembershipResponse = Schemas.IamApiResponseSingle & {
  result?: {
    id?: Schemas.IamMembershipComponentsSchemasIdentifier;
  };
};

export type UserSAccountMembershipsDeleteMembershipVariables = {
  pathParams: UserSAccountMembershipsDeleteMembershipPathParams;
} & FetcherExtraProps;

/**
 * Remove the associated member from an account.
 */
export const userSAccountMembershipsDeleteMembership = (
  variables: UserSAccountMembershipsDeleteMembershipVariables,
  signal?: AbortSignal
) =>
  fetch<
    UserSAccountMembershipsDeleteMembershipResponse,
    UserSAccountMembershipsDeleteMembershipError,
    undefined,
    {},
    {},
    UserSAccountMembershipsDeleteMembershipPathParams
  >({ url: '/memberships/{membershipId}', method: 'delete', ...variables, signal });

export type UserSAccountMembershipsMembershipDetailsPathParams = {
  membershipId: Schemas.IamMembershipComponentsSchemasIdentifier;
};

export type UserSAccountMembershipsMembershipDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserSAccountMembershipsMembershipDetailsVariables = {
  pathParams: UserSAccountMembershipsMembershipDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get a specific membership.
 */
export const userSAccountMembershipsMembershipDetails = (
  variables: UserSAccountMembershipsMembershipDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.IamSingleMembershipResponseWithPolicies,
    UserSAccountMembershipsMembershipDetailsError,
    undefined,
    {},
    {},
    UserSAccountMembershipsMembershipDetailsPathParams
  >({ url: '/memberships/{membershipId}', method: 'get', ...variables, signal });

export type UserSAccountMembershipsUpdateMembershipPathParams = {
  membershipId: Schemas.IamMembershipComponentsSchemasIdentifier;
};

export type UserSAccountMembershipsUpdateMembershipError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserSAccountMembershipsUpdateMembershipRequestBody = {
  /**
   * Whether to accept or reject this account invitation.
   *
   * @example accepted
   */
  status: 'accepted' | 'rejected';
};

export type UserSAccountMembershipsUpdateMembershipVariables = {
  body: UserSAccountMembershipsUpdateMembershipRequestBody;
  pathParams: UserSAccountMembershipsUpdateMembershipPathParams;
} & FetcherExtraProps;

/**
 * Accept or reject this account invitation.
 */
export const userSAccountMembershipsUpdateMembership = (
  variables: UserSAccountMembershipsUpdateMembershipVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.IamSingleMembershipResponseWithPolicies,
    UserSAccountMembershipsUpdateMembershipError,
    UserSAccountMembershipsUpdateMembershipRequestBody,
    {},
    {},
    UserSAccountMembershipsUpdateMembershipPathParams
  >({ url: '/memberships/{membershipId}', method: 'put', ...variables, signal });

export type AuditLogsGetOrganizationAuditLogsPathParams = {
  organizationId: Schemas.AaaIdentifier;
};

export type AuditLogsGetOrganizationAuditLogsQueryParams = {
  /**
   * @example f174be97-19b1-40d6-954d-70cd5fbd52db
   */
  id?: string;
  /**
   * @example true
   */
  ['export']?: boolean;
  /**
   * @example add
   */
  ['action.type']?: string;
  /**
   * @example 17.168.228.63
   */
  ['actor.ip']?: string;
  /**
   * @example alice@example.com
   * @format email
   */
  ['actor.email']?: string;
  since?: string | string;
  before?: string | string;
  /**
   * @example example.com
   */
  ['zone.name']?: string;
  /**
   * @default desc
   * @example desc
   */
  direction?: 'desc' | 'asc';
  /**
   * @default 100
   * @example 25
   * @maximum 1000
   * @minimum 1
   */
  per_page?: number;
  /**
   * @default 1
   * @example 50
   * @minimum 1
   */
  page?: number;
  /**
   * @default false
   */
  hide_user_logs?: boolean;
};

export type AuditLogsGetOrganizationAuditLogsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaAuditLogsResponseCollection & Schemas.AaaApiResponseCommonFailure;
}>;

export type AuditLogsGetOrganizationAuditLogsVariables = {
  pathParams: AuditLogsGetOrganizationAuditLogsPathParams;
  queryParams?: AuditLogsGetOrganizationAuditLogsQueryParams;
} & FetcherExtraProps;

/**
 * Gets a list of audit logs for an organization. Can be filtered by who made the change, on which zone, and the timeframe of the change.
 */
export const auditLogsGetOrganizationAuditLogs = (
  variables: AuditLogsGetOrganizationAuditLogsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AaaAuditLogsResponseCollection,
    AuditLogsGetOrganizationAuditLogsError,
    undefined,
    {},
    AuditLogsGetOrganizationAuditLogsQueryParams,
    AuditLogsGetOrganizationAuditLogsPathParams
  >({ url: '/organizations/{organizationId}/audit_logs', method: 'get', ...variables, signal });

export type OrganizationSharesListPathParams = {
  organizationId: Schemas.ResourceSharingOrganizationId;
};

export type OrganizationSharesListQueryParams = {
  /**
   * Filter shares by status.
   */
  status?: Schemas.ResourceSharingShareStatus;
  /**
   * Filter shares by kind.
   */
  kind?: Schemas.ResourceSharingShareKind;
  /**
   * Filter shares by target_type.
   */
  target_type?: Schemas.ResourceSharingShareTargetType;
  /**
   * Order shares by values in the given field.
   *
   * @default created
   */
  order?: 'name' | 'created';
  /**
   * Direction to sort objects.
   *
   * @default asc
   */
  direction?: 'asc' | 'desc';
  /**
   * Page number.
   *
   * @example 2
   * @minimum 0
   * @multipleOf 1
   */
  page?: number;
  /**
   * Number of objects to return per page.
   *
   * @example 20
   * @maximum 100
   * @minimum 0
   * @multipleOf 1
   */
  per_page?: number;
};

export type OrganizationSharesListError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.ResourceSharingApiResponseCommonFailure;
    }
>;

export type OrganizationSharesListVariables = {
  pathParams: OrganizationSharesListPathParams;
  queryParams?: OrganizationSharesListQueryParams;
} & FetcherExtraProps;

/**
 * Lists all organization shares.
 */
export const organizationSharesList = (variables: OrganizationSharesListVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ResourceSharingShareResponseCollection,
    OrganizationSharesListError,
    undefined,
    {},
    OrganizationSharesListQueryParams,
    OrganizationSharesListPathParams
  >({ url: '/organizations/{organizationId}/shares', method: 'get', ...variables, signal });

export type RadarGetAiBotsSummaryByUserAgentQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAiBotsSummaryByUserAgentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAiBotsSummaryByUserAgentResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    /**
     * @example {"Amazonbot":"10.274394","Bytespider":"8.381743","facebookexternalhit":"63.40249"}
     */
    summary_0: {
      [key: string]: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAiBotsSummaryByUserAgentVariables = {
  queryParams?: RadarGetAiBotsSummaryByUserAgentQueryParams;
} & FetcherExtraProps;

/**
 * Percentage of Internet traffic generated by AI user agents, over a given time period.
 */
export const radarGetAiBotsSummaryByUserAgent = (
  variables: RadarGetAiBotsSummaryByUserAgentVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAiBotsSummaryByUserAgentResponse,
    RadarGetAiBotsSummaryByUserAgentError,
    undefined,
    {},
    RadarGetAiBotsSummaryByUserAgentQueryParams,
    {}
  >({ url: '/radar/ai/bots/summary/user_agent', method: 'get', ...variables, signal });

export type RadarGetAiBotsTimeseriesGroupByUserAgentQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAiBotsTimeseriesGroupByUserAgentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAiBotsTimeseriesGroupByUserAgentResponse = {
  result: {
    meta: Record<string, any>;
    /**
     * @example {"facebookexternalhit":["0.862022"],"timestamps":["2024-07-30T03:00:00Z"]}
     */
    serie_0: {
      timestamps: string[];
    } & {
      [key: string]: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAiBotsTimeseriesGroupByUserAgentVariables = {
  queryParams?: RadarGetAiBotsTimeseriesGroupByUserAgentQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of traffic per AI user agent over time.
 */
export const radarGetAiBotsTimeseriesGroupByUserAgent = (
  variables: RadarGetAiBotsTimeseriesGroupByUserAgentVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAiBotsTimeseriesGroupByUserAgentResponse,
    RadarGetAiBotsTimeseriesGroupByUserAgentError,
    undefined,
    {},
    RadarGetAiBotsTimeseriesGroupByUserAgentQueryParams,
    {}
  >({ url: '/radar/ai/bots/timeseries_groups/user_agent', method: 'get', ...variables, signal });

export type RadarGetAnnotationsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Number of objects to skip before grabbing results.
   */
  offset?: number;
  /**
   * Shorthand date ranges for the last X days - use when you don't need specific start and end dates.
   *
   * @example 7d
   * @pattern ^((([1-9]|[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-4])[d](control)?)|(([1-9]|[1-4][0-9]|5[0-2])[w](control)?))$
   */
  dateRange?: string;
  /**
   * Start of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   * @format date-time
   */
  dateStart?: string;
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   * @format date-time
   */
  dateEnd?: string;
  /**
   * Single ASN as integer.
   *
   * @example 174
   */
  asn?: number;
  /**
   * Location Alpha2 code.
   *
   * @example US
   */
  location?: string;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAnnotationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAnnotationsResponse = {
  result: {
    annotations: {
      asns: number[];
      asnsDetails: {
        /**
         * @example 189
         */
        asn: string;
        locations?: {
          /**
           * @example US
           */
          code: string;
          /**
           * @example United States
           */
          name: string;
        };
        /**
         * @example LUMEN-LEGACY-L3-PARTITION
         */
        name: string;
      }[];
      /**
       * @example ALL
       */
      dataSource: string;
      /**
       * @example example
       */
      description?: string;
      /**
       * @example 2022-09-08T10:00:28Z
       */
      endDate?: string;
      /**
       * @example OUTAGE
       */
      eventType: string;
      /**
       * @example 550
       */
      id: string;
      /**
       * @example http://example.com
       */
      linkedUrl?: string;
      locations: string[];
      locationsDetails: {
        /**
         * @example US
         */
        code: string;
        /**
         * @example United States
         */
        name: string;
      }[];
      outage: {
        /**
         * @example CABLE_CUT
         */
        outageCause: string;
        /**
         * @example NATIONWIDE
         */
        outageType: string;
      };
      /**
       * @example Colima, Michoacán, México
       */
      scope?: string;
      /**
       * @example 2022-09-06T10:00:28Z
       */
      startDate: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAnnotationsVariables = {
  queryParams?: RadarGetAnnotationsQueryParams;
} & FetcherExtraProps;

/**
 * Get the latest annotations.
 */
export const radarGetAnnotations = (variables: RadarGetAnnotationsVariables, signal?: AbortSignal) =>
  fetch<RadarGetAnnotationsResponse, RadarGetAnnotationsError, undefined, {}, RadarGetAnnotationsQueryParams, {}>({
    url: '/radar/annotations',
    method: 'get',
    ...variables,
    signal
  });

export type RadarGetAnnotationsOutagesQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Number of objects to skip before grabbing results.
   */
  offset?: number;
  /**
   * Shorthand date ranges for the last X days - use when you don't need specific start and end dates.
   *
   * @example 7d
   * @pattern ^((([1-9]|[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-4])[d](control)?)|(([1-9]|[1-4][0-9]|5[0-2])[w](control)?))$
   */
  dateRange?: string;
  /**
   * Start of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   * @format date-time
   */
  dateStart?: string;
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   * @format date-time
   */
  dateEnd?: string;
  /**
   * Single ASN as integer.
   *
   * @example 174
   */
  asn?: number;
  /**
   * Location Alpha2 code.
   *
   * @example US
   */
  location?: string;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAnnotationsOutagesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAnnotationsOutagesResponse = {
  result: {
    annotations: {
      asns: number[];
      asnsDetails: {
        /**
         * @example 189
         */
        asn: string;
        locations?: {
          /**
           * @example US
           */
          code: string;
          /**
           * @example United States
           */
          name: string;
        };
        /**
         * @example LUMEN-LEGACY-L3-PARTITION
         */
        name: string;
      }[];
      /**
       * @example ALL
       */
      dataSource: string;
      /**
       * @example example
       */
      description?: string;
      /**
       * @example 2022-09-08T10:00:28Z
       */
      endDate?: string;
      /**
       * @example OUTAGE
       */
      eventType: string;
      /**
       * @example 550
       */
      id: string;
      /**
       * @example http://example.com
       */
      linkedUrl?: string;
      locations: string[];
      locationsDetails: {
        /**
         * @example US
         */
        code: string;
        /**
         * @example United States
         */
        name: string;
      }[];
      outage: {
        /**
         * @example CABLE_CUT
         */
        outageCause: string;
        /**
         * @example NATIONWIDE
         */
        outageType: string;
      };
      /**
       * @example Colima, Michoacán, México
       */
      scope?: string;
      /**
       * @example 2022-09-06T10:00:28Z
       */
      startDate: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAnnotationsOutagesVariables = {
  queryParams?: RadarGetAnnotationsOutagesQueryParams;
} & FetcherExtraProps;

/**
 * Get latest Internet outages and anomalies.
 */
export const radarGetAnnotationsOutages = (variables: RadarGetAnnotationsOutagesVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetAnnotationsOutagesResponse,
    RadarGetAnnotationsOutagesError,
    undefined,
    {},
    RadarGetAnnotationsOutagesQueryParams,
    {}
  >({ url: '/radar/annotations/outages', method: 'get', ...variables, signal });

export type RadarGetAnnotationsOutagesTopQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Shorthand date ranges for the last X days - use when you don't need specific start and end dates.
   *
   * @example 7d
   * @pattern ^((([1-9]|[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-4])[d](control)?)|(([1-9]|[1-4][0-9]|5[0-2])[w](control)?))$
   */
  dateRange?: string;
  /**
   * Start of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   * @format date-time
   */
  dateStart?: string;
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   * @format date-time
   */
  dateEnd?: string;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAnnotationsOutagesTopError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAnnotationsOutagesTopResponse = {
  result: {
    annotations: {
      /**
       * @example PT
       */
      clientCountryAlpha2: string;
      /**
       * @example Portugal
       */
      clientCountryName: string;
      /**
       * @example 5
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAnnotationsOutagesTopVariables = {
  queryParams?: RadarGetAnnotationsOutagesTopQueryParams;
} & FetcherExtraProps;

/**
 * Get the number of outages by location.
 */
export const radarGetAnnotationsOutagesTop = (
  variables: RadarGetAnnotationsOutagesTopVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAnnotationsOutagesTopResponse,
    RadarGetAnnotationsOutagesTopError,
    undefined,
    {},
    RadarGetAnnotationsOutagesTopQueryParams,
    {}
  >({ url: '/radar/annotations/outages/locations', method: 'get', ...variables, signal });

export type RadarGetDnsAs112TimeseriesByDnssecQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsAs112TimeseriesByDnssecError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetDnsAs112TimeseriesByDnssecResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 16
       */
      NOT_SUPPORTED: string;
      /**
       * @example 84
       */
      SUPPORTED: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsAs112TimeseriesByDnssecVariables = {
  queryParams?: RadarGetDnsAs112TimeseriesByDnssecQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of DNS queries to AS112 by DNSSEC support.
 */
export const radarGetDnsAs112TimeseriesByDnssec = (
  variables: RadarGetDnsAs112TimeseriesByDnssecVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetDnsAs112TimeseriesByDnssecResponse,
    RadarGetDnsAs112TimeseriesByDnssecError,
    undefined,
    {},
    RadarGetDnsAs112TimeseriesByDnssecQueryParams,
    {}
  >({ url: '/radar/as112/summary/dnssec', method: 'get', ...variables, signal });

export type RadarGetDnsAs112TimeseriesByEdnsQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsAs112TimeseriesByEdnsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetDnsAs112TimeseriesByEdnsResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 6
       */
      NOT_SUPPORTED: string;
      /**
       * @example 94
       */
      SUPPORTED: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsAs112TimeseriesByEdnsVariables = {
  queryParams?: RadarGetDnsAs112TimeseriesByEdnsQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of DNS queries to AS112 by EDNS support.
 */
export const radarGetDnsAs112TimeseriesByEdns = (
  variables: RadarGetDnsAs112TimeseriesByEdnsVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetDnsAs112TimeseriesByEdnsResponse,
    RadarGetDnsAs112TimeseriesByEdnsError,
    undefined,
    {},
    RadarGetDnsAs112TimeseriesByEdnsQueryParams,
    {}
  >({ url: '/radar/as112/summary/edns', method: 'get', ...variables, signal });

export type RadarGetDnsAs112TimeseriesByIpVersionQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsAs112TimeseriesByIpVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetDnsAs112TimeseriesByIpVersionResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 80
       */
      IPv4: string;
      /**
       * @example 20
       */
      IPv6: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsAs112TimeseriesByIpVersionVariables = {
  queryParams?: RadarGetDnsAs112TimeseriesByIpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of DNS queries to AS112 per IP Version.
 */
export const radarGetDnsAs112TimeseriesByIpVersion = (
  variables: RadarGetDnsAs112TimeseriesByIpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetDnsAs112TimeseriesByIpVersionResponse,
    RadarGetDnsAs112TimeseriesByIpVersionError,
    undefined,
    {},
    RadarGetDnsAs112TimeseriesByIpVersionQueryParams,
    {}
  >({ url: '/radar/as112/summary/ip_version', method: 'get', ...variables, signal });

export type RadarGetDnsAs112TimeseriesByProtocolQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsAs112TimeseriesByProtocolError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetDnsAs112TimeseriesByProtocolResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 1
       */
      tcp: string;
      /**
       * @example 99
       */
      udp: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsAs112TimeseriesByProtocolVariables = {
  queryParams?: RadarGetDnsAs112TimeseriesByProtocolQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of DNS queries to AS112 per protocol.
 */
export const radarGetDnsAs112TimeseriesByProtocol = (
  variables: RadarGetDnsAs112TimeseriesByProtocolVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetDnsAs112TimeseriesByProtocolResponse,
    RadarGetDnsAs112TimeseriesByProtocolError,
    undefined,
    {},
    RadarGetDnsAs112TimeseriesByProtocolQueryParams,
    {}
  >({ url: '/radar/as112/summary/protocol', method: 'get', ...variables, signal });

export type RadarGetDnsAs112TimeseriesByQueryTypeQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsAs112TimeseriesByQueryTypeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetDnsAs112TimeseriesByQueryTypeResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    /**
     * @example {"A":"19","AAAA":"1","PTR":"74","SOA":"5","SRV":"1"}
     */
    summary_0: {
      [key: string]: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsAs112TimeseriesByQueryTypeVariables = {
  queryParams?: RadarGetDnsAs112TimeseriesByQueryTypeQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of DNS queries to AS112 by query type.
 */
export const radarGetDnsAs112TimeseriesByQueryType = (
  variables: RadarGetDnsAs112TimeseriesByQueryTypeVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetDnsAs112TimeseriesByQueryTypeResponse,
    RadarGetDnsAs112TimeseriesByQueryTypeError,
    undefined,
    {},
    RadarGetDnsAs112TimeseriesByQueryTypeQueryParams,
    {}
  >({ url: '/radar/as112/summary/query_type', method: 'get', ...variables, signal });

export type RadarGetDnsAs112TimeseriesByResponseCodesQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsAs112TimeseriesByResponseCodesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetDnsAs112TimeseriesByResponseCodesResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    /**
     * @example {"NOERROR":"70","NOTIMP":"5","NXDOMAIN":"10","REFUSED":"5","SERVFAIL":"5"}
     */
    summary_0: {
      [key: string]: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsAs112TimeseriesByResponseCodesVariables = {
  queryParams?: RadarGetDnsAs112TimeseriesByResponseCodesQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of AS112 DNS requests classified by response code.
 */
export const radarGetDnsAs112TimeseriesByResponseCodes = (
  variables: RadarGetDnsAs112TimeseriesByResponseCodesVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetDnsAs112TimeseriesByResponseCodesResponse,
    RadarGetDnsAs112TimeseriesByResponseCodesError,
    undefined,
    {},
    RadarGetDnsAs112TimeseriesByResponseCodesQueryParams,
    {}
  >({ url: '/radar/as112/summary/response_codes', method: 'get', ...variables, signal });

export type RadarGetDnsAs112TimeseriesQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsAs112TimeseriesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetDnsAs112TimeseriesResponse = {
  result: {
    meta: {
      /**
       * @example 1h
       */
      aggInterval: string;
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @format date-time
       */
      lastUpdated: string;
    };
    serie_0: {
      timestamps: string[];
      values: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsAs112TimeseriesVariables = {
  queryParams?: RadarGetDnsAs112TimeseriesQueryParams;
} & FetcherExtraProps;

/**
 * Get AS112 queries change over time.
 */
export const radarGetDnsAs112Timeseries = (variables: RadarGetDnsAs112TimeseriesVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetDnsAs112TimeseriesResponse,
    RadarGetDnsAs112TimeseriesError,
    undefined,
    {},
    RadarGetDnsAs112TimeseriesQueryParams,
    {}
  >({ url: '/radar/as112/timeseries', method: 'get', ...variables, signal });

export type RadarGetDnsAs112TimeseriesGroupByDnssecQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsAs112TimeseriesGroupByDnssecError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetDnsAs112TimeseriesGroupByDnssecResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      NOT_SUPPORTED: string[];
      SUPPORTED: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsAs112TimeseriesGroupByDnssecVariables = {
  queryParams?: RadarGetDnsAs112TimeseriesGroupByDnssecQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of AS112 DNS queries by DNSSEC support over time.
 */
export const radarGetDnsAs112TimeseriesGroupByDnssec = (
  variables: RadarGetDnsAs112TimeseriesGroupByDnssecVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetDnsAs112TimeseriesGroupByDnssecResponse,
    RadarGetDnsAs112TimeseriesGroupByDnssecError,
    undefined,
    {},
    RadarGetDnsAs112TimeseriesGroupByDnssecQueryParams,
    {}
  >({ url: '/radar/as112/timeseries_groups/dnssec', method: 'get', ...variables, signal });

export type RadarGetDnsAs112TimeseriesGroupByEdnsQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsAs112TimeseriesGroupByEdnsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetDnsAs112TimeseriesGroupByEdnsResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      NOT_SUPPORTED: string[];
      SUPPORTED: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsAs112TimeseriesGroupByEdnsVariables = {
  queryParams?: RadarGetDnsAs112TimeseriesGroupByEdnsQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of AS112 DNS queries by EDNS support over time.
 */
export const radarGetDnsAs112TimeseriesGroupByEdns = (
  variables: RadarGetDnsAs112TimeseriesGroupByEdnsVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetDnsAs112TimeseriesGroupByEdnsResponse,
    RadarGetDnsAs112TimeseriesGroupByEdnsError,
    undefined,
    {},
    RadarGetDnsAs112TimeseriesGroupByEdnsQueryParams,
    {}
  >({ url: '/radar/as112/timeseries_groups/edns', method: 'get', ...variables, signal });

export type RadarGetDnsAs112TimeseriesGroupByIpVersionQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsAs112TimeseriesGroupByIpVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetDnsAs112TimeseriesGroupByIpVersionResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      IPv4: string[];
      IPv6: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsAs112TimeseriesGroupByIpVersionVariables = {
  queryParams?: RadarGetDnsAs112TimeseriesGroupByIpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of AS112 DNS queries by IP version over time.
 */
export const radarGetDnsAs112TimeseriesGroupByIpVersion = (
  variables: RadarGetDnsAs112TimeseriesGroupByIpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetDnsAs112TimeseriesGroupByIpVersionResponse,
    RadarGetDnsAs112TimeseriesGroupByIpVersionError,
    undefined,
    {},
    RadarGetDnsAs112TimeseriesGroupByIpVersionQueryParams,
    {}
  >({ url: '/radar/as112/timeseries_groups/ip_version', method: 'get', ...variables, signal });

export type RadarGetDnsAs112TimeseriesGroupByProtocolQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsAs112TimeseriesGroupByProtocolError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetDnsAs112TimeseriesGroupByProtocolResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      tcp: string[];
      udp: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsAs112TimeseriesGroupByProtocolVariables = {
  queryParams?: RadarGetDnsAs112TimeseriesGroupByProtocolQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of AS112 DNS requests classified by protocol over time.
 */
export const radarGetDnsAs112TimeseriesGroupByProtocol = (
  variables: RadarGetDnsAs112TimeseriesGroupByProtocolVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetDnsAs112TimeseriesGroupByProtocolResponse,
    RadarGetDnsAs112TimeseriesGroupByProtocolError,
    undefined,
    {},
    RadarGetDnsAs112TimeseriesGroupByProtocolQueryParams,
    {}
  >({ url: '/radar/as112/timeseries_groups/protocol', method: 'get', ...variables, signal });

export type RadarGetDnsAs112TimeseriesGroupByQueryTypeQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsAs112TimeseriesGroupByQueryTypeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetDnsAs112TimeseriesGroupByQueryTypeResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      A: string[];
      AAAA: string[];
      PTR: string[];
      SOA: string[];
      SRV: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsAs112TimeseriesGroupByQueryTypeVariables = {
  queryParams?: RadarGetDnsAs112TimeseriesGroupByQueryTypeQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of AS112 DNS queries by query type over time.
 */
export const radarGetDnsAs112TimeseriesGroupByQueryType = (
  variables: RadarGetDnsAs112TimeseriesGroupByQueryTypeVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetDnsAs112TimeseriesGroupByQueryTypeResponse,
    RadarGetDnsAs112TimeseriesGroupByQueryTypeError,
    undefined,
    {},
    RadarGetDnsAs112TimeseriesGroupByQueryTypeQueryParams,
    {}
  >({ url: '/radar/as112/timeseries_groups/query_type', method: 'get', ...variables, signal });

export type RadarGetDnsAs112TimeseriesGroupByResponseCodesQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsAs112TimeseriesGroupByResponseCodesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetDnsAs112TimeseriesGroupByResponseCodesResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      NOERROR: string[];
      NXDOMAIN: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsAs112TimeseriesGroupByResponseCodesVariables = {
  queryParams?: RadarGetDnsAs112TimeseriesGroupByResponseCodesQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of AS112 DNS requests classified by response code over time.
 */
export const radarGetDnsAs112TimeseriesGroupByResponseCodes = (
  variables: RadarGetDnsAs112TimeseriesGroupByResponseCodesVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetDnsAs112TimeseriesGroupByResponseCodesResponse,
    RadarGetDnsAs112TimeseriesGroupByResponseCodesError,
    undefined,
    {},
    RadarGetDnsAs112TimeseriesGroupByResponseCodesQueryParams,
    {}
  >({ url: '/radar/as112/timeseries_groups/response_codes', method: 'get', ...variables, signal });

export type RadarGetDnsAs112TopLocationsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsAs112TopLocationsError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetDnsAs112TopLocationsResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example US
       */
      clientCountryAlpha2: string;
      /**
       * @example United States
       */
      clientCountryName: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsAs112TopLocationsVariables = {
  queryParams?: RadarGetDnsAs112TopLocationsQueryParams;
} & FetcherExtraProps;

/**
 * Get the top locations by AS112 DNS queries. Values are a percentage out of the total queries.
 */
export const radarGetDnsAs112TopLocations = (variables: RadarGetDnsAs112TopLocationsVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetDnsAs112TopLocationsResponse,
    RadarGetDnsAs112TopLocationsError,
    undefined,
    {},
    RadarGetDnsAs112TopLocationsQueryParams,
    {}
  >({ url: '/radar/as112/top/locations', method: 'get', ...variables, signal });

export type RadarGetDnsAs112TopLocationsByDnssecPathParams = {
  /**
   * DNSSEC.
   *
   * @example SUPPORTED
   */
  dnssec: 'SUPPORTED' | 'NOT_SUPPORTED';
};

export type RadarGetDnsAs112TopLocationsByDnssecQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsAs112TopLocationsByDnssecError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetDnsAs112TopLocationsByDnssecResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example US
       */
      clientCountryAlpha2: string;
      /**
       * @example United States
       */
      clientCountryName: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsAs112TopLocationsByDnssecVariables = {
  pathParams: RadarGetDnsAs112TopLocationsByDnssecPathParams;
  queryParams?: RadarGetDnsAs112TopLocationsByDnssecQueryParams;
} & FetcherExtraProps;

/**
 * Get the top locations of DNS queries to AS112 with DNSSEC.
 */
export const radarGetDnsAs112TopLocationsByDnssec = (
  variables: RadarGetDnsAs112TopLocationsByDnssecVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetDnsAs112TopLocationsByDnssecResponse,
    RadarGetDnsAs112TopLocationsByDnssecError,
    undefined,
    {},
    RadarGetDnsAs112TopLocationsByDnssecQueryParams,
    RadarGetDnsAs112TopLocationsByDnssecPathParams
  >({ url: '/radar/as112/top/locations/dnssec/{dnssec}', method: 'get', ...variables, signal });

export type RadarGetDnsAs112TopLocationsByEdnsPathParams = {
  /**
   * EDNS.
   *
   * @example SUPPORTED
   */
  edns: 'SUPPORTED' | 'NOT_SUPPORTED';
};

export type RadarGetDnsAs112TopLocationsByEdnsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsAs112TopLocationsByEdnsError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetDnsAs112TopLocationsByEdnsResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example US
       */
      clientCountryAlpha2: string;
      /**
       * @example United States
       */
      clientCountryName: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsAs112TopLocationsByEdnsVariables = {
  pathParams: RadarGetDnsAs112TopLocationsByEdnsPathParams;
  queryParams?: RadarGetDnsAs112TopLocationsByEdnsQueryParams;
} & FetcherExtraProps;

/**
 * Get the top locations of DNS queries to AS112 with EDNS support.
 */
export const radarGetDnsAs112TopLocationsByEdns = (
  variables: RadarGetDnsAs112TopLocationsByEdnsVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetDnsAs112TopLocationsByEdnsResponse,
    RadarGetDnsAs112TopLocationsByEdnsError,
    undefined,
    {},
    RadarGetDnsAs112TopLocationsByEdnsQueryParams,
    RadarGetDnsAs112TopLocationsByEdnsPathParams
  >({ url: '/radar/as112/top/locations/edns/{edns}', method: 'get', ...variables, signal });

export type RadarGetDnsAs112TopLocationsByIpVersionPathParams = {
  /**
   * IP Version.
   *
   * @example IPv4
   */
  ipVersion: 'IPv4' | 'IPv6';
};

export type RadarGetDnsAs112TopLocationsByIpVersionQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsAs112TopLocationsByIpVersionError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetDnsAs112TopLocationsByIpVersionResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example US
       */
      clientCountryAlpha2: string;
      /**
       * @example United States
       */
      clientCountryName: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsAs112TopLocationsByIpVersionVariables = {
  pathParams: RadarGetDnsAs112TopLocationsByIpVersionPathParams;
  queryParams?: RadarGetDnsAs112TopLocationsByIpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Get the top locations of DNS queries to AS112 by IP version.
 */
export const radarGetDnsAs112TopLocationsByIpVersion = (
  variables: RadarGetDnsAs112TopLocationsByIpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetDnsAs112TopLocationsByIpVersionResponse,
    RadarGetDnsAs112TopLocationsByIpVersionError,
    undefined,
    {},
    RadarGetDnsAs112TopLocationsByIpVersionQueryParams,
    RadarGetDnsAs112TopLocationsByIpVersionPathParams
  >({ url: '/radar/as112/top/locations/ip_version/{ipVersion}', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3SummaryQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3SummaryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer3SummaryResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
    };
    summary_0: {
      /**
       * @example 0.9
       */
      gre: string;
      /**
       * @example 0.1
       */
      icmp: string;
      /**
       * @example 60
       */
      tcp: string;
      /**
       * @example 39
       */
      udp: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3SummaryVariables = {
  queryParams?: RadarGetAttacksLayer3SummaryQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of network protocols in Layer 3/4 attacks over a given time period.
 */
export const radarGetAttacksLayer3Summary = (variables: RadarGetAttacksLayer3SummaryVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetAttacksLayer3SummaryResponse,
    RadarGetAttacksLayer3SummaryError,
    undefined,
    {},
    RadarGetAttacksLayer3SummaryQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/summary', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3SummaryByBitrateQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Array of L3/4 attack types.
   */
  protocol?: ('UDP' | 'TCP' | 'ICMP' | 'GRE')[];
  /**
   * Together with the `location` parameter, will apply the filter to origin or target location.
   *
   * @default ORIGIN
   */
  direction?: 'ORIGIN' | 'TARGET';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3SummaryByBitrateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer3SummaryByBitrateResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 13.141944
       */
      OVER_100_GBPS: string;
      /**
       * @example 74.891763
       */
      UNDER_500_MBPS: string;
      /**
       * @example 0.01056
       */
      _10_GBPS_TO_100_GBPS: string;
      /**
       * @example 6.007082
       */
      _1_GBPS_TO_10_GBPS: string;
      /**
       * @example 5.948652
       */
      _500_MBPS_TO_1_GBPS: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3SummaryByBitrateVariables = {
  queryParams?: RadarGetAttacksLayer3SummaryByBitrateQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by bitrate.
 */
export const radarGetAttacksLayer3SummaryByBitrate = (
  variables: RadarGetAttacksLayer3SummaryByBitrateVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3SummaryByBitrateResponse,
    RadarGetAttacksLayer3SummaryByBitrateError,
    undefined,
    {},
    RadarGetAttacksLayer3SummaryByBitrateQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/summary/bitrate', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3SummaryByDurationQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Array of L3/4 attack types.
   */
  protocol?: ('UDP' | 'TCP' | 'ICMP' | 'GRE')[];
  /**
   * Together with the `location` parameter, will apply the filter to origin or target location.
   *
   * @default ORIGIN
   */
  direction?: 'ORIGIN' | 'TARGET';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3SummaryByDurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer3SummaryByDurationResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 4.462923
       */
      OVER_3_HOURS: string;
      /**
       * @example 76.243322
       */
      UNDER_10_MINS: string;
      /**
       * @example 9.48709
       */
      _10_MINS_TO_20_MINS: string;
      /**
       * @example 4.038413
       */
      _1_HOUR_TO_3_HOURS: string;
      /**
       * @example 3.87624
       */
      _20_MINS_TO_40_MINS: string;
      /**
       * @example 1.892012
       */
      _40_MINS_TO_1_HOUR: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3SummaryByDurationVariables = {
  queryParams?: RadarGetAttacksLayer3SummaryByDurationQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by duration.
 */
export const radarGetAttacksLayer3SummaryByDuration = (
  variables: RadarGetAttacksLayer3SummaryByDurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3SummaryByDurationResponse,
    RadarGetAttacksLayer3SummaryByDurationError,
    undefined,
    {},
    RadarGetAttacksLayer3SummaryByDurationQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/summary/duration', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3SummaryByIpVersionQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Array of L3/4 attack types.
   */
  protocol?: ('UDP' | 'TCP' | 'ICMP' | 'GRE')[];
  /**
   * Together with the `location` parameter, will apply the filter to origin or target location.
   *
   * @default ORIGIN
   */
  direction?: 'ORIGIN' | 'TARGET';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3SummaryByIpVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer3SummaryByIpVersionResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 99.984766
       */
      IPv4: string;
      /**
       * @example 0.015234
       */
      IPv6: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3SummaryByIpVersionVariables = {
  queryParams?: RadarGetAttacksLayer3SummaryByIpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by ip version used.
 */
export const radarGetAttacksLayer3SummaryByIpVersion = (
  variables: RadarGetAttacksLayer3SummaryByIpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3SummaryByIpVersionResponse,
    RadarGetAttacksLayer3SummaryByIpVersionError,
    undefined,
    {},
    RadarGetAttacksLayer3SummaryByIpVersionQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/summary/ip_version', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3SummaryByProtocolQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Together with the `location` parameter, will apply the filter to origin or target location.
   *
   * @default ORIGIN
   */
  direction?: 'ORIGIN' | 'TARGET';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3SummaryByProtocolError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer3SummaryByProtocolResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 0.756379
       */
      GRE: string;
      /**
       * @example 0.015245
       */
      ICMP: string;
      /**
       * @example 82.89908
       */
      TCP: string;
      /**
       * @example 16.328986
       */
      UDP: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3SummaryByProtocolVariables = {
  queryParams?: RadarGetAttacksLayer3SummaryByProtocolQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by protocol used.
 */
export const radarGetAttacksLayer3SummaryByProtocol = (
  variables: RadarGetAttacksLayer3SummaryByProtocolVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3SummaryByProtocolResponse,
    RadarGetAttacksLayer3SummaryByProtocolError,
    undefined,
    {},
    RadarGetAttacksLayer3SummaryByProtocolQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/summary/protocol', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3SummaryByVectorQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Array of L3/4 attack types.
   */
  protocol?: ('UDP' | 'TCP' | 'ICMP' | 'GRE')[];
  /**
   * Together with the `location` parameter, will apply the filter to origin or target location.
   *
   * @default ORIGIN
   */
  direction?: 'ORIGIN' | 'TARGET';
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3SummaryByVectorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer3SummaryByVectorResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    /**
     * @example {"ACK Flood":"65.662148","SYN Flood":"16.86401"}
     */
    summary_0: {
      [key: string]: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3SummaryByVectorVariables = {
  queryParams?: RadarGetAttacksLayer3SummaryByVectorQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by vector.
 */
export const radarGetAttacksLayer3SummaryByVector = (
  variables: RadarGetAttacksLayer3SummaryByVectorVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3SummaryByVectorResponse,
    RadarGetAttacksLayer3SummaryByVectorError,
    undefined,
    {},
    RadarGetAttacksLayer3SummaryByVectorQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/summary/vector', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3TimeseriesByBytesQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Array of L3/4 attack types.
   */
  protocol?: ('UDP' | 'TCP' | 'ICMP' | 'GRE')[];
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @example MIN0_MAX
   */
  normalization?: 'PERCENTAGE_CHANGE' | 'MIN0_MAX';
  /**
   * Measurement units, eg. bytes.
   *
   * @default bytes
   */
  metric?: 'BYTES' | 'BYTES_OLD';
  /**
   * Together with the `location` parameter, will apply the filter to origin or target location.
   *
   * @default ORIGIN
   */
  direction?: 'ORIGIN' | 'TARGET';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3TimeseriesByBytesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer3TimeseriesByBytesResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      timestamps: string[];
      values: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3TimeseriesByBytesVariables = {
  queryParams?: RadarGetAttacksLayer3TimeseriesByBytesQueryParams;
} & FetcherExtraProps;

/**
 * Get attacks change over time by bytes.
 */
export const radarGetAttacksLayer3TimeseriesByBytes = (
  variables: RadarGetAttacksLayer3TimeseriesByBytesVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3TimeseriesByBytesResponse,
    RadarGetAttacksLayer3TimeseriesByBytesError,
    undefined,
    {},
    RadarGetAttacksLayer3TimeseriesByBytesQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/timeseries', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3TimeseriesGroupsQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3TimeseriesGroupsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer3TimeseriesGroupsResponse = {
  result: {
    meta: {
      /**
       * @example 1h
       */
      aggInterval: string;
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @format date-time
       */
      lastUpdated: string;
    };
    serie_0: {
      gre: string[];
      icmp: string[];
      tcp: string[];
      timestamps: string[];
      udp: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3TimeseriesGroupsVariables = {
  queryParams?: RadarGetAttacksLayer3TimeseriesGroupsQueryParams;
} & FetcherExtraProps;

/**
 * Get a time series of the percentage distribution of network protocols in Layer 3/4 attacks.
 */
export const radarGetAttacksLayer3TimeseriesGroups = (
  variables: RadarGetAttacksLayer3TimeseriesGroupsVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3TimeseriesGroupsResponse,
    RadarGetAttacksLayer3TimeseriesGroupsError,
    undefined,
    {},
    RadarGetAttacksLayer3TimeseriesGroupsQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/timeseries_groups', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3TimeseriesGroupByBitrateQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Array of L3/4 attack types.
   */
  protocol?: ('UDP' | 'TCP' | 'ICMP' | 'GRE')[];
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @default PERCENTAGE
   * @example PERCENTAGE
   */
  normalization?: 'PERCENTAGE' | 'MIN0_MAX';
  /**
   * Together with the `location` parameter, will apply the filter to origin or target location.
   *
   * @default ORIGIN
   */
  direction?: 'ORIGIN' | 'TARGET';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3TimeseriesGroupByBitrateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer3TimeseriesGroupByBitrateResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      OVER_100_GBPS: string[];
      UNDER_500_MBPS: string[];
      _10_GBPS_TO_100_GBPS: string[];
      _1_GBPS_TO_10_GBPS: string[];
      _500_MBPS_TO_1_GBPS: string[];
      timestamps: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3TimeseriesGroupByBitrateVariables = {
  queryParams?: RadarGetAttacksLayer3TimeseriesGroupByBitrateQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by bitrate over time.
 */
export const radarGetAttacksLayer3TimeseriesGroupByBitrate = (
  variables: RadarGetAttacksLayer3TimeseriesGroupByBitrateVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3TimeseriesGroupByBitrateResponse,
    RadarGetAttacksLayer3TimeseriesGroupByBitrateError,
    undefined,
    {},
    RadarGetAttacksLayer3TimeseriesGroupByBitrateQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/timeseries_groups/bitrate', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3TimeseriesGroupByDurationQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Array of L3/4 attack types.
   */
  protocol?: ('UDP' | 'TCP' | 'ICMP' | 'GRE')[];
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @default PERCENTAGE
   * @example PERCENTAGE
   */
  normalization?: 'PERCENTAGE' | 'MIN0_MAX';
  /**
   * Together with the `location` parameter, will apply the filter to origin or target location.
   *
   * @default ORIGIN
   */
  direction?: 'ORIGIN' | 'TARGET';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3TimeseriesGroupByDurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer3TimeseriesGroupByDurationResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      OVER_3_HOURS: string[];
      UNDER_10_MINS: string[];
      _10_MINS_TO_20_MINS: string[];
      _1_HOUR_TO_3_HOURS: string[];
      _20_MINS_TO_40_MINS: string[];
      _40_MINS_TO_1_HOUR: string[];
      timestamps: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3TimeseriesGroupByDurationVariables = {
  queryParams?: RadarGetAttacksLayer3TimeseriesGroupByDurationQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by duration over time.
 */
export const radarGetAttacksLayer3TimeseriesGroupByDuration = (
  variables: RadarGetAttacksLayer3TimeseriesGroupByDurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3TimeseriesGroupByDurationResponse,
    RadarGetAttacksLayer3TimeseriesGroupByDurationError,
    undefined,
    {},
    RadarGetAttacksLayer3TimeseriesGroupByDurationQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/timeseries_groups/duration', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3TimeseriesGroupByIndustryQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Array of L3/4 attack types.
   */
  protocol?: ('UDP' | 'TCP' | 'ICMP' | 'GRE')[];
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @default PERCENTAGE
   * @example PERCENTAGE
   */
  normalization?: 'PERCENTAGE' | 'MIN0_MAX';
  /**
   * Together with the `location` parameter, will apply the filter to origin or target location.
   *
   * @default ORIGIN
   */
  direction?: 'ORIGIN' | 'TARGET';
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3TimeseriesGroupByIndustryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer3TimeseriesGroupByIndustryResponse = {
  result: {
    meta: Record<string, any>;
    /**
     * @example {"Internet":["5.519081"],"timestamps":["2023-08-08T10:15:00Z"]}
     */
    serie_0: {
      timestamps: string[];
    } & {
      [key: string]: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3TimeseriesGroupByIndustryVariables = {
  queryParams?: RadarGetAttacksLayer3TimeseriesGroupByIndustryQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by industry targeted over time.
 */
export const radarGetAttacksLayer3TimeseriesGroupByIndustry = (
  variables: RadarGetAttacksLayer3TimeseriesGroupByIndustryVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3TimeseriesGroupByIndustryResponse,
    RadarGetAttacksLayer3TimeseriesGroupByIndustryError,
    undefined,
    {},
    RadarGetAttacksLayer3TimeseriesGroupByIndustryQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/timeseries_groups/industry', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3TimeseriesGroupByIpVersionQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Array of L3/4 attack types.
   */
  protocol?: ('UDP' | 'TCP' | 'ICMP' | 'GRE')[];
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @default PERCENTAGE
   * @example PERCENTAGE
   */
  normalization?: 'PERCENTAGE' | 'MIN0_MAX';
  /**
   * Together with the `location` parameter, will apply the filter to origin or target location.
   *
   * @default ORIGIN
   */
  direction?: 'ORIGIN' | 'TARGET';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3TimeseriesGroupByIpVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer3TimeseriesGroupByIpVersionResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      IPv4: string[];
      IPv6: string[];
      timestamps: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3TimeseriesGroupByIpVersionVariables = {
  queryParams?: RadarGetAttacksLayer3TimeseriesGroupByIpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by ip version used over time.
 */
export const radarGetAttacksLayer3TimeseriesGroupByIpVersion = (
  variables: RadarGetAttacksLayer3TimeseriesGroupByIpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3TimeseriesGroupByIpVersionResponse,
    RadarGetAttacksLayer3TimeseriesGroupByIpVersionError,
    undefined,
    {},
    RadarGetAttacksLayer3TimeseriesGroupByIpVersionQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/timeseries_groups/ip_version', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3TimeseriesGroupByProtocolQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @default PERCENTAGE
   * @example PERCENTAGE
   */
  normalization?: 'PERCENTAGE' | 'MIN0_MAX';
  /**
   * Together with the `location` parameter, will apply the filter to origin or target location.
   *
   * @default ORIGIN
   */
  direction?: 'ORIGIN' | 'TARGET';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3TimeseriesGroupByProtocolError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer3TimeseriesGroupByProtocolResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      GRE: string[];
      ICMP: string[];
      TCP: string[];
      UDP: string[];
      timestamps: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3TimeseriesGroupByProtocolVariables = {
  queryParams?: RadarGetAttacksLayer3TimeseriesGroupByProtocolQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by protocol used over time.
 */
export const radarGetAttacksLayer3TimeseriesGroupByProtocol = (
  variables: RadarGetAttacksLayer3TimeseriesGroupByProtocolVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3TimeseriesGroupByProtocolResponse,
    RadarGetAttacksLayer3TimeseriesGroupByProtocolError,
    undefined,
    {},
    RadarGetAttacksLayer3TimeseriesGroupByProtocolQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/timeseries_groups/protocol', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3TimeseriesGroupByVectorQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Array of L3/4 attack types.
   */
  protocol?: ('UDP' | 'TCP' | 'ICMP' | 'GRE')[];
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @default PERCENTAGE
   * @example PERCENTAGE
   */
  normalization?: 'PERCENTAGE' | 'MIN0_MAX';
  /**
   * Together with the `location` parameter, will apply the filter to origin or target location.
   *
   * @default ORIGIN
   */
  direction?: 'ORIGIN' | 'TARGET';
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3TimeseriesGroupByVectorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer3TimeseriesGroupByVectorResponse = {
  result: {
    meta: Record<string, any>;
    /**
     * @example {"ACK Flood":["97.28898"],"timestamps":["2023-08-08T10:15:00Z"]}
     */
    serie_0: {
      timestamps: string[];
    } & {
      [key: string]: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3TimeseriesGroupByVectorVariables = {
  queryParams?: RadarGetAttacksLayer3TimeseriesGroupByVectorQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by vector used over time.
 */
export const radarGetAttacksLayer3TimeseriesGroupByVector = (
  variables: RadarGetAttacksLayer3TimeseriesGroupByVectorVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3TimeseriesGroupByVectorResponse,
    RadarGetAttacksLayer3TimeseriesGroupByVectorError,
    undefined,
    {},
    RadarGetAttacksLayer3TimeseriesGroupByVectorQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/timeseries_groups/vector', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3TimeseriesGroupByVerticalQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Array of L3/4 attack types.
   */
  protocol?: ('UDP' | 'TCP' | 'ICMP' | 'GRE')[];
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @default PERCENTAGE
   * @example PERCENTAGE
   */
  normalization?: 'PERCENTAGE' | 'MIN0_MAX';
  /**
   * Together with the `location` parameter, will apply the filter to origin or target location.
   *
   * @default ORIGIN
   */
  direction?: 'ORIGIN' | 'TARGET';
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3TimeseriesGroupByVerticalError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer3TimeseriesGroupByVerticalResponse = {
  result: {
    meta: Record<string, any>;
    /**
     * @example {"Internet and Telecom":["5.519081"],"timestamps":["2023-08-08T10:15:00Z"]}
     */
    serie_0: {
      timestamps: string[];
    } & {
      [key: string]: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3TimeseriesGroupByVerticalVariables = {
  queryParams?: RadarGetAttacksLayer3TimeseriesGroupByVerticalQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by vertical targeted over time.
 */
export const radarGetAttacksLayer3TimeseriesGroupByVertical = (
  variables: RadarGetAttacksLayer3TimeseriesGroupByVerticalVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3TimeseriesGroupByVerticalResponse,
    RadarGetAttacksLayer3TimeseriesGroupByVerticalError,
    undefined,
    {},
    RadarGetAttacksLayer3TimeseriesGroupByVerticalQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/timeseries_groups/vertical', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3TopAttacksQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Array of L3/4 attack types.
   */
  protocol?: ('UDP' | 'TCP' | 'ICMP' | 'GRE')[];
  /**
   * Array of attack origin/target location attack limits. Together with `limitPerLocation`, limits how many objects will be fetched per origin/target location.
   *
   * @default ORIGIN
   * @example ORIGIN
   */
  limitDirection?: 'ORIGIN' | 'TARGET';
  /**
   * Limit the number of attacks per origin/target (refer to `limitDirection` parameter) location.
   *
   * @example 10
   */
  limitPerLocation?: number;
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @default PERCENTAGE
   * @example PERCENTAGE
   */
  normalization?: 'PERCENTAGE' | 'MIN_MAX';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3TopAttacksError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetAttacksLayer3TopAttacksResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example FR
       */
      originCountryAlpha2: string;
      /**
       * @example France
       */
      originCountryName: string;
      /**
       * @example 4.323214
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3TopAttacksVariables = {
  queryParams?: RadarGetAttacksLayer3TopAttacksQueryParams;
} & FetcherExtraProps;

/**
 * Get the top attacks from origin to target location. Values are a percentage out of the total layer 3 attacks (with billing country). You can optionally limit the number of attacks per origin/target location (useful if all the top attacks are from or to the same location).
 */
export const radarGetAttacksLayer3TopAttacks = (
  variables: RadarGetAttacksLayer3TopAttacksVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3TopAttacksResponse,
    RadarGetAttacksLayer3TopAttacksError,
    undefined,
    {},
    RadarGetAttacksLayer3TopAttacksQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/top/attacks', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3TopIndustriesQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Array of L3/4 attack types.
   */
  protocol?: ('UDP' | 'TCP' | 'ICMP' | 'GRE')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3TopIndustriesError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetAttacksLayer3TopIndustriesResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example Computer Software
       */
      name: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3TopIndustriesVariables = {
  queryParams?: RadarGetAttacksLayer3TopIndustriesQueryParams;
} & FetcherExtraProps;

/**
 * Get the industries targeted by attacks.
 */
export const radarGetAttacksLayer3TopIndustries = (
  variables: RadarGetAttacksLayer3TopIndustriesVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3TopIndustriesResponse,
    RadarGetAttacksLayer3TopIndustriesError,
    undefined,
    {},
    RadarGetAttacksLayer3TopIndustriesQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/top/industry', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3TopOriginLocationsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Array of L3/4 attack types.
   */
  protocol?: ('UDP' | 'TCP' | 'ICMP' | 'GRE')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3TopOriginLocationsError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetAttacksLayer3TopOriginLocationsResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example FR
       */
      originCountryAlpha2: string;
      /**
       * @example France
       */
      originCountryName: string;
      /**
       * @example 1
       */
      rank: number;
      /**
       * @example 4.323214
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3TopOriginLocationsVariables = {
  queryParams?: RadarGetAttacksLayer3TopOriginLocationsQueryParams;
} & FetcherExtraProps;

/**
 * Get the origin locations of attacks.
 */
export const radarGetAttacksLayer3TopOriginLocations = (
  variables: RadarGetAttacksLayer3TopOriginLocationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3TopOriginLocationsResponse,
    RadarGetAttacksLayer3TopOriginLocationsError,
    undefined,
    {},
    RadarGetAttacksLayer3TopOriginLocationsQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/top/locations/origin', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3TopTargetLocationsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Array of L3/4 attack types.
   */
  protocol?: ('UDP' | 'TCP' | 'ICMP' | 'GRE')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3TopTargetLocationsError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetAttacksLayer3TopTargetLocationsResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example 1
       */
      rank: number;
      /**
       * @example FR
       */
      targetCountryAlpha2: string;
      /**
       * @example France
       */
      targetCountryName: string;
      /**
       * @example 4.323214
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3TopTargetLocationsVariables = {
  queryParams?: RadarGetAttacksLayer3TopTargetLocationsQueryParams;
} & FetcherExtraProps;

/**
 * Get the target locations of attacks.
 */
export const radarGetAttacksLayer3TopTargetLocations = (
  variables: RadarGetAttacksLayer3TopTargetLocationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3TopTargetLocationsResponse,
    RadarGetAttacksLayer3TopTargetLocationsError,
    undefined,
    {},
    RadarGetAttacksLayer3TopTargetLocationsQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/top/locations/target', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer3TopVerticalsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Array of L3/4 attack types.
   */
  protocol?: ('UDP' | 'TCP' | 'ICMP' | 'GRE')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer3TopVerticalsError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetAttacksLayer3TopVerticalsResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example Internet and Telecom
       */
      name: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer3TopVerticalsVariables = {
  queryParams?: RadarGetAttacksLayer3TopVerticalsQueryParams;
} & FetcherExtraProps;

/**
 * Get the verticals targeted by attacks.
 */
export const radarGetAttacksLayer3TopVerticals = (
  variables: RadarGetAttacksLayer3TopVerticalsVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer3TopVerticalsResponse,
    RadarGetAttacksLayer3TopVerticalsError,
    undefined,
    {},
    RadarGetAttacksLayer3TopVerticalsQueryParams,
    {}
  >({ url: '/radar/attacks/layer3/top/vertical', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7SummaryQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7SummaryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer7SummaryResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
    };
    summary_0: {
      /**
       * @example 0.9
       */
      ACCESS_RULES: string;
      /**
       * @example 0.9
       */
      API_SHIELD: string;
      /**
       * @example 0.9
       */
      BOT_MANAGEMENT: string;
      /**
       * @example 0.9
       */
      DATA_LOSS_PREVENTION: string;
      /**
       * @example 34
       */
      DDOS: string;
      /**
       * @example 0.1
       */
      IP_REPUTATION: string;
      /**
       * @example 65
       */
      WAF: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7SummaryVariables = {
  queryParams?: RadarGetAttacksLayer7SummaryQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of mitigation techniques in Layer 7 attacks.
 */
export const radarGetAttacksLayer7Summary = (variables: RadarGetAttacksLayer7SummaryVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetAttacksLayer7SummaryResponse,
    RadarGetAttacksLayer7SummaryError,
    undefined,
    {},
    RadarGetAttacksLayer7SummaryQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/summary', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7SummaryByHttpMethodQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Array of L7 mitigation products.
   */
  mitigationProduct?: (
    | 'DDOS'
    | 'WAF'
    | 'BOT_MANAGEMENT'
    | 'ACCESS_RULES'
    | 'IP_REPUTATION'
    | 'API_SHIELD'
    | 'DATA_LOSS_PREVENTION'
  )[];
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7SummaryByHttpMethodError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer7SummaryByHttpMethodResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    /**
     * @example {"GET":"99.100257","POST":"0.899743"}
     */
    summary_0: {
      [key: string]: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7SummaryByHttpMethodVariables = {
  queryParams?: RadarGetAttacksLayer7SummaryByHttpMethodQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by http method used.
 */
export const radarGetAttacksLayer7SummaryByHttpMethod = (
  variables: RadarGetAttacksLayer7SummaryByHttpMethodVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7SummaryByHttpMethodResponse,
    RadarGetAttacksLayer7SummaryByHttpMethodError,
    undefined,
    {},
    RadarGetAttacksLayer7SummaryByHttpMethodQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/summary/http_method', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7SummaryByHttpVersionQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for http method.
   *
   * @example GET
   */
  httpMethod?: (
    | 'GET'
    | 'POST'
    | 'DELETE'
    | 'PUT'
    | 'HEAD'
    | 'PURGE'
    | 'OPTIONS'
    | 'PROPFIND'
    | 'MKCOL'
    | 'PATCH'
    | 'ACL'
    | 'BCOPY'
    | 'BDELETE'
    | 'BMOVE'
    | 'BPROPFIND'
    | 'BPROPPATCH'
    | 'CHECKIN'
    | 'CHECKOUT'
    | 'CONNECT'
    | 'COPY'
    | 'LABEL'
    | 'LOCK'
    | 'MERGE'
    | 'MKACTIVITY'
    | 'MKWORKSPACE'
    | 'MOVE'
    | 'NOTIFY'
    | 'ORDERPATCH'
    | 'POLL'
    | 'PROPPATCH'
    | 'REPORT'
    | 'SEARCH'
    | 'SUBSCRIBE'
    | 'TRACE'
    | 'UNCHECKOUT'
    | 'UNLOCK'
    | 'UNSUBSCRIBE'
    | 'UPDATE'
    | 'VERSIONCONTROL'
    | 'BASELINECONTROL'
    | 'XMSENUMATTS'
    | 'RPC_OUT_DATA'
    | 'RPC_IN_DATA'
    | 'JSON'
    | 'COOK'
    | 'TRACK'
  )[];
  /**
   * Array of L7 mitigation products.
   */
  mitigationProduct?: (
    | 'DDOS'
    | 'WAF'
    | 'BOT_MANAGEMENT'
    | 'ACCESS_RULES'
    | 'IP_REPUTATION'
    | 'API_SHIELD'
    | 'DATA_LOSS_PREVENTION'
  )[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7SummaryByHttpVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer7SummaryByHttpVersionResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    /**
     * @example {"HTTP/1.x":"21.722365","HTTP/2":"77.056555","HTTP/3":"1.22108"}
     */
    summary_0: {
      ['HTTP/1.x']: string;
      ['HTTP/2']: string;
      ['HTTP/3']: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7SummaryByHttpVersionVariables = {
  queryParams?: RadarGetAttacksLayer7SummaryByHttpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by http version used.
 */
export const radarGetAttacksLayer7SummaryByHttpVersion = (
  variables: RadarGetAttacksLayer7SummaryByHttpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7SummaryByHttpVersionResponse,
    RadarGetAttacksLayer7SummaryByHttpVersionError,
    undefined,
    {},
    RadarGetAttacksLayer7SummaryByHttpVersionQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/summary/http_version', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7SummaryByIpVersionQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for http method.
   *
   * @example GET
   */
  httpMethod?: (
    | 'GET'
    | 'POST'
    | 'DELETE'
    | 'PUT'
    | 'HEAD'
    | 'PURGE'
    | 'OPTIONS'
    | 'PROPFIND'
    | 'MKCOL'
    | 'PATCH'
    | 'ACL'
    | 'BCOPY'
    | 'BDELETE'
    | 'BMOVE'
    | 'BPROPFIND'
    | 'BPROPPATCH'
    | 'CHECKIN'
    | 'CHECKOUT'
    | 'CONNECT'
    | 'COPY'
    | 'LABEL'
    | 'LOCK'
    | 'MERGE'
    | 'MKACTIVITY'
    | 'MKWORKSPACE'
    | 'MOVE'
    | 'NOTIFY'
    | 'ORDERPATCH'
    | 'POLL'
    | 'PROPPATCH'
    | 'REPORT'
    | 'SEARCH'
    | 'SUBSCRIBE'
    | 'TRACE'
    | 'UNCHECKOUT'
    | 'UNLOCK'
    | 'UNSUBSCRIBE'
    | 'UPDATE'
    | 'VERSIONCONTROL'
    | 'BASELINECONTROL'
    | 'XMSENUMATTS'
    | 'RPC_OUT_DATA'
    | 'RPC_IN_DATA'
    | 'JSON'
    | 'COOK'
    | 'TRACK'
  )[];
  /**
   * Array of L7 mitigation products.
   */
  mitigationProduct?: (
    | 'DDOS'
    | 'WAF'
    | 'BOT_MANAGEMENT'
    | 'ACCESS_RULES'
    | 'IP_REPUTATION'
    | 'API_SHIELD'
    | 'DATA_LOSS_PREVENTION'
  )[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7SummaryByIpVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer7SummaryByIpVersionResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    /**
     * @example {"IPv4":"99.935733","IPv6":"0.064267"}
     */
    summary_0: {
      IPv4: string;
      IPv6: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7SummaryByIpVersionVariables = {
  queryParams?: RadarGetAttacksLayer7SummaryByIpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by ip version used.
 */
export const radarGetAttacksLayer7SummaryByIpVersion = (
  variables: RadarGetAttacksLayer7SummaryByIpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7SummaryByIpVersionResponse,
    RadarGetAttacksLayer7SummaryByIpVersionError,
    undefined,
    {},
    RadarGetAttacksLayer7SummaryByIpVersionQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/summary/ip_version', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7SummaryByManagedRulesQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for http method.
   *
   * @example GET
   */
  httpMethod?: (
    | 'GET'
    | 'POST'
    | 'DELETE'
    | 'PUT'
    | 'HEAD'
    | 'PURGE'
    | 'OPTIONS'
    | 'PROPFIND'
    | 'MKCOL'
    | 'PATCH'
    | 'ACL'
    | 'BCOPY'
    | 'BDELETE'
    | 'BMOVE'
    | 'BPROPFIND'
    | 'BPROPPATCH'
    | 'CHECKIN'
    | 'CHECKOUT'
    | 'CONNECT'
    | 'COPY'
    | 'LABEL'
    | 'LOCK'
    | 'MERGE'
    | 'MKACTIVITY'
    | 'MKWORKSPACE'
    | 'MOVE'
    | 'NOTIFY'
    | 'ORDERPATCH'
    | 'POLL'
    | 'PROPPATCH'
    | 'REPORT'
    | 'SEARCH'
    | 'SUBSCRIBE'
    | 'TRACE'
    | 'UNCHECKOUT'
    | 'UNLOCK'
    | 'UNSUBSCRIBE'
    | 'UPDATE'
    | 'VERSIONCONTROL'
    | 'BASELINECONTROL'
    | 'XMSENUMATTS'
    | 'RPC_OUT_DATA'
    | 'RPC_IN_DATA'
    | 'JSON'
    | 'COOK'
    | 'TRACK'
  )[];
  /**
   * Array of L7 mitigation products.
   */
  mitigationProduct?: (
    | 'DDOS'
    | 'WAF'
    | 'BOT_MANAGEMENT'
    | 'ACCESS_RULES'
    | 'IP_REPUTATION'
    | 'API_SHIELD'
    | 'DATA_LOSS_PREVENTION'
  )[];
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7SummaryByManagedRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer7SummaryByManagedRulesResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    /**
     * @example {"HTTP Anomaly":"85.714286","XSS":"10.274394"}
     */
    summary_0: {
      [key: string]: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7SummaryByManagedRulesVariables = {
  queryParams?: RadarGetAttacksLayer7SummaryByManagedRulesQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by managed rules used.
 */
export const radarGetAttacksLayer7SummaryByManagedRules = (
  variables: RadarGetAttacksLayer7SummaryByManagedRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7SummaryByManagedRulesResponse,
    RadarGetAttacksLayer7SummaryByManagedRulesError,
    undefined,
    {},
    RadarGetAttacksLayer7SummaryByManagedRulesQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/summary/managed_rules', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7SummaryByMitigationProductQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for http method.
   *
   * @example GET
   */
  httpMethod?: (
    | 'GET'
    | 'POST'
    | 'DELETE'
    | 'PUT'
    | 'HEAD'
    | 'PURGE'
    | 'OPTIONS'
    | 'PROPFIND'
    | 'MKCOL'
    | 'PATCH'
    | 'ACL'
    | 'BCOPY'
    | 'BDELETE'
    | 'BMOVE'
    | 'BPROPFIND'
    | 'BPROPPATCH'
    | 'CHECKIN'
    | 'CHECKOUT'
    | 'CONNECT'
    | 'COPY'
    | 'LABEL'
    | 'LOCK'
    | 'MERGE'
    | 'MKACTIVITY'
    | 'MKWORKSPACE'
    | 'MOVE'
    | 'NOTIFY'
    | 'ORDERPATCH'
    | 'POLL'
    | 'PROPPATCH'
    | 'REPORT'
    | 'SEARCH'
    | 'SUBSCRIBE'
    | 'TRACE'
    | 'UNCHECKOUT'
    | 'UNLOCK'
    | 'UNSUBSCRIBE'
    | 'UPDATE'
    | 'VERSIONCONTROL'
    | 'BASELINECONTROL'
    | 'XMSENUMATTS'
    | 'RPC_OUT_DATA'
    | 'RPC_IN_DATA'
    | 'JSON'
    | 'COOK'
    | 'TRACK'
  )[];
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7SummaryByMitigationProductError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer7SummaryByMitigationProductResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    /**
     * @example {"DDOS":"24.421594","WAF":"53.213368"}
     */
    summary_0: {
      [key: string]: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7SummaryByMitigationProductVariables = {
  queryParams?: RadarGetAttacksLayer7SummaryByMitigationProductQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by mitigation product used.
 */
export const radarGetAttacksLayer7SummaryByMitigationProduct = (
  variables: RadarGetAttacksLayer7SummaryByMitigationProductVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7SummaryByMitigationProductResponse,
    RadarGetAttacksLayer7SummaryByMitigationProductError,
    undefined,
    {},
    RadarGetAttacksLayer7SummaryByMitigationProductQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/summary/mitigation_product', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7TimeseriesQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * This field is deprecated, please use the new `mitigationProduct`.
   *
   * @deprecated true
   */
  attack?: (
    | 'DDOS'
    | 'WAF'
    | 'BOT_MANAGEMENT'
    | 'ACCESS_RULES'
    | 'IP_REPUTATION'
    | 'API_SHIELD'
    | 'DATA_LOSS_PREVENTION'
  )[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @example MIN0_MAX
   */
  normalization?: 'PERCENTAGE_CHANGE' | 'MIN0_MAX';
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for http method.
   *
   * @example GET
   */
  httpMethod?: (
    | 'GET'
    | 'POST'
    | 'DELETE'
    | 'PUT'
    | 'HEAD'
    | 'PURGE'
    | 'OPTIONS'
    | 'PROPFIND'
    | 'MKCOL'
    | 'PATCH'
    | 'ACL'
    | 'BCOPY'
    | 'BDELETE'
    | 'BMOVE'
    | 'BPROPFIND'
    | 'BPROPPATCH'
    | 'CHECKIN'
    | 'CHECKOUT'
    | 'CONNECT'
    | 'COPY'
    | 'LABEL'
    | 'LOCK'
    | 'MERGE'
    | 'MKACTIVITY'
    | 'MKWORKSPACE'
    | 'MOVE'
    | 'NOTIFY'
    | 'ORDERPATCH'
    | 'POLL'
    | 'PROPPATCH'
    | 'REPORT'
    | 'SEARCH'
    | 'SUBSCRIBE'
    | 'TRACE'
    | 'UNCHECKOUT'
    | 'UNLOCK'
    | 'UNSUBSCRIBE'
    | 'UPDATE'
    | 'VERSIONCONTROL'
    | 'BASELINECONTROL'
    | 'XMSENUMATTS'
    | 'RPC_OUT_DATA'
    | 'RPC_IN_DATA'
    | 'JSON'
    | 'COOK'
    | 'TRACK'
  )[];
  /**
   * Array of L7 mitigation products.
   */
  mitigationProduct?: (
    | 'DDOS'
    | 'WAF'
    | 'BOT_MANAGEMENT'
    | 'ACCESS_RULES'
    | 'IP_REPUTATION'
    | 'API_SHIELD'
    | 'DATA_LOSS_PREVENTION'
  )[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7TimeseriesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer7TimeseriesResponse = {
  result: {
    meta: {
      /**
       * @example 1h
       */
      aggInterval: string;
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @format date-time
       */
      lastUpdated: string;
    };
    serie_0: {
      timestamps: string[];
      values: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7TimeseriesVariables = {
  queryParams?: RadarGetAttacksLayer7TimeseriesQueryParams;
} & FetcherExtraProps;

/**
 * Get a timeseries of Layer 7 attacks. Values represent HTTP requests and are normalized using min-max by default.
 */
export const radarGetAttacksLayer7Timeseries = (
  variables: RadarGetAttacksLayer7TimeseriesVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7TimeseriesResponse,
    RadarGetAttacksLayer7TimeseriesError,
    undefined,
    {},
    RadarGetAttacksLayer7TimeseriesQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/timeseries', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7TimeseriesGroupQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7TimeseriesGroupError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer7TimeseriesGroupResponse = {
  result: {
    meta: {
      /**
       * @example 1h
       */
      aggInterval: string;
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @format date-time
       */
      lastUpdated: string;
    };
    serie_0: {
      ACCESS_RULES: string[];
      API_SHIELD: string[];
      BOT_MANAGEMENT: string[];
      DATA_LOSS_PREVENTION: string[];
      DDOS: string[];
      IP_REPUTATION: string[];
      WAF: string[];
      timestamps: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7TimeseriesGroupVariables = {
  queryParams?: RadarGetAttacksLayer7TimeseriesGroupQueryParams;
} & FetcherExtraProps;

/**
 * Get a time series of the distribution of mitigation techniques over time.
 */
export const radarGetAttacksLayer7TimeseriesGroup = (
  variables: RadarGetAttacksLayer7TimeseriesGroupVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7TimeseriesGroupResponse,
    RadarGetAttacksLayer7TimeseriesGroupError,
    undefined,
    {},
    RadarGetAttacksLayer7TimeseriesGroupQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/timeseries_groups', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7TimeseriesGroupByHttpMethodQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Array of L7 mitigation products.
   */
  mitigationProduct?: (
    | 'DDOS'
    | 'WAF'
    | 'BOT_MANAGEMENT'
    | 'ACCESS_RULES'
    | 'IP_REPUTATION'
    | 'API_SHIELD'
    | 'DATA_LOSS_PREVENTION'
  )[];
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @default PERCENTAGE
   * @example PERCENTAGE
   */
  normalization?: 'PERCENTAGE' | 'MIN0_MAX';
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7TimeseriesGroupByHttpMethodError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer7TimeseriesGroupByHttpMethodResponse = {
  result: {
    meta: Record<string, any>;
    /**
     * @example {"GET":["70.970199"],"timestamps":["2023-10-01T00:00:00Z"]}
     */
    serie_0: {
      timestamps: string[];
    } & {
      [key: string]: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7TimeseriesGroupByHttpMethodVariables = {
  queryParams?: RadarGetAttacksLayer7TimeseriesGroupByHttpMethodQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by http method used over time.
 */
export const radarGetAttacksLayer7TimeseriesGroupByHttpMethod = (
  variables: RadarGetAttacksLayer7TimeseriesGroupByHttpMethodVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7TimeseriesGroupByHttpMethodResponse,
    RadarGetAttacksLayer7TimeseriesGroupByHttpMethodError,
    undefined,
    {},
    RadarGetAttacksLayer7TimeseriesGroupByHttpMethodQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/timeseries_groups/http_method', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7TimeseriesGroupByHttpVersionQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for http method.
   *
   * @example GET
   */
  httpMethod?: (
    | 'GET'
    | 'POST'
    | 'DELETE'
    | 'PUT'
    | 'HEAD'
    | 'PURGE'
    | 'OPTIONS'
    | 'PROPFIND'
    | 'MKCOL'
    | 'PATCH'
    | 'ACL'
    | 'BCOPY'
    | 'BDELETE'
    | 'BMOVE'
    | 'BPROPFIND'
    | 'BPROPPATCH'
    | 'CHECKIN'
    | 'CHECKOUT'
    | 'CONNECT'
    | 'COPY'
    | 'LABEL'
    | 'LOCK'
    | 'MERGE'
    | 'MKACTIVITY'
    | 'MKWORKSPACE'
    | 'MOVE'
    | 'NOTIFY'
    | 'ORDERPATCH'
    | 'POLL'
    | 'PROPPATCH'
    | 'REPORT'
    | 'SEARCH'
    | 'SUBSCRIBE'
    | 'TRACE'
    | 'UNCHECKOUT'
    | 'UNLOCK'
    | 'UNSUBSCRIBE'
    | 'UPDATE'
    | 'VERSIONCONTROL'
    | 'BASELINECONTROL'
    | 'XMSENUMATTS'
    | 'RPC_OUT_DATA'
    | 'RPC_IN_DATA'
    | 'JSON'
    | 'COOK'
    | 'TRACK'
  )[];
  /**
   * Array of L7 mitigation products.
   */
  mitigationProduct?: (
    | 'DDOS'
    | 'WAF'
    | 'BOT_MANAGEMENT'
    | 'ACCESS_RULES'
    | 'IP_REPUTATION'
    | 'API_SHIELD'
    | 'DATA_LOSS_PREVENTION'
  )[];
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @default PERCENTAGE
   * @example PERCENTAGE
   */
  normalization?: 'PERCENTAGE' | 'MIN0_MAX';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7TimeseriesGroupByHttpVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer7TimeseriesGroupByHttpVersionResponse = {
  result: {
    meta: Record<string, any>;
    /**
     * @example {"HTTP/1.x":["50.338734"],"HTTP/2":["48.661266"],"HTTP/3":["1.22108"],"timestamps":["2023-10-01T00:00:00Z"]}
     */
    serie_0: {
      ['HTTP/1.x']: string[];
      ['HTTP/2']: string[];
      ['HTTP/3']: string[];
      timestamps: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7TimeseriesGroupByHttpVersionVariables = {
  queryParams?: RadarGetAttacksLayer7TimeseriesGroupByHttpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by http version used over time.
 */
export const radarGetAttacksLayer7TimeseriesGroupByHttpVersion = (
  variables: RadarGetAttacksLayer7TimeseriesGroupByHttpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7TimeseriesGroupByHttpVersionResponse,
    RadarGetAttacksLayer7TimeseriesGroupByHttpVersionError,
    undefined,
    {},
    RadarGetAttacksLayer7TimeseriesGroupByHttpVersionQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/timeseries_groups/http_version', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7TimeseriesGroupByIndustryQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for http method.
   *
   * @example GET
   */
  httpMethod?: (
    | 'GET'
    | 'POST'
    | 'DELETE'
    | 'PUT'
    | 'HEAD'
    | 'PURGE'
    | 'OPTIONS'
    | 'PROPFIND'
    | 'MKCOL'
    | 'PATCH'
    | 'ACL'
    | 'BCOPY'
    | 'BDELETE'
    | 'BMOVE'
    | 'BPROPFIND'
    | 'BPROPPATCH'
    | 'CHECKIN'
    | 'CHECKOUT'
    | 'CONNECT'
    | 'COPY'
    | 'LABEL'
    | 'LOCK'
    | 'MERGE'
    | 'MKACTIVITY'
    | 'MKWORKSPACE'
    | 'MOVE'
    | 'NOTIFY'
    | 'ORDERPATCH'
    | 'POLL'
    | 'PROPPATCH'
    | 'REPORT'
    | 'SEARCH'
    | 'SUBSCRIBE'
    | 'TRACE'
    | 'UNCHECKOUT'
    | 'UNLOCK'
    | 'UNSUBSCRIBE'
    | 'UPDATE'
    | 'VERSIONCONTROL'
    | 'BASELINECONTROL'
    | 'XMSENUMATTS'
    | 'RPC_OUT_DATA'
    | 'RPC_IN_DATA'
    | 'JSON'
    | 'COOK'
    | 'TRACK'
  )[];
  /**
   * Array of L7 mitigation products.
   */
  mitigationProduct?: (
    | 'DDOS'
    | 'WAF'
    | 'BOT_MANAGEMENT'
    | 'ACCESS_RULES'
    | 'IP_REPUTATION'
    | 'API_SHIELD'
    | 'DATA_LOSS_PREVENTION'
  )[];
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @default PERCENTAGE
   * @example PERCENTAGE
   */
  normalization?: 'PERCENTAGE' | 'MIN0_MAX';
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7TimeseriesGroupByIndustryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer7TimeseriesGroupByIndustryResponse = {
  result: {
    meta: Record<string, any>;
    /**
     * @example {"Internet":["5.519081"],"timestamps":["2023-08-08T10:15:00Z"]}
     */
    serie_0: {
      timestamps: string[];
    } & {
      [key: string]: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7TimeseriesGroupByIndustryVariables = {
  queryParams?: RadarGetAttacksLayer7TimeseriesGroupByIndustryQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by targeted industry over time.
 */
export const radarGetAttacksLayer7TimeseriesGroupByIndustry = (
  variables: RadarGetAttacksLayer7TimeseriesGroupByIndustryVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7TimeseriesGroupByIndustryResponse,
    RadarGetAttacksLayer7TimeseriesGroupByIndustryError,
    undefined,
    {},
    RadarGetAttacksLayer7TimeseriesGroupByIndustryQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/timeseries_groups/industry', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7TimeseriesGroupByIpVersionQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for http method.
   *
   * @example GET
   */
  httpMethod?: (
    | 'GET'
    | 'POST'
    | 'DELETE'
    | 'PUT'
    | 'HEAD'
    | 'PURGE'
    | 'OPTIONS'
    | 'PROPFIND'
    | 'MKCOL'
    | 'PATCH'
    | 'ACL'
    | 'BCOPY'
    | 'BDELETE'
    | 'BMOVE'
    | 'BPROPFIND'
    | 'BPROPPATCH'
    | 'CHECKIN'
    | 'CHECKOUT'
    | 'CONNECT'
    | 'COPY'
    | 'LABEL'
    | 'LOCK'
    | 'MERGE'
    | 'MKACTIVITY'
    | 'MKWORKSPACE'
    | 'MOVE'
    | 'NOTIFY'
    | 'ORDERPATCH'
    | 'POLL'
    | 'PROPPATCH'
    | 'REPORT'
    | 'SEARCH'
    | 'SUBSCRIBE'
    | 'TRACE'
    | 'UNCHECKOUT'
    | 'UNLOCK'
    | 'UNSUBSCRIBE'
    | 'UPDATE'
    | 'VERSIONCONTROL'
    | 'BASELINECONTROL'
    | 'XMSENUMATTS'
    | 'RPC_OUT_DATA'
    | 'RPC_IN_DATA'
    | 'JSON'
    | 'COOK'
    | 'TRACK'
  )[];
  /**
   * Array of L7 mitigation products.
   */
  mitigationProduct?: (
    | 'DDOS'
    | 'WAF'
    | 'BOT_MANAGEMENT'
    | 'ACCESS_RULES'
    | 'IP_REPUTATION'
    | 'API_SHIELD'
    | 'DATA_LOSS_PREVENTION'
  )[];
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @default PERCENTAGE
   * @example PERCENTAGE
   */
  normalization?: 'PERCENTAGE' | 'MIN0_MAX';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7TimeseriesGroupByIpVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer7TimeseriesGroupByIpVersionResponse = {
  result: {
    meta: Record<string, any>;
    /**
     * @example {"IPv4":["99.935733"],"IPv6":["0.064267"],"timestamps":["2023-10-01T00:00:00Z"]}
     */
    serie_0: {
      IPv4: string[];
      IPv6: string[];
      timestamps: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7TimeseriesGroupByIpVersionVariables = {
  queryParams?: RadarGetAttacksLayer7TimeseriesGroupByIpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by ip version used over time.
 */
export const radarGetAttacksLayer7TimeseriesGroupByIpVersion = (
  variables: RadarGetAttacksLayer7TimeseriesGroupByIpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7TimeseriesGroupByIpVersionResponse,
    RadarGetAttacksLayer7TimeseriesGroupByIpVersionError,
    undefined,
    {},
    RadarGetAttacksLayer7TimeseriesGroupByIpVersionQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/timeseries_groups/ip_version', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7TimeseriesGroupByManagedRulesQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for http method.
   *
   * @example GET
   */
  httpMethod?: (
    | 'GET'
    | 'POST'
    | 'DELETE'
    | 'PUT'
    | 'HEAD'
    | 'PURGE'
    | 'OPTIONS'
    | 'PROPFIND'
    | 'MKCOL'
    | 'PATCH'
    | 'ACL'
    | 'BCOPY'
    | 'BDELETE'
    | 'BMOVE'
    | 'BPROPFIND'
    | 'BPROPPATCH'
    | 'CHECKIN'
    | 'CHECKOUT'
    | 'CONNECT'
    | 'COPY'
    | 'LABEL'
    | 'LOCK'
    | 'MERGE'
    | 'MKACTIVITY'
    | 'MKWORKSPACE'
    | 'MOVE'
    | 'NOTIFY'
    | 'ORDERPATCH'
    | 'POLL'
    | 'PROPPATCH'
    | 'REPORT'
    | 'SEARCH'
    | 'SUBSCRIBE'
    | 'TRACE'
    | 'UNCHECKOUT'
    | 'UNLOCK'
    | 'UNSUBSCRIBE'
    | 'UPDATE'
    | 'VERSIONCONTROL'
    | 'BASELINECONTROL'
    | 'XMSENUMATTS'
    | 'RPC_OUT_DATA'
    | 'RPC_IN_DATA'
    | 'JSON'
    | 'COOK'
    | 'TRACK'
  )[];
  /**
   * Array of L7 mitigation products.
   */
  mitigationProduct?: (
    | 'DDOS'
    | 'WAF'
    | 'BOT_MANAGEMENT'
    | 'ACCESS_RULES'
    | 'IP_REPUTATION'
    | 'API_SHIELD'
    | 'DATA_LOSS_PREVENTION'
  )[];
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @default PERCENTAGE
   * @example PERCENTAGE
   */
  normalization?: 'PERCENTAGE' | 'MIN0_MAX';
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7TimeseriesGroupByManagedRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer7TimeseriesGroupByManagedRulesResponse = {
  result: {
    meta: Record<string, any>;
    /**
     * @example {"XSS":["0.324198"],"timestamps":["2023-10-01T00:00:00Z"]}
     */
    serie_0: {
      timestamps: string[];
    } & {
      [key: string]: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7TimeseriesGroupByManagedRulesVariables = {
  queryParams?: RadarGetAttacksLayer7TimeseriesGroupByManagedRulesQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by managed rules used over time.
 */
export const radarGetAttacksLayer7TimeseriesGroupByManagedRules = (
  variables: RadarGetAttacksLayer7TimeseriesGroupByManagedRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7TimeseriesGroupByManagedRulesResponse,
    RadarGetAttacksLayer7TimeseriesGroupByManagedRulesError,
    undefined,
    {},
    RadarGetAttacksLayer7TimeseriesGroupByManagedRulesQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/timeseries_groups/managed_rules', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7TimeseriesGroupByMitigationProductQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for http method.
   *
   * @example GET
   */
  httpMethod?: (
    | 'GET'
    | 'POST'
    | 'DELETE'
    | 'PUT'
    | 'HEAD'
    | 'PURGE'
    | 'OPTIONS'
    | 'PROPFIND'
    | 'MKCOL'
    | 'PATCH'
    | 'ACL'
    | 'BCOPY'
    | 'BDELETE'
    | 'BMOVE'
    | 'BPROPFIND'
    | 'BPROPPATCH'
    | 'CHECKIN'
    | 'CHECKOUT'
    | 'CONNECT'
    | 'COPY'
    | 'LABEL'
    | 'LOCK'
    | 'MERGE'
    | 'MKACTIVITY'
    | 'MKWORKSPACE'
    | 'MOVE'
    | 'NOTIFY'
    | 'ORDERPATCH'
    | 'POLL'
    | 'PROPPATCH'
    | 'REPORT'
    | 'SEARCH'
    | 'SUBSCRIBE'
    | 'TRACE'
    | 'UNCHECKOUT'
    | 'UNLOCK'
    | 'UNSUBSCRIBE'
    | 'UPDATE'
    | 'VERSIONCONTROL'
    | 'BASELINECONTROL'
    | 'XMSENUMATTS'
    | 'RPC_OUT_DATA'
    | 'RPC_IN_DATA'
    | 'JSON'
    | 'COOK'
    | 'TRACK'
  )[];
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @default PERCENTAGE
   * @example PERCENTAGE
   */
  normalization?: 'PERCENTAGE' | 'MIN0_MAX';
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7TimeseriesGroupByMitigationProductError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer7TimeseriesGroupByMitigationProductResponse = {
  result: {
    meta: Record<string, any>;
    /**
     * @example {"DDOS":["48.926354"],"timestamps":["2023-10-01T00:00:00Z"]}
     */
    serie_0: {
      timestamps: string[];
    } & {
      [key: string]: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7TimeseriesGroupByMitigationProductVariables = {
  queryParams?: RadarGetAttacksLayer7TimeseriesGroupByMitigationProductQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by mitigation product used over time.
 */
export const radarGetAttacksLayer7TimeseriesGroupByMitigationProduct = (
  variables: RadarGetAttacksLayer7TimeseriesGroupByMitigationProductVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7TimeseriesGroupByMitigationProductResponse,
    RadarGetAttacksLayer7TimeseriesGroupByMitigationProductError,
    undefined,
    {},
    RadarGetAttacksLayer7TimeseriesGroupByMitigationProductQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/timeseries_groups/mitigation_product', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7TimeseriesGroupByVerticalQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for http method.
   *
   * @example GET
   */
  httpMethod?: (
    | 'GET'
    | 'POST'
    | 'DELETE'
    | 'PUT'
    | 'HEAD'
    | 'PURGE'
    | 'OPTIONS'
    | 'PROPFIND'
    | 'MKCOL'
    | 'PATCH'
    | 'ACL'
    | 'BCOPY'
    | 'BDELETE'
    | 'BMOVE'
    | 'BPROPFIND'
    | 'BPROPPATCH'
    | 'CHECKIN'
    | 'CHECKOUT'
    | 'CONNECT'
    | 'COPY'
    | 'LABEL'
    | 'LOCK'
    | 'MERGE'
    | 'MKACTIVITY'
    | 'MKWORKSPACE'
    | 'MOVE'
    | 'NOTIFY'
    | 'ORDERPATCH'
    | 'POLL'
    | 'PROPPATCH'
    | 'REPORT'
    | 'SEARCH'
    | 'SUBSCRIBE'
    | 'TRACE'
    | 'UNCHECKOUT'
    | 'UNLOCK'
    | 'UNSUBSCRIBE'
    | 'UPDATE'
    | 'VERSIONCONTROL'
    | 'BASELINECONTROL'
    | 'XMSENUMATTS'
    | 'RPC_OUT_DATA'
    | 'RPC_IN_DATA'
    | 'JSON'
    | 'COOK'
    | 'TRACK'
  )[];
  /**
   * Array of L7 mitigation products.
   */
  mitigationProduct?: (
    | 'DDOS'
    | 'WAF'
    | 'BOT_MANAGEMENT'
    | 'ACCESS_RULES'
    | 'IP_REPUTATION'
    | 'API_SHIELD'
    | 'DATA_LOSS_PREVENTION'
  )[];
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @default PERCENTAGE
   * @example PERCENTAGE
   */
  normalization?: 'PERCENTAGE' | 'MIN0_MAX';
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7TimeseriesGroupByVerticalError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAttacksLayer7TimeseriesGroupByVerticalResponse = {
  result: {
    meta: Record<string, any>;
    /**
     * @example {"Internet and Telecom":["5.519081"],"timestamps":["2023-08-08T10:15:00Z"]}
     */
    serie_0: {
      timestamps: string[];
    } & {
      [key: string]: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7TimeseriesGroupByVerticalVariables = {
  queryParams?: RadarGetAttacksLayer7TimeseriesGroupByVerticalQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of attacks by targeted vertical over time.
 */
export const radarGetAttacksLayer7TimeseriesGroupByVertical = (
  variables: RadarGetAttacksLayer7TimeseriesGroupByVerticalVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7TimeseriesGroupByVerticalResponse,
    RadarGetAttacksLayer7TimeseriesGroupByVerticalError,
    undefined,
    {},
    RadarGetAttacksLayer7TimeseriesGroupByVerticalQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/timeseries_groups/vertical', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7TopOriginAsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for http method.
   *
   * @example GET
   */
  httpMethod?: (
    | 'GET'
    | 'POST'
    | 'DELETE'
    | 'PUT'
    | 'HEAD'
    | 'PURGE'
    | 'OPTIONS'
    | 'PROPFIND'
    | 'MKCOL'
    | 'PATCH'
    | 'ACL'
    | 'BCOPY'
    | 'BDELETE'
    | 'BMOVE'
    | 'BPROPFIND'
    | 'BPROPPATCH'
    | 'CHECKIN'
    | 'CHECKOUT'
    | 'CONNECT'
    | 'COPY'
    | 'LABEL'
    | 'LOCK'
    | 'MERGE'
    | 'MKACTIVITY'
    | 'MKWORKSPACE'
    | 'MOVE'
    | 'NOTIFY'
    | 'ORDERPATCH'
    | 'POLL'
    | 'PROPPATCH'
    | 'REPORT'
    | 'SEARCH'
    | 'SUBSCRIBE'
    | 'TRACE'
    | 'UNCHECKOUT'
    | 'UNLOCK'
    | 'UNSUBSCRIBE'
    | 'UPDATE'
    | 'VERSIONCONTROL'
    | 'BASELINECONTROL'
    | 'XMSENUMATTS'
    | 'RPC_OUT_DATA'
    | 'RPC_IN_DATA'
    | 'JSON'
    | 'COOK'
    | 'TRACK'
  )[];
  /**
   * Array of L7 mitigation products.
   */
  mitigationProduct?: (
    | 'DDOS'
    | 'WAF'
    | 'BOT_MANAGEMENT'
    | 'ACCESS_RULES'
    | 'IP_REPUTATION'
    | 'API_SHIELD'
    | 'DATA_LOSS_PREVENTION'
  )[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7TopOriginAsError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetAttacksLayer7TopOriginAsResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example 55836
       */
      originAsn: string;
      /**
       * @example RELIANCEJIO-IN Reliance Jio Infocomm Limited
       */
      originAsnName: string;
      /**
       * @example 1
       */
      rank: number;
      /**
       * @example 4.323214
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7TopOriginAsVariables = {
  queryParams?: RadarGetAttacksLayer7TopOriginAsQueryParams;
} & FetcherExtraProps;

/**
 * Get the top origin Autonomous Systems of and by Layer 7 attacks. Values are a percentage out of the total Layer 7 attacks. The origin Autonomous Systems is determined by the client IP address.
 */
export const radarGetAttacksLayer7TopOriginAs = (
  variables: RadarGetAttacksLayer7TopOriginAsVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7TopOriginAsResponse,
    RadarGetAttacksLayer7TopOriginAsError,
    undefined,
    {},
    RadarGetAttacksLayer7TopOriginAsQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/top/ases/origin', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7TopAttacksQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for http method.
   *
   * @example GET
   */
  httpMethod?: (
    | 'GET'
    | 'POST'
    | 'DELETE'
    | 'PUT'
    | 'HEAD'
    | 'PURGE'
    | 'OPTIONS'
    | 'PROPFIND'
    | 'MKCOL'
    | 'PATCH'
    | 'ACL'
    | 'BCOPY'
    | 'BDELETE'
    | 'BMOVE'
    | 'BPROPFIND'
    | 'BPROPPATCH'
    | 'CHECKIN'
    | 'CHECKOUT'
    | 'CONNECT'
    | 'COPY'
    | 'LABEL'
    | 'LOCK'
    | 'MERGE'
    | 'MKACTIVITY'
    | 'MKWORKSPACE'
    | 'MOVE'
    | 'NOTIFY'
    | 'ORDERPATCH'
    | 'POLL'
    | 'PROPPATCH'
    | 'REPORT'
    | 'SEARCH'
    | 'SUBSCRIBE'
    | 'TRACE'
    | 'UNCHECKOUT'
    | 'UNLOCK'
    | 'UNSUBSCRIBE'
    | 'UPDATE'
    | 'VERSIONCONTROL'
    | 'BASELINECONTROL'
    | 'XMSENUMATTS'
    | 'RPC_OUT_DATA'
    | 'RPC_IN_DATA'
    | 'JSON'
    | 'COOK'
    | 'TRACK'
  )[];
  /**
   * Array of L7 mitigation products.
   */
  mitigationProduct?: (
    | 'DDOS'
    | 'WAF'
    | 'BOT_MANAGEMENT'
    | 'ACCESS_RULES'
    | 'IP_REPUTATION'
    | 'API_SHIELD'
    | 'DATA_LOSS_PREVENTION'
  )[];
  /**
   * Array of attack origin/target location attack limits. Together with `limitPerLocation`, limits how many objects will be fetched per origin/target location.
   *
   * @default ORIGIN
   * @example ORIGIN
   */
  limitDirection?: 'ORIGIN' | 'TARGET';
  /**
   * Limit the number of attacks per origin/target (refer to `limitDirection` parameter) location.
   *
   * @example 10
   */
  limitPerLocation?: number;
  /**
   * Attack magnitude can be defined by total requests mitigated or by total zones attacked.
   *
   * @example MITIGATED_REQUESTS
   */
  magnitude?: 'AFFECTED_ZONES' | 'MITIGATED_REQUESTS';
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @default PERCENTAGE
   * @example PERCENTAGE
   */
  normalization?: 'PERCENTAGE' | 'MIN_MAX';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7TopAttacksError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetAttacksLayer7TopAttacksResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example US
       */
      originCountryAlpha2: string;
      /**
       * @example United States
       */
      originCountryName: string;
      /**
       * @example FR
       */
      targetCountryAlpha2: string;
      /**
       * @example France
       */
      targetCountryName: string;
      /**
       * @example 4.323214
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7TopAttacksVariables = {
  queryParams?: RadarGetAttacksLayer7TopAttacksQueryParams;
} & FetcherExtraProps;

/**
 * Get the top attacks from origin to target location. Values are a percentage out of the total Layer 7 attacks (with billing country). The attack magnitude can be defined by the number of mitigated requests or by the number of zones affected. You can optionally limit the number of attacks by origin/target location (useful if all the top attacks are from or to the same location).
 */
export const radarGetAttacksLayer7TopAttacks = (
  variables: RadarGetAttacksLayer7TopAttacksVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7TopAttacksResponse,
    RadarGetAttacksLayer7TopAttacksError,
    undefined,
    {},
    RadarGetAttacksLayer7TopAttacksQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/top/attacks', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7TopIndustriesQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for http method.
   *
   * @example GET
   */
  httpMethod?: (
    | 'GET'
    | 'POST'
    | 'DELETE'
    | 'PUT'
    | 'HEAD'
    | 'PURGE'
    | 'OPTIONS'
    | 'PROPFIND'
    | 'MKCOL'
    | 'PATCH'
    | 'ACL'
    | 'BCOPY'
    | 'BDELETE'
    | 'BMOVE'
    | 'BPROPFIND'
    | 'BPROPPATCH'
    | 'CHECKIN'
    | 'CHECKOUT'
    | 'CONNECT'
    | 'COPY'
    | 'LABEL'
    | 'LOCK'
    | 'MERGE'
    | 'MKACTIVITY'
    | 'MKWORKSPACE'
    | 'MOVE'
    | 'NOTIFY'
    | 'ORDERPATCH'
    | 'POLL'
    | 'PROPPATCH'
    | 'REPORT'
    | 'SEARCH'
    | 'SUBSCRIBE'
    | 'TRACE'
    | 'UNCHECKOUT'
    | 'UNLOCK'
    | 'UNSUBSCRIBE'
    | 'UPDATE'
    | 'VERSIONCONTROL'
    | 'BASELINECONTROL'
    | 'XMSENUMATTS'
    | 'RPC_OUT_DATA'
    | 'RPC_IN_DATA'
    | 'JSON'
    | 'COOK'
    | 'TRACK'
  )[];
  /**
   * Array of L7 mitigation products.
   */
  mitigationProduct?: (
    | 'DDOS'
    | 'WAF'
    | 'BOT_MANAGEMENT'
    | 'ACCESS_RULES'
    | 'IP_REPUTATION'
    | 'API_SHIELD'
    | 'DATA_LOSS_PREVENTION'
  )[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7TopIndustriesError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetAttacksLayer7TopIndustriesResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example Computer Software
       */
      name: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7TopIndustriesVariables = {
  queryParams?: RadarGetAttacksLayer7TopIndustriesQueryParams;
} & FetcherExtraProps;

/**
 * Get the industries targeted by attacks.
 */
export const radarGetAttacksLayer7TopIndustries = (
  variables: RadarGetAttacksLayer7TopIndustriesVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7TopIndustriesResponse,
    RadarGetAttacksLayer7TopIndustriesError,
    undefined,
    {},
    RadarGetAttacksLayer7TopIndustriesQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/top/industry', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7TopOriginLocationQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for http method.
   *
   * @example GET
   */
  httpMethod?: (
    | 'GET'
    | 'POST'
    | 'DELETE'
    | 'PUT'
    | 'HEAD'
    | 'PURGE'
    | 'OPTIONS'
    | 'PROPFIND'
    | 'MKCOL'
    | 'PATCH'
    | 'ACL'
    | 'BCOPY'
    | 'BDELETE'
    | 'BMOVE'
    | 'BPROPFIND'
    | 'BPROPPATCH'
    | 'CHECKIN'
    | 'CHECKOUT'
    | 'CONNECT'
    | 'COPY'
    | 'LABEL'
    | 'LOCK'
    | 'MERGE'
    | 'MKACTIVITY'
    | 'MKWORKSPACE'
    | 'MOVE'
    | 'NOTIFY'
    | 'ORDERPATCH'
    | 'POLL'
    | 'PROPPATCH'
    | 'REPORT'
    | 'SEARCH'
    | 'SUBSCRIBE'
    | 'TRACE'
    | 'UNCHECKOUT'
    | 'UNLOCK'
    | 'UNSUBSCRIBE'
    | 'UPDATE'
    | 'VERSIONCONTROL'
    | 'BASELINECONTROL'
    | 'XMSENUMATTS'
    | 'RPC_OUT_DATA'
    | 'RPC_IN_DATA'
    | 'JSON'
    | 'COOK'
    | 'TRACK'
  )[];
  /**
   * Array of L7 mitigation products.
   */
  mitigationProduct?: (
    | 'DDOS'
    | 'WAF'
    | 'BOT_MANAGEMENT'
    | 'ACCESS_RULES'
    | 'IP_REPUTATION'
    | 'API_SHIELD'
    | 'DATA_LOSS_PREVENTION'
  )[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7TopOriginLocationError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetAttacksLayer7TopOriginLocationResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example FR
       */
      originCountryAlpha2: string;
      /**
       * @example France
       */
      originCountryName: string;
      /**
       * @example 1
       */
      rank: number;
      /**
       * @example 4.323214
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7TopOriginLocationVariables = {
  queryParams?: RadarGetAttacksLayer7TopOriginLocationQueryParams;
} & FetcherExtraProps;

/**
 * Get the top origin locations of and by Layer 7 attacks. Values are a percentage out of the total Layer 7 attacks. The origin location is determined by the client IP address.
 */
export const radarGetAttacksLayer7TopOriginLocation = (
  variables: RadarGetAttacksLayer7TopOriginLocationVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7TopOriginLocationResponse,
    RadarGetAttacksLayer7TopOriginLocationError,
    undefined,
    {},
    RadarGetAttacksLayer7TopOriginLocationQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/top/locations/origin', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7TopTargetLocationQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for http method.
   *
   * @example GET
   */
  httpMethod?: (
    | 'GET'
    | 'POST'
    | 'DELETE'
    | 'PUT'
    | 'HEAD'
    | 'PURGE'
    | 'OPTIONS'
    | 'PROPFIND'
    | 'MKCOL'
    | 'PATCH'
    | 'ACL'
    | 'BCOPY'
    | 'BDELETE'
    | 'BMOVE'
    | 'BPROPFIND'
    | 'BPROPPATCH'
    | 'CHECKIN'
    | 'CHECKOUT'
    | 'CONNECT'
    | 'COPY'
    | 'LABEL'
    | 'LOCK'
    | 'MERGE'
    | 'MKACTIVITY'
    | 'MKWORKSPACE'
    | 'MOVE'
    | 'NOTIFY'
    | 'ORDERPATCH'
    | 'POLL'
    | 'PROPPATCH'
    | 'REPORT'
    | 'SEARCH'
    | 'SUBSCRIBE'
    | 'TRACE'
    | 'UNCHECKOUT'
    | 'UNLOCK'
    | 'UNSUBSCRIBE'
    | 'UPDATE'
    | 'VERSIONCONTROL'
    | 'BASELINECONTROL'
    | 'XMSENUMATTS'
    | 'RPC_OUT_DATA'
    | 'RPC_IN_DATA'
    | 'JSON'
    | 'COOK'
    | 'TRACK'
  )[];
  /**
   * Array of L7 mitigation products.
   */
  mitigationProduct?: (
    | 'DDOS'
    | 'WAF'
    | 'BOT_MANAGEMENT'
    | 'ACCESS_RULES'
    | 'IP_REPUTATION'
    | 'API_SHIELD'
    | 'DATA_LOSS_PREVENTION'
  )[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7TopTargetLocationError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetAttacksLayer7TopTargetLocationResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example 1
       */
      rank: number;
      /**
       * @example FR
       */
      targetCountryAlpha2: string;
      /**
       * @example France
       */
      targetCountryName: string;
      /**
       * @example 4.323214
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7TopTargetLocationVariables = {
  queryParams?: RadarGetAttacksLayer7TopTargetLocationQueryParams;
} & FetcherExtraProps;

/**
 * Get the top target locations of and by layer 7 attacks. Values are a percentage out of the total layer 7 attacks. The target location is determined by the attacked zone's billing country, when available.
 */
export const radarGetAttacksLayer7TopTargetLocation = (
  variables: RadarGetAttacksLayer7TopTargetLocationVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7TopTargetLocationResponse,
    RadarGetAttacksLayer7TopTargetLocationError,
    undefined,
    {},
    RadarGetAttacksLayer7TopTargetLocationQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/top/locations/target', method: 'get', ...variables, signal });

export type RadarGetAttacksLayer7TopVerticalsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for http method.
   *
   * @example GET
   */
  httpMethod?: (
    | 'GET'
    | 'POST'
    | 'DELETE'
    | 'PUT'
    | 'HEAD'
    | 'PURGE'
    | 'OPTIONS'
    | 'PROPFIND'
    | 'MKCOL'
    | 'PATCH'
    | 'ACL'
    | 'BCOPY'
    | 'BDELETE'
    | 'BMOVE'
    | 'BPROPFIND'
    | 'BPROPPATCH'
    | 'CHECKIN'
    | 'CHECKOUT'
    | 'CONNECT'
    | 'COPY'
    | 'LABEL'
    | 'LOCK'
    | 'MERGE'
    | 'MKACTIVITY'
    | 'MKWORKSPACE'
    | 'MOVE'
    | 'NOTIFY'
    | 'ORDERPATCH'
    | 'POLL'
    | 'PROPPATCH'
    | 'REPORT'
    | 'SEARCH'
    | 'SUBSCRIBE'
    | 'TRACE'
    | 'UNCHECKOUT'
    | 'UNLOCK'
    | 'UNSUBSCRIBE'
    | 'UPDATE'
    | 'VERSIONCONTROL'
    | 'BASELINECONTROL'
    | 'XMSENUMATTS'
    | 'RPC_OUT_DATA'
    | 'RPC_IN_DATA'
    | 'JSON'
    | 'COOK'
    | 'TRACK'
  )[];
  /**
   * Array of L7 mitigation products.
   */
  mitigationProduct?: (
    | 'DDOS'
    | 'WAF'
    | 'BOT_MANAGEMENT'
    | 'ACCESS_RULES'
    | 'IP_REPUTATION'
    | 'API_SHIELD'
    | 'DATA_LOSS_PREVENTION'
  )[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAttacksLayer7TopVerticalsError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetAttacksLayer7TopVerticalsResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example Internet and Telecom
       */
      name: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAttacksLayer7TopVerticalsVariables = {
  queryParams?: RadarGetAttacksLayer7TopVerticalsQueryParams;
} & FetcherExtraProps;

/**
 * Get the verticals targeted by attacks.
 */
export const radarGetAttacksLayer7TopVerticals = (
  variables: RadarGetAttacksLayer7TopVerticalsVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetAttacksLayer7TopVerticalsResponse,
    RadarGetAttacksLayer7TopVerticalsError,
    undefined,
    {},
    RadarGetAttacksLayer7TopVerticalsQueryParams,
    {}
  >({ url: '/radar/attacks/layer7/top/vertical', method: 'get', ...variables, signal });

export type RadarGetBgpHijacksEventsQueryParams = {
  /**
   * Current page number, starting from 1
   */
  page?: number;
  /**
   * Number of entries per page
   */
  per_page?: number;
  /**
   * The unique identifier of a event
   */
  eventId?: number;
  /**
   * The potential hijacker AS of a BGP hijack event
   */
  hijackerAsn?: number;
  /**
   * The potential victim AS of a BGP hijack event
   */
  victimAsn?: number;
  /**
   * The potential hijacker or victim AS of a BGP hijack event
   */
  involvedAsn?: number;
  /**
   * The country code of the potential hijacker or victim AS of a BGP hijack event
   */
  involvedCountry?: string;
  /**
   * Network prefix, IPv4 or IPv6.
   *
   * @example 1.1.1.0/24
   */
  prefix?: string;
  /**
   * The minimum confidence score to filter events (1-4 low, 5-7 mid, 8+ high)
   */
  minConfidence?: number;
  /**
   * The maximum confidence score to filter events (1-4 low, 5-7 mid, 8+ high)
   */
  maxConfidence?: number;
  /**
   * Shorthand date ranges for the last X days - use when you don't need specific start and end dates.
   *
   * @example 7d
   * @pattern ^((([1-9]|[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-4])[d](control)?)|(([1-9]|[1-4][0-9]|5[0-2])[w](control)?))$
   */
  dateRange?: string;
  /**
   * Start of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   * @format date-time
   */
  dateStart?: string;
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   * @format date-time
   */
  dateEnd?: string;
  /**
   * Sort events by field
   *
   * @example TIME
   */
  sortBy?: 'ID' | 'TIME' | 'CONFIDENCE';
  /**
   * Sort order
   *
   * @example DESC
   */
  sortOrder?: 'ASC' | 'DESC';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetBgpHijacksEventsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetBgpHijacksEventsResponse = {
  result: {
    asn_info: {
      asn: number;
      country_code: string;
      org_name: string;
    }[];
    events: {
      confidence_score: number;
      duration: number;
      event_type: number;
      hijack_msgs_count: number;
      hijacker_asn: number;
      hijacker_country: string;
      id: number;
      is_stale: boolean;
      max_hijack_ts: string;
      max_msg_ts: string;
      min_hijack_ts: string;
      on_going_count: number;
      peer_asns: number[];
      peer_ip_count: number;
      prefixes: string[];
      tags: {
        name: string;
        score: number;
      }[];
      victim_asns: number[];
      victim_countries: string[];
    }[];
    total_monitors: number;
  };
  result_info: {
    count: number;
    page: number;
    per_page: number;
    total_count: number;
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetBgpHijacksEventsVariables = {
  queryParams?: RadarGetBgpHijacksEventsQueryParams;
} & FetcherExtraProps;

/**
 * Get the BGP hijack events. (Beta)
 */
export const radarGetBgpHijacksEvents = (variables: RadarGetBgpHijacksEventsVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetBgpHijacksEventsResponse,
    RadarGetBgpHijacksEventsError,
    undefined,
    {},
    RadarGetBgpHijacksEventsQueryParams,
    {}
  >({ url: '/radar/bgp/hijacks/events', method: 'get', ...variables, signal });

export type RadarGetBgpIpsTimeseriesQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of locations (alpha-2 country codes).
   *
   * @example US
   */
  location?: string[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Include data delay meta information
   *
   * @example true
   */
  includeDelay?: boolean;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetBgpIpsTimeseriesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetBgpIpsTimeseriesResponse = {
  result: {
    meta: {
      queries: {
        dateRange: {
          /**
           * @example 2024-07-29T13:30:00Z
           */
          endTime: string;
          /**
           * @example 2024-07-28T13:30:00Z
           */
          startTime: string;
        };
        /**
         * @example 174
         */
        entity: string;
      }[];
    };
    serie_174: {
      ipv4: string[];
      ipv6: string[];
      timestamps: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetBgpIpsTimeseriesVariables = {
  queryParams?: RadarGetBgpIpsTimeseriesQueryParams;
} & FetcherExtraProps;

/**
 * Get time series data for the announced IP space count, represented as the number of IPv4 /24s and IPv6 /48s, for a given ASN.
 */
export const radarGetBgpIpsTimeseries = (variables: RadarGetBgpIpsTimeseriesVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetBgpIpsTimeseriesResponse,
    RadarGetBgpIpsTimeseriesError,
    undefined,
    {},
    RadarGetBgpIpsTimeseriesQueryParams,
    {}
  >({ url: '/radar/bgp/ips/timeseries', method: 'get', ...variables, signal });

export type RadarGetBgpRouteLeakEventsQueryParams = {
  /**
   * Current page number, starting from 1
   */
  page?: number;
  /**
   * Number of entries per page
   */
  per_page?: number;
  /**
   * The unique identifier of a event
   */
  eventId?: number;
  /**
   * The leaking AS of a route leak event
   */
  leakAsn?: number;
  /**
   * ASN that is causing or affected by a route leak event
   */
  involvedAsn?: number;
  /**
   * Country code of a involved ASN in a route leak event
   */
  involvedCountry?: string;
  /**
   * Shorthand date ranges for the last X days - use when you don't need specific start and end dates.
   *
   * @example 7d
   * @pattern ^((([1-9]|[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-4])[d](control)?)|(([1-9]|[1-4][0-9]|5[0-2])[w](control)?))$
   */
  dateRange?: string;
  /**
   * Start of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   * @format date-time
   */
  dateStart?: string;
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   * @format date-time
   */
  dateEnd?: string;
  /**
   * Sort events by field
   *
   * @example TIME
   */
  sortBy?: 'ID' | 'LEAKS' | 'PEERS' | 'PREFIXES' | 'ORIGINS' | 'TIME';
  /**
   * Sort order
   *
   * @example DESC
   */
  sortOrder?: 'ASC' | 'DESC';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetBgpRouteLeakEventsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetBgpRouteLeakEventsResponse = {
  result: {
    asn_info: {
      asn: number;
      country_code: string;
      org_name: string;
    }[];
    events: {
      countries: string[];
      detected_ts: string;
      finished: boolean;
      id: number;
      leak_asn: number;
      leak_count: number;
      leak_seg: number[];
      leak_type: number;
      max_ts: string;
      min_ts: string;
      origin_count: number;
      peer_count: number;
      prefix_count: number;
    }[];
  };
  result_info: {
    count: number;
    page: number;
    per_page: number;
    total_count: number;
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetBgpRouteLeakEventsVariables = {
  queryParams?: RadarGetBgpRouteLeakEventsQueryParams;
} & FetcherExtraProps;

/**
 * Get the BGP route leak events (Beta).
 */
export const radarGetBgpRouteLeakEvents = (variables: RadarGetBgpRouteLeakEventsVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetBgpRouteLeakEventsResponse,
    RadarGetBgpRouteLeakEventsError,
    undefined,
    {},
    RadarGetBgpRouteLeakEventsQueryParams,
    {}
  >({ url: '/radar/bgp/leaks/events', method: 'get', ...variables, signal });

export type RadarGetBgpRoutesAsnsQueryParams = {
  /**
   * Location Alpha2 code.
   *
   * @example US
   */
  location?: string;
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Return order results by given type
   *
   * @example ipv4
   */
  sortBy?: 'cone' | 'pfxs' | 'ipv4' | 'ipv6' | 'rpki_valid' | 'rpki_invalid' | 'rpki_unknown';
  /**
   * Sort by value ascending or descending
   *
   * @default desc
   * @example desc
   */
  sortOrder?: 'asc' | 'desc';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetBgpRoutesAsnsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetBgpRoutesAsnsResponse = {
  result: {
    asns: {
      asn: number;
      /**
       * AS's customer cone size
       */
      coneSize: number;
      /**
       * 2-letter country code for the AS's registration country
       *
       * @example US
       */
      country: string;
      /**
       * number of IPv4 addresses originated by the AS
       */
      ipv4Count: number;
      /**
       * number of IPv6 addresses originated by the AS
       *
       * @example 1.21e24
       */
      ipv6Count: string;
      /**
       * name of the AS
       */
      name: string;
      /**
       * number of total IP prefixes originated by the AS
       */
      pfxsCount: number;
      /**
       * number of RPKI invalid prefixes originated by the AS
       */
      rpkiInvalid: number;
      /**
       * number of RPKI unknown prefixes originated by the AS
       */
      rpkiUnknown: number;
      /**
       * number of RPKI valid prefixes originated by the AS
       */
      rpkiValid: number;
    }[];
    meta: {
      /**
       * the timestamp of when the data is generated
       *
       * @example 2024-06-03T14:00:00
       */
      dataTime: string;
      /**
       * the timestamp of the query
       *
       * @example 2024-06-03T14:00:00
       */
      queryTime: string;
      /**
       * total number of route collector peers used to generate this data
       */
      totalPeers: number;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetBgpRoutesAsnsVariables = {
  queryParams?: RadarGetBgpRoutesAsnsQueryParams;
} & FetcherExtraProps;

/**
 * List all ASes in current global routing tables with routing statistics
 */
export const radarGetBgpRoutesAsns = (variables: RadarGetBgpRoutesAsnsVariables, signal?: AbortSignal) =>
  fetch<RadarGetBgpRoutesAsnsResponse, RadarGetBgpRoutesAsnsError, undefined, {}, RadarGetBgpRoutesAsnsQueryParams, {}>(
    { url: '/radar/bgp/routes/ases', method: 'get', ...variables, signal }
  );

export type RadarGetBgpPfx2asMoasQueryParams = {
  /**
   * Lookup MOASes originated by the given ASN
   */
  origin?: number;
  /**
   * Network prefix, IPv4 or IPv6.
   *
   * @example 1.1.1.0/24
   */
  prefix?: string;
  /**
   * Lookup only RPKI invalid MOASes
   */
  invalid_only?: boolean;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetBgpPfx2asMoasError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetBgpPfx2asMoasResponse = {
  result: {
    meta: {
      data_time: string;
      query_time: string;
      total_peers: number;
    };
    moas: {
      origins: {
        origin: number;
        peer_count: number;
        rpki_validation: string;
      }[];
      prefix: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetBgpPfx2asMoasVariables = {
  queryParams?: RadarGetBgpPfx2asMoasQueryParams;
} & FetcherExtraProps;

/**
 * List all Multi-Origin AS (MOAS) prefixes on the global routing tables.
 */
export const radarGetBgpPfx2asMoas = (variables: RadarGetBgpPfx2asMoasVariables, signal?: AbortSignal) =>
  fetch<RadarGetBgpPfx2asMoasResponse, RadarGetBgpPfx2asMoasError, undefined, {}, RadarGetBgpPfx2asMoasQueryParams, {}>(
    { url: '/radar/bgp/routes/moas', method: 'get', ...variables, signal }
  );

export type RadarGetBgpPfx2asQueryParams = {
  /**
   * Network prefix, IPv4 or IPv6.
   *
   * @example 1.1.1.0/24
   */
  prefix?: string;
  /**
   * Lookup prefixes originated by the given ASN
   */
  origin?: number;
  /**
   * Return only results with matching rpki status: valid, invalid or unknown
   *
   * @example INVALID
   */
  rpkiStatus?: 'VALID' | 'INVALID' | 'UNKNOWN';
  /**
   * Return only results with the longest prefix match for the given prefix. For example, specify a /32 prefix to lookup the origin ASN for an IPv4 address.
   *
   * @example true
   */
  longestPrefixMatch?: boolean;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetBgpPfx2asError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetBgpPfx2asResponse = {
  result: {
    meta: {
      data_time: string;
      query_time: string;
      total_peers: number;
    };
    prefix_origins: {
      origin: number;
      peer_count: number;
      prefix: string;
      rpki_validation: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetBgpPfx2asVariables = {
  queryParams?: RadarGetBgpPfx2asQueryParams;
} & FetcherExtraProps;

/**
 * Lookup prefix-to-ASN mapping on global routing tables.
 */
export const radarGetBgpPfx2as = (variables: RadarGetBgpPfx2asVariables, signal?: AbortSignal) =>
  fetch<RadarGetBgpPfx2asResponse, RadarGetBgpPfx2asError, undefined, {}, RadarGetBgpPfx2asQueryParams, {}>({
    url: '/radar/bgp/routes/pfx2as',
    method: 'get',
    ...variables,
    signal
  });

export type RadarGetBgpRoutesStatsQueryParams = {
  /**
   * Single ASN as integer.
   *
   * @example 174
   */
  asn?: number;
  /**
   * Location Alpha2 code.
   *
   * @example US
   */
  location?: string;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetBgpRoutesStatsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetBgpRoutesStatsResponse = {
  result: {
    meta: {
      data_time: string;
      query_time: string;
      total_peers: number;
    };
    stats: {
      distinct_origins: number;
      distinct_origins_ipv4: number;
      distinct_origins_ipv6: number;
      distinct_prefixes: number;
      distinct_prefixes_ipv4: number;
      distinct_prefixes_ipv6: number;
      routes_invalid: number;
      routes_invalid_ipv4: number;
      routes_invalid_ipv6: number;
      routes_total: number;
      routes_total_ipv4: number;
      routes_total_ipv6: number;
      routes_unknown: number;
      routes_unknown_ipv4: number;
      routes_unknown_ipv6: number;
      routes_valid: number;
      routes_valid_ipv4: number;
      routes_valid_ipv6: number;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetBgpRoutesStatsVariables = {
  queryParams?: RadarGetBgpRoutesStatsQueryParams;
} & FetcherExtraProps;

/**
 * Get the BGP routing table stats (Beta).
 */
export const radarGetBgpRoutesStats = (variables: RadarGetBgpRoutesStatsVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetBgpRoutesStatsResponse,
    RadarGetBgpRoutesStatsError,
    undefined,
    {},
    RadarGetBgpRoutesStatsQueryParams,
    {}
  >({ url: '/radar/bgp/routes/stats', method: 'get', ...variables, signal });

export type RadarGetBgpTimeseriesQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of BGP network prefixes.
   *
   * @example 1.1.1.0/24
   */
  prefix?: string[];
  /**
   * Array of BGP update types.
   *
   * @example ANNOUNCEMENT
   */
  updateType?: ('ANNOUNCEMENT' | 'WITHDRAWAL')[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetBgpTimeseriesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetBgpTimeseriesResponse = {
  result: {
    meta: {
      /**
       * @example 1h
       */
      aggInterval: string;
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @format date-time
       */
      lastUpdated: string;
    };
    serie_0: {
      timestamps: string[];
      values: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetBgpTimeseriesVariables = {
  queryParams?: RadarGetBgpTimeseriesQueryParams;
} & FetcherExtraProps;

/**
 * Get BGP updates change over time. Raw values are returned. When requesting updates for an autonomous system (AS), only BGP updates of type announcement are returned.
 */
export const radarGetBgpTimeseries = (variables: RadarGetBgpTimeseriesVariables, signal?: AbortSignal) =>
  fetch<RadarGetBgpTimeseriesResponse, RadarGetBgpTimeseriesError, undefined, {}, RadarGetBgpTimeseriesQueryParams, {}>(
    { url: '/radar/bgp/timeseries', method: 'get', ...variables, signal }
  );

export type RadarGetBgpTopAsesQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of BGP network prefixes.
   *
   * @example 1.1.1.0/24
   */
  prefix?: string[];
  /**
   * Array of BGP update types.
   *
   * @example ANNOUNCEMENT
   */
  updateType?: ('ANNOUNCEMENT' | 'WITHDRAWAL')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetBgpTopAsesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetBgpTopAsesResponse = {
  result: {
    meta: {
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
    };
    top_0: {
      /**
       * @example Apple-Engineering
       */
      ASName: string;
      /**
       * @example 714
       */
      asn: number;
      /**
       * Percentage of updates by this AS out of the total updates by all autonomous systems.
       *
       * @example 0.73996
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetBgpTopAsesVariables = {
  queryParams?: RadarGetBgpTopAsesQueryParams;
} & FetcherExtraProps;

/**
 * Get the top autonomous systems (ASes) by BGP updates (announcements only). Values are a percentage out of the total updates.
 */
export const radarGetBgpTopAses = (variables: RadarGetBgpTopAsesVariables, signal?: AbortSignal) =>
  fetch<RadarGetBgpTopAsesResponse, RadarGetBgpTopAsesError, undefined, {}, RadarGetBgpTopAsesQueryParams, {}>({
    url: '/radar/bgp/top/ases',
    method: 'get',
    ...variables,
    signal
  });

export type RadarGetBgpTopAsnsByPrefixesQueryParams = {
  /**
   * Alpha-2 country code.
   *
   * @example NZ
   */
  country?: string;
  /**
   * Maximum number of ASes to return
   *
   * @example 10
   */
  limit?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetBgpTopAsnsByPrefixesError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetBgpTopAsnsByPrefixesResponse = {
  result: {
    asns: {
      asn: number;
      country: string;
      name: string;
      pfxs_count: number;
    }[];
    meta: {
      data_time: string;
      query_time: string;
      total_peers: number;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetBgpTopAsnsByPrefixesVariables = {
  queryParams?: RadarGetBgpTopAsnsByPrefixesQueryParams;
} & FetcherExtraProps;

/**
 * Get the full list of autonomous systems on the global routing table ordered by announced prefixes count. The data comes from public BGP MRT data archives and updates every 2 hours.
 */
export const radarGetBgpTopAsnsByPrefixes = (variables: RadarGetBgpTopAsnsByPrefixesVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetBgpTopAsnsByPrefixesResponse,
    RadarGetBgpTopAsnsByPrefixesError,
    undefined,
    {},
    RadarGetBgpTopAsnsByPrefixesQueryParams,
    {}
  >({ url: '/radar/bgp/top/ases/prefixes', method: 'get', ...variables, signal });

export type RadarGetBgpTopPrefixesQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of BGP update types.
   *
   * @example ANNOUNCEMENT
   */
  updateType?: ('ANNOUNCEMENT' | 'WITHDRAWAL')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetBgpTopPrefixesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetBgpTopPrefixesResponse = {
  result: {
    meta: {
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
    };
    top_0: {
      /**
       * @example 2804:77cc:8000::/33
       */
      prefix: string;
      /**
       * @example 0.73996
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetBgpTopPrefixesVariables = {
  queryParams?: RadarGetBgpTopPrefixesQueryParams;
} & FetcherExtraProps;

/**
 * Get the top network prefixes by BGP updates. Values are a percentage out of the total BGP updates.
 */
export const radarGetBgpTopPrefixes = (variables: RadarGetBgpTopPrefixesVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetBgpTopPrefixesResponse,
    RadarGetBgpTopPrefixesError,
    undefined,
    {},
    RadarGetBgpTopPrefixesQueryParams,
    {}
  >({ url: '/radar/bgp/top/prefixes', method: 'get', ...variables, signal });

export type RadarGetReportsDatasetsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Number of objects to skip before grabbing results.
   */
  offset?: number;
  /**
   * Dataset type.
   *
   * @default RANKING_BUCKET
   * @example RANKING_BUCKET
   */
  datasetType?: 'RANKING_BUCKET' | 'REPORT';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetReportsDatasetsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetReportsDatasetsResponse = {
  result: {
    datasets: {
      /**
       * @example This dataset contains a list of the op 20000 domains globally
       */
      description: string;
      /**
       * @example 3
       */
      id: number;
      meta: Record<string, any>;
      tags: string[];
      /**
       * @example Top bucket 20000 domains
       */
      title: string;
      /**
       * @example RANKING_BUCKET
       */
      type: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetReportsDatasetsVariables = {
  queryParams?: RadarGetReportsDatasetsQueryParams;
} & FetcherExtraProps;

/**
 * Get a list of datasets.
 */
export const radarGetReportsDatasets = (variables: RadarGetReportsDatasetsVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetReportsDatasetsResponse,
    RadarGetReportsDatasetsError,
    undefined,
    {},
    RadarGetReportsDatasetsQueryParams,
    {}
  >({ url: '/radar/datasets', method: 'get', ...variables, signal });

export type RadarPostReportsDatasetDownloadUrlQueryParams = {
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarPostReportsDatasetDownloadUrlError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarPostReportsDatasetDownloadUrlResponse = {
  result: {
    dataset: {
      /**
       * @example https://example.com/download
       */
      url: string;
    };
  };
};

export type RadarPostReportsDatasetDownloadUrlRequestBody = {
  /**
   * @example 3
   */
  datasetId: number;
};

export type RadarPostReportsDatasetDownloadUrlVariables = {
  body: RadarPostReportsDatasetDownloadUrlRequestBody;
  queryParams?: RadarPostReportsDatasetDownloadUrlQueryParams;
} & FetcherExtraProps;

/**
 * Get a url to download a single dataset.
 */
export const radarPostReportsDatasetDownloadUrl = (
  variables: RadarPostReportsDatasetDownloadUrlVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarPostReportsDatasetDownloadUrlResponse,
    RadarPostReportsDatasetDownloadUrlError,
    RadarPostReportsDatasetDownloadUrlRequestBody,
    {},
    RadarPostReportsDatasetDownloadUrlQueryParams,
    {}
  >({ url: '/radar/datasets/download', method: 'post', ...variables, signal });

export type RadarGetReportsDatasetDownloadPathParams = {
  /**
   * Dataset alias or id
   *
   * @example ranking_top_1000
   */
  alias: string;
};

export type RadarGetReportsDatasetDownloadError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetReportsDatasetDownloadVariables = {
  pathParams: RadarGetReportsDatasetDownloadPathParams;
} & FetcherExtraProps;

/**
 * Get the CSV content of a given dataset by alias or ID. When getting the content by alias the latest dataset is returned, optionally filtered by the latest available at a given date.
 */
export const radarGetReportsDatasetDownload = (
  variables: RadarGetReportsDatasetDownloadVariables,
  signal?: AbortSignal
) =>
  fetch<undefined, RadarGetReportsDatasetDownloadError, undefined, {}, {}, RadarGetReportsDatasetDownloadPathParams>({
    url: '/radar/datasets/{alias}',
    method: 'get',
    ...variables,
    signal
  });

export type RadarGetDnsTopAsesQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * Array of domain names.
   *
   * @example google.com
   */
  domain: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsTopAsesError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetDnsTopAsesResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
    };
    top_0: {
      /**
       * @example 174
       */
      clientASN: number;
      /**
       * @example Cogent-174
       */
      clientASName: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsTopAsesVariables = {
  queryParams: RadarGetDnsTopAsesQueryParams;
} & FetcherExtraProps;

/**
 * Get top autonomous systems by DNS queries made to Cloudflare's public DNS resolver.
 */
export const radarGetDnsTopAses = (variables: RadarGetDnsTopAsesVariables, signal?: AbortSignal) =>
  fetch<RadarGetDnsTopAsesResponse, RadarGetDnsTopAsesError, undefined, {}, RadarGetDnsTopAsesQueryParams, {}>({
    url: '/radar/dns/top/ases',
    method: 'get',
    ...variables,
    signal
  });

export type RadarGetDnsTopLocationsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * Array of domain names.
   *
   * @example google.com
   */
  domain: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetDnsTopLocationsError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetDnsTopLocationsResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
    };
    top_0: {
      /**
       * @example PT
       */
      clientCountryAlpha2: string;
      /**
       * @example Portugal
       */
      clientCountryName: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetDnsTopLocationsVariables = {
  queryParams: RadarGetDnsTopLocationsQueryParams;
} & FetcherExtraProps;

/**
 * Get top locations by DNS queries made to Cloudflare's public DNS resolver.
 */
export const radarGetDnsTopLocations = (variables: RadarGetDnsTopLocationsVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetDnsTopLocationsResponse,
    RadarGetDnsTopLocationsError,
    undefined,
    {},
    RadarGetDnsTopLocationsQueryParams,
    {}
  >({ url: '/radar/dns/top/locations', method: 'get', ...variables, signal });

export type RadarGetEmailRoutingSummaryByArcQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for encrypted emails.
   *
   * @example ENCRYPTED
   */
  encrypted?: ('ENCRYPTED' | 'NOT_ENCRYPTED')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailRoutingSummaryByArcError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailRoutingSummaryByArcResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 2
       */
      FAIL: string;
      /**
       * @example 53
       */
      NONE: string;
      /**
       * @example 45
       */
      PASS: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailRoutingSummaryByArcVariables = {
  queryParams?: RadarGetEmailRoutingSummaryByArcQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by ARC validation.
 */
export const radarGetEmailRoutingSummaryByArc = (
  variables: RadarGetEmailRoutingSummaryByArcVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailRoutingSummaryByArcResponse,
    RadarGetEmailRoutingSummaryByArcError,
    undefined,
    {},
    RadarGetEmailRoutingSummaryByArcQueryParams,
    {}
  >({ url: '/radar/email/routing/summary/arc', method: 'get', ...variables, signal });

export type RadarGetEmailRoutingSummaryByDkimQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for encrypted emails.
   *
   * @example ENCRYPTED
   */
  encrypted?: ('ENCRYPTED' | 'NOT_ENCRYPTED')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailRoutingSummaryByDkimError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailRoutingSummaryByDkimResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 2
       */
      FAIL: string;
      /**
       * @example 53
       */
      NONE: string;
      /**
       * @example 45
       */
      PASS: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailRoutingSummaryByDkimVariables = {
  queryParams?: RadarGetEmailRoutingSummaryByDkimQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by DKIM validation.
 */
export const radarGetEmailRoutingSummaryByDkim = (
  variables: RadarGetEmailRoutingSummaryByDkimVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailRoutingSummaryByDkimResponse,
    RadarGetEmailRoutingSummaryByDkimError,
    undefined,
    {},
    RadarGetEmailRoutingSummaryByDkimQueryParams,
    {}
  >({ url: '/radar/email/routing/summary/dkim', method: 'get', ...variables, signal });

export type RadarGetEmailRoutingSummaryByDmarcQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for encrypted emails.
   *
   * @example ENCRYPTED
   */
  encrypted?: ('ENCRYPTED' | 'NOT_ENCRYPTED')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailRoutingSummaryByDmarcError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailRoutingSummaryByDmarcResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 2
       */
      FAIL: string;
      /**
       * @example 53
       */
      NONE: string;
      /**
       * @example 45
       */
      PASS: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailRoutingSummaryByDmarcVariables = {
  queryParams?: RadarGetEmailRoutingSummaryByDmarcQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by DMARC validation.
 */
export const radarGetEmailRoutingSummaryByDmarc = (
  variables: RadarGetEmailRoutingSummaryByDmarcVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailRoutingSummaryByDmarcResponse,
    RadarGetEmailRoutingSummaryByDmarcError,
    undefined,
    {},
    RadarGetEmailRoutingSummaryByDmarcQueryParams,
    {}
  >({ url: '/radar/email/routing/summary/dmarc', method: 'get', ...variables, signal });

export type RadarGetEmailRoutingSummaryByEncryptedQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailRoutingSummaryByEncryptedError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailRoutingSummaryByEncryptedResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 65
       */
      ENCRYPTED: string;
      /**
       * @example 35
       */
      NOT_ENCRYPTED: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailRoutingSummaryByEncryptedVariables = {
  queryParams?: RadarGetEmailRoutingSummaryByEncryptedQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails by encryption status.
 */
export const radarGetEmailRoutingSummaryByEncrypted = (
  variables: RadarGetEmailRoutingSummaryByEncryptedVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailRoutingSummaryByEncryptedResponse,
    RadarGetEmailRoutingSummaryByEncryptedError,
    undefined,
    {},
    RadarGetEmailRoutingSummaryByEncryptedQueryParams,
    {}
  >({ url: '/radar/email/routing/summary/encrypted', method: 'get', ...variables, signal });

export type RadarGetEmailRoutingSummaryByIpVersionQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for encrypted emails.
   *
   * @example ENCRYPTED
   */
  encrypted?: ('ENCRYPTED' | 'NOT_ENCRYPTED')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailRoutingSummaryByIpVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailRoutingSummaryByIpVersionResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 65
       */
      IPv4: string;
      /**
       * @example 35
       */
      IPv6: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailRoutingSummaryByIpVersionVariables = {
  queryParams?: RadarGetEmailRoutingSummaryByIpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails by IP version.
 */
export const radarGetEmailRoutingSummaryByIpVersion = (
  variables: RadarGetEmailRoutingSummaryByIpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailRoutingSummaryByIpVersionResponse,
    RadarGetEmailRoutingSummaryByIpVersionError,
    undefined,
    {},
    RadarGetEmailRoutingSummaryByIpVersionQueryParams,
    {}
  >({ url: '/radar/email/routing/summary/ip_version', method: 'get', ...variables, signal });

export type RadarGetEmailRoutingSummaryBySpfQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for encrypted emails.
   *
   * @example ENCRYPTED
   */
  encrypted?: ('ENCRYPTED' | 'NOT_ENCRYPTED')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailRoutingSummaryBySpfError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailRoutingSummaryBySpfResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 2
       */
      FAIL: string;
      /**
       * @example 53
       */
      NONE: string;
      /**
       * @example 45
       */
      PASS: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailRoutingSummaryBySpfVariables = {
  queryParams?: RadarGetEmailRoutingSummaryBySpfQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by SPF validation.
 */
export const radarGetEmailRoutingSummaryBySpf = (
  variables: RadarGetEmailRoutingSummaryBySpfVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailRoutingSummaryBySpfResponse,
    RadarGetEmailRoutingSummaryBySpfError,
    undefined,
    {},
    RadarGetEmailRoutingSummaryBySpfQueryParams,
    {}
  >({ url: '/radar/email/routing/summary/spf', method: 'get', ...variables, signal });

export type RadarGetEmailRoutingTimeseriesGroupByArcQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for encrypted emails.
   *
   * @example ENCRYPTED
   */
  encrypted?: ('ENCRYPTED' | 'NOT_ENCRYPTED')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailRoutingTimeseriesGroupByArcError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailRoutingTimeseriesGroupByArcResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      FAIL: string[];
      NONE: string[];
      PASS: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailRoutingTimeseriesGroupByArcVariables = {
  queryParams?: RadarGetEmailRoutingTimeseriesGroupByArcQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by ARC validation over time.
 */
export const radarGetEmailRoutingTimeseriesGroupByArc = (
  variables: RadarGetEmailRoutingTimeseriesGroupByArcVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailRoutingTimeseriesGroupByArcResponse,
    RadarGetEmailRoutingTimeseriesGroupByArcError,
    undefined,
    {},
    RadarGetEmailRoutingTimeseriesGroupByArcQueryParams,
    {}
  >({ url: '/radar/email/routing/timeseries_groups/arc', method: 'get', ...variables, signal });

export type RadarGetEmailRoutingTimeseriesGroupByDkimQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for encrypted emails.
   *
   * @example ENCRYPTED
   */
  encrypted?: ('ENCRYPTED' | 'NOT_ENCRYPTED')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailRoutingTimeseriesGroupByDkimError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailRoutingTimeseriesGroupByDkimResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      FAIL: string[];
      NONE: string[];
      PASS: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailRoutingTimeseriesGroupByDkimVariables = {
  queryParams?: RadarGetEmailRoutingTimeseriesGroupByDkimQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by DKIM validation over time.
 */
export const radarGetEmailRoutingTimeseriesGroupByDkim = (
  variables: RadarGetEmailRoutingTimeseriesGroupByDkimVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailRoutingTimeseriesGroupByDkimResponse,
    RadarGetEmailRoutingTimeseriesGroupByDkimError,
    undefined,
    {},
    RadarGetEmailRoutingTimeseriesGroupByDkimQueryParams,
    {}
  >({ url: '/radar/email/routing/timeseries_groups/dkim', method: 'get', ...variables, signal });

export type RadarGetEmailRoutingTimeseriesGroupByDmarcQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for encrypted emails.
   *
   * @example ENCRYPTED
   */
  encrypted?: ('ENCRYPTED' | 'NOT_ENCRYPTED')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailRoutingTimeseriesGroupByDmarcError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailRoutingTimeseriesGroupByDmarcResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      FAIL: string[];
      NONE: string[];
      PASS: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailRoutingTimeseriesGroupByDmarcVariables = {
  queryParams?: RadarGetEmailRoutingTimeseriesGroupByDmarcQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by DMARC validation over time.
 */
export const radarGetEmailRoutingTimeseriesGroupByDmarc = (
  variables: RadarGetEmailRoutingTimeseriesGroupByDmarcVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailRoutingTimeseriesGroupByDmarcResponse,
    RadarGetEmailRoutingTimeseriesGroupByDmarcError,
    undefined,
    {},
    RadarGetEmailRoutingTimeseriesGroupByDmarcQueryParams,
    {}
  >({ url: '/radar/email/routing/timeseries_groups/dmarc', method: 'get', ...variables, signal });

export type RadarGetEmailRoutingTimeseriesGroupByEncryptedQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailRoutingTimeseriesGroupByEncryptedError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailRoutingTimeseriesGroupByEncryptedResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      ENCRYPTED: string[];
      NOT_ENCRYPTED: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailRoutingTimeseriesGroupByEncryptedVariables = {
  queryParams?: RadarGetEmailRoutingTimeseriesGroupByEncryptedQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails by encryption status over time.
 */
export const radarGetEmailRoutingTimeseriesGroupByEncrypted = (
  variables: RadarGetEmailRoutingTimeseriesGroupByEncryptedVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailRoutingTimeseriesGroupByEncryptedResponse,
    RadarGetEmailRoutingTimeseriesGroupByEncryptedError,
    undefined,
    {},
    RadarGetEmailRoutingTimeseriesGroupByEncryptedQueryParams,
    {}
  >({ url: '/radar/email/routing/timeseries_groups/encrypted', method: 'get', ...variables, signal });

export type RadarGetEmailRoutingTimeseriesGroupByIpVersionQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for encrypted emails.
   *
   * @example ENCRYPTED
   */
  encrypted?: ('ENCRYPTED' | 'NOT_ENCRYPTED')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailRoutingTimeseriesGroupByIpVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailRoutingTimeseriesGroupByIpVersionResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      IPv4: string[];
      IPv6: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailRoutingTimeseriesGroupByIpVersionVariables = {
  queryParams?: RadarGetEmailRoutingTimeseriesGroupByIpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails by IP version over time.
 */
export const radarGetEmailRoutingTimeseriesGroupByIpVersion = (
  variables: RadarGetEmailRoutingTimeseriesGroupByIpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailRoutingTimeseriesGroupByIpVersionResponse,
    RadarGetEmailRoutingTimeseriesGroupByIpVersionError,
    undefined,
    {},
    RadarGetEmailRoutingTimeseriesGroupByIpVersionQueryParams,
    {}
  >({ url: '/radar/email/routing/timeseries_groups/ip_version', method: 'get', ...variables, signal });

export type RadarGetEmailRoutingTimeseriesGroupBySpfQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for encrypted emails.
   *
   * @example ENCRYPTED
   */
  encrypted?: ('ENCRYPTED' | 'NOT_ENCRYPTED')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailRoutingTimeseriesGroupBySpfError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailRoutingTimeseriesGroupBySpfResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      FAIL: string[];
      NONE: string[];
      PASS: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailRoutingTimeseriesGroupBySpfVariables = {
  queryParams?: RadarGetEmailRoutingTimeseriesGroupBySpfQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by SPF validation over time.
 */
export const radarGetEmailRoutingTimeseriesGroupBySpf = (
  variables: RadarGetEmailRoutingTimeseriesGroupBySpfVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailRoutingTimeseriesGroupBySpfResponse,
    RadarGetEmailRoutingTimeseriesGroupBySpfError,
    undefined,
    {},
    RadarGetEmailRoutingTimeseriesGroupBySpfQueryParams,
    {}
  >({ url: '/radar/email/routing/timeseries_groups/spf', method: 'get', ...variables, signal });

export type RadarGetEmailSecuritySummaryByArcQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecuritySummaryByArcError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailSecuritySummaryByArcResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 2
       */
      FAIL: string;
      /**
       * @example 53
       */
      NONE: string;
      /**
       * @example 45
       */
      PASS: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecuritySummaryByArcVariables = {
  queryParams?: RadarGetEmailSecuritySummaryByArcQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by ARC validation.
 */
export const radarGetEmailSecuritySummaryByArc = (
  variables: RadarGetEmailSecuritySummaryByArcVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecuritySummaryByArcResponse,
    RadarGetEmailSecuritySummaryByArcError,
    undefined,
    {},
    RadarGetEmailSecuritySummaryByArcQueryParams,
    {}
  >({ url: '/radar/email/security/summary/arc', method: 'get', ...variables, signal });

export type RadarGetEmailSecuritySummaryByDkimQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecuritySummaryByDkimError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailSecuritySummaryByDkimResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 2
       */
      FAIL: string;
      /**
       * @example 53
       */
      NONE: string;
      /**
       * @example 45
       */
      PASS: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecuritySummaryByDkimVariables = {
  queryParams?: RadarGetEmailSecuritySummaryByDkimQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by DKIM validation.
 */
export const radarGetEmailSecuritySummaryByDkim = (
  variables: RadarGetEmailSecuritySummaryByDkimVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecuritySummaryByDkimResponse,
    RadarGetEmailSecuritySummaryByDkimError,
    undefined,
    {},
    RadarGetEmailSecuritySummaryByDkimQueryParams,
    {}
  >({ url: '/radar/email/security/summary/dkim', method: 'get', ...variables, signal });

export type RadarGetEmailSecuritySummaryByDmarcQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecuritySummaryByDmarcError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailSecuritySummaryByDmarcResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 2
       */
      FAIL: string;
      /**
       * @example 53
       */
      NONE: string;
      /**
       * @example 45
       */
      PASS: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecuritySummaryByDmarcVariables = {
  queryParams?: RadarGetEmailSecuritySummaryByDmarcQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by DMARC validation.
 */
export const radarGetEmailSecuritySummaryByDmarc = (
  variables: RadarGetEmailSecuritySummaryByDmarcVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecuritySummaryByDmarcResponse,
    RadarGetEmailSecuritySummaryByDmarcError,
    undefined,
    {},
    RadarGetEmailSecuritySummaryByDmarcQueryParams,
    {}
  >({ url: '/radar/email/security/summary/dmarc', method: 'get', ...variables, signal });

export type RadarGetEmailSecuritySummaryByMaliciousQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecuritySummaryByMaliciousError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailSecuritySummaryByMaliciousResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 65
       */
      MALICIOUS: string;
      /**
       * @example 35
       */
      NOT_MALICIOUS: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecuritySummaryByMaliciousVariables = {
  queryParams?: RadarGetEmailSecuritySummaryByMaliciousQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified as MALICIOUS.
 */
export const radarGetEmailSecuritySummaryByMalicious = (
  variables: RadarGetEmailSecuritySummaryByMaliciousVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecuritySummaryByMaliciousResponse,
    RadarGetEmailSecuritySummaryByMaliciousError,
    undefined,
    {},
    RadarGetEmailSecuritySummaryByMaliciousQueryParams,
    {}
  >({ url: '/radar/email/security/summary/malicious', method: 'get', ...variables, signal });

export type RadarGetEmailSecuritySummaryBySpamQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecuritySummaryBySpamError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailSecuritySummaryBySpamResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 35
       */
      NOT_SPAM: string;
      /**
       * @example 65
       */
      SPAM: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecuritySummaryBySpamVariables = {
  queryParams?: RadarGetEmailSecuritySummaryBySpamQueryParams;
} & FetcherExtraProps;

/**
 * Proportion of emails categorized as either spam or legitimate (non-spam).
 */
export const radarGetEmailSecuritySummaryBySpam = (
  variables: RadarGetEmailSecuritySummaryBySpamVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecuritySummaryBySpamResponse,
    RadarGetEmailSecuritySummaryBySpamError,
    undefined,
    {},
    RadarGetEmailSecuritySummaryBySpamQueryParams,
    {}
  >({ url: '/radar/email/security/summary/spam', method: 'get', ...variables, signal });

export type RadarGetEmailSecuritySummaryBySpfQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecuritySummaryBySpfError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailSecuritySummaryBySpfResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 2
       */
      FAIL: string;
      /**
       * @example 53
       */
      NONE: string;
      /**
       * @example 45
       */
      PASS: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecuritySummaryBySpfVariables = {
  queryParams?: RadarGetEmailSecuritySummaryBySpfQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by SPF validation.
 */
export const radarGetEmailSecuritySummaryBySpf = (
  variables: RadarGetEmailSecuritySummaryBySpfVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecuritySummaryBySpfResponse,
    RadarGetEmailSecuritySummaryBySpfError,
    undefined,
    {},
    RadarGetEmailSecuritySummaryBySpfQueryParams,
    {}
  >({ url: '/radar/email/security/summary/spf', method: 'get', ...variables, signal });

export type RadarGetEmailSecuritySummaryBySpoofQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecuritySummaryBySpoofError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailSecuritySummaryBySpoofResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 35
       */
      NOT_SPOOF: string;
      /**
       * @example 65
       */
      SPOOF: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecuritySummaryBySpoofVariables = {
  queryParams?: RadarGetEmailSecuritySummaryBySpoofQueryParams;
} & FetcherExtraProps;

/**
 * Proportion of emails categorized as either spoof or legitimate (non-spoof).
 */
export const radarGetEmailSecuritySummaryBySpoof = (
  variables: RadarGetEmailSecuritySummaryBySpoofVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecuritySummaryBySpoofResponse,
    RadarGetEmailSecuritySummaryBySpoofError,
    undefined,
    {},
    RadarGetEmailSecuritySummaryBySpoofQueryParams,
    {}
  >({ url: '/radar/email/security/summary/spoof', method: 'get', ...variables, signal });

export type RadarGetEmailSecuritySummaryByThreatCategoryQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecuritySummaryByThreatCategoryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailSecuritySummaryByThreatCategoryResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 35
       */
      BrandImpersonation: string;
      /**
       * @example 32
       */
      CredentialHarvester: string;
      /**
       * @example 47
       */
      IdentityDeception: string;
      /**
       * @example 43
       */
      Link: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecuritySummaryByThreatCategoryVariables = {
  queryParams?: RadarGetEmailSecuritySummaryByThreatCategoryQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified in Threat Categories.
 */
export const radarGetEmailSecuritySummaryByThreatCategory = (
  variables: RadarGetEmailSecuritySummaryByThreatCategoryVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecuritySummaryByThreatCategoryResponse,
    RadarGetEmailSecuritySummaryByThreatCategoryError,
    undefined,
    {},
    RadarGetEmailSecuritySummaryByThreatCategoryQueryParams,
    {}
  >({ url: '/radar/email/security/summary/threat_category', method: 'get', ...variables, signal });

export type RadarGetEmailSecuritySummaryByTlsVersionQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecuritySummaryByTlsVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailSecuritySummaryByTlsVersionResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 3
       */
      ['TLS 1.0']: string;
      /**
       * @example 12
       */
      ['TLS 1.1']: string;
      /**
       * @example 41
       */
      ['TLS 1.2']: string;
      /**
       * @example 44
       */
      ['TLS 1.3']: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecuritySummaryByTlsVersionVariables = {
  queryParams?: RadarGetEmailSecuritySummaryByTlsVersionQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by TLS version.
 */
export const radarGetEmailSecuritySummaryByTlsVersion = (
  variables: RadarGetEmailSecuritySummaryByTlsVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecuritySummaryByTlsVersionResponse,
    RadarGetEmailSecuritySummaryByTlsVersionError,
    undefined,
    {},
    RadarGetEmailSecuritySummaryByTlsVersionQueryParams,
    {}
  >({ url: '/radar/email/security/summary/tls_version', method: 'get', ...variables, signal });

export type RadarGetEmailSecurityTimeseriesGroupByArcQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecurityTimeseriesGroupByArcError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailSecurityTimeseriesGroupByArcResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      FAIL: string[];
      NONE: string[];
      PASS: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecurityTimeseriesGroupByArcVariables = {
  queryParams?: RadarGetEmailSecurityTimeseriesGroupByArcQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by ARC validation over time.
 */
export const radarGetEmailSecurityTimeseriesGroupByArc = (
  variables: RadarGetEmailSecurityTimeseriesGroupByArcVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecurityTimeseriesGroupByArcResponse,
    RadarGetEmailSecurityTimeseriesGroupByArcError,
    undefined,
    {},
    RadarGetEmailSecurityTimeseriesGroupByArcQueryParams,
    {}
  >({ url: '/radar/email/security/timeseries_groups/arc', method: 'get', ...variables, signal });

export type RadarGetEmailSecurityTimeseriesGroupByDkimQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecurityTimeseriesGroupByDkimError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailSecurityTimeseriesGroupByDkimResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      FAIL: string[];
      NONE: string[];
      PASS: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecurityTimeseriesGroupByDkimVariables = {
  queryParams?: RadarGetEmailSecurityTimeseriesGroupByDkimQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by DKIM validation over time.
 */
export const radarGetEmailSecurityTimeseriesGroupByDkim = (
  variables: RadarGetEmailSecurityTimeseriesGroupByDkimVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecurityTimeseriesGroupByDkimResponse,
    RadarGetEmailSecurityTimeseriesGroupByDkimError,
    undefined,
    {},
    RadarGetEmailSecurityTimeseriesGroupByDkimQueryParams,
    {}
  >({ url: '/radar/email/security/timeseries_groups/dkim', method: 'get', ...variables, signal });

export type RadarGetEmailSecurityTimeseriesGroupByDmarcQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecurityTimeseriesGroupByDmarcError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailSecurityTimeseriesGroupByDmarcResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      FAIL: string[];
      NONE: string[];
      PASS: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecurityTimeseriesGroupByDmarcVariables = {
  queryParams?: RadarGetEmailSecurityTimeseriesGroupByDmarcQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by DMARC validation over time.
 */
export const radarGetEmailSecurityTimeseriesGroupByDmarc = (
  variables: RadarGetEmailSecurityTimeseriesGroupByDmarcVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecurityTimeseriesGroupByDmarcResponse,
    RadarGetEmailSecurityTimeseriesGroupByDmarcError,
    undefined,
    {},
    RadarGetEmailSecurityTimeseriesGroupByDmarcQueryParams,
    {}
  >({ url: '/radar/email/security/timeseries_groups/dmarc', method: 'get', ...variables, signal });

export type RadarGetEmailSecurityTimeseriesGroupByMaliciousQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecurityTimeseriesGroupByMaliciousError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailSecurityTimeseriesGroupByMaliciousResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      MALICIOUS: string[];
      NOT_MALICIOUS: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecurityTimeseriesGroupByMaliciousVariables = {
  queryParams?: RadarGetEmailSecurityTimeseriesGroupByMaliciousQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified as MALICIOUS over time.
 */
export const radarGetEmailSecurityTimeseriesGroupByMalicious = (
  variables: RadarGetEmailSecurityTimeseriesGroupByMaliciousVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecurityTimeseriesGroupByMaliciousResponse,
    RadarGetEmailSecurityTimeseriesGroupByMaliciousError,
    undefined,
    {},
    RadarGetEmailSecurityTimeseriesGroupByMaliciousQueryParams,
    {}
  >({ url: '/radar/email/security/timeseries_groups/malicious', method: 'get', ...variables, signal });

export type RadarGetEmailSecurityTimeseriesGroupBySpamQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecurityTimeseriesGroupBySpamError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailSecurityTimeseriesGroupBySpamResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      NOT_SPAM: string[];
      SPAM: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecurityTimeseriesGroupBySpamVariables = {
  queryParams?: RadarGetEmailSecurityTimeseriesGroupBySpamQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified as SPAM over time.
 */
export const radarGetEmailSecurityTimeseriesGroupBySpam = (
  variables: RadarGetEmailSecurityTimeseriesGroupBySpamVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecurityTimeseriesGroupBySpamResponse,
    RadarGetEmailSecurityTimeseriesGroupBySpamError,
    undefined,
    {},
    RadarGetEmailSecurityTimeseriesGroupBySpamQueryParams,
    {}
  >({ url: '/radar/email/security/timeseries_groups/spam', method: 'get', ...variables, signal });

export type RadarGetEmailSecurityTimeseriesGroupBySpfQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecurityTimeseriesGroupBySpfError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailSecurityTimeseriesGroupBySpfResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      FAIL: string[];
      NONE: string[];
      PASS: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecurityTimeseriesGroupBySpfVariables = {
  queryParams?: RadarGetEmailSecurityTimeseriesGroupBySpfQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by SPF validation over time.
 */
export const radarGetEmailSecurityTimeseriesGroupBySpf = (
  variables: RadarGetEmailSecurityTimeseriesGroupBySpfVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecurityTimeseriesGroupBySpfResponse,
    RadarGetEmailSecurityTimeseriesGroupBySpfError,
    undefined,
    {},
    RadarGetEmailSecurityTimeseriesGroupBySpfQueryParams,
    {}
  >({ url: '/radar/email/security/timeseries_groups/spf', method: 'get', ...variables, signal });

export type RadarGetEmailSecurityTimeseriesGroupBySpoofQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecurityTimeseriesGroupBySpoofError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailSecurityTimeseriesGroupBySpoofResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      NOT_SPOOF: string[];
      SPOOF: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecurityTimeseriesGroupBySpoofVariables = {
  queryParams?: RadarGetEmailSecurityTimeseriesGroupBySpoofQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified as SPOOF over time.
 */
export const radarGetEmailSecurityTimeseriesGroupBySpoof = (
  variables: RadarGetEmailSecurityTimeseriesGroupBySpoofVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecurityTimeseriesGroupBySpoofResponse,
    RadarGetEmailSecurityTimeseriesGroupBySpoofError,
    undefined,
    {},
    RadarGetEmailSecurityTimeseriesGroupBySpoofQueryParams,
    {}
  >({ url: '/radar/email/security/timeseries_groups/spoof', method: 'get', ...variables, signal });

export type RadarGetEmailSecurityTimeseriesGroupByThreatCategoryQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecurityTimeseriesGroupByThreatCategoryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailSecurityTimeseriesGroupByThreatCategoryResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      BrandImpersonation: string[];
      CredentialHarvester: string[];
      IdentityDeception: string[];
      Link: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecurityTimeseriesGroupByThreatCategoryVariables = {
  queryParams?: RadarGetEmailSecurityTimeseriesGroupByThreatCategoryQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by threat category over time.
 */
export const radarGetEmailSecurityTimeseriesGroupByThreatCategory = (
  variables: RadarGetEmailSecurityTimeseriesGroupByThreatCategoryVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecurityTimeseriesGroupByThreatCategoryResponse,
    RadarGetEmailSecurityTimeseriesGroupByThreatCategoryError,
    undefined,
    {},
    RadarGetEmailSecurityTimeseriesGroupByThreatCategoryQueryParams,
    {}
  >({ url: '/radar/email/security/timeseries_groups/threat_category', method: 'get', ...variables, signal });

export type RadarGetEmailSecurityTimeseriesGroupByTlsVersionQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecurityTimeseriesGroupByTlsVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEmailSecurityTimeseriesGroupByTlsVersionResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      ['TLS 1.0']: string[];
      ['TLS 1.1']: string[];
      ['TLS 1.2']: string[];
      ['TLS 1.3']: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecurityTimeseriesGroupByTlsVersionVariables = {
  queryParams?: RadarGetEmailSecurityTimeseriesGroupByTlsVersionQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of emails classified by TLS version over time.
 */
export const radarGetEmailSecurityTimeseriesGroupByTlsVersion = (
  variables: RadarGetEmailSecurityTimeseriesGroupByTlsVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecurityTimeseriesGroupByTlsVersionResponse,
    RadarGetEmailSecurityTimeseriesGroupByTlsVersionError,
    undefined,
    {},
    RadarGetEmailSecurityTimeseriesGroupByTlsVersionQueryParams,
    {}
  >({ url: '/radar/email/security/timeseries_groups/tls_version', method: 'get', ...variables, signal });

export type RadarGetEmailSecurityTopTldsByMessagesQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Filter for TLDs by category.
   *
   * @example CLASSIC
   */
  tldCategory?: 'CLASSIC' | 'COUNTRY';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecurityTopTldsByMessagesError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetEmailSecurityTopTldsByMessagesResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example com.
       */
      name: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecurityTopTldsByMessagesVariables = {
  queryParams?: RadarGetEmailSecurityTopTldsByMessagesQueryParams;
} & FetcherExtraProps;

/**
 * Get the top TLDs by email messages. Values are a percentage out of total email volume.
 */
export const radarGetEmailSecurityTopTldsByMessages = (
  variables: RadarGetEmailSecurityTopTldsByMessagesVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecurityTopTldsByMessagesResponse,
    RadarGetEmailSecurityTopTldsByMessagesError,
    undefined,
    {},
    RadarGetEmailSecurityTopTldsByMessagesQueryParams,
    {}
  >({ url: '/radar/email/security/top/tlds', method: 'get', ...variables, signal });

export type RadarGetEmailSecurityTopTldsByMaliciousPathParams = {
  /**
   * Malicious.
   *
   * @example MALICIOUS
   */
  malicious: 'MALICIOUS' | 'NOT_MALICIOUS';
};

export type RadarGetEmailSecurityTopTldsByMaliciousQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Filter for TLDs by category.
   *
   * @example CLASSIC
   */
  tldCategory?: 'CLASSIC' | 'COUNTRY';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecurityTopTldsByMaliciousError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetEmailSecurityTopTldsByMaliciousResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example com.
       */
      name: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecurityTopTldsByMaliciousVariables = {
  pathParams: RadarGetEmailSecurityTopTldsByMaliciousPathParams;
  queryParams?: RadarGetEmailSecurityTopTldsByMaliciousQueryParams;
} & FetcherExtraProps;

/**
 * Get the TLDs by emails classified as malicious or not.
 */
export const radarGetEmailSecurityTopTldsByMalicious = (
  variables: RadarGetEmailSecurityTopTldsByMaliciousVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecurityTopTldsByMaliciousResponse,
    RadarGetEmailSecurityTopTldsByMaliciousError,
    undefined,
    {},
    RadarGetEmailSecurityTopTldsByMaliciousQueryParams,
    RadarGetEmailSecurityTopTldsByMaliciousPathParams
  >({ url: '/radar/email/security/top/tlds/malicious/{malicious}', method: 'get', ...variables, signal });

export type RadarGetEmailSecurityTopTldsBySpamPathParams = {
  /**
   * Spam.
   *
   * @example SPAM
   */
  spam: 'SPAM' | 'NOT_SPAM';
};

export type RadarGetEmailSecurityTopTldsBySpamQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Filter for TLDs by category.
   *
   * @example CLASSIC
   */
  tldCategory?: 'CLASSIC' | 'COUNTRY';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecurityTopTldsBySpamError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetEmailSecurityTopTldsBySpamResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example com.
       */
      name: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecurityTopTldsBySpamVariables = {
  pathParams: RadarGetEmailSecurityTopTldsBySpamPathParams;
  queryParams?: RadarGetEmailSecurityTopTldsBySpamQueryParams;
} & FetcherExtraProps;

/**
 * Get the top TLDs by emails classified as spam or not.
 */
export const radarGetEmailSecurityTopTldsBySpam = (
  variables: RadarGetEmailSecurityTopTldsBySpamVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecurityTopTldsBySpamResponse,
    RadarGetEmailSecurityTopTldsBySpamError,
    undefined,
    {},
    RadarGetEmailSecurityTopTldsBySpamQueryParams,
    RadarGetEmailSecurityTopTldsBySpamPathParams
  >({ url: '/radar/email/security/top/tlds/spam/{spam}', method: 'get', ...variables, signal });

export type RadarGetEmailSecurityTopTldsBySpoofPathParams = {
  /**
   * Spoof.
   *
   * @example SPOOF
   */
  spoof: 'SPOOF' | 'NOT_SPOOF';
};

export type RadarGetEmailSecurityTopTldsBySpoofQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Filter for arc (Authenticated Received Chain).
   *
   * @example PASS
   */
  arc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dkim.
   *
   * @example PASS
   */
  dkim?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for dmarc.
   *
   * @example PASS
   */
  dmarc?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for spf.
   *
   * @example PASS
   */
  spf?: ('PASS' | 'NONE' | 'FAIL')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3')[];
  /**
   * Filter for TLDs by category.
   *
   * @example CLASSIC
   */
  tldCategory?: 'CLASSIC' | 'COUNTRY';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEmailSecurityTopTldsBySpoofError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetEmailSecurityTopTldsBySpoofResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example com.
       */
      name: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEmailSecurityTopTldsBySpoofVariables = {
  pathParams: RadarGetEmailSecurityTopTldsBySpoofPathParams;
  queryParams?: RadarGetEmailSecurityTopTldsBySpoofQueryParams;
} & FetcherExtraProps;

/**
 * Get the TLDs by emails classified as spoof or not.
 */
export const radarGetEmailSecurityTopTldsBySpoof = (
  variables: RadarGetEmailSecurityTopTldsBySpoofVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEmailSecurityTopTldsBySpoofResponse,
    RadarGetEmailSecurityTopTldsBySpoofError,
    undefined,
    {},
    RadarGetEmailSecurityTopTldsBySpoofQueryParams,
    RadarGetEmailSecurityTopTldsBySpoofPathParams
  >({ url: '/radar/email/security/top/tlds/spoof/{spoof}', method: 'get', ...variables, signal });

export type RadarGetEntitiesAsnListQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Number of objects to skip before grabbing results.
   */
  offset?: number;
  /**
   * Comma separated list of ASNs.
   *
   * @example 174,7922
   */
  asn?: string;
  /**
   * Location Alpha2 to filter results.
   *
   * @example US
   */
  location?: string;
  /**
   * Order asn list.
   *
   * @default ASN
   */
  orderBy?: 'ASN' | 'POPULATION';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEntitiesAsnListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEntitiesAsnListResponse = {
  result: {
    asns: {
      aka?: string;
      /**
       * @example 714
       */
      asn: number;
      /**
       * @example GB
       */
      country: string;
      /**
       * @example United Kingdom
       */
      countryName: string;
      /**
       * @example Apple Inc.
       */
      name: string;
      /**
       * Deprecated field. Please use 'aka'.
       */
      nameLong?: string;
      orgName?: string;
      /**
       * @example https://www.apple.com/support/systemstatus/
       */
      website?: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEntitiesAsnListVariables = {
  queryParams?: RadarGetEntitiesAsnListQueryParams;
} & FetcherExtraProps;

/**
 * Get a list of autonomous systems (ASes).
 */
export const radarGetEntitiesAsnList = (variables: RadarGetEntitiesAsnListVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetEntitiesAsnListResponse,
    RadarGetEntitiesAsnListError,
    undefined,
    {},
    RadarGetEntitiesAsnListQueryParams,
    {}
  >({ url: '/radar/entities/asns', method: 'get', ...variables, signal });

export type RadarGetEntitiesAsnByIpQueryParams = {
  /**
   * IP address.
   *
   * @example 8.8.8.8
   * @format ip
   */
  ip: string;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEntitiesAsnByIpError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetEntitiesAsnByIpResponse = {
  result: {
    asn: {
      aka?: string;
      /**
       * @example 714
       */
      asn: number;
      /**
       * @example GB
       */
      country: string;
      /**
       * @example United Kingdom
       */
      countryName: string;
      estimatedUsers: {
        /**
         * Total estimated users
         *
         * @example 86099
         */
        estimatedUsers?: number;
        locations: {
          /**
           * Estimated users per location
           *
           * @example 16710
           */
          estimatedUsers?: number;
          /**
           * @example US
           */
          locationAlpha2: string;
          /**
           * @example United States
           */
          locationName: string;
        }[];
      };
      /**
       * @example Apple Inc.
       */
      name: string;
      /**
       * Deprecated field. Please use 'aka'.
       */
      nameLong?: string;
      orgName: string;
      related: {
        aka?: string;
        asn: number;
        /**
         * Total estimated users
         *
         * @example 65345
         */
        estimatedUsers?: number;
        name: string;
      }[];
      /**
       * Regional Internet Registry
       *
       * @example RIPE
       */
      source: string;
      /**
       * @example https://www.apple.com/support/systemstatus/
       */
      website: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEntitiesAsnByIpVariables = {
  queryParams: RadarGetEntitiesAsnByIpQueryParams;
} & FetcherExtraProps;

/**
 * Get the requested autonomous system information based on IP address. Population estimates come from APNIC (refer to https://labs.apnic.net/?p=526).
 */
export const radarGetEntitiesAsnByIp = (variables: RadarGetEntitiesAsnByIpVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetEntitiesAsnByIpResponse,
    RadarGetEntitiesAsnByIpError,
    undefined,
    {},
    RadarGetEntitiesAsnByIpQueryParams,
    {}
  >({ url: '/radar/entities/asns/ip', method: 'get', ...variables, signal });

export type RadarGetEntitiesAsnByIdPathParams = {
  /**
   * Autonomous System Number (ASN).
   *
   * @example 3
   */
  asn: number;
};

export type RadarGetEntitiesAsnByIdQueryParams = {
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEntitiesAsnByIdError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetEntitiesAsnByIdResponse = {
  result: {
    asn: {
      aka?: string;
      /**
       * @example 714
       */
      asn: number;
      /**
       * @example 5
       */
      confidenceLevel: number;
      /**
       * @example GB
       */
      country: string;
      /**
       * @example United Kingdom
       */
      countryName: string;
      estimatedUsers: {
        /**
         * Total estimated users
         *
         * @example 86099
         */
        estimatedUsers?: number;
        locations: {
          /**
           * Estimated users per location
           *
           * @example 16710
           */
          estimatedUsers?: number;
          /**
           * @example US
           */
          locationAlpha2: string;
          /**
           * @example United States
           */
          locationName: string;
        }[];
      };
      /**
       * @example Apple Inc.
       */
      name: string;
      /**
       * Deprecated field. Please use 'aka'.
       */
      nameLong?: string;
      orgName: string;
      related: {
        aka?: string;
        /**
         * @example 174
         */
        asn: number;
        /**
         * Total estimated users
         *
         * @example 65345
         */
        estimatedUsers?: number;
        /**
         * @example Cogent-174
         */
        name: string;
      }[];
      /**
       * Regional Internet Registry
       *
       * @example RIPE
       */
      source: string;
      /**
       * @example https://www.apple.com/support/systemstatus/
       */
      website: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEntitiesAsnByIdVariables = {
  pathParams: RadarGetEntitiesAsnByIdPathParams;
  queryParams?: RadarGetEntitiesAsnByIdQueryParams;
} & FetcherExtraProps;

/**
 * Get the requested autonomous system information. (A confidence level below `5` indicates a low level of confidence in the traffic data - normally this happens because Cloudflare has a small amount of traffic from/to this AS). Population estimates come from APNIC (refer to https://labs.apnic.net/?p=526).
 */
export const radarGetEntitiesAsnById = (variables: RadarGetEntitiesAsnByIdVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetEntitiesAsnByIdResponse,
    RadarGetEntitiesAsnByIdError,
    undefined,
    {},
    RadarGetEntitiesAsnByIdQueryParams,
    RadarGetEntitiesAsnByIdPathParams
  >({ url: '/radar/entities/asns/{asn}', method: 'get', ...variables, signal });

export type RadarGetAsnsRelPathParams = {
  /**
   * Get all ASNs with provider-customer or peering relationships with the given ASN
   *
   * @example 3
   */
  asn: number;
};

export type RadarGetAsnsRelQueryParams = {
  /**
   * Get the AS relationship of ASN2 with respect to the given ASN
   */
  asn2?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetAsnsRelError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetAsnsRelResponse = {
  result: {
    meta: {
      data_time: string;
      query_time: string;
      total_peers: number;
    };
    rels: {
      asn1: number;
      asn1_country: string;
      asn1_name: string;
      asn2: number;
      asn2_country: string;
      asn2_name: string;
      rel: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetAsnsRelVariables = {
  pathParams: RadarGetAsnsRelPathParams;
  queryParams?: RadarGetAsnsRelQueryParams;
} & FetcherExtraProps;

/**
 * Get AS-level relationship for given networks.
 */
export const radarGetAsnsRel = (variables: RadarGetAsnsRelVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetAsnsRelResponse,
    RadarGetAsnsRelError,
    undefined,
    {},
    RadarGetAsnsRelQueryParams,
    RadarGetAsnsRelPathParams
  >({ url: '/radar/entities/asns/{asn}/rel', method: 'get', ...variables, signal });

export type RadarGetEntitiesIpQueryParams = {
  /**
   * IP address.
   *
   * @example 8.8.8.8
   * @format ip
   */
  ip: string;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEntitiesIpError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetEntitiesIpResponse = {
  result: {
    ip: {
      /**
       * @example 15169
       */
      asn: string;
      /**
       * @example US
       */
      asnLocation: string;
      /**
       * @example GOOGLE
       */
      asnName: string;
      /**
       * @example Google LLC
       */
      asnOrgName: string;
      /**
       * @example 8.8.8.8
       */
      ip: string;
      /**
       * @example IPv4
       */
      ipVersion: string;
      /**
       * @example GB
       */
      location: string;
      /**
       * @example United Kingdom
       */
      locationName: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEntitiesIpVariables = {
  queryParams: RadarGetEntitiesIpQueryParams;
} & FetcherExtraProps;

/**
 * Get IP address information.
 */
export const radarGetEntitiesIp = (variables: RadarGetEntitiesIpVariables, signal?: AbortSignal) =>
  fetch<RadarGetEntitiesIpResponse, RadarGetEntitiesIpError, undefined, {}, RadarGetEntitiesIpQueryParams, {}>({
    url: '/radar/entities/ip',
    method: 'get',
    ...variables,
    signal
  });

export type RadarGetEntitiesLocationsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Number of objects to skip before grabbing results.
   */
  offset?: number;
  /**
   * Comma separated list of locations.
   *
   * @example US,CA
   */
  location?: string;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEntitiesLocationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetEntitiesLocationsResponse = {
  result: {
    locations: {
      /**
       * @example AF
       */
      alpha2: string;
      /**
       * @example 33.939116
       */
      latitude: string;
      /**
       * @example 67.709953
       */
      longitude: string;
      /**
       * @example Afghanistan
       */
      name: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEntitiesLocationsVariables = {
  queryParams?: RadarGetEntitiesLocationsQueryParams;
} & FetcherExtraProps;

/**
 * Get a list of locations.
 */
export const radarGetEntitiesLocations = (variables: RadarGetEntitiesLocationsVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetEntitiesLocationsResponse,
    RadarGetEntitiesLocationsError,
    undefined,
    {},
    RadarGetEntitiesLocationsQueryParams,
    {}
  >({ url: '/radar/entities/locations', method: 'get', ...variables, signal });

export type RadarGetEntitiesLocationByAlpha2PathParams = {
  /**
   * Alpha-2 country code.
   *
   * @example US
   */
  location: string;
};

export type RadarGetEntitiesLocationByAlpha2QueryParams = {
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetEntitiesLocationByAlpha2Error = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetEntitiesLocationByAlpha2Response = {
  result: {
    location: {
      /**
       * @example AF
       */
      alpha2: string;
      /**
       * @example 5
       */
      confidenceLevel: number;
      /**
       * @example 33.939116
       */
      latitude: string;
      /**
       * @example 67.709953
       */
      longitude: string;
      /**
       * @example Afghanistan
       */
      name: string;
      /**
       * @example Middle East
       */
      region: string;
      /**
       * @example Southern Asia
       */
      subregion: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetEntitiesLocationByAlpha2Variables = {
  pathParams: RadarGetEntitiesLocationByAlpha2PathParams;
  queryParams?: RadarGetEntitiesLocationByAlpha2QueryParams;
} & FetcherExtraProps;

/**
 * Get the requested location information. (A confidence level below `5` indicates a low level of confidence in the traffic data - normally this happens because Cloudflare has a small amount of traffic from/to this location).
 */
export const radarGetEntitiesLocationByAlpha2 = (
  variables: RadarGetEntitiesLocationByAlpha2Variables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetEntitiesLocationByAlpha2Response,
    RadarGetEntitiesLocationByAlpha2Error,
    undefined,
    {},
    RadarGetEntitiesLocationByAlpha2QueryParams,
    RadarGetEntitiesLocationByAlpha2PathParams
  >({ url: '/radar/entities/locations/{location}', method: 'get', ...variables, signal });

export type RadarGetHttpSummaryByBotClassQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpSummaryByBotClassError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpSummaryByBotClassResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 35
       */
      bot: string;
      /**
       * @example 65
       */
      human: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpSummaryByBotClassVariables = {
  queryParams?: RadarGetHttpSummaryByBotClassQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of bot-generated traffic to genuine human traffic, as classified by Cloudflare. Visit https://developers.cloudflare.com/radar/concepts/bot-classes/ for more information.
 */
export const radarGetHttpSummaryByBotClass = (
  variables: RadarGetHttpSummaryByBotClassVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpSummaryByBotClassResponse,
    RadarGetHttpSummaryByBotClassError,
    undefined,
    {},
    RadarGetHttpSummaryByBotClassQueryParams,
    {}
  >({ url: '/radar/http/summary/bot_class', method: 'get', ...variables, signal });

export type RadarGetHttpSummaryByDeviceTypeQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpSummaryByDeviceTypeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpSummaryByDeviceTypeResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 65
       */
      desktop: string;
      /**
       * @example 30
       */
      mobile: string;
      /**
       * @example 5
       */
      other: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpSummaryByDeviceTypeVariables = {
  queryParams?: RadarGetHttpSummaryByDeviceTypeQueryParams;
} & FetcherExtraProps;

/**
 * Percentage of Internet traffic generated by mobile, desktop, and other types of devices over a given time period.
 */
export const radarGetHttpSummaryByDeviceType = (
  variables: RadarGetHttpSummaryByDeviceTypeVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpSummaryByDeviceTypeResponse,
    RadarGetHttpSummaryByDeviceTypeError,
    undefined,
    {},
    RadarGetHttpSummaryByDeviceTypeQueryParams,
    {}
  >({ url: '/radar/http/summary/device_type', method: 'get', ...variables, signal });

export type RadarGetHttpSummaryByHttpProtocolQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpSummaryByHttpProtocolError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpSummaryByHttpProtocolResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 99
       */
      http: string;
      /**
       * @example 1
       */
      https: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpSummaryByHttpProtocolVariables = {
  queryParams?: RadarGetHttpSummaryByHttpProtocolQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of traffic by HTTP protocol over a given time period.
 */
export const radarGetHttpSummaryByHttpProtocol = (
  variables: RadarGetHttpSummaryByHttpProtocolVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpSummaryByHttpProtocolResponse,
    RadarGetHttpSummaryByHttpProtocolError,
    undefined,
    {},
    RadarGetHttpSummaryByHttpProtocolQueryParams,
    {}
  >({ url: '/radar/http/summary/http_protocol', method: 'get', ...variables, signal });

export type RadarGetHttpSummaryByHttpVersionQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpSummaryByHttpVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpSummaryByHttpVersionResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 1
       */
      ['HTTP/1.x']: string;
      /**
       * @example 39
       */
      ['HTTP/2']: string;
      /**
       * @example 60
       */
      ['HTTP/3']: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpSummaryByHttpVersionVariables = {
  queryParams?: RadarGetHttpSummaryByHttpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of traffic by HTTP version over a given time period.
 */
export const radarGetHttpSummaryByHttpVersion = (
  variables: RadarGetHttpSummaryByHttpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpSummaryByHttpVersionResponse,
    RadarGetHttpSummaryByHttpVersionError,
    undefined,
    {},
    RadarGetHttpSummaryByHttpVersionQueryParams,
    {}
  >({ url: '/radar/http/summary/http_version', method: 'get', ...variables, signal });

export type RadarGetHttpSummaryByIpVersionQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpSummaryByIpVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpSummaryByIpVersionResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 65
       */
      IPv4: string;
      /**
       * @example 35
       */
      IPv6: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpSummaryByIpVersionVariables = {
  queryParams?: RadarGetHttpSummaryByIpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of Internet traffic based on IP versions (IPv4 and IPv6) over a given time period.
 */
export const radarGetHttpSummaryByIpVersion = (
  variables: RadarGetHttpSummaryByIpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpSummaryByIpVersionResponse,
    RadarGetHttpSummaryByIpVersionError,
    undefined,
    {},
    RadarGetHttpSummaryByIpVersionQueryParams,
    {}
  >({ url: '/radar/http/summary/ip_version', method: 'get', ...variables, signal });

export type RadarGetHttpSummaryByOperatingSystemQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpSummaryByOperatingSystemError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpSummaryByOperatingSystemResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 65
       */
      ANDROID: string;
      /**
       * @example 35
       */
      IOS: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpSummaryByOperatingSystemVariables = {
  queryParams?: RadarGetHttpSummaryByOperatingSystemQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of Internet traffic generated by different operating systems like Windows, macOS, Android, iOS, and others, over a given time period.
 */
export const radarGetHttpSummaryByOperatingSystem = (
  variables: RadarGetHttpSummaryByOperatingSystemVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpSummaryByOperatingSystemResponse,
    RadarGetHttpSummaryByOperatingSystemError,
    undefined,
    {},
    RadarGetHttpSummaryByOperatingSystemQueryParams,
    {}
  >({ url: '/radar/http/summary/os', method: 'get', ...variables, signal });

export type RadarGetHttpSummaryByPostQuantumQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpSummaryByPostQuantumError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpSummaryByPostQuantumResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 16
       */
      NOT_SUPPORTED: string;
      /**
       * @example 84
       */
      SUPPORTED: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpSummaryByPostQuantumVariables = {
  queryParams?: RadarGetHttpSummaryByPostQuantumQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of traffic by post-quantum support over a given time period.
 */
export const radarGetHttpSummaryByPostQuantum = (
  variables: RadarGetHttpSummaryByPostQuantumVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpSummaryByPostQuantumResponse,
    RadarGetHttpSummaryByPostQuantumError,
    undefined,
    {},
    RadarGetHttpSummaryByPostQuantumQueryParams,
    {}
  >({ url: '/radar/http/summary/post_quantum', method: 'get', ...variables, signal });

export type RadarGetHttpSummaryByTlsVersionQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpSummaryByTlsVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpSummaryByTlsVersionResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 0.5
       */
      ['TLS 1.0']: string;
      /**
       * @example 0.5
       */
      ['TLS 1.1']: string;
      /**
       * @example 60
       */
      ['TLS 1.2']: string;
      /**
       * @example 10
       */
      ['TLS 1.3']: string;
      /**
       * @example 29
       */
      ['TLS QUIC']: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpSummaryByTlsVersionVariables = {
  queryParams?: RadarGetHttpSummaryByTlsVersionQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of traffic by TLS protocol version, over a given time period.
 */
export const radarGetHttpSummaryByTlsVersion = (
  variables: RadarGetHttpSummaryByTlsVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpSummaryByTlsVersionResponse,
    RadarGetHttpSummaryByTlsVersionError,
    undefined,
    {},
    RadarGetHttpSummaryByTlsVersionQueryParams,
    {}
  >({ url: '/radar/http/summary/tls_version', method: 'get', ...variables, signal });

export type RadarGetHttpTimeseriesQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @example MIN0_MAX
   */
  normalization?: 'PERCENTAGE_CHANGE' | 'MIN0_MAX';
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTimeseriesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpTimeseriesResponse = {
  result: {
    meta: {
      /**
       * @example 1h
       */
      aggInterval: string;
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @format date-time
       */
      lastUpdated: string;
    };
    serie_0: {
      timestamps: string[];
      values: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTimeseriesVariables = {
  queryParams?: RadarGetHttpTimeseriesQueryParams;
} & FetcherExtraProps;

/**
 * Get HTTP requests over time.
 */
export const radarGetHttpTimeseries = (variables: RadarGetHttpTimeseriesVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetHttpTimeseriesResponse,
    RadarGetHttpTimeseriesError,
    undefined,
    {},
    RadarGetHttpTimeseriesQueryParams,
    {}
  >({ url: '/radar/http/timeseries', method: 'get', ...variables, signal });

export type RadarGetHttpTimeseriesGroupByBotClassQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTimeseriesGroupByBotClassError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpTimeseriesGroupByBotClassResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      bot: string[];
      human: string[];
      timestamps: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTimeseriesGroupByBotClassVariables = {
  queryParams?: RadarGetHttpTimeseriesGroupByBotClassQueryParams;
} & FetcherExtraProps;

/**
 * Get a time series of the percentage distribution of traffic classified as automated or human. Visit https://developers.cloudflare.com/radar/concepts/bot-classes/ for more information.
 */
export const radarGetHttpTimeseriesGroupByBotClass = (
  variables: RadarGetHttpTimeseriesGroupByBotClassVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTimeseriesGroupByBotClassResponse,
    RadarGetHttpTimeseriesGroupByBotClassError,
    undefined,
    {},
    RadarGetHttpTimeseriesGroupByBotClassQueryParams,
    {}
  >({ url: '/radar/http/timeseries_groups/bot_class', method: 'get', ...variables, signal });

export type RadarGetHttpTimeseriesGroupByBrowsersQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTimeseriesGroupByBrowsersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpTimeseriesGroupByBrowsersResponse = {
  result: {
    meta: Record<string, any>;
    /**
     * @example {"Chrome":["50.168733"],"timestamps":["2023-08-08T10:15:00Z"]}
     */
    serie_0: {
      timestamps: string[];
    } & {
      [key: string]: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTimeseriesGroupByBrowsersVariables = {
  queryParams?: RadarGetHttpTimeseriesGroupByBrowsersQueryParams;
} & FetcherExtraProps;

/**
 * Get a time series of the percentage distribution of traffic of the top user agents.
 */
export const radarGetHttpTimeseriesGroupByBrowsers = (
  variables: RadarGetHttpTimeseriesGroupByBrowsersVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTimeseriesGroupByBrowsersResponse,
    RadarGetHttpTimeseriesGroupByBrowsersError,
    undefined,
    {},
    RadarGetHttpTimeseriesGroupByBrowsersQueryParams,
    {}
  >({ url: '/radar/http/timeseries_groups/browser', method: 'get', ...variables, signal });

export type RadarGetHttpTimeseriesGroupByBrowserFamiliesQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Limit the number of objects (eg browsers, verticals, etc) to the top items over the time range.
   *
   * @example 10
   */
  limitPerGroup?: number;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTimeseriesGroupByBrowserFamiliesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpTimeseriesGroupByBrowserFamiliesResponse = {
  result: {
    meta: Record<string, any>;
    /**
     * @example {"Chrome":["50.168733"],"timestamps":["2023-08-08T10:15:00Z"]}
     */
    serie_0: {
      timestamps: string[];
    } & {
      [key: string]: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTimeseriesGroupByBrowserFamiliesVariables = {
  queryParams?: RadarGetHttpTimeseriesGroupByBrowserFamiliesQueryParams;
} & FetcherExtraProps;

/**
 * Get a time series of the percentage distribution of traffic of the top user agents aggregated in families.
 */
export const radarGetHttpTimeseriesGroupByBrowserFamilies = (
  variables: RadarGetHttpTimeseriesGroupByBrowserFamiliesVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTimeseriesGroupByBrowserFamiliesResponse,
    RadarGetHttpTimeseriesGroupByBrowserFamiliesError,
    undefined,
    {},
    RadarGetHttpTimeseriesGroupByBrowserFamiliesQueryParams,
    {}
  >({ url: '/radar/http/timeseries_groups/browser_family', method: 'get', ...variables, signal });

export type RadarGetHttpTimeseriesGroupByDeviceTypeQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTimeseriesGroupByDeviceTypeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpTimeseriesGroupByDeviceTypeResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      desktop: string[];
      mobile: string[];
      other: string[];
      timestamps: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTimeseriesGroupByDeviceTypeVariables = {
  queryParams?: RadarGetHttpTimeseriesGroupByDeviceTypeQueryParams;
} & FetcherExtraProps;

/**
 * Get a time series of the percentage distribution of traffic by device type.
 */
export const radarGetHttpTimeseriesGroupByDeviceType = (
  variables: RadarGetHttpTimeseriesGroupByDeviceTypeVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTimeseriesGroupByDeviceTypeResponse,
    RadarGetHttpTimeseriesGroupByDeviceTypeError,
    undefined,
    {},
    RadarGetHttpTimeseriesGroupByDeviceTypeQueryParams,
    {}
  >({ url: '/radar/http/timeseries_groups/device_type', method: 'get', ...variables, signal });

export type RadarGetHttpTimeseriesGroupByHttpProtocolQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTimeseriesGroupByHttpProtocolError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpTimeseriesGroupByHttpProtocolResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      http: string[];
      https: string[];
      timestamps: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTimeseriesGroupByHttpProtocolVariables = {
  queryParams?: RadarGetHttpTimeseriesGroupByHttpProtocolQueryParams;
} & FetcherExtraProps;

/**
 * Get a time series of the percentage distribution of traffic by HTTP protocol.
 */
export const radarGetHttpTimeseriesGroupByHttpProtocol = (
  variables: RadarGetHttpTimeseriesGroupByHttpProtocolVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTimeseriesGroupByHttpProtocolResponse,
    RadarGetHttpTimeseriesGroupByHttpProtocolError,
    undefined,
    {},
    RadarGetHttpTimeseriesGroupByHttpProtocolQueryParams,
    {}
  >({ url: '/radar/http/timeseries_groups/http_protocol', method: 'get', ...variables, signal });

export type RadarGetHttpTimeseriesGroupByHttpVersionQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTimeseriesGroupByHttpVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpTimeseriesGroupByHttpVersionResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      ['HTTP/1.x']: string[];
      ['HTTP/2']: string[];
      ['HTTP/3']: string[];
      timestamps: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTimeseriesGroupByHttpVersionVariables = {
  queryParams?: RadarGetHttpTimeseriesGroupByHttpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Get a time series of the percentage distribution of traffic by HTTP version.
 */
export const radarGetHttpTimeseriesGroupByHttpVersion = (
  variables: RadarGetHttpTimeseriesGroupByHttpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTimeseriesGroupByHttpVersionResponse,
    RadarGetHttpTimeseriesGroupByHttpVersionError,
    undefined,
    {},
    RadarGetHttpTimeseriesGroupByHttpVersionQueryParams,
    {}
  >({ url: '/radar/http/timeseries_groups/http_version', method: 'get', ...variables, signal });

export type RadarGetHttpTimeseriesGroupByIpVersionQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTimeseriesGroupByIpVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpTimeseriesGroupByIpVersionResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      IPv4: string[];
      IPv6: string[];
      timestamps: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTimeseriesGroupByIpVersionVariables = {
  queryParams?: RadarGetHttpTimeseriesGroupByIpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Get a time series of the percentage distribution of traffic by IP version.
 */
export const radarGetHttpTimeseriesGroupByIpVersion = (
  variables: RadarGetHttpTimeseriesGroupByIpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTimeseriesGroupByIpVersionResponse,
    RadarGetHttpTimeseriesGroupByIpVersionError,
    undefined,
    {},
    RadarGetHttpTimeseriesGroupByIpVersionQueryParams,
    {}
  >({ url: '/radar/http/timeseries_groups/ip_version', method: 'get', ...variables, signal });

export type RadarGetHttpTimeseriesGroupByOperatingSystemQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTimeseriesGroupByOperatingSystemError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpTimeseriesGroupByOperatingSystemResponse = {
  result: {
    meta: Record<string, any>;
    /**
     * @example {"ANDROID":["97.28898"],"timestamps":["2023-08-08T10:15:00Z"]}
     */
    serie_0: {
      timestamps: string[];
    } & {
      [key: string]: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTimeseriesGroupByOperatingSystemVariables = {
  queryParams?: RadarGetHttpTimeseriesGroupByOperatingSystemQueryParams;
} & FetcherExtraProps;

/**
 * Get a time series of the percentage distribution of traffic of the top operating systems.
 */
export const radarGetHttpTimeseriesGroupByOperatingSystem = (
  variables: RadarGetHttpTimeseriesGroupByOperatingSystemVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTimeseriesGroupByOperatingSystemResponse,
    RadarGetHttpTimeseriesGroupByOperatingSystemError,
    undefined,
    {},
    RadarGetHttpTimeseriesGroupByOperatingSystemQueryParams,
    {}
  >({ url: '/radar/http/timeseries_groups/os', method: 'get', ...variables, signal });

export type RadarGetHttpTimeseriesGroupByPostQuantumQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTimeseriesGroupByPostQuantumError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpTimeseriesGroupByPostQuantumResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      NOT_SUPPORTED: string[];
      SUPPORTED: string[];
      timestamps: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTimeseriesGroupByPostQuantumVariables = {
  queryParams?: RadarGetHttpTimeseriesGroupByPostQuantumQueryParams;
} & FetcherExtraProps;

/**
 * Get a time series of the percentage distribution of traffic by post-quantum suport.
 */
export const radarGetHttpTimeseriesGroupByPostQuantum = (
  variables: RadarGetHttpTimeseriesGroupByPostQuantumVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTimeseriesGroupByPostQuantumResponse,
    RadarGetHttpTimeseriesGroupByPostQuantumError,
    undefined,
    {},
    RadarGetHttpTimeseriesGroupByPostQuantumQueryParams,
    {}
  >({ url: '/radar/http/timeseries_groups/post_quantum', method: 'get', ...variables, signal });

export type RadarGetHttpTimeseriesGroupByTlsVersionQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTimeseriesGroupByTlsVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetHttpTimeseriesGroupByTlsVersionResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      ['TLS 1.0']: string[];
      ['TLS 1.1']: string[];
      ['TLS 1.2']: string[];
      ['TLS 1.3']: string[];
      ['TLS QUIC']: string[];
      timestamps: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTimeseriesGroupByTlsVersionVariables = {
  queryParams?: RadarGetHttpTimeseriesGroupByTlsVersionQueryParams;
} & FetcherExtraProps;

/**
 * Get a time series of the percentage distribution of traffic by TLS protocol version.
 */
export const radarGetHttpTimeseriesGroupByTlsVersion = (
  variables: RadarGetHttpTimeseriesGroupByTlsVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTimeseriesGroupByTlsVersionResponse,
    RadarGetHttpTimeseriesGroupByTlsVersionError,
    undefined,
    {},
    RadarGetHttpTimeseriesGroupByTlsVersionQueryParams,
    {}
  >({ url: '/radar/http/timeseries_groups/tls_version', method: 'get', ...variables, signal });

export type RadarGetHttpTopAsesByHttpRequestsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Filter for browser family.
   *
   * @example CHROME
   */
  browserFamily?: ('CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopAsesByHttpRequestsError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopAsesByHttpRequestsResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example 3243
       */
      clientASN: number;
      /**
       * @example MEO
       */
      clientASName: string;
      /**
       * @example 3
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopAsesByHttpRequestsVariables = {
  queryParams?: RadarGetHttpTopAsesByHttpRequestsQueryParams;
} & FetcherExtraProps;

/**
 * Get the top autonomous systems by HTTP traffic. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopAsesByHttpRequests = (
  variables: RadarGetHttpTopAsesByHttpRequestsVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopAsesByHttpRequestsResponse,
    RadarGetHttpTopAsesByHttpRequestsError,
    undefined,
    {},
    RadarGetHttpTopAsesByHttpRequestsQueryParams,
    {}
  >({ url: '/radar/http/top/ases', method: 'get', ...variables, signal });

export type RadarGetHttpTopAsesByBotClassPathParams = {
  /**
   * Bot class.
   */
  botClass: 'LIKELY_AUTOMATED' | 'LIKELY_HUMAN';
};

export type RadarGetHttpTopAsesByBotClassQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Filter for browser family.
   *
   * @example CHROME
   */
  browserFamily?: ('CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopAsesByBotClassError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopAsesByBotClassResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example 3243
       */
      clientASN: number;
      /**
       * @example MEO
       */
      clientASName: string;
      /**
       * @example 3
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopAsesByBotClassVariables = {
  pathParams: RadarGetHttpTopAsesByBotClassPathParams;
  queryParams?: RadarGetHttpTopAsesByBotClassQueryParams;
} & FetcherExtraProps;

/**
 * Get the top autonomous systems (AS), by HTTP traffic, of the requested bot class. These two categories use Cloudflare's bot score - refer to [Bot Scores](https://developers.cloudflare.com/bots/concepts/bot-score) for more information. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopAsesByBotClass = (
  variables: RadarGetHttpTopAsesByBotClassVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopAsesByBotClassResponse,
    RadarGetHttpTopAsesByBotClassError,
    undefined,
    {},
    RadarGetHttpTopAsesByBotClassQueryParams,
    RadarGetHttpTopAsesByBotClassPathParams
  >({ url: '/radar/http/top/ases/bot_class/{botClass}', method: 'get', ...variables, signal });

export type RadarGetHttpTopAsesByBrowserFamilyPathParams = {
  /**
   * Browser family.
   */
  browserFamily: 'CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI';
};

export type RadarGetHttpTopAsesByBrowserFamilyQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopAsesByBrowserFamilyError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopAsesByBrowserFamilyResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example 3243
       */
      clientASN: number;
      /**
       * @example MEO
       */
      clientASName: string;
      /**
       * @example 3
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopAsesByBrowserFamilyVariables = {
  pathParams: RadarGetHttpTopAsesByBrowserFamilyPathParams;
  queryParams?: RadarGetHttpTopAsesByBrowserFamilyQueryParams;
} & FetcherExtraProps;

/**
 * Get the top autonomous systems (AS), by HTTP traffic, of the requested browser family. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopAsesByBrowserFamily = (
  variables: RadarGetHttpTopAsesByBrowserFamilyVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopAsesByBrowserFamilyResponse,
    RadarGetHttpTopAsesByBrowserFamilyError,
    undefined,
    {},
    RadarGetHttpTopAsesByBrowserFamilyQueryParams,
    RadarGetHttpTopAsesByBrowserFamilyPathParams
  >({ url: '/radar/http/top/ases/browser_family/{browserFamily}', method: 'get', ...variables, signal });

export type RadarGetHttpTopAsesByDeviceTypePathParams = {
  /**
   * Device type.
   */
  deviceType: 'DESKTOP' | 'MOBILE' | 'OTHER';
};

export type RadarGetHttpTopAsesByDeviceTypeQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Filter for browser family.
   *
   * @example CHROME
   */
  browserFamily?: ('CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopAsesByDeviceTypeError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopAsesByDeviceTypeResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example 3243
       */
      clientASN: number;
      /**
       * @example MEO
       */
      clientASName: string;
      /**
       * @example 3
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopAsesByDeviceTypeVariables = {
  pathParams: RadarGetHttpTopAsesByDeviceTypePathParams;
  queryParams?: RadarGetHttpTopAsesByDeviceTypeQueryParams;
} & FetcherExtraProps;

/**
 * Get the top autonomous systems (AS), by HTTP traffic, of the requested device type. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopAsesByDeviceType = (
  variables: RadarGetHttpTopAsesByDeviceTypeVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopAsesByDeviceTypeResponse,
    RadarGetHttpTopAsesByDeviceTypeError,
    undefined,
    {},
    RadarGetHttpTopAsesByDeviceTypeQueryParams,
    RadarGetHttpTopAsesByDeviceTypePathParams
  >({ url: '/radar/http/top/ases/device_type/{deviceType}', method: 'get', ...variables, signal });

export type RadarGetHttpTopAsesByHttpProtocolPathParams = {
  /**
   * HTTP Protocol.
   */
  httpProtocol: 'HTTP' | 'HTTPS';
};

export type RadarGetHttpTopAsesByHttpProtocolQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Filter for browser family.
   *
   * @example CHROME
   */
  browserFamily?: ('CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopAsesByHttpProtocolError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopAsesByHttpProtocolResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example 3243
       */
      clientASN: number;
      /**
       * @example MEO
       */
      clientASName: string;
      /**
       * @example 3
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopAsesByHttpProtocolVariables = {
  pathParams: RadarGetHttpTopAsesByHttpProtocolPathParams;
  queryParams?: RadarGetHttpTopAsesByHttpProtocolQueryParams;
} & FetcherExtraProps;

/**
 * Get the top autonomous systems (AS), by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopAsesByHttpProtocol = (
  variables: RadarGetHttpTopAsesByHttpProtocolVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopAsesByHttpProtocolResponse,
    RadarGetHttpTopAsesByHttpProtocolError,
    undefined,
    {},
    RadarGetHttpTopAsesByHttpProtocolQueryParams,
    RadarGetHttpTopAsesByHttpProtocolPathParams
  >({ url: '/radar/http/top/ases/http_protocol/{httpProtocol}', method: 'get', ...variables, signal });

export type RadarGetHttpTopAsesByHttpVersionPathParams = {
  /**
   * HTTP version.
   */
  httpVersion: 'HTTPv1' | 'HTTPv2' | 'HTTPv3';
};

export type RadarGetHttpTopAsesByHttpVersionQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Filter for browser family.
   *
   * @example CHROME
   */
  browserFamily?: ('CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopAsesByHttpVersionError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopAsesByHttpVersionResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example 3243
       */
      clientASN: number;
      /**
       * @example MEO
       */
      clientASName: string;
      /**
       * @example 3
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopAsesByHttpVersionVariables = {
  pathParams: RadarGetHttpTopAsesByHttpVersionPathParams;
  queryParams?: RadarGetHttpTopAsesByHttpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Get the top autonomous systems (AS), by HTTP traffic, of the requested HTTP version. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopAsesByHttpVersion = (
  variables: RadarGetHttpTopAsesByHttpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopAsesByHttpVersionResponse,
    RadarGetHttpTopAsesByHttpVersionError,
    undefined,
    {},
    RadarGetHttpTopAsesByHttpVersionQueryParams,
    RadarGetHttpTopAsesByHttpVersionPathParams
  >({ url: '/radar/http/top/ases/http_version/{httpVersion}', method: 'get', ...variables, signal });

export type RadarGetHttpTopAsesByIpVersionPathParams = {
  /**
   * IP version.
   */
  ipVersion: 'IPv4' | 'IPv6';
};

export type RadarGetHttpTopAsesByIpVersionQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Filter for browser family.
   *
   * @example CHROME
   */
  browserFamily?: ('CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopAsesByIpVersionError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopAsesByIpVersionResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example 3243
       */
      clientASN: number;
      /**
       * @example MEO
       */
      clientASName: string;
      /**
       * @example 3
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopAsesByIpVersionVariables = {
  pathParams: RadarGetHttpTopAsesByIpVersionPathParams;
  queryParams?: RadarGetHttpTopAsesByIpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Get the top autonomous systems, by HTTP traffic, of the requested IP version. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopAsesByIpVersion = (
  variables: RadarGetHttpTopAsesByIpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopAsesByIpVersionResponse,
    RadarGetHttpTopAsesByIpVersionError,
    undefined,
    {},
    RadarGetHttpTopAsesByIpVersionQueryParams,
    RadarGetHttpTopAsesByIpVersionPathParams
  >({ url: '/radar/http/top/ases/ip_version/{ipVersion}', method: 'get', ...variables, signal });

export type RadarGetHttpTopAsesByOperatingSystemPathParams = {
  /**
   * Operating system.
   */
  os: 'WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV';
};

export type RadarGetHttpTopAsesByOperatingSystemQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Filter for browser family.
   *
   * @example CHROME
   */
  browserFamily?: ('CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopAsesByOperatingSystemError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopAsesByOperatingSystemResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example 3243
       */
      clientASN: number;
      /**
       * @example MEO
       */
      clientASName: string;
      /**
       * @example 3
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopAsesByOperatingSystemVariables = {
  pathParams: RadarGetHttpTopAsesByOperatingSystemPathParams;
  queryParams?: RadarGetHttpTopAsesByOperatingSystemQueryParams;
} & FetcherExtraProps;

/**
 * Get the top autonomous systems, by HTTP traffic, of the requested operating systems. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopAsesByOperatingSystem = (
  variables: RadarGetHttpTopAsesByOperatingSystemVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopAsesByOperatingSystemResponse,
    RadarGetHttpTopAsesByOperatingSystemError,
    undefined,
    {},
    RadarGetHttpTopAsesByOperatingSystemQueryParams,
    RadarGetHttpTopAsesByOperatingSystemPathParams
  >({ url: '/radar/http/top/ases/os/{os}', method: 'get', ...variables, signal });

export type RadarGetHttpTopAsesByTlsVersionPathParams = {
  /**
   * TLS version.
   */
  tlsVersion: 'TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC';
};

export type RadarGetHttpTopAsesByTlsVersionQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for browser family.
   *
   * @example CHROME
   */
  browserFamily?: ('CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopAsesByTlsVersionError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopAsesByTlsVersionResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example 3243
       */
      clientASN: number;
      /**
       * @example MEO
       */
      clientASName: string;
      /**
       * @example 3
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopAsesByTlsVersionVariables = {
  pathParams: RadarGetHttpTopAsesByTlsVersionPathParams;
  queryParams?: RadarGetHttpTopAsesByTlsVersionQueryParams;
} & FetcherExtraProps;

/**
 * Get the top autonomous systems (AS), by HTTP traffic, of the requested TLS protocol version. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopAsesByTlsVersion = (
  variables: RadarGetHttpTopAsesByTlsVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopAsesByTlsVersionResponse,
    RadarGetHttpTopAsesByTlsVersionError,
    undefined,
    {},
    RadarGetHttpTopAsesByTlsVersionQueryParams,
    RadarGetHttpTopAsesByTlsVersionPathParams
  >({ url: '/radar/http/top/ases/tls_version/{tlsVersion}', method: 'get', ...variables, signal });

export type RadarGetHttpTopBrowsersQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Filter for browser family.
   *
   * @example CHROME
   */
  browserFamily?: ('CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopBrowsersError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopBrowsersResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example chrome
       */
      name: string;
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopBrowsersVariables = {
  queryParams?: RadarGetHttpTopBrowsersQueryParams;
} & FetcherExtraProps;

/**
 * Get the top user agents by HTTP traffic. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopBrowsers = (variables: RadarGetHttpTopBrowsersVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetHttpTopBrowsersResponse,
    RadarGetHttpTopBrowsersError,
    undefined,
    {},
    RadarGetHttpTopBrowsersQueryParams,
    {}
  >({ url: '/radar/http/top/browser', method: 'get', ...variables, signal });

export type RadarGetHttpTopBrowserFamiliesQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Filter for browser family.
   *
   * @example CHROME
   */
  browserFamily?: ('CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopBrowserFamiliesError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopBrowserFamiliesResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example chrome
       */
      name: string;
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopBrowserFamiliesVariables = {
  queryParams?: RadarGetHttpTopBrowserFamiliesQueryParams;
} & FetcherExtraProps;

/**
 * Get the top user agents aggregated in families by HTTP traffic. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopBrowserFamilies = (
  variables: RadarGetHttpTopBrowserFamiliesVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopBrowserFamiliesResponse,
    RadarGetHttpTopBrowserFamiliesError,
    undefined,
    {},
    RadarGetHttpTopBrowserFamiliesQueryParams,
    {}
  >({ url: '/radar/http/top/browser_family', method: 'get', ...variables, signal });

export type RadarGetHttpTopLocationsByHttpRequestsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Filter for browser family.
   *
   * @example CHROME
   */
  browserFamily?: ('CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopLocationsByHttpRequestsError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopLocationsByHttpRequestsResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example US
       */
      clientCountryAlpha2: string;
      /**
       * @example United States
       */
      clientCountryName: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopLocationsByHttpRequestsVariables = {
  queryParams?: RadarGetHttpTopLocationsByHttpRequestsQueryParams;
} & FetcherExtraProps;

/**
 * Get the top locations by HTTP traffic. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopLocationsByHttpRequests = (
  variables: RadarGetHttpTopLocationsByHttpRequestsVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopLocationsByHttpRequestsResponse,
    RadarGetHttpTopLocationsByHttpRequestsError,
    undefined,
    {},
    RadarGetHttpTopLocationsByHttpRequestsQueryParams,
    {}
  >({ url: '/radar/http/top/locations', method: 'get', ...variables, signal });

export type RadarGetHttpTopLocationsByBotClassPathParams = {
  /**
   * Bot class.
   */
  botClass: 'LIKELY_AUTOMATED' | 'LIKELY_HUMAN';
};

export type RadarGetHttpTopLocationsByBotClassQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Filter for browser family.
   *
   * @example CHROME
   */
  browserFamily?: ('CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopLocationsByBotClassError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopLocationsByBotClassResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example US
       */
      clientCountryAlpha2: string;
      /**
       * @example United States
       */
      clientCountryName: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopLocationsByBotClassVariables = {
  pathParams: RadarGetHttpTopLocationsByBotClassPathParams;
  queryParams?: RadarGetHttpTopLocationsByBotClassQueryParams;
} & FetcherExtraProps;

/**
 * Get the top locations, by HTTP traffic, of the requested bot class. These two categories use Cloudflare's bot score - refer to [Bot scores])https://developers.cloudflare.com/bots/concepts/bot-score). Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopLocationsByBotClass = (
  variables: RadarGetHttpTopLocationsByBotClassVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopLocationsByBotClassResponse,
    RadarGetHttpTopLocationsByBotClassError,
    undefined,
    {},
    RadarGetHttpTopLocationsByBotClassQueryParams,
    RadarGetHttpTopLocationsByBotClassPathParams
  >({ url: '/radar/http/top/locations/bot_class/{botClass}', method: 'get', ...variables, signal });

export type RadarGetHttpTopLocationsByBrowserFamilyPathParams = {
  /**
   * Browser family.
   */
  browserFamily: 'CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI';
};

export type RadarGetHttpTopLocationsByBrowserFamilyQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopLocationsByBrowserFamilyError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopLocationsByBrowserFamilyResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example US
       */
      clientCountryAlpha2: string;
      /**
       * @example United States
       */
      clientCountryName: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopLocationsByBrowserFamilyVariables = {
  pathParams: RadarGetHttpTopLocationsByBrowserFamilyPathParams;
  queryParams?: RadarGetHttpTopLocationsByBrowserFamilyQueryParams;
} & FetcherExtraProps;

/**
 * Get the top locations, by HTTP traffic, of the requested browser family. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopLocationsByBrowserFamily = (
  variables: RadarGetHttpTopLocationsByBrowserFamilyVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopLocationsByBrowserFamilyResponse,
    RadarGetHttpTopLocationsByBrowserFamilyError,
    undefined,
    {},
    RadarGetHttpTopLocationsByBrowserFamilyQueryParams,
    RadarGetHttpTopLocationsByBrowserFamilyPathParams
  >({ url: '/radar/http/top/locations/browser_family/{browserFamily}', method: 'get', ...variables, signal });

export type RadarGetHttpTopLocationsByDeviceTypePathParams = {
  /**
   * Device type.
   */
  deviceType: 'DESKTOP' | 'MOBILE' | 'OTHER';
};

export type RadarGetHttpTopLocationsByDeviceTypeQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Filter for browser family.
   *
   * @example CHROME
   */
  browserFamily?: ('CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopLocationsByDeviceTypeError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopLocationsByDeviceTypeResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example US
       */
      clientCountryAlpha2: string;
      /**
       * @example United States
       */
      clientCountryName: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopLocationsByDeviceTypeVariables = {
  pathParams: RadarGetHttpTopLocationsByDeviceTypePathParams;
  queryParams?: RadarGetHttpTopLocationsByDeviceTypeQueryParams;
} & FetcherExtraProps;

/**
 * Get the top locations, by HTTP traffic, of the requested device type. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopLocationsByDeviceType = (
  variables: RadarGetHttpTopLocationsByDeviceTypeVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopLocationsByDeviceTypeResponse,
    RadarGetHttpTopLocationsByDeviceTypeError,
    undefined,
    {},
    RadarGetHttpTopLocationsByDeviceTypeQueryParams,
    RadarGetHttpTopLocationsByDeviceTypePathParams
  >({ url: '/radar/http/top/locations/device_type/{deviceType}', method: 'get', ...variables, signal });

export type RadarGetHttpTopLocationsByHttpProtocolPathParams = {
  /**
   * HTTP Protocol.
   */
  httpProtocol: 'HTTP' | 'HTTPS';
};

export type RadarGetHttpTopLocationsByHttpProtocolQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Filter for browser family.
   *
   * @example CHROME
   */
  browserFamily?: ('CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopLocationsByHttpProtocolError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopLocationsByHttpProtocolResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example US
       */
      clientCountryAlpha2: string;
      /**
       * @example United States
       */
      clientCountryName: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopLocationsByHttpProtocolVariables = {
  pathParams: RadarGetHttpTopLocationsByHttpProtocolPathParams;
  queryParams?: RadarGetHttpTopLocationsByHttpProtocolQueryParams;
} & FetcherExtraProps;

/**
 * Get the top locations, by HTTP traffic, of the requested HTTP protocol. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopLocationsByHttpProtocol = (
  variables: RadarGetHttpTopLocationsByHttpProtocolVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopLocationsByHttpProtocolResponse,
    RadarGetHttpTopLocationsByHttpProtocolError,
    undefined,
    {},
    RadarGetHttpTopLocationsByHttpProtocolQueryParams,
    RadarGetHttpTopLocationsByHttpProtocolPathParams
  >({ url: '/radar/http/top/locations/http_protocol/{httpProtocol}', method: 'get', ...variables, signal });

export type RadarGetHttpTopLocationsByHttpVersionPathParams = {
  /**
   * HTTP version.
   */
  httpVersion: 'HTTPv1' | 'HTTPv2' | 'HTTPv3';
};

export type RadarGetHttpTopLocationsByHttpVersionQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Filter for browser family.
   *
   * @example CHROME
   */
  browserFamily?: ('CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopLocationsByHttpVersionError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopLocationsByHttpVersionResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example US
       */
      clientCountryAlpha2: string;
      /**
       * @example United States
       */
      clientCountryName: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopLocationsByHttpVersionVariables = {
  pathParams: RadarGetHttpTopLocationsByHttpVersionPathParams;
  queryParams?: RadarGetHttpTopLocationsByHttpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Get the top locations, by HTTP traffic, of the requested HTTP version. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopLocationsByHttpVersion = (
  variables: RadarGetHttpTopLocationsByHttpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopLocationsByHttpVersionResponse,
    RadarGetHttpTopLocationsByHttpVersionError,
    undefined,
    {},
    RadarGetHttpTopLocationsByHttpVersionQueryParams,
    RadarGetHttpTopLocationsByHttpVersionPathParams
  >({ url: '/radar/http/top/locations/http_version/{httpVersion}', method: 'get', ...variables, signal });

export type RadarGetHttpTopLocationsByIpVersionPathParams = {
  /**
   * IP version.
   */
  ipVersion: 'IPv4' | 'IPv6';
};

export type RadarGetHttpTopLocationsByIpVersionQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Filter for browser family.
   *
   * @example CHROME
   */
  browserFamily?: ('CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopLocationsByIpVersionError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopLocationsByIpVersionResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example US
       */
      clientCountryAlpha2: string;
      /**
       * @example United States
       */
      clientCountryName: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopLocationsByIpVersionVariables = {
  pathParams: RadarGetHttpTopLocationsByIpVersionPathParams;
  queryParams?: RadarGetHttpTopLocationsByIpVersionQueryParams;
} & FetcherExtraProps;

/**
 * Get the top locations, by HTTP traffic, of the requested IP version. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopLocationsByIpVersion = (
  variables: RadarGetHttpTopLocationsByIpVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopLocationsByIpVersionResponse,
    RadarGetHttpTopLocationsByIpVersionError,
    undefined,
    {},
    RadarGetHttpTopLocationsByIpVersionQueryParams,
    RadarGetHttpTopLocationsByIpVersionPathParams
  >({ url: '/radar/http/top/locations/ip_version/{ipVersion}', method: 'get', ...variables, signal });

export type RadarGetHttpTopLocationsByOperatingSystemPathParams = {
  /**
   * Operating system.
   */
  os: 'WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV';
};

export type RadarGetHttpTopLocationsByOperatingSystemQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for tls version.
   *
   * @example TLSv1_2
   */
  tlsVersion?: ('TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC')[];
  /**
   * Filter for browser family.
   *
   * @example CHROME
   */
  browserFamily?: ('CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopLocationsByOperatingSystemError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopLocationsByOperatingSystemResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example US
       */
      clientCountryAlpha2: string;
      /**
       * @example United States
       */
      clientCountryName: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopLocationsByOperatingSystemVariables = {
  pathParams: RadarGetHttpTopLocationsByOperatingSystemPathParams;
  queryParams?: RadarGetHttpTopLocationsByOperatingSystemQueryParams;
} & FetcherExtraProps;

/**
 * Get the top locations, by HTTP traffic, of the requested operating systems. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopLocationsByOperatingSystem = (
  variables: RadarGetHttpTopLocationsByOperatingSystemVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopLocationsByOperatingSystemResponse,
    RadarGetHttpTopLocationsByOperatingSystemError,
    undefined,
    {},
    RadarGetHttpTopLocationsByOperatingSystemQueryParams,
    RadarGetHttpTopLocationsByOperatingSystemPathParams
  >({ url: '/radar/http/top/locations/os/{os}', method: 'get', ...variables, signal });

export type RadarGetHttpTopLocationsByTlsVersionPathParams = {
  /**
   * TLS version.
   */
  tlsVersion: 'TLSv1_0' | 'TLSv1_1' | 'TLSv1_2' | 'TLSv1_3' | 'TLSvQUIC';
};

export type RadarGetHttpTopLocationsByTlsVersionQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Filter for bot class. Refer to [Bot classes](https://developers.cloudflare.com/radar/concepts/bot-classes/).
   *
   * @example LIKELY_AUTOMATED
   */
  botClass?: ('LIKELY_AUTOMATED' | 'LIKELY_HUMAN')[];
  /**
   * Filter for device type.
   *
   * @example DESKTOP
   */
  deviceType?: ('DESKTOP' | 'MOBILE' | 'OTHER')[];
  /**
   * Filter for http protocol.
   *
   * @example HTTPS
   */
  httpProtocol?: ('HTTP' | 'HTTPS')[];
  /**
   * Filter for http version.
   *
   * @example HTTPv1
   */
  httpVersion?: ('HTTPv1' | 'HTTPv2' | 'HTTPv3')[];
  /**
   * Filter for ip version.
   *
   * @example IPv4
   */
  ipVersion?: ('IPv4' | 'IPv6')[];
  /**
   * Filter for os name.
   *
   * @example WINDOWS
   */
  os?: ('WINDOWS' | 'MACOSX' | 'IOS' | 'ANDROID' | 'CHROMEOS' | 'LINUX' | 'SMART_TV')[];
  /**
   * Filter for browser family.
   *
   * @example CHROME
   */
  browserFamily?: ('CHROME' | 'EDGE' | 'FIREFOX' | 'SAFARI')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetHttpTopLocationsByTlsVersionError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetHttpTopLocationsByTlsVersionResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example US
       */
      clientCountryAlpha2: string;
      /**
       * @example United States
       */
      clientCountryName: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetHttpTopLocationsByTlsVersionVariables = {
  pathParams: RadarGetHttpTopLocationsByTlsVersionPathParams;
  queryParams?: RadarGetHttpTopLocationsByTlsVersionQueryParams;
} & FetcherExtraProps;

/**
 * Get the top locations, by HTTP traffic, of the requested TLS protocol version. Values are a percentage out of the total traffic.
 */
export const radarGetHttpTopLocationsByTlsVersion = (
  variables: RadarGetHttpTopLocationsByTlsVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetHttpTopLocationsByTlsVersionResponse,
    RadarGetHttpTopLocationsByTlsVersionError,
    undefined,
    {},
    RadarGetHttpTopLocationsByTlsVersionQueryParams,
    RadarGetHttpTopLocationsByTlsVersionPathParams
  >({ url: '/radar/http/top/locations/tls_version/{tlsVersion}', method: 'get', ...variables, signal });

export type RadarGetNetflowsSummaryQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetNetflowsSummaryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetNetflowsSummaryResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
    };
    summary_0: {
      /**
       * @example 60
       */
      HTTP: string;
      /**
       * @example 39
       */
      OTHER: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetNetflowsSummaryVariables = {
  queryParams?: RadarGetNetflowsSummaryQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution of HTTP vs other protocols traffic over a given time period.
 */
export const radarGetNetflowsSummary = (variables: RadarGetNetflowsSummaryVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetNetflowsSummaryResponse,
    RadarGetNetflowsSummaryError,
    undefined,
    {},
    RadarGetNetflowsSummaryQueryParams,
    {}
  >({ url: '/radar/netflows/summary', method: 'get', ...variables, signal });

export type RadarGetNetflowsTimeseriesQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of network traffic product types.
   *
   * @example all
   */
  product?: ('HTTP' | 'ALL')[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Normalization method applied. Refer to [Normalization methods](https://developers.cloudflare.com/radar/concepts/normalization/).
   *
   * @example MIN0_MAX
   */
  normalization?: 'PERCENTAGE_CHANGE' | 'MIN0_MAX';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetNetflowsTimeseriesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetNetflowsTimeseriesResponse = {
  result: {
    meta: {
      /**
       * @example 1h
       */
      aggInterval: string;
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @format date-time
       */
      lastUpdated: string;
    };
    serie_0: {
      timestamps: string[];
      values: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetNetflowsTimeseriesVariables = {
  queryParams?: RadarGetNetflowsTimeseriesQueryParams;
} & FetcherExtraProps;

/**
 * Get network traffic change over time. Visit https://en.wikipedia.org/wiki/NetFlow for more information on NetFlows.
 */
export const radarGetNetflowsTimeseries = (variables: RadarGetNetflowsTimeseriesVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetNetflowsTimeseriesResponse,
    RadarGetNetflowsTimeseriesError,
    undefined,
    {},
    RadarGetNetflowsTimeseriesQueryParams,
    {}
  >({ url: '/radar/netflows/timeseries', method: 'get', ...variables, signal });

export type RadarGetNetflowsTopAsesQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetNetflowsTopAsesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetNetflowsTopAsesResponse = {
  result: {
    top_0: {
      /**
       * @example 16509
       */
      clientASN: number;
      /**
       * @example AMAZON-02
       */
      clientASName: string;
      /**
       * @example 0.73996
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetNetflowsTopAsesVariables = {
  queryParams?: RadarGetNetflowsTopAsesQueryParams;
} & FetcherExtraProps;

/**
 * Get the top autonomous systems (AS) by network traffic (NetFlows) over a given time period. Visit https://en.wikipedia.org/wiki/NetFlow for more information.
 */
export const radarGetNetflowsTopAses = (variables: RadarGetNetflowsTopAsesVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetNetflowsTopAsesResponse,
    RadarGetNetflowsTopAsesError,
    undefined,
    {},
    RadarGetNetflowsTopAsesQueryParams,
    {}
  >({ url: '/radar/netflows/top/ases', method: 'get', ...variables, signal });

export type RadarGetNetflowsTopLocationsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetNetflowsTopLocationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetNetflowsTopLocationsResponse = {
  result: {
    top_0: {
      /**
       * @example US
       */
      clientCountryAlpha2: string;
      /**
       * @example United States
       */
      clientCountryName: string;
      /**
       * @example 0.73996
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetNetflowsTopLocationsVariables = {
  queryParams?: RadarGetNetflowsTopLocationsQueryParams;
} & FetcherExtraProps;

/**
 * Get the top locations by network traffic (NetFlows) over a given time period. Visit https://en.wikipedia.org/wiki/NetFlow for more information.
 */
export const radarGetNetflowsTopLocations = (variables: RadarGetNetflowsTopLocationsVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetNetflowsTopLocationsResponse,
    RadarGetNetflowsTopLocationsError,
    undefined,
    {},
    RadarGetNetflowsTopLocationsQueryParams,
    {}
  >({ url: '/radar/netflows/top/locations', method: 'get', ...variables, signal });

export type RadarGetQualityIndexSummaryQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Which metric to return: bandwidth, latency or DNS response time.
   *
   * @example latency
   */
  metric: 'BANDWIDTH' | 'DNS' | 'LATENCY';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetQualityIndexSummaryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetQualityIndexSummaryResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 32.20938
       */
      p25: string;
      /**
       * @example 61.819881
       */
      p50: string;
      /**
       * @example 133.813087
       */
      p75: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetQualityIndexSummaryVariables = {
  queryParams: RadarGetQualityIndexSummaryQueryParams;
} & FetcherExtraProps;

/**
 * Get a summary (percentiles) of bandwidth, latency or DNS response time from the Radar Internet Quality Index (IQI).
 */
export const radarGetQualityIndexSummary = (variables: RadarGetQualityIndexSummaryVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetQualityIndexSummaryResponse,
    RadarGetQualityIndexSummaryError,
    undefined,
    {},
    RadarGetQualityIndexSummaryQueryParams,
    {}
  >({ url: '/radar/quality/iqi/summary', method: 'get', ...variables, signal });

export type RadarGetQualityIndexTimeseriesGroupQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Enable interpolation for all series (using the average).
   */
  interpolation?: boolean;
  /**
   * Which metric to return: bandwidth, latency or DNS response time.
   *
   * @example latency
   */
  metric: 'BANDWIDTH' | 'DNS' | 'LATENCY';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetQualityIndexTimeseriesGroupError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetQualityIndexTimeseriesGroupResponse = {
  result: {
    meta: Record<string, any>;
    serie_0: {
      p25: string[];
      p50: string[];
      p75: string[];
      timestamps: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetQualityIndexTimeseriesGroupVariables = {
  queryParams: RadarGetQualityIndexTimeseriesGroupQueryParams;
} & FetcherExtraProps;

/**
 * Get a time series (percentiles) of bandwidth, latency or DNS response time from the Radar Internet Quality Index (IQI).
 */
export const radarGetQualityIndexTimeseriesGroup = (
  variables: RadarGetQualityIndexTimeseriesGroupVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetQualityIndexTimeseriesGroupResponse,
    RadarGetQualityIndexTimeseriesGroupError,
    undefined,
    {},
    RadarGetQualityIndexTimeseriesGroupQueryParams,
    {}
  >({ url: '/radar/quality/iqi/timeseries_groups', method: 'get', ...variables, signal });

export type RadarGetQualitySpeedHistogramQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * The width for every bucket in the histogram.
   */
  bucketSize?: number;
  /**
   * Metrics to be returned.
   *
   * @default bandwidth
   * @example bandwidth
   */
  metricGroup?: 'BANDWIDTH' | 'LATENCY' | 'JITTER';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetQualitySpeedHistogramError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetQualitySpeedHistogramResponse = {
  result: {
    histogram_0: {
      bandwidthDownload: string[];
      bandwidthUpload: string[];
      bucketMin: string[];
    };
    meta: Record<string, any>;
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetQualitySpeedHistogramVariables = {
  queryParams?: RadarGetQualitySpeedHistogramQueryParams;
} & FetcherExtraProps;

/**
 * Get an histogram from the previous 90 days of Cloudflare Speed Test data, split into fixed bandwidth (Mbps), latency (ms) or jitter (ms) buckets.
 */
export const radarGetQualitySpeedHistogram = (
  variables: RadarGetQualitySpeedHistogramVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetQualitySpeedHistogramResponse,
    RadarGetQualitySpeedHistogramError,
    undefined,
    {},
    RadarGetQualitySpeedHistogramQueryParams,
    {}
  >({ url: '/radar/quality/speed/histogram', method: 'get', ...variables, signal });

export type RadarGetQualitySpeedSummaryQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetQualitySpeedSummaryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetQualitySpeedSummaryResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
      /**
       * @example PERCENTAGE
       */
      normalization: string;
    };
    summary_0: {
      /**
       * @example 83.765201
       */
      bandwidthDownload: string;
      /**
       * @example 39.005561
       */
      bandwidthUpload: string;
      /**
       * @example 25.648713
       */
      jitterIdle: string;
      /**
       * @example 77.462155
       */
      jitterLoaded: string;
      /**
       * @example 83.165385
       */
      latencyIdle: string;
      /**
       * @example 270.561124
       */
      latencyLoaded: string;
      /**
       * @example 1.23705
       */
      packetLoss: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetQualitySpeedSummaryVariables = {
  queryParams?: RadarGetQualitySpeedSummaryQueryParams;
} & FetcherExtraProps;

/**
 * Get a summary of bandwidth, latency, jitter and packet loss, from the previous 90 days of Cloudflare Speed Test data.
 */
export const radarGetQualitySpeedSummary = (variables: RadarGetQualitySpeedSummaryVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetQualitySpeedSummaryResponse,
    RadarGetQualitySpeedSummaryError,
    undefined,
    {},
    RadarGetQualitySpeedSummaryQueryParams,
    {}
  >({ url: '/radar/quality/speed/summary', method: 'get', ...variables, signal });

export type RadarGetQualitySpeedTopAsesQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Metric to order the results by.
   *
   * @default BANDWIDTH_DOWNLOAD
   */
  orderBy?:
    | 'BANDWIDTH_DOWNLOAD'
    | 'BANDWIDTH_UPLOAD'
    | 'LATENCY_IDLE'
    | 'LATENCY_LOADED'
    | 'JITTER_IDLE'
    | 'JITTER_LOADED';
  /**
   * Reverse the order of results.
   */
  reverse?: boolean;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetQualitySpeedTopAsesError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetQualitySpeedTopAsesResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example 642.509004
       */
      bandwidthDownload: string;
      /**
       * @example 300.672274
       */
      bandwidthUpload: string;
      /**
       * @example 33353
       */
      clientASN: number;
      /**
       * @example SIE-CGEI-ASN-1
       */
      clientASName: string;
      /**
       * @example 2.956908
       */
      jitterIdle: string;
      /**
       * @example 19.500469
       */
      jitterLoaded: string;
      /**
       * @example 15.925
       */
      latencyIdle: string;
      /**
       * @example 65.65
       */
      latencyLoaded: string;
      /**
       * @example 13123
       */
      numTests: number;
      /**
       * @example 0.77
       */
      rankPower: number;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetQualitySpeedTopAsesVariables = {
  queryParams?: RadarGetQualitySpeedTopAsesQueryParams;
} & FetcherExtraProps;

/**
 * Get the top autonomous systems by bandwidth, latency, jitter or packet loss, from the previous 90 days of Cloudflare Speed Test data.
 */
export const radarGetQualitySpeedTopAses = (variables: RadarGetQualitySpeedTopAsesVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetQualitySpeedTopAsesResponse,
    RadarGetQualitySpeedTopAsesError,
    undefined,
    {},
    RadarGetQualitySpeedTopAsesQueryParams,
    {}
  >({ url: '/radar/quality/speed/top/ases', method: 'get', ...variables, signal });

export type RadarGetQualitySpeedTopLocationsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Metric to order the results by.
   *
   * @default BANDWIDTH_DOWNLOAD
   */
  orderBy?:
    | 'BANDWIDTH_DOWNLOAD'
    | 'BANDWIDTH_UPLOAD'
    | 'LATENCY_IDLE'
    | 'LATENCY_LOADED'
    | 'JITTER_IDLE'
    | 'JITTER_LOADED';
  /**
   * Reverse the order of results.
   */
  reverse?: boolean;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetQualitySpeedTopLocationsError = Fetcher.ErrorWrapper<{
  status: 404;
  payload: {
    /**
     * @example Not Found
     */
    error: string;
  };
}>;

export type RadarGetQualitySpeedTopLocationsResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @example 2023-07-26T08:59:57Z
       */
      lastUpdated: string;
    };
    top_0: {
      /**
       * @example 295.886073
       */
      bandwidthDownload: string;
      /**
       * @example 158.85269
       */
      bandwidthUpload: string;
      /**
       * @example IS
       */
      clientCountryAlpha2: string;
      /**
       * @example Iceland
       */
      clientCountryName: string;
      /**
       * @example 9.640685
       */
      jitterIdle: string;
      /**
       * @example 46.480023
       */
      jitterLoaded: string;
      /**
       * @example 15.208124
       */
      latencyIdle: string;
      /**
       * @example 114.758887
       */
      latencyLoaded: string;
      /**
       * @example 13123
       */
      numTests: number;
      /**
       * @example 0.77
       */
      rankPower: number;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetQualitySpeedTopLocationsVariables = {
  queryParams?: RadarGetQualitySpeedTopLocationsQueryParams;
} & FetcherExtraProps;

/**
 * Get the top locations by bandwidth, latency, jitter or packet loss, from the previous 90 days of Cloudflare Speed Test data.
 */
export const radarGetQualitySpeedTopLocations = (
  variables: RadarGetQualitySpeedTopLocationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetQualitySpeedTopLocationsResponse,
    RadarGetQualitySpeedTopLocationsError,
    undefined,
    {},
    RadarGetQualitySpeedTopLocationsQueryParams,
    {}
  >({ url: '/radar/quality/speed/top/locations', method: 'get', ...variables, signal });

export type RadarGetRankingDomainDetailsPathParams = {
  /**
   * @example google.com
   * @pattern ^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9-]*[A-Za-z0-9])$
   */
  domain: string;
};

export type RadarGetRankingDomainDetailsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * The ranking type.
   *
   * @default POPULAR
   * @example POPULAR
   */
  rankingType?: 'POPULAR' | 'TRENDING_RISE' | 'TRENDING_STEADY';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * Include top locations in the response.
   */
  includeTopLocations?: boolean;
  /**
   * Array of dates to filter the ranking.
   *
   * @example 2022-09-19
   */
  date?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetRankingDomainDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetRankingDomainDetailsResponse = {
  result: {
    details_0: {
      /**
       * Only available in POPULAR ranking for the most recent ranking.
       *
       * @example 2000
       */
      bucket?: string;
      categories: {
        /**
         * @example 81
         */
        id: number;
        /**
         * @example Content Servers
         */
        name: string;
        /**
         * @example 26
         */
        superCategoryId: number;
      }[];
      /**
       * @example 3
       */
      rank?: number;
      top_locations: {
        /**
         * @example US
         */
        locationCode: string;
        /**
         * @example United States
         */
        locationName: string;
        /**
         * @example 1
         */
        rank: number;
      }[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetRankingDomainDetailsVariables = {
  pathParams: RadarGetRankingDomainDetailsPathParams;
  queryParams?: RadarGetRankingDomainDetailsQueryParams;
} & FetcherExtraProps;

/**
 * Gets Domains Rank details.
 *     Cloudflare provides an ordered rank for the top 100 domains, but for the remainder it only provides ranking buckets
 *     like top 200 thousand, top one million, etc.. These are available through Radar datasets endpoints.
 */
export const radarGetRankingDomainDetails = (variables: RadarGetRankingDomainDetailsVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetRankingDomainDetailsResponse,
    RadarGetRankingDomainDetailsError,
    undefined,
    {},
    RadarGetRankingDomainDetailsQueryParams,
    RadarGetRankingDomainDetailsPathParams
  >({ url: '/radar/ranking/domain/{domain}', method: 'get', ...variables, signal });

export type RadarGetRankingDomainTimeseriesQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * The ranking type.
   *
   * @default POPULAR
   * @example POPULAR
   */
  rankingType?: 'POPULAR' | 'TRENDING_RISE' | 'TRENDING_STEADY';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * Array of locations (alpha-2 country codes).
   *
   * @example US
   */
  location?: string[];
  /**
   * Array of comma separated list of domains names.
   *
   * @example google.com,facebook.com
   */
  domains?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetRankingDomainTimeseriesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetRankingDomainTimeseriesResponse = {
  result: {
    meta: {
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
    };
    /**
     * @example {"google.com":[2],"timestamps":["2022-09-02"]}
     */
    serie_0: {
      timestamps: string[];
    } & {
      [key: string]: (string | number)[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetRankingDomainTimeseriesVariables = {
  queryParams?: RadarGetRankingDomainTimeseriesQueryParams;
} & FetcherExtraProps;

/**
 * Gets Domains Rank updates change over time. Raw values are returned.
 */
export const radarGetRankingDomainTimeseries = (
  variables: RadarGetRankingDomainTimeseriesVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetRankingDomainTimeseriesResponse,
    RadarGetRankingDomainTimeseriesError,
    undefined,
    {},
    RadarGetRankingDomainTimeseriesQueryParams,
    {}
  >({ url: '/radar/ranking/timeseries_groups', method: 'get', ...variables, signal });

export type RadarGetRankingTopDomainsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * Array of locations (alpha-2 country codes).
   *
   * @example US
   */
  location?: string[];
  /**
   * Array of dates to filter the ranking.
   *
   * @example 2022-09-19
   */
  date?: string[];
  /**
   * The ranking type.
   *
   * @default POPULAR
   * @example POPULAR
   */
  rankingType?: 'POPULAR' | 'TRENDING_RISE' | 'TRENDING_STEADY';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetRankingTopDomainsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetRankingTopDomainsResponse = {
  result: {
    meta: {
      top_0: {
        /**
         * @example 2022-09-19
         */
        date: string;
      };
    };
    top_0: {
      categories: {
        /**
         * @example 81
         */
        id: number;
        /**
         * @example Content Servers
         */
        name: string;
        /**
         * @example 26
         */
        superCategoryId: number;
      }[];
      /**
       * @example google.com
       */
      domain: string;
      /**
       * Only available in TRENDING rankings.
       *
       * @example 10.8
       */
      pctRankChange?: number;
      /**
       * @example 1
       */
      rank: number;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetRankingTopDomainsVariables = {
  queryParams?: RadarGetRankingTopDomainsQueryParams;
} & FetcherExtraProps;

/**
 * Get top or trending domains based on their rank. Popular domains are domains of broad appeal based on how people use the Internet. Trending domains are domains that are generating a surge in interest. For more information on top domains, see https://blog.cloudflare.com/radar-domain-rankings/.
 */
export const radarGetRankingTopDomains = (variables: RadarGetRankingTopDomainsVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetRankingTopDomainsResponse,
    RadarGetRankingTopDomainsError,
    undefined,
    {},
    RadarGetRankingTopDomainsQueryParams,
    {}
  >({ url: '/radar/ranking/top', method: 'get', ...variables, signal });

export type RadarGetSearchGlobalQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Limit the number of objects per search category.
   */
  limitPerGroup?: number;
  /**
   * Search for locations, AS and reports.
   *
   * @example United
   */
  query: string;
  /**
   * Search types to be included in results.
   */
  include?: ('SPECIAL_EVENTS' | 'NOTEBOOKS' | 'LOCATIONS' | 'ASNS')[];
  /**
   * Search types to be excluded from results.
   */
  exclude?: ('SPECIAL_EVENTS' | 'NOTEBOOKS' | 'LOCATIONS' | 'ASNS')[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetSearchGlobalError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetSearchGlobalResponse = {
  result: {
    search: {
      /**
       * @example 13335
       */
      code: string;
      /**
       * @example Cloudflare
       */
      name: string;
      /**
       * @example asn
       */
      type: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetSearchGlobalVariables = {
  queryParams: RadarGetSearchGlobalQueryParams;
} & FetcherExtraProps;

/**
 * Lets you search for locations, autonomous systems (ASes), and reports.
 */
export const radarGetSearchGlobal = (variables: RadarGetSearchGlobalVariables, signal?: AbortSignal) =>
  fetch<RadarGetSearchGlobalResponse, RadarGetSearchGlobalError, undefined, {}, RadarGetSearchGlobalQueryParams, {}>({
    url: '/radar/search/global',
    method: 'get',
    ...variables,
    signal
  });

export type RadarGetTcpResetsTimeoutsSummaryQueryParams = {
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetTcpResetsTimeoutsSummaryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetTcpResetsTimeoutsSummaryResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
    };
    summary_0: {
      /**
       * Connection resets within the first 10 packets from the client, but after the server has received multiple data packets.
       *
       * @example 10
       */
      later_in_flow: string;
      /**
       * All other connections.
       *
       * @example 65
       */
      no_match: string;
      /**
       * Connection resets or timeouts after the server received both a SYN packet and an ACK packet, meaning the connection was successfully established.
       *
       * @example 5
       */
      post_ack: string;
      /**
       * Connection resets or timeouts after the server received a packet with PSH flag set, following connection establishment.
       *
       * @example 10
       */
      post_psh: string;
      /**
       * Connection resets or timeouts after the server received only a single SYN packet.
       *
       * @example 10
       */
      post_syn: string;
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetTcpResetsTimeoutsSummaryVariables = {
  queryParams?: RadarGetTcpResetsTimeoutsSummaryQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution by connection stage of TCP connections terminated within the first 10 packets by a reset or timeout, for a given time period.
 */
export const radarGetTcpResetsTimeoutsSummary = (
  variables: RadarGetTcpResetsTimeoutsSummaryVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetTcpResetsTimeoutsSummaryResponse,
    RadarGetTcpResetsTimeoutsSummaryError,
    undefined,
    {},
    RadarGetTcpResetsTimeoutsSummaryQueryParams,
    {}
  >({ url: '/radar/tcp_resets_timeouts/summary', method: 'get', ...variables, signal });

export type RadarGetTcpResetsTimeoutsTimeseriesGroupQueryParams = {
  /**
   * Aggregation interval results should be returned in (for example, in 15 minutes or 1 hour intervals). Refer to [Aggregation intervals](https://developers.cloudflare.com/radar/concepts/aggregation-intervals/).
   *
   * @example 1h
   */
  aggInterval?: '15m' | '1h' | '1d' | '1w';
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetTcpResetsTimeoutsTimeseriesGroupError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetTcpResetsTimeoutsTimeseriesGroupResponse = {
  result: {
    meta: {
      /**
       * @example 1h
       */
      aggInterval: string;
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
      /**
       * @format date-time
       */
      lastUpdated: string;
    };
    serie_0: {
      later_in_flow: string[];
      no_match: string[];
      post_ack: string[];
      post_psh: string[];
      post_syn: string[];
      timestamps: string[];
    };
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetTcpResetsTimeoutsTimeseriesGroupVariables = {
  queryParams?: RadarGetTcpResetsTimeoutsTimeseriesGroupQueryParams;
} & FetcherExtraProps;

/**
 * Percentage distribution by connection stage of TCP connections terminated within the first 10 packets by a reset or timeout, over time.
 */
export const radarGetTcpResetsTimeoutsTimeseriesGroup = (
  variables: RadarGetTcpResetsTimeoutsTimeseriesGroupVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetTcpResetsTimeoutsTimeseriesGroupResponse,
    RadarGetTcpResetsTimeoutsTimeseriesGroupError,
    undefined,
    {},
    RadarGetTcpResetsTimeoutsTimeseriesGroupQueryParams,
    {}
  >({ url: '/radar/tcp_resets_timeouts/timeseries_groups', method: 'get', ...variables, signal });

export type RadarGetTrafficAnomaliesQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Number of objects to skip before grabbing results.
   */
  offset?: number;
  /**
   * Shorthand date ranges for the last X days - use when you don't need specific start and end dates.
   *
   * @example 7d
   * @pattern ^((([1-9]|[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-4])[d](control)?)|(([1-9]|[1-4][0-9]|5[0-2])[w](control)?))$
   */
  dateRange?: string;
  /**
   * Start of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   * @format date-time
   */
  dateStart?: string;
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   * @format date-time
   */
  dateEnd?: string;
  status?: 'VERIFIED' | 'UNVERIFIED';
  /**
   * Single ASN as integer.
   *
   * @example 174
   */
  asn?: number;
  /**
   * Location Alpha2 code.
   *
   * @example US
   */
  location?: string;
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetTrafficAnomaliesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetTrafficAnomaliesResponse = {
  result: {
    trafficAnomalies: {
      asnDetails?: {
        /**
         * @example 189
         */
        asn: string;
        locations?: {
          /**
           * @example US
           */
          code: string;
          /**
           * @example United States
           */
          name: string;
        };
        /**
         * @example LUMEN-LEGACY-L3-PARTITION
         */
        name: string;
      };
      /**
       * @example 2023-08-03T23:15:00Z
       */
      endDate?: string;
      locationDetails?: {
        /**
         * @example US
         */
        code: string;
        /**
         * @example United States
         */
        name: string;
      };
      /**
       * @example 2023-08-02T23:15:00Z
       */
      startDate: string;
      /**
       * @example UNVERIFIED
       */
      status: string;
      /**
       * @example LOCATION
       */
      type: string;
      /**
       * @example 55a57f33-8bc0-4984-b4df-fdaff72df39d
       */
      uuid: string;
      visibleInDataSources?: string[];
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetTrafficAnomaliesVariables = {
  queryParams?: RadarGetTrafficAnomaliesQueryParams;
} & FetcherExtraProps;

/**
 * Internet traffic anomalies are signals that might point to an outage.
 *         These alerts are automatically detected by Radar and then manually verified by our team.
 *         This endpoint returns the latest alerts.
 */
export const radarGetTrafficAnomalies = (variables: RadarGetTrafficAnomaliesVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetTrafficAnomaliesResponse,
    RadarGetTrafficAnomaliesError,
    undefined,
    {},
    RadarGetTrafficAnomaliesQueryParams,
    {}
  >({ url: '/radar/traffic_anomalies', method: 'get', ...variables, signal });

export type RadarGetTrafficAnomaliesTopQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Shorthand date ranges for the last X days - use when you don't need specific start and end dates.
   *
   * @example 7d
   * @pattern ^((([1-9]|[1-9][0-9]|[1-2][0-9][0-9]|3[0-5][0-9]|36[0-4])[d](control)?)|(([1-9]|[1-4][0-9]|5[0-2])[w](control)?))$
   */
  dateRange?: string;
  /**
   * Start of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   * @format date-time
   */
  dateStart?: string;
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   * @format date-time
   */
  dateEnd?: string;
  status?: 'VERIFIED' | 'UNVERIFIED';
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetTrafficAnomaliesTopError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetTrafficAnomaliesTopResponse = {
  result: {
    trafficAnomalies: {
      /**
       * @example PT
       */
      clientCountryAlpha2: string;
      /**
       * @example Portugal
       */
      clientCountryName: string;
      /**
       * @example 5
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetTrafficAnomaliesTopVariables = {
  queryParams?: RadarGetTrafficAnomaliesTopQueryParams;
} & FetcherExtraProps;

/**
 * Internet traffic anomalies are signals that might point to an outage.
 *         These alerts are automatically detected by Radar and then manually verified by our team.
 *         This endpoint returns the sum of alerts grouped by location.
 */
export const radarGetTrafficAnomaliesTop = (variables: RadarGetTrafficAnomaliesTopVariables, signal?: AbortSignal) =>
  fetch<
    RadarGetTrafficAnomaliesTopResponse,
    RadarGetTrafficAnomaliesTopError,
    undefined,
    {},
    RadarGetTrafficAnomaliesTopQueryParams,
    {}
  >({ url: '/radar/traffic_anomalies/locations', method: 'get', ...variables, signal });

export type RadarGetVerifiedBotsTopByHttpRequestsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetVerifiedBotsTopByHttpRequestsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetVerifiedBotsTopByHttpRequestsResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
    };
    top_0: {
      /**
       * @example Search Engine Crawler
       */
      botCategory: string;
      /**
       * @example GoogleBot
       */
      botName: string;
      /**
       * @example Google
       */
      botOwner: string;
      /**
       * @example 29.034407
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetVerifiedBotsTopByHttpRequestsVariables = {
  queryParams?: RadarGetVerifiedBotsTopByHttpRequestsQueryParams;
} & FetcherExtraProps;

/**
 * Get top verified bots by HTTP requests, with owner and category.
 */
export const radarGetVerifiedBotsTopByHttpRequests = (
  variables: RadarGetVerifiedBotsTopByHttpRequestsVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetVerifiedBotsTopByHttpRequestsResponse,
    RadarGetVerifiedBotsTopByHttpRequestsError,
    undefined,
    {},
    RadarGetVerifiedBotsTopByHttpRequestsQueryParams,
    {}
  >({ url: '/radar/verified_bots/top/bots', method: 'get', ...variables, signal });

export type RadarGetVerifiedBotsTopCategoriesByHttpRequestsQueryParams = {
  /**
   * Limit the number of objects in the response.
   *
   * @example 5
   */
  limit?: number;
  /**
   * Array of names that will be used to name the series in responses.
   *
   * @example main_series
   */
  name?: string[];
  /**
   * For example, use `7d` and `7dControl` to compare this week with the previous week. Use this parameter or set specific start and end dates (`dateStart` and `dateEnd` parameters).
   *
   * @example 7d
   */
  dateRange?: string[];
  /**
   * Array of datetimes to filter the start of a series.
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateStart?: string[];
  /**
   * End of the date range (inclusive).
   *
   * @example 2023-09-01T11:41:33.782Z
   */
  dateEnd?: string[];
  /**
   * Array of comma separated list of ASNs, start with `-` to exclude from results. For example, `-174, 3356` excludes results from AS174, but includes results from AS3356.
   *
   * @example 15169
   */
  asn?: string[];
  /**
   * Array of comma separated list of locations (alpha-2 country codes). Start with `-` to exclude from results. For example, `-US,PT` excludes results from the US, but includes results from PT.
   *
   * @example US,CA
   */
  location?: string[];
  /**
   * Array of comma separated list of continents (alpha-2 continent codes). Start with `-` to exclude from results. For example, `-EU,NA` excludes results from Europe, but includes results from North America.
   *
   * @example EU,NA
   */
  continent?: string[];
  /**
   * Format results are returned in.
   *
   * @example json
   */
  format?: 'JSON' | 'CSV';
};

export type RadarGetVerifiedBotsTopCategoriesByHttpRequestsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    errors: {
      message: string;
    }[];
    result: Record<string, any>;
    /**
     * @example false
     */
    success: boolean;
  };
}>;

export type RadarGetVerifiedBotsTopCategoriesByHttpRequestsResponse = {
  result: {
    meta: {
      confidenceInfo?: {
        annotations?: {
          /**
           * @example ALL
           */
          dataSource: string;
          /**
           * @example Cable cut in Tonga
           */
          description: string;
          /**
           * @format date-time
           */
          endTime?: string;
          /**
           * @example OUTAGE
           */
          eventType: string;
          /**
           * @example true
           */
          isInstantaneous: boolean;
          linkedUrl?: string;
          /**
           * @format date-time
           */
          startTime?: string;
        }[];
        level?: number;
      };
      dateRange: {
        /**
         * Adjusted end of date range.
         *
         * @example 2022-09-17T10:22:57.555Z
         * @format date-time
         */
        endTime: string;
        /**
         * Adjusted start of date range.
         *
         * @example 2022-09-16T10:22:57.555Z
         * @format date-time
         */
        startTime: string;
      }[];
    };
    top_0: {
      /**
       * @example Search
       */
      botCategory: string;
      /**
       * @example 65
       */
      value: string;
    }[];
  };
  /**
   * @example true
   */
  success: boolean;
};

export type RadarGetVerifiedBotsTopCategoriesByHttpRequestsVariables = {
  queryParams?: RadarGetVerifiedBotsTopCategoriesByHttpRequestsQueryParams;
} & FetcherExtraProps;

/**
 * Get top verified bot categories by HTTP requests, along with their corresponding percentage, over the total verified bot HTTP requests.
 */
export const radarGetVerifiedBotsTopCategoriesByHttpRequests = (
  variables: RadarGetVerifiedBotsTopCategoriesByHttpRequestsVariables,
  signal?: AbortSignal
) =>
  fetch<
    RadarGetVerifiedBotsTopCategoriesByHttpRequestsResponse,
    RadarGetVerifiedBotsTopCategoriesByHttpRequestsError,
    undefined,
    {},
    RadarGetVerifiedBotsTopCategoriesByHttpRequestsQueryParams,
    {}
  >({ url: '/radar/verified_bots/top/categories', method: 'get', ...variables, signal });

export type UserUserDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserUserDetailsVariables = FetcherExtraProps;

export const userUserDetails = (variables: UserUserDetailsVariables, signal?: AbortSignal) =>
  fetch<Schemas.IamSingleUserResponse, UserUserDetailsError, undefined, {}, {}, {}>({
    url: '/user',
    method: 'get',
    ...variables,
    signal
  });

export type UserEditUserError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserEditUserRequestBody = {
  country?: Schemas.IamCountry;
  first_name?: Schemas.IamFirstName;
  last_name?: Schemas.IamLastName;
  telephone?: Schemas.IamTelephone;
  zipcode?: Schemas.IamZipcode;
};

export type UserEditUserVariables = {
  body?: UserEditUserRequestBody;
} & FetcherExtraProps;

/**
 * Edit part of your user details.
 */
export const userEditUser = (variables: UserEditUserVariables, signal?: AbortSignal) =>
  fetch<Schemas.IamSingleUserResponse, UserEditUserError, UserEditUserRequestBody, {}, {}, {}>({
    url: '/user',
    method: 'patch',
    ...variables,
    signal
  });

export type AuditLogsGetUserAuditLogsQueryParams = {
  /**
   * @example f174be97-19b1-40d6-954d-70cd5fbd52db
   */
  id?: string;
  /**
   * @example true
   */
  ['export']?: boolean;
  /**
   * @example add
   */
  ['action.type']?: string;
  /**
   * @example 17.168.228.63
   */
  ['actor.ip']?: string;
  /**
   * @example alice@example.com
   * @format email
   */
  ['actor.email']?: string;
  since?: string | string;
  before?: string | string;
  /**
   * @example example.com
   */
  ['zone.name']?: string;
  /**
   * @default desc
   * @example desc
   */
  direction?: 'desc' | 'asc';
  /**
   * @default 100
   * @example 25
   * @maximum 1000
   * @minimum 1
   */
  per_page?: number;
  /**
   * @default 1
   * @example 50
   * @minimum 1
   */
  page?: number;
  /**
   * @default false
   */
  hide_user_logs?: boolean;
};

export type AuditLogsGetUserAuditLogsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AaaAuditLogsResponseCollection & Schemas.AaaApiResponseCommonFailure;
}>;

export type AuditLogsGetUserAuditLogsVariables = {
  queryParams?: AuditLogsGetUserAuditLogsQueryParams;
} & FetcherExtraProps;

/**
 * Gets a list of audit logs for a user account. Can be filtered by who made the change, on which zone, and the timeframe of the change.
 */
export const auditLogsGetUserAuditLogs = (variables: AuditLogsGetUserAuditLogsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.AaaAuditLogsResponseCollection,
    AuditLogsGetUserAuditLogsError,
    undefined,
    {},
    AuditLogsGetUserAuditLogsQueryParams,
    {}
  >({ url: '/user/audit_logs', method: 'get', ...variables, signal });

export type UserBillingHistoryDeprecatedBillingHistoryDetailsQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example occurred_at
   */
  order?: 'type' | 'occurred_at' | 'action';
  occurred_at?: Schemas.BillSubsApiOccurredAt;
  /**
   * @example charge
   * @maxLength 30
   */
  type?: string;
  /**
   * @example subscription
   * @maxLength 30
   */
  action?: string;
};

export type UserBillingHistoryDeprecatedBillingHistoryDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.BillSubsApiBillingHistoryCollection & Schemas.BillSubsApiApiResponseCommonFailure;
}>;

export type UserBillingHistoryDeprecatedBillingHistoryDetailsVariables = {
  queryParams?: UserBillingHistoryDeprecatedBillingHistoryDetailsQueryParams;
} & FetcherExtraProps;

/**
 * Accesses your billing history object.
 */
export const userBillingHistoryDeprecatedBillingHistoryDetails = (
  variables: UserBillingHistoryDeprecatedBillingHistoryDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.BillSubsApiBillingHistoryCollection,
    UserBillingHistoryDeprecatedBillingHistoryDetailsError,
    undefined,
    {},
    UserBillingHistoryDeprecatedBillingHistoryDetailsQueryParams,
    {}
  >({ url: '/user/billing/history', method: 'get', ...variables, signal });

export type UserBillingProfileDeprecatedBillingProfileDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.BillSubsApiBillingResponseSingle & Schemas.BillSubsApiApiResponseCommonFailure;
}>;

export type UserBillingProfileDeprecatedBillingProfileDetailsVariables = FetcherExtraProps;

/**
 * Accesses your billing profile object.
 */
export const userBillingProfileDeprecatedBillingProfileDetails = (
  variables: UserBillingProfileDeprecatedBillingProfileDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.BillSubsApiBillingResponseSingle,
    UserBillingProfileDeprecatedBillingProfileDetailsError,
    undefined,
    {},
    {},
    {}
  >({ url: '/user/billing/profile', method: 'get', ...variables, signal });

export type IpAccessRulesForAUserListIpAccessRulesQueryParams = {
  mode?: Schemas.FirewallSchemasMode;
  /**
   * @example ip
   */
  ['configuration.target']?: 'ip' | 'ip_range' | 'asn' | 'country';
  /**
   * @example 198.51.100.4
   */
  ['configuration.value']?: string;
  /**
   * @example my note
   */
  notes?: string;
  /**
   * @default all
   */
  match?: 'any' | 'all';
  /**
   * @example 1
   */
  page?: number;
  /**
   * @example 20
   */
  per_page?: number;
  /**
   * @example mode
   */
  order?: 'configuration.target' | 'configuration.value' | 'mode';
  /**
   * @example desc
   */
  direction?: 'asc' | 'desc';
};

export type IpAccessRulesForAUserListIpAccessRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallRuleCollectionResponse & Schemas.FirewallApiResponseCommonFailure;
}>;

export type IpAccessRulesForAUserListIpAccessRulesVariables = {
  queryParams?: IpAccessRulesForAUserListIpAccessRulesQueryParams;
} & FetcherExtraProps;

/**
 * Fetches IP Access rules of the user. You can filter the results using several optional parameters.
 */
export const ipAccessRulesForAUserListIpAccessRules = (
  variables: IpAccessRulesForAUserListIpAccessRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallRuleCollectionResponse,
    IpAccessRulesForAUserListIpAccessRulesError,
    undefined,
    {},
    IpAccessRulesForAUserListIpAccessRulesQueryParams,
    {}
  >({ url: '/user/firewall/access_rules/rules', method: 'get', ...variables, signal });

export type IpAccessRulesForAUserCreateAnIpAccessRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallRuleSingleResponse & Schemas.FirewallApiResponseCommonFailure;
}>;

export type IpAccessRulesForAUserCreateAnIpAccessRuleRequestBody = {
  configuration: Schemas.FirewallConfiguration;
  mode: Schemas.FirewallSchemasMode;
  notes?: Schemas.FirewallNotes;
};

export type IpAccessRulesForAUserCreateAnIpAccessRuleVariables = {
  body: IpAccessRulesForAUserCreateAnIpAccessRuleRequestBody;
} & FetcherExtraProps;

/**
 * Creates a new IP Access rule for all zones owned by the current user.
 *
 * Note: To create an IP Access rule that applies to a specific zone, refer to the [IP Access rules for a zone](#ip-access-rules-for-a-zone) endpoints.
 */
export const ipAccessRulesForAUserCreateAnIpAccessRule = (
  variables: IpAccessRulesForAUserCreateAnIpAccessRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallRuleSingleResponse,
    IpAccessRulesForAUserCreateAnIpAccessRuleError,
    IpAccessRulesForAUserCreateAnIpAccessRuleRequestBody,
    {},
    {},
    {}
  >({ url: '/user/firewall/access_rules/rules', method: 'post', ...variables, signal });

export type IpAccessRulesForAUserDeleteAnIpAccessRulePathParams = {
  ruleId: Schemas.FirewallRuleIdentifier;
};

export type IpAccessRulesForAUserDeleteAnIpAccessRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallRuleSingleIdResponse & Schemas.FirewallApiResponseCommonFailure;
}>;

export type IpAccessRulesForAUserDeleteAnIpAccessRuleVariables = {
  pathParams: IpAccessRulesForAUserDeleteAnIpAccessRulePathParams;
} & FetcherExtraProps;

/**
 * Deletes an IP Access rule at the user level.
 *
 * Note: Deleting a user-level rule will affect all zones owned by the user.
 */
export const ipAccessRulesForAUserDeleteAnIpAccessRule = (
  variables: IpAccessRulesForAUserDeleteAnIpAccessRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallRuleSingleIdResponse,
    IpAccessRulesForAUserDeleteAnIpAccessRuleError,
    undefined,
    {},
    {},
    IpAccessRulesForAUserDeleteAnIpAccessRulePathParams
  >({ url: '/user/firewall/access_rules/rules/{ruleId}', method: 'delete', ...variables, signal });

export type IpAccessRulesForAUserUpdateAnIpAccessRulePathParams = {
  ruleId: Schemas.FirewallRuleIdentifier;
};

export type IpAccessRulesForAUserUpdateAnIpAccessRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallRuleSingleResponse & Schemas.FirewallApiResponseCommonFailure;
}>;

export type IpAccessRulesForAUserUpdateAnIpAccessRuleRequestBody = {
  mode?: Schemas.FirewallSchemasMode;
  notes?: Schemas.FirewallNotes;
};

export type IpAccessRulesForAUserUpdateAnIpAccessRuleVariables = {
  body?: IpAccessRulesForAUserUpdateAnIpAccessRuleRequestBody;
  pathParams: IpAccessRulesForAUserUpdateAnIpAccessRulePathParams;
} & FetcherExtraProps;

/**
 * Updates an IP Access rule defined at the user level. You can only update the rule action (`mode` parameter) and notes.
 */
export const ipAccessRulesForAUserUpdateAnIpAccessRule = (
  variables: IpAccessRulesForAUserUpdateAnIpAccessRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallRuleSingleResponse,
    IpAccessRulesForAUserUpdateAnIpAccessRuleError,
    IpAccessRulesForAUserUpdateAnIpAccessRuleRequestBody,
    {},
    {},
    IpAccessRulesForAUserUpdateAnIpAccessRulePathParams
  >({ url: '/user/firewall/access_rules/rules/{ruleId}', method: 'patch', ...variables, signal });

export type UserSInvitesListInvitationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserSInvitesListInvitationsVariables = FetcherExtraProps;

/**
 * Lists all invitations associated with my user.
 */
export const userSInvitesListInvitations = (variables: UserSInvitesListInvitationsVariables, signal?: AbortSignal) =>
  fetch<Schemas.IamSchemasCollectionInviteResponse, UserSInvitesListInvitationsError, undefined, {}, {}, {}>({
    url: '/user/invites',
    method: 'get',
    ...variables,
    signal
  });

export type UserSInvitesInvitationDetailsPathParams = {
  inviteId: Schemas.IamInviteComponentsSchemasIdentifier;
};

export type UserSInvitesInvitationDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserSInvitesInvitationDetailsVariables = {
  pathParams: UserSInvitesInvitationDetailsPathParams;
} & FetcherExtraProps;

/**
 * Gets the details of an invitation.
 */
export const userSInvitesInvitationDetails = (
  variables: UserSInvitesInvitationDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.IamSingleInviteResponse,
    UserSInvitesInvitationDetailsError,
    undefined,
    {},
    {},
    UserSInvitesInvitationDetailsPathParams
  >({ url: '/user/invites/{inviteId}', method: 'get', ...variables, signal });

export type UserSInvitesRespondToInvitationPathParams = {
  inviteId: Schemas.IamInviteComponentsSchemasIdentifier;
};

export type UserSInvitesRespondToInvitationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserSInvitesRespondToInvitationRequestBody = {
  /**
   * Status of your response to the invitation (rejected or accepted).
   *
   * @example accepted
   */
  status: 'accepted' | 'rejected';
};

export type UserSInvitesRespondToInvitationVariables = {
  body: UserSInvitesRespondToInvitationRequestBody;
  pathParams: UserSInvitesRespondToInvitationPathParams;
} & FetcherExtraProps;

/**
 * Responds to an invitation.
 */
export const userSInvitesRespondToInvitation = (
  variables: UserSInvitesRespondToInvitationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.IamSingleInviteResponse,
    UserSInvitesRespondToInvitationError,
    UserSInvitesRespondToInvitationRequestBody,
    {},
    {},
    UserSInvitesRespondToInvitationPathParams
  >({ url: '/user/invites/{inviteId}', method: 'patch', ...variables, signal });

export type LoadBalancerMonitorsListMonitorsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingMonitorResponseCollection & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerMonitorsListMonitorsVariables = FetcherExtraProps;

/**
 * List configured monitors for a user.
 */
export const loadBalancerMonitorsListMonitors = (
  variables: LoadBalancerMonitorsListMonitorsVariables,
  signal?: AbortSignal
) =>
  fetch<Schemas.LoadBalancingMonitorResponseCollection, LoadBalancerMonitorsListMonitorsError, undefined, {}, {}, {}>({
    url: '/user/load_balancers/monitors',
    method: 'get',
    ...variables,
    signal
  });

export type LoadBalancerMonitorsCreateMonitorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingMonitorResponseSingle & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerMonitorsCreateMonitorRequestBody = Schemas.LoadBalancingMonitorEditable;

export type LoadBalancerMonitorsCreateMonitorVariables = {
  body?: LoadBalancerMonitorsCreateMonitorRequestBody;
} & FetcherExtraProps;

/**
 * Create a configured monitor.
 */
export const loadBalancerMonitorsCreateMonitor = (
  variables: LoadBalancerMonitorsCreateMonitorVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingMonitorResponseSingle,
    LoadBalancerMonitorsCreateMonitorError,
    LoadBalancerMonitorsCreateMonitorRequestBody,
    {},
    {},
    {}
  >({ url: '/user/load_balancers/monitors', method: 'post', ...variables, signal });

export type LoadBalancerMonitorsDeleteMonitorPathParams = {
  monitorId: Schemas.LoadBalancingIdentifier;
};

export type LoadBalancerMonitorsDeleteMonitorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingIdResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerMonitorsDeleteMonitorVariables = {
  pathParams: LoadBalancerMonitorsDeleteMonitorPathParams;
} & FetcherExtraProps;

/**
 * Delete a configured monitor.
 */
export const loadBalancerMonitorsDeleteMonitor = (
  variables: LoadBalancerMonitorsDeleteMonitorVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingIdResponse,
    LoadBalancerMonitorsDeleteMonitorError,
    undefined,
    {},
    {},
    LoadBalancerMonitorsDeleteMonitorPathParams
  >({ url: '/user/load_balancers/monitors/{monitorId}', method: 'delete', ...variables, signal });

export type LoadBalancerMonitorsMonitorDetailsPathParams = {
  monitorId: Schemas.LoadBalancingIdentifier;
};

export type LoadBalancerMonitorsMonitorDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingMonitorResponseSingle & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerMonitorsMonitorDetailsVariables = {
  pathParams: LoadBalancerMonitorsMonitorDetailsPathParams;
} & FetcherExtraProps;

/**
 * List a single configured monitor for a user.
 */
export const loadBalancerMonitorsMonitorDetails = (
  variables: LoadBalancerMonitorsMonitorDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingMonitorResponseSingle,
    LoadBalancerMonitorsMonitorDetailsError,
    undefined,
    {},
    {},
    LoadBalancerMonitorsMonitorDetailsPathParams
  >({ url: '/user/load_balancers/monitors/{monitorId}', method: 'get', ...variables, signal });

export type LoadBalancerMonitorsPatchMonitorPathParams = {
  monitorId: Schemas.LoadBalancingIdentifier;
};

export type LoadBalancerMonitorsPatchMonitorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingMonitorResponseSingle & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerMonitorsPatchMonitorRequestBody = Schemas.LoadBalancingMonitorEditable;

export type LoadBalancerMonitorsPatchMonitorVariables = {
  body?: LoadBalancerMonitorsPatchMonitorRequestBody;
  pathParams: LoadBalancerMonitorsPatchMonitorPathParams;
} & FetcherExtraProps;

/**
 * Apply changes to an existing monitor, overwriting the supplied properties.
 */
export const loadBalancerMonitorsPatchMonitor = (
  variables: LoadBalancerMonitorsPatchMonitorVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingMonitorResponseSingle,
    LoadBalancerMonitorsPatchMonitorError,
    LoadBalancerMonitorsPatchMonitorRequestBody,
    {},
    {},
    LoadBalancerMonitorsPatchMonitorPathParams
  >({ url: '/user/load_balancers/monitors/{monitorId}', method: 'patch', ...variables, signal });

export type LoadBalancerMonitorsUpdateMonitorPathParams = {
  monitorId: Schemas.LoadBalancingIdentifier;
};

export type LoadBalancerMonitorsUpdateMonitorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingMonitorResponseSingle & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerMonitorsUpdateMonitorRequestBody = Schemas.LoadBalancingMonitorEditable;

export type LoadBalancerMonitorsUpdateMonitorVariables = {
  body?: LoadBalancerMonitorsUpdateMonitorRequestBody;
  pathParams: LoadBalancerMonitorsUpdateMonitorPathParams;
} & FetcherExtraProps;

/**
 * Modify a configured monitor.
 */
export const loadBalancerMonitorsUpdateMonitor = (
  variables: LoadBalancerMonitorsUpdateMonitorVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingMonitorResponseSingle,
    LoadBalancerMonitorsUpdateMonitorError,
    LoadBalancerMonitorsUpdateMonitorRequestBody,
    {},
    {},
    LoadBalancerMonitorsUpdateMonitorPathParams
  >({ url: '/user/load_balancers/monitors/{monitorId}', method: 'put', ...variables, signal });

export type LoadBalancerMonitorsPreviewMonitorPathParams = {
  monitorId: Schemas.LoadBalancingIdentifier;
};

export type LoadBalancerMonitorsPreviewMonitorError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingPreviewResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerMonitorsPreviewMonitorRequestBody = Schemas.LoadBalancingMonitorEditable;

export type LoadBalancerMonitorsPreviewMonitorVariables = {
  body?: LoadBalancerMonitorsPreviewMonitorRequestBody;
  pathParams: LoadBalancerMonitorsPreviewMonitorPathParams;
} & FetcherExtraProps;

/**
 * Preview pools using the specified monitor with provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
 */
export const loadBalancerMonitorsPreviewMonitor = (
  variables: LoadBalancerMonitorsPreviewMonitorVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingPreviewResponse,
    LoadBalancerMonitorsPreviewMonitorError,
    LoadBalancerMonitorsPreviewMonitorRequestBody,
    {},
    {},
    LoadBalancerMonitorsPreviewMonitorPathParams
  >({ url: '/user/load_balancers/monitors/{monitorId}/preview', method: 'post', ...variables, signal });

export type LoadBalancerMonitorsListMonitorReferencesPathParams = {
  monitorId: Schemas.LoadBalancingIdentifier;
};

export type LoadBalancerMonitorsListMonitorReferencesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingMonitorReferencesResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerMonitorsListMonitorReferencesVariables = {
  pathParams: LoadBalancerMonitorsListMonitorReferencesPathParams;
} & FetcherExtraProps;

/**
 * Get the list of resources that reference the provided monitor.
 */
export const loadBalancerMonitorsListMonitorReferences = (
  variables: LoadBalancerMonitorsListMonitorReferencesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingMonitorReferencesResponse,
    LoadBalancerMonitorsListMonitorReferencesError,
    undefined,
    {},
    {},
    LoadBalancerMonitorsListMonitorReferencesPathParams
  >({ url: '/user/load_balancers/monitors/{monitorId}/references', method: 'get', ...variables, signal });

export type LoadBalancerPoolsListPoolsQueryParams = {
  monitor?: string;
};

export type LoadBalancerPoolsListPoolsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingSchemasResponseCollection & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerPoolsListPoolsVariables = {
  queryParams?: LoadBalancerPoolsListPoolsQueryParams;
} & FetcherExtraProps;

/**
 * List configured pools.
 */
export const loadBalancerPoolsListPools = (variables: LoadBalancerPoolsListPoolsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.LoadBalancingSchemasResponseCollection,
    LoadBalancerPoolsListPoolsError,
    undefined,
    {},
    LoadBalancerPoolsListPoolsQueryParams,
    {}
  >({ url: '/user/load_balancers/pools', method: 'get', ...variables, signal });

export type LoadBalancerPoolsPatchPoolsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingSchemasResponseCollection & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerPoolsPatchPoolsRequestBody = {
  notification_email?: Schemas.LoadBalancingPatchPoolsNotificationEmail;
};

export type LoadBalancerPoolsPatchPoolsVariables = {
  body?: LoadBalancerPoolsPatchPoolsRequestBody;
} & FetcherExtraProps;

/**
 * Apply changes to a number of existing pools, overwriting the supplied properties. Pools are ordered by ascending `name`. Returns the list of affected pools. Supports the standard pagination query parameters, either `limit`/`offset` or `per_page`/`page`.
 */
export const loadBalancerPoolsPatchPools = (variables: LoadBalancerPoolsPatchPoolsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.LoadBalancingSchemasResponseCollection,
    LoadBalancerPoolsPatchPoolsError,
    LoadBalancerPoolsPatchPoolsRequestBody,
    {},
    {},
    {}
  >({ url: '/user/load_balancers/pools', method: 'patch', ...variables, signal });

export type LoadBalancerPoolsCreatePoolError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingSchemasSingleResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerPoolsCreatePoolRequestBody = {
  check_regions?: Schemas.LoadBalancingCheckRegions;
  description?: Schemas.LoadBalancingSchemasDescription;
  enabled?: Schemas.LoadBalancingEnabled;
  latitude?: Schemas.LoadBalancingLatitude;
  load_shedding?: Schemas.LoadBalancingLoadShedding;
  longitude?: Schemas.LoadBalancingLongitude;
  minimum_origins?: Schemas.LoadBalancingMinimumOrigins;
  monitor?: Schemas.LoadBalancingMonitorId;
  name: Schemas.LoadBalancingName;
  networks?: Schemas.LoadBalancingNetworks;
  notification_email?: Schemas.LoadBalancingNotificationEmail;
  notification_filter?: Schemas.LoadBalancingNotificationFilter;
  origin_steering?: Schemas.LoadBalancingOriginSteering;
  origins: Schemas.LoadBalancingOrigins;
};

export type LoadBalancerPoolsCreatePoolVariables = {
  body: LoadBalancerPoolsCreatePoolRequestBody;
} & FetcherExtraProps;

/**
 * Create a new pool.
 */
export const loadBalancerPoolsCreatePool = (variables: LoadBalancerPoolsCreatePoolVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.LoadBalancingSchemasSingleResponse,
    LoadBalancerPoolsCreatePoolError,
    LoadBalancerPoolsCreatePoolRequestBody,
    {},
    {},
    {}
  >({ url: '/user/load_balancers/pools', method: 'post', ...variables, signal });

export type LoadBalancerPoolsDeletePoolPathParams = {
  poolId: Schemas.LoadBalancingSchemasIdentifier;
};

export type LoadBalancerPoolsDeletePoolError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingSchemasIdResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerPoolsDeletePoolVariables = {
  pathParams: LoadBalancerPoolsDeletePoolPathParams;
} & FetcherExtraProps;

/**
 * Delete a configured pool.
 */
export const loadBalancerPoolsDeletePool = (variables: LoadBalancerPoolsDeletePoolVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.LoadBalancingSchemasIdResponse,
    LoadBalancerPoolsDeletePoolError,
    undefined,
    {},
    {},
    LoadBalancerPoolsDeletePoolPathParams
  >({ url: '/user/load_balancers/pools/{poolId}', method: 'delete', ...variables, signal });

export type LoadBalancerPoolsPoolDetailsPathParams = {
  poolId: Schemas.LoadBalancingSchemasIdentifier;
};

export type LoadBalancerPoolsPoolDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingSchemasSingleResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerPoolsPoolDetailsVariables = {
  pathParams: LoadBalancerPoolsPoolDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetch a single configured pool.
 */
export const loadBalancerPoolsPoolDetails = (variables: LoadBalancerPoolsPoolDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.LoadBalancingSchemasSingleResponse,
    LoadBalancerPoolsPoolDetailsError,
    undefined,
    {},
    {},
    LoadBalancerPoolsPoolDetailsPathParams
  >({ url: '/user/load_balancers/pools/{poolId}', method: 'get', ...variables, signal });

export type LoadBalancerPoolsPatchPoolPathParams = {
  poolId: Schemas.LoadBalancingSchemasIdentifier;
};

export type LoadBalancerPoolsPatchPoolError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingSchemasSingleResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerPoolsPatchPoolRequestBody = {
  check_regions?: Schemas.LoadBalancingCheckRegions;
  description?: Schemas.LoadBalancingSchemasDescription;
  disabled_at?: Schemas.LoadBalancingSchemasDisabledAt;
  enabled?: Schemas.LoadBalancingEnabled;
  latitude?: Schemas.LoadBalancingLatitude;
  load_shedding?: Schemas.LoadBalancingLoadShedding;
  longitude?: Schemas.LoadBalancingLongitude;
  minimum_origins?: Schemas.LoadBalancingMinimumOrigins;
  monitor?: Schemas.LoadBalancingMonitorId;
  name?: Schemas.LoadBalancingName;
  notification_email?: Schemas.LoadBalancingNotificationEmail;
  notification_filter?: Schemas.LoadBalancingNotificationFilter;
  origin_steering?: Schemas.LoadBalancingOriginSteering;
  origins?: Schemas.LoadBalancingOrigins;
};

export type LoadBalancerPoolsPatchPoolVariables = {
  body?: LoadBalancerPoolsPatchPoolRequestBody;
  pathParams: LoadBalancerPoolsPatchPoolPathParams;
} & FetcherExtraProps;

/**
 * Apply changes to an existing pool, overwriting the supplied properties.
 */
export const loadBalancerPoolsPatchPool = (variables: LoadBalancerPoolsPatchPoolVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.LoadBalancingSchemasSingleResponse,
    LoadBalancerPoolsPatchPoolError,
    LoadBalancerPoolsPatchPoolRequestBody,
    {},
    {},
    LoadBalancerPoolsPatchPoolPathParams
  >({ url: '/user/load_balancers/pools/{poolId}', method: 'patch', ...variables, signal });

export type LoadBalancerPoolsUpdatePoolPathParams = {
  poolId: Schemas.LoadBalancingSchemasIdentifier;
};

export type LoadBalancerPoolsUpdatePoolError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingSchemasSingleResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerPoolsUpdatePoolRequestBody = {
  check_regions?: Schemas.LoadBalancingCheckRegions;
  description?: Schemas.LoadBalancingSchemasDescription;
  disabled_at?: Schemas.LoadBalancingSchemasDisabledAt;
  enabled?: Schemas.LoadBalancingEnabled;
  latitude?: Schemas.LoadBalancingLatitude;
  load_shedding?: Schemas.LoadBalancingLoadShedding;
  longitude?: Schemas.LoadBalancingLongitude;
  minimum_origins?: Schemas.LoadBalancingMinimumOrigins;
  monitor?: Schemas.LoadBalancingMonitorId;
  name: Schemas.LoadBalancingName;
  networks?: Schemas.LoadBalancingNetworks;
  notification_email?: Schemas.LoadBalancingNotificationEmail;
  notification_filter?: Schemas.LoadBalancingNotificationFilter;
  origin_steering?: Schemas.LoadBalancingOriginSteering;
  origins: Schemas.LoadBalancingOrigins;
};

export type LoadBalancerPoolsUpdatePoolVariables = {
  body: LoadBalancerPoolsUpdatePoolRequestBody;
  pathParams: LoadBalancerPoolsUpdatePoolPathParams;
} & FetcherExtraProps;

/**
 * Modify a configured pool.
 */
export const loadBalancerPoolsUpdatePool = (variables: LoadBalancerPoolsUpdatePoolVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.LoadBalancingSchemasSingleResponse,
    LoadBalancerPoolsUpdatePoolError,
    LoadBalancerPoolsUpdatePoolRequestBody,
    {},
    {},
    LoadBalancerPoolsUpdatePoolPathParams
  >({ url: '/user/load_balancers/pools/{poolId}', method: 'put', ...variables, signal });

export type LoadBalancerPoolsPoolHealthDetailsPathParams = {
  poolId: Schemas.LoadBalancingSchemasIdentifier;
};

export type LoadBalancerPoolsPoolHealthDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingHealthDetails & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerPoolsPoolHealthDetailsVariables = {
  pathParams: LoadBalancerPoolsPoolHealthDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetch the latest pool health status for a single pool.
 */
export const loadBalancerPoolsPoolHealthDetails = (
  variables: LoadBalancerPoolsPoolHealthDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingHealthDetails,
    LoadBalancerPoolsPoolHealthDetailsError,
    undefined,
    {},
    {},
    LoadBalancerPoolsPoolHealthDetailsPathParams
  >({ url: '/user/load_balancers/pools/{poolId}/health', method: 'get', ...variables, signal });

export type LoadBalancerPoolsPreviewPoolPathParams = {
  poolId: Schemas.LoadBalancingSchemasIdentifier;
};

export type LoadBalancerPoolsPreviewPoolError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingPreviewResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerPoolsPreviewPoolRequestBody = Schemas.LoadBalancingMonitorEditable;

export type LoadBalancerPoolsPreviewPoolVariables = {
  body?: LoadBalancerPoolsPreviewPoolRequestBody;
  pathParams: LoadBalancerPoolsPreviewPoolPathParams;
} & FetcherExtraProps;

/**
 * Preview pool health using provided monitor details. The returned preview_id can be used in the preview endpoint to retrieve the results.
 */
export const loadBalancerPoolsPreviewPool = (variables: LoadBalancerPoolsPreviewPoolVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.LoadBalancingPreviewResponse,
    LoadBalancerPoolsPreviewPoolError,
    LoadBalancerPoolsPreviewPoolRequestBody,
    {},
    {},
    LoadBalancerPoolsPreviewPoolPathParams
  >({ url: '/user/load_balancers/pools/{poolId}/preview', method: 'post', ...variables, signal });

export type LoadBalancerPoolsListPoolReferencesPathParams = {
  poolId: Schemas.LoadBalancingSchemasIdentifier;
};

export type LoadBalancerPoolsListPoolReferencesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingPoolsReferencesResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerPoolsListPoolReferencesVariables = {
  pathParams: LoadBalancerPoolsListPoolReferencesPathParams;
} & FetcherExtraProps;

/**
 * Get the list of resources that reference the provided pool.
 */
export const loadBalancerPoolsListPoolReferences = (
  variables: LoadBalancerPoolsListPoolReferencesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingPoolsReferencesResponse,
    LoadBalancerPoolsListPoolReferencesError,
    undefined,
    {},
    {},
    LoadBalancerPoolsListPoolReferencesPathParams
  >({ url: '/user/load_balancers/pools/{poolId}/references', method: 'get', ...variables, signal });

export type LoadBalancerMonitorsPreviewResultPathParams = {
  previewId: Schemas.LoadBalancingPreviewId;
};

export type LoadBalancerMonitorsPreviewResultError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingPreviewResultResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerMonitorsPreviewResultVariables = {
  pathParams: LoadBalancerMonitorsPreviewResultPathParams;
} & FetcherExtraProps;

/**
 * Get the result of a previous preview operation using the provided preview_id.
 */
export const loadBalancerMonitorsPreviewResult = (
  variables: LoadBalancerMonitorsPreviewResultVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingPreviewResultResponse,
    LoadBalancerMonitorsPreviewResultError,
    undefined,
    {},
    {},
    LoadBalancerMonitorsPreviewResultPathParams
  >({ url: '/user/load_balancers/preview/{previewId}', method: 'get', ...variables, signal });

export type LoadBalancerHealthcheckEventsListHealthcheckEventsQueryParams = {
  until?: Schemas.LoadBalancingUntil;
  pool_name?: Schemas.LoadBalancingPoolName;
  origin_healthy?: Schemas.LoadBalancingOriginHealthy2;
  pool_id?: Schemas.LoadBalancingSchemasIdentifier;
  /**
   * @example 2016-11-11T12:00:00Z
   * @format date-time
   */
  since?: string;
  /**
   * @example primary-dc-1
   */
  origin_name?: string;
  /**
   * @default true
   * @example true
   */
  pool_healthy?: boolean;
};

export type LoadBalancerHealthcheckEventsListHealthcheckEventsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingComponentsSchemasResponseCollection & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancerHealthcheckEventsListHealthcheckEventsVariables = {
  queryParams?: LoadBalancerHealthcheckEventsListHealthcheckEventsQueryParams;
} & FetcherExtraProps;

/**
 * List origin health changes.
 */
export const loadBalancerHealthcheckEventsListHealthcheckEvents = (
  variables: LoadBalancerHealthcheckEventsListHealthcheckEventsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingComponentsSchemasResponseCollection,
    LoadBalancerHealthcheckEventsListHealthcheckEventsError,
    undefined,
    {},
    LoadBalancerHealthcheckEventsListHealthcheckEventsQueryParams,
    {}
  >({ url: '/user/load_balancing_analytics/events', method: 'get', ...variables, signal });

export type UserSOrganizationsListOrganizationsQueryParams = {
  name?: Schemas.IamSchemasName;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example status
   */
  order?: 'id' | 'name' | 'status';
  /**
   * @example desc
   */
  direction?: 'asc' | 'desc';
  /**
   * @default all
   */
  match?: 'any' | 'all';
  /**
   * @example member
   */
  status?: 'member' | 'invited';
};

export type UserSOrganizationsListOrganizationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserSOrganizationsListOrganizationsVariables = {
  queryParams?: UserSOrganizationsListOrganizationsQueryParams;
} & FetcherExtraProps;

/**
 * Lists organizations the user is associated with.
 */
export const userSOrganizationsListOrganizations = (
  variables: UserSOrganizationsListOrganizationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.IamCollectionOrganizationResponse,
    UserSOrganizationsListOrganizationsError,
    undefined,
    {},
    UserSOrganizationsListOrganizationsQueryParams,
    {}
  >({ url: '/user/organizations', method: 'get', ...variables, signal });

export type UserSOrganizationsLeaveOrganizationPathParams = {
  organizationId: Schemas.IamCommonComponentsSchemasIdentifier;
};

export type UserSOrganizationsLeaveOrganizationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserSOrganizationsLeaveOrganizationResponse = {
  id?: Schemas.IamCommonComponentsSchemasIdentifier;
};

export type UserSOrganizationsLeaveOrganizationVariables = {
  pathParams: UserSOrganizationsLeaveOrganizationPathParams;
} & FetcherExtraProps;

/**
 * Removes association to an organization.
 */
export const userSOrganizationsLeaveOrganization = (
  variables: UserSOrganizationsLeaveOrganizationVariables,
  signal?: AbortSignal
) =>
  fetch<
    UserSOrganizationsLeaveOrganizationResponse,
    UserSOrganizationsLeaveOrganizationError,
    undefined,
    {},
    {},
    UserSOrganizationsLeaveOrganizationPathParams
  >({ url: '/user/organizations/{organizationId}', method: 'delete', ...variables, signal });

export type UserSOrganizationsOrganizationDetailsPathParams = {
  organizationId: Schemas.IamCommonComponentsSchemasIdentifier;
};

export type UserSOrganizationsOrganizationDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserSOrganizationsOrganizationDetailsVariables = {
  pathParams: UserSOrganizationsOrganizationDetailsPathParams;
} & FetcherExtraProps;

/**
 * Gets a specific organization the user is associated with.
 */
export const userSOrganizationsOrganizationDetails = (
  variables: UserSOrganizationsOrganizationDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.IamSingleOrganizationResponse,
    UserSOrganizationsOrganizationDetailsError,
    undefined,
    {},
    {},
    UserSOrganizationsOrganizationDetailsPathParams
  >({ url: '/user/organizations/{organizationId}', method: 'get', ...variables, signal });

export type UserSubscriptionGetUserSubscriptionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.BillSubsApiUserSubscriptionResponseCollection & Schemas.BillSubsApiApiResponseCommonFailure;
}>;

export type UserSubscriptionGetUserSubscriptionsVariables = FetcherExtraProps;

/**
 * Lists all of a user's subscriptions.
 */
export const userSubscriptionGetUserSubscriptions = (
  variables: UserSubscriptionGetUserSubscriptionsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.BillSubsApiUserSubscriptionResponseCollection,
    UserSubscriptionGetUserSubscriptionsError,
    undefined,
    {},
    {},
    {}
  >({ url: '/user/subscriptions', method: 'get', ...variables, signal });

export type UserSubscriptionDeleteUserSubscriptionPathParams = {
  identifier: Schemas.BillSubsApiSchemasIdentifier;
};

export type UserSubscriptionDeleteUserSubscriptionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    subscription_id?: Schemas.BillSubsApiSchemasIdentifier;
  } & Schemas.BillSubsApiApiResponseCommonFailure;
}>;

export type UserSubscriptionDeleteUserSubscriptionResponse = {
  subscription_id?: Schemas.BillSubsApiSchemasIdentifier;
};

export type UserSubscriptionDeleteUserSubscriptionVariables = {
  pathParams: UserSubscriptionDeleteUserSubscriptionPathParams;
} & FetcherExtraProps;

/**
 * Deletes a user's subscription.
 */
export const userSubscriptionDeleteUserSubscription = (
  variables: UserSubscriptionDeleteUserSubscriptionVariables,
  signal?: AbortSignal
) =>
  fetch<
    UserSubscriptionDeleteUserSubscriptionResponse,
    UserSubscriptionDeleteUserSubscriptionError,
    undefined,
    {},
    {},
    UserSubscriptionDeleteUserSubscriptionPathParams
  >({ url: '/user/subscriptions/{identifier}', method: 'delete', ...variables, signal });

export type UserSubscriptionUpdateUserSubscriptionPathParams = {
  identifier: Schemas.BillSubsApiSchemasIdentifier;
};

export type UserSubscriptionUpdateUserSubscriptionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.BillSubsApiUserSubscriptionResponseSingle & Schemas.BillSubsApiApiResponseCommonFailure;
}>;

export type UserSubscriptionUpdateUserSubscriptionVariables = {
  body?: Schemas.BillSubsApiSubscriptionV2;
  pathParams: UserSubscriptionUpdateUserSubscriptionPathParams;
} & FetcherExtraProps;

/**
 * Updates a user's subscriptions.
 */
export const userSubscriptionUpdateUserSubscription = (
  variables: UserSubscriptionUpdateUserSubscriptionVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.BillSubsApiUserSubscriptionResponseSingle,
    UserSubscriptionUpdateUserSubscriptionError,
    Schemas.BillSubsApiSubscriptionV2,
    {},
    {},
    UserSubscriptionUpdateUserSubscriptionPathParams
  >({ url: '/user/subscriptions/{identifier}', method: 'put', ...variables, signal });

export type UserApiTokensListTokensQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example desc
   */
  direction?: 'asc' | 'desc';
};

export type UserApiTokensListTokensError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserApiTokensListTokensVariables = {
  queryParams?: UserApiTokensListTokensQueryParams;
} & FetcherExtraProps;

/**
 * List all access tokens you created.
 */
export const userApiTokensListTokens = (variables: UserApiTokensListTokensVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamCollectionTokensResponse,
    UserApiTokensListTokensError,
    undefined,
    {},
    UserApiTokensListTokensQueryParams,
    {}
  >({ url: '/user/tokens', method: 'get', ...variables, signal });

export type UserApiTokensCreateTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserApiTokensCreateTokenVariables = {
  body: Schemas.IamCreatePayload;
} & FetcherExtraProps;

/**
 * Create a new access token.
 */
export const userApiTokensCreateToken = (variables: UserApiTokensCreateTokenVariables, signal?: AbortSignal) =>
  fetch<Schemas.IamSingleTokenCreateResponse, UserApiTokensCreateTokenError, Schemas.IamCreatePayload, {}, {}, {}>({
    url: '/user/tokens',
    method: 'post',
    ...variables,
    signal
  });

export type PermissionGroupsListPermissionGroupsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type PermissionGroupsListPermissionGroupsVariables = FetcherExtraProps;

/**
 * Find all available permission groups for API Tokens
 */
export const permissionGroupsListPermissionGroups = (
  variables: PermissionGroupsListPermissionGroupsVariables,
  signal?: AbortSignal
) =>
  fetch<Schemas.IamSchemasResponseCollection, PermissionGroupsListPermissionGroupsError, undefined, {}, {}, {}>({
    url: '/user/tokens/permission_groups',
    method: 'get',
    ...variables,
    signal
  });

export type UserApiTokensVerifyTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserApiTokensVerifyTokenVariables = FetcherExtraProps;

/**
 * Test whether a token works.
 */
export const userApiTokensVerifyToken = (variables: UserApiTokensVerifyTokenVariables, signal?: AbortSignal) =>
  fetch<Schemas.IamResponseSingleSegment, UserApiTokensVerifyTokenError, undefined, {}, {}, {}>({
    url: '/user/tokens/verify',
    method: 'get',
    ...variables,
    signal
  });

export type UserApiTokensDeleteTokenPathParams = {
  tokenId: Schemas.IamTokenIdentifier;
};

export type UserApiTokensDeleteTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserApiTokensDeleteTokenVariables = {
  pathParams: UserApiTokensDeleteTokenPathParams;
} & FetcherExtraProps;

/**
 * Destroy a token.
 */
export const userApiTokensDeleteToken = (variables: UserApiTokensDeleteTokenVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamApiResponseSingleId,
    UserApiTokensDeleteTokenError,
    undefined,
    {},
    {},
    UserApiTokensDeleteTokenPathParams
  >({ url: '/user/tokens/{tokenId}', method: 'delete', ...variables, signal });

export type UserApiTokensTokenDetailsPathParams = {
  tokenId: Schemas.IamTokenIdentifier;
};

export type UserApiTokensTokenDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserApiTokensTokenDetailsVariables = {
  pathParams: UserApiTokensTokenDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get information about a specific token.
 */
export const userApiTokensTokenDetails = (variables: UserApiTokensTokenDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamSingleTokenResponse,
    UserApiTokensTokenDetailsError,
    undefined,
    {},
    {},
    UserApiTokensTokenDetailsPathParams
  >({ url: '/user/tokens/{tokenId}', method: 'get', ...variables, signal });

export type UserApiTokensUpdateTokenPathParams = {
  tokenId: Schemas.IamTokenIdentifier;
};

export type UserApiTokensUpdateTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserApiTokensUpdateTokenVariables = {
  body?: Schemas.IamTokenBody;
  pathParams: UserApiTokensUpdateTokenPathParams;
} & FetcherExtraProps;

/**
 * Update an existing token.
 */
export const userApiTokensUpdateToken = (variables: UserApiTokensUpdateTokenVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamSingleTokenResponse,
    UserApiTokensUpdateTokenError,
    Schemas.IamTokenBody,
    {},
    {},
    UserApiTokensUpdateTokenPathParams
  >({ url: '/user/tokens/{tokenId}', method: 'put', ...variables, signal });

export type UserApiTokensRollTokenPathParams = {
  tokenId: Schemas.IamTokenIdentifier;
};

export type UserApiTokensRollTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.IamApiResponseCommonFailure;
}>;

export type UserApiTokensRollTokenVariables = {
  body?: Record<string, any>;
  pathParams: UserApiTokensRollTokenPathParams;
} & FetcherExtraProps;

/**
 * Roll the token secret.
 */
export const userApiTokensRollToken = (variables: UserApiTokensRollTokenVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.IamResponseSingleValue,
    UserApiTokensRollTokenError,
    Record<string, any>,
    {},
    {},
    UserApiTokensRollTokenPathParams
  >({ url: '/user/tokens/{tokenId}/value', method: 'put', ...variables, signal });

export type ZonesGetQueryParams = {
  /**
   * @maxLength 253
   */
  name?: string;
  status?: 'initializing' | 'pending' | 'active' | 'moved';
  ['account.id']?: string;
  /**
   * @maxLength 253
   */
  ['account.name']?: string;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example status
   */
  order?: 'name' | 'status' | 'account.id' | 'account.name';
  /**
   * @example desc
   */
  direction?: 'asc' | 'desc';
  /**
   * @default all
   */
  match?: 'any' | 'all';
};

export type ZonesGetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesApiResponseCommonFailure;
}>;

export type ZonesGetResponse = Schemas.ZonesApiResponseCommon & {
  result_info?: Schemas.ZonesResultInfo;
} & {
  result?: Schemas.ZonesZone[];
};

export type ZonesGetVariables = {
  queryParams?: ZonesGetQueryParams;
} & FetcherExtraProps;

/**
 * Lists, searches, sorts, and filters your zones. Listing zones across more than 500 accounts
 * is currently not allowed.
 */
export const zonesGet = (variables: ZonesGetVariables, signal?: AbortSignal) =>
  fetch<ZonesGetResponse, ZonesGetError, undefined, {}, ZonesGetQueryParams, {}>({
    url: '/zones',
    method: 'get',
    ...variables,
    signal
  });

export type ZonesPostError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesApiResponseCommonFailure;
}>;

export type ZonesPostResponse = Schemas.ZonesApiResponseCommon & {
  result?: Schemas.ZonesZone;
};

export type ZonesPostRequestBody = {
  account: {
    id?: Schemas.ZonesIdentifier;
  };
  name: Schemas.ZonesName;
  type?: Schemas.ZonesType;
};

export type ZonesPostVariables = {
  body: ZonesPostRequestBody;
} & FetcherExtraProps;

export const zonesPost = (variables: ZonesPostVariables, signal?: AbortSignal) =>
  fetch<ZonesPostResponse, ZonesPostError, ZonesPostRequestBody, {}, {}, {}>({
    url: '/zones',
    method: 'post',
    ...variables,
    signal
  });

export type ZoneSubscriptionZoneSubscriptionDetailsPathParams = {
  identifier: Schemas.BillSubsApiSchemasIdentifier;
};

export type ZoneSubscriptionZoneSubscriptionDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.BillSubsApiZoneSubscriptionResponseSingle & Schemas.BillSubsApiApiResponseCommonFailure;
}>;

export type ZoneSubscriptionZoneSubscriptionDetailsVariables = {
  pathParams: ZoneSubscriptionZoneSubscriptionDetailsPathParams;
} & FetcherExtraProps;

/**
 * Lists zone subscription details.
 */
export const zoneSubscriptionZoneSubscriptionDetails = (
  variables: ZoneSubscriptionZoneSubscriptionDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.BillSubsApiZoneSubscriptionResponseSingle,
    ZoneSubscriptionZoneSubscriptionDetailsError,
    undefined,
    {},
    {},
    ZoneSubscriptionZoneSubscriptionDetailsPathParams
  >({ url: '/zones/{identifier}/subscription', method: 'get', ...variables, signal });

export type ZoneSubscriptionCreateZoneSubscriptionPathParams = {
  identifier: Schemas.BillSubsApiSchemasIdentifier;
};

export type ZoneSubscriptionCreateZoneSubscriptionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.BillSubsApiZoneSubscriptionResponseSingle & Schemas.BillSubsApiApiResponseCommonFailure;
}>;

export type ZoneSubscriptionCreateZoneSubscriptionVariables = {
  body?: Schemas.BillSubsApiSubscriptionV2;
  pathParams: ZoneSubscriptionCreateZoneSubscriptionPathParams;
} & FetcherExtraProps;

/**
 * Create a zone subscription, either plan or add-ons.
 */
export const zoneSubscriptionCreateZoneSubscription = (
  variables: ZoneSubscriptionCreateZoneSubscriptionVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.BillSubsApiZoneSubscriptionResponseSingle,
    ZoneSubscriptionCreateZoneSubscriptionError,
    Schemas.BillSubsApiSubscriptionV2,
    {},
    {},
    ZoneSubscriptionCreateZoneSubscriptionPathParams
  >({ url: '/zones/{identifier}/subscription', method: 'post', ...variables, signal });

export type ZoneSubscriptionUpdateZoneSubscriptionPathParams = {
  identifier: Schemas.BillSubsApiSchemasIdentifier;
};

export type ZoneSubscriptionUpdateZoneSubscriptionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.BillSubsApiZoneSubscriptionResponseSingle & Schemas.BillSubsApiApiResponseCommonFailure;
}>;

export type ZoneSubscriptionUpdateZoneSubscriptionVariables = {
  body?: Schemas.BillSubsApiSubscriptionV2;
  pathParams: ZoneSubscriptionUpdateZoneSubscriptionPathParams;
} & FetcherExtraProps;

/**
 * Updates zone subscriptions, either plan or add-ons.
 */
export const zoneSubscriptionUpdateZoneSubscription = (
  variables: ZoneSubscriptionUpdateZoneSubscriptionVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.BillSubsApiZoneSubscriptionResponseSingle,
    ZoneSubscriptionUpdateZoneSubscriptionError,
    Schemas.BillSubsApiSubscriptionV2,
    {},
    {},
    ZoneSubscriptionUpdateZoneSubscriptionPathParams
  >({ url: '/zones/{identifier}/subscription', method: 'put', ...variables, signal });

export type ZoneAnalyticsDeprecatedGetAnalyticsByCoLocationsPathParams = {
  zoneIdentifier: Schemas.ZoneAnalyticsApiIdentifier;
};

export type ZoneAnalyticsDeprecatedGetAnalyticsByCoLocationsQueryParams = {
  until?: Schemas.ZoneAnalyticsApiUntil;
  /**
   * @default -10080
   * @example 2015-01-01T12:23:00Z
   */
  since?: string | number;
  /**
   * @default true
   */
  continuous?: boolean;
};

export type ZoneAnalyticsDeprecatedGetAnalyticsByCoLocationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZoneAnalyticsApiColoResponse & Schemas.ZoneAnalyticsApiApiResponseCommonFailure;
}>;

export type ZoneAnalyticsDeprecatedGetAnalyticsByCoLocationsVariables = {
  pathParams: ZoneAnalyticsDeprecatedGetAnalyticsByCoLocationsPathParams;
  queryParams?: ZoneAnalyticsDeprecatedGetAnalyticsByCoLocationsQueryParams;
} & FetcherExtraProps;

/**
 * This view provides a breakdown of analytics data by datacenter. Note: This is available to Enterprise customers only.
 */
export const zoneAnalyticsDeprecatedGetAnalyticsByCoLocations = (
  variables: ZoneAnalyticsDeprecatedGetAnalyticsByCoLocationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZoneAnalyticsApiColoResponse,
    ZoneAnalyticsDeprecatedGetAnalyticsByCoLocationsError,
    undefined,
    {},
    ZoneAnalyticsDeprecatedGetAnalyticsByCoLocationsQueryParams,
    ZoneAnalyticsDeprecatedGetAnalyticsByCoLocationsPathParams
  >({ url: '/zones/{zoneIdentifier}/analytics/colos', method: 'get', ...variables, signal });

export type ZoneAnalyticsDeprecatedGetDashboardPathParams = {
  zoneIdentifier: Schemas.ZoneAnalyticsApiIdentifier;
};

export type ZoneAnalyticsDeprecatedGetDashboardQueryParams = {
  until?: Schemas.ZoneAnalyticsApiUntil;
  /**
   * @default -10080
   * @example 2015-01-01T12:23:00Z
   */
  since?: string | number;
  /**
   * @default true
   */
  continuous?: boolean;
};

export type ZoneAnalyticsDeprecatedGetDashboardError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZoneAnalyticsApiDashboardResponse & Schemas.ZoneAnalyticsApiApiResponseCommonFailure;
}>;

export type ZoneAnalyticsDeprecatedGetDashboardVariables = {
  pathParams: ZoneAnalyticsDeprecatedGetDashboardPathParams;
  queryParams?: ZoneAnalyticsDeprecatedGetDashboardQueryParams;
} & FetcherExtraProps;

/**
 * The dashboard view provides both totals and timeseries data for the given zone and time period across the entire Cloudflare network.
 */
export const zoneAnalyticsDeprecatedGetDashboard = (
  variables: ZoneAnalyticsDeprecatedGetDashboardVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZoneAnalyticsApiDashboardResponse,
    ZoneAnalyticsDeprecatedGetDashboardError,
    undefined,
    {},
    ZoneAnalyticsDeprecatedGetDashboardQueryParams,
    ZoneAnalyticsDeprecatedGetDashboardPathParams
  >({ url: '/zones/{zoneIdentifier}/analytics/dashboard', method: 'get', ...variables, signal });

export type CustomPagesForAZoneListCustomPagesPathParams = {
  zoneIdentifier: Schemas.CustomPagesIdentifier;
};

export type CustomPagesForAZoneListCustomPagesError = Fetcher.ErrorWrapper<{
  status: ClientErrorStatus;
  payload: Schemas.CustomPagesCustomPagesResponseCollection & Schemas.CustomPagesApiResponseCommonFailure;
}>;

export type CustomPagesForAZoneListCustomPagesVariables = {
  pathParams: CustomPagesForAZoneListCustomPagesPathParams;
} & FetcherExtraProps;

/**
 * Fetches all the custom pages at the zone level.
 */
export const customPagesForAZoneListCustomPages = (
  variables: CustomPagesForAZoneListCustomPagesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CustomPagesCustomPagesResponseCollection,
    CustomPagesForAZoneListCustomPagesError,
    undefined,
    {},
    {},
    CustomPagesForAZoneListCustomPagesPathParams
  >({ url: '/zones/{zoneIdentifier}/custom_pages', method: 'get', ...variables, signal });

export type CustomPagesForAZoneGetACustomPagePathParams = {
  identifier: Schemas.CustomPagesIdentifier;
  zoneIdentifier: Schemas.CustomPagesIdentifier;
};

export type CustomPagesForAZoneGetACustomPageError = Fetcher.ErrorWrapper<{
  status: ClientErrorStatus;
  payload: Schemas.CustomPagesCustomPagesResponseSingle & Schemas.CustomPagesApiResponseCommonFailure;
}>;

export type CustomPagesForAZoneGetACustomPageVariables = {
  pathParams: CustomPagesForAZoneGetACustomPagePathParams;
} & FetcherExtraProps;

/**
 * Fetches the details of a custom page.
 */
export const customPagesForAZoneGetACustomPage = (
  variables: CustomPagesForAZoneGetACustomPageVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CustomPagesCustomPagesResponseSingle,
    CustomPagesForAZoneGetACustomPageError,
    undefined,
    {},
    {},
    CustomPagesForAZoneGetACustomPagePathParams
  >({ url: '/zones/{zoneIdentifier}/custom_pages/{identifier}', method: 'get', ...variables, signal });

export type CustomPagesForAZoneUpdateACustomPagePathParams = {
  identifier: Schemas.CustomPagesIdentifier;
  zoneIdentifier: Schemas.CustomPagesIdentifier;
};

export type CustomPagesForAZoneUpdateACustomPageError = Fetcher.ErrorWrapper<{
  status: ClientErrorStatus;
  payload: Schemas.CustomPagesCustomPagesResponseSingle & Schemas.CustomPagesApiResponseCommonFailure;
}>;

export type CustomPagesForAZoneUpdateACustomPageRequestBody = {
  state: Schemas.CustomPagesState;
  url: Schemas.CustomPagesUrl;
};

export type CustomPagesForAZoneUpdateACustomPageVariables = {
  body: CustomPagesForAZoneUpdateACustomPageRequestBody;
  pathParams: CustomPagesForAZoneUpdateACustomPagePathParams;
} & FetcherExtraProps;

/**
 * Updates the configuration of an existing custom page.
 */
export const customPagesForAZoneUpdateACustomPage = (
  variables: CustomPagesForAZoneUpdateACustomPageVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CustomPagesCustomPagesResponseSingle,
    CustomPagesForAZoneUpdateACustomPageError,
    CustomPagesForAZoneUpdateACustomPageRequestBody,
    {},
    {},
    CustomPagesForAZoneUpdateACustomPagePathParams
  >({ url: '/zones/{zoneIdentifier}/custom_pages/{identifier}', method: 'put', ...variables, signal });

export type SslTlsModeRecommendationSslTlsRecommendationPathParams = {
  zoneIdentifier: Schemas.LegacyJhsIdentifier;
};

export type SslTlsModeRecommendationSslTlsRecommendationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.LegacyJhsApiResponseSingle & {
    result?: {
      id?: Schemas.LegacyJhsId;
      modified_on?: Schemas.LegacyJhsTimestamp;
      value?: Schemas.LegacyJhsValue;
    };
  }) &
    Schemas.LegacyJhsApiResponseCommonFailure;
}>;

export type SslTlsModeRecommendationSslTlsRecommendationResponse = Schemas.LegacyJhsApiResponseSingle & {
  result?: {
    id?: Schemas.LegacyJhsId;
    modified_on?: Schemas.LegacyJhsTimestamp;
    value?: Schemas.LegacyJhsValue;
  };
};

export type SslTlsModeRecommendationSslTlsRecommendationVariables = {
  pathParams: SslTlsModeRecommendationSslTlsRecommendationPathParams;
} & FetcherExtraProps;

/**
 * Retrieve the SSL/TLS Recommender's recommendation for a zone.
 */
export const sslTlsModeRecommendationSslTlsRecommendation = (
  variables: SslTlsModeRecommendationSslTlsRecommendationVariables,
  signal?: AbortSignal
) =>
  fetch<
    SslTlsModeRecommendationSslTlsRecommendationResponse,
    SslTlsModeRecommendationSslTlsRecommendationError,
    undefined,
    {},
    {},
    SslTlsModeRecommendationSslTlsRecommendationPathParams
  >({ url: '/zones/{zoneIdentifier}/ssl/recommendation', method: 'get', ...variables, signal });

export type Zones0DeletePathParams = {
  zoneId: Schemas.ZonesIdentifier;
};

export type Zones0DeleteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesApiResponseCommonFailure;
}>;

export type Zones0DeleteVariables = {
  pathParams: Zones0DeletePathParams;
} & FetcherExtraProps;

/**
 * Deletes an existing zone.
 */
export const zones0Delete = (variables: Zones0DeleteVariables, signal?: AbortSignal) =>
  fetch<Schemas.ZonesApiResponseSingleId, Zones0DeleteError, undefined, {}, {}, Zones0DeletePathParams>({
    url: '/zones/{zoneId}',
    method: 'delete',
    ...variables,
    signal
  });

export type Zones0GetPathParams = {
  zoneId: Schemas.ZonesIdentifier;
};

export type Zones0GetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesApiResponseCommonFailure;
}>;

export type Zones0GetResponse = Schemas.ZonesApiResponseCommon & {
  result?: Schemas.ZonesZone;
};

export type Zones0GetVariables = {
  pathParams: Zones0GetPathParams;
} & FetcherExtraProps;

export const zones0Get = (variables: Zones0GetVariables, signal?: AbortSignal) =>
  fetch<Zones0GetResponse, Zones0GetError, undefined, {}, {}, Zones0GetPathParams>({
    url: '/zones/{zoneId}',
    method: 'get',
    ...variables,
    signal
  });

export type Zones0PatchPathParams = {
  zoneId: Schemas.ZonesIdentifier;
};

export type Zones0PatchError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesApiResponseCommonFailure;
}>;

export type Zones0PatchResponse = Schemas.ZonesApiResponseCommon & {
  result?: Schemas.ZonesZone;
};

export type Zones0PatchRequestBody = {
  paused?: Schemas.ZonesPaused;
  /**
   * (Deprecated) Please use the `/zones/{zone_id}/subscription` API
   * to update a zone's plan. Changing this value will create/cancel
   * associated subscriptions. To view available plans for this zone,
   * see Zone Plans.
   */
  plan?: {
    id?: Schemas.ZonesIdentifier;
  };
  /**
   * A full zone implies that DNS is hosted with Cloudflare. A partial
   * zone is typically a partner-hosted zone or a CNAME setup. This
   * parameter is only available to Enterprise customers or if it has
   * been explicitly enabled on a zone.
   *
   * @example full
   */
  type?: 'full' | 'partial' | 'secondary';
  vanity_name_servers?: Schemas.ZonesVanityNameServers;
};

export type Zones0PatchVariables = {
  body?: Zones0PatchRequestBody;
  pathParams: Zones0PatchPathParams;
} & FetcherExtraProps;

/**
 * Edits a zone. Only one zone property can be changed at a time.
 */
export const zones0Patch = (variables: Zones0PatchVariables, signal?: AbortSignal) =>
  fetch<Zones0PatchResponse, Zones0PatchError, Zones0PatchRequestBody, {}, {}, Zones0PatchPathParams>({
    url: '/zones/{zoneId}',
    method: 'patch',
    ...variables,
    signal
  });

export type ZoneLevelAccessApplicationsListAccessApplicationsPathParams = {
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessApplicationsListAccessApplicationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessApplicationsListAccessApplicationsVariables = {
  pathParams: ZoneLevelAccessApplicationsListAccessApplicationsPathParams;
} & FetcherExtraProps;

/**
 * List all Access Applications in a zone.
 */
export const zoneLevelAccessApplicationsListAccessApplications = (
  variables: ZoneLevelAccessApplicationsListAccessApplicationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessAppsComponentsSchemasResponseCollection2,
    ZoneLevelAccessApplicationsListAccessApplicationsError,
    undefined,
    {},
    {},
    ZoneLevelAccessApplicationsListAccessApplicationsPathParams
  >({ url: '/zones/{zoneId}/access/apps', method: 'get', ...variables, signal });

export type ZoneLevelAccessApplicationsAddABookmarkApplicationPathParams = {
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessApplicationsAddABookmarkApplicationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessApplicationsAddABookmarkApplicationResponse =
  Schemas.AccessAppsComponentsSchemasSingleResponse2 & {
    result?: Schemas.AccessApps;
  };

export type ZoneLevelAccessApplicationsAddABookmarkApplicationVariables = {
  body?: Schemas.AccessApps;
  pathParams: ZoneLevelAccessApplicationsAddABookmarkApplicationPathParams;
} & FetcherExtraProps;

/**
 * Adds a new application to Access.
 */
export const zoneLevelAccessApplicationsAddABookmarkApplication = (
  variables: ZoneLevelAccessApplicationsAddABookmarkApplicationVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneLevelAccessApplicationsAddABookmarkApplicationResponse,
    ZoneLevelAccessApplicationsAddABookmarkApplicationError,
    Schemas.AccessApps,
    {},
    {},
    ZoneLevelAccessApplicationsAddABookmarkApplicationPathParams
  >({ url: '/zones/{zoneId}/access/apps', method: 'post', ...variables, signal });

export type ZoneLevelAccessShortLivedCertificateCAsListShortLivedCertificateCAsPathParams = {
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessShortLivedCertificateCAsListShortLivedCertificateCAsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessShortLivedCertificateCAsListShortLivedCertificateCAsVariables = {
  pathParams: ZoneLevelAccessShortLivedCertificateCAsListShortLivedCertificateCAsPathParams;
} & FetcherExtraProps;

/**
 * Lists short-lived certificate CAs and their public keys.
 */
export const zoneLevelAccessShortLivedCertificateCAsListShortLivedCertificateCAs = (
  variables: ZoneLevelAccessShortLivedCertificateCAsListShortLivedCertificateCAsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCaComponentsSchemasResponseCollection,
    ZoneLevelAccessShortLivedCertificateCAsListShortLivedCertificateCAsError,
    undefined,
    {},
    {},
    ZoneLevelAccessShortLivedCertificateCAsListShortLivedCertificateCAsPathParams
  >({ url: '/zones/{zoneId}/access/apps/ca', method: 'get', ...variables, signal });

export type ZoneLevelAccessApplicationsDeleteAnAccessApplicationPathParams = {
  appId: Schemas.AccessAppId;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessApplicationsDeleteAnAccessApplicationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessApplicationsDeleteAnAccessApplicationVariables = {
  pathParams: ZoneLevelAccessApplicationsDeleteAnAccessApplicationPathParams;
} & FetcherExtraProps;

/**
 * Deletes an application from Access.
 */
export const zoneLevelAccessApplicationsDeleteAnAccessApplication = (
  variables: ZoneLevelAccessApplicationsDeleteAnAccessApplicationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessIdResponse,
    ZoneLevelAccessApplicationsDeleteAnAccessApplicationError,
    undefined,
    {},
    {},
    ZoneLevelAccessApplicationsDeleteAnAccessApplicationPathParams
  >({ url: '/zones/{zoneId}/access/apps/{appId}', method: 'delete', ...variables, signal });

export type ZoneLevelAccessApplicationsGetAnAccessApplicationPathParams = {
  appId: Schemas.AccessAppId;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessApplicationsGetAnAccessApplicationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessApplicationsGetAnAccessApplicationVariables = {
  pathParams: ZoneLevelAccessApplicationsGetAnAccessApplicationPathParams;
} & FetcherExtraProps;

/**
 * Fetches information about an Access application.
 */
export const zoneLevelAccessApplicationsGetAnAccessApplication = (
  variables: ZoneLevelAccessApplicationsGetAnAccessApplicationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessAppsComponentsSchemasSingleResponse2,
    ZoneLevelAccessApplicationsGetAnAccessApplicationError,
    undefined,
    {},
    {},
    ZoneLevelAccessApplicationsGetAnAccessApplicationPathParams
  >({ url: '/zones/{zoneId}/access/apps/{appId}', method: 'get', ...variables, signal });

export type ZoneLevelAccessApplicationsUpdateABookmarkApplicationPathParams = {
  appId: Schemas.AccessAppId;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessApplicationsUpdateABookmarkApplicationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessApplicationsUpdateABookmarkApplicationResponse =
  Schemas.AccessAppsComponentsSchemasSingleResponse2 & {
    result?: Schemas.AccessApps;
  };

export type ZoneLevelAccessApplicationsUpdateABookmarkApplicationVariables = {
  body?: Schemas.AccessApps;
  pathParams: ZoneLevelAccessApplicationsUpdateABookmarkApplicationPathParams;
} & FetcherExtraProps;

/**
 * Updates an Access application.
 */
export const zoneLevelAccessApplicationsUpdateABookmarkApplication = (
  variables: ZoneLevelAccessApplicationsUpdateABookmarkApplicationVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneLevelAccessApplicationsUpdateABookmarkApplicationResponse,
    ZoneLevelAccessApplicationsUpdateABookmarkApplicationError,
    Schemas.AccessApps,
    {},
    {},
    ZoneLevelAccessApplicationsUpdateABookmarkApplicationPathParams
  >({ url: '/zones/{zoneId}/access/apps/{appId}', method: 'put', ...variables, signal });

export type ZoneLevelAccessShortLivedCertificateCAsDeleteAShortLivedCertificateCaPathParams = {
  appId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessShortLivedCertificateCAsDeleteAShortLivedCertificateCaError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessShortLivedCertificateCAsDeleteAShortLivedCertificateCaVariables = {
  pathParams: ZoneLevelAccessShortLivedCertificateCAsDeleteAShortLivedCertificateCaPathParams;
} & FetcherExtraProps;

/**
 * Deletes a short-lived certificate CA.
 */
export const zoneLevelAccessShortLivedCertificateCAsDeleteAShortLivedCertificateCa = (
  variables: ZoneLevelAccessShortLivedCertificateCAsDeleteAShortLivedCertificateCaVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessSchemasIdResponse,
    ZoneLevelAccessShortLivedCertificateCAsDeleteAShortLivedCertificateCaError,
    undefined,
    {},
    {},
    ZoneLevelAccessShortLivedCertificateCAsDeleteAShortLivedCertificateCaPathParams
  >({ url: '/zones/{zoneId}/access/apps/{appId}/ca', method: 'delete', ...variables, signal });

export type ZoneLevelAccessShortLivedCertificateCAsGetAShortLivedCertificateCaPathParams = {
  appId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessShortLivedCertificateCAsGetAShortLivedCertificateCaError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessShortLivedCertificateCAsGetAShortLivedCertificateCaVariables = {
  pathParams: ZoneLevelAccessShortLivedCertificateCAsGetAShortLivedCertificateCaPathParams;
} & FetcherExtraProps;

/**
 * Fetches a short-lived certificate CA and its public key.
 */
export const zoneLevelAccessShortLivedCertificateCAsGetAShortLivedCertificateCa = (
  variables: ZoneLevelAccessShortLivedCertificateCAsGetAShortLivedCertificateCaVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCaComponentsSchemasSingleResponse,
    ZoneLevelAccessShortLivedCertificateCAsGetAShortLivedCertificateCaError,
    undefined,
    {},
    {},
    ZoneLevelAccessShortLivedCertificateCAsGetAShortLivedCertificateCaPathParams
  >({ url: '/zones/{zoneId}/access/apps/{appId}/ca', method: 'get', ...variables, signal });

export type ZoneLevelAccessShortLivedCertificateCAsCreateAShortLivedCertificateCaPathParams = {
  appId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessShortLivedCertificateCAsCreateAShortLivedCertificateCaError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessShortLivedCertificateCAsCreateAShortLivedCertificateCaVariables = {
  pathParams: ZoneLevelAccessShortLivedCertificateCAsCreateAShortLivedCertificateCaPathParams;
} & FetcherExtraProps;

/**
 * Generates a new short-lived certificate CA and public key.
 */
export const zoneLevelAccessShortLivedCertificateCAsCreateAShortLivedCertificateCa = (
  variables: ZoneLevelAccessShortLivedCertificateCAsCreateAShortLivedCertificateCaVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCaComponentsSchemasSingleResponse,
    ZoneLevelAccessShortLivedCertificateCAsCreateAShortLivedCertificateCaError,
    undefined,
    {},
    {},
    ZoneLevelAccessShortLivedCertificateCAsCreateAShortLivedCertificateCaPathParams
  >({ url: '/zones/{zoneId}/access/apps/{appId}/ca', method: 'post', ...variables, signal });

export type ZoneLevelAccessPoliciesListAccessPoliciesPathParams = {
  appId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessPoliciesListAccessPoliciesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessPoliciesListAccessPoliciesVariables = {
  pathParams: ZoneLevelAccessPoliciesListAccessPoliciesPathParams;
} & FetcherExtraProps;

/**
 * Lists Access policies configured for an application.
 */
export const zoneLevelAccessPoliciesListAccessPolicies = (
  variables: ZoneLevelAccessPoliciesListAccessPoliciesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessPoliciesComponentsSchemasResponseCollection,
    ZoneLevelAccessPoliciesListAccessPoliciesError,
    undefined,
    {},
    {},
    ZoneLevelAccessPoliciesListAccessPoliciesPathParams
  >({ url: '/zones/{zoneId}/access/apps/{appId}/policies', method: 'get', ...variables, signal });

export type ZoneLevelAccessPoliciesCreateAnAccessPolicyPathParams = {
  appId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessPoliciesCreateAnAccessPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessPoliciesCreateAnAccessPolicyRequestBody = {
  approval_groups?: Schemas.AccessSchemasApprovalGroups;
  approval_required?: Schemas.AccessApprovalRequired;
  decision: Schemas.AccessSchemasDecision;
  exclude?: Schemas.AccessSchemasExclude;
  include: Schemas.AccessInclude;
  isolation_required?: Schemas.AccessSchemasIsolationRequired;
  name: Schemas.AccessPoliciesComponentsSchemasName;
  precedence?: Schemas.AccessSchemasPrecedence;
  purpose_justification_prompt?: Schemas.AccessPurposeJustificationPrompt;
  purpose_justification_required?: Schemas.AccessPurposeJustificationRequired;
  require?: Schemas.AccessSchemasRequire;
};

export type ZoneLevelAccessPoliciesCreateAnAccessPolicyVariables = {
  body: ZoneLevelAccessPoliciesCreateAnAccessPolicyRequestBody;
  pathParams: ZoneLevelAccessPoliciesCreateAnAccessPolicyPathParams;
} & FetcherExtraProps;

/**
 * Create a new Access policy for an application.
 */
export const zoneLevelAccessPoliciesCreateAnAccessPolicy = (
  variables: ZoneLevelAccessPoliciesCreateAnAccessPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessPoliciesComponentsSchemasSingleResponse,
    ZoneLevelAccessPoliciesCreateAnAccessPolicyError,
    ZoneLevelAccessPoliciesCreateAnAccessPolicyRequestBody,
    {},
    {},
    ZoneLevelAccessPoliciesCreateAnAccessPolicyPathParams
  >({ url: '/zones/{zoneId}/access/apps/{appId}/policies', method: 'post', ...variables, signal });

export type ZoneLevelAccessPoliciesDeleteAnAccessPolicyPathParams = {
  policyId: Schemas.AccessUuid;
  appId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessPoliciesDeleteAnAccessPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessPoliciesDeleteAnAccessPolicyVariables = {
  pathParams: ZoneLevelAccessPoliciesDeleteAnAccessPolicyPathParams;
} & FetcherExtraProps;

/**
 * Delete an Access policy.
 */
export const zoneLevelAccessPoliciesDeleteAnAccessPolicy = (
  variables: ZoneLevelAccessPoliciesDeleteAnAccessPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessIdResponse,
    ZoneLevelAccessPoliciesDeleteAnAccessPolicyError,
    undefined,
    {},
    {},
    ZoneLevelAccessPoliciesDeleteAnAccessPolicyPathParams
  >({ url: '/zones/{zoneId}/access/apps/{appId}/policies/{policyId}', method: 'delete', ...variables, signal });

export type ZoneLevelAccessPoliciesGetAnAccessPolicyPathParams = {
  policyId: Schemas.AccessUuid;
  appId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessPoliciesGetAnAccessPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessPoliciesGetAnAccessPolicyVariables = {
  pathParams: ZoneLevelAccessPoliciesGetAnAccessPolicyPathParams;
} & FetcherExtraProps;

/**
 * Fetches a single Access policy.
 */
export const zoneLevelAccessPoliciesGetAnAccessPolicy = (
  variables: ZoneLevelAccessPoliciesGetAnAccessPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessPoliciesComponentsSchemasSingleResponse,
    ZoneLevelAccessPoliciesGetAnAccessPolicyError,
    undefined,
    {},
    {},
    ZoneLevelAccessPoliciesGetAnAccessPolicyPathParams
  >({ url: '/zones/{zoneId}/access/apps/{appId}/policies/{policyId}', method: 'get', ...variables, signal });

export type ZoneLevelAccessPoliciesUpdateAnAccessPolicyPathParams = {
  policyId: Schemas.AccessUuid;
  appId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessPoliciesUpdateAnAccessPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessPoliciesUpdateAnAccessPolicyRequestBody = {
  approval_groups?: Schemas.AccessSchemasApprovalGroups;
  approval_required?: Schemas.AccessApprovalRequired;
  decision: Schemas.AccessSchemasDecision;
  exclude?: Schemas.AccessSchemasExclude;
  include: Schemas.AccessInclude;
  isolation_required?: Schemas.AccessSchemasIsolationRequired;
  name: Schemas.AccessPoliciesComponentsSchemasName;
  precedence?: Schemas.AccessSchemasPrecedence;
  purpose_justification_prompt?: Schemas.AccessPurposeJustificationPrompt;
  purpose_justification_required?: Schemas.AccessPurposeJustificationRequired;
  require?: Schemas.AccessSchemasRequire;
};

export type ZoneLevelAccessPoliciesUpdateAnAccessPolicyVariables = {
  body: ZoneLevelAccessPoliciesUpdateAnAccessPolicyRequestBody;
  pathParams: ZoneLevelAccessPoliciesUpdateAnAccessPolicyPathParams;
} & FetcherExtraProps;

/**
 * Update a configured Access policy.
 */
export const zoneLevelAccessPoliciesUpdateAnAccessPolicy = (
  variables: ZoneLevelAccessPoliciesUpdateAnAccessPolicyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessPoliciesComponentsSchemasSingleResponse,
    ZoneLevelAccessPoliciesUpdateAnAccessPolicyError,
    ZoneLevelAccessPoliciesUpdateAnAccessPolicyRequestBody,
    {},
    {},
    ZoneLevelAccessPoliciesUpdateAnAccessPolicyPathParams
  >({ url: '/zones/{zoneId}/access/apps/{appId}/policies/{policyId}', method: 'put', ...variables, signal });

export type ZoneLevelAccessApplicationsRevokeServiceTokensPathParams = {
  appId: Schemas.AccessAppId;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessApplicationsRevokeServiceTokensError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessApplicationsRevokeServiceTokensVariables = {
  pathParams: ZoneLevelAccessApplicationsRevokeServiceTokensPathParams;
} & FetcherExtraProps;

/**
 * Revokes all tokens issued for an application.
 */
export const zoneLevelAccessApplicationsRevokeServiceTokens = (
  variables: ZoneLevelAccessApplicationsRevokeServiceTokensVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessSchemasEmptyResponse,
    ZoneLevelAccessApplicationsRevokeServiceTokensError,
    undefined,
    {},
    {},
    ZoneLevelAccessApplicationsRevokeServiceTokensPathParams
  >({ url: '/zones/{zoneId}/access/apps/{appId}/revoke_tokens', method: 'post', ...variables, signal });

export type ZoneLevelAccessApplicationsTestAccessPoliciesPathParams = {
  appId: Schemas.AccessAppId;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessApplicationsTestAccessPoliciesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessApplicationsTestAccessPoliciesVariables = {
  pathParams: ZoneLevelAccessApplicationsTestAccessPoliciesPathParams;
} & FetcherExtraProps;

/**
 * Tests if a specific user has permission to access an application.
 */
export const zoneLevelAccessApplicationsTestAccessPolicies = (
  variables: ZoneLevelAccessApplicationsTestAccessPoliciesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessSchemasPolicyCheckResponse,
    ZoneLevelAccessApplicationsTestAccessPoliciesError,
    undefined,
    {},
    {},
    ZoneLevelAccessApplicationsTestAccessPoliciesPathParams
  >({ url: '/zones/{zoneId}/access/apps/{appId}/user_policy_checks', method: 'get', ...variables, signal });

export type ZoneLevelAccessMtlsAuthenticationListMtlsCertificatesPathParams = {
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessMtlsAuthenticationListMtlsCertificatesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessMtlsAuthenticationListMtlsCertificatesVariables = {
  pathParams: ZoneLevelAccessMtlsAuthenticationListMtlsCertificatesPathParams;
} & FetcherExtraProps;

/**
 * Lists all mTLS certificates.
 */
export const zoneLevelAccessMtlsAuthenticationListMtlsCertificates = (
  variables: ZoneLevelAccessMtlsAuthenticationListMtlsCertificatesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCertificatesComponentsSchemasResponseCollection2,
    ZoneLevelAccessMtlsAuthenticationListMtlsCertificatesError,
    undefined,
    {},
    {},
    ZoneLevelAccessMtlsAuthenticationListMtlsCertificatesPathParams
  >({ url: '/zones/{zoneId}/access/certificates', method: 'get', ...variables, signal });

export type ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificatePathParams = {
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateRequestBody = {
  associated_hostnames?: Schemas.AccessAssociatedHostnames;
  /**
     * The certificate content.
     *
     * @example -----BEGIN CERTIFICATE-----
    MIIGAjCCA+qgAwIBAgIJAI7kymlF7CWT...N4RI7KKB7nikiuUf8vhULKy5IX10
    DrUtmu/B
    -----END CERTIFICATE-----
     */
  certificate: string;
  name: Schemas.AccessCertificatesComponentsSchemasName;
};

export type ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateVariables = {
  body: ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateRequestBody;
  pathParams: ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificatePathParams;
} & FetcherExtraProps;

/**
 * Adds a new mTLS root certificate to Access.
 */
export const zoneLevelAccessMtlsAuthenticationAddAnMtlsCertificate = (
  variables: ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCertificatesComponentsSchemasSingleResponse2,
    ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateError,
    ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificateRequestBody,
    {},
    {},
    ZoneLevelAccessMtlsAuthenticationAddAnMtlsCertificatePathParams
  >({ url: '/zones/{zoneId}/access/certificates', method: 'post', ...variables, signal });

export type ZoneLevelAccessMtlsAuthenticationListMtlsCertificatesHostnameSettingsPathParams = {
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessMtlsAuthenticationListMtlsCertificatesHostnameSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessMtlsAuthenticationListMtlsCertificatesHostnameSettingsVariables = {
  pathParams: ZoneLevelAccessMtlsAuthenticationListMtlsCertificatesHostnameSettingsPathParams;
} & FetcherExtraProps;

/**
 * List all mTLS hostname settings for this zone.
 */
export const zoneLevelAccessMtlsAuthenticationListMtlsCertificatesHostnameSettings = (
  variables: ZoneLevelAccessMtlsAuthenticationListMtlsCertificatesHostnameSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessResponseCollectionHostnames,
    ZoneLevelAccessMtlsAuthenticationListMtlsCertificatesHostnameSettingsError,
    undefined,
    {},
    {},
    ZoneLevelAccessMtlsAuthenticationListMtlsCertificatesHostnameSettingsPathParams
  >({ url: '/zones/{zoneId}/access/certificates/settings', method: 'get', ...variables, signal });

export type ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsPathParams = {
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsRequestBody = {
  settings: Schemas.AccessSettings[];
};

export type ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsVariables = {
  body: ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsRequestBody;
  pathParams: ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsPathParams;
} & FetcherExtraProps;

/**
 * Updates an mTLS certificate's hostname settings.
 */
export const zoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateSettings = (
  variables: ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessResponseCollectionHostnames,
    ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsError,
    ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsRequestBody,
    {},
    {},
    ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateSettingsPathParams
  >({ url: '/zones/{zoneId}/access/certificates/settings', method: 'put', ...variables, signal });

export type ZoneLevelAccessMtlsAuthenticationDeleteAnMtlsCertificatePathParams = {
  certificateId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessMtlsAuthenticationDeleteAnMtlsCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessMtlsAuthenticationDeleteAnMtlsCertificateVariables = {
  pathParams: ZoneLevelAccessMtlsAuthenticationDeleteAnMtlsCertificatePathParams;
} & FetcherExtraProps;

/**
 * Deletes an mTLS certificate.
 */
export const zoneLevelAccessMtlsAuthenticationDeleteAnMtlsCertificate = (
  variables: ZoneLevelAccessMtlsAuthenticationDeleteAnMtlsCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessComponentsSchemasIdResponse,
    ZoneLevelAccessMtlsAuthenticationDeleteAnMtlsCertificateError,
    undefined,
    {},
    {},
    ZoneLevelAccessMtlsAuthenticationDeleteAnMtlsCertificatePathParams
  >({ url: '/zones/{zoneId}/access/certificates/{certificateId}', method: 'delete', ...variables, signal });

export type ZoneLevelAccessMtlsAuthenticationGetAnMtlsCertificatePathParams = {
  certificateId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessMtlsAuthenticationGetAnMtlsCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessMtlsAuthenticationGetAnMtlsCertificateVariables = {
  pathParams: ZoneLevelAccessMtlsAuthenticationGetAnMtlsCertificatePathParams;
} & FetcherExtraProps;

/**
 * Fetches a single mTLS certificate.
 */
export const zoneLevelAccessMtlsAuthenticationGetAnMtlsCertificate = (
  variables: ZoneLevelAccessMtlsAuthenticationGetAnMtlsCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCertificatesComponentsSchemasSingleResponse2,
    ZoneLevelAccessMtlsAuthenticationGetAnMtlsCertificateError,
    undefined,
    {},
    {},
    ZoneLevelAccessMtlsAuthenticationGetAnMtlsCertificatePathParams
  >({ url: '/zones/{zoneId}/access/certificates/{certificateId}', method: 'get', ...variables, signal });

export type ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificatePathParams = {
  certificateId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateRequestBody = {
  associated_hostnames: Schemas.AccessAssociatedHostnames;
  name?: Schemas.AccessCertificatesComponentsSchemasName;
};

export type ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateVariables = {
  body: ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateRequestBody;
  pathParams: ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificatePathParams;
} & FetcherExtraProps;

/**
 * Updates a configured mTLS certificate.
 */
export const zoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificate = (
  variables: ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCertificatesComponentsSchemasSingleResponse2,
    ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateError,
    ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateRequestBody,
    {},
    {},
    ZoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificatePathParams
  >({ url: '/zones/{zoneId}/access/certificates/{certificateId}', method: 'put', ...variables, signal });

export type ZoneLevelAccessGroupsListAccessGroupsPathParams = {
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessGroupsListAccessGroupsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessGroupsListAccessGroupsVariables = {
  pathParams: ZoneLevelAccessGroupsListAccessGroupsPathParams;
} & FetcherExtraProps;

/**
 * Lists all Access groups.
 */
export const zoneLevelAccessGroupsListAccessGroups = (
  variables: ZoneLevelAccessGroupsListAccessGroupsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessGroupsComponentsSchemasResponseCollection,
    ZoneLevelAccessGroupsListAccessGroupsError,
    undefined,
    {},
    {},
    ZoneLevelAccessGroupsListAccessGroupsPathParams
  >({ url: '/zones/{zoneId}/access/groups', method: 'get', ...variables, signal });

export type ZoneLevelAccessGroupsCreateAnAccessGroupPathParams = {
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessGroupsCreateAnAccessGroupError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessGroupsCreateAnAccessGroupRequestBody = {
  exclude?: Schemas.AccessExclude;
  include: Schemas.AccessInclude;
  name: Schemas.AccessGroupsComponentsSchemasName;
  require?: Schemas.AccessRequire;
};

export type ZoneLevelAccessGroupsCreateAnAccessGroupVariables = {
  body: ZoneLevelAccessGroupsCreateAnAccessGroupRequestBody;
  pathParams: ZoneLevelAccessGroupsCreateAnAccessGroupPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Access group.
 */
export const zoneLevelAccessGroupsCreateAnAccessGroup = (
  variables: ZoneLevelAccessGroupsCreateAnAccessGroupVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessGroupsComponentsSchemasSingleResponse2,
    ZoneLevelAccessGroupsCreateAnAccessGroupError,
    ZoneLevelAccessGroupsCreateAnAccessGroupRequestBody,
    {},
    {},
    ZoneLevelAccessGroupsCreateAnAccessGroupPathParams
  >({ url: '/zones/{zoneId}/access/groups', method: 'post', ...variables, signal });

export type ZoneLevelAccessGroupsDeleteAnAccessGroupPathParams = {
  groupId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessGroupsDeleteAnAccessGroupError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessGroupsDeleteAnAccessGroupVariables = {
  pathParams: ZoneLevelAccessGroupsDeleteAnAccessGroupPathParams;
} & FetcherExtraProps;

/**
 * Deletes an Access group.
 */
export const zoneLevelAccessGroupsDeleteAnAccessGroup = (
  variables: ZoneLevelAccessGroupsDeleteAnAccessGroupVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessIdResponse,
    ZoneLevelAccessGroupsDeleteAnAccessGroupError,
    undefined,
    {},
    {},
    ZoneLevelAccessGroupsDeleteAnAccessGroupPathParams
  >({ url: '/zones/{zoneId}/access/groups/{groupId}', method: 'delete', ...variables, signal });

export type ZoneLevelAccessGroupsGetAnAccessGroupPathParams = {
  groupId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessGroupsGetAnAccessGroupError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessGroupsGetAnAccessGroupVariables = {
  pathParams: ZoneLevelAccessGroupsGetAnAccessGroupPathParams;
} & FetcherExtraProps;

/**
 * Fetches a single Access group.
 */
export const zoneLevelAccessGroupsGetAnAccessGroup = (
  variables: ZoneLevelAccessGroupsGetAnAccessGroupVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessGroupsComponentsSchemasSingleResponse2,
    ZoneLevelAccessGroupsGetAnAccessGroupError,
    undefined,
    {},
    {},
    ZoneLevelAccessGroupsGetAnAccessGroupPathParams
  >({ url: '/zones/{zoneId}/access/groups/{groupId}', method: 'get', ...variables, signal });

export type ZoneLevelAccessGroupsUpdateAnAccessGroupPathParams = {
  groupId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessGroupsUpdateAnAccessGroupError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessGroupsUpdateAnAccessGroupRequestBody = {
  exclude?: Schemas.AccessExclude;
  include: Schemas.AccessInclude;
  name: Schemas.AccessGroupsComponentsSchemasName;
  require?: Schemas.AccessRequire;
};

export type ZoneLevelAccessGroupsUpdateAnAccessGroupVariables = {
  body: ZoneLevelAccessGroupsUpdateAnAccessGroupRequestBody;
  pathParams: ZoneLevelAccessGroupsUpdateAnAccessGroupPathParams;
} & FetcherExtraProps;

/**
 * Updates a configured Access group.
 */
export const zoneLevelAccessGroupsUpdateAnAccessGroup = (
  variables: ZoneLevelAccessGroupsUpdateAnAccessGroupVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessGroupsComponentsSchemasSingleResponse2,
    ZoneLevelAccessGroupsUpdateAnAccessGroupError,
    ZoneLevelAccessGroupsUpdateAnAccessGroupRequestBody,
    {},
    {},
    ZoneLevelAccessGroupsUpdateAnAccessGroupPathParams
  >({ url: '/zones/{zoneId}/access/groups/{groupId}', method: 'put', ...variables, signal });

export type ZoneLevelAccessIdentityProvidersListAccessIdentityProvidersPathParams = {
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessIdentityProvidersListAccessIdentityProvidersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessIdentityProvidersListAccessIdentityProvidersVariables = {
  pathParams: ZoneLevelAccessIdentityProvidersListAccessIdentityProvidersPathParams;
} & FetcherExtraProps;

/**
 * Lists all configured identity providers.
 */
export const zoneLevelAccessIdentityProvidersListAccessIdentityProviders = (
  variables: ZoneLevelAccessIdentityProvidersListAccessIdentityProvidersVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessIdentityProvidersComponentsSchemasResponseCollection,
    ZoneLevelAccessIdentityProvidersListAccessIdentityProvidersError,
    undefined,
    {},
    {},
    ZoneLevelAccessIdentityProvidersListAccessIdentityProvidersPathParams
  >({ url: '/zones/{zoneId}/access/identity_providers', method: 'get', ...variables, signal });

export type ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderPathParams = {
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderVariables = {
  body?: Schemas.AccessSchemasIdentityProviders;
  pathParams: ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderPathParams;
} & FetcherExtraProps;

/**
 * Adds a new identity provider to Access.
 */
export const zoneLevelAccessIdentityProvidersAddAnAccessIdentityProvider = (
  variables: ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessIdentityProvidersComponentsSchemasSingleResponse,
    ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderError,
    Schemas.AccessSchemasIdentityProviders,
    {},
    {},
    ZoneLevelAccessIdentityProvidersAddAnAccessIdentityProviderPathParams
  >({ url: '/zones/{zoneId}/access/identity_providers', method: 'post', ...variables, signal });

export type ZoneLevelAccessIdentityProvidersDeleteAnAccessIdentityProviderPathParams = {
  identityProviderId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessIdentityProvidersDeleteAnAccessIdentityProviderError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessIdentityProvidersDeleteAnAccessIdentityProviderVariables = {
  pathParams: ZoneLevelAccessIdentityProvidersDeleteAnAccessIdentityProviderPathParams;
} & FetcherExtraProps;

/**
 * Deletes an identity provider from Access.
 */
export const zoneLevelAccessIdentityProvidersDeleteAnAccessIdentityProvider = (
  variables: ZoneLevelAccessIdentityProvidersDeleteAnAccessIdentityProviderVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessIdResponse,
    ZoneLevelAccessIdentityProvidersDeleteAnAccessIdentityProviderError,
    undefined,
    {},
    {},
    ZoneLevelAccessIdentityProvidersDeleteAnAccessIdentityProviderPathParams
  >({ url: '/zones/{zoneId}/access/identity_providers/{identityProviderId}', method: 'delete', ...variables, signal });

export type ZoneLevelAccessIdentityProvidersGetAnAccessIdentityProviderPathParams = {
  identityProviderId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessIdentityProvidersGetAnAccessIdentityProviderError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessIdentityProvidersGetAnAccessIdentityProviderVariables = {
  pathParams: ZoneLevelAccessIdentityProvidersGetAnAccessIdentityProviderPathParams;
} & FetcherExtraProps;

/**
 * Fetches a configured identity provider.
 */
export const zoneLevelAccessIdentityProvidersGetAnAccessIdentityProvider = (
  variables: ZoneLevelAccessIdentityProvidersGetAnAccessIdentityProviderVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessIdentityProvidersComponentsSchemasSingleResponse,
    ZoneLevelAccessIdentityProvidersGetAnAccessIdentityProviderError,
    undefined,
    {},
    {},
    ZoneLevelAccessIdentityProvidersGetAnAccessIdentityProviderPathParams
  >({ url: '/zones/{zoneId}/access/identity_providers/{identityProviderId}', method: 'get', ...variables, signal });

export type ZoneLevelAccessIdentityProvidersUpdateAnAccessIdentityProviderPathParams = {
  identityProviderId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessIdentityProvidersUpdateAnAccessIdentityProviderError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessIdentityProvidersUpdateAnAccessIdentityProviderVariables = {
  body?: Schemas.AccessSchemasIdentityProviders;
  pathParams: ZoneLevelAccessIdentityProvidersUpdateAnAccessIdentityProviderPathParams;
} & FetcherExtraProps;

/**
 * Updates a configured identity provider.
 */
export const zoneLevelAccessIdentityProvidersUpdateAnAccessIdentityProvider = (
  variables: ZoneLevelAccessIdentityProvidersUpdateAnAccessIdentityProviderVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessIdentityProvidersComponentsSchemasSingleResponse,
    ZoneLevelAccessIdentityProvidersUpdateAnAccessIdentityProviderError,
    Schemas.AccessSchemasIdentityProviders,
    {},
    {},
    ZoneLevelAccessIdentityProvidersUpdateAnAccessIdentityProviderPathParams
  >({ url: '/zones/{zoneId}/access/identity_providers/{identityProviderId}', method: 'put', ...variables, signal });

export type ZoneLevelZeroTrustOrganizationGetYourZeroTrustOrganizationPathParams = {
  zoneId: Schemas.AccessOrganizationsComponentsSchemasIdentifier;
};

export type ZoneLevelZeroTrustOrganizationGetYourZeroTrustOrganizationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelZeroTrustOrganizationGetYourZeroTrustOrganizationVariables = {
  pathParams: ZoneLevelZeroTrustOrganizationGetYourZeroTrustOrganizationPathParams;
} & FetcherExtraProps;

/**
 * Returns the configuration for your Zero Trust organization.
 */
export const zoneLevelZeroTrustOrganizationGetYourZeroTrustOrganization = (
  variables: ZoneLevelZeroTrustOrganizationGetYourZeroTrustOrganizationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessOrganizationsComponentsSchemasSingleResponse,
    ZoneLevelZeroTrustOrganizationGetYourZeroTrustOrganizationError,
    undefined,
    {},
    {},
    ZoneLevelZeroTrustOrganizationGetYourZeroTrustOrganizationPathParams
  >({ url: '/zones/{zoneId}/access/organizations', method: 'get', ...variables, signal });

export type ZoneLevelZeroTrustOrganizationCreateYourZeroTrustOrganizationPathParams = {
  zoneId: Schemas.AccessOrganizationsComponentsSchemasIdentifier;
};

export type ZoneLevelZeroTrustOrganizationCreateYourZeroTrustOrganizationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelZeroTrustOrganizationCreateYourZeroTrustOrganizationRequestBody = {
  auth_domain: Schemas.AccessAuthDomain;
  is_ui_read_only?: Schemas.AccessIsUiReadOnly;
  login_design?: Schemas.AccessLoginDesign;
  name: Schemas.AccessName;
  ui_read_only_toggle_reason?: Schemas.AccessUiReadOnlyToggleReason;
  user_seat_expiration_inactive_time?: Schemas.AccessSchemasUserSeatExpirationInactiveTime;
};

export type ZoneLevelZeroTrustOrganizationCreateYourZeroTrustOrganizationVariables = {
  body: ZoneLevelZeroTrustOrganizationCreateYourZeroTrustOrganizationRequestBody;
  pathParams: ZoneLevelZeroTrustOrganizationCreateYourZeroTrustOrganizationPathParams;
} & FetcherExtraProps;

/**
 * Sets up a Zero Trust organization for your account.
 */
export const zoneLevelZeroTrustOrganizationCreateYourZeroTrustOrganization = (
  variables: ZoneLevelZeroTrustOrganizationCreateYourZeroTrustOrganizationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessOrganizationsComponentsSchemasSingleResponse,
    ZoneLevelZeroTrustOrganizationCreateYourZeroTrustOrganizationError,
    ZoneLevelZeroTrustOrganizationCreateYourZeroTrustOrganizationRequestBody,
    {},
    {},
    ZoneLevelZeroTrustOrganizationCreateYourZeroTrustOrganizationPathParams
  >({ url: '/zones/{zoneId}/access/organizations', method: 'post', ...variables, signal });

export type ZoneLevelZeroTrustOrganizationUpdateYourZeroTrustOrganizationPathParams = {
  zoneId: Schemas.AccessOrganizationsComponentsSchemasIdentifier;
};

export type ZoneLevelZeroTrustOrganizationUpdateYourZeroTrustOrganizationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelZeroTrustOrganizationUpdateYourZeroTrustOrganizationRequestBody = {
  auth_domain?: Schemas.AccessAuthDomain;
  is_ui_read_only?: Schemas.AccessIsUiReadOnly;
  login_design?: Schemas.AccessLoginDesign;
  name?: Schemas.AccessName;
  ui_read_only_toggle_reason?: Schemas.AccessUiReadOnlyToggleReason;
  user_seat_expiration_inactive_time?: Schemas.AccessSchemasUserSeatExpirationInactiveTime;
};

export type ZoneLevelZeroTrustOrganizationUpdateYourZeroTrustOrganizationVariables = {
  body?: ZoneLevelZeroTrustOrganizationUpdateYourZeroTrustOrganizationRequestBody;
  pathParams: ZoneLevelZeroTrustOrganizationUpdateYourZeroTrustOrganizationPathParams;
} & FetcherExtraProps;

/**
 * Updates the configuration for your Zero Trust organization.
 */
export const zoneLevelZeroTrustOrganizationUpdateYourZeroTrustOrganization = (
  variables: ZoneLevelZeroTrustOrganizationUpdateYourZeroTrustOrganizationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessOrganizationsComponentsSchemasSingleResponse,
    ZoneLevelZeroTrustOrganizationUpdateYourZeroTrustOrganizationError,
    ZoneLevelZeroTrustOrganizationUpdateYourZeroTrustOrganizationRequestBody,
    {},
    {},
    ZoneLevelZeroTrustOrganizationUpdateYourZeroTrustOrganizationPathParams
  >({ url: '/zones/{zoneId}/access/organizations', method: 'put', ...variables, signal });

export type ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserPathParams = {
  zoneId: Schemas.AccessOrganizationsComponentsSchemasIdentifier;
};

export type ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserError = Fetcher.ErrorWrapper<{
  status: ClientErrorStatus;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserRequestBody = {
  /**
   * The email of the user to revoke.
   *
   * @example test@example.com
   */
  email: string;
};

export type ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserVariables = {
  body: ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserRequestBody;
  pathParams: ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserPathParams;
} & FetcherExtraProps;

/**
 * Revokes a user's access across all applications.
 */
export const zoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUser = (
  variables: ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessEmptyResponse,
    ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserError,
    ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserRequestBody,
    {},
    {},
    ZoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUserPathParams
  >({ url: '/zones/{zoneId}/access/organizations/revoke_user', method: 'post', ...variables, signal });

export type ZoneLevelAccessServiceTokensListServiceTokensPathParams = {
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessServiceTokensListServiceTokensError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessServiceTokensListServiceTokensVariables = {
  pathParams: ZoneLevelAccessServiceTokensListServiceTokensPathParams;
} & FetcherExtraProps;

/**
 * Lists all service tokens.
 */
export const zoneLevelAccessServiceTokensListServiceTokens = (
  variables: ZoneLevelAccessServiceTokensListServiceTokensVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessComponentsSchemasResponseCollection,
    ZoneLevelAccessServiceTokensListServiceTokensError,
    undefined,
    {},
    {},
    ZoneLevelAccessServiceTokensListServiceTokensPathParams
  >({ url: '/zones/{zoneId}/access/service_tokens', method: 'get', ...variables, signal });

export type ZoneLevelAccessServiceTokensCreateAServiceTokenPathParams = {
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessServiceTokensCreateAServiceTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessServiceTokensCreateAServiceTokenRequestBody = {
  duration?: Schemas.AccessDuration;
  name: Schemas.AccessSchemasName;
};

export type ZoneLevelAccessServiceTokensCreateAServiceTokenVariables = {
  body: ZoneLevelAccessServiceTokensCreateAServiceTokenRequestBody;
  pathParams: ZoneLevelAccessServiceTokensCreateAServiceTokenPathParams;
} & FetcherExtraProps;

/**
 * Generates a new service token. **Note:** This is the only time you can get the Client Secret. If you lose the Client Secret, you will have to create a new service token.
 */
export const zoneLevelAccessServiceTokensCreateAServiceToken = (
  variables: ZoneLevelAccessServiceTokensCreateAServiceTokenVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessCreateResponse,
    ZoneLevelAccessServiceTokensCreateAServiceTokenError,
    ZoneLevelAccessServiceTokensCreateAServiceTokenRequestBody,
    {},
    {},
    ZoneLevelAccessServiceTokensCreateAServiceTokenPathParams
  >({ url: '/zones/{zoneId}/access/service_tokens', method: 'post', ...variables, signal });

export type ZoneLevelAccessServiceTokensDeleteAServiceTokenPathParams = {
  serviceTokenId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessServiceTokensDeleteAServiceTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessServiceTokensDeleteAServiceTokenVariables = {
  pathParams: ZoneLevelAccessServiceTokensDeleteAServiceTokenPathParams;
} & FetcherExtraProps;

/**
 * Deletes a service token.
 */
export const zoneLevelAccessServiceTokensDeleteAServiceToken = (
  variables: ZoneLevelAccessServiceTokensDeleteAServiceTokenVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessSchemasSingleResponse,
    ZoneLevelAccessServiceTokensDeleteAServiceTokenError,
    undefined,
    {},
    {},
    ZoneLevelAccessServiceTokensDeleteAServiceTokenPathParams
  >({ url: '/zones/{zoneId}/access/service_tokens/{serviceTokenId}', method: 'delete', ...variables, signal });

export type ZoneLevelAccessServiceTokensGetAServiceTokenPathParams = {
  serviceTokenId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessServiceTokensGetAServiceTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessServiceTokensGetAServiceTokenVariables = {
  pathParams: ZoneLevelAccessServiceTokensGetAServiceTokenPathParams;
} & FetcherExtraProps;

/**
 * Fetches a single service token.
 */
export const zoneLevelAccessServiceTokensGetAServiceToken = (
  variables: ZoneLevelAccessServiceTokensGetAServiceTokenVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessSchemasSingleResponse,
    ZoneLevelAccessServiceTokensGetAServiceTokenError,
    undefined,
    {},
    {},
    ZoneLevelAccessServiceTokensGetAServiceTokenPathParams
  >({ url: '/zones/{zoneId}/access/service_tokens/{serviceTokenId}', method: 'get', ...variables, signal });

export type ZoneLevelAccessServiceTokensUpdateAServiceTokenPathParams = {
  serviceTokenId: Schemas.AccessUuid;
  zoneId: Schemas.AccessIdentifier;
};

export type ZoneLevelAccessServiceTokensUpdateAServiceTokenError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.AccessApiResponseCommonFailure;
}>;

export type ZoneLevelAccessServiceTokensUpdateAServiceTokenRequestBody = {
  duration?: Schemas.AccessDuration;
  name?: Schemas.AccessSchemasName;
};

export type ZoneLevelAccessServiceTokensUpdateAServiceTokenVariables = {
  body?: ZoneLevelAccessServiceTokensUpdateAServiceTokenRequestBody;
  pathParams: ZoneLevelAccessServiceTokensUpdateAServiceTokenPathParams;
} & FetcherExtraProps;

/**
 * Updates a configured service token.
 */
export const zoneLevelAccessServiceTokensUpdateAServiceToken = (
  variables: ZoneLevelAccessServiceTokensUpdateAServiceTokenVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.AccessSchemasSingleResponse,
    ZoneLevelAccessServiceTokensUpdateAServiceTokenError,
    ZoneLevelAccessServiceTokensUpdateAServiceTokenRequestBody,
    {},
    {},
    ZoneLevelAccessServiceTokensUpdateAServiceTokenPathParams
  >({ url: '/zones/{zoneId}/access/service_tokens/{serviceTokenId}', method: 'put', ...variables, signal });

export type TotalTlsTotalTlsSettingsDetailsPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type TotalTlsTotalTlsSettingsDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesTotalTlsSettingsResponse &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type TotalTlsTotalTlsSettingsDetailsVariables = {
  pathParams: TotalTlsTotalTlsSettingsDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get Total TLS Settings for a Zone.
 */
export const totalTlsTotalTlsSettingsDetails = (
  variables: TotalTlsTotalTlsSettingsDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesTotalTlsSettingsResponse,
    TotalTlsTotalTlsSettingsDetailsError,
    undefined,
    {},
    {},
    TotalTlsTotalTlsSettingsDetailsPathParams
  >({ url: '/zones/{zoneId}/acm/total_tls', method: 'get', ...variables, signal });

export type TotalTlsEnableOrDisableTotalTlsPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type TotalTlsEnableOrDisableTotalTlsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesTotalTlsSettingsResponse &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type TotalTlsEnableOrDisableTotalTlsRequestBody = {
  certificate_authority?: Schemas.TlsCertificatesAndHostnamesComponentsSchemasCertificateAuthority;
  enabled: Schemas.TlsCertificatesAndHostnamesComponentsSchemasEnabled;
};

export type TotalTlsEnableOrDisableTotalTlsVariables = {
  body: TotalTlsEnableOrDisableTotalTlsRequestBody;
  pathParams: TotalTlsEnableOrDisableTotalTlsPathParams;
} & FetcherExtraProps;

/**
 * Set Total TLS Settings or disable the feature for a Zone.
 */
export const totalTlsEnableOrDisableTotalTls = (
  variables: TotalTlsEnableOrDisableTotalTlsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesTotalTlsSettingsResponse,
    TotalTlsEnableOrDisableTotalTlsError,
    TotalTlsEnableOrDisableTotalTlsRequestBody,
    {},
    {},
    TotalTlsEnableOrDisableTotalTlsPathParams
  >({ url: '/zones/{zoneId}/acm/total_tls', method: 'post', ...variables, signal });

export type PutZonesZoneIdActivationCheckPathParams = {
  /**
   * Zone ID
   */
  zoneId: Schemas.ZoneActivationIdentifier;
};

export type PutZonesZoneIdActivationCheckError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZoneActivationApiResponseCommonFailure;
}>;

export type PutZonesZoneIdActivationCheckResponse = Schemas.ZoneActivationApiResponseSingle & {
  result?: {
    id?: Schemas.ZoneActivationIdentifier;
  };
};

export type PutZonesZoneIdActivationCheckVariables = {
  pathParams: PutZonesZoneIdActivationCheckPathParams;
} & FetcherExtraProps;

/**
 * Triggeres a new activation check for a PENDING Zone. This can be
 * triggered every 5 min for paygo/ent customers, every hour for FREE
 * Zones.
 */
export const putZonesZoneIdActivationCheck = (
  variables: PutZonesZoneIdActivationCheckVariables,
  signal?: AbortSignal
) =>
  fetch<
    PutZonesZoneIdActivationCheckResponse,
    PutZonesZoneIdActivationCheckError,
    undefined,
    {},
    {},
    PutZonesZoneIdActivationCheckPathParams
  >({ url: '/zones/{zoneId}/activation_check', method: 'put', ...variables, signal });

export type DlsAccountRegionalHostnamesAccountListHostnamesPathParams = {
  zoneId: Schemas.DlsIdentifier;
};

export type DlsAccountRegionalHostnamesAccountListHostnamesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlsApiResponseCommonFailure;
}>;

export type DlsAccountRegionalHostnamesAccountListHostnamesResponse = Schemas.DlsApiResponseCollection & {
  result?: Schemas.DlsRegionalHostnameResponse[];
};

export type DlsAccountRegionalHostnamesAccountListHostnamesVariables = {
  pathParams: DlsAccountRegionalHostnamesAccountListHostnamesPathParams;
} & FetcherExtraProps;

/**
 * List all Regional Hostnames within a zone.
 */
export const dlsAccountRegionalHostnamesAccountListHostnames = (
  variables: DlsAccountRegionalHostnamesAccountListHostnamesVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlsAccountRegionalHostnamesAccountListHostnamesResponse,
    DlsAccountRegionalHostnamesAccountListHostnamesError,
    undefined,
    {},
    {},
    DlsAccountRegionalHostnamesAccountListHostnamesPathParams
  >({ url: '/zones/{zoneId}/addressing/regional_hostnames', method: 'get', ...variables, signal });

export type DlsAccountRegionalHostnamesAccountCreateHostnamePathParams = {
  zoneId: Schemas.DlsIdentifier;
};

export type DlsAccountRegionalHostnamesAccountCreateHostnameError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlsApiResponseCommonFailure;
}>;

export type DlsAccountRegionalHostnamesAccountCreateHostnameResponse = Schemas.DlsApiResponseCommon & {
  result?: Schemas.DlsRegionalHostnameResponse;
};

export type DlsAccountRegionalHostnamesAccountCreateHostnameRequestBody = {
  hostname: Schemas.DlsHostname;
  region_key: Schemas.DlsRegionKey;
};

export type DlsAccountRegionalHostnamesAccountCreateHostnameVariables = {
  body: DlsAccountRegionalHostnamesAccountCreateHostnameRequestBody;
  pathParams: DlsAccountRegionalHostnamesAccountCreateHostnamePathParams;
} & FetcherExtraProps;

/**
 * Create a new Regional Hostname entry. Cloudflare will only use data centers that are physically located within the chosen region to decrypt and service HTTPS traffic. Learn more about [Regional Services](https://developers.cloudflare.com/data-localization/regional-services/get-started/).
 */
export const dlsAccountRegionalHostnamesAccountCreateHostname = (
  variables: DlsAccountRegionalHostnamesAccountCreateHostnameVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlsAccountRegionalHostnamesAccountCreateHostnameResponse,
    DlsAccountRegionalHostnamesAccountCreateHostnameError,
    DlsAccountRegionalHostnamesAccountCreateHostnameRequestBody,
    {},
    {},
    DlsAccountRegionalHostnamesAccountCreateHostnamePathParams
  >({ url: '/zones/{zoneId}/addressing/regional_hostnames', method: 'post', ...variables, signal });

export type DlsAccountRegionalHostnamesAccountDeleteHostnamePathParams = {
  zoneId: Schemas.DlsIdentifier;
  hostname: Schemas.DlsHostname;
};

export type DlsAccountRegionalHostnamesAccountDeleteHostnameError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlsApiResponseCommonFailure;
}>;

export type DlsAccountRegionalHostnamesAccountDeleteHostnameResponse = Schemas.DlsApiResponseCommon;

export type DlsAccountRegionalHostnamesAccountDeleteHostnameVariables = {
  pathParams: DlsAccountRegionalHostnamesAccountDeleteHostnamePathParams;
} & FetcherExtraProps;

/**
 * Delete the region configuration for a specific Regional Hostname.
 */
export const dlsAccountRegionalHostnamesAccountDeleteHostname = (
  variables: DlsAccountRegionalHostnamesAccountDeleteHostnameVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlsAccountRegionalHostnamesAccountDeleteHostnameResponse,
    DlsAccountRegionalHostnamesAccountDeleteHostnameError,
    undefined,
    {},
    {},
    DlsAccountRegionalHostnamesAccountDeleteHostnamePathParams
  >({ url: '/zones/{zoneId}/addressing/regional_hostnames/{hostname}', method: 'delete', ...variables, signal });

export type DlsAccountRegionalHostnamesAccountFetchHostnamePathParams = {
  zoneId: Schemas.DlsIdentifier;
  hostname: Schemas.DlsHostname;
};

export type DlsAccountRegionalHostnamesAccountFetchHostnameError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlsApiResponseCommonFailure;
}>;

export type DlsAccountRegionalHostnamesAccountFetchHostnameResponse = Schemas.DlsApiResponseCommon & {
  result?: Schemas.DlsRegionalHostnameResponse;
};

export type DlsAccountRegionalHostnamesAccountFetchHostnameVariables = {
  pathParams: DlsAccountRegionalHostnamesAccountFetchHostnamePathParams;
} & FetcherExtraProps;

/**
 * Fetch the configuration for a specific Regional Hostname, within a zone.
 */
export const dlsAccountRegionalHostnamesAccountFetchHostname = (
  variables: DlsAccountRegionalHostnamesAccountFetchHostnameVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlsAccountRegionalHostnamesAccountFetchHostnameResponse,
    DlsAccountRegionalHostnamesAccountFetchHostnameError,
    undefined,
    {},
    {},
    DlsAccountRegionalHostnamesAccountFetchHostnamePathParams
  >({ url: '/zones/{zoneId}/addressing/regional_hostnames/{hostname}', method: 'get', ...variables, signal });

export type DlsAccountRegionalHostnamesAccountPatchHostnamePathParams = {
  zoneId: Schemas.DlsIdentifier;
  hostname: Schemas.DlsHostname;
};

export type DlsAccountRegionalHostnamesAccountPatchHostnameError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DlsApiResponseCommonFailure;
}>;

export type DlsAccountRegionalHostnamesAccountPatchHostnameResponse = Schemas.DlsApiResponseCommon & {
  result?: Schemas.DlsRegionalHostnameResponse;
};

export type DlsAccountRegionalHostnamesAccountPatchHostnameRequestBody = {
  region_key: Schemas.DlsRegionKey;
};

export type DlsAccountRegionalHostnamesAccountPatchHostnameVariables = {
  body: DlsAccountRegionalHostnamesAccountPatchHostnameRequestBody;
  pathParams: DlsAccountRegionalHostnamesAccountPatchHostnamePathParams;
} & FetcherExtraProps;

/**
 * Update the configuration for a specific Regional Hostname. Only the region_key of a hostname is mutable.
 */
export const dlsAccountRegionalHostnamesAccountPatchHostname = (
  variables: DlsAccountRegionalHostnamesAccountPatchHostnameVariables,
  signal?: AbortSignal
) =>
  fetch<
    DlsAccountRegionalHostnamesAccountPatchHostnameResponse,
    DlsAccountRegionalHostnamesAccountPatchHostnameError,
    DlsAccountRegionalHostnamesAccountPatchHostnameRequestBody,
    {},
    {},
    DlsAccountRegionalHostnamesAccountPatchHostnamePathParams
  >({ url: '/zones/{zoneId}/addressing/regional_hostnames/{hostname}', method: 'patch', ...variables, signal });

export type ArgoAnalyticsForZoneArgoAnalyticsForAZonePathParams = {
  zoneId: Schemas.ArgoAnalyticsIdentifier;
};

export type ArgoAnalyticsForZoneArgoAnalyticsForAZoneQueryParams = {
  bins?: string;
};

export type ArgoAnalyticsForZoneArgoAnalyticsForAZoneError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ArgoAnalyticsResponseSingle & Schemas.ArgoAnalyticsApiResponseCommonFailure;
}>;

export type ArgoAnalyticsForZoneArgoAnalyticsForAZoneVariables = {
  pathParams: ArgoAnalyticsForZoneArgoAnalyticsForAZonePathParams;
  queryParams?: ArgoAnalyticsForZoneArgoAnalyticsForAZoneQueryParams;
} & FetcherExtraProps;

export const argoAnalyticsForZoneArgoAnalyticsForAZone = (
  variables: ArgoAnalyticsForZoneArgoAnalyticsForAZoneVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ArgoAnalyticsResponseSingle,
    ArgoAnalyticsForZoneArgoAnalyticsForAZoneError,
    undefined,
    {},
    ArgoAnalyticsForZoneArgoAnalyticsForAZoneQueryParams,
    ArgoAnalyticsForZoneArgoAnalyticsForAZonePathParams
  >({ url: '/zones/{zoneId}/analytics/latency', method: 'get', ...variables, signal });

export type ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsPathParams = {
  zoneId: Schemas.ArgoAnalyticsIdentifier;
};

export type ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ArgoAnalyticsResponseSingle & Schemas.ArgoAnalyticsApiResponseCommonFailure;
}>;

export type ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsVariables = {
  pathParams: ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsPathParams;
} & FetcherExtraProps;

export const argoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPs = (
  variables: ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ArgoAnalyticsResponseSingle,
    ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsError,
    undefined,
    {},
    {},
    ArgoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPsPathParams
  >({ url: '/zones/{zoneId}/analytics/latency/colos', method: 'get', ...variables, signal });

export type ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesQueryParams = {
  properties?: Schemas.ApiShieldProperties;
};

export type ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesVariables = {
  pathParams: ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesPathParams;
  queryParams?: ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesQueryParams;
} & FetcherExtraProps;

export const apiShieldSettingsRetrieveInformationAboutSpecificConfigurationProperties = (
  variables: ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ApiShieldConfigurationSingleResponse,
    ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesError,
    undefined,
    {},
    ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesQueryParams,
    ApiShieldSettingsRetrieveInformationAboutSpecificConfigurationPropertiesPathParams
  >({ url: '/zones/{zoneId}/api_gateway/configuration', method: 'get', ...variables, signal });

export type ApiShieldSettingsSetConfigurationPropertiesPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldSettingsSetConfigurationPropertiesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldSettingsSetConfigurationPropertiesVariables = {
  body: Schemas.ApiShieldConfiguration;
  pathParams: ApiShieldSettingsSetConfigurationPropertiesPathParams;
} & FetcherExtraProps;

export const apiShieldSettingsSetConfigurationProperties = (
  variables: ApiShieldSettingsSetConfigurationPropertiesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ApiShieldApiResponseCommon,
    ApiShieldSettingsSetConfigurationPropertiesError,
    Schemas.ApiShieldConfiguration,
    {},
    {},
    ApiShieldSettingsSetConfigurationPropertiesPathParams
  >({ url: '/zones/{zoneId}/api_gateway/configuration', method: 'put', ...variables, signal });

export type ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldSchemaResponseDiscovery & Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiVariables = {
  pathParams: ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiPathParams;
} & FetcherExtraProps;

/**
 * Retrieve the most up to date view of discovered operations, rendered as OpenAPI schemas
 */
export const apiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapi = (
  variables: ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ApiShieldSchemaResponseDiscovery,
    ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiError,
    undefined,
    {},
    {},
    ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapiPathParams
  >({ url: '/zones/{zoneId}/api_gateway/discovery', method: 'get', ...variables, signal });

export type ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZonePathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneQueryParams = {
  /**
   * Page number of paginated results.
   *
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * Maximum number of results per page.
   *
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * @uniqueItems true
   */
  host?: string[];
  /**
   * @uniqueItems true
   */
  method?: string[];
  /**
   * @example /api/v1
   */
  endpoint?: string;
  /**
   * @example desc
   */
  direction?: 'asc' | 'desc';
  /**
   * @example method
   */
  order?: 'host' | 'method' | 'endpoint' | 'traffic_stats.requests' | 'traffic_stats.last_updated';
  diff?: boolean;
  /**
   * Filter results to only include discovery results sourced from a particular discovery engine
   *   * `ML` - Discovered operations that were sourced using ML API Discovery
   *   * `SessionIdentifier` - Discovered operations that were sourced using Session Identifier API Discovery
   */
  origin?: Schemas.ApiShieldApiDiscoveryOrigin;
  /**
   * Filter results to only include discovery results in a particular state. States are as follows
   *   * `review` - Discovered operations that are not saved into API Shield Endpoint Management
   *   * `saved` - Discovered operations that are already saved into API Shield Endpoint Management
   *   * `ignored` - Discovered operations that have been marked as ignored
   */
  state?: Schemas.ApiShieldApiDiscoveryState;
};

export type ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneResponse =
  Schemas.ApiShieldApiResponseCollection & {
    result: Schemas.ApiShieldDiscoveryOperation[];
  };

export type ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneVariables = {
  pathParams: ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZonePathParams;
  queryParams?: ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneQueryParams;
} & FetcherExtraProps;

/**
 * Retrieve the most up to date view of discovered operations
 */
export const apiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZone = (
  variables: ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneVariables,
  signal?: AbortSignal
) =>
  fetch<
    ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneResponse,
    ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneError,
    undefined,
    {},
    ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneQueryParams,
    ApiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZonePathParams
  >({ url: '/zones/{zoneId}/api_gateway/discovery/operations', method: 'get', ...variables, signal });

export type ApiShieldApiPatchDiscoveredOperationsPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldApiPatchDiscoveredOperationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldApiPatchDiscoveredOperationsVariables = {
  body?: Schemas.ApiShieldApiDiscoveryPatchMultipleRequest;
  pathParams: ApiShieldApiPatchDiscoveredOperationsPathParams;
} & FetcherExtraProps;

/**
 * Update the `state` on one or more discovered operations
 */
export const apiShieldApiPatchDiscoveredOperations = (
  variables: ApiShieldApiPatchDiscoveredOperationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ApiShieldPatchDiscoveriesResponse,
    ApiShieldApiPatchDiscoveredOperationsError,
    Schemas.ApiShieldApiDiscoveryPatchMultipleRequest,
    {},
    {},
    ApiShieldApiPatchDiscoveredOperationsPathParams
  >({ url: '/zones/{zoneId}/api_gateway/discovery/operations', method: 'patch', ...variables, signal });

export type ApiShieldApiPatchDiscoveredOperationPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
  /**
   * Identifier for the discovered operation
   */
  operationId: Schemas.ApiShieldSchemasUuid;
};

export type ApiShieldApiPatchDiscoveredOperationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldApiPatchDiscoveredOperationRequestBody = {
  /**
   * Mark state of operation in API Discovery
   *   * `review` - Mark operation as for review
   *   * `ignored` - Mark operation as ignored
   */
  state?: Schemas.ApiShieldApiDiscoveryStatePatch;
};

export type ApiShieldApiPatchDiscoveredOperationVariables = {
  body?: ApiShieldApiPatchDiscoveredOperationRequestBody;
  pathParams: ApiShieldApiPatchDiscoveredOperationPathParams;
} & FetcherExtraProps;

/**
 * Update the `state` on a discovered operation
 */
export const apiShieldApiPatchDiscoveredOperation = (
  variables: ApiShieldApiPatchDiscoveredOperationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ApiShieldPatchDiscoveryResponse,
    ApiShieldApiPatchDiscoveredOperationError,
    ApiShieldApiPatchDiscoveredOperationRequestBody,
    {},
    {},
    ApiShieldApiPatchDiscoveredOperationPathParams
  >({ url: '/zones/{zoneId}/api_gateway/discovery/operations/{operationId}', method: 'patch', ...variables, signal });

export type ApiShieldExpressionTemplatesFallthroughPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldExpressionTemplatesFallthroughError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldExpressionTemplatesFallthroughResponse = Schemas.ApiShieldApiResponseCommon & {
  result: Schemas.ApiShieldResponseExpressionTemplatesFallthrough;
};

export type ApiShieldExpressionTemplatesFallthroughVariables = {
  body: Schemas.ApiShieldRequestExpressionTemplatesFallthrough;
  pathParams: ApiShieldExpressionTemplatesFallthroughPathParams;
} & FetcherExtraProps;

export const apiShieldExpressionTemplatesFallthrough = (
  variables: ApiShieldExpressionTemplatesFallthroughVariables,
  signal?: AbortSignal
) =>
  fetch<
    ApiShieldExpressionTemplatesFallthroughResponse,
    ApiShieldExpressionTemplatesFallthroughError,
    Schemas.ApiShieldRequestExpressionTemplatesFallthrough,
    {},
    {},
    ApiShieldExpressionTemplatesFallthroughPathParams
  >({ url: '/zones/{zoneId}/api_gateway/expression-template/fallthrough', method: 'post', ...variables, signal });

export type ApiShieldEndpointManagementDeleteMultipleOperationsPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldEndpointManagementDeleteMultipleOperationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldEndpointManagementDeleteMultipleOperationsRequestBody = Schemas.ApiShieldObjectWithOperationId[];

export type ApiShieldEndpointManagementDeleteMultipleOperationsVariables = {
  body?: ApiShieldEndpointManagementDeleteMultipleOperationsRequestBody;
  pathParams: ApiShieldEndpointManagementDeleteMultipleOperationsPathParams;
} & FetcherExtraProps;

export const apiShieldEndpointManagementDeleteMultipleOperations = (
  variables: ApiShieldEndpointManagementDeleteMultipleOperationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ApiShieldApiResponseCommon,
    ApiShieldEndpointManagementDeleteMultipleOperationsError,
    ApiShieldEndpointManagementDeleteMultipleOperationsRequestBody,
    {},
    {},
    ApiShieldEndpointManagementDeleteMultipleOperationsPathParams
  >({ url: '/zones/{zoneId}/api_gateway/operations', method: 'delete', ...variables, signal });

export type ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZonePathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneQueryParams = {
  /**
   * Page number of paginated results.
   *
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * Maximum number of results per page.
   *
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example method
   */
  order?: 'method' | 'host' | 'endpoint' | 'thresholds.$key';
  /**
   * @example desc
   */
  direction?: 'asc' | 'desc';
  /**
   * @uniqueItems true
   */
  host?: string[];
  /**
   * @uniqueItems true
   */
  method?: string[];
  /**
   * @example /api/v1
   */
  endpoint?: string;
  /**
   * Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning.
   *
   * @example thresholds
   * @uniqueItems true
   */
  feature?: ('thresholds' | 'parameter_schemas' | 'schema_info')[];
};

export type ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneVariables = {
  pathParams: ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZonePathParams;
  queryParams?: ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneQueryParams;
} & FetcherExtraProps;

export const apiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZone = (
  variables: ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ApiShieldMultipleOperationResponsePaginated,
    ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneError,
    undefined,
    {},
    ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZoneQueryParams,
    ApiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZonePathParams
  >({ url: '/zones/{zoneId}/api_gateway/operations', method: 'get', ...variables, signal });

export type ApiShieldEndpointManagementAddOperationsToAZonePathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldEndpointManagementAddOperationsToAZoneError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldEndpointManagementAddOperationsToAZoneRequestBody = Schemas.ApiShieldBasicOperation[];

export type ApiShieldEndpointManagementAddOperationsToAZoneVariables = {
  body?: ApiShieldEndpointManagementAddOperationsToAZoneRequestBody;
  pathParams: ApiShieldEndpointManagementAddOperationsToAZonePathParams;
} & FetcherExtraProps;

/**
 * Add one or more operations to a zone. Endpoints can contain path variables. Host, method, endpoint will be normalized to a canoncial form when creating an operation and must be unique on the zone. Inserting an operation that matches an existing one will return the record of the already existing operation and update its last_updated date.
 */
export const apiShieldEndpointManagementAddOperationsToAZone = (
  variables: ApiShieldEndpointManagementAddOperationsToAZoneVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ApiShieldMultipleOperationResponse,
    ApiShieldEndpointManagementAddOperationsToAZoneError,
    ApiShieldEndpointManagementAddOperationsToAZoneRequestBody,
    {},
    {},
    ApiShieldEndpointManagementAddOperationsToAZonePathParams
  >({ url: '/zones/{zoneId}/api_gateway/operations', method: 'post', ...variables, signal });

export type ApiShieldEndpointManagementAddOperationToAZonePathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldEndpointManagementAddOperationToAZoneError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldEndpointManagementAddOperationToAZoneVariables = {
  body: Schemas.ApiShieldBasicOperation;
  pathParams: ApiShieldEndpointManagementAddOperationToAZonePathParams;
} & FetcherExtraProps;

/**
 * Add one operation to a zone. Endpoints can contain path variables. Host, method, endpoint will be normalized to a canoncial form when creating an operation and must be unique on the zone. Inserting an operation that matches an existing one will return the record of the already existing operation and update its last_updated date.
 */
export const apiShieldEndpointManagementAddOperationToAZone = (
  variables: ApiShieldEndpointManagementAddOperationToAZoneVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ApiShieldSingleOperationResponse,
    ApiShieldEndpointManagementAddOperationToAZoneError,
    Schemas.ApiShieldBasicOperation,
    {},
    {},
    ApiShieldEndpointManagementAddOperationToAZonePathParams
  >({ url: '/zones/{zoneId}/api_gateway/operations/item', method: 'post', ...variables, signal });

export type ApiShieldSchemaValidationUpdateMultipleOperationLevelSettingsPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldSchemaValidationUpdateMultipleOperationLevelSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldSchemaValidationUpdateMultipleOperationLevelSettingsResponse =
  Schemas.ApiShieldApiResponseCommon & {
    result: Schemas.ApiShieldOperationSchemaValidationSettingsMultipleRequest;
  };

export type ApiShieldSchemaValidationUpdateMultipleOperationLevelSettingsVariables = {
  body?: Schemas.ApiShieldOperationSchemaValidationSettingsMultipleRequest;
  pathParams: ApiShieldSchemaValidationUpdateMultipleOperationLevelSettingsPathParams;
} & FetcherExtraProps;

/**
 * Updates multiple operation-level schema validation settings on the zone
 */
export const apiShieldSchemaValidationUpdateMultipleOperationLevelSettings = (
  variables: ApiShieldSchemaValidationUpdateMultipleOperationLevelSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    ApiShieldSchemaValidationUpdateMultipleOperationLevelSettingsResponse,
    ApiShieldSchemaValidationUpdateMultipleOperationLevelSettingsError,
    Schemas.ApiShieldOperationSchemaValidationSettingsMultipleRequest,
    {},
    {},
    ApiShieldSchemaValidationUpdateMultipleOperationLevelSettingsPathParams
  >({ url: '/zones/{zoneId}/api_gateway/operations/schema_validation', method: 'patch', ...variables, signal });

export type ApiShieldEndpointManagementDeleteAnOperationPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
  /**
   * Identifier for the operation
   */
  operationId: Schemas.ApiShieldUuid;
};

export type ApiShieldEndpointManagementDeleteAnOperationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldEndpointManagementDeleteAnOperationVariables = {
  pathParams: ApiShieldEndpointManagementDeleteAnOperationPathParams;
} & FetcherExtraProps;

export const apiShieldEndpointManagementDeleteAnOperation = (
  variables: ApiShieldEndpointManagementDeleteAnOperationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ApiShieldApiResponseCommon,
    ApiShieldEndpointManagementDeleteAnOperationError,
    undefined,
    {},
    {},
    ApiShieldEndpointManagementDeleteAnOperationPathParams
  >({ url: '/zones/{zoneId}/api_gateway/operations/{operationId}', method: 'delete', ...variables, signal });

export type ApiShieldEndpointManagementRetrieveInformationAboutAnOperationPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
  /**
   * Identifier for the operation
   */
  operationId: Schemas.ApiShieldUuid;
};

export type ApiShieldEndpointManagementRetrieveInformationAboutAnOperationQueryParams = {
  /**
   * Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning.
   *
   * @example thresholds
   * @uniqueItems true
   */
  feature?: ('thresholds' | 'parameter_schemas' | 'schema_info')[];
};

export type ApiShieldEndpointManagementRetrieveInformationAboutAnOperationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldEndpointManagementRetrieveInformationAboutAnOperationVariables = {
  pathParams: ApiShieldEndpointManagementRetrieveInformationAboutAnOperationPathParams;
  queryParams?: ApiShieldEndpointManagementRetrieveInformationAboutAnOperationQueryParams;
} & FetcherExtraProps;

export const apiShieldEndpointManagementRetrieveInformationAboutAnOperation = (
  variables: ApiShieldEndpointManagementRetrieveInformationAboutAnOperationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ApiShieldSingleOperationResponse,
    ApiShieldEndpointManagementRetrieveInformationAboutAnOperationError,
    undefined,
    {},
    ApiShieldEndpointManagementRetrieveInformationAboutAnOperationQueryParams,
    ApiShieldEndpointManagementRetrieveInformationAboutAnOperationPathParams
  >({ url: '/zones/{zoneId}/api_gateway/operations/{operationId}', method: 'get', ...variables, signal });

export type ApiShieldSchemaValidationRetrieveOperationLevelSettingsPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
  /**
   * Identifier for the operation
   */
  operationId: Schemas.ApiShieldUuid;
};

export type ApiShieldSchemaValidationRetrieveOperationLevelSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldSchemaValidationRetrieveOperationLevelSettingsVariables = {
  pathParams: ApiShieldSchemaValidationRetrieveOperationLevelSettingsPathParams;
} & FetcherExtraProps;

/**
 * Retrieves operation-level schema validation settings on the zone
 */
export const apiShieldSchemaValidationRetrieveOperationLevelSettings = (
  variables: ApiShieldSchemaValidationRetrieveOperationLevelSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ApiShieldOperationSchemaValidationSettings,
    ApiShieldSchemaValidationRetrieveOperationLevelSettingsError,
    undefined,
    {},
    {},
    ApiShieldSchemaValidationRetrieveOperationLevelSettingsPathParams
  >({
    url: '/zones/{zoneId}/api_gateway/operations/{operationId}/schema_validation',
    method: 'get',
    ...variables,
    signal
  });

export type ApiShieldSchemaValidationUpdateOperationLevelSettingsPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
  /**
   * Identifier for the operation
   */
  operationId: Schemas.ApiShieldUuid;
};

export type ApiShieldSchemaValidationUpdateOperationLevelSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldSchemaValidationUpdateOperationLevelSettingsVariables = {
  body?: Schemas.ApiShieldOperationSchemaValidationSettings;
  pathParams: ApiShieldSchemaValidationUpdateOperationLevelSettingsPathParams;
} & FetcherExtraProps;

/**
 * Updates operation-level schema validation settings on the zone
 */
export const apiShieldSchemaValidationUpdateOperationLevelSettings = (
  variables: ApiShieldSchemaValidationUpdateOperationLevelSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ApiShieldOperationSchemaValidationSettings,
    ApiShieldSchemaValidationUpdateOperationLevelSettingsError,
    Schemas.ApiShieldOperationSchemaValidationSettings,
    {},
    {},
    ApiShieldSchemaValidationUpdateOperationLevelSettingsPathParams
  >({
    url: '/zones/{zoneId}/api_gateway/operations/{operationId}/schema_validation',
    method: 'put',
    ...variables,
    signal
  });

export type ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasQueryParams = {
  /**
   * @uniqueItems true
   */
  host?: string[];
  /**
   * Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning.
   *
   * @example thresholds
   * @uniqueItems true
   */
  feature?: ('thresholds' | 'parameter_schemas' | 'schema_info')[];
};

export type ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasVariables = {
  pathParams: ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasPathParams;
  queryParams?: ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasQueryParams;
} & FetcherExtraProps;

export const apiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemas = (
  variables: ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ApiShieldSchemaResponseWithThresholds,
    ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasError,
    undefined,
    {},
    ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasQueryParams,
    ApiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemasPathParams
  >({ url: '/zones/{zoneId}/api_gateway/schemas', method: 'get', ...variables, signal });

export type ApiShieldSchemaValidationRetrieveZoneLevelSettingsPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldSchemaValidationRetrieveZoneLevelSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldSchemaValidationRetrieveZoneLevelSettingsVariables = {
  pathParams: ApiShieldSchemaValidationRetrieveZoneLevelSettingsPathParams;
} & FetcherExtraProps;

/**
 * Retrieves zone level schema validation settings currently set on the zone
 */
export const apiShieldSchemaValidationRetrieveZoneLevelSettings = (
  variables: ApiShieldSchemaValidationRetrieveZoneLevelSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ApiShieldZoneSchemaValidationSettings,
    ApiShieldSchemaValidationRetrieveZoneLevelSettingsError,
    undefined,
    {},
    {},
    ApiShieldSchemaValidationRetrieveZoneLevelSettingsPathParams
  >({ url: '/zones/{zoneId}/api_gateway/settings/schema_validation', method: 'get', ...variables, signal });

export type ApiShieldSchemaValidationPatchZoneLevelSettingsPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldSchemaValidationPatchZoneLevelSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldSchemaValidationPatchZoneLevelSettingsVariables = {
  body?: Schemas.ApiShieldZoneSchemaValidationSettingsPatch;
  pathParams: ApiShieldSchemaValidationPatchZoneLevelSettingsPathParams;
} & FetcherExtraProps;

/**
 * Updates zone level schema validation settings on the zone
 */
export const apiShieldSchemaValidationPatchZoneLevelSettings = (
  variables: ApiShieldSchemaValidationPatchZoneLevelSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ApiShieldZoneSchemaValidationSettings,
    ApiShieldSchemaValidationPatchZoneLevelSettingsError,
    Schemas.ApiShieldZoneSchemaValidationSettingsPatch,
    {},
    {},
    ApiShieldSchemaValidationPatchZoneLevelSettingsPathParams
  >({ url: '/zones/{zoneId}/api_gateway/settings/schema_validation', method: 'patch', ...variables, signal });

export type ApiShieldSchemaValidationUpdateZoneLevelSettingsPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldSchemaValidationUpdateZoneLevelSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldSchemaValidationUpdateZoneLevelSettingsVariables = {
  body: Schemas.ApiShieldZoneSchemaValidationSettingsPut;
  pathParams: ApiShieldSchemaValidationUpdateZoneLevelSettingsPathParams;
} & FetcherExtraProps;

/**
 * Updates zone level schema validation settings on the zone
 */
export const apiShieldSchemaValidationUpdateZoneLevelSettings = (
  variables: ApiShieldSchemaValidationUpdateZoneLevelSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ApiShieldZoneSchemaValidationSettings,
    ApiShieldSchemaValidationUpdateZoneLevelSettingsError,
    Schemas.ApiShieldZoneSchemaValidationSettingsPut,
    {},
    {},
    ApiShieldSchemaValidationUpdateZoneLevelSettingsPathParams
  >({ url: '/zones/{zoneId}/api_gateway/settings/schema_validation', method: 'put', ...variables, signal });

export type ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasQueryParams = {
  /**
   * Page number of paginated results.
   *
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * Maximum number of results per page.
   *
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * Omit the source-files of schemas and only retrieve their meta-data.
   *
   * @default false
   */
  omit_source?: boolean;
  validation_enabled?: Schemas.ApiShieldValidationEnabled;
};

export type ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasResponse =
  Schemas.ApiShieldApiResponseCollection & {
    result: Schemas.ApiShieldPublicSchema[];
  };

export type ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasVariables = {
  pathParams: ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasPathParams;
  queryParams?: ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasQueryParams;
} & FetcherExtraProps;

export const apiShieldSchemaValidationRetrieveInformationAboutAllSchemas = (
  variables: ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasVariables,
  signal?: AbortSignal
) =>
  fetch<
    ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasResponse,
    ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasError,
    undefined,
    {},
    ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasQueryParams,
    ApiShieldSchemaValidationRetrieveInformationAboutAllSchemasPathParams
  >({ url: '/zones/{zoneId}/api_gateway/user_schemas', method: 'get', ...variables, signal });

export type ApiShieldSchemaValidationPostSchemaPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldSchemaValidationPostSchemaError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldSchemaUploadFailure;
}>;

export type ApiShieldSchemaValidationPostSchemaResponse = Schemas.ApiShieldApiResponseCommon & {
  result: Schemas.ApiShieldSchemaUploadResponse;
};

export type ApiShieldSchemaValidationPostSchemaRequestBody = {
  /**
   * Schema file bytes
   *
   * @format binary
   */
  file: Blob;
  kind: Schemas.ApiShieldKind;
  /**
   * Name of the schema
   *
   * @example petstore schema
   */
  name?: string;
  /**
   * Flag whether schema is enabled for validation.
   */
  validation_enabled?: 'true' | 'false';
};

export type ApiShieldSchemaValidationPostSchemaVariables = {
  body: ApiShieldSchemaValidationPostSchemaRequestBody;
  pathParams: ApiShieldSchemaValidationPostSchemaPathParams;
} & FetcherExtraProps;

export const apiShieldSchemaValidationPostSchema = (
  variables: ApiShieldSchemaValidationPostSchemaVariables,
  signal?: AbortSignal
) =>
  fetch<
    ApiShieldSchemaValidationPostSchemaResponse,
    ApiShieldSchemaValidationPostSchemaError,
    ApiShieldSchemaValidationPostSchemaRequestBody,
    {},
    {},
    ApiShieldSchemaValidationPostSchemaPathParams
  >({ url: '/zones/{zoneId}/api_gateway/user_schemas', method: 'post', ...variables, signal });

export type ApiShieldSchemaValidationRetrieveUserSchemaHostsPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldSchemaValidationRetrieveUserSchemaHostsQueryParams = {
  /**
   * Page number of paginated results.
   *
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * Maximum number of results per page.
   *
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
};

export type ApiShieldSchemaValidationRetrieveUserSchemaHostsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldSchemaValidationRetrieveUserSchemaHostsResponse = Schemas.ApiShieldApiResponseCollection & {
  result?: Schemas.ApiShieldResponseUserSchemasHosts[];
};

export type ApiShieldSchemaValidationRetrieveUserSchemaHostsVariables = {
  pathParams: ApiShieldSchemaValidationRetrieveUserSchemaHostsPathParams;
  queryParams?: ApiShieldSchemaValidationRetrieveUserSchemaHostsQueryParams;
} & FetcherExtraProps;

export const apiShieldSchemaValidationRetrieveUserSchemaHosts = (
  variables: ApiShieldSchemaValidationRetrieveUserSchemaHostsVariables,
  signal?: AbortSignal
) =>
  fetch<
    ApiShieldSchemaValidationRetrieveUserSchemaHostsResponse,
    ApiShieldSchemaValidationRetrieveUserSchemaHostsError,
    undefined,
    {},
    ApiShieldSchemaValidationRetrieveUserSchemaHostsQueryParams,
    ApiShieldSchemaValidationRetrieveUserSchemaHostsPathParams
  >({ url: '/zones/{zoneId}/api_gateway/user_schemas/hosts', method: 'get', ...variables, signal });

export type ApiShieldSchemaDeleteASchemaPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
  /**
   * Identifier for the schema-ID
   *
   * @format uuid
   * @maxLength 36
   */
  schemaId: string;
};

export type ApiShieldSchemaDeleteASchemaError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldSchemaDeleteASchemaVariables = {
  pathParams: ApiShieldSchemaDeleteASchemaPathParams;
} & FetcherExtraProps;

export const apiShieldSchemaDeleteASchema = (variables: ApiShieldSchemaDeleteASchemaVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ApiShieldApiResponseSingle,
    ApiShieldSchemaDeleteASchemaError,
    undefined,
    {},
    {},
    ApiShieldSchemaDeleteASchemaPathParams
  >({ url: '/zones/{zoneId}/api_gateway/user_schemas/{schemaId}', method: 'delete', ...variables, signal });

export type ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
  /**
   * Identifier for the schema-ID
   *
   * @format uuid
   * @maxLength 36
   */
  schemaId: string;
};

export type ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaQueryParams = {
  /**
   * Omit the source-files of schemas and only retrieve their meta-data.
   *
   * @default false
   */
  omit_source?: boolean;
};

export type ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaResponse =
  Schemas.ApiShieldApiResponseCommon & {
    result: Schemas.ApiShieldPublicSchema;
  };

export type ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaVariables = {
  pathParams: ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaPathParams;
  queryParams?: ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaQueryParams;
} & FetcherExtraProps;

export const apiShieldSchemaValidationRetrieveInformationAboutSpecificSchema = (
  variables: ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaVariables,
  signal?: AbortSignal
) =>
  fetch<
    ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaResponse,
    ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaError,
    undefined,
    {},
    ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaQueryParams,
    ApiShieldSchemaValidationRetrieveInformationAboutSpecificSchemaPathParams
  >({ url: '/zones/{zoneId}/api_gateway/user_schemas/{schemaId}', method: 'get', ...variables, signal });

export type ApiShieldSchemaValidationEnableValidationForASchemaPathParams = {
  zoneId: Schemas.ApiShieldSchemasIdentifier;
  /**
   * Identifier for the schema-ID
   *
   * @format uuid
   * @maxLength 36
   */
  schemaId: string;
};

export type ApiShieldSchemaValidationEnableValidationForASchemaError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldSchemaValidationEnableValidationForASchemaResponse = Schemas.ApiShieldApiResponseCommon & {
  result: Schemas.ApiShieldPublicSchema;
};

export type ApiShieldSchemaValidationEnableValidationForASchemaRequestBody = {
  /**
   * Flag whether schema is enabled for validation.
   */
  validation_enabled?: Schemas.ApiShieldValidationEnabled & true;
};

export type ApiShieldSchemaValidationEnableValidationForASchemaVariables = {
  body?: ApiShieldSchemaValidationEnableValidationForASchemaRequestBody;
  pathParams: ApiShieldSchemaValidationEnableValidationForASchemaPathParams;
} & FetcherExtraProps;

export const apiShieldSchemaValidationEnableValidationForASchema = (
  variables: ApiShieldSchemaValidationEnableValidationForASchemaVariables,
  signal?: AbortSignal
) =>
  fetch<
    ApiShieldSchemaValidationEnableValidationForASchemaResponse,
    ApiShieldSchemaValidationEnableValidationForASchemaError,
    ApiShieldSchemaValidationEnableValidationForASchemaRequestBody,
    {},
    {},
    ApiShieldSchemaValidationEnableValidationForASchemaPathParams
  >({ url: '/zones/{zoneId}/api_gateway/user_schemas/{schemaId}', method: 'patch', ...variables, signal });

export type ApiShieldSchemaValidationExtractOperationsFromSchemaPathParams = {
  /**
   * Identifier for the schema-ID
   *
   * @format uuid
   * @maxLength 36
   */
  schemaId: string;
  zoneId: Schemas.ApiShieldSchemasIdentifier;
};

export type ApiShieldSchemaValidationExtractOperationsFromSchemaQueryParams = {
  /**
   * Add feature(s) to the results. The feature name that is given here corresponds to the resulting feature object. Have a look at the top-level object description for more details on the specific meaning.
   *
   * @example thresholds
   * @uniqueItems true
   */
  feature?: ('thresholds' | 'parameter_schemas' | 'schema_info')[];
  /**
   * @uniqueItems true
   */
  host?: string[];
  /**
   * @uniqueItems true
   */
  method?: string[];
  /**
   * @example /api/v1
   */
  endpoint?: string;
  /**
   * Page number of paginated results.
   *
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * Maximum number of results per page.
   *
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * Filter results by whether operations exist in API Shield Endpoint Management or not. `new` will just return operations from the schema that do not exist in API Shield Endpoint Management. `existing` will just return operations from the schema that already exist in API Shield Endpoint Management.
   *
   * @example new
   */
  operation_status?: 'new' | 'existing';
};

export type ApiShieldSchemaValidationExtractOperationsFromSchemaError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ApiShieldApiResponseCommonFailure;
}>;

export type ApiShieldSchemaValidationExtractOperationsFromSchemaResponse = Schemas.ApiShieldApiResponseCollection & {
  result: (Schemas.ApiShieldOperation | Schemas.ApiShieldBasicOperation)[];
};

export type ApiShieldSchemaValidationExtractOperationsFromSchemaVariables = {
  pathParams: ApiShieldSchemaValidationExtractOperationsFromSchemaPathParams;
  queryParams?: ApiShieldSchemaValidationExtractOperationsFromSchemaQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves all operations from the schema. Operations that already exist in API Shield Endpoint Management will be returned as full operations.
 */
export const apiShieldSchemaValidationExtractOperationsFromSchema = (
  variables: ApiShieldSchemaValidationExtractOperationsFromSchemaVariables,
  signal?: AbortSignal
) =>
  fetch<
    ApiShieldSchemaValidationExtractOperationsFromSchemaResponse,
    ApiShieldSchemaValidationExtractOperationsFromSchemaError,
    undefined,
    {},
    ApiShieldSchemaValidationExtractOperationsFromSchemaQueryParams,
    ApiShieldSchemaValidationExtractOperationsFromSchemaPathParams
  >({ url: '/zones/{zoneId}/api_gateway/user_schemas/{schemaId}/operations', method: 'get', ...variables, signal });

export type ArgoSmartRoutingGetArgoSmartRoutingSettingPathParams = {
  zoneId: Schemas.ArgoConfigIdentifier;
};

export type ArgoSmartRoutingGetArgoSmartRoutingSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ArgoConfigResponseSingle & Schemas.ArgoConfigApiResponseCommonFailure;
}>;

export type ArgoSmartRoutingGetArgoSmartRoutingSettingVariables = {
  pathParams: ArgoSmartRoutingGetArgoSmartRoutingSettingPathParams;
} & FetcherExtraProps;

export const argoSmartRoutingGetArgoSmartRoutingSetting = (
  variables: ArgoSmartRoutingGetArgoSmartRoutingSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ArgoConfigResponseSingle,
    ArgoSmartRoutingGetArgoSmartRoutingSettingError,
    undefined,
    {},
    {},
    ArgoSmartRoutingGetArgoSmartRoutingSettingPathParams
  >({ url: '/zones/{zoneId}/argo/smart_routing', method: 'get', ...variables, signal });

export type ArgoSmartRoutingPatchArgoSmartRoutingSettingPathParams = {
  zoneId: Schemas.ArgoConfigIdentifier;
};

export type ArgoSmartRoutingPatchArgoSmartRoutingSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ArgoConfigResponseSingle & Schemas.ArgoConfigApiResponseCommonFailure;
}>;

export type ArgoSmartRoutingPatchArgoSmartRoutingSettingVariables = {
  body: Schemas.ArgoConfigPatch;
  pathParams: ArgoSmartRoutingPatchArgoSmartRoutingSettingPathParams;
} & FetcherExtraProps;

/**
 * Updates enablement of Argo Smart Routing.
 */
export const argoSmartRoutingPatchArgoSmartRoutingSetting = (
  variables: ArgoSmartRoutingPatchArgoSmartRoutingSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ArgoConfigResponseSingle,
    ArgoSmartRoutingPatchArgoSmartRoutingSettingError,
    Schemas.ArgoConfigPatch,
    {},
    {},
    ArgoSmartRoutingPatchArgoSmartRoutingSettingPathParams
  >({ url: '/zones/{zoneId}/argo/smart_routing', method: 'patch', ...variables, signal });

export type TieredCachingGetTieredCachingSettingPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type TieredCachingGetTieredCachingSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type TieredCachingGetTieredCachingSettingResponse = Schemas.CacheRulesZoneCacheSettingsResponseSingle &
  Schemas.CacheRulesTieredCacheResponseValue;

export type TieredCachingGetTieredCachingSettingVariables = {
  pathParams: TieredCachingGetTieredCachingSettingPathParams;
} & FetcherExtraProps;

/**
 * Tiered Cache works by dividing Cloudflare's data centers into a hierarchy of lower-tiers and upper-tiers. If content is not cached in lower-tier data centers (generally the ones closest to a visitor), the lower-tier must ask an upper-tier to see if it has the content. If the upper-tier does not have the content, only the upper-tier can ask the origin for content. This practice improves bandwidth efficiency by limiting the number of data centers that can ask the origin for content, which reduces origin load and makes websites more cost-effective to operate. Additionally, Tiered Cache concentrates connections to origin servers so they come from a small number of data centers rather than the full set of network locations. This results in fewer open connections using server resources.
 */
export const tieredCachingGetTieredCachingSetting = (
  variables: TieredCachingGetTieredCachingSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    TieredCachingGetTieredCachingSettingResponse,
    TieredCachingGetTieredCachingSettingError,
    undefined,
    {},
    {},
    TieredCachingGetTieredCachingSettingPathParams
  >({ url: '/zones/{zoneId}/argo/tiered_caching', method: 'get', ...variables, signal });

export type TieredCachingPatchTieredCachingSettingPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type TieredCachingPatchTieredCachingSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type TieredCachingPatchTieredCachingSettingResponse = Schemas.CacheRulesZoneCacheSettingsResponseSingle &
  Schemas.CacheRulesTieredCacheResponseValue;

export type TieredCachingPatchTieredCachingSettingVariables = {
  body: Schemas.CacheRulesPatch;
  pathParams: TieredCachingPatchTieredCachingSettingPathParams;
} & FetcherExtraProps;

/**
 * Tiered Cache works by dividing Cloudflare's data centers into a hierarchy of lower-tiers and upper-tiers. If content is not cached in lower-tier data centers (generally the ones closest to a visitor), the lower-tier must ask an upper-tier to see if it has the content. If the upper-tier does not have the content, only the upper-tier can ask the origin for content. This practice improves bandwidth efficiency by limiting the number of data centers that can ask the origin for content, which reduces origin load and makes websites more cost-effective to operate. Additionally, Tiered Cache concentrates connections to origin servers so they come from a small number of data centers rather than the full set of network locations. This results in fewer open connections using server resources.
 */
export const tieredCachingPatchTieredCachingSetting = (
  variables: TieredCachingPatchTieredCachingSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    TieredCachingPatchTieredCachingSettingResponse,
    TieredCachingPatchTieredCachingSettingError,
    Schemas.CacheRulesPatch,
    {},
    {},
    TieredCachingPatchTieredCachingSettingPathParams
  >({ url: '/zones/{zoneId}/argo/tiered_caching', method: 'patch', ...variables, signal });

export type ZoneRatePlanListAvailablePlansPathParams = {
  zoneId: Schemas.BillSubsApiIdentifier;
};

export type ZoneRatePlanListAvailablePlansError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.BillSubsApiApiResponseCollection & {
    result?: Schemas.BillSubsApiAvailableRatePlan[];
  }) &
    Schemas.BillSubsApiApiResponseCommonFailure;
}>;

export type ZoneRatePlanListAvailablePlansResponse = Schemas.BillSubsApiApiResponseCollection & {
  result?: Schemas.BillSubsApiAvailableRatePlan[];
};

export type ZoneRatePlanListAvailablePlansVariables = {
  pathParams: ZoneRatePlanListAvailablePlansPathParams;
} & FetcherExtraProps;

/**
 * Lists available plans the zone can subscribe to.
 */
export const zoneRatePlanListAvailablePlans = (
  variables: ZoneRatePlanListAvailablePlansVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneRatePlanListAvailablePlansResponse,
    ZoneRatePlanListAvailablePlansError,
    undefined,
    {},
    {},
    ZoneRatePlanListAvailablePlansPathParams
  >({ url: '/zones/{zoneId}/available_plans', method: 'get', ...variables, signal });

export type ZoneRatePlanAvailablePlanDetailsPathParams = {
  planIdentifier: Schemas.BillSubsApiIdentifier;
  zoneId: Schemas.BillSubsApiIdentifier;
};

export type ZoneRatePlanAvailablePlanDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.BillSubsApiApiResponseSingle & {
    result?: Schemas.BillSubsApiAvailableRatePlan;
  }) &
    Schemas.BillSubsApiApiResponseCommonFailure;
}>;

export type ZoneRatePlanAvailablePlanDetailsResponse = Schemas.BillSubsApiApiResponseSingle & {
  result?: Schemas.BillSubsApiAvailableRatePlan;
};

export type ZoneRatePlanAvailablePlanDetailsVariables = {
  pathParams: ZoneRatePlanAvailablePlanDetailsPathParams;
} & FetcherExtraProps;

/**
 * Details of the available plan that the zone can subscribe to.
 */
export const zoneRatePlanAvailablePlanDetails = (
  variables: ZoneRatePlanAvailablePlanDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneRatePlanAvailablePlanDetailsResponse,
    ZoneRatePlanAvailablePlanDetailsError,
    undefined,
    {},
    {},
    ZoneRatePlanAvailablePlanDetailsPathParams
  >({ url: '/zones/{zoneId}/available_plans/{planIdentifier}', method: 'get', ...variables, signal });

export type ZoneRatePlanListAvailableRatePlansPathParams = {
  zoneId: Schemas.BillSubsApiIdentifier;
};

export type ZoneRatePlanListAvailableRatePlansError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.BillSubsApiPlanResponseCollection & Schemas.BillSubsApiApiResponseCommonFailure;
}>;

export type ZoneRatePlanListAvailableRatePlansVariables = {
  pathParams: ZoneRatePlanListAvailableRatePlansPathParams;
} & FetcherExtraProps;

/**
 * Lists all rate plans the zone can subscribe to.
 */
export const zoneRatePlanListAvailableRatePlans = (
  variables: ZoneRatePlanListAvailableRatePlansVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.BillSubsApiPlanResponseCollection,
    ZoneRatePlanListAvailableRatePlansError,
    undefined,
    {},
    {},
    ZoneRatePlanListAvailableRatePlansPathParams
  >({ url: '/zones/{zoneId}/available_rate_plans', method: 'get', ...variables, signal });

export type BotManagementForAZoneGetConfigPathParams = {
  zoneId: Schemas.BotManagementIdentifier;
};

export type BotManagementForAZoneGetConfigError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.BotManagementBotManagementResponseBody & Schemas.BotManagementApiResponseCommonFailure;
}>;

export type BotManagementForAZoneGetConfigVariables = {
  pathParams: BotManagementForAZoneGetConfigPathParams;
} & FetcherExtraProps;

/**
 * Retrieve a zone's Bot Management Config
 */
export const botManagementForAZoneGetConfig = (
  variables: BotManagementForAZoneGetConfigVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.BotManagementBotManagementResponseBody,
    BotManagementForAZoneGetConfigError,
    undefined,
    {},
    {},
    BotManagementForAZoneGetConfigPathParams
  >({ url: '/zones/{zoneId}/bot_management', method: 'get', ...variables, signal });

export type BotManagementForAZoneUpdateConfigPathParams = {
  zoneId: Schemas.BotManagementIdentifier;
};

export type BotManagementForAZoneUpdateConfigError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.BotManagementBotManagementResponseBody & Schemas.BotManagementApiResponseCommonFailure;
}>;

export type BotManagementForAZoneUpdateConfigVariables = {
  body?: Schemas.BotManagementConfigSingle;
  pathParams: BotManagementForAZoneUpdateConfigPathParams;
} & FetcherExtraProps;

/**
 * Updates the Bot Management configuration for a zone.
 *
 * This API is used to update:
 * - **Bot Fight Mode**
 * - **Super Bot Fight Mode**
 * - **Bot Management for Enterprise**
 *
 * See [Bot Plans](https://developers.cloudflare.com/bots/plans/) for more information on the different plans
 * \
 * If you recently upgraded or downgraded your plan, refer to the following examples to clean up old configurations.
 * Copy and paste the example body to remove old zone configurations based on your current plan.
 * #### Clean up configuration for Bot Fight Mode plan
 * ```json
 * {
 *   "sbfm_likely_automated": "allow",
 *   "sbfm_definitely_automated": "allow",
 *   "sbfm_verified_bots": "allow",
 *   "sbfm_static_resource_protection": false,
 *   "optimize_wordpress": false,
 *   "suppress_session_score": false
 * }
 * ```
 * #### Clean up configuration for SBFM Pro plan
 * ```json
 * {
 *   "sbfm_likely_automated": "allow",
 *   "fight_mode": false
 * }
 * ```
 * #### Clean up configuration for SBFM Biz plan
 * ```json
 * {
 *   "fight_mode": false
 * }
 * ```
 * #### Clean up configuration for BM Enterprise Subscription plan
 * It is strongly recommended that you ensure you have [custom rules](https://developers.cloudflare.com/waf/custom-rules/) in place to protect your zone before disabling the SBFM rules. Without these protections, your zone is vulnerable to attacks.
 * ```json
 * {
 *   "sbfm_likely_automated": "allow",
 *   "sbfm_definitely_automated": "allow",
 *   "sbfm_verified_bots": "allow",
 *   "sbfm_static_resource_protection": false,
 *   "optimize_wordpress": false,
 *   "fight_mode": false
 * }
 * ```
 */
export const botManagementForAZoneUpdateConfig = (
  variables: BotManagementForAZoneUpdateConfigVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.BotManagementBotManagementResponseBody,
    BotManagementForAZoneUpdateConfigError,
    Schemas.BotManagementConfigSingle,
    {},
    {},
    BotManagementForAZoneUpdateConfigPathParams
  >({ url: '/zones/{zoneId}/bot_management', method: 'put', ...variables, signal });

export type ZoneCacheSettingsGetCacheReserveSettingPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type ZoneCacheSettingsGetCacheReserveSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type ZoneCacheSettingsGetCacheReserveSettingResponse = Schemas.CacheRulesZoneCacheSettingsResponseSingle &
  Schemas.CacheRulesCacheReserveResponseValue;

export type ZoneCacheSettingsGetCacheReserveSettingVariables = {
  pathParams: ZoneCacheSettingsGetCacheReserveSettingPathParams;
} & FetcherExtraProps;

/**
 * Increase cache lifetimes by automatically storing all cacheable files into Cloudflare's persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve) for more information.
 */
export const zoneCacheSettingsGetCacheReserveSetting = (
  variables: ZoneCacheSettingsGetCacheReserveSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneCacheSettingsGetCacheReserveSettingResponse,
    ZoneCacheSettingsGetCacheReserveSettingError,
    undefined,
    {},
    {},
    ZoneCacheSettingsGetCacheReserveSettingPathParams
  >({ url: '/zones/{zoneId}/cache/cache_reserve', method: 'get', ...variables, signal });

export type ZoneCacheSettingsChangeCacheReserveSettingPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type ZoneCacheSettingsChangeCacheReserveSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type ZoneCacheSettingsChangeCacheReserveSettingResponse = Schemas.CacheRulesZoneCacheSettingsResponseSingle &
  Schemas.CacheRulesCacheReserveResponseValue;

export type ZoneCacheSettingsChangeCacheReserveSettingRequestBody = {
  value: Schemas.CacheRulesCacheReserveValue;
};

export type ZoneCacheSettingsChangeCacheReserveSettingVariables = {
  body: ZoneCacheSettingsChangeCacheReserveSettingRequestBody;
  pathParams: ZoneCacheSettingsChangeCacheReserveSettingPathParams;
} & FetcherExtraProps;

/**
 * Increase cache lifetimes by automatically storing all cacheable files into Cloudflare's persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve) for more information.
 */
export const zoneCacheSettingsChangeCacheReserveSetting = (
  variables: ZoneCacheSettingsChangeCacheReserveSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneCacheSettingsChangeCacheReserveSettingResponse,
    ZoneCacheSettingsChangeCacheReserveSettingError,
    ZoneCacheSettingsChangeCacheReserveSettingRequestBody,
    {},
    {},
    ZoneCacheSettingsChangeCacheReserveSettingPathParams
  >({ url: '/zones/{zoneId}/cache/cache_reserve', method: 'patch', ...variables, signal });

export type ZoneCacheSettingsGetCacheReserveClearPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type ZoneCacheSettingsGetCacheReserveClearError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type ZoneCacheSettingsGetCacheReserveClearResponse = Schemas.CacheRulesApiResponseCommon &
  Schemas.CacheRulesCacheReserveClearResponseValue;

export type ZoneCacheSettingsGetCacheReserveClearVariables = {
  pathParams: ZoneCacheSettingsGetCacheReserveClearPathParams;
} & FetcherExtraProps;

/**
 * You can use Cache Reserve Clear to clear your Cache Reserve, but you must first disable Cache Reserve. In most cases, this will be accomplished within 24 hours. You cannot re-enable Cache Reserve while this process is ongoing. Keep in mind that you cannot undo or cancel this operation.
 */
export const zoneCacheSettingsGetCacheReserveClear = (
  variables: ZoneCacheSettingsGetCacheReserveClearVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneCacheSettingsGetCacheReserveClearResponse,
    ZoneCacheSettingsGetCacheReserveClearError,
    undefined,
    {},
    {},
    ZoneCacheSettingsGetCacheReserveClearPathParams
  >({ url: '/zones/{zoneId}/cache/cache_reserve_clear', method: 'get', ...variables, signal });

export type ZoneCacheSettingsStartCacheReserveClearPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type ZoneCacheSettingsStartCacheReserveClearError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type ZoneCacheSettingsStartCacheReserveClearResponse = Schemas.CacheRulesApiResponseCommon &
  Schemas.CacheRulesCacheReserveClearResponseValue;

export type ZoneCacheSettingsStartCacheReserveClearVariables = {
  pathParams: ZoneCacheSettingsStartCacheReserveClearPathParams;
} & FetcherExtraProps;

/**
 * You can use Cache Reserve Clear to clear your Cache Reserve, but you must first disable Cache Reserve. In most cases, this will be accomplished within 24 hours. You cannot re-enable Cache Reserve while this process is ongoing. Keep in mind that you cannot undo or cancel this operation.
 */
export const zoneCacheSettingsStartCacheReserveClear = (
  variables: ZoneCacheSettingsStartCacheReserveClearVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneCacheSettingsStartCacheReserveClearResponse,
    ZoneCacheSettingsStartCacheReserveClearError,
    undefined,
    {},
    {},
    ZoneCacheSettingsStartCacheReserveClearPathParams
  >({ url: '/zones/{zoneId}/cache/cache_reserve_clear', method: 'post', ...variables, signal });

export type ZoneCacheSettingsGetOriginPostQuantumEncryptionSettingPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type ZoneCacheSettingsGetOriginPostQuantumEncryptionSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type ZoneCacheSettingsGetOriginPostQuantumEncryptionSettingResponse =
  Schemas.CacheRulesZoneCacheSettingsResponseSingle & Schemas.CacheRulesOriginPostQuantumEncryptionResponseValue;

export type ZoneCacheSettingsGetOriginPostQuantumEncryptionSettingVariables = {
  pathParams: ZoneCacheSettingsGetOriginPostQuantumEncryptionSettingPathParams;
} & FetcherExtraProps;

/**
 * Instructs Cloudflare to use Post-Quantum (PQ) key agreement algorithms when connecting to your origin. Preferred instructs Cloudflare to opportunistically send a Post-Quantum keyshare in the first message to the origin (for fastest connections when the origin supports and prefers PQ), supported means that PQ algorithms are advertised but only used when requested by the origin, and off means that PQ algorithms are not advertised
 */
export const zoneCacheSettingsGetOriginPostQuantumEncryptionSetting = (
  variables: ZoneCacheSettingsGetOriginPostQuantumEncryptionSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneCacheSettingsGetOriginPostQuantumEncryptionSettingResponse,
    ZoneCacheSettingsGetOriginPostQuantumEncryptionSettingError,
    undefined,
    {},
    {},
    ZoneCacheSettingsGetOriginPostQuantumEncryptionSettingPathParams
  >({ url: '/zones/{zoneId}/cache/origin_post_quantum_encryption', method: 'get', ...variables, signal });

export type ZoneCacheSettingsChangeOriginPostQuantumEncryptionSettingPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type ZoneCacheSettingsChangeOriginPostQuantumEncryptionSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type ZoneCacheSettingsChangeOriginPostQuantumEncryptionSettingResponse =
  Schemas.CacheRulesZoneCacheSettingsResponseSingle & Schemas.CacheRulesOriginPostQuantumEncryptionResponseValue;

export type ZoneCacheSettingsChangeOriginPostQuantumEncryptionSettingRequestBody = {
  value: Schemas.CacheRulesOriginPostQuantumEncryptionValue;
};

export type ZoneCacheSettingsChangeOriginPostQuantumEncryptionSettingVariables = {
  body: ZoneCacheSettingsChangeOriginPostQuantumEncryptionSettingRequestBody;
  pathParams: ZoneCacheSettingsChangeOriginPostQuantumEncryptionSettingPathParams;
} & FetcherExtraProps;

/**
 * Instructs Cloudflare to use Post-Quantum (PQ) key agreement algorithms when connecting to your origin. Preferred instructs Cloudflare to opportunistically send a Post-Quantum keyshare in the first message to the origin (for fastest connections when the origin supports and prefers PQ), supported means that PQ algorithms are advertised but only used when requested by the origin, and off means that PQ algorithms are not advertised
 */
export const zoneCacheSettingsChangeOriginPostQuantumEncryptionSetting = (
  variables: ZoneCacheSettingsChangeOriginPostQuantumEncryptionSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneCacheSettingsChangeOriginPostQuantumEncryptionSettingResponse,
    ZoneCacheSettingsChangeOriginPostQuantumEncryptionSettingError,
    ZoneCacheSettingsChangeOriginPostQuantumEncryptionSettingRequestBody,
    {},
    {},
    ZoneCacheSettingsChangeOriginPostQuantumEncryptionSettingPathParams
  >({ url: '/zones/{zoneId}/cache/origin_post_quantum_encryption', method: 'put', ...variables, signal });

export type ZoneCacheSettingsGetRegionalTieredCacheSettingPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type ZoneCacheSettingsGetRegionalTieredCacheSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type ZoneCacheSettingsGetRegionalTieredCacheSettingResponse = Schemas.CacheRulesZoneCacheSettingsResponseSingle &
  Schemas.CacheRulesRegionalTieredCacheResponseValue;

export type ZoneCacheSettingsGetRegionalTieredCacheSettingVariables = {
  pathParams: ZoneCacheSettingsGetRegionalTieredCacheSettingPathParams;
} & FetcherExtraProps;

/**
 * Instructs Cloudflare to check a regional hub data center on the way to your upper tier. This can help improve performance for smart and custom tiered cache topologies.
 */
export const zoneCacheSettingsGetRegionalTieredCacheSetting = (
  variables: ZoneCacheSettingsGetRegionalTieredCacheSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneCacheSettingsGetRegionalTieredCacheSettingResponse,
    ZoneCacheSettingsGetRegionalTieredCacheSettingError,
    undefined,
    {},
    {},
    ZoneCacheSettingsGetRegionalTieredCacheSettingPathParams
  >({ url: '/zones/{zoneId}/cache/regional_tiered_cache', method: 'get', ...variables, signal });

export type ZoneCacheSettingsChangeRegionalTieredCacheSettingPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type ZoneCacheSettingsChangeRegionalTieredCacheSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type ZoneCacheSettingsChangeRegionalTieredCacheSettingResponse =
  Schemas.CacheRulesZoneCacheSettingsResponseSingle & Schemas.CacheRulesRegionalTieredCacheResponseValue;

export type ZoneCacheSettingsChangeRegionalTieredCacheSettingRequestBody = {
  value: Schemas.CacheRulesRegionalTieredCacheValue;
};

export type ZoneCacheSettingsChangeRegionalTieredCacheSettingVariables = {
  body: ZoneCacheSettingsChangeRegionalTieredCacheSettingRequestBody;
  pathParams: ZoneCacheSettingsChangeRegionalTieredCacheSettingPathParams;
} & FetcherExtraProps;

/**
 * Instructs Cloudflare to check a regional hub data center on the way to your upper tier. This can help improve performance for smart and custom tiered cache topologies.
 */
export const zoneCacheSettingsChangeRegionalTieredCacheSetting = (
  variables: ZoneCacheSettingsChangeRegionalTieredCacheSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneCacheSettingsChangeRegionalTieredCacheSettingResponse,
    ZoneCacheSettingsChangeRegionalTieredCacheSettingError,
    ZoneCacheSettingsChangeRegionalTieredCacheSettingRequestBody,
    {},
    {},
    ZoneCacheSettingsChangeRegionalTieredCacheSettingPathParams
  >({ url: '/zones/{zoneId}/cache/regional_tiered_cache', method: 'patch', ...variables, signal });

export type SmartTieredCacheDeleteSmartTieredCacheSettingPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type SmartTieredCacheDeleteSmartTieredCacheSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type SmartTieredCacheDeleteSmartTieredCacheSettingResponse =
  Schemas.CacheRulesZoneCacheSettingsDeleteResponseSingle & {
    result?: Schemas.CacheRulesSmartTieredCache;
  };

export type SmartTieredCacheDeleteSmartTieredCacheSettingVariables = {
  pathParams: SmartTieredCacheDeleteSmartTieredCacheSettingPathParams;
} & FetcherExtraProps;

/**
 * Smart Tiered Cache dynamically selects the single closest upper tier for each of your website’s origins with no configuration required, using our in-house performance and routing data. Cloudflare collects latency data for each request to an origin, and uses the latency data to determine how well any upper-tier data center is connected with an origin. As a result, Cloudflare can select the data center with the lowest latency to be the upper-tier for an origin.
 */
export const smartTieredCacheDeleteSmartTieredCacheSetting = (
  variables: SmartTieredCacheDeleteSmartTieredCacheSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    SmartTieredCacheDeleteSmartTieredCacheSettingResponse,
    SmartTieredCacheDeleteSmartTieredCacheSettingError,
    undefined,
    {},
    {},
    SmartTieredCacheDeleteSmartTieredCacheSettingPathParams
  >({ url: '/zones/{zoneId}/cache/tiered_cache_smart_topology_enable', method: 'delete', ...variables, signal });

export type SmartTieredCacheGetSmartTieredCacheSettingPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type SmartTieredCacheGetSmartTieredCacheSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type SmartTieredCacheGetSmartTieredCacheSettingResponse = Schemas.CacheRulesZoneCacheSettingsResponseSingle &
  Schemas.CacheRulesSmartTieredCacheResponseValue;

export type SmartTieredCacheGetSmartTieredCacheSettingVariables = {
  pathParams: SmartTieredCacheGetSmartTieredCacheSettingPathParams;
} & FetcherExtraProps;

/**
 * Smart Tiered Cache dynamically selects the single closest upper tier for each of your website’s origins with no configuration required, using our in-house performance and routing data. Cloudflare collects latency data for each request to an origin, and uses the latency data to determine how well any upper-tier data center is connected with an origin. As a result, Cloudflare can select the data center with the lowest latency to be the upper-tier for an origin.
 */
export const smartTieredCacheGetSmartTieredCacheSetting = (
  variables: SmartTieredCacheGetSmartTieredCacheSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    SmartTieredCacheGetSmartTieredCacheSettingResponse,
    SmartTieredCacheGetSmartTieredCacheSettingError,
    undefined,
    {},
    {},
    SmartTieredCacheGetSmartTieredCacheSettingPathParams
  >({ url: '/zones/{zoneId}/cache/tiered_cache_smart_topology_enable', method: 'get', ...variables, signal });

export type SmartTieredCachePatchSmartTieredCacheSettingPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type SmartTieredCachePatchSmartTieredCacheSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type SmartTieredCachePatchSmartTieredCacheSettingResponse = Schemas.CacheRulesZoneCacheSettingsResponseSingle &
  Schemas.CacheRulesSmartTieredCacheResponseValue;

export type SmartTieredCachePatchSmartTieredCacheSettingVariables = {
  body: Schemas.CacheRulesSmartTieredCachePatch;
  pathParams: SmartTieredCachePatchSmartTieredCacheSettingPathParams;
} & FetcherExtraProps;

/**
 * Smart Tiered Cache dynamically selects the single closest upper tier for each of your website’s origins with no configuration required, using our in-house performance and routing data. Cloudflare collects latency data for each request to an origin, and uses the latency data to determine how well any upper-tier data center is connected with an origin. As a result, Cloudflare can select the data center with the lowest latency to be the upper-tier for an origin.
 */
export const smartTieredCachePatchSmartTieredCacheSetting = (
  variables: SmartTieredCachePatchSmartTieredCacheSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    SmartTieredCachePatchSmartTieredCacheSettingResponse,
    SmartTieredCachePatchSmartTieredCacheSettingError,
    Schemas.CacheRulesSmartTieredCachePatch,
    {},
    {},
    SmartTieredCachePatchSmartTieredCacheSettingPathParams
  >({ url: '/zones/{zoneId}/cache/tiered_cache_smart_topology_enable', method: 'patch', ...variables, signal });

export type ZoneCacheSettingsDeleteVariantsSettingPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type ZoneCacheSettingsDeleteVariantsSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type ZoneCacheSettingsDeleteVariantsSettingResponse = Schemas.CacheRulesZoneCacheSettingsDeleteResponseSingle & {
  result?: Schemas.CacheRulesVariants;
};

export type ZoneCacheSettingsDeleteVariantsSettingVariables = {
  pathParams: ZoneCacheSettingsDeleteVariantsSettingPathParams;
} & FetcherExtraProps;

/**
 * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
 */
export const zoneCacheSettingsDeleteVariantsSetting = (
  variables: ZoneCacheSettingsDeleteVariantsSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneCacheSettingsDeleteVariantsSettingResponse,
    ZoneCacheSettingsDeleteVariantsSettingError,
    undefined,
    {},
    {},
    ZoneCacheSettingsDeleteVariantsSettingPathParams
  >({ url: '/zones/{zoneId}/cache/variants', method: 'delete', ...variables, signal });

export type ZoneCacheSettingsGetVariantsSettingPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type ZoneCacheSettingsGetVariantsSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type ZoneCacheSettingsGetVariantsSettingResponse = Schemas.CacheRulesZoneCacheSettingsResponseSingle &
  Schemas.CacheRulesVariantsResponseValue;

export type ZoneCacheSettingsGetVariantsSettingVariables = {
  pathParams: ZoneCacheSettingsGetVariantsSettingPathParams;
} & FetcherExtraProps;

/**
 * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
 */
export const zoneCacheSettingsGetVariantsSetting = (
  variables: ZoneCacheSettingsGetVariantsSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneCacheSettingsGetVariantsSettingResponse,
    ZoneCacheSettingsGetVariantsSettingError,
    undefined,
    {},
    {},
    ZoneCacheSettingsGetVariantsSettingPathParams
  >({ url: '/zones/{zoneId}/cache/variants', method: 'get', ...variables, signal });

export type ZoneCacheSettingsChangeVariantsSettingPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type ZoneCacheSettingsChangeVariantsSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type ZoneCacheSettingsChangeVariantsSettingResponse = Schemas.CacheRulesZoneCacheSettingsResponseSingle &
  Schemas.CacheRulesVariantsResponseValue;

export type ZoneCacheSettingsChangeVariantsSettingRequestBody = {
  value: Schemas.CacheRulesVariantsValue;
};

export type ZoneCacheSettingsChangeVariantsSettingVariables = {
  body: ZoneCacheSettingsChangeVariantsSettingRequestBody;
  pathParams: ZoneCacheSettingsChangeVariantsSettingPathParams;
} & FetcherExtraProps;

/**
 * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
 */
export const zoneCacheSettingsChangeVariantsSetting = (
  variables: ZoneCacheSettingsChangeVariantsSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneCacheSettingsChangeVariantsSettingResponse,
    ZoneCacheSettingsChangeVariantsSettingError,
    ZoneCacheSettingsChangeVariantsSettingRequestBody,
    {},
    {},
    ZoneCacheSettingsChangeVariantsSettingPathParams
  >({ url: '/zones/{zoneId}/cache/variants', method: 'patch', ...variables, signal });

export type ClientCertificateForAZoneListHostnameAssociationsPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type ClientCertificateForAZoneListHostnameAssociationsQueryParams = {
  /**
   * @example b2134436-2555-4acf-be5b-26c48136575e
   * @maxLength 36
   * @minLength 36
   */
  mtls_certificate_id?: string;
};

export type ClientCertificateForAZoneListHostnameAssociationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type ClientCertificateForAZoneListHostnameAssociationsVariables = {
  pathParams: ClientCertificateForAZoneListHostnameAssociationsPathParams;
  queryParams?: ClientCertificateForAZoneListHostnameAssociationsQueryParams;
} & FetcherExtraProps;

/**
 * List Hostname Associations
 */
export const clientCertificateForAZoneListHostnameAssociations = (
  variables: ClientCertificateForAZoneListHostnameAssociationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesHostnameAssociationsResponse,
    ClientCertificateForAZoneListHostnameAssociationsError,
    undefined,
    {},
    ClientCertificateForAZoneListHostnameAssociationsQueryParams,
    ClientCertificateForAZoneListHostnameAssociationsPathParams
  >({ url: '/zones/{zoneId}/certificate_authorities/hostname_associations', method: 'get', ...variables, signal });

export type ClientCertificateForAZonePutHostnameAssociationsPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type ClientCertificateForAZonePutHostnameAssociationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type ClientCertificateForAZonePutHostnameAssociationsVariables = {
  body?: Schemas.TlsCertificatesAndHostnamesHostnameAssociation;
  pathParams: ClientCertificateForAZonePutHostnameAssociationsPathParams;
} & FetcherExtraProps;

/**
 * Replace Hostname Associations
 */
export const clientCertificateForAZonePutHostnameAssociations = (
  variables: ClientCertificateForAZonePutHostnameAssociationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesHostnameAssociationsResponse,
    ClientCertificateForAZonePutHostnameAssociationsError,
    Schemas.TlsCertificatesAndHostnamesHostnameAssociation,
    {},
    {},
    ClientCertificateForAZonePutHostnameAssociationsPathParams
  >({ url: '/zones/{zoneId}/certificate_authorities/hostname_associations', method: 'put', ...variables, signal });

export type ClientCertificateForAZoneListClientCertificatesPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type ClientCertificateForAZoneListClientCertificatesQueryParams = {
  /**
   * @example all
   */
  status?: 'all' | 'active' | 'pending_reactivation' | 'pending_revocation' | 'revoked';
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example 10
   */
  limit?: number;
  /**
   * @example 10
   */
  offset?: number;
};

export type ClientCertificateForAZoneListClientCertificatesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type ClientCertificateForAZoneListClientCertificatesVariables = {
  pathParams: ClientCertificateForAZoneListClientCertificatesPathParams;
  queryParams?: ClientCertificateForAZoneListClientCertificatesQueryParams;
} & FetcherExtraProps;

/**
 * List all of your Zone's API Shield mTLS Client Certificates by Status and/or using Pagination
 */
export const clientCertificateForAZoneListClientCertificates = (
  variables: ClientCertificateForAZoneListClientCertificatesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesClientCertificateResponseCollection,
    ClientCertificateForAZoneListClientCertificatesError,
    undefined,
    {},
    ClientCertificateForAZoneListClientCertificatesQueryParams,
    ClientCertificateForAZoneListClientCertificatesPathParams
  >({ url: '/zones/{zoneId}/client_certificates', method: 'get', ...variables, signal });

export type ClientCertificateForAZoneCreateClientCertificatePathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type ClientCertificateForAZoneCreateClientCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesClientCertificateResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type ClientCertificateForAZoneCreateClientCertificateRequestBody = {
  csr: Schemas.TlsCertificatesAndHostnamesSchemasCsr;
  validity_days: Schemas.TlsCertificatesAndHostnamesSchemasValidityDays;
};

export type ClientCertificateForAZoneCreateClientCertificateVariables = {
  body: ClientCertificateForAZoneCreateClientCertificateRequestBody;
  pathParams: ClientCertificateForAZoneCreateClientCertificatePathParams;
} & FetcherExtraProps;

/**
 * Create a new API Shield mTLS Client Certificate
 */
export const clientCertificateForAZoneCreateClientCertificate = (
  variables: ClientCertificateForAZoneCreateClientCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesClientCertificateResponseSingle,
    ClientCertificateForAZoneCreateClientCertificateError,
    ClientCertificateForAZoneCreateClientCertificateRequestBody,
    {},
    {},
    ClientCertificateForAZoneCreateClientCertificatePathParams
  >({ url: '/zones/{zoneId}/client_certificates', method: 'post', ...variables, signal });

export type ClientCertificateForAZoneDeleteClientCertificatePathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  clientCertificateId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type ClientCertificateForAZoneDeleteClientCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type ClientCertificateForAZoneDeleteClientCertificateVariables = {
  pathParams: ClientCertificateForAZoneDeleteClientCertificatePathParams;
} & FetcherExtraProps;

/**
 * Set a API Shield mTLS Client Certificate to pending_revocation status for processing to revoked status.
 */
export const clientCertificateForAZoneDeleteClientCertificate = (
  variables: ClientCertificateForAZoneDeleteClientCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesClientCertificateResponseSingle,
    ClientCertificateForAZoneDeleteClientCertificateError,
    undefined,
    {},
    {},
    ClientCertificateForAZoneDeleteClientCertificatePathParams
  >({ url: '/zones/{zoneId}/client_certificates/{clientCertificateId}', method: 'delete', ...variables, signal });

export type ClientCertificateForAZoneClientCertificateDetailsPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  clientCertificateId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type ClientCertificateForAZoneClientCertificateDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type ClientCertificateForAZoneClientCertificateDetailsVariables = {
  pathParams: ClientCertificateForAZoneClientCertificateDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get Details for a single mTLS API Shield Client Certificate
 */
export const clientCertificateForAZoneClientCertificateDetails = (
  variables: ClientCertificateForAZoneClientCertificateDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesClientCertificateResponseSingle,
    ClientCertificateForAZoneClientCertificateDetailsError,
    undefined,
    {},
    {},
    ClientCertificateForAZoneClientCertificateDetailsPathParams
  >({ url: '/zones/{zoneId}/client_certificates/{clientCertificateId}', method: 'get', ...variables, signal });

export type ClientCertificateForAZoneEditClientCertificatePathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  clientCertificateId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type ClientCertificateForAZoneEditClientCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type ClientCertificateForAZoneEditClientCertificateVariables = {
  pathParams: ClientCertificateForAZoneEditClientCertificatePathParams;
} & FetcherExtraProps;

/**
 * If a API Shield mTLS Client Certificate is in a pending_revocation state, you may reactivate it with this endpoint.
 */
export const clientCertificateForAZoneEditClientCertificate = (
  variables: ClientCertificateForAZoneEditClientCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesClientCertificateResponseSingle,
    ClientCertificateForAZoneEditClientCertificateError,
    undefined,
    {},
    {},
    ClientCertificateForAZoneEditClientCertificatePathParams
  >({ url: '/zones/{zoneId}/client_certificates/{clientCertificateId}', method: 'patch', ...variables, signal });

export type ZoneCloudConnectorRulesPathParams = {
  zoneId: Schemas.CloudConnectorIdentifier;
};

export type ZoneCloudConnectorRulesError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.CloudConnectorApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.CloudConnectorApiResponseCommonFailure;
    }
>;

export type ZoneCloudConnectorRulesResponse = Schemas.CloudConnectorApiResponseCommon & {
  result?: Schemas.CloudConnectorRules;
};

export type ZoneCloudConnectorRulesVariables = {
  pathParams: ZoneCloudConnectorRulesPathParams;
} & FetcherExtraProps;

export const zoneCloudConnectorRules = (variables: ZoneCloudConnectorRulesVariables, signal?: AbortSignal) =>
  fetch<
    ZoneCloudConnectorRulesResponse,
    ZoneCloudConnectorRulesError,
    undefined,
    {},
    {},
    ZoneCloudConnectorRulesPathParams
  >({ url: '/zones/{zoneId}/cloud_connector/rules', method: 'get', ...variables, signal });

export type ZoneCloudConenctorRulesPutPathParams = {
  zoneId: Schemas.CloudConnectorIdentifier;
};

export type ZoneCloudConenctorRulesPutError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.CloudConnectorApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.CloudConnectorApiResponseCommonFailure;
    }
>;

export type ZoneCloudConenctorRulesPutResponse = Schemas.CloudConnectorApiResponseCommon & {
  result?: Schemas.CloudConnectorRules;
};

export type ZoneCloudConenctorRulesPutVariables = {
  body?: Schemas.CloudConnectorRules;
  pathParams: ZoneCloudConenctorRulesPutPathParams;
} & FetcherExtraProps;

export const zoneCloudConenctorRulesPut = (variables: ZoneCloudConenctorRulesPutVariables, signal?: AbortSignal) =>
  fetch<
    ZoneCloudConenctorRulesPutResponse,
    ZoneCloudConenctorRulesPutError,
    Schemas.CloudConnectorRules,
    {},
    {},
    ZoneCloudConenctorRulesPutPathParams
  >({ url: '/zones/{zoneId}/cloud_connector/rules', method: 'put', ...variables, signal });

export type WafContentScanningDisablePathParams = {
  zoneId: Schemas.WafProductApiBundleIdentifier;
};

export type WafContentScanningDisableError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WafProductApiBundleSchemasApiResponseCommonFailure;
}>;

export type WafContentScanningDisableVariables = {
  pathParams: WafContentScanningDisablePathParams;
} & FetcherExtraProps;

/**
 * Disable Content Scanning
 */
export const wafContentScanningDisable = (variables: WafContentScanningDisableVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WafProductApiBundleSchemasApiResponseCommon,
    WafContentScanningDisableError,
    undefined,
    {},
    {},
    WafContentScanningDisablePathParams
  >({ url: '/zones/{zoneId}/content-upload-scan/disable', method: 'post', ...variables, signal });

export type WafContentScanningEnablePathParams = {
  zoneId: Schemas.WafProductApiBundleIdentifier;
};

export type WafContentScanningEnableError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WafProductApiBundleSchemasApiResponseCommonFailure;
}>;

export type WafContentScanningEnableVariables = {
  pathParams: WafContentScanningEnablePathParams;
} & FetcherExtraProps;

/**
 * Enable Content Scanning
 */
export const wafContentScanningEnable = (variables: WafContentScanningEnableVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WafProductApiBundleSchemasApiResponseCommon,
    WafContentScanningEnableError,
    undefined,
    {},
    {},
    WafContentScanningEnablePathParams
  >({ url: '/zones/{zoneId}/content-upload-scan/enable', method: 'post', ...variables, signal });

export type WafContentScanningListCustomScanExpressionsPathParams = {
  zoneId: Schemas.WafProductApiBundleIdentifier;
};

export type WafContentScanningListCustomScanExpressionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WafProductApiBundleResponseCustomScanCollection &
    Schemas.WafProductApiBundleSchemasApiResponseCommonFailure;
}>;

export type WafContentScanningListCustomScanExpressionsVariables = {
  pathParams: WafContentScanningListCustomScanExpressionsPathParams;
} & FetcherExtraProps;

/**
 * Get a list of existing custom scan expressions for Content Scanning
 */
export const wafContentScanningListCustomScanExpressions = (
  variables: WafContentScanningListCustomScanExpressionsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WafProductApiBundleResponseCustomScanCollection,
    WafContentScanningListCustomScanExpressionsError,
    undefined,
    {},
    {},
    WafContentScanningListCustomScanExpressionsPathParams
  >({ url: '/zones/{zoneId}/content-upload-scan/payloads', method: 'get', ...variables, signal });

export type WafContentScanningAddCustomScanExpressionsPathParams = {
  zoneId: Schemas.WafProductApiBundleIdentifier;
};

export type WafContentScanningAddCustomScanExpressionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WafProductApiBundleResponseCustomScanCollection &
    Schemas.WafProductApiBundleSchemasApiResponseCommonFailure;
}>;

export type WafContentScanningAddCustomScanExpressionsRequestBody = {
  payload: Schemas.WafProductApiBundleCustomScanPayload;
}[];

export type WafContentScanningAddCustomScanExpressionsVariables = {
  body?: WafContentScanningAddCustomScanExpressionsRequestBody;
  pathParams: WafContentScanningAddCustomScanExpressionsPathParams;
} & FetcherExtraProps;

/**
 * Add custom scan expressions for Content Scanning
 */
export const wafContentScanningAddCustomScanExpressions = (
  variables: WafContentScanningAddCustomScanExpressionsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WafProductApiBundleResponseCustomScanCollection,
    WafContentScanningAddCustomScanExpressionsError,
    WafContentScanningAddCustomScanExpressionsRequestBody,
    {},
    {},
    WafContentScanningAddCustomScanExpressionsPathParams
  >({ url: '/zones/{zoneId}/content-upload-scan/payloads', method: 'post', ...variables, signal });

export type WafContentScanningDeleteCustomScanExpressionsPathParams = {
  zoneId: Schemas.WafProductApiBundleIdentifier;
  expressionId: Schemas.WafProductApiBundleCustomScanId;
};

export type WafContentScanningDeleteCustomScanExpressionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WafProductApiBundleResponseCustomScanCollection &
    Schemas.WafProductApiBundleSchemasApiResponseCommonFailure;
}>;

export type WafContentScanningDeleteCustomScanExpressionsVariables = {
  pathParams: WafContentScanningDeleteCustomScanExpressionsPathParams;
} & FetcherExtraProps;

/**
 * Delete a Content Scan Custom Expression
 */
export const wafContentScanningDeleteCustomScanExpressions = (
  variables: WafContentScanningDeleteCustomScanExpressionsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WafProductApiBundleResponseCustomScanCollection,
    WafContentScanningDeleteCustomScanExpressionsError,
    undefined,
    {},
    {},
    WafContentScanningDeleteCustomScanExpressionsPathParams
  >({ url: '/zones/{zoneId}/content-upload-scan/payloads/{expressionId}', method: 'delete', ...variables, signal });

export type WafContentScanningGetStatusPathParams = {
  zoneId: Schemas.WafProductApiBundleIdentifier;
};

export type WafContentScanningGetStatusError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WafProductApiBundleSchemasApiResponseCommonFailure;
}>;

export type WafContentScanningGetStatusVariables = {
  pathParams: WafContentScanningGetStatusPathParams;
} & FetcherExtraProps;

/**
 * Retrieve the current status of Content Scanning
 */
export const wafContentScanningGetStatus = (variables: WafContentScanningGetStatusVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WafProductApiBundleSchemasResponseStatus,
    WafContentScanningGetStatusError,
    undefined,
    {},
    {},
    WafContentScanningGetStatusPathParams
  >({ url: '/zones/{zoneId}/content-upload-scan/settings', method: 'get', ...variables, signal });

export type CustomSslForAZoneListSslConfigurationsPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CustomSslForAZoneListSslConfigurationsQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * @default all
   */
  match?: 'any' | 'all';
  /**
   * @example active
   */
  status?: 'active' | 'expired' | 'deleted' | 'pending' | 'initializing';
};

export type CustomSslForAZoneListSslConfigurationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesCertificateResponseCollection &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CustomSslForAZoneListSslConfigurationsVariables = {
  pathParams: CustomSslForAZoneListSslConfigurationsPathParams;
  queryParams?: CustomSslForAZoneListSslConfigurationsQueryParams;
} & FetcherExtraProps;

/**
 * List, search, and filter all of your custom SSL certificates. The higher priority will break ties across overlapping 'legacy_custom' certificates, but 'legacy_custom' certificates will always supercede 'sni_custom' certificates.
 */
export const customSslForAZoneListSslConfigurations = (
  variables: CustomSslForAZoneListSslConfigurationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesCertificateResponseCollection,
    CustomSslForAZoneListSslConfigurationsError,
    undefined,
    {},
    CustomSslForAZoneListSslConfigurationsQueryParams,
    CustomSslForAZoneListSslConfigurationsPathParams
  >({ url: '/zones/{zoneId}/custom_certificates', method: 'get', ...variables, signal });

export type CustomSslForAZoneCreateSslConfigurationPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CustomSslForAZoneCreateSslConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesCertificateResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CustomSslForAZoneCreateSslConfigurationRequestBody = {
  bundle_method?: Schemas.TlsCertificatesAndHostnamesBundleMethod;
  certificate: Schemas.TlsCertificatesAndHostnamesCertificate;
  geo_restrictions?: Schemas.TlsCertificatesAndHostnamesGeoRestrictions;
  policy?: Schemas.TlsCertificatesAndHostnamesPolicy;
  private_key: Schemas.TlsCertificatesAndHostnamesPrivateKey;
  type?: Schemas.TlsCertificatesAndHostnamesType;
};

export type CustomSslForAZoneCreateSslConfigurationVariables = {
  body: CustomSslForAZoneCreateSslConfigurationRequestBody;
  pathParams: CustomSslForAZoneCreateSslConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Upload a new SSL certificate for a zone.
 */
export const customSslForAZoneCreateSslConfiguration = (
  variables: CustomSslForAZoneCreateSslConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesCertificateResponseSingle,
    CustomSslForAZoneCreateSslConfigurationError,
    CustomSslForAZoneCreateSslConfigurationRequestBody,
    {},
    {},
    CustomSslForAZoneCreateSslConfigurationPathParams
  >({ url: '/zones/{zoneId}/custom_certificates', method: 'post', ...variables, signal });

export type CustomSslForAZoneRePrioritizeSslCertificatesPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CustomSslForAZoneRePrioritizeSslCertificatesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesCertificateResponseCollection &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CustomSslForAZoneRePrioritizeSslCertificatesRequestBody = {
  /**
   * Array of ordered certificates.
   *
   * @example {"id":"5a7805061c76ada191ed06f989cc3dac","priority":2}
   * @example {"id":"9a7806061c88ada191ed06f989cc3dac","priority":1}
   */
  certificates: {
    id?: Schemas.TlsCertificatesAndHostnamesIdentifier;
    priority?: Schemas.TlsCertificatesAndHostnamesPriority;
  }[];
};

export type CustomSslForAZoneRePrioritizeSslCertificatesVariables = {
  body: CustomSslForAZoneRePrioritizeSslCertificatesRequestBody;
  pathParams: CustomSslForAZoneRePrioritizeSslCertificatesPathParams;
} & FetcherExtraProps;

/**
 * If a zone has multiple SSL certificates, you can set the order in which they should be used during a request. The higher priority will break ties across overlapping 'legacy_custom' certificates.
 */
export const customSslForAZoneRePrioritizeSslCertificates = (
  variables: CustomSslForAZoneRePrioritizeSslCertificatesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesCertificateResponseCollection,
    CustomSslForAZoneRePrioritizeSslCertificatesError,
    CustomSslForAZoneRePrioritizeSslCertificatesRequestBody,
    {},
    {},
    CustomSslForAZoneRePrioritizeSslCertificatesPathParams
  >({ url: '/zones/{zoneId}/custom_certificates/prioritize', method: 'put', ...variables, signal });

export type CustomSslForAZoneDeleteSslConfigurationPathParams = {
  customCertificateId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CustomSslForAZoneDeleteSslConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesCertificateResponseIdOnly &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CustomSslForAZoneDeleteSslConfigurationVariables = {
  pathParams: CustomSslForAZoneDeleteSslConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Remove a SSL certificate from a zone.
 */
export const customSslForAZoneDeleteSslConfiguration = (
  variables: CustomSslForAZoneDeleteSslConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesCertificateResponseIdOnly,
    CustomSslForAZoneDeleteSslConfigurationError,
    undefined,
    {},
    {},
    CustomSslForAZoneDeleteSslConfigurationPathParams
  >({ url: '/zones/{zoneId}/custom_certificates/{customCertificateId}', method: 'delete', ...variables, signal });

export type CustomSslForAZoneSslConfigurationDetailsPathParams = {
  customCertificateId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CustomSslForAZoneSslConfigurationDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesCertificateResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CustomSslForAZoneSslConfigurationDetailsVariables = {
  pathParams: CustomSslForAZoneSslConfigurationDetailsPathParams;
} & FetcherExtraProps;

export const customSslForAZoneSslConfigurationDetails = (
  variables: CustomSslForAZoneSslConfigurationDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesCertificateResponseSingle,
    CustomSslForAZoneSslConfigurationDetailsError,
    undefined,
    {},
    {},
    CustomSslForAZoneSslConfigurationDetailsPathParams
  >({ url: '/zones/{zoneId}/custom_certificates/{customCertificateId}', method: 'get', ...variables, signal });

export type CustomSslForAZoneEditSslConfigurationPathParams = {
  customCertificateId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CustomSslForAZoneEditSslConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesCertificateResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CustomSslForAZoneEditSslConfigurationRequestBody = {
  bundle_method?: Schemas.TlsCertificatesAndHostnamesBundleMethod;
  certificate?: Schemas.TlsCertificatesAndHostnamesCertificate;
  geo_restrictions?: Schemas.TlsCertificatesAndHostnamesGeoRestrictions;
  policy?: Schemas.TlsCertificatesAndHostnamesPolicy;
  private_key?: Schemas.TlsCertificatesAndHostnamesPrivateKey;
};

export type CustomSslForAZoneEditSslConfigurationVariables = {
  body?: CustomSslForAZoneEditSslConfigurationRequestBody;
  pathParams: CustomSslForAZoneEditSslConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Upload a new private key and/or PEM/CRT for the SSL certificate. Note: PATCHing a configuration for sni_custom certificates will result in a new resource id being returned, and the previous one being deleted.
 */
export const customSslForAZoneEditSslConfiguration = (
  variables: CustomSslForAZoneEditSslConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesCertificateResponseSingle,
    CustomSslForAZoneEditSslConfigurationError,
    CustomSslForAZoneEditSslConfigurationRequestBody,
    {},
    {},
    CustomSslForAZoneEditSslConfigurationPathParams
  >({ url: '/zones/{zoneId}/custom_certificates/{customCertificateId}', method: 'patch', ...variables, signal });

export type CustomHostnameForAZoneListCustomHostnamesPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CustomHostnameForAZoneListCustomHostnamesQueryParams = {
  /**
   * @example app.example.com
   * @maxLength 255
   */
  hostname?: string;
  /**
   * @example 0d89c70d-ad9f-4843-b99f-6cc0252067e9
   * @maxLength 36
   * @minLength 36
   */
  id?: string;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * @default ssl
   * @example ssl
   */
  order?: 'ssl' | 'ssl_status';
  /**
   * @example desc
   */
  direction?: 'asc' | 'desc';
  /**
   * @default 0
   */
  ssl?: 0 | 1;
};

export type CustomHostnameForAZoneListCustomHostnamesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesCustomHostnameResponseCollection &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CustomHostnameForAZoneListCustomHostnamesVariables = {
  pathParams: CustomHostnameForAZoneListCustomHostnamesPathParams;
  queryParams?: CustomHostnameForAZoneListCustomHostnamesQueryParams;
} & FetcherExtraProps;

/**
 * List, search, sort, and filter all of your custom hostnames.
 */
export const customHostnameForAZoneListCustomHostnames = (
  variables: CustomHostnameForAZoneListCustomHostnamesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesCustomHostnameResponseCollection,
    CustomHostnameForAZoneListCustomHostnamesError,
    undefined,
    {},
    CustomHostnameForAZoneListCustomHostnamesQueryParams,
    CustomHostnameForAZoneListCustomHostnamesPathParams
  >({ url: '/zones/{zoneId}/custom_hostnames', method: 'get', ...variables, signal });

export type CustomHostnameForAZoneCreateCustomHostnamePathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CustomHostnameForAZoneCreateCustomHostnameError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesCustomHostnameResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CustomHostnameForAZoneCreateCustomHostnameRequestBody = {
  custom_metadata?: Schemas.TlsCertificatesAndHostnamesCustomMetadata;
  hostname: Schemas.TlsCertificatesAndHostnamesHostnamePost;
  ssl: Schemas.TlsCertificatesAndHostnamesSslpost;
};

export type CustomHostnameForAZoneCreateCustomHostnameVariables = {
  body: CustomHostnameForAZoneCreateCustomHostnameRequestBody;
  pathParams: CustomHostnameForAZoneCreateCustomHostnamePathParams;
} & FetcherExtraProps;

/**
 * Add a new custom hostname and request that an SSL certificate be issued for it. One of three validation methods—http, txt, email—should be used, with 'http' recommended if the CNAME is already in place (or will be soon). Specifying 'email' will send an email to the WHOIS contacts on file for the base domain plus hostmaster, postmaster, webmaster, admin, administrator. If http is used and the domain is not already pointing to the Managed CNAME host, the PATCH method must be used once it is (to complete validation).
 */
export const customHostnameForAZoneCreateCustomHostname = (
  variables: CustomHostnameForAZoneCreateCustomHostnameVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesCustomHostnameResponseSingle,
    CustomHostnameForAZoneCreateCustomHostnameError,
    CustomHostnameForAZoneCreateCustomHostnameRequestBody,
    {},
    {},
    CustomHostnameForAZoneCreateCustomHostnamePathParams
  >({ url: '/zones/{zoneId}/custom_hostnames', method: 'post', ...variables, signal });

export type CustomHostnameFallbackOriginForAZoneDeleteFallbackOriginForCustomHostnamesPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CustomHostnameFallbackOriginForAZoneDeleteFallbackOriginForCustomHostnamesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesFallbackOriginResponse &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CustomHostnameFallbackOriginForAZoneDeleteFallbackOriginForCustomHostnamesVariables = {
  pathParams: CustomHostnameFallbackOriginForAZoneDeleteFallbackOriginForCustomHostnamesPathParams;
} & FetcherExtraProps;

export const customHostnameFallbackOriginForAZoneDeleteFallbackOriginForCustomHostnames = (
  variables: CustomHostnameFallbackOriginForAZoneDeleteFallbackOriginForCustomHostnamesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesFallbackOriginResponse,
    CustomHostnameFallbackOriginForAZoneDeleteFallbackOriginForCustomHostnamesError,
    undefined,
    {},
    {},
    CustomHostnameFallbackOriginForAZoneDeleteFallbackOriginForCustomHostnamesPathParams
  >({ url: '/zones/{zoneId}/custom_hostnames/fallback_origin', method: 'delete', ...variables, signal });

export type CustomHostnameFallbackOriginForAZoneGetFallbackOriginForCustomHostnamesPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CustomHostnameFallbackOriginForAZoneGetFallbackOriginForCustomHostnamesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesFallbackOriginResponse &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CustomHostnameFallbackOriginForAZoneGetFallbackOriginForCustomHostnamesVariables = {
  pathParams: CustomHostnameFallbackOriginForAZoneGetFallbackOriginForCustomHostnamesPathParams;
} & FetcherExtraProps;

export const customHostnameFallbackOriginForAZoneGetFallbackOriginForCustomHostnames = (
  variables: CustomHostnameFallbackOriginForAZoneGetFallbackOriginForCustomHostnamesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesFallbackOriginResponse,
    CustomHostnameFallbackOriginForAZoneGetFallbackOriginForCustomHostnamesError,
    undefined,
    {},
    {},
    CustomHostnameFallbackOriginForAZoneGetFallbackOriginForCustomHostnamesPathParams
  >({ url: '/zones/{zoneId}/custom_hostnames/fallback_origin', method: 'get', ...variables, signal });

export type CustomHostnameFallbackOriginForAZoneUpdateFallbackOriginForCustomHostnamesPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CustomHostnameFallbackOriginForAZoneUpdateFallbackOriginForCustomHostnamesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesFallbackOriginResponse &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CustomHostnameFallbackOriginForAZoneUpdateFallbackOriginForCustomHostnamesRequestBody = {
  origin: Schemas.TlsCertificatesAndHostnamesOrigin;
};

export type CustomHostnameFallbackOriginForAZoneUpdateFallbackOriginForCustomHostnamesVariables = {
  body: CustomHostnameFallbackOriginForAZoneUpdateFallbackOriginForCustomHostnamesRequestBody;
  pathParams: CustomHostnameFallbackOriginForAZoneUpdateFallbackOriginForCustomHostnamesPathParams;
} & FetcherExtraProps;

export const customHostnameFallbackOriginForAZoneUpdateFallbackOriginForCustomHostnames = (
  variables: CustomHostnameFallbackOriginForAZoneUpdateFallbackOriginForCustomHostnamesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesFallbackOriginResponse,
    CustomHostnameFallbackOriginForAZoneUpdateFallbackOriginForCustomHostnamesError,
    CustomHostnameFallbackOriginForAZoneUpdateFallbackOriginForCustomHostnamesRequestBody,
    {},
    {},
    CustomHostnameFallbackOriginForAZoneUpdateFallbackOriginForCustomHostnamesPathParams
  >({ url: '/zones/{zoneId}/custom_hostnames/fallback_origin', method: 'put', ...variables, signal });

export type CustomHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificatesPathParams = {
  customHostnameId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CustomHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificatesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    id?: Schemas.TlsCertificatesAndHostnamesIdentifier;
  } & Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CustomHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificatesResponse = {
  id?: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CustomHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificatesVariables = {
  pathParams: CustomHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificatesPathParams;
} & FetcherExtraProps;

export const customHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificates = (
  variables: CustomHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificatesVariables,
  signal?: AbortSignal
) =>
  fetch<
    CustomHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificatesResponse,
    CustomHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificatesError,
    undefined,
    {},
    {},
    CustomHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificatesPathParams
  >({ url: '/zones/{zoneId}/custom_hostnames/{customHostnameId}', method: 'delete', ...variables, signal });

export type CustomHostnameForAZoneCustomHostnameDetailsPathParams = {
  customHostnameId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CustomHostnameForAZoneCustomHostnameDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesCustomHostnameResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CustomHostnameForAZoneCustomHostnameDetailsVariables = {
  pathParams: CustomHostnameForAZoneCustomHostnameDetailsPathParams;
} & FetcherExtraProps;

export const customHostnameForAZoneCustomHostnameDetails = (
  variables: CustomHostnameForAZoneCustomHostnameDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesCustomHostnameResponseSingle,
    CustomHostnameForAZoneCustomHostnameDetailsError,
    undefined,
    {},
    {},
    CustomHostnameForAZoneCustomHostnameDetailsPathParams
  >({ url: '/zones/{zoneId}/custom_hostnames/{customHostnameId}', method: 'get', ...variables, signal });

export type CustomHostnameForAZoneEditCustomHostnamePathParams = {
  customHostnameId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CustomHostnameForAZoneEditCustomHostnameError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesCustomHostnameResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CustomHostnameForAZoneEditCustomHostnameRequestBody = {
  custom_metadata?: Schemas.TlsCertificatesAndHostnamesCustomMetadata;
  custom_origin_server?: Schemas.TlsCertificatesAndHostnamesCustomOriginServer;
  custom_origin_sni?: Schemas.TlsCertificatesAndHostnamesCustomOriginSni;
  ssl?: Schemas.TlsCertificatesAndHostnamesSslpost;
};

export type CustomHostnameForAZoneEditCustomHostnameVariables = {
  body?: CustomHostnameForAZoneEditCustomHostnameRequestBody;
  pathParams: CustomHostnameForAZoneEditCustomHostnamePathParams;
} & FetcherExtraProps;

/**
 * Modify SSL configuration for a custom hostname. When sent with SSL config that matches existing config, used to indicate that hostname should pass domain control validation (DCV). Can also be used to change validation type, e.g., from 'http' to 'email'.
 */
export const customHostnameForAZoneEditCustomHostname = (
  variables: CustomHostnameForAZoneEditCustomHostnameVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesCustomHostnameResponseSingle,
    CustomHostnameForAZoneEditCustomHostnameError,
    CustomHostnameForAZoneEditCustomHostnameRequestBody,
    {},
    {},
    CustomHostnameForAZoneEditCustomHostnamePathParams
  >({ url: '/zones/{zoneId}/custom_hostnames/{customHostnameId}', method: 'patch', ...variables, signal });

export type AccountLevelCustomNameserversUsageForAZoneGetAccountCustomNameserverRelatedZoneMetadataPathParams = {
  zoneId: Schemas.DnsCustomNameserversSchemasIdentifier;
};

export type AccountLevelCustomNameserversUsageForAZoneGetAccountCustomNameserverRelatedZoneMetadataError =
  Fetcher.ErrorWrapper<{
    status: 400;
    payload: Schemas.DnsCustomNameserversGetResponse & Schemas.DnsCustomNameserversApiResponseCommonFailure;
  }>;

export type AccountLevelCustomNameserversUsageForAZoneGetAccountCustomNameserverRelatedZoneMetadataVariables = {
  pathParams: AccountLevelCustomNameserversUsageForAZoneGetAccountCustomNameserverRelatedZoneMetadataPathParams;
} & FetcherExtraProps;

/**
 * Get metadata for account-level custom nameservers on a zone.
 *
 * Deprecated in favor of [Show DNS Settings](https://developers.cloudflare.com/api/operations/dns-settings-for-a-zone-list-dns-settings).
 */
export const accountLevelCustomNameserversUsageForAZoneGetAccountCustomNameserverRelatedZoneMetadata = (
  variables: AccountLevelCustomNameserversUsageForAZoneGetAccountCustomNameserverRelatedZoneMetadataVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsCustomNameserversGetResponse,
    AccountLevelCustomNameserversUsageForAZoneGetAccountCustomNameserverRelatedZoneMetadataError,
    undefined,
    {},
    {},
    AccountLevelCustomNameserversUsageForAZoneGetAccountCustomNameserverRelatedZoneMetadataPathParams
  >({ url: '/zones/{zoneId}/custom_ns', method: 'get', ...variables, signal });

export type AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataPathParams = {
  zoneId: Schemas.DnsCustomNameserversSchemasIdentifier;
};

export type AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataError =
  Fetcher.ErrorWrapper<{
    status: 400;
    payload: Schemas.DnsCustomNameserversSchemasEmptyResponse & Schemas.DnsCustomNameserversApiResponseCommonFailure;
  }>;

export type AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataVariables = {
  body?: Schemas.DnsCustomNameserversZoneMetadata;
  pathParams: AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataPathParams;
} & FetcherExtraProps;

/**
 * Set metadata for account-level custom nameservers on a zone.
 *
 * If you would like new zones in the account to use account custom nameservers by default, use PUT /accounts/:identifier to set the account setting use_account_custom_ns_by_default to true.
 *
 * Deprecated in favor of [Update DNS Settings](https://developers.cloudflare.com/api/operations/dns-settings-for-a-zone-update-dns-settings).
 */
export const accountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadata = (
  variables: AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsCustomNameserversSchemasEmptyResponse,
    AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataError,
    Schemas.DnsCustomNameserversZoneMetadata,
    {},
    {},
    AccountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadataPathParams
  >({ url: '/zones/{zoneId}/custom_ns', method: 'put', ...variables, signal });

export type DcvDelegationUuidGetPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type DcvDelegationUuidGetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesDcvDelegationResponse &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type DcvDelegationUuidGetVariables = {
  pathParams: DcvDelegationUuidGetPathParams;
} & FetcherExtraProps;

/**
 * Retrieve the account and zone specific unique identifier used as part of the CNAME target for DCV Delegation.
 */
export const dcvDelegationUuidGet = (variables: DcvDelegationUuidGetVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesDcvDelegationResponse,
    DcvDelegationUuidGetError,
    undefined,
    {},
    {},
    DcvDelegationUuidGetPathParams
  >({ url: '/zones/{zoneId}/dcv_delegation/uuid', method: 'get', ...variables, signal });

export type DevicesGetPolicyCertificatesPathParams = {
  zoneId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesGetPolicyCertificatesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesDevicesPolicyCertificatesSingle & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesGetPolicyCertificatesVariables = {
  pathParams: DevicesGetPolicyCertificatesPathParams;
} & FetcherExtraProps;

/**
 * Fetches device certificate provisioning
 */
export const devicesGetPolicyCertificates = (variables: DevicesGetPolicyCertificatesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.TeamsDevicesDevicesPolicyCertificatesSingle,
    DevicesGetPolicyCertificatesError,
    undefined,
    {},
    {},
    DevicesGetPolicyCertificatesPathParams
  >({ url: '/zones/{zoneId}/devices/policy/certificates', method: 'get', ...variables, signal });

export type DevicesUpdatePolicyCertificatesPathParams = {
  zoneId: Schemas.TeamsDevicesIdentifier;
};

export type DevicesUpdatePolicyCertificatesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TeamsDevicesDevicesPolicyCertificatesSingle & Schemas.TeamsDevicesApiResponseCommonFailure;
}>;

export type DevicesUpdatePolicyCertificatesVariables = {
  body: Schemas.TeamsDevicesDevicesPolicyCertificates;
  pathParams: DevicesUpdatePolicyCertificatesPathParams;
} & FetcherExtraProps;

/**
 * Enable Zero Trust Clients to provision a certificate, containing a x509 subject, and referenced by Access device posture policies when the client visits MTLS protected domains. This facilitates device posture without a WARP session.
 */
export const devicesUpdatePolicyCertificates = (
  variables: DevicesUpdatePolicyCertificatesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TeamsDevicesDevicesPolicyCertificatesSingle,
    DevicesUpdatePolicyCertificatesError,
    Schemas.TeamsDevicesDevicesPolicyCertificates,
    {},
    {},
    DevicesUpdatePolicyCertificatesPathParams
  >({ url: '/zones/{zoneId}/devices/policy/certificates', method: 'patch', ...variables, signal });

export type DnsAnalyticsTablePathParams = {
  zoneId: Schemas.DnsAnalyticsIdentifier;
};

export type DnsAnalyticsTableQueryParams = {
  metrics?: Schemas.DnsAnalyticsMetrics;
  dimensions?: Schemas.DnsAnalyticsDimensions;
  since?: Schemas.DnsAnalyticsSince;
  until?: Schemas.DnsAnalyticsUntil;
  limit?: Schemas.DnsAnalyticsLimit;
  sort?: Schemas.DnsAnalyticsSort;
  filters?: Schemas.DnsAnalyticsFilters;
};

export type DnsAnalyticsTableError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.DnsAnalyticsApiResponseSingle & {
    result?: Schemas.DnsAnalyticsReport;
  }) &
    Schemas.DnsAnalyticsApiResponseCommonFailure;
}>;

export type DnsAnalyticsTableResponse = Schemas.DnsAnalyticsApiResponseSingle & {
  result?: Schemas.DnsAnalyticsReport;
};

export type DnsAnalyticsTableVariables = {
  pathParams: DnsAnalyticsTablePathParams;
  queryParams?: DnsAnalyticsTableQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of summarised aggregate metrics over a given time period.
 *
 * See [Analytics API properties](https://developers.cloudflare.com/dns/reference/analytics-api-properties/) for detailed information about the available query parameters.
 */
export const dnsAnalyticsTable = (variables: DnsAnalyticsTableVariables, signal?: AbortSignal) =>
  fetch<
    DnsAnalyticsTableResponse,
    DnsAnalyticsTableError,
    undefined,
    {},
    DnsAnalyticsTableQueryParams,
    DnsAnalyticsTablePathParams
  >({ url: '/zones/{zoneId}/dns_analytics/report', method: 'get', ...variables, signal });

export type DnsAnalyticsByTimePathParams = {
  zoneId: Schemas.DnsAnalyticsIdentifier;
};

export type DnsAnalyticsByTimeQueryParams = {
  metrics?: Schemas.DnsAnalyticsMetrics;
  dimensions?: Schemas.DnsAnalyticsDimensions;
  since?: Schemas.DnsAnalyticsSince;
  until?: Schemas.DnsAnalyticsUntil;
  limit?: Schemas.DnsAnalyticsLimit;
  sort?: Schemas.DnsAnalyticsSort;
  filters?: Schemas.DnsAnalyticsFilters;
  time_delta?: Schemas.DnsAnalyticsTimeDelta;
};

export type DnsAnalyticsByTimeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.DnsAnalyticsApiResponseSingle & {
    result?: Schemas.DnsAnalyticsReportBytime;
  }) &
    Schemas.DnsAnalyticsApiResponseCommonFailure;
}>;

export type DnsAnalyticsByTimeResponse = Schemas.DnsAnalyticsApiResponseSingle & {
  result?: Schemas.DnsAnalyticsReportBytime;
};

export type DnsAnalyticsByTimeVariables = {
  pathParams: DnsAnalyticsByTimePathParams;
  queryParams?: DnsAnalyticsByTimeQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of aggregate metrics grouped by time interval.
 *
 * See [Analytics API properties](https://developers.cloudflare.com/dns/reference/analytics-api-properties/) for detailed information about the available query parameters.
 */
export const dnsAnalyticsByTime = (variables: DnsAnalyticsByTimeVariables, signal?: AbortSignal) =>
  fetch<
    DnsAnalyticsByTimeResponse,
    DnsAnalyticsByTimeError,
    undefined,
    {},
    DnsAnalyticsByTimeQueryParams,
    DnsAnalyticsByTimePathParams
  >({ url: '/zones/{zoneId}/dns_analytics/report/bytime', method: 'get', ...variables, signal });

export type DnsRecordsForAZoneListDnsRecordsPathParams = {
  zoneId: Schemas.DnsRecordsIdentifier;
};

export type DnsRecordsForAZoneListDnsRecordsQueryParams = {
  /**
   * @example www.example.com
   */
  name?: string;
  /**
   * @example www.example.com
   */
  ['name.exact']?: string;
  /**
   * @example w.example.
   */
  ['name.contains']?: string;
  /**
   * @example www.example
   */
  ['name.startswith']?: string;
  /**
   * @example .example.com
   */
  ['name.endswith']?: string;
  type?: Schemas.DnsRecordsType;
  /**
   * @example 127.0.0.1
   */
  content?: string;
  /**
   * @example 127.0.0.1
   */
  ['content.exact']?: string;
  /**
   * @example 7.0.0.
   */
  ['content.contains']?: string;
  /**
   * @example 127.0.
   */
  ['content.startswith']?: string;
  /**
   * @example .0.1
   */
  ['content.endswith']?: string;
  proxied?: Schemas.DnsRecordsProxied;
  match?: Schemas.DnsRecordsMatch;
  /**
   * @example Hello, world
   */
  comment?: string;
  ['comment.present']?: string;
  ['comment.absent']?: string;
  /**
   * @example Hello, world
   */
  ['comment.exact']?: string;
  /**
   * @example ello, worl
   */
  ['comment.contains']?: string;
  /**
   * @example Hello, w
   */
  ['comment.startswith']?: string;
  /**
   * @example o, world
   */
  ['comment.endswith']?: string;
  /**
   * @example team:DNS
   */
  tag?: string;
  /**
   * @example important
   */
  ['tag.present']?: string;
  /**
   * @example important
   */
  ['tag.absent']?: string;
  /**
   * @example greeting:Hello, world
   */
  ['tag.exact']?: string;
  /**
   * @example greeting:ello, worl
   */
  ['tag.contains']?: string;
  /**
   * @example greeting:Hello, w
   */
  ['tag.startswith']?: string;
  /**
   * @example greeting:o, world
   */
  ['tag.endswith']?: string;
  search?: Schemas.DnsRecordsSearch;
  tag_match?: Schemas.DnsRecordsTagMatch;
  page?: Schemas.DnsRecordsPage;
  per_page?: Schemas.DnsRecordsPerPage;
  order?: Schemas.DnsRecordsOrder;
  direction?: Schemas.DnsRecordsDirection;
};

export type DnsRecordsForAZoneListDnsRecordsError = Fetcher.ErrorWrapper<{
  status: ClientErrorStatus;
  payload: Schemas.DnsRecordsDnsResponseCollection & Schemas.DnsRecordsApiResponseCommonFailure;
}>;

export type DnsRecordsForAZoneListDnsRecordsVariables = {
  pathParams: DnsRecordsForAZoneListDnsRecordsPathParams;
  queryParams?: DnsRecordsForAZoneListDnsRecordsQueryParams;
} & FetcherExtraProps;

/**
 * List, search, sort, and filter a zones' DNS records.
 */
export const dnsRecordsForAZoneListDnsRecords = (
  variables: DnsRecordsForAZoneListDnsRecordsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsRecordsDnsResponseCollection,
    DnsRecordsForAZoneListDnsRecordsError,
    undefined,
    {},
    DnsRecordsForAZoneListDnsRecordsQueryParams,
    DnsRecordsForAZoneListDnsRecordsPathParams
  >({ url: '/zones/{zoneId}/dns_records', method: 'get', ...variables, signal });

export type DnsRecordsForAZoneCreateDnsRecordPathParams = {
  zoneId: Schemas.DnsRecordsIdentifier;
};

export type DnsRecordsForAZoneCreateDnsRecordError = Fetcher.ErrorWrapper<{
  status: ClientErrorStatus;
  payload: Schemas.DnsRecordsDnsResponseSingle & Schemas.DnsRecordsApiResponseCommonFailure;
}>;

export type DnsRecordsForAZoneCreateDnsRecordVariables = {
  body: Schemas.DnsRecordsDnsRecordPost;
  pathParams: DnsRecordsForAZoneCreateDnsRecordPathParams;
} & FetcherExtraProps;

/**
 * Create a new DNS record for a zone.
 *
 * Notes:
 * - A/AAAA records cannot exist on the same name as CNAME records.
 * - NS records cannot exist on the same name as any other record type.
 * - Domain names are always represented in Punycode, even if Unicode
 *   characters were used when creating the record.
 */
export const dnsRecordsForAZoneCreateDnsRecord = (
  variables: DnsRecordsForAZoneCreateDnsRecordVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsRecordsDnsResponseSingle,
    DnsRecordsForAZoneCreateDnsRecordError,
    Schemas.DnsRecordsDnsRecordPost,
    {},
    {},
    DnsRecordsForAZoneCreateDnsRecordPathParams
  >({ url: '/zones/{zoneId}/dns_records', method: 'post', ...variables, signal });

export type DnsRecordsForAZoneBatchDnsRecordsPathParams = {
  zoneId: Schemas.DnsRecordsIdentifier;
};

export type DnsRecordsForAZoneBatchDnsRecordsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsRecordsApiResponseCommonFailure;
}>;

export type DnsRecordsForAZoneBatchDnsRecordsVariables = {
  body?: Schemas.DnsRecordsDnsRequestBatchObject;
  pathParams: DnsRecordsForAZoneBatchDnsRecordsPathParams;
} & FetcherExtraProps;

/**
 * Send a Batch of DNS Record API calls to be executed together.
 *
 * Notes:
 * - Although Cloudflare will execute the batched operations in a single database transaction, Cloudflare's distributed KV store must treat each record change as a single key-value pair. This means that the propagation of changes is not atomic. See [the documentation](https://developers.cloudflare.com/dns/manage-dns-records/how-to/batch-record-changes/ "Batch DNS records") for more information.
 * - The operations you specify within the /batch request body are always executed in the following order:
 *
 *     - Deletes
 *     - Patches
 *     - Puts
 *     - Posts
 */
export const dnsRecordsForAZoneBatchDnsRecords = (
  variables: DnsRecordsForAZoneBatchDnsRecordsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsRecordsDnsResponseBatch,
    DnsRecordsForAZoneBatchDnsRecordsError,
    Schemas.DnsRecordsDnsRequestBatchObject,
    {},
    {},
    DnsRecordsForAZoneBatchDnsRecordsPathParams
  >({ url: '/zones/{zoneId}/dns_records/batch', method: 'post', ...variables, signal });

export type DnsRecordsForAZoneExportDnsRecordsPathParams = {
  zoneId: Schemas.DnsRecordsIdentifier;
};

export type DnsRecordsForAZoneExportDnsRecordsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsRecordsApiResponseCommonFailure;
}>;

export type DnsRecordsForAZoneExportDnsRecordsVariables = {
  pathParams: DnsRecordsForAZoneExportDnsRecordsPathParams;
} & FetcherExtraProps;

/**
 * You can export your [BIND config](https://en.wikipedia.org/wiki/Zone_file "Zone file") through this endpoint.
 *
 * See [the documentation](https://developers.cloudflare.com/dns/manage-dns-records/how-to/import-and-export/ "Import and export records") for more information.
 */
export const dnsRecordsForAZoneExportDnsRecords = (
  variables: DnsRecordsForAZoneExportDnsRecordsVariables,
  signal?: AbortSignal
) =>
  fetch<
    undefined,
    DnsRecordsForAZoneExportDnsRecordsError,
    undefined,
    {},
    {},
    DnsRecordsForAZoneExportDnsRecordsPathParams
  >({ url: '/zones/{zoneId}/dns_records/export', method: 'get', ...variables, signal });

export type DnsRecordsForAZoneImportDnsRecordsPathParams = {
  zoneId: Schemas.DnsRecordsIdentifier;
};

export type DnsRecordsForAZoneImportDnsRecordsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsRecordsDnsResponseImportScan & Schemas.DnsRecordsApiResponseCommonFailure;
}>;

export type DnsRecordsForAZoneImportDnsRecordsRequestBody = {
  /**
   * BIND config to import.
   *
   * **Tip:** When using cURL, a file can be uploaded using `--form 'file=@bind_config.txt'`.
   *
   * @example www.example.com. 300 IN  A 127.0.0.1
   */
  file: string;
  /**
   * Whether or not proxiable records should receive the performance and security benefits of Cloudflare.
   *
   * The value should be either `true` or `false`.
   *
   * @default false
   * @example true
   */
  proxied?: string;
};

export type DnsRecordsForAZoneImportDnsRecordsVariables = {
  body: DnsRecordsForAZoneImportDnsRecordsRequestBody;
  pathParams: DnsRecordsForAZoneImportDnsRecordsPathParams;
} & FetcherExtraProps;

/**
 * You can upload your [BIND config](https://en.wikipedia.org/wiki/Zone_file "Zone file") through this endpoint. It assumes that cURL is called from a location with bind_config.txt (valid BIND config) present.
 *
 * See [the documentation](https://developers.cloudflare.com/dns/manage-dns-records/how-to/import-and-export/ "Import and export records") for more information.
 */
export const dnsRecordsForAZoneImportDnsRecords = (
  variables: DnsRecordsForAZoneImportDnsRecordsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsRecordsDnsResponseImportScan,
    DnsRecordsForAZoneImportDnsRecordsError,
    DnsRecordsForAZoneImportDnsRecordsRequestBody,
    {},
    {},
    DnsRecordsForAZoneImportDnsRecordsPathParams
  >({ url: '/zones/{zoneId}/dns_records/import', method: 'post', ...variables, signal });

export type DnsRecordsForAZoneScanDnsRecordsPathParams = {
  zoneId: Schemas.DnsRecordsIdentifier;
};

export type DnsRecordsForAZoneScanDnsRecordsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsRecordsDnsResponseImportScan & Schemas.DnsRecordsApiResponseCommonFailure;
}>;

export type DnsRecordsForAZoneScanDnsRecordsVariables = {
  pathParams: DnsRecordsForAZoneScanDnsRecordsPathParams;
} & FetcherExtraProps;

/**
 * Scan for common DNS records on your domain and automatically add them to your zone. Useful if you haven't updated your nameservers yet.
 */
export const dnsRecordsForAZoneScanDnsRecords = (
  variables: DnsRecordsForAZoneScanDnsRecordsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsRecordsDnsResponseImportScan,
    DnsRecordsForAZoneScanDnsRecordsError,
    undefined,
    {},
    {},
    DnsRecordsForAZoneScanDnsRecordsPathParams
  >({ url: '/zones/{zoneId}/dns_records/scan', method: 'post', ...variables, signal });

export type DnsRecordsForAZoneDeleteDnsRecordPathParams = {
  dnsRecordId: Schemas.DnsRecordsIdentifier;
  zoneId: Schemas.DnsRecordsIdentifier;
};

export type DnsRecordsForAZoneDeleteDnsRecordError = Fetcher.ErrorWrapper<{
  status: ClientErrorStatus;
  payload: {
    result: any | null;
    /**
     * @example {"code":7003,"message":"No route for the URI"}
     * @minLength 1
     */
    errors: Schemas.DnsRecordsMessages;
    messages: Schemas.DnsRecordsMessages;
    /**
     * Whether the API call was successful
     *
     * @example false
     */
    success: false;
  };
}>;

export type DnsRecordsForAZoneDeleteDnsRecordResponse = {
  result?: {
    id?: Schemas.DnsRecordsIdentifier;
  };
};

export type DnsRecordsForAZoneDeleteDnsRecordVariables = {
  pathParams: DnsRecordsForAZoneDeleteDnsRecordPathParams;
} & FetcherExtraProps;

export const dnsRecordsForAZoneDeleteDnsRecord = (
  variables: DnsRecordsForAZoneDeleteDnsRecordVariables,
  signal?: AbortSignal
) =>
  fetch<
    DnsRecordsForAZoneDeleteDnsRecordResponse,
    DnsRecordsForAZoneDeleteDnsRecordError,
    undefined,
    {},
    {},
    DnsRecordsForAZoneDeleteDnsRecordPathParams
  >({ url: '/zones/{zoneId}/dns_records/{dnsRecordId}', method: 'delete', ...variables, signal });

export type DnsRecordsForAZoneDnsRecordDetailsPathParams = {
  dnsRecordId: Schemas.DnsRecordsIdentifier;
  zoneId: Schemas.DnsRecordsIdentifier;
};

export type DnsRecordsForAZoneDnsRecordDetailsError = Fetcher.ErrorWrapper<{
  status: ClientErrorStatus;
  payload: Schemas.DnsRecordsDnsResponseSingle & Schemas.DnsRecordsApiResponseCommonFailure;
}>;

export type DnsRecordsForAZoneDnsRecordDetailsVariables = {
  pathParams: DnsRecordsForAZoneDnsRecordDetailsPathParams;
} & FetcherExtraProps;

export const dnsRecordsForAZoneDnsRecordDetails = (
  variables: DnsRecordsForAZoneDnsRecordDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsRecordsDnsResponseSingle,
    DnsRecordsForAZoneDnsRecordDetailsError,
    undefined,
    {},
    {},
    DnsRecordsForAZoneDnsRecordDetailsPathParams
  >({ url: '/zones/{zoneId}/dns_records/{dnsRecordId}', method: 'get', ...variables, signal });

export type DnsRecordsForAZonePatchDnsRecordPathParams = {
  dnsRecordId: Schemas.DnsRecordsIdentifier;
  zoneId: Schemas.DnsRecordsIdentifier;
};

export type DnsRecordsForAZonePatchDnsRecordError = Fetcher.ErrorWrapper<{
  status: ClientErrorStatus;
  payload: Schemas.DnsRecordsDnsResponseSingle & Schemas.DnsRecordsApiResponseCommonFailure;
}>;

export type DnsRecordsForAZonePatchDnsRecordVariables = {
  body?: Schemas.DnsRecordsDnsRecordPatch;
  pathParams: DnsRecordsForAZonePatchDnsRecordPathParams;
} & FetcherExtraProps;

/**
 * Update an existing DNS record.
 *
 * Notes:
 * - A/AAAA records cannot exist on the same name as CNAME records.
 * - NS records cannot exist on the same name as any other record type.
 * - Domain names are always represented in Punycode, even if Unicode
 *   characters were used when creating the record.
 */
export const dnsRecordsForAZonePatchDnsRecord = (
  variables: DnsRecordsForAZonePatchDnsRecordVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsRecordsDnsResponseSingle,
    DnsRecordsForAZonePatchDnsRecordError,
    Schemas.DnsRecordsDnsRecordPatch,
    {},
    {},
    DnsRecordsForAZonePatchDnsRecordPathParams
  >({ url: '/zones/{zoneId}/dns_records/{dnsRecordId}', method: 'patch', ...variables, signal });

export type DnsRecordsForAZoneUpdateDnsRecordPathParams = {
  dnsRecordId: Schemas.DnsRecordsIdentifier;
  zoneId: Schemas.DnsRecordsIdentifier;
};

export type DnsRecordsForAZoneUpdateDnsRecordError = Fetcher.ErrorWrapper<{
  status: ClientErrorStatus;
  payload: Schemas.DnsRecordsDnsResponseSingle & Schemas.DnsRecordsApiResponseCommonFailure;
}>;

export type DnsRecordsForAZoneUpdateDnsRecordVariables = {
  body: Schemas.DnsRecordsDnsRecordPost;
  pathParams: DnsRecordsForAZoneUpdateDnsRecordPathParams;
} & FetcherExtraProps;

/**
 * Overwrite an existing DNS record.
 *
 * Notes:
 * - A/AAAA records cannot exist on the same name as CNAME records.
 * - NS records cannot exist on the same name as any other record type.
 * - Domain names are always represented in Punycode, even if Unicode
 *   characters were used when creating the record.
 */
export const dnsRecordsForAZoneUpdateDnsRecord = (
  variables: DnsRecordsForAZoneUpdateDnsRecordVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsRecordsDnsResponseSingle,
    DnsRecordsForAZoneUpdateDnsRecordError,
    Schemas.DnsRecordsDnsRecordPost,
    {},
    {},
    DnsRecordsForAZoneUpdateDnsRecordPathParams
  >({ url: '/zones/{zoneId}/dns_records/{dnsRecordId}', method: 'put', ...variables, signal });

export type DnsSettingsForAZoneListDnsSettingsPathParams = {
  zoneId: Schemas.DnsSettingsIdentifier;
};

export type DnsSettingsForAZoneListDnsSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsSettingsSchemasDnsResponseSingle & Schemas.DnsSettingsApiResponseCommonFailure;
}>;

export type DnsSettingsForAZoneListDnsSettingsVariables = {
  pathParams: DnsSettingsForAZoneListDnsSettingsPathParams;
} & FetcherExtraProps;

/**
 * Show DNS settings for a zone
 */
export const dnsSettingsForAZoneListDnsSettings = (
  variables: DnsSettingsForAZoneListDnsSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsSettingsSchemasDnsResponseSingle,
    DnsSettingsForAZoneListDnsSettingsError,
    undefined,
    {},
    {},
    DnsSettingsForAZoneListDnsSettingsPathParams
  >({ url: '/zones/{zoneId}/dns_settings', method: 'get', ...variables, signal });

export type DnsSettingsForAZoneUpdateDnsSettingsPathParams = {
  zoneId: Schemas.DnsSettingsIdentifier;
};

export type DnsSettingsForAZoneUpdateDnsSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnsSettingsSchemasDnsResponseSingle & Schemas.DnsSettingsApiResponseCommonFailure;
}>;

export type DnsSettingsForAZoneUpdateDnsSettingsVariables = {
  body?: Schemas.DnsSettingsDnsSettingsZone;
  pathParams: DnsSettingsForAZoneUpdateDnsSettingsPathParams;
} & FetcherExtraProps;

/**
 * Update DNS settings for a zone
 */
export const dnsSettingsForAZoneUpdateDnsSettings = (
  variables: DnsSettingsForAZoneUpdateDnsSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.DnsSettingsSchemasDnsResponseSingle,
    DnsSettingsForAZoneUpdateDnsSettingsError,
    Schemas.DnsSettingsDnsSettingsZone,
    {},
    {},
    DnsSettingsForAZoneUpdateDnsSettingsPathParams
  >({ url: '/zones/{zoneId}/dns_settings', method: 'patch', ...variables, signal });

export type DnssecDeleteDnssecRecordsPathParams = {
  zoneId: Schemas.DnssecIdentifier;
};

export type DnssecDeleteDnssecRecordsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnssecDeleteDnssecResponseSingle & Schemas.DnssecApiResponseCommonFailure;
}>;

export type DnssecDeleteDnssecRecordsVariables = {
  pathParams: DnssecDeleteDnssecRecordsPathParams;
} & FetcherExtraProps;

/**
 * Delete DNSSEC.
 */
export const dnssecDeleteDnssecRecords = (variables: DnssecDeleteDnssecRecordsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.DnssecDeleteDnssecResponseSingle,
    DnssecDeleteDnssecRecordsError,
    undefined,
    {},
    {},
    DnssecDeleteDnssecRecordsPathParams
  >({ url: '/zones/{zoneId}/dnssec', method: 'delete', ...variables, signal });

export type DnssecDnssecDetailsPathParams = {
  zoneId: Schemas.DnssecIdentifier;
};

export type DnssecDnssecDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnssecDnssecResponseSingle & Schemas.DnssecApiResponseCommonFailure;
}>;

export type DnssecDnssecDetailsVariables = {
  pathParams: DnssecDnssecDetailsPathParams;
} & FetcherExtraProps;

/**
 * Details about DNSSEC status and configuration.
 */
export const dnssecDnssecDetails = (variables: DnssecDnssecDetailsVariables, signal?: AbortSignal) =>
  fetch<Schemas.DnssecDnssecResponseSingle, DnssecDnssecDetailsError, undefined, {}, {}, DnssecDnssecDetailsPathParams>(
    { url: '/zones/{zoneId}/dnssec', method: 'get', ...variables, signal }
  );

export type DnssecEditDnssecStatusPathParams = {
  zoneId: Schemas.DnssecIdentifier;
};

export type DnssecEditDnssecStatusError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.DnssecDnssecResponseSingle & Schemas.DnssecApiResponseCommonFailure;
}>;

export type DnssecEditDnssecStatusRequestBody = {
  dnssec_multi_signer?: Schemas.DnssecDnssecMultiSigner;
  dnssec_presigned?: Schemas.DnssecDnssecPresigned;
  /**
   * Status of DNSSEC, based on user-desired state and presence of necessary records.
   *
   * @example active
   */
  status?: 'active' | 'disabled';
};

export type DnssecEditDnssecStatusVariables = {
  body?: DnssecEditDnssecStatusRequestBody;
  pathParams: DnssecEditDnssecStatusPathParams;
} & FetcherExtraProps;

/**
 * Enable or disable DNSSEC.
 */
export const dnssecEditDnssecStatus = (variables: DnssecEditDnssecStatusVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.DnssecDnssecResponseSingle,
    DnssecEditDnssecStatusError,
    DnssecEditDnssecStatusRequestBody,
    {},
    {},
    DnssecEditDnssecStatusPathParams
  >({ url: '/zones/{zoneId}/dnssec', method: 'patch', ...variables, signal });

export type EmailRoutingSettingsGetEmailRoutingSettingsPathParams = {
  zoneId: Schemas.EmailIdentifier;
};

export type EmailRoutingSettingsGetEmailRoutingSettingsError = Fetcher.ErrorWrapper<undefined>;

export type EmailRoutingSettingsGetEmailRoutingSettingsVariables = {
  pathParams: EmailRoutingSettingsGetEmailRoutingSettingsPathParams;
} & FetcherExtraProps;

/**
 * Get information about the settings for your Email Routing zone.
 */
export const emailRoutingSettingsGetEmailRoutingSettings = (
  variables: EmailRoutingSettingsGetEmailRoutingSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.EmailEmailSettingsResponseSingle,
    EmailRoutingSettingsGetEmailRoutingSettingsError,
    undefined,
    {},
    {},
    EmailRoutingSettingsGetEmailRoutingSettingsPathParams
  >({ url: '/zones/{zoneId}/email/routing', method: 'get', ...variables, signal });

export type EmailRoutingSettingsDisableEmailRoutingPathParams = {
  zoneId: Schemas.EmailIdentifier;
};

export type EmailRoutingSettingsDisableEmailRoutingError = Fetcher.ErrorWrapper<undefined>;

export type EmailRoutingSettingsDisableEmailRoutingVariables = {
  pathParams: EmailRoutingSettingsDisableEmailRoutingPathParams;
} & FetcherExtraProps;

/**
 * Disable your Email Routing zone. Also removes additional MX records previously required for Email Routing to work.
 */
export const emailRoutingSettingsDisableEmailRouting = (
  variables: EmailRoutingSettingsDisableEmailRoutingVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.EmailEmailSettingsResponseSingle,
    EmailRoutingSettingsDisableEmailRoutingError,
    undefined,
    {},
    {},
    EmailRoutingSettingsDisableEmailRoutingPathParams
  >({ url: '/zones/{zoneId}/email/routing/disable', method: 'post', ...variables, signal });

export type EmailRoutingSettingsDisableEmailRoutingDnsPathParams = {
  zoneId: Schemas.EmailIdentifier;
};

export type EmailRoutingSettingsDisableEmailRoutingDnsError = Fetcher.ErrorWrapper<undefined>;

export type EmailRoutingSettingsDisableEmailRoutingDnsVariables = {
  body: Schemas.EmailEmailSettingDnsRequestBody;
  pathParams: EmailRoutingSettingsDisableEmailRoutingDnsPathParams;
} & FetcherExtraProps;

/**
 * Disable your Email Routing zone. Also removes additional MX records previously required for Email Routing to work.
 */
export const emailRoutingSettingsDisableEmailRoutingDns = (
  variables: EmailRoutingSettingsDisableEmailRoutingDnsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.EmailApiResponseSingle | Schemas.EmailDnsSettingsResponseCollection,
    EmailRoutingSettingsDisableEmailRoutingDnsError,
    Schemas.EmailEmailSettingDnsRequestBody,
    {},
    {},
    EmailRoutingSettingsDisableEmailRoutingDnsPathParams
  >({ url: '/zones/{zoneId}/email/routing/dns', method: 'delete', ...variables, signal });

export type EmailRoutingSettingsEmailRoutingDnsSettingsPathParams = {
  zoneId: Schemas.EmailIdentifier;
};

export type EmailRoutingSettingsEmailRoutingDnsSettingsQueryParams = {
  subdomain?: Schemas.EmailEmailSettingName;
};

export type EmailRoutingSettingsEmailRoutingDnsSettingsError = Fetcher.ErrorWrapper<undefined>;

export type EmailRoutingSettingsEmailRoutingDnsSettingsVariables = {
  pathParams: EmailRoutingSettingsEmailRoutingDnsSettingsPathParams;
  queryParams?: EmailRoutingSettingsEmailRoutingDnsSettingsQueryParams;
} & FetcherExtraProps;

/**
 * Show the DNS records needed to configure your Email Routing zone.
 */
export const emailRoutingSettingsEmailRoutingDnsSettings = (
  variables: EmailRoutingSettingsEmailRoutingDnsSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.EmailEmailRoutingDnsQueryResponse | Schemas.EmailDnsSettingsResponseCollection,
    EmailRoutingSettingsEmailRoutingDnsSettingsError,
    undefined,
    {},
    EmailRoutingSettingsEmailRoutingDnsSettingsQueryParams,
    EmailRoutingSettingsEmailRoutingDnsSettingsPathParams
  >({ url: '/zones/{zoneId}/email/routing/dns', method: 'get', ...variables, signal });

export type EmailRoutingSettingsUnlockEmailRoutingDnsPathParams = {
  zoneId: Schemas.EmailIdentifier;
};

export type EmailRoutingSettingsUnlockEmailRoutingDnsError = Fetcher.ErrorWrapper<undefined>;

export type EmailRoutingSettingsUnlockEmailRoutingDnsVariables = {
  body: Schemas.EmailEmailSettingDnsRequestBody;
  pathParams: EmailRoutingSettingsUnlockEmailRoutingDnsPathParams;
} & FetcherExtraProps;

/**
 * Unlock MX Records previously locked by Email Routing.
 */
export const emailRoutingSettingsUnlockEmailRoutingDns = (
  variables: EmailRoutingSettingsUnlockEmailRoutingDnsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.EmailEmailSettingsResponseSingle,
    EmailRoutingSettingsUnlockEmailRoutingDnsError,
    Schemas.EmailEmailSettingDnsRequestBody,
    {},
    {},
    EmailRoutingSettingsUnlockEmailRoutingDnsPathParams
  >({ url: '/zones/{zoneId}/email/routing/dns', method: 'patch', ...variables, signal });

export type EmailRoutingSettingsEnableEmailRoutingDnsPathParams = {
  zoneId: Schemas.EmailIdentifier;
};

export type EmailRoutingSettingsEnableEmailRoutingDnsError = Fetcher.ErrorWrapper<undefined>;

export type EmailRoutingSettingsEnableEmailRoutingDnsVariables = {
  body: Schemas.EmailEmailSettingDnsRequestBody;
  pathParams: EmailRoutingSettingsEnableEmailRoutingDnsPathParams;
} & FetcherExtraProps;

/**
 * Enable you Email Routing zone. Add and lock the necessary MX and SPF records.
 */
export const emailRoutingSettingsEnableEmailRoutingDns = (
  variables: EmailRoutingSettingsEnableEmailRoutingDnsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.EmailEmailSettingsResponseSingle,
    EmailRoutingSettingsEnableEmailRoutingDnsError,
    Schemas.EmailEmailSettingDnsRequestBody,
    {},
    {},
    EmailRoutingSettingsEnableEmailRoutingDnsPathParams
  >({ url: '/zones/{zoneId}/email/routing/dns', method: 'post', ...variables, signal });

export type EmailRoutingSettingsEnableEmailRoutingPathParams = {
  zoneId: Schemas.EmailIdentifier;
};

export type EmailRoutingSettingsEnableEmailRoutingError = Fetcher.ErrorWrapper<undefined>;

export type EmailRoutingSettingsEnableEmailRoutingVariables = {
  pathParams: EmailRoutingSettingsEnableEmailRoutingPathParams;
} & FetcherExtraProps;

/**
 * Enable you Email Routing zone. Add and lock the necessary MX and SPF records.
 */
export const emailRoutingSettingsEnableEmailRouting = (
  variables: EmailRoutingSettingsEnableEmailRoutingVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.EmailEmailSettingsResponseSingle,
    EmailRoutingSettingsEnableEmailRoutingError,
    undefined,
    {},
    {},
    EmailRoutingSettingsEnableEmailRoutingPathParams
  >({ url: '/zones/{zoneId}/email/routing/enable', method: 'post', ...variables, signal });

export type EmailRoutingRoutingRulesListRoutingRulesPathParams = {
  zoneId: Schemas.EmailIdentifier;
};

export type EmailRoutingRoutingRulesListRoutingRulesQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example true
   */
  enabled?: true | false;
};

export type EmailRoutingRoutingRulesListRoutingRulesError = Fetcher.ErrorWrapper<undefined>;

export type EmailRoutingRoutingRulesListRoutingRulesVariables = {
  pathParams: EmailRoutingRoutingRulesListRoutingRulesPathParams;
  queryParams?: EmailRoutingRoutingRulesListRoutingRulesQueryParams;
} & FetcherExtraProps;

/**
 * Lists existing routing rules.
 */
export const emailRoutingRoutingRulesListRoutingRules = (
  variables: EmailRoutingRoutingRulesListRoutingRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.EmailRulesResponseCollection,
    EmailRoutingRoutingRulesListRoutingRulesError,
    undefined,
    {},
    EmailRoutingRoutingRulesListRoutingRulesQueryParams,
    EmailRoutingRoutingRulesListRoutingRulesPathParams
  >({ url: '/zones/{zoneId}/email/routing/rules', method: 'get', ...variables, signal });

export type EmailRoutingRoutingRulesCreateRoutingRulePathParams = {
  zoneId: Schemas.EmailIdentifier;
};

export type EmailRoutingRoutingRulesCreateRoutingRuleError = Fetcher.ErrorWrapper<undefined>;

export type EmailRoutingRoutingRulesCreateRoutingRuleVariables = {
  body: Schemas.EmailCreateRuleProperties;
  pathParams: EmailRoutingRoutingRulesCreateRoutingRulePathParams;
} & FetcherExtraProps;

/**
 * Rules consist of a set of criteria for matching emails (such as an email being sent to a specific custom email address) plus a set of actions to take on the email (like forwarding it to a specific destination address).
 */
export const emailRoutingRoutingRulesCreateRoutingRule = (
  variables: EmailRoutingRoutingRulesCreateRoutingRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.EmailRuleResponseSingle,
    EmailRoutingRoutingRulesCreateRoutingRuleError,
    Schemas.EmailCreateRuleProperties,
    {},
    {},
    EmailRoutingRoutingRulesCreateRoutingRulePathParams
  >({ url: '/zones/{zoneId}/email/routing/rules', method: 'post', ...variables, signal });

export type EmailRoutingRoutingRulesGetCatchAllRulePathParams = {
  zoneId: Schemas.EmailIdentifier;
};

export type EmailRoutingRoutingRulesGetCatchAllRuleError = Fetcher.ErrorWrapper<undefined>;

export type EmailRoutingRoutingRulesGetCatchAllRuleVariables = {
  pathParams: EmailRoutingRoutingRulesGetCatchAllRulePathParams;
} & FetcherExtraProps;

/**
 * Get information on the default catch-all routing rule.
 */
export const emailRoutingRoutingRulesGetCatchAllRule = (
  variables: EmailRoutingRoutingRulesGetCatchAllRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.EmailCatchAllRuleResponseSingle,
    EmailRoutingRoutingRulesGetCatchAllRuleError,
    undefined,
    {},
    {},
    EmailRoutingRoutingRulesGetCatchAllRulePathParams
  >({ url: '/zones/{zoneId}/email/routing/rules/catch_all', method: 'get', ...variables, signal });

export type EmailRoutingRoutingRulesUpdateCatchAllRulePathParams = {
  zoneId: Schemas.EmailIdentifier;
};

export type EmailRoutingRoutingRulesUpdateCatchAllRuleError = Fetcher.ErrorWrapper<undefined>;

export type EmailRoutingRoutingRulesUpdateCatchAllRuleVariables = {
  body: Schemas.EmailUpdateCatchAllRuleProperties;
  pathParams: EmailRoutingRoutingRulesUpdateCatchAllRulePathParams;
} & FetcherExtraProps;

/**
 * Enable or disable catch-all routing rule, or change action to forward to specific destination address.
 */
export const emailRoutingRoutingRulesUpdateCatchAllRule = (
  variables: EmailRoutingRoutingRulesUpdateCatchAllRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.EmailCatchAllRuleResponseSingle,
    EmailRoutingRoutingRulesUpdateCatchAllRuleError,
    Schemas.EmailUpdateCatchAllRuleProperties,
    {},
    {},
    EmailRoutingRoutingRulesUpdateCatchAllRulePathParams
  >({ url: '/zones/{zoneId}/email/routing/rules/catch_all', method: 'put', ...variables, signal });

export type EmailRoutingRoutingRulesDeleteRoutingRulePathParams = {
  ruleIdentifier: Schemas.EmailRuleIdentifier;
  zoneId: Schemas.EmailIdentifier;
};

export type EmailRoutingRoutingRulesDeleteRoutingRuleError = Fetcher.ErrorWrapper<undefined>;

export type EmailRoutingRoutingRulesDeleteRoutingRuleVariables = {
  pathParams: EmailRoutingRoutingRulesDeleteRoutingRulePathParams;
} & FetcherExtraProps;

/**
 * Delete a specific routing rule.
 */
export const emailRoutingRoutingRulesDeleteRoutingRule = (
  variables: EmailRoutingRoutingRulesDeleteRoutingRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.EmailRuleResponseSingle,
    EmailRoutingRoutingRulesDeleteRoutingRuleError,
    undefined,
    {},
    {},
    EmailRoutingRoutingRulesDeleteRoutingRulePathParams
  >({ url: '/zones/{zoneId}/email/routing/rules/{ruleIdentifier}', method: 'delete', ...variables, signal });

export type EmailRoutingRoutingRulesGetRoutingRulePathParams = {
  ruleIdentifier: Schemas.EmailRuleIdentifier;
  zoneId: Schemas.EmailIdentifier;
};

export type EmailRoutingRoutingRulesGetRoutingRuleError = Fetcher.ErrorWrapper<undefined>;

export type EmailRoutingRoutingRulesGetRoutingRuleVariables = {
  pathParams: EmailRoutingRoutingRulesGetRoutingRulePathParams;
} & FetcherExtraProps;

/**
 * Get information for a specific routing rule already created.
 */
export const emailRoutingRoutingRulesGetRoutingRule = (
  variables: EmailRoutingRoutingRulesGetRoutingRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.EmailRuleResponseSingle,
    EmailRoutingRoutingRulesGetRoutingRuleError,
    undefined,
    {},
    {},
    EmailRoutingRoutingRulesGetRoutingRulePathParams
  >({ url: '/zones/{zoneId}/email/routing/rules/{ruleIdentifier}', method: 'get', ...variables, signal });

export type EmailRoutingRoutingRulesUpdateRoutingRulePathParams = {
  ruleIdentifier: Schemas.EmailRuleIdentifier;
  zoneId: Schemas.EmailIdentifier;
};

export type EmailRoutingRoutingRulesUpdateRoutingRuleError = Fetcher.ErrorWrapper<undefined>;

export type EmailRoutingRoutingRulesUpdateRoutingRuleVariables = {
  body: Schemas.EmailUpdateRuleProperties;
  pathParams: EmailRoutingRoutingRulesUpdateRoutingRulePathParams;
} & FetcherExtraProps;

/**
 * Update actions and matches, or enable/disable specific routing rules.
 */
export const emailRoutingRoutingRulesUpdateRoutingRule = (
  variables: EmailRoutingRoutingRulesUpdateRoutingRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.EmailRuleResponseSingle,
    EmailRoutingRoutingRulesUpdateRoutingRuleError,
    Schemas.EmailUpdateRuleProperties,
    {},
    {},
    EmailRoutingRoutingRulesUpdateRoutingRulePathParams
  >({ url: '/zones/{zoneId}/email/routing/rules/{ruleIdentifier}', method: 'put', ...variables, signal });

export type FiltersDeleteFiltersPathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type FiltersDeleteFiltersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFilterDeleteResponseCollection & Schemas.FirewallApiResponseCommonFailure;
}>;

export type FiltersDeleteFiltersRequestBody = {
  id: Schemas.FirewallFiltersComponentsSchemasId;
};

export type FiltersDeleteFiltersVariables = {
  body: FiltersDeleteFiltersRequestBody;
  pathParams: FiltersDeleteFiltersPathParams;
} & FetcherExtraProps;

/**
 * Deletes one or more existing filters.
 */
export const filtersDeleteFilters = (variables: FiltersDeleteFiltersVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.FirewallFilterDeleteResponseCollection,
    FiltersDeleteFiltersError,
    FiltersDeleteFiltersRequestBody,
    {},
    {},
    FiltersDeleteFiltersPathParams
  >({ url: '/zones/{zoneId}/filters', method: 'delete', ...variables, signal });

export type FiltersListFiltersPathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type FiltersListFiltersQueryParams = {
  paused?: Schemas.FirewallFiltersComponentsSchemasPaused;
  /**
   * @example php
   */
  expression?: string;
  /**
   * @example browsers
   */
  description?: string;
  /**
   * @example FIL-100
   */
  ref?: string;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 25
   * @maximum 100
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example 372e67954025e0ba6aaa6d586b9e0b61
   * @maxLength 32
   * @minLength 32
   */
  id?: string;
};

export type FiltersListFiltersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFilterResponseCollection & Schemas.FirewallApiResponseCommonFailure;
}>;

export type FiltersListFiltersVariables = {
  pathParams: FiltersListFiltersPathParams;
  queryParams?: FiltersListFiltersQueryParams;
} & FetcherExtraProps;

/**
 * Fetches filters in a zone. You can filter the results using several optional parameters.
 */
export const filtersListFilters = (variables: FiltersListFiltersVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.FirewallFilterResponseCollection,
    FiltersListFiltersError,
    undefined,
    {},
    FiltersListFiltersQueryParams,
    FiltersListFiltersPathParams
  >({ url: '/zones/{zoneId}/filters', method: 'get', ...variables, signal });

export type FiltersCreateFiltersPathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type FiltersCreateFiltersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFilterResponseCollection & Schemas.FirewallApiResponseCommonFailure;
}>;

export type FiltersCreateFiltersResponse = Schemas.FirewallFilterResponseCollection;

export type FiltersCreateFiltersRequestBody = {
  expression: Schemas.FirewallExpression;
};

export type FiltersCreateFiltersVariables = {
  body: FiltersCreateFiltersRequestBody;
  pathParams: FiltersCreateFiltersPathParams;
} & FetcherExtraProps;

/**
 * Creates one or more filters.
 */
export const filtersCreateFilters = (variables: FiltersCreateFiltersVariables, signal?: AbortSignal) =>
  fetch<
    FiltersCreateFiltersResponse,
    FiltersCreateFiltersError,
    FiltersCreateFiltersRequestBody,
    {},
    {},
    FiltersCreateFiltersPathParams
  >({ url: '/zones/{zoneId}/filters', method: 'post', ...variables, signal });

export type FiltersUpdateFiltersPathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type FiltersUpdateFiltersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFilterResponseCollection & Schemas.FirewallApiResponseCommonFailure;
}>;

export type FiltersUpdateFiltersRequestBody = {
  id: Schemas.FirewallComponentsSchemasIdentifier;
};

export type FiltersUpdateFiltersVariables = {
  body: FiltersUpdateFiltersRequestBody;
  pathParams: FiltersUpdateFiltersPathParams;
} & FetcherExtraProps;

/**
 * Updates one or more existing filters.
 */
export const filtersUpdateFilters = (variables: FiltersUpdateFiltersVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.FirewallFilterResponseCollection,
    FiltersUpdateFiltersError,
    FiltersUpdateFiltersRequestBody,
    {},
    {},
    FiltersUpdateFiltersPathParams
  >({ url: '/zones/{zoneId}/filters', method: 'put', ...variables, signal });

export type FiltersDeleteAFilterPathParams = {
  filterId: Schemas.FirewallFiltersComponentsSchemasId;
  zoneId: Schemas.FirewallIdentifier;
};

export type FiltersDeleteAFilterError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFilterDeleteResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type FiltersDeleteAFilterVariables = {
  pathParams: FiltersDeleteAFilterPathParams;
} & FetcherExtraProps;

/**
 * Deletes an existing filter.
 */
export const filtersDeleteAFilter = (variables: FiltersDeleteAFilterVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.FirewallFilterDeleteResponseSingle,
    FiltersDeleteAFilterError,
    undefined,
    {},
    {},
    FiltersDeleteAFilterPathParams
  >({ url: '/zones/{zoneId}/filters/{filterId}', method: 'delete', ...variables, signal });

export type FiltersGetAFilterPathParams = {
  filterId: Schemas.FirewallFiltersComponentsSchemasId;
  zoneId: Schemas.FirewallIdentifier;
};

export type FiltersGetAFilterError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFilterResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type FiltersGetAFilterVariables = {
  pathParams: FiltersGetAFilterPathParams;
} & FetcherExtraProps;

/**
 * Fetches the details of a filter.
 */
export const filtersGetAFilter = (variables: FiltersGetAFilterVariables, signal?: AbortSignal) =>
  fetch<Schemas.FirewallFilterResponseSingle, FiltersGetAFilterError, undefined, {}, {}, FiltersGetAFilterPathParams>({
    url: '/zones/{zoneId}/filters/{filterId}',
    method: 'get',
    ...variables,
    signal
  });

export type FiltersUpdateAFilterPathParams = {
  filterId: Schemas.FirewallFiltersComponentsSchemasId;
  zoneId: Schemas.FirewallIdentifier;
};

export type FiltersUpdateAFilterError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFilterResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type FiltersUpdateAFilterVariables = {
  body: void;
  pathParams: FiltersUpdateAFilterPathParams;
} & FetcherExtraProps;

/**
 * Updates an existing filter.
 */
export const filtersUpdateAFilter = (variables: FiltersUpdateAFilterVariables, signal?: AbortSignal) =>
  fetch<Schemas.FirewallFilterResponseSingle, FiltersUpdateAFilterError, void, {}, {}, FiltersUpdateAFilterPathParams>({
    url: '/zones/{zoneId}/filters/{filterId}',
    method: 'put',
    ...variables,
    signal
  });

export type IpAccessRulesForAZoneListIpAccessRulesPathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type IpAccessRulesForAZoneListIpAccessRulesQueryParams = {
  mode?: Schemas.FirewallSchemasMode;
  /**
   * @example ip
   */
  ['configuration.target']?: 'ip' | 'ip_range' | 'asn' | 'country';
  /**
   * @example 198.51.100.4
   */
  ['configuration.value']?: string;
  /**
   * @example my note
   */
  notes?: string;
  /**
   * @default all
   */
  match?: 'any' | 'all';
  /**
   * @example 1
   */
  page?: number;
  /**
   * @example 20
   */
  per_page?: number;
  /**
   * @example mode
   */
  order?: 'configuration.target' | 'configuration.value' | 'mode';
  /**
   * @example desc
   */
  direction?: 'asc' | 'desc';
};

export type IpAccessRulesForAZoneListIpAccessRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallRuleCollectionResponse & Schemas.FirewallApiResponseCommonFailure;
}>;

export type IpAccessRulesForAZoneListIpAccessRulesVariables = {
  pathParams: IpAccessRulesForAZoneListIpAccessRulesPathParams;
  queryParams?: IpAccessRulesForAZoneListIpAccessRulesQueryParams;
} & FetcherExtraProps;

/**
 * Fetches IP Access rules of a zone. You can filter the results using several optional parameters.
 */
export const ipAccessRulesForAZoneListIpAccessRules = (
  variables: IpAccessRulesForAZoneListIpAccessRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallRuleCollectionResponse,
    IpAccessRulesForAZoneListIpAccessRulesError,
    undefined,
    {},
    IpAccessRulesForAZoneListIpAccessRulesQueryParams,
    IpAccessRulesForAZoneListIpAccessRulesPathParams
  >({ url: '/zones/{zoneId}/firewall/access_rules/rules', method: 'get', ...variables, signal });

export type IpAccessRulesForAZoneCreateAnIpAccessRulePathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type IpAccessRulesForAZoneCreateAnIpAccessRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallRuleSingleResponse & Schemas.FirewallApiResponseCommonFailure;
}>;

export type IpAccessRulesForAZoneCreateAnIpAccessRuleRequestBody = {
  configuration: Schemas.FirewallConfiguration;
  mode: Schemas.FirewallSchemasMode;
  notes: Schemas.FirewallNotes;
};

export type IpAccessRulesForAZoneCreateAnIpAccessRuleVariables = {
  body: IpAccessRulesForAZoneCreateAnIpAccessRuleRequestBody;
  pathParams: IpAccessRulesForAZoneCreateAnIpAccessRulePathParams;
} & FetcherExtraProps;

/**
 * Creates a new IP Access rule for a zone.
 *
 * Note: To create an IP Access rule that applies to multiple zones, refer to [IP Access rules for a user](#ip-access-rules-for-a-user) or [IP Access rules for an account](#ip-access-rules-for-an-account) as appropriate.
 */
export const ipAccessRulesForAZoneCreateAnIpAccessRule = (
  variables: IpAccessRulesForAZoneCreateAnIpAccessRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallRuleSingleResponse,
    IpAccessRulesForAZoneCreateAnIpAccessRuleError,
    IpAccessRulesForAZoneCreateAnIpAccessRuleRequestBody,
    {},
    {},
    IpAccessRulesForAZoneCreateAnIpAccessRulePathParams
  >({ url: '/zones/{zoneId}/firewall/access_rules/rules', method: 'post', ...variables, signal });

export type IpAccessRulesForAZoneDeleteAnIpAccessRulePathParams = {
  zoneId: Schemas.FirewallIdentifier;
  ruleId: Schemas.FirewallRuleIdentifier;
};

export type IpAccessRulesForAZoneDeleteAnIpAccessRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallRuleSingleIdResponse & Schemas.FirewallApiResponseCommonFailure;
}>;

export type IpAccessRulesForAZoneDeleteAnIpAccessRuleRequestBody = {
  /**
   * The level to attempt to delete similar rules defined for other zones with the same owner. The default value is `none`, which will only delete the current rule. Using `basic` will delete rules that match the same action (mode) and configuration, while using `aggressive` will delete rules that match the same configuration.
   *
   * @default none
   */
  cascade?: 'none' | 'basic' | 'aggressive';
};

export type IpAccessRulesForAZoneDeleteAnIpAccessRuleVariables = {
  body?: IpAccessRulesForAZoneDeleteAnIpAccessRuleRequestBody;
  pathParams: IpAccessRulesForAZoneDeleteAnIpAccessRulePathParams;
} & FetcherExtraProps;

/**
 * Deletes an IP Access rule defined at the zone level.
 *
 * Optionally, you can use the `cascade` property to specify that you wish to delete similar rules in other zones managed by the same zone owner.
 */
export const ipAccessRulesForAZoneDeleteAnIpAccessRule = (
  variables: IpAccessRulesForAZoneDeleteAnIpAccessRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallRuleSingleIdResponse,
    IpAccessRulesForAZoneDeleteAnIpAccessRuleError,
    IpAccessRulesForAZoneDeleteAnIpAccessRuleRequestBody,
    {},
    {},
    IpAccessRulesForAZoneDeleteAnIpAccessRulePathParams
  >({ url: '/zones/{zoneId}/firewall/access_rules/rules/{ruleId}', method: 'delete', ...variables, signal });

export type IpAccessRulesForAZoneUpdateAnIpAccessRulePathParams = {
  zoneId: Schemas.FirewallIdentifier;
  ruleId: Schemas.FirewallRuleIdentifier;
};

export type IpAccessRulesForAZoneUpdateAnIpAccessRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallRuleSingleResponse & Schemas.FirewallApiResponseCommonFailure;
}>;

export type IpAccessRulesForAZoneUpdateAnIpAccessRuleRequestBody = {
  mode?: Schemas.FirewallSchemasMode;
  notes?: Schemas.FirewallNotes;
};

export type IpAccessRulesForAZoneUpdateAnIpAccessRuleVariables = {
  body?: IpAccessRulesForAZoneUpdateAnIpAccessRuleRequestBody;
  pathParams: IpAccessRulesForAZoneUpdateAnIpAccessRulePathParams;
} & FetcherExtraProps;

/**
 * Updates an IP Access rule defined at the zone level. You can only update the rule action (`mode` parameter) and notes.
 */
export const ipAccessRulesForAZoneUpdateAnIpAccessRule = (
  variables: IpAccessRulesForAZoneUpdateAnIpAccessRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallRuleSingleResponse,
    IpAccessRulesForAZoneUpdateAnIpAccessRuleError,
    IpAccessRulesForAZoneUpdateAnIpAccessRuleRequestBody,
    {},
    {},
    IpAccessRulesForAZoneUpdateAnIpAccessRulePathParams
  >({ url: '/zones/{zoneId}/firewall/access_rules/rules/{ruleId}', method: 'patch', ...variables, signal });

export type ZoneLockdownListZoneLockdownRulesPathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type ZoneLockdownListZoneLockdownRulesQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * A string to search for in the description of existing rules.
   *
   * @example endpoints
   */
  description?: Schemas.FirewallSchemasDescriptionSearch;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: Schemas.FirewallModifiedOn;
  /**
   * A single IP address to search for in existing rules.
   *
   * @example 1.2.3.4
   */
  ip?: Schemas.FirewallIpSearch;
  /**
   * The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
   *
   * @example 5
   */
  priority?: Schemas.FirewallSchemasPriority;
  /**
   * A single URI to search for in the list of URLs of existing rules.
   *
   * @example /some/path
   */
  uri_search?: Schemas.FirewallUriSearch;
  /**
   * A single IP address range to search for in existing rules.
   *
   * @example 1.2.3.0/16
   */
  ip_range_search?: Schemas.FirewallIpRangeSearch;
  /**
   * @default 20
   * @maximum 1000
   * @minimum 1
   */
  per_page?: number;
  /**
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  created_on?: string;
  /**
   * @example endpoints
   */
  description_search?: string;
  /**
   * @example 1.2.3.4
   */
  ip_search?: string;
};

export type ZoneLockdownListZoneLockdownRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallZonelockdownResponseCollection & Schemas.FirewallApiResponseCommonFailure;
}>;

export type ZoneLockdownListZoneLockdownRulesVariables = {
  pathParams: ZoneLockdownListZoneLockdownRulesPathParams;
  queryParams?: ZoneLockdownListZoneLockdownRulesQueryParams;
} & FetcherExtraProps;

/**
 * Fetches Zone Lockdown rules. You can filter the results using several optional parameters.
 */
export const zoneLockdownListZoneLockdownRules = (
  variables: ZoneLockdownListZoneLockdownRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallZonelockdownResponseCollection,
    ZoneLockdownListZoneLockdownRulesError,
    undefined,
    {},
    ZoneLockdownListZoneLockdownRulesQueryParams,
    ZoneLockdownListZoneLockdownRulesPathParams
  >({ url: '/zones/{zoneId}/firewall/lockdowns', method: 'get', ...variables, signal });

export type ZoneLockdownCreateAZoneLockdownRulePathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type ZoneLockdownCreateAZoneLockdownRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallZonelockdownResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type ZoneLockdownCreateAZoneLockdownRuleRequestBody = {
  configurations: Schemas.FirewallConfigurations;
  urls: Schemas.FirewallUrls;
};

export type ZoneLockdownCreateAZoneLockdownRuleVariables = {
  body: ZoneLockdownCreateAZoneLockdownRuleRequestBody;
  pathParams: ZoneLockdownCreateAZoneLockdownRulePathParams;
} & FetcherExtraProps;

/**
 * Creates a new Zone Lockdown rule.
 */
export const zoneLockdownCreateAZoneLockdownRule = (
  variables: ZoneLockdownCreateAZoneLockdownRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallZonelockdownResponseSingle,
    ZoneLockdownCreateAZoneLockdownRuleError,
    ZoneLockdownCreateAZoneLockdownRuleRequestBody,
    {},
    {},
    ZoneLockdownCreateAZoneLockdownRulePathParams
  >({ url: '/zones/{zoneId}/firewall/lockdowns', method: 'post', ...variables, signal });

export type ZoneLockdownDeleteAZoneLockdownRulePathParams = {
  lockDownsId: Schemas.FirewallLockdownsComponentsSchemasId;
  zoneId: Schemas.FirewallIdentifier;
};

export type ZoneLockdownDeleteAZoneLockdownRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    result: any | null;
    /**
     * @example {"code":7003,"message":"No route for the URI"}
     * @minLength 1
     */
    errors: Schemas.FirewallMessages;
    messages: Schemas.FirewallMessages;
    /**
     * Whether the API call was successful
     *
     * @example false
     */
    success: false;
  };
}>;

export type ZoneLockdownDeleteAZoneLockdownRuleResponse = {
  result?: {
    id?: Schemas.FirewallLockdownsComponentsSchemasId;
  };
};

export type ZoneLockdownDeleteAZoneLockdownRuleVariables = {
  pathParams: ZoneLockdownDeleteAZoneLockdownRulePathParams;
} & FetcherExtraProps;

/**
 * Deletes an existing Zone Lockdown rule.
 */
export const zoneLockdownDeleteAZoneLockdownRule = (
  variables: ZoneLockdownDeleteAZoneLockdownRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneLockdownDeleteAZoneLockdownRuleResponse,
    ZoneLockdownDeleteAZoneLockdownRuleError,
    undefined,
    {},
    {},
    ZoneLockdownDeleteAZoneLockdownRulePathParams
  >({ url: '/zones/{zoneId}/firewall/lockdowns/{lockDownsId}', method: 'delete', ...variables, signal });

export type ZoneLockdownGetAZoneLockdownRulePathParams = {
  lockDownsId: Schemas.FirewallLockdownsComponentsSchemasId;
  zoneId: Schemas.FirewallIdentifier;
};

export type ZoneLockdownGetAZoneLockdownRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallZonelockdownResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type ZoneLockdownGetAZoneLockdownRuleVariables = {
  pathParams: ZoneLockdownGetAZoneLockdownRulePathParams;
} & FetcherExtraProps;

/**
 * Fetches the details of a Zone Lockdown rule.
 */
export const zoneLockdownGetAZoneLockdownRule = (
  variables: ZoneLockdownGetAZoneLockdownRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallZonelockdownResponseSingle,
    ZoneLockdownGetAZoneLockdownRuleError,
    undefined,
    {},
    {},
    ZoneLockdownGetAZoneLockdownRulePathParams
  >({ url: '/zones/{zoneId}/firewall/lockdowns/{lockDownsId}', method: 'get', ...variables, signal });

export type ZoneLockdownUpdateAZoneLockdownRulePathParams = {
  lockDownsId: Schemas.FirewallLockdownsComponentsSchemasId;
  zoneId: Schemas.FirewallIdentifier;
};

export type ZoneLockdownUpdateAZoneLockdownRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallZonelockdownResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type ZoneLockdownUpdateAZoneLockdownRuleRequestBody = {
  configurations: Schemas.FirewallConfigurations;
  urls: Schemas.FirewallUrls;
};

export type ZoneLockdownUpdateAZoneLockdownRuleVariables = {
  body: ZoneLockdownUpdateAZoneLockdownRuleRequestBody;
  pathParams: ZoneLockdownUpdateAZoneLockdownRulePathParams;
} & FetcherExtraProps;

/**
 * Updates an existing Zone Lockdown rule.
 */
export const zoneLockdownUpdateAZoneLockdownRule = (
  variables: ZoneLockdownUpdateAZoneLockdownRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallZonelockdownResponseSingle,
    ZoneLockdownUpdateAZoneLockdownRuleError,
    ZoneLockdownUpdateAZoneLockdownRuleRequestBody,
    {},
    {},
    ZoneLockdownUpdateAZoneLockdownRulePathParams
  >({ url: '/zones/{zoneId}/firewall/lockdowns/{lockDownsId}', method: 'put', ...variables, signal });

export type FirewallRulesDeleteFirewallRulesPathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type FirewallRulesDeleteFirewallRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFilterRulesResponseCollectionDelete & Schemas.FirewallApiResponseCommonFailure;
}>;

export type FirewallRulesDeleteFirewallRulesRequestBody = {
  id: Schemas.FirewallFirewallRulesComponentsSchemasId;
};

export type FirewallRulesDeleteFirewallRulesVariables = {
  body: FirewallRulesDeleteFirewallRulesRequestBody;
  pathParams: FirewallRulesDeleteFirewallRulesPathParams;
} & FetcherExtraProps;

/**
 * Deletes existing firewall rules.
 */
export const firewallRulesDeleteFirewallRules = (
  variables: FirewallRulesDeleteFirewallRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallFilterRulesResponseCollectionDelete,
    FirewallRulesDeleteFirewallRulesError,
    FirewallRulesDeleteFirewallRulesRequestBody,
    {},
    {},
    FirewallRulesDeleteFirewallRulesPathParams
  >({ url: '/zones/{zoneId}/firewall/rules', method: 'delete', ...variables, signal });

export type FirewallRulesListFirewallRulesPathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type FirewallRulesListFirewallRulesQueryParams = {
  /**
   * @example mir
   */
  description?: string;
  /**
   * @example block
   */
  action?: string;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 25
   * @maximum 100
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example 372e67954025e0ba6aaa6d586b9e0b60
   * @maxLength 32
   */
  id?: string;
  /**
   * @example false
   */
  paused?: boolean;
};

export type FirewallRulesListFirewallRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFilterRulesResponseCollection & Schemas.FirewallApiResponseCommonFailure;
}>;

export type FirewallRulesListFirewallRulesVariables = {
  pathParams: FirewallRulesListFirewallRulesPathParams;
  queryParams?: FirewallRulesListFirewallRulesQueryParams;
} & FetcherExtraProps;

/**
 * Fetches firewall rules in a zone. You can filter the results using several optional parameters.
 */
export const firewallRulesListFirewallRules = (
  variables: FirewallRulesListFirewallRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallFilterRulesResponseCollection,
    FirewallRulesListFirewallRulesError,
    undefined,
    {},
    FirewallRulesListFirewallRulesQueryParams,
    FirewallRulesListFirewallRulesPathParams
  >({ url: '/zones/{zoneId}/firewall/rules', method: 'get', ...variables, signal });

export type FirewallRulesUpdatePriorityOfFirewallRulesPathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type FirewallRulesUpdatePriorityOfFirewallRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFilterRulesResponseCollection & Schemas.FirewallApiResponseCommonFailure;
}>;

export type FirewallRulesUpdatePriorityOfFirewallRulesVariables = {
  body: void;
  pathParams: FirewallRulesUpdatePriorityOfFirewallRulesPathParams;
} & FetcherExtraProps;

/**
 * Updates the priority of existing firewall rules.
 */
export const firewallRulesUpdatePriorityOfFirewallRules = (
  variables: FirewallRulesUpdatePriorityOfFirewallRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallFilterRulesResponseCollection,
    FirewallRulesUpdatePriorityOfFirewallRulesError,
    void,
    {},
    {},
    FirewallRulesUpdatePriorityOfFirewallRulesPathParams
  >({ url: '/zones/{zoneId}/firewall/rules', method: 'patch', ...variables, signal });

export type FirewallRulesCreateFirewallRulesPathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type FirewallRulesCreateFirewallRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFilterRulesResponseCollection & Schemas.FirewallApiResponseCommonFailure;
}>;

export type FirewallRulesCreateFirewallRulesRequestBody = {
  action: Schemas.FirewallAction;
  filter: Schemas.FirewallFilter;
};

export type FirewallRulesCreateFirewallRulesVariables = {
  body: FirewallRulesCreateFirewallRulesRequestBody;
  pathParams: FirewallRulesCreateFirewallRulesPathParams;
} & FetcherExtraProps;

/**
 * Create one or more firewall rules.
 */
export const firewallRulesCreateFirewallRules = (
  variables: FirewallRulesCreateFirewallRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallFilterRulesResponseCollection,
    FirewallRulesCreateFirewallRulesError,
    FirewallRulesCreateFirewallRulesRequestBody,
    {},
    {},
    FirewallRulesCreateFirewallRulesPathParams
  >({ url: '/zones/{zoneId}/firewall/rules', method: 'post', ...variables, signal });

export type FirewallRulesUpdateFirewallRulesPathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type FirewallRulesUpdateFirewallRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFilterRulesResponseCollection & Schemas.FirewallApiResponseCommonFailure;
}>;

export type FirewallRulesUpdateFirewallRulesVariables = {
  body: void;
  pathParams: FirewallRulesUpdateFirewallRulesPathParams;
} & FetcherExtraProps;

/**
 * Updates one or more existing firewall rules.
 */
export const firewallRulesUpdateFirewallRules = (
  variables: FirewallRulesUpdateFirewallRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallFilterRulesResponseCollection,
    FirewallRulesUpdateFirewallRulesError,
    void,
    {},
    {},
    FirewallRulesUpdateFirewallRulesPathParams
  >({ url: '/zones/{zoneId}/firewall/rules', method: 'put', ...variables, signal });

export type FirewallRulesDeleteAFirewallRulePathParams = {
  ruleId: Schemas.FirewallFirewallRulesComponentsSchemasId;
  zoneId: Schemas.FirewallIdentifier;
};

export type FirewallRulesDeleteAFirewallRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFilterRulesSingleResponseDelete & Schemas.FirewallApiResponseCommonFailure;
}>;

export type FirewallRulesDeleteAFirewallRuleRequestBody = {
  delete_filter_if_unused?: Schemas.FirewallDeleteFilterIfUnused;
};

export type FirewallRulesDeleteAFirewallRuleVariables = {
  body?: FirewallRulesDeleteAFirewallRuleRequestBody;
  pathParams: FirewallRulesDeleteAFirewallRulePathParams;
} & FetcherExtraProps;

/**
 * Deletes an existing firewall rule.
 */
export const firewallRulesDeleteAFirewallRule = (
  variables: FirewallRulesDeleteAFirewallRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallFilterRulesSingleResponseDelete,
    FirewallRulesDeleteAFirewallRuleError,
    FirewallRulesDeleteAFirewallRuleRequestBody,
    {},
    {},
    FirewallRulesDeleteAFirewallRulePathParams
  >({ url: '/zones/{zoneId}/firewall/rules/{ruleId}', method: 'delete', ...variables, signal });

export type FirewallRulesGetAFirewallRulePathParams = {
  ruleId: Schemas.FirewallFirewallRulesComponentsSchemasId;
  zoneId: Schemas.FirewallIdentifier;
};

export type FirewallRulesGetAFirewallRuleQueryParams = {
  /**
   * The unique identifier of the firewall rule.
   *
   * @example 372e67954025e0ba6aaa6d586b9e0b60
   * @maxLength 32
   */
  id?: Schemas.FirewallFirewallRulesComponentsSchemasId;
};

export type FirewallRulesGetAFirewallRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFilterRulesSingleResponse & Schemas.FirewallApiResponseCommonFailure;
}>;

export type FirewallRulesGetAFirewallRuleVariables = {
  pathParams: FirewallRulesGetAFirewallRulePathParams;
  queryParams?: FirewallRulesGetAFirewallRuleQueryParams;
} & FetcherExtraProps;

/**
 * Fetches the details of a firewall rule.
 */
export const firewallRulesGetAFirewallRule = (
  variables: FirewallRulesGetAFirewallRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallFilterRulesSingleResponse,
    FirewallRulesGetAFirewallRuleError,
    undefined,
    {},
    FirewallRulesGetAFirewallRuleQueryParams,
    FirewallRulesGetAFirewallRulePathParams
  >({ url: '/zones/{zoneId}/firewall/rules/{ruleId}', method: 'get', ...variables, signal });

export type FirewallRulesUpdatePriorityOfAFirewallRulePathParams = {
  ruleId: Schemas.FirewallFirewallRulesComponentsSchemasId;
  zoneId: Schemas.FirewallIdentifier;
};

export type FirewallRulesUpdatePriorityOfAFirewallRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFilterRulesResponseCollection & Schemas.FirewallApiResponseCommonFailure;
}>;

export type FirewallRulesUpdatePriorityOfAFirewallRuleRequestBody = {
  id: Schemas.FirewallComponentsSchemasIdentifier;
};

export type FirewallRulesUpdatePriorityOfAFirewallRuleVariables = {
  body: FirewallRulesUpdatePriorityOfAFirewallRuleRequestBody;
  pathParams: FirewallRulesUpdatePriorityOfAFirewallRulePathParams;
} & FetcherExtraProps;

/**
 * Updates the priority of an existing firewall rule.
 */
export const firewallRulesUpdatePriorityOfAFirewallRule = (
  variables: FirewallRulesUpdatePriorityOfAFirewallRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallFilterRulesResponseCollection,
    FirewallRulesUpdatePriorityOfAFirewallRuleError,
    FirewallRulesUpdatePriorityOfAFirewallRuleRequestBody,
    {},
    {},
    FirewallRulesUpdatePriorityOfAFirewallRulePathParams
  >({ url: '/zones/{zoneId}/firewall/rules/{ruleId}', method: 'patch', ...variables, signal });

export type FirewallRulesUpdateAFirewallRulePathParams = {
  ruleId: Schemas.FirewallFirewallRulesComponentsSchemasId;
  zoneId: Schemas.FirewallIdentifier;
};

export type FirewallRulesUpdateAFirewallRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFilterRulesSingleResponse & Schemas.FirewallApiResponseCommonFailure;
}>;

export type FirewallRulesUpdateAFirewallRuleRequestBody = {
  action: Schemas.FirewallAction;
  filter: Schemas.FirewallFilter;
  id: Schemas.FirewallComponentsSchemasIdentifier;
};

export type FirewallRulesUpdateAFirewallRuleVariables = {
  body: FirewallRulesUpdateAFirewallRuleRequestBody;
  pathParams: FirewallRulesUpdateAFirewallRulePathParams;
} & FetcherExtraProps;

/**
 * Updates an existing firewall rule.
 */
export const firewallRulesUpdateAFirewallRule = (
  variables: FirewallRulesUpdateAFirewallRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallFilterRulesSingleResponse,
    FirewallRulesUpdateAFirewallRuleError,
    FirewallRulesUpdateAFirewallRuleRequestBody,
    {},
    {},
    FirewallRulesUpdateAFirewallRulePathParams
  >({ url: '/zones/{zoneId}/firewall/rules/{ruleId}', method: 'put', ...variables, signal });

export type UserAgentBlockingRulesListUserAgentBlockingRulesPathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type UserAgentBlockingRulesListUserAgentBlockingRulesQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * A string to search for in the description of existing rules.
   *
   * @example abusive
   */
  description?: Schemas.FirewallDescriptionSearch;
  /**
   * A string to search for in the description of existing rules.
   *
   * @example abusive
   */
  description_search?: Schemas.FirewallDescriptionSearch;
  /**
   * @default 20
   * @maximum 1000
   * @minimum 1
   */
  per_page?: number;
  /**
   * @example Safari
   */
  ua_search?: string;
};

export type UserAgentBlockingRulesListUserAgentBlockingRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFirewalluablockResponseCollection & Schemas.FirewallApiResponseCommonFailure;
}>;

export type UserAgentBlockingRulesListUserAgentBlockingRulesVariables = {
  pathParams: UserAgentBlockingRulesListUserAgentBlockingRulesPathParams;
  queryParams?: UserAgentBlockingRulesListUserAgentBlockingRulesQueryParams;
} & FetcherExtraProps;

/**
 * Fetches User Agent Blocking rules in a zone. You can filter the results using several optional parameters.
 */
export const userAgentBlockingRulesListUserAgentBlockingRules = (
  variables: UserAgentBlockingRulesListUserAgentBlockingRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallFirewalluablockResponseCollection,
    UserAgentBlockingRulesListUserAgentBlockingRulesError,
    undefined,
    {},
    UserAgentBlockingRulesListUserAgentBlockingRulesQueryParams,
    UserAgentBlockingRulesListUserAgentBlockingRulesPathParams
  >({ url: '/zones/{zoneId}/firewall/ua_rules', method: 'get', ...variables, signal });

export type UserAgentBlockingRulesCreateAUserAgentBlockingRulePathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type UserAgentBlockingRulesCreateAUserAgentBlockingRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFirewalluablockResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type UserAgentBlockingRulesCreateAUserAgentBlockingRuleRequestBody = {
  configuration: Schemas.FirewallConfiguration;
  mode: Schemas.FirewallSchemasMode;
};

export type UserAgentBlockingRulesCreateAUserAgentBlockingRuleVariables = {
  body: UserAgentBlockingRulesCreateAUserAgentBlockingRuleRequestBody;
  pathParams: UserAgentBlockingRulesCreateAUserAgentBlockingRulePathParams;
} & FetcherExtraProps;

/**
 * Creates a new User Agent Blocking rule in a zone.
 */
export const userAgentBlockingRulesCreateAUserAgentBlockingRule = (
  variables: UserAgentBlockingRulesCreateAUserAgentBlockingRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallFirewalluablockResponseSingle,
    UserAgentBlockingRulesCreateAUserAgentBlockingRuleError,
    UserAgentBlockingRulesCreateAUserAgentBlockingRuleRequestBody,
    {},
    {},
    UserAgentBlockingRulesCreateAUserAgentBlockingRulePathParams
  >({ url: '/zones/{zoneId}/firewall/ua_rules', method: 'post', ...variables, signal });

export type UserAgentBlockingRulesDeleteAUserAgentBlockingRulePathParams = {
  uaRuleId: Schemas.FirewallComponentsUaRuleId;
  zoneId: Schemas.FirewallIdentifier;
};

export type UserAgentBlockingRulesDeleteAUserAgentBlockingRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.FirewallFirewalluablockResponseSingle & {
    result?: {
      id?: Schemas.FirewallComponentsUaRuleId;
    };
  }) &
    Schemas.FirewallApiResponseCommonFailure;
}>;

export type UserAgentBlockingRulesDeleteAUserAgentBlockingRuleResponse =
  Schemas.FirewallFirewalluablockResponseSingle & {
    result?: {
      id?: Schemas.FirewallComponentsUaRuleId;
    };
  };

export type UserAgentBlockingRulesDeleteAUserAgentBlockingRuleVariables = {
  pathParams: UserAgentBlockingRulesDeleteAUserAgentBlockingRulePathParams;
} & FetcherExtraProps;

/**
 * Deletes an existing User Agent Blocking rule.
 */
export const userAgentBlockingRulesDeleteAUserAgentBlockingRule = (
  variables: UserAgentBlockingRulesDeleteAUserAgentBlockingRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    UserAgentBlockingRulesDeleteAUserAgentBlockingRuleResponse,
    UserAgentBlockingRulesDeleteAUserAgentBlockingRuleError,
    undefined,
    {},
    {},
    UserAgentBlockingRulesDeleteAUserAgentBlockingRulePathParams
  >({ url: '/zones/{zoneId}/firewall/ua_rules/{uaRuleId}', method: 'delete', ...variables, signal });

export type UserAgentBlockingRulesGetAUserAgentBlockingRulePathParams = {
  uaRuleId: Schemas.FirewallComponentsUaRuleId;
  zoneId: Schemas.FirewallIdentifier;
};

export type UserAgentBlockingRulesGetAUserAgentBlockingRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFirewalluablockResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type UserAgentBlockingRulesGetAUserAgentBlockingRuleVariables = {
  pathParams: UserAgentBlockingRulesGetAUserAgentBlockingRulePathParams;
} & FetcherExtraProps;

/**
 * Fetches the details of a User Agent Blocking rule.
 */
export const userAgentBlockingRulesGetAUserAgentBlockingRule = (
  variables: UserAgentBlockingRulesGetAUserAgentBlockingRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallFirewalluablockResponseSingle,
    UserAgentBlockingRulesGetAUserAgentBlockingRuleError,
    undefined,
    {},
    {},
    UserAgentBlockingRulesGetAUserAgentBlockingRulePathParams
  >({ url: '/zones/{zoneId}/firewall/ua_rules/{uaRuleId}', method: 'get', ...variables, signal });

export type UserAgentBlockingRulesUpdateAUserAgentBlockingRulePathParams = {
  uaRuleId: Schemas.FirewallComponentsUaRuleId;
  zoneId: Schemas.FirewallIdentifier;
};

export type UserAgentBlockingRulesUpdateAUserAgentBlockingRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallFirewalluablockResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type UserAgentBlockingRulesUpdateAUserAgentBlockingRuleRequestBody = {
  configuration: Schemas.FirewallConfiguration;
  id: Schemas.FirewallComponentsSchemasIdentifier;
  mode: Schemas.FirewallSchemasMode;
};

export type UserAgentBlockingRulesUpdateAUserAgentBlockingRuleVariables = {
  body: UserAgentBlockingRulesUpdateAUserAgentBlockingRuleRequestBody;
  pathParams: UserAgentBlockingRulesUpdateAUserAgentBlockingRulePathParams;
} & FetcherExtraProps;

/**
 * Updates an existing User Agent Blocking rule.
 */
export const userAgentBlockingRulesUpdateAUserAgentBlockingRule = (
  variables: UserAgentBlockingRulesUpdateAUserAgentBlockingRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallFirewalluablockResponseSingle,
    UserAgentBlockingRulesUpdateAUserAgentBlockingRuleError,
    UserAgentBlockingRulesUpdateAUserAgentBlockingRuleRequestBody,
    {},
    {},
    UserAgentBlockingRulesUpdateAUserAgentBlockingRulePathParams
  >({ url: '/zones/{zoneId}/firewall/ua_rules/{uaRuleId}', method: 'put', ...variables, signal });

export type WafOverridesListWafOverridesPathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type WafOverridesListWafOverridesQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 50
   * @maximum 100
   * @minimum 5
   */
  per_page?: number;
};

export type WafOverridesListWafOverridesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallOverrideResponseCollection & Schemas.FirewallApiResponseCommonFailure;
}>;

export type WafOverridesListWafOverridesVariables = {
  pathParams: WafOverridesListWafOverridesPathParams;
  queryParams?: WafOverridesListWafOverridesQueryParams;
} & FetcherExtraProps;

/**
 * Fetches the URI-based WAF overrides in a zone.
 *
 * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
 */
export const wafOverridesListWafOverrides = (variables: WafOverridesListWafOverridesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.FirewallOverrideResponseCollection,
    WafOverridesListWafOverridesError,
    undefined,
    {},
    WafOverridesListWafOverridesQueryParams,
    WafOverridesListWafOverridesPathParams
  >({ url: '/zones/{zoneId}/firewall/waf/overrides', method: 'get', ...variables, signal });

export type WafOverridesCreateAWafOverridePathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type WafOverridesCreateAWafOverrideError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallOverrideResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type WafOverridesCreateAWafOverrideRequestBody = {
  urls: Schemas.FirewallUrls;
};

export type WafOverridesCreateAWafOverrideVariables = {
  body: WafOverridesCreateAWafOverrideRequestBody;
  pathParams: WafOverridesCreateAWafOverridePathParams;
} & FetcherExtraProps;

/**
 * Creates a URI-based WAF override for a zone.
 *
 * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
 */
export const wafOverridesCreateAWafOverride = (
  variables: WafOverridesCreateAWafOverrideVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallOverrideResponseSingle,
    WafOverridesCreateAWafOverrideError,
    WafOverridesCreateAWafOverrideRequestBody,
    {},
    {},
    WafOverridesCreateAWafOverridePathParams
  >({ url: '/zones/{zoneId}/firewall/waf/overrides', method: 'post', ...variables, signal });

export type WafOverridesDeleteAWafOverridePathParams = {
  overridesId: Schemas.FirewallOverridesId;
  zoneId: Schemas.FirewallIdentifier;
};

export type WafOverridesDeleteAWafOverrideError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: {
    result: any | null;
    /**
     * @example {"code":7003,"message":"No route for the URI"}
     * @minLength 1
     */
    errors: Schemas.FirewallMessages;
    messages: Schemas.FirewallMessages;
    /**
     * Whether the API call was successful
     *
     * @example false
     */
    success: false;
  };
}>;

export type WafOverridesDeleteAWafOverrideResponse = {
  result?: {
    id?: Schemas.FirewallOverridesId;
  };
};

export type WafOverridesDeleteAWafOverrideVariables = {
  pathParams: WafOverridesDeleteAWafOverridePathParams;
} & FetcherExtraProps;

/**
 * Deletes an existing URI-based WAF override.
 *
 * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
 */
export const wafOverridesDeleteAWafOverride = (
  variables: WafOverridesDeleteAWafOverrideVariables,
  signal?: AbortSignal
) =>
  fetch<
    WafOverridesDeleteAWafOverrideResponse,
    WafOverridesDeleteAWafOverrideError,
    undefined,
    {},
    {},
    WafOverridesDeleteAWafOverridePathParams
  >({ url: '/zones/{zoneId}/firewall/waf/overrides/{overridesId}', method: 'delete', ...variables, signal });

export type WafOverridesGetAWafOverridePathParams = {
  overridesId: Schemas.FirewallOverridesId;
  zoneId: Schemas.FirewallIdentifier;
};

export type WafOverridesGetAWafOverrideError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallOverrideResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type WafOverridesGetAWafOverrideVariables = {
  pathParams: WafOverridesGetAWafOverridePathParams;
} & FetcherExtraProps;

/**
 * Fetches the details of a URI-based WAF override.
 *
 * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
 */
export const wafOverridesGetAWafOverride = (variables: WafOverridesGetAWafOverrideVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.FirewallOverrideResponseSingle,
    WafOverridesGetAWafOverrideError,
    undefined,
    {},
    {},
    WafOverridesGetAWafOverridePathParams
  >({ url: '/zones/{zoneId}/firewall/waf/overrides/{overridesId}', method: 'get', ...variables, signal });

export type WafOverridesUpdateWafOverridePathParams = {
  overridesId: Schemas.FirewallOverridesId;
  zoneId: Schemas.FirewallIdentifier;
};

export type WafOverridesUpdateWafOverrideError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallOverrideResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type WafOverridesUpdateWafOverrideRequestBody = {
  id: Schemas.FirewallIdentifier;
  rewrite_action: Schemas.FirewallRewriteAction;
  rules: Schemas.FirewallRules;
  urls: Schemas.FirewallUrls;
};

export type WafOverridesUpdateWafOverrideVariables = {
  body: WafOverridesUpdateWafOverrideRequestBody;
  pathParams: WafOverridesUpdateWafOverridePathParams;
} & FetcherExtraProps;

/**
 * Updates an existing URI-based WAF override.
 *
 * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
 */
export const wafOverridesUpdateWafOverride = (
  variables: WafOverridesUpdateWafOverrideVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallOverrideResponseSingle,
    WafOverridesUpdateWafOverrideError,
    WafOverridesUpdateWafOverrideRequestBody,
    {},
    {},
    WafOverridesUpdateWafOverridePathParams
  >({ url: '/zones/{zoneId}/firewall/waf/overrides/{overridesId}', method: 'put', ...variables, signal });

export type WafPackagesListWafPackagesPathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type WafPackagesListWafPackagesQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 50
   * @maximum 100
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example status
   */
  order?: 'name';
  /**
   * @example desc
   */
  direction?: 'asc' | 'desc';
  /**
   * @default all
   */
  match?: 'any' | 'all';
  /**
   * @example USER
   */
  name?: string;
};

export type WafPackagesListWafPackagesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallPackageResponseCollection & Schemas.FirewallApiResponseCommonFailure;
}>;

export type WafPackagesListWafPackagesVariables = {
  pathParams: WafPackagesListWafPackagesPathParams;
  queryParams?: WafPackagesListWafPackagesQueryParams;
} & FetcherExtraProps;

/**
 * Fetches WAF packages for a zone.
 *
 * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
 */
export const wafPackagesListWafPackages = (variables: WafPackagesListWafPackagesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.FirewallPackageResponseCollection,
    WafPackagesListWafPackagesError,
    undefined,
    {},
    WafPackagesListWafPackagesQueryParams,
    WafPackagesListWafPackagesPathParams
  >({ url: '/zones/{zoneId}/firewall/waf/packages', method: 'get', ...variables, signal });

export type WafPackagesGetAWafPackagePathParams = {
  packageId: Schemas.FirewallPackageId;
  zoneId: Schemas.FirewallIdentifier;
};

export type WafPackagesGetAWafPackageError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallPackageResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type WafPackagesGetAWafPackageVariables = {
  pathParams: WafPackagesGetAWafPackagePathParams;
} & FetcherExtraProps;

/**
 * Fetches the details of a WAF package.
 *
 * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
 */
export const wafPackagesGetAWafPackage = (variables: WafPackagesGetAWafPackageVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.FirewallPackageResponseSingle,
    WafPackagesGetAWafPackageError,
    undefined,
    {},
    {},
    WafPackagesGetAWafPackagePathParams
  >({ url: '/zones/{zoneId}/firewall/waf/packages/{packageId}', method: 'get', ...variables, signal });

export type WafPackagesUpdateAWafPackagePathParams = {
  packageId: Schemas.FirewallPackageId;
  zoneId: Schemas.FirewallIdentifier;
};

export type WafPackagesUpdateAWafPackageError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.FirewallPackageResponseSingle & {
    result?: Schemas.FirewallAnomalyPackage;
  }) &
    Schemas.FirewallApiResponseCommonFailure;
}>;

export type WafPackagesUpdateAWafPackageResponse = Schemas.FirewallPackageResponseSingle & {
  result?: Schemas.FirewallAnomalyPackage;
};

export type WafPackagesUpdateAWafPackageRequestBody = {
  action_mode?: Schemas.FirewallActionMode;
  sensitivity?: Schemas.FirewallSensitivity;
};

export type WafPackagesUpdateAWafPackageVariables = {
  body?: WafPackagesUpdateAWafPackageRequestBody;
  pathParams: WafPackagesUpdateAWafPackagePathParams;
} & FetcherExtraProps;

/**
 * Updates a WAF package. You can update the sensitivity and the action of an anomaly detection WAF package.
 *
 * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
 */
export const wafPackagesUpdateAWafPackage = (variables: WafPackagesUpdateAWafPackageVariables, signal?: AbortSignal) =>
  fetch<
    WafPackagesUpdateAWafPackageResponse,
    WafPackagesUpdateAWafPackageError,
    WafPackagesUpdateAWafPackageRequestBody,
    {},
    {},
    WafPackagesUpdateAWafPackagePathParams
  >({ url: '/zones/{zoneId}/firewall/waf/packages/{packageId}', method: 'patch', ...variables, signal });

export type WafRuleGroupsListWafRuleGroupsPathParams = {
  packageId: Schemas.WafManagedRulesIdentifier;
  zoneId: Schemas.WafManagedRulesSchemasIdentifier;
};

export type WafRuleGroupsListWafRuleGroupsQueryParams = {
  /**
   * The state of the rules contained in the rule group. When `on`, the rules in the group are configurable/usable.
   *
   * @default on
   */
  mode?: Schemas.WafManagedRulesMode;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 50
   * @maximum 100
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example mode
   */
  order?: 'mode' | 'rules_count';
  /**
   * @example desc
   */
  direction?: 'asc' | 'desc';
  /**
   * @default all
   */
  match?: 'any' | 'all';
  /**
   * @example Project Honey Pot
   */
  name?: string;
  /**
   * @default 0
   * @example 10
   */
  rules_count?: number;
};

export type WafRuleGroupsListWafRuleGroupsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WafManagedRulesRuleGroupResponseCollection & Schemas.WafManagedRulesApiResponseCommonFailure;
}>;

export type WafRuleGroupsListWafRuleGroupsVariables = {
  pathParams: WafRuleGroupsListWafRuleGroupsPathParams;
  queryParams?: WafRuleGroupsListWafRuleGroupsQueryParams;
} & FetcherExtraProps;

/**
 * Fetches the WAF rule groups in a WAF package.
 *
 * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
 */
export const wafRuleGroupsListWafRuleGroups = (
  variables: WafRuleGroupsListWafRuleGroupsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WafManagedRulesRuleGroupResponseCollection,
    WafRuleGroupsListWafRuleGroupsError,
    undefined,
    {},
    WafRuleGroupsListWafRuleGroupsQueryParams,
    WafRuleGroupsListWafRuleGroupsPathParams
  >({ url: '/zones/{zoneId}/firewall/waf/packages/{packageId}/groups', method: 'get', ...variables, signal });

export type WafRuleGroupsGetAWafRuleGroupPathParams = {
  groupId: Schemas.WafManagedRulesIdentifier;
  packageId: Schemas.WafManagedRulesIdentifier;
  zoneId: Schemas.WafManagedRulesSchemasIdentifier;
};

export type WafRuleGroupsGetAWafRuleGroupError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WafManagedRulesRuleGroupResponseSingle & Schemas.WafManagedRulesApiResponseCommonFailure;
}>;

export type WafRuleGroupsGetAWafRuleGroupVariables = {
  pathParams: WafRuleGroupsGetAWafRuleGroupPathParams;
} & FetcherExtraProps;

/**
 * Fetches the details of a WAF rule group.
 *
 * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
 */
export const wafRuleGroupsGetAWafRuleGroup = (
  variables: WafRuleGroupsGetAWafRuleGroupVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WafManagedRulesRuleGroupResponseSingle,
    WafRuleGroupsGetAWafRuleGroupError,
    undefined,
    {},
    {},
    WafRuleGroupsGetAWafRuleGroupPathParams
  >({ url: '/zones/{zoneId}/firewall/waf/packages/{packageId}/groups/{groupId}', method: 'get', ...variables, signal });

export type WafRuleGroupsUpdateAWafRuleGroupPathParams = {
  groupId: Schemas.WafManagedRulesIdentifier;
  packageId: Schemas.WafManagedRulesIdentifier;
  zoneId: Schemas.WafManagedRulesSchemasIdentifier;
};

export type WafRuleGroupsUpdateAWafRuleGroupError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WafManagedRulesRuleGroupResponseSingle & Schemas.WafManagedRulesApiResponseCommonFailure;
}>;

export type WafRuleGroupsUpdateAWafRuleGroupRequestBody = {
  mode?: Schemas.WafManagedRulesMode;
};

export type WafRuleGroupsUpdateAWafRuleGroupVariables = {
  body?: WafRuleGroupsUpdateAWafRuleGroupRequestBody;
  pathParams: WafRuleGroupsUpdateAWafRuleGroupPathParams;
} & FetcherExtraProps;

/**
 * Updates a WAF rule group. You can update the state (`mode` parameter) of a rule group.
 *
 * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
 */
export const wafRuleGroupsUpdateAWafRuleGroup = (
  variables: WafRuleGroupsUpdateAWafRuleGroupVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WafManagedRulesRuleGroupResponseSingle,
    WafRuleGroupsUpdateAWafRuleGroupError,
    WafRuleGroupsUpdateAWafRuleGroupRequestBody,
    {},
    {},
    WafRuleGroupsUpdateAWafRuleGroupPathParams
  >({
    url: '/zones/{zoneId}/firewall/waf/packages/{packageId}/groups/{groupId}',
    method: 'patch',
    ...variables,
    signal
  });

export type WafRulesListWafRulesPathParams = {
  packageId: Schemas.WafManagedRulesIdentifier;
  zoneId: Schemas.WafManagedRulesSchemasIdentifier;
};

export type WafRulesListWafRulesQueryParams = {
  /**
   * @example CHL
   */
  mode?: 'DIS' | 'CHL' | 'BLK' | 'SIM';
  /**
   * The unique identifier of the rule group.
   *
   * @example de677e5818985db1285d0e80225f06e5
   * @maxLength 32
   */
  group_id?: Schemas.WafManagedRulesComponentsSchemasIdentifier;
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 50
   * @maximum 100
   * @minimum 5
   */
  per_page?: number;
  /**
   * @example status
   */
  order?: 'priority' | 'group_id' | 'description';
  /**
   * @example desc
   */
  direction?: 'asc' | 'desc';
  /**
   * @default all
   */
  match?: 'any' | 'all';
  /**
   * @example SQL injection prevention for SELECT statements
   */
  description?: string;
  priority?: string;
};

export type WafRulesListWafRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WafManagedRulesRuleResponseCollection & Schemas.WafManagedRulesApiResponseCommonFailure;
}>;

export type WafRulesListWafRulesVariables = {
  pathParams: WafRulesListWafRulesPathParams;
  queryParams?: WafRulesListWafRulesQueryParams;
} & FetcherExtraProps;

/**
 * Fetches WAF rules in a WAF package.
 *
 * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
 */
export const wafRulesListWafRules = (variables: WafRulesListWafRulesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WafManagedRulesRuleResponseCollection,
    WafRulesListWafRulesError,
    undefined,
    {},
    WafRulesListWafRulesQueryParams,
    WafRulesListWafRulesPathParams
  >({ url: '/zones/{zoneId}/firewall/waf/packages/{packageId}/rules', method: 'get', ...variables, signal });

export type WafRulesGetAWafRulePathParams = {
  ruleId: Schemas.WafManagedRulesIdentifier;
  packageId: Schemas.WafManagedRulesIdentifier;
  zoneId: Schemas.WafManagedRulesSchemasIdentifier;
};

export type WafRulesGetAWafRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WafManagedRulesRuleResponseSingle & Schemas.WafManagedRulesApiResponseCommonFailure;
}>;

export type WafRulesGetAWafRuleVariables = {
  pathParams: WafRulesGetAWafRulePathParams;
} & FetcherExtraProps;

/**
 * Fetches the details of a WAF rule in a WAF package.
 *
 * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
 */
export const wafRulesGetAWafRule = (variables: WafRulesGetAWafRuleVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WafManagedRulesRuleResponseSingle,
    WafRulesGetAWafRuleError,
    undefined,
    {},
    {},
    WafRulesGetAWafRulePathParams
  >({ url: '/zones/{zoneId}/firewall/waf/packages/{packageId}/rules/{ruleId}', method: 'get', ...variables, signal });

export type WafRulesUpdateAWafRulePathParams = {
  ruleId: Schemas.WafManagedRulesIdentifier;
  packageId: Schemas.WafManagedRulesIdentifier;
  zoneId: Schemas.WafManagedRulesSchemasIdentifier;
};

export type WafRulesUpdateAWafRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.WafManagedRulesRuleResponseSingle & {
    result?:
      | Schemas.WafManagedRulesAnomalyRule
      | Schemas.WafManagedRulesTraditionalDenyRule
      | Schemas.WafManagedRulesTraditionalAllowRule;
  }) &
    Schemas.WafManagedRulesApiResponseCommonFailure;
}>;

export type WafRulesUpdateAWafRuleResponse = Schemas.WafManagedRulesRuleResponseSingle & {
  result?:
    | Schemas.WafManagedRulesAnomalyRule
    | Schemas.WafManagedRulesTraditionalDenyRule
    | Schemas.WafManagedRulesTraditionalAllowRule;
};

export type WafRulesUpdateAWafRuleRequestBody = {
  /**
   * The mode/action of the rule when triggered. You must use a value from the `allowed_modes` array of the current rule.
   *
   * @example on
   */
  mode?: 'default' | 'disable' | 'simulate' | 'block' | 'challenge' | 'on' | 'off';
};

export type WafRulesUpdateAWafRuleVariables = {
  body?: WafRulesUpdateAWafRuleRequestBody;
  pathParams: WafRulesUpdateAWafRulePathParams;
} & FetcherExtraProps;

/**
 * Updates a WAF rule. You can only update the mode/action of the rule.
 *
 * **Note:** Applies only to the [previous version of WAF managed rules](https://developers.cloudflare.com/support/firewall/managed-rules-web-application-firewall-waf/understanding-waf-managed-rules-web-application-firewall/).
 */
export const wafRulesUpdateAWafRule = (variables: WafRulesUpdateAWafRuleVariables, signal?: AbortSignal) =>
  fetch<
    WafRulesUpdateAWafRuleResponse,
    WafRulesUpdateAWafRuleError,
    WafRulesUpdateAWafRuleRequestBody,
    {},
    {},
    WafRulesUpdateAWafRulePathParams
  >({ url: '/zones/{zoneId}/firewall/waf/packages/{packageId}/rules/{ruleId}', method: 'patch', ...variables, signal });

export type HealthChecksListHealthChecksPathParams = {
  zoneId: Schemas.HealthchecksIdentifier;
};

export type HealthChecksListHealthChecksQueryParams = {
  /**
   * Page number of paginated results.
   *
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * Maximum number of results per page. Must be a multiple of 5.
   *
   * @default 25
   * @maximum 1000
   * @minimum 5
   */
  per_page?: number;
};

export type HealthChecksListHealthChecksError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.HealthchecksResponseCollection & Schemas.HealthchecksApiResponseCommonFailure;
}>;

export type HealthChecksListHealthChecksVariables = {
  pathParams: HealthChecksListHealthChecksPathParams;
  queryParams?: HealthChecksListHealthChecksQueryParams;
} & FetcherExtraProps;

/**
 * List configured health checks.
 */
export const healthChecksListHealthChecks = (variables: HealthChecksListHealthChecksVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.HealthchecksResponseCollection,
    HealthChecksListHealthChecksError,
    undefined,
    {},
    HealthChecksListHealthChecksQueryParams,
    HealthChecksListHealthChecksPathParams
  >({ url: '/zones/{zoneId}/healthchecks', method: 'get', ...variables, signal });

export type HealthChecksCreateHealthCheckPathParams = {
  zoneId: Schemas.HealthchecksIdentifier;
};

export type HealthChecksCreateHealthCheckError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.HealthchecksSingleResponse & Schemas.HealthchecksApiResponseCommonFailure;
}>;

export type HealthChecksCreateHealthCheckVariables = {
  body: Schemas.HealthchecksQueryHealthcheck;
  pathParams: HealthChecksCreateHealthCheckPathParams;
} & FetcherExtraProps;

/**
 * Create a new health check.
 */
export const healthChecksCreateHealthCheck = (
  variables: HealthChecksCreateHealthCheckVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.HealthchecksSingleResponse,
    HealthChecksCreateHealthCheckError,
    Schemas.HealthchecksQueryHealthcheck,
    {},
    {},
    HealthChecksCreateHealthCheckPathParams
  >({ url: '/zones/{zoneId}/healthchecks', method: 'post', ...variables, signal });

export type HealthChecksCreatePreviewHealthCheckPathParams = {
  zoneId: Schemas.HealthchecksIdentifier;
};

export type HealthChecksCreatePreviewHealthCheckError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.HealthchecksSingleResponse & Schemas.HealthchecksApiResponseCommonFailure;
}>;

export type HealthChecksCreatePreviewHealthCheckVariables = {
  body: Schemas.HealthchecksQueryHealthcheck;
  pathParams: HealthChecksCreatePreviewHealthCheckPathParams;
} & FetcherExtraProps;

/**
 * Create a new preview health check.
 */
export const healthChecksCreatePreviewHealthCheck = (
  variables: HealthChecksCreatePreviewHealthCheckVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.HealthchecksSingleResponse,
    HealthChecksCreatePreviewHealthCheckError,
    Schemas.HealthchecksQueryHealthcheck,
    {},
    {},
    HealthChecksCreatePreviewHealthCheckPathParams
  >({ url: '/zones/{zoneId}/healthchecks/preview', method: 'post', ...variables, signal });

export type HealthChecksDeletePreviewHealthCheckPathParams = {
  healthcheckId: Schemas.HealthchecksIdentifier;
  zoneId: Schemas.HealthchecksIdentifier;
};

export type HealthChecksDeletePreviewHealthCheckError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.HealthchecksIdResponse & Schemas.HealthchecksApiResponseCommonFailure;
}>;

export type HealthChecksDeletePreviewHealthCheckVariables = {
  pathParams: HealthChecksDeletePreviewHealthCheckPathParams;
} & FetcherExtraProps;

/**
 * Delete a health check.
 */
export const healthChecksDeletePreviewHealthCheck = (
  variables: HealthChecksDeletePreviewHealthCheckVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.HealthchecksIdResponse,
    HealthChecksDeletePreviewHealthCheckError,
    undefined,
    {},
    {},
    HealthChecksDeletePreviewHealthCheckPathParams
  >({ url: '/zones/{zoneId}/healthchecks/preview/{healthcheckId}', method: 'delete', ...variables, signal });

export type HealthChecksHealthCheckPreviewDetailsPathParams = {
  healthcheckId: Schemas.HealthchecksIdentifier;
  zoneId: Schemas.HealthchecksIdentifier;
};

export type HealthChecksHealthCheckPreviewDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.HealthchecksSingleResponse & Schemas.HealthchecksApiResponseCommonFailure;
}>;

export type HealthChecksHealthCheckPreviewDetailsVariables = {
  pathParams: HealthChecksHealthCheckPreviewDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetch a single configured health check preview.
 */
export const healthChecksHealthCheckPreviewDetails = (
  variables: HealthChecksHealthCheckPreviewDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.HealthchecksSingleResponse,
    HealthChecksHealthCheckPreviewDetailsError,
    undefined,
    {},
    {},
    HealthChecksHealthCheckPreviewDetailsPathParams
  >({ url: '/zones/{zoneId}/healthchecks/preview/{healthcheckId}', method: 'get', ...variables, signal });

export type HealthChecksDeleteHealthCheckPathParams = {
  healthcheckId: Schemas.HealthchecksIdentifier;
  zoneId: Schemas.HealthchecksIdentifier;
};

export type HealthChecksDeleteHealthCheckError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.HealthchecksIdResponse & Schemas.HealthchecksApiResponseCommonFailure;
}>;

export type HealthChecksDeleteHealthCheckVariables = {
  pathParams: HealthChecksDeleteHealthCheckPathParams;
} & FetcherExtraProps;

/**
 * Delete a health check.
 */
export const healthChecksDeleteHealthCheck = (
  variables: HealthChecksDeleteHealthCheckVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.HealthchecksIdResponse,
    HealthChecksDeleteHealthCheckError,
    undefined,
    {},
    {},
    HealthChecksDeleteHealthCheckPathParams
  >({ url: '/zones/{zoneId}/healthchecks/{healthcheckId}', method: 'delete', ...variables, signal });

export type HealthChecksHealthCheckDetailsPathParams = {
  healthcheckId: Schemas.HealthchecksIdentifier;
  zoneId: Schemas.HealthchecksIdentifier;
};

export type HealthChecksHealthCheckDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.HealthchecksSingleResponse & Schemas.HealthchecksApiResponseCommonFailure;
}>;

export type HealthChecksHealthCheckDetailsVariables = {
  pathParams: HealthChecksHealthCheckDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetch a single configured health check.
 */
export const healthChecksHealthCheckDetails = (
  variables: HealthChecksHealthCheckDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.HealthchecksSingleResponse,
    HealthChecksHealthCheckDetailsError,
    undefined,
    {},
    {},
    HealthChecksHealthCheckDetailsPathParams
  >({ url: '/zones/{zoneId}/healthchecks/{healthcheckId}', method: 'get', ...variables, signal });

export type HealthChecksPatchHealthCheckPathParams = {
  healthcheckId: Schemas.HealthchecksIdentifier;
  zoneId: Schemas.HealthchecksIdentifier;
};

export type HealthChecksPatchHealthCheckError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.HealthchecksSingleResponse & Schemas.HealthchecksApiResponseCommonFailure;
}>;

export type HealthChecksPatchHealthCheckVariables = {
  body: Schemas.HealthchecksQueryHealthcheck;
  pathParams: HealthChecksPatchHealthCheckPathParams;
} & FetcherExtraProps;

/**
 * Patch a configured health check.
 */
export const healthChecksPatchHealthCheck = (variables: HealthChecksPatchHealthCheckVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.HealthchecksSingleResponse,
    HealthChecksPatchHealthCheckError,
    Schemas.HealthchecksQueryHealthcheck,
    {},
    {},
    HealthChecksPatchHealthCheckPathParams
  >({ url: '/zones/{zoneId}/healthchecks/{healthcheckId}', method: 'patch', ...variables, signal });

export type HealthChecksUpdateHealthCheckPathParams = {
  healthcheckId: Schemas.HealthchecksIdentifier;
  zoneId: Schemas.HealthchecksIdentifier;
};

export type HealthChecksUpdateHealthCheckError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.HealthchecksSingleResponse & Schemas.HealthchecksApiResponseCommonFailure;
}>;

export type HealthChecksUpdateHealthCheckVariables = {
  body: Schemas.HealthchecksQueryHealthcheck;
  pathParams: HealthChecksUpdateHealthCheckPathParams;
} & FetcherExtraProps;

/**
 * Update a configured health check.
 */
export const healthChecksUpdateHealthCheck = (
  variables: HealthChecksUpdateHealthCheckVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.HealthchecksSingleResponse,
    HealthChecksUpdateHealthCheckError,
    Schemas.HealthchecksQueryHealthcheck,
    {},
    {},
    HealthChecksUpdateHealthCheckPathParams
  >({ url: '/zones/{zoneId}/healthchecks/{healthcheckId}', method: 'put', ...variables, signal });

export type Zones0HoldDeletePathParams = {
  /**
   * Zone ID
   */
  zoneId: Schemas.ZonesIdentifier;
};

export type Zones0HoldDeleteQueryParams = {
  /**
   * If `hold_after` is provided, the hold will be temporarily disabled,
   * then automatically re-enabled by the system at the time specified
   * in this RFC3339-formatted timestamp. Otherwise, the hold will be
   * disabled indefinitely.
   */
  hold_after?: string;
};

export type Zones0HoldDeleteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesSchemasApiResponseCommonFailure;
}>;

export type Zones0HoldDeleteResponse = Schemas.ZonesSchemasApiResponseSingle & {
  result?: {
    /**
     * @example false
     */
    hold?: boolean;
    hold_after?: string;
    /**
     * @example false
     */
    include_subdomains?: string;
  };
};

export type Zones0HoldDeleteVariables = {
  pathParams: Zones0HoldDeletePathParams;
  queryParams?: Zones0HoldDeleteQueryParams;
} & FetcherExtraProps;

/**
 * Stop enforcement of a zone hold on the zone, permanently or temporarily, allowing the
 * creation and activation of zones with this zone's hostname.
 */
export const zones0HoldDelete = (variables: Zones0HoldDeleteVariables, signal?: AbortSignal) =>
  fetch<
    Zones0HoldDeleteResponse,
    Zones0HoldDeleteError,
    undefined,
    {},
    Zones0HoldDeleteQueryParams,
    Zones0HoldDeletePathParams
  >({ url: '/zones/{zoneId}/hold', method: 'delete', ...variables, signal });

export type Zones0HoldGetPathParams = {
  /**
   * Zone ID
   */
  zoneId: Schemas.ZonesIdentifier;
};

export type Zones0HoldGetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesSchemasApiResponseCommonFailure;
}>;

export type Zones0HoldGetResponse = Schemas.ZonesSchemasApiResponseSingle & {
  result?: {
    /**
     * @example true
     */
    hold?: boolean;
    /**
     * @example 2023-01-31T15:56:36+00:00
     */
    hold_after?: string;
    /**
     * @example false
     */
    include_subdomains?: string;
  };
};

export type Zones0HoldGetVariables = {
  pathParams: Zones0HoldGetPathParams;
} & FetcherExtraProps;

/**
 * Retrieve whether the zone is subject to a zone hold, and metadata about the hold.
 */
export const zones0HoldGet = (variables: Zones0HoldGetVariables, signal?: AbortSignal) =>
  fetch<Zones0HoldGetResponse, Zones0HoldGetError, undefined, {}, {}, Zones0HoldGetPathParams>({
    url: '/zones/{zoneId}/hold',
    method: 'get',
    ...variables,
    signal
  });

export type Zones0HoldPatchPathParams = {
  /**
   * Zone ID
   */
  zoneId: Schemas.ZonesIdentifier;
};

export type Zones0HoldPatchError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesSchemasApiResponseCommonFailure;
}>;

export type Zones0HoldPatchResponse = Schemas.ZonesSchemasApiResponseSingle & {
  result?: {
    /**
     * @example false
     */
    hold?: boolean;
    hold_after?: string;
    /**
     * @example false
     */
    include_subdomains?: string;
  };
};

export type Zones0HoldPatchRequestBody = {
  /**
   * If `hold_after` is provided and future-dated, the hold will be temporarily disabled,
   * then automatically re-enabled by the system at the time specified
   * in this RFC3339-formatted timestamp. A past-dated `hold_after` value will have
   * no effect on an existing, enabled hold. Providing an empty string will set its value
   * to the current time.
   *
   * @default
   * @example 2023-01-31T15:56:36+00:00
   */
  hold_after?: string;
  /**
   * If `true`, the zone hold will extend to block any subdomain of the given zone, as well
   * as SSL4SaaS Custom Hostnames. For example, a zone hold on a zone with the hostname
   * 'example.com' and include_subdomains=true will block 'example.com',
   * 'staging.example.com', 'api.staging.example.com', etc.
   *
   * @default false
   * @example true
   */
  include_subdomains?: boolean;
};

export type Zones0HoldPatchVariables = {
  body?: Zones0HoldPatchRequestBody;
  pathParams: Zones0HoldPatchPathParams;
} & FetcherExtraProps;

/**
 * Update the `hold_after` and/or `include_subdomains` values on an existing zone hold.
 * The hold is enabled if the `hold_after` date-time value is in the past.
 */
export const zones0HoldPatch = (variables: Zones0HoldPatchVariables, signal?: AbortSignal) =>
  fetch<Zones0HoldPatchResponse, Zones0HoldPatchError, Zones0HoldPatchRequestBody, {}, {}, Zones0HoldPatchPathParams>({
    url: '/zones/{zoneId}/hold',
    method: 'patch',
    ...variables,
    signal
  });

export type Zones0HoldPostPathParams = {
  /**
   * Zone ID
   */
  zoneId: Schemas.ZonesIdentifier;
};

export type Zones0HoldPostQueryParams = {
  /**
   * If provided, the zone hold will extend to block any subdomain of the given zone, as well
   * as SSL4SaaS Custom Hostnames. For example, a zone hold on a zone with the hostname
   * 'example.com' and include_subdomains=true will block 'example.com',
   * 'staging.example.com', 'api.staging.example.com', etc.
   */
  include_subdomains?: boolean;
};

export type Zones0HoldPostError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesSchemasApiResponseCommonFailure;
}>;

export type Zones0HoldPostResponse = Schemas.ZonesSchemasApiResponseSingle & {
  result?: {
    /**
     * @example true
     */
    hold?: boolean;
    /**
     * @example 2023-01-31T15:56:36+00:00
     */
    hold_after?: string;
    /**
     * @example true
     */
    include_subdomains?: string;
  };
};

export type Zones0HoldPostVariables = {
  pathParams: Zones0HoldPostPathParams;
  queryParams?: Zones0HoldPostQueryParams;
} & FetcherExtraProps;

/**
 * Enforce a zone hold on the zone, blocking the creation and activation of zones with this zone's hostname.
 */
export const zones0HoldPost = (variables: Zones0HoldPostVariables, signal?: AbortSignal) =>
  fetch<
    Zones0HoldPostResponse,
    Zones0HoldPostError,
    undefined,
    {},
    Zones0HoldPostQueryParams,
    Zones0HoldPostPathParams
  >({ url: '/zones/{zoneId}/hold', method: 'post', ...variables, signal });

export type PerHostnameTlsSettingsListPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  settingId: Schemas.TlsCertificatesAndHostnamesSettingId;
};

export type PerHostnameTlsSettingsListError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesPerHostnameSettingsResponseCollection &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type PerHostnameTlsSettingsListVariables = {
  pathParams: PerHostnameTlsSettingsListPathParams;
} & FetcherExtraProps;

/**
 * List the requested TLS setting for the hostnames under this zone.
 */
export const perHostnameTlsSettingsList = (variables: PerHostnameTlsSettingsListVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesPerHostnameSettingsResponseCollection,
    PerHostnameTlsSettingsListError,
    undefined,
    {},
    {},
    PerHostnameTlsSettingsListPathParams
  >({ url: '/zones/{zoneId}/hostnames/settings/{settingId}', method: 'get', ...variables, signal });

export type PerHostnameTlsSettingsDeletePathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  settingId: Schemas.TlsCertificatesAndHostnamesSettingId;
  hostname: Schemas.TlsCertificatesAndHostnamesComponentsSchemasHostname;
};

export type PerHostnameTlsSettingsDeleteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesPerHostnameSettingsResponseDelete &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type PerHostnameTlsSettingsDeleteVariables = {
  pathParams: PerHostnameTlsSettingsDeletePathParams;
} & FetcherExtraProps;

/**
 * Delete the tls setting value for the hostname.
 */
export const perHostnameTlsSettingsDelete = (variables: PerHostnameTlsSettingsDeleteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesPerHostnameSettingsResponseDelete,
    PerHostnameTlsSettingsDeleteError,
    undefined,
    {},
    {},
    PerHostnameTlsSettingsDeletePathParams
  >({ url: '/zones/{zoneId}/hostnames/settings/{settingId}/{hostname}', method: 'delete', ...variables, signal });

export type PerHostnameTlsSettingsPutPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  settingId: Schemas.TlsCertificatesAndHostnamesSettingId;
  hostname: Schemas.TlsCertificatesAndHostnamesComponentsSchemasHostname;
};

export type PerHostnameTlsSettingsPutError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesPerHostnameSettingsResponse &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type PerHostnameTlsSettingsPutRequestBody = {
  value: Schemas.TlsCertificatesAndHostnamesValue;
};

export type PerHostnameTlsSettingsPutVariables = {
  body: PerHostnameTlsSettingsPutRequestBody;
  pathParams: PerHostnameTlsSettingsPutPathParams;
} & FetcherExtraProps;

/**
 * Update the tls setting value for the hostname.
 */
export const perHostnameTlsSettingsPut = (variables: PerHostnameTlsSettingsPutVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesPerHostnameSettingsResponse,
    PerHostnameTlsSettingsPutError,
    PerHostnameTlsSettingsPutRequestBody,
    {},
    {},
    PerHostnameTlsSettingsPutPathParams
  >({ url: '/zones/{zoneId}/hostnames/settings/{settingId}/{hostname}', method: 'put', ...variables, signal });

export type KeylessSslForAZoneListKeylessSslConfigurationsPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type KeylessSslForAZoneListKeylessSslConfigurationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesKeylessResponseCollection &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type KeylessSslForAZoneListKeylessSslConfigurationsVariables = {
  pathParams: KeylessSslForAZoneListKeylessSslConfigurationsPathParams;
} & FetcherExtraProps;

/**
 * List all Keyless SSL configurations for a given zone.
 */
export const keylessSslForAZoneListKeylessSslConfigurations = (
  variables: KeylessSslForAZoneListKeylessSslConfigurationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesKeylessResponseCollection,
    KeylessSslForAZoneListKeylessSslConfigurationsError,
    undefined,
    {},
    {},
    KeylessSslForAZoneListKeylessSslConfigurationsPathParams
  >({ url: '/zones/{zoneId}/keyless_certificates', method: 'get', ...variables, signal });

export type KeylessSslForAZoneCreateKeylessSslConfigurationPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type KeylessSslForAZoneCreateKeylessSslConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesKeylessResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type KeylessSslForAZoneCreateKeylessSslConfigurationRequestBody = {
  bundle_method?: Schemas.TlsCertificatesAndHostnamesBundleMethod;
  certificate: Schemas.TlsCertificatesAndHostnamesSchemasCertificate;
  host: Schemas.TlsCertificatesAndHostnamesHost;
  name?: Schemas.TlsCertificatesAndHostnamesNameWrite;
  port: Schemas.TlsCertificatesAndHostnamesPort;
  tunnel?: Schemas.TlsCertificatesAndHostnamesKeylessTunnel;
};

export type KeylessSslForAZoneCreateKeylessSslConfigurationVariables = {
  body: KeylessSslForAZoneCreateKeylessSslConfigurationRequestBody;
  pathParams: KeylessSslForAZoneCreateKeylessSslConfigurationPathParams;
} & FetcherExtraProps;

export const keylessSslForAZoneCreateKeylessSslConfiguration = (
  variables: KeylessSslForAZoneCreateKeylessSslConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesKeylessResponseSingle,
    KeylessSslForAZoneCreateKeylessSslConfigurationError,
    KeylessSslForAZoneCreateKeylessSslConfigurationRequestBody,
    {},
    {},
    KeylessSslForAZoneCreateKeylessSslConfigurationPathParams
  >({ url: '/zones/{zoneId}/keyless_certificates', method: 'post', ...variables, signal });

export type KeylessSslForAZoneDeleteKeylessSslConfigurationPathParams = {
  keylessCertificateId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type KeylessSslForAZoneDeleteKeylessSslConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesKeylessResponseSingleId &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type KeylessSslForAZoneDeleteKeylessSslConfigurationVariables = {
  pathParams: KeylessSslForAZoneDeleteKeylessSslConfigurationPathParams;
} & FetcherExtraProps;

export const keylessSslForAZoneDeleteKeylessSslConfiguration = (
  variables: KeylessSslForAZoneDeleteKeylessSslConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesKeylessResponseSingleId,
    KeylessSslForAZoneDeleteKeylessSslConfigurationError,
    undefined,
    {},
    {},
    KeylessSslForAZoneDeleteKeylessSslConfigurationPathParams
  >({ url: '/zones/{zoneId}/keyless_certificates/{keylessCertificateId}', method: 'delete', ...variables, signal });

export type KeylessSslForAZoneGetKeylessSslConfigurationPathParams = {
  keylessCertificateId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type KeylessSslForAZoneGetKeylessSslConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesKeylessResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type KeylessSslForAZoneGetKeylessSslConfigurationVariables = {
  pathParams: KeylessSslForAZoneGetKeylessSslConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Get details for one Keyless SSL configuration.
 */
export const keylessSslForAZoneGetKeylessSslConfiguration = (
  variables: KeylessSslForAZoneGetKeylessSslConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesKeylessResponseSingle,
    KeylessSslForAZoneGetKeylessSslConfigurationError,
    undefined,
    {},
    {},
    KeylessSslForAZoneGetKeylessSslConfigurationPathParams
  >({ url: '/zones/{zoneId}/keyless_certificates/{keylessCertificateId}', method: 'get', ...variables, signal });

export type KeylessSslForAZoneEditKeylessSslConfigurationPathParams = {
  keylessCertificateId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type KeylessSslForAZoneEditKeylessSslConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesKeylessResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type KeylessSslForAZoneEditKeylessSslConfigurationRequestBody = {
  enabled?: Schemas.TlsCertificatesAndHostnamesEnabledWrite;
  host?: Schemas.TlsCertificatesAndHostnamesHost;
  name?: Schemas.TlsCertificatesAndHostnamesNameWrite;
  port?: Schemas.TlsCertificatesAndHostnamesPort;
  tunnel?: Schemas.TlsCertificatesAndHostnamesKeylessTunnel;
};

export type KeylessSslForAZoneEditKeylessSslConfigurationVariables = {
  body?: KeylessSslForAZoneEditKeylessSslConfigurationRequestBody;
  pathParams: KeylessSslForAZoneEditKeylessSslConfigurationPathParams;
} & FetcherExtraProps;

/**
 * This will update attributes of a Keyless SSL. Consists of one or more of the following:  host,name,port.
 */
export const keylessSslForAZoneEditKeylessSslConfiguration = (
  variables: KeylessSslForAZoneEditKeylessSslConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesKeylessResponseSingle,
    KeylessSslForAZoneEditKeylessSslConfigurationError,
    KeylessSslForAZoneEditKeylessSslConfigurationRequestBody,
    {},
    {},
    KeylessSslForAZoneEditKeylessSslConfigurationPathParams
  >({ url: '/zones/{zoneId}/keyless_certificates/{keylessCertificateId}', method: 'patch', ...variables, signal });

export type WafProductApiLeakedCredentialsGetStatusPathParams = {
  zoneId: Schemas.WafProductApiBundleIdentifier;
};

export type WafProductApiLeakedCredentialsGetStatusError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WafProductApiBundleResponseStatus & Schemas.WafProductApiBundleApiResponseCommonFailure;
}>;

export type WafProductApiLeakedCredentialsGetStatusVariables = {
  pathParams: WafProductApiLeakedCredentialsGetStatusPathParams;
} & FetcherExtraProps;

/**
 * Retrieves the current status of Leaked Credential Checks
 */
export const wafProductApiLeakedCredentialsGetStatus = (
  variables: WafProductApiLeakedCredentialsGetStatusVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WafProductApiBundleResponseStatus,
    WafProductApiLeakedCredentialsGetStatusError,
    undefined,
    {},
    {},
    WafProductApiLeakedCredentialsGetStatusPathParams
  >({ url: '/zones/{zoneId}/leaked-credential-checks', method: 'get', ...variables, signal });

export type WafProductApiLeakedCredentialsSetStatusPathParams = {
  zoneId: Schemas.WafProductApiBundleIdentifier;
};

export type WafProductApiLeakedCredentialsSetStatusError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WafProductApiBundleResponseStatus & Schemas.WafProductApiBundleApiResponseCommonFailure;
}>;

export type WafProductApiLeakedCredentialsSetStatusVariables = {
  body?: Schemas.WafProductApiBundleStatus;
  pathParams: WafProductApiLeakedCredentialsSetStatusPathParams;
} & FetcherExtraProps;

/**
 * Updates the current status of Leaked Credential Checks
 */
export const wafProductApiLeakedCredentialsSetStatus = (
  variables: WafProductApiLeakedCredentialsSetStatusVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WafProductApiBundleResponseStatus,
    WafProductApiLeakedCredentialsSetStatusError,
    Schemas.WafProductApiBundleStatus,
    {},
    {},
    WafProductApiLeakedCredentialsSetStatusPathParams
  >({ url: '/zones/{zoneId}/leaked-credential-checks', method: 'post', ...variables, signal });

export type WafProductApiLeakedCredentialsListDetectionsPathParams = {
  zoneId: Schemas.WafProductApiBundleIdentifier;
};

export type WafProductApiLeakedCredentialsListDetectionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WafProductApiBundleResponseCustomDetectionCollection &
    Schemas.WafProductApiBundleApiResponseCommonFailure;
}>;

export type WafProductApiLeakedCredentialsListDetectionsVariables = {
  pathParams: WafProductApiLeakedCredentialsListDetectionsPathParams;
} & FetcherExtraProps;

/**
 * List user-defined detection patterns for Leaked Credential Checks
 */
export const wafProductApiLeakedCredentialsListDetections = (
  variables: WafProductApiLeakedCredentialsListDetectionsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WafProductApiBundleResponseCustomDetectionCollection,
    WafProductApiLeakedCredentialsListDetectionsError,
    undefined,
    {},
    {},
    WafProductApiLeakedCredentialsListDetectionsPathParams
  >({ url: '/zones/{zoneId}/leaked-credential-checks/detections', method: 'get', ...variables, signal });

export type WafProductApiLeakedCredentialsCreateDetectionPathParams = {
  zoneId: Schemas.WafProductApiBundleIdentifier;
};

export type WafProductApiLeakedCredentialsCreateDetectionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WafProductApiBundleResponseCustomDetection & Schemas.WafProductApiBundleApiResponseCommonFailure;
}>;

export type WafProductApiLeakedCredentialsCreateDetectionVariables = {
  body?: Schemas.WafProductApiBundleCustomDetection;
  pathParams: WafProductApiLeakedCredentialsCreateDetectionPathParams;
} & FetcherExtraProps;

/**
 * Create user-defined detection pattern for Leaked Credential Checks
 */
export const wafProductApiLeakedCredentialsCreateDetection = (
  variables: WafProductApiLeakedCredentialsCreateDetectionVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WafProductApiBundleResponseCustomDetection,
    WafProductApiLeakedCredentialsCreateDetectionError,
    Schemas.WafProductApiBundleCustomDetection,
    {},
    {},
    WafProductApiLeakedCredentialsCreateDetectionPathParams
  >({ url: '/zones/{zoneId}/leaked-credential-checks/detections', method: 'post', ...variables, signal });

export type WafProductApiLeakedCredentialsDeleteDetectionPathParams = {
  zoneId: Schemas.WafProductApiBundleIdentifier;
  detectionId: Schemas.WafProductApiBundleDetectionId;
};

export type WafProductApiLeakedCredentialsDeleteDetectionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WafProductApiBundleApiResponseCommonFailure;
}>;

export type WafProductApiLeakedCredentialsDeleteDetectionVariables = {
  pathParams: WafProductApiLeakedCredentialsDeleteDetectionPathParams;
} & FetcherExtraProps;

/**
 * Remove user-defined detection pattern for Leaked Credential Checks
 */
export const wafProductApiLeakedCredentialsDeleteDetection = (
  variables: WafProductApiLeakedCredentialsDeleteDetectionVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WafProductApiBundleApiResponseCommon,
    WafProductApiLeakedCredentialsDeleteDetectionError,
    undefined,
    {},
    {},
    WafProductApiLeakedCredentialsDeleteDetectionPathParams
  >({
    url: '/zones/{zoneId}/leaked-credential-checks/detections/{detectionId}',
    method: 'delete',
    ...variables,
    signal
  });

export type WafProductApiLeakedCredentialsUpdateDetectionPathParams = {
  zoneId: Schemas.WafProductApiBundleIdentifier;
  detectionId: Schemas.WafProductApiBundleDetectionId;
};

export type WafProductApiLeakedCredentialsUpdateDetectionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WafProductApiBundleResponseCustomDetection & Schemas.WafProductApiBundleApiResponseCommonFailure;
}>;

export type WafProductApiLeakedCredentialsUpdateDetectionVariables = {
  body?: Schemas.WafProductApiBundleCustomDetection;
  pathParams: WafProductApiLeakedCredentialsUpdateDetectionPathParams;
} & FetcherExtraProps;

/**
 * Update user-defined detection pattern for Leaked Credential Checks
 */
export const wafProductApiLeakedCredentialsUpdateDetection = (
  variables: WafProductApiLeakedCredentialsUpdateDetectionVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WafProductApiBundleResponseCustomDetection,
    WafProductApiLeakedCredentialsUpdateDetectionError,
    Schemas.WafProductApiBundleCustomDetection,
    {},
    {},
    WafProductApiLeakedCredentialsUpdateDetectionPathParams
  >({ url: '/zones/{zoneId}/leaked-credential-checks/detections/{detectionId}', method: 'put', ...variables, signal });

export type LoadBalancersListLoadBalancersPathParams = {
  zoneId: Schemas.LoadBalancingLoadBalancerComponentsSchemasIdentifier;
};

export type LoadBalancersListLoadBalancersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingLoadBalancerComponentsSchemasResponseCollection &
    Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancersListLoadBalancersVariables = {
  pathParams: LoadBalancersListLoadBalancersPathParams;
} & FetcherExtraProps;

/**
 * List configured load balancers.
 */
export const loadBalancersListLoadBalancers = (
  variables: LoadBalancersListLoadBalancersVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingLoadBalancerComponentsSchemasResponseCollection,
    LoadBalancersListLoadBalancersError,
    undefined,
    {},
    {},
    LoadBalancersListLoadBalancersPathParams
  >({ url: '/zones/{zoneId}/load_balancers', method: 'get', ...variables, signal });

export type LoadBalancersCreateLoadBalancerPathParams = {
  zoneId: Schemas.LoadBalancingLoadBalancerComponentsSchemasIdentifier;
};

export type LoadBalancersCreateLoadBalancerError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingLoadBalancerComponentsSchemasSingleResponse &
    Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancersCreateLoadBalancerRequestBody = {
  adaptive_routing?: Schemas.LoadBalancingAdaptiveRouting;
  country_pools?: Schemas.LoadBalancingCountryPools;
  default_pools: Schemas.LoadBalancingDefaultPools;
  description?: Schemas.LoadBalancingComponentsSchemasDescription;
  fallback_pool: Schemas.LoadBalancingFallbackPool;
  location_strategy?: Schemas.LoadBalancingLocationStrategy;
  name: Schemas.LoadBalancingComponentsSchemasName;
  networks?: Schemas.LoadBalancingNetworks;
  pop_pools?: Schemas.LoadBalancingPopPools;
  proxied?: Schemas.LoadBalancingProxied;
  random_steering?: Schemas.LoadBalancingRandomSteering;
  region_pools?: Schemas.LoadBalancingRegionPools;
  rules?: Schemas.LoadBalancingRules;
  session_affinity?: Schemas.LoadBalancingSessionAffinity;
  session_affinity_attributes?: Schemas.LoadBalancingSessionAffinityAttributes;
  session_affinity_ttl?: Schemas.LoadBalancingSessionAffinityTtl;
  steering_policy?: Schemas.LoadBalancingSteeringPolicy;
  ttl?: Schemas.LoadBalancingTtl;
};

export type LoadBalancersCreateLoadBalancerVariables = {
  body: LoadBalancersCreateLoadBalancerRequestBody;
  pathParams: LoadBalancersCreateLoadBalancerPathParams;
} & FetcherExtraProps;

/**
 * Create a new load balancer.
 */
export const loadBalancersCreateLoadBalancer = (
  variables: LoadBalancersCreateLoadBalancerVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingLoadBalancerComponentsSchemasSingleResponse,
    LoadBalancersCreateLoadBalancerError,
    LoadBalancersCreateLoadBalancerRequestBody,
    {},
    {},
    LoadBalancersCreateLoadBalancerPathParams
  >({ url: '/zones/{zoneId}/load_balancers', method: 'post', ...variables, signal });

export type LoadBalancersDeleteLoadBalancerPathParams = {
  zoneId: Schemas.LoadBalancingLoadBalancerComponentsSchemasIdentifier;
  loadBalancerId: Schemas.LoadBalancingLoadBalancerComponentsSchemasIdentifier;
};

export type LoadBalancersDeleteLoadBalancerError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingComponentsSchemasIdResponse & Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancersDeleteLoadBalancerVariables = {
  pathParams: LoadBalancersDeleteLoadBalancerPathParams;
} & FetcherExtraProps;

/**
 * Delete a configured load balancer.
 */
export const loadBalancersDeleteLoadBalancer = (
  variables: LoadBalancersDeleteLoadBalancerVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingComponentsSchemasIdResponse,
    LoadBalancersDeleteLoadBalancerError,
    undefined,
    {},
    {},
    LoadBalancersDeleteLoadBalancerPathParams
  >({ url: '/zones/{zoneId}/load_balancers/{loadBalancerId}', method: 'delete', ...variables, signal });

export type LoadBalancersLoadBalancerDetailsPathParams = {
  zoneId: Schemas.LoadBalancingLoadBalancerComponentsSchemasIdentifier;
  loadBalancerId: Schemas.LoadBalancingLoadBalancerComponentsSchemasIdentifier;
};

export type LoadBalancersLoadBalancerDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingLoadBalancerComponentsSchemasSingleResponse &
    Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancersLoadBalancerDetailsVariables = {
  pathParams: LoadBalancersLoadBalancerDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetch a single configured load balancer.
 */
export const loadBalancersLoadBalancerDetails = (
  variables: LoadBalancersLoadBalancerDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingLoadBalancerComponentsSchemasSingleResponse,
    LoadBalancersLoadBalancerDetailsError,
    undefined,
    {},
    {},
    LoadBalancersLoadBalancerDetailsPathParams
  >({ url: '/zones/{zoneId}/load_balancers/{loadBalancerId}', method: 'get', ...variables, signal });

export type LoadBalancersPatchLoadBalancerPathParams = {
  zoneId: Schemas.LoadBalancingLoadBalancerComponentsSchemasIdentifier;
  loadBalancerId: Schemas.LoadBalancingLoadBalancerComponentsSchemasIdentifier;
};

export type LoadBalancersPatchLoadBalancerError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingLoadBalancerComponentsSchemasSingleResponse &
    Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancersPatchLoadBalancerRequestBody = {
  adaptive_routing?: Schemas.LoadBalancingAdaptiveRouting;
  country_pools?: Schemas.LoadBalancingCountryPools;
  default_pools?: Schemas.LoadBalancingDefaultPools;
  description?: Schemas.LoadBalancingComponentsSchemasDescription;
  enabled?: Schemas.LoadBalancingComponentsSchemasEnabled;
  fallback_pool?: Schemas.LoadBalancingFallbackPool;
  location_strategy?: Schemas.LoadBalancingLocationStrategy;
  name?: Schemas.LoadBalancingComponentsSchemasName;
  pop_pools?: Schemas.LoadBalancingPopPools;
  proxied?: Schemas.LoadBalancingProxied;
  random_steering?: Schemas.LoadBalancingRandomSteering;
  region_pools?: Schemas.LoadBalancingRegionPools;
  rules?: Schemas.LoadBalancingRules;
  session_affinity?: Schemas.LoadBalancingSessionAffinity;
  session_affinity_attributes?: Schemas.LoadBalancingSessionAffinityAttributes;
  session_affinity_ttl?: Schemas.LoadBalancingSessionAffinityTtl;
  steering_policy?: Schemas.LoadBalancingSteeringPolicy;
  ttl?: Schemas.LoadBalancingTtl;
};

export type LoadBalancersPatchLoadBalancerVariables = {
  body?: LoadBalancersPatchLoadBalancerRequestBody;
  pathParams: LoadBalancersPatchLoadBalancerPathParams;
} & FetcherExtraProps;

/**
 * Apply changes to an existing load balancer, overwriting the supplied properties.
 */
export const loadBalancersPatchLoadBalancer = (
  variables: LoadBalancersPatchLoadBalancerVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingLoadBalancerComponentsSchemasSingleResponse,
    LoadBalancersPatchLoadBalancerError,
    LoadBalancersPatchLoadBalancerRequestBody,
    {},
    {},
    LoadBalancersPatchLoadBalancerPathParams
  >({ url: '/zones/{zoneId}/load_balancers/{loadBalancerId}', method: 'patch', ...variables, signal });

export type LoadBalancersUpdateLoadBalancerPathParams = {
  zoneId: Schemas.LoadBalancingLoadBalancerComponentsSchemasIdentifier;
  loadBalancerId: Schemas.LoadBalancingLoadBalancerComponentsSchemasIdentifier;
};

export type LoadBalancersUpdateLoadBalancerError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LoadBalancingLoadBalancerComponentsSchemasSingleResponse &
    Schemas.LoadBalancingApiResponseCommonFailure;
}>;

export type LoadBalancersUpdateLoadBalancerRequestBody = {
  adaptive_routing?: Schemas.LoadBalancingAdaptiveRouting;
  country_pools?: Schemas.LoadBalancingCountryPools;
  default_pools: Schemas.LoadBalancingDefaultPools;
  description?: Schemas.LoadBalancingComponentsSchemasDescription;
  enabled?: Schemas.LoadBalancingComponentsSchemasEnabled;
  fallback_pool: Schemas.LoadBalancingFallbackPool;
  location_strategy?: Schemas.LoadBalancingLocationStrategy;
  name: Schemas.LoadBalancingComponentsSchemasName;
  networks?: Schemas.LoadBalancingNetworks;
  pop_pools?: Schemas.LoadBalancingPopPools;
  proxied?: Schemas.LoadBalancingProxied;
  random_steering?: Schemas.LoadBalancingRandomSteering;
  region_pools?: Schemas.LoadBalancingRegionPools;
  rules?: Schemas.LoadBalancingRules;
  session_affinity?: Schemas.LoadBalancingSessionAffinity;
  session_affinity_attributes?: Schemas.LoadBalancingSessionAffinityAttributes;
  session_affinity_ttl?: Schemas.LoadBalancingSessionAffinityTtl;
  steering_policy?: Schemas.LoadBalancingSteeringPolicy;
  ttl?: Schemas.LoadBalancingTtl;
};

export type LoadBalancersUpdateLoadBalancerVariables = {
  body: LoadBalancersUpdateLoadBalancerRequestBody;
  pathParams: LoadBalancersUpdateLoadBalancerPathParams;
} & FetcherExtraProps;

/**
 * Update a configured load balancer.
 */
export const loadBalancersUpdateLoadBalancer = (
  variables: LoadBalancersUpdateLoadBalancerVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LoadBalancingLoadBalancerComponentsSchemasSingleResponse,
    LoadBalancersUpdateLoadBalancerError,
    LoadBalancersUpdateLoadBalancerRequestBody,
    {},
    {},
    LoadBalancersUpdateLoadBalancerPathParams
  >({ url: '/zones/{zoneId}/load_balancers/{loadBalancerId}', method: 'put', ...variables, signal });

export type GetZonesZoneIdLogpushDatasetsDatasetIdFieldsPathParams = {
  datasetId: Schemas.LogpushDataset;
  zoneId: Schemas.LogpushIdentifier;
};

export type GetZonesZoneIdLogpushDatasetsDatasetIdFieldsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type GetZonesZoneIdLogpushDatasetsDatasetIdFieldsVariables = {
  pathParams: GetZonesZoneIdLogpushDatasetsDatasetIdFieldsPathParams;
} & FetcherExtraProps;

/**
 * Lists all fields available for a dataset. The response result is an object with key-value pairs, where keys are field names, and values are descriptions.
 */
export const getZonesZoneIdLogpushDatasetsDatasetIdFields = (
  variables: GetZonesZoneIdLogpushDatasetsDatasetIdFieldsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushLogpushFieldResponseCollection,
    GetZonesZoneIdLogpushDatasetsDatasetIdFieldsError,
    undefined,
    {},
    {},
    GetZonesZoneIdLogpushDatasetsDatasetIdFieldsPathParams
  >({ url: '/zones/{zoneId}/logpush/datasets/{datasetId}/fields', method: 'get', ...variables, signal });

export type GetZonesZoneIdLogpushDatasetsDatasetIdJobsPathParams = {
  datasetId: Schemas.LogpushDataset;
  zoneId: Schemas.LogpushIdentifier;
};

export type GetZonesZoneIdLogpushDatasetsDatasetIdJobsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type GetZonesZoneIdLogpushDatasetsDatasetIdJobsVariables = {
  pathParams: GetZonesZoneIdLogpushDatasetsDatasetIdJobsPathParams;
} & FetcherExtraProps;

/**
 * Lists Logpush jobs for a zone for a dataset.
 */
export const getZonesZoneIdLogpushDatasetsDatasetIdJobs = (
  variables: GetZonesZoneIdLogpushDatasetsDatasetIdJobsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushLogpushJobResponseCollection,
    GetZonesZoneIdLogpushDatasetsDatasetIdJobsError,
    undefined,
    {},
    {},
    GetZonesZoneIdLogpushDatasetsDatasetIdJobsPathParams
  >({ url: '/zones/{zoneId}/logpush/datasets/{datasetId}/jobs', method: 'get', ...variables, signal });

export type GetZonesZoneIdLogpushEdgeJobsPathParams = {
  zoneId: Schemas.LogpushIdentifier;
};

export type GetZonesZoneIdLogpushEdgeJobsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushInstantLogsJobResponseCollection & Schemas.LogpushApiResponseCommonFailure;
}>;

export type GetZonesZoneIdLogpushEdgeJobsVariables = {
  pathParams: GetZonesZoneIdLogpushEdgeJobsPathParams;
} & FetcherExtraProps;

/**
 * Lists Instant Logs jobs for a zone.
 */
export const getZonesZoneIdLogpushEdgeJobs = (
  variables: GetZonesZoneIdLogpushEdgeJobsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushInstantLogsJobResponseCollection,
    GetZonesZoneIdLogpushEdgeJobsError,
    undefined,
    {},
    {},
    GetZonesZoneIdLogpushEdgeJobsPathParams
  >({ url: '/zones/{zoneId}/logpush/edge', method: 'get', ...variables, signal });

export type PostZonesZoneIdLogpushEdgeJobsPathParams = {
  zoneId: Schemas.LogpushIdentifier;
};

export type PostZonesZoneIdLogpushEdgeJobsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushInstantLogsJobResponseSingle & Schemas.LogpushApiResponseCommonFailure;
}>;

export type PostZonesZoneIdLogpushEdgeJobsRequestBody = {
  fields?: Schemas.LogpushFields;
  filter?: Schemas.LogpushFilter;
  sample?: Schemas.LogpushSample;
};

export type PostZonesZoneIdLogpushEdgeJobsVariables = {
  body?: PostZonesZoneIdLogpushEdgeJobsRequestBody;
  pathParams: PostZonesZoneIdLogpushEdgeJobsPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Instant Logs job for a zone.
 */
export const postZonesZoneIdLogpushEdgeJobs = (
  variables: PostZonesZoneIdLogpushEdgeJobsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushInstantLogsJobResponseSingle,
    PostZonesZoneIdLogpushEdgeJobsError,
    PostZonesZoneIdLogpushEdgeJobsRequestBody,
    {},
    {},
    PostZonesZoneIdLogpushEdgeJobsPathParams
  >({ url: '/zones/{zoneId}/logpush/edge', method: 'post', ...variables, signal });

export type GetZonesZoneIdLogpushJobsPathParams = {
  zoneId: Schemas.LogpushIdentifier;
};

export type GetZonesZoneIdLogpushJobsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type GetZonesZoneIdLogpushJobsVariables = {
  pathParams: GetZonesZoneIdLogpushJobsPathParams;
} & FetcherExtraProps;

/**
 * Lists Logpush jobs for a zone.
 */
export const getZonesZoneIdLogpushJobs = (variables: GetZonesZoneIdLogpushJobsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.LogpushLogpushJobResponseCollection,
    GetZonesZoneIdLogpushJobsError,
    undefined,
    {},
    {},
    GetZonesZoneIdLogpushJobsPathParams
  >({ url: '/zones/{zoneId}/logpush/jobs', method: 'get', ...variables, signal });

export type PostZonesZoneIdLogpushJobsPathParams = {
  zoneId: Schemas.LogpushIdentifier;
};

export type PostZonesZoneIdLogpushJobsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type PostZonesZoneIdLogpushJobsRequestBody = {
  dataset?: Schemas.LogpushDataset;
  destination_conf: Schemas.LogpushDestinationConf;
  enabled?: Schemas.LogpushEnabled;
  frequency?: Schemas.LogpushFrequency;
  kind?: Schemas.LogpushKind;
  logpull_options?: Schemas.LogpushLogpullOptions;
  max_upload_bytes?: Schemas.LogpushMaxUploadBytes;
  max_upload_interval_seconds?: Schemas.LogpushMaxUploadIntervalSeconds;
  max_upload_records?: Schemas.LogpushMaxUploadRecords;
  name?: Schemas.LogpushName;
  output_options?: Schemas.LogpushOutputOptions;
  ownership_challenge?: Schemas.LogpushOwnershipChallenge;
};

export type PostZonesZoneIdLogpushJobsVariables = {
  body: PostZonesZoneIdLogpushJobsRequestBody;
  pathParams: PostZonesZoneIdLogpushJobsPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Logpush job for a zone.
 */
export const postZonesZoneIdLogpushJobs = (variables: PostZonesZoneIdLogpushJobsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.LogpushLogpushJobResponseSingle,
    PostZonesZoneIdLogpushJobsError,
    PostZonesZoneIdLogpushJobsRequestBody,
    {},
    {},
    PostZonesZoneIdLogpushJobsPathParams
  >({ url: '/zones/{zoneId}/logpush/jobs', method: 'post', ...variables, signal });

export type DeleteZonesZoneIdLogpushJobsJobIdPathParams = {
  jobId: Schemas.LogpushId;
  zoneId: Schemas.LogpushIdentifier;
};

export type DeleteZonesZoneIdLogpushJobsJobIdError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type DeleteZonesZoneIdLogpushJobsJobIdResponse = Schemas.LogpushApiResponseCommon & {
  result?: {
    id?: Schemas.LogpushId;
  };
};

export type DeleteZonesZoneIdLogpushJobsJobIdVariables = {
  pathParams: DeleteZonesZoneIdLogpushJobsJobIdPathParams;
} & FetcherExtraProps;

/**
 * Deletes a Logpush job.
 */
export const deleteZonesZoneIdLogpushJobsJobId = (
  variables: DeleteZonesZoneIdLogpushJobsJobIdVariables,
  signal?: AbortSignal
) =>
  fetch<
    DeleteZonesZoneIdLogpushJobsJobIdResponse,
    DeleteZonesZoneIdLogpushJobsJobIdError,
    undefined,
    {},
    {},
    DeleteZonesZoneIdLogpushJobsJobIdPathParams
  >({ url: '/zones/{zoneId}/logpush/jobs/{jobId}', method: 'delete', ...variables, signal });

export type GetZonesZoneIdLogpushJobsJobIdPathParams = {
  jobId: Schemas.LogpushId;
  zoneId: Schemas.LogpushIdentifier;
};

export type GetZonesZoneIdLogpushJobsJobIdError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type GetZonesZoneIdLogpushJobsJobIdVariables = {
  pathParams: GetZonesZoneIdLogpushJobsJobIdPathParams;
} & FetcherExtraProps;

/**
 * Gets the details of a Logpush job.
 */
export const getZonesZoneIdLogpushJobsJobId = (
  variables: GetZonesZoneIdLogpushJobsJobIdVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushLogpushJobResponseSingle,
    GetZonesZoneIdLogpushJobsJobIdError,
    undefined,
    {},
    {},
    GetZonesZoneIdLogpushJobsJobIdPathParams
  >({ url: '/zones/{zoneId}/logpush/jobs/{jobId}', method: 'get', ...variables, signal });

export type PutZonesZoneIdLogpushJobsJobIdPathParams = {
  jobId: Schemas.LogpushId;
  zoneId: Schemas.LogpushIdentifier;
};

export type PutZonesZoneIdLogpushJobsJobIdError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type PutZonesZoneIdLogpushJobsJobIdRequestBody = {
  destination_conf?: Schemas.LogpushDestinationConf;
  enabled?: Schemas.LogpushEnabled;
  frequency?: Schemas.LogpushFrequency;
  kind?: Schemas.LogpushKind;
  logpull_options?: Schemas.LogpushLogpullOptions;
  max_upload_bytes?: Schemas.LogpushMaxUploadBytes;
  max_upload_interval_seconds?: Schemas.LogpushMaxUploadIntervalSeconds;
  max_upload_records?: Schemas.LogpushMaxUploadRecords;
  name?: Schemas.LogpushName;
  output_options?: Schemas.LogpushOutputOptions;
  ownership_challenge?: Schemas.LogpushOwnershipChallenge;
};

export type PutZonesZoneIdLogpushJobsJobIdVariables = {
  body?: PutZonesZoneIdLogpushJobsJobIdRequestBody;
  pathParams: PutZonesZoneIdLogpushJobsJobIdPathParams;
} & FetcherExtraProps;

/**
 * Updates a Logpush job.
 */
export const putZonesZoneIdLogpushJobsJobId = (
  variables: PutZonesZoneIdLogpushJobsJobIdVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushLogpushJobResponseSingle,
    PutZonesZoneIdLogpushJobsJobIdError,
    PutZonesZoneIdLogpushJobsJobIdRequestBody,
    {},
    {},
    PutZonesZoneIdLogpushJobsJobIdPathParams
  >({ url: '/zones/{zoneId}/logpush/jobs/{jobId}', method: 'put', ...variables, signal });

export type PostZonesZoneIdLogpushOwnershipPathParams = {
  zoneId: Schemas.LogpushIdentifier;
};

export type PostZonesZoneIdLogpushOwnershipError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type PostZonesZoneIdLogpushOwnershipRequestBody = {
  destination_conf: Schemas.LogpushDestinationConf;
};

export type PostZonesZoneIdLogpushOwnershipVariables = {
  body: PostZonesZoneIdLogpushOwnershipRequestBody;
  pathParams: PostZonesZoneIdLogpushOwnershipPathParams;
} & FetcherExtraProps;

/**
 * Gets a new ownership challenge sent to your destination.
 */
export const postZonesZoneIdLogpushOwnership = (
  variables: PostZonesZoneIdLogpushOwnershipVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushGetOwnershipResponse,
    PostZonesZoneIdLogpushOwnershipError,
    PostZonesZoneIdLogpushOwnershipRequestBody,
    {},
    {},
    PostZonesZoneIdLogpushOwnershipPathParams
  >({ url: '/zones/{zoneId}/logpush/ownership', method: 'post', ...variables, signal });

export type PostZonesZoneIdLogpushOwnershipValidatePathParams = {
  zoneId: Schemas.LogpushIdentifier;
};

export type PostZonesZoneIdLogpushOwnershipValidateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type PostZonesZoneIdLogpushOwnershipValidateRequestBody = {
  destination_conf: Schemas.LogpushDestinationConf;
  ownership_challenge: Schemas.LogpushOwnershipChallenge;
};

export type PostZonesZoneIdLogpushOwnershipValidateVariables = {
  body: PostZonesZoneIdLogpushOwnershipValidateRequestBody;
  pathParams: PostZonesZoneIdLogpushOwnershipValidatePathParams;
} & FetcherExtraProps;

/**
 * Validates ownership challenge of the destination.
 */
export const postZonesZoneIdLogpushOwnershipValidate = (
  variables: PostZonesZoneIdLogpushOwnershipValidateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushValidateOwnershipResponse,
    PostZonesZoneIdLogpushOwnershipValidateError,
    PostZonesZoneIdLogpushOwnershipValidateRequestBody,
    {},
    {},
    PostZonesZoneIdLogpushOwnershipValidatePathParams
  >({ url: '/zones/{zoneId}/logpush/ownership/validate', method: 'post', ...variables, signal });

export type PostZonesZoneIdLogpushValidateDestinationPathParams = {
  zoneId: Schemas.LogpushIdentifier;
};

export type PostZonesZoneIdLogpushValidateDestinationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type PostZonesZoneIdLogpushValidateDestinationRequestBody = {
  destination_conf: Schemas.LogpushDestinationConf;
};

export type PostZonesZoneIdLogpushValidateDestinationVariables = {
  body: PostZonesZoneIdLogpushValidateDestinationRequestBody;
  pathParams: PostZonesZoneIdLogpushValidateDestinationPathParams;
} & FetcherExtraProps;

/**
 * Validates destination.
 */
export const postZonesZoneIdLogpushValidateDestination = (
  variables: PostZonesZoneIdLogpushValidateDestinationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushValidateResponse,
    PostZonesZoneIdLogpushValidateDestinationError,
    PostZonesZoneIdLogpushValidateDestinationRequestBody,
    {},
    {},
    PostZonesZoneIdLogpushValidateDestinationPathParams
  >({ url: '/zones/{zoneId}/logpush/validate/destination', method: 'post', ...variables, signal });

export type PostZonesZoneIdLogpushValidateDestinationExistsPathParams = {
  zoneId: Schemas.LogpushIdentifier;
};

export type PostZonesZoneIdLogpushValidateDestinationExistsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type PostZonesZoneIdLogpushValidateDestinationExistsRequestBody = {
  destination_conf: Schemas.LogpushDestinationConf;
};

export type PostZonesZoneIdLogpushValidateDestinationExistsVariables = {
  body: PostZonesZoneIdLogpushValidateDestinationExistsRequestBody;
  pathParams: PostZonesZoneIdLogpushValidateDestinationExistsPathParams;
} & FetcherExtraProps;

/**
 * Checks if there is an existing job with a destination.
 */
export const postZonesZoneIdLogpushValidateDestinationExists = (
  variables: PostZonesZoneIdLogpushValidateDestinationExistsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushDestinationExistsResponse,
    PostZonesZoneIdLogpushValidateDestinationExistsError,
    PostZonesZoneIdLogpushValidateDestinationExistsRequestBody,
    {},
    {},
    PostZonesZoneIdLogpushValidateDestinationExistsPathParams
  >({ url: '/zones/{zoneId}/logpush/validate/destination/exists', method: 'post', ...variables, signal });

export type PostZonesZoneIdLogpushValidateOriginPathParams = {
  zoneId: Schemas.LogpushIdentifier;
};

export type PostZonesZoneIdLogpushValidateOriginError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogpushApiResponseCommonFailure;
}>;

export type PostZonesZoneIdLogpushValidateOriginRequestBody = {
  logpull_options: Schemas.LogpushLogpullOptions;
};

export type PostZonesZoneIdLogpushValidateOriginVariables = {
  body: PostZonesZoneIdLogpushValidateOriginRequestBody;
  pathParams: PostZonesZoneIdLogpushValidateOriginPathParams;
} & FetcherExtraProps;

/**
 * Validates logpull origin with logpull_options.
 */
export const postZonesZoneIdLogpushValidateOrigin = (
  variables: PostZonesZoneIdLogpushValidateOriginVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogpushValidateResponse,
    PostZonesZoneIdLogpushValidateOriginError,
    PostZonesZoneIdLogpushValidateOriginRequestBody,
    {},
    {},
    PostZonesZoneIdLogpushValidateOriginPathParams
  >({ url: '/zones/{zoneId}/logpush/validate/origin', method: 'post', ...variables, signal });

export type GetZonesZoneIdLogsControlRetentionFlagPathParams = {
  zoneId: Schemas.LogcontrolIdentifier;
};

export type GetZonesZoneIdLogsControlRetentionFlagError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogcontrolApiResponseCommonFailure;
}>;

export type GetZonesZoneIdLogsControlRetentionFlagVariables = {
  pathParams: GetZonesZoneIdLogsControlRetentionFlagPathParams;
} & FetcherExtraProps;

/**
 * Gets log retention flag for Logpull API.
 */
export const getZonesZoneIdLogsControlRetentionFlag = (
  variables: GetZonesZoneIdLogsControlRetentionFlagVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogcontrolRetentionFlagResponseSingle,
    GetZonesZoneIdLogsControlRetentionFlagError,
    undefined,
    {},
    {},
    GetZonesZoneIdLogsControlRetentionFlagPathParams
  >({ url: '/zones/{zoneId}/logs/control/retention/flag', method: 'get', ...variables, signal });

export type PostZonesZoneIdLogsControlRetentionFlagPathParams = {
  zoneId: Schemas.LogcontrolIdentifier;
};

export type PostZonesZoneIdLogsControlRetentionFlagError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogcontrolApiResponseCommonFailure;
}>;

export type PostZonesZoneIdLogsControlRetentionFlagVariables = {
  body?: Schemas.LogcontrolRetentionFlag;
  pathParams: PostZonesZoneIdLogsControlRetentionFlagPathParams;
} & FetcherExtraProps;

/**
 * Updates log retention flag for Logpull API.
 */
export const postZonesZoneIdLogsControlRetentionFlag = (
  variables: PostZonesZoneIdLogsControlRetentionFlagVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogcontrolRetentionFlagResponseSingle,
    PostZonesZoneIdLogsControlRetentionFlagError,
    Schemas.LogcontrolRetentionFlag,
    {},
    {},
    PostZonesZoneIdLogsControlRetentionFlagPathParams
  >({ url: '/zones/{zoneId}/logs/control/retention/flag', method: 'post', ...variables, signal });

export type GetZonesZoneIdLogsRayidsRayIdPathParams = {
  zoneId: Schemas.LogshareIdentifier;
  rayId: Schemas.LogshareRayIdentifier;
};

export type GetZonesZoneIdLogsRayidsRayIdQueryParams = {
  fields?: Schemas.LogshareFields;
  timestamps?: Schemas.LogshareTimestamps;
};

export type GetZonesZoneIdLogsRayidsRayIdError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogshareApiResponseCommonFailure;
}>;

export type GetZonesZoneIdLogsRayidsRayIdVariables = {
  pathParams: GetZonesZoneIdLogsRayidsRayIdPathParams;
  queryParams?: GetZonesZoneIdLogsRayidsRayIdQueryParams;
} & FetcherExtraProps;

/**
 * The `/rayids` api route allows lookups by specific rayid. The rayids route will return zero, one, or more records (ray ids are not unique).
 */
export const getZonesZoneIdLogsRayidsRayId = (
  variables: GetZonesZoneIdLogsRayidsRayIdVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogshareLogsResponseJsonLines,
    GetZonesZoneIdLogsRayidsRayIdError,
    undefined,
    {},
    GetZonesZoneIdLogsRayidsRayIdQueryParams,
    GetZonesZoneIdLogsRayidsRayIdPathParams
  >({ url: '/zones/{zoneId}/logs/rayids/{rayId}', method: 'get', ...variables, signal });

export type GetZonesZoneIdLogsReceivedPathParams = {
  zoneId: Schemas.LogshareIdentifier;
};

export type GetZonesZoneIdLogsReceivedQueryParams = {
  start?: Schemas.LogshareStart;
  end: Schemas.LogshareEnd;
  fields?: Schemas.LogshareFields;
  sample?: Schemas.LogshareSample;
  count?: Schemas.LogshareCount;
  timestamps?: Schemas.LogshareTimestamps;
};

export type GetZonesZoneIdLogsReceivedError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogshareApiResponseCommonFailure;
}>;

export type GetZonesZoneIdLogsReceivedVariables = {
  pathParams: GetZonesZoneIdLogsReceivedPathParams;
  queryParams: GetZonesZoneIdLogsReceivedQueryParams;
} & FetcherExtraProps;

/**
 * The `/received` api route allows customers to retrieve their edge HTTP logs. The basic access pattern is "give me all the logs for zone Z for minute M", where the minute M refers to the time records were received at Cloudflare's central data center. `start` is inclusive, and `end` is exclusive. Because of that, to get all data, at minutely cadence, starting at 10AM, the proper values are: `start=2018-05-20T10:00:00Z&end=2018-05-20T10:01:00Z`, then `start=2018-05-20T10:01:00Z&end=2018-05-20T10:02:00Z` and so on; the overlap will be handled properly.
 */
export const getZonesZoneIdLogsReceived = (variables: GetZonesZoneIdLogsReceivedVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.LogshareLogsResponseJsonLines,
    GetZonesZoneIdLogsReceivedError,
    undefined,
    {},
    GetZonesZoneIdLogsReceivedQueryParams,
    GetZonesZoneIdLogsReceivedPathParams
  >({ url: '/zones/{zoneId}/logs/received', method: 'get', ...variables, signal });

export type GetZonesZoneIdLogsReceivedFieldsPathParams = {
  zoneId: Schemas.LogshareIdentifier;
};

export type GetZonesZoneIdLogsReceivedFieldsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.LogshareApiResponseCommonFailure;
}>;

export type GetZonesZoneIdLogsReceivedFieldsVariables = {
  pathParams: GetZonesZoneIdLogsReceivedFieldsPathParams;
} & FetcherExtraProps;

/**
 * Lists all fields available. The response is json object with key-value pairs, where keys are field names, and values are descriptions.
 */
export const getZonesZoneIdLogsReceivedFields = (
  variables: GetZonesZoneIdLogsReceivedFieldsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.LogshareFieldsResponse,
    GetZonesZoneIdLogsReceivedFieldsError,
    undefined,
    {},
    {},
    GetZonesZoneIdLogsReceivedFieldsPathParams
  >({ url: '/zones/{zoneId}/logs/received/fields', method: 'get', ...variables, signal });

export type DeleteManagedTransformsPathParams = {
  zoneId: Schemas.RulesetsZoneId;
};

export type DeleteManagedTransformsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type DeleteManagedTransformsVariables = {
  pathParams: DeleteManagedTransformsPathParams;
} & FetcherExtraProps;

/**
 * Disables all Managed Transforms.
 */
export const deleteManagedTransforms = (variables: DeleteManagedTransformsVariables, signal?: AbortSignal) =>
  fetch<Responses.RulesetsEmpty, DeleteManagedTransformsError, undefined, {}, {}, DeleteManagedTransformsPathParams>({
    url: '/zones/{zoneId}/managed_headers',
    method: 'delete',
    ...variables,
    signal
  });

export type ListManagedTransformsPathParams = {
  zoneId: Schemas.RulesetsZoneId;
};

export type ListManagedTransformsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type ListManagedTransformsVariables = {
  pathParams: ListManagedTransformsPathParams;
} & FetcherExtraProps;

/**
 * Fetches a list of all Managed Transforms.
 */
export const listManagedTransforms = (variables: ListManagedTransformsVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RulesetsManagedTransforms,
    ListManagedTransformsError,
    undefined,
    {},
    {},
    ListManagedTransformsPathParams
  >({ url: '/zones/{zoneId}/managed_headers', method: 'get', ...variables, signal });

export type UpdateManagedTransformsPathParams = {
  zoneId: Schemas.RulesetsZoneId;
};

export type UpdateManagedTransformsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type UpdateManagedTransformsVariables = {
  body: RequestBodies.RulesetsManagedTransforms;
  pathParams: UpdateManagedTransformsPathParams;
} & FetcherExtraProps;

/**
 * Updates the status of one or more Managed Transforms.
 */
export const updateManagedTransforms = (variables: UpdateManagedTransformsVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RulesetsManagedTransforms,
    UpdateManagedTransformsError,
    RequestBodies.RulesetsManagedTransforms,
    {},
    {},
    UpdateManagedTransformsPathParams
  >({ url: '/zones/{zoneId}/managed_headers', method: 'patch', ...variables, signal });

export type ZoneLevelAuthenticatedOriginPullsListCertificatesPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type ZoneLevelAuthenticatedOriginPullsListCertificatesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesComponentsSchemasCertificateResponseCollection &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type ZoneLevelAuthenticatedOriginPullsListCertificatesVariables = {
  pathParams: ZoneLevelAuthenticatedOriginPullsListCertificatesPathParams;
} & FetcherExtraProps;

export const zoneLevelAuthenticatedOriginPullsListCertificates = (
  variables: ZoneLevelAuthenticatedOriginPullsListCertificatesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesComponentsSchemasCertificateResponseCollection,
    ZoneLevelAuthenticatedOriginPullsListCertificatesError,
    undefined,
    {},
    {},
    ZoneLevelAuthenticatedOriginPullsListCertificatesPathParams
  >({ url: '/zones/{zoneId}/origin_tls_client_auth', method: 'get', ...variables, signal });

export type ZoneLevelAuthenticatedOriginPullsUploadCertificatePathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type ZoneLevelAuthenticatedOriginPullsUploadCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesComponentsSchemasCertificateResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type ZoneLevelAuthenticatedOriginPullsUploadCertificateRequestBody = {
  certificate: Schemas.TlsCertificatesAndHostnamesZoneAuthenticatedOriginPullComponentsSchemasCertificate;
  private_key: Schemas.TlsCertificatesAndHostnamesPrivateKey;
};

export type ZoneLevelAuthenticatedOriginPullsUploadCertificateVariables = {
  body: ZoneLevelAuthenticatedOriginPullsUploadCertificateRequestBody;
  pathParams: ZoneLevelAuthenticatedOriginPullsUploadCertificatePathParams;
} & FetcherExtraProps;

/**
 * Upload your own certificate you want Cloudflare to use for edge-to-origin communication to override the shared certificate. Please note that it is important to keep only one certificate active. Also, make sure to enable zone-level authenticated origin pulls by making a PUT call to settings endpoint to see the uploaded certificate in use.
 */
export const zoneLevelAuthenticatedOriginPullsUploadCertificate = (
  variables: ZoneLevelAuthenticatedOriginPullsUploadCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesComponentsSchemasCertificateResponseSingle,
    ZoneLevelAuthenticatedOriginPullsUploadCertificateError,
    ZoneLevelAuthenticatedOriginPullsUploadCertificateRequestBody,
    {},
    {},
    ZoneLevelAuthenticatedOriginPullsUploadCertificatePathParams
  >({ url: '/zones/{zoneId}/origin_tls_client_auth', method: 'post', ...variables, signal });

export type PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationError =
  Fetcher.ErrorWrapper<{
    status: 400;
    payload: Schemas.TlsCertificatesAndHostnamesHostnameAopResponseCollection &
      Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
  }>;

export type PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationRequestBody = {
  config: Schemas.TlsCertificatesAndHostnamesConfig;
};

export type PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationVariables = {
  body: PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationRequestBody;
  pathParams: PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationPathParams;
} & FetcherExtraProps;

/**
 * Associate a hostname to a certificate and enable, disable or invalidate the association. If disabled, client certificate will not be sent to the hostname even if activated at the zone level. 100 maximum associations on a single certificate are allowed. Note: Use a null value for parameter *enabled* to invalidate the association.
 */
export const perHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthentication = (
  variables: PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesHostnameAopResponseCollection,
    PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationError,
    PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationRequestBody,
    {},
    {},
    PerHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthenticationPathParams
  >({ url: '/zones/{zoneId}/origin_tls_client_auth/hostnames', method: 'put', ...variables, signal });

export type PerHostnameAuthenticatedOriginPullListCertificatesPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type PerHostnameAuthenticatedOriginPullListCertificatesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasCertificateResponseCollection &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type PerHostnameAuthenticatedOriginPullListCertificatesVariables = {
  pathParams: PerHostnameAuthenticatedOriginPullListCertificatesPathParams;
} & FetcherExtraProps;

export const perHostnameAuthenticatedOriginPullListCertificates = (
  variables: PerHostnameAuthenticatedOriginPullListCertificatesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasCertificateResponseCollection,
    PerHostnameAuthenticatedOriginPullListCertificatesError,
    undefined,
    {},
    {},
    PerHostnameAuthenticatedOriginPullListCertificatesPathParams
  >({ url: '/zones/{zoneId}/origin_tls_client_auth/hostnames/certificates', method: 'get', ...variables, signal });

export type PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificatePathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasCertificateResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateRequestBody = {
  certificate: Schemas.TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasCertificate;
  private_key: Schemas.TlsCertificatesAndHostnamesSchemasPrivateKey;
};

export type PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateVariables = {
  body: PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateRequestBody;
  pathParams: PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificatePathParams;
} & FetcherExtraProps;

/**
 * Upload a certificate to be used for client authentication on a hostname. 10 hostname certificates per zone are allowed.
 */
export const perHostnameAuthenticatedOriginPullUploadAHostnameClientCertificate = (
  variables: PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasCertificateResponseSingle,
    PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateError,
    PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificateRequestBody,
    {},
    {},
    PerHostnameAuthenticatedOriginPullUploadAHostnameClientCertificatePathParams
  >({ url: '/zones/{zoneId}/origin_tls_client_auth/hostnames/certificates', method: 'post', ...variables, signal });

export type PerHostnameAuthenticatedOriginPullDeleteHostnameClientCertificatePathParams = {
  certificateId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type PerHostnameAuthenticatedOriginPullDeleteHostnameClientCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasCertificateResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type PerHostnameAuthenticatedOriginPullDeleteHostnameClientCertificateVariables = {
  pathParams: PerHostnameAuthenticatedOriginPullDeleteHostnameClientCertificatePathParams;
} & FetcherExtraProps;

export const perHostnameAuthenticatedOriginPullDeleteHostnameClientCertificate = (
  variables: PerHostnameAuthenticatedOriginPullDeleteHostnameClientCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasCertificateResponseSingle,
    PerHostnameAuthenticatedOriginPullDeleteHostnameClientCertificateError,
    undefined,
    {},
    {},
    PerHostnameAuthenticatedOriginPullDeleteHostnameClientCertificatePathParams
  >({
    url: '/zones/{zoneId}/origin_tls_client_auth/hostnames/certificates/{certificateId}',
    method: 'delete',
    ...variables,
    signal
  });

export type PerHostnameAuthenticatedOriginPullGetTheHostnameClientCertificatePathParams = {
  certificateId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type PerHostnameAuthenticatedOriginPullGetTheHostnameClientCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasCertificateResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type PerHostnameAuthenticatedOriginPullGetTheHostnameClientCertificateVariables = {
  pathParams: PerHostnameAuthenticatedOriginPullGetTheHostnameClientCertificatePathParams;
} & FetcherExtraProps;

/**
 * Get the certificate by ID to be used for client authentication on a hostname.
 */
export const perHostnameAuthenticatedOriginPullGetTheHostnameClientCertificate = (
  variables: PerHostnameAuthenticatedOriginPullGetTheHostnameClientCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasCertificateResponseSingle,
    PerHostnameAuthenticatedOriginPullGetTheHostnameClientCertificateError,
    undefined,
    {},
    {},
    PerHostnameAuthenticatedOriginPullGetTheHostnameClientCertificatePathParams
  >({
    url: '/zones/{zoneId}/origin_tls_client_auth/hostnames/certificates/{certificateId}',
    method: 'get',
    ...variables,
    signal
  });

export type PerHostnameAuthenticatedOriginPullGetTheHostnameStatusForClientAuthenticationPathParams = {
  hostname: Schemas.TlsCertificatesAndHostnamesSchemasHostname;
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type PerHostnameAuthenticatedOriginPullGetTheHostnameStatusForClientAuthenticationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesHostnameAopSingleResponse &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type PerHostnameAuthenticatedOriginPullGetTheHostnameStatusForClientAuthenticationVariables = {
  pathParams: PerHostnameAuthenticatedOriginPullGetTheHostnameStatusForClientAuthenticationPathParams;
} & FetcherExtraProps;

export const perHostnameAuthenticatedOriginPullGetTheHostnameStatusForClientAuthentication = (
  variables: PerHostnameAuthenticatedOriginPullGetTheHostnameStatusForClientAuthenticationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesHostnameAopSingleResponse,
    PerHostnameAuthenticatedOriginPullGetTheHostnameStatusForClientAuthenticationError,
    undefined,
    {},
    {},
    PerHostnameAuthenticatedOriginPullGetTheHostnameStatusForClientAuthenticationPathParams
  >({ url: '/zones/{zoneId}/origin_tls_client_auth/hostnames/{hostname}', method: 'get', ...variables, signal });

export type ZoneLevelAuthenticatedOriginPullsGetEnablementSettingForZonePathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type ZoneLevelAuthenticatedOriginPullsGetEnablementSettingForZoneError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesEnabledResponse &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type ZoneLevelAuthenticatedOriginPullsGetEnablementSettingForZoneVariables = {
  pathParams: ZoneLevelAuthenticatedOriginPullsGetEnablementSettingForZonePathParams;
} & FetcherExtraProps;

/**
 * Get whether zone-level authenticated origin pulls is enabled or not. It is false by default.
 */
export const zoneLevelAuthenticatedOriginPullsGetEnablementSettingForZone = (
  variables: ZoneLevelAuthenticatedOriginPullsGetEnablementSettingForZoneVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesEnabledResponse,
    ZoneLevelAuthenticatedOriginPullsGetEnablementSettingForZoneError,
    undefined,
    {},
    {},
    ZoneLevelAuthenticatedOriginPullsGetEnablementSettingForZonePathParams
  >({ url: '/zones/{zoneId}/origin_tls_client_auth/settings', method: 'get', ...variables, signal });

export type ZoneLevelAuthenticatedOriginPullsSetEnablementForZonePathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesEnabledResponse &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneRequestBody = {
  enabled: Schemas.TlsCertificatesAndHostnamesZoneAuthenticatedOriginPullComponentsSchemasEnabled;
};

export type ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneVariables = {
  body: ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneRequestBody;
  pathParams: ZoneLevelAuthenticatedOriginPullsSetEnablementForZonePathParams;
} & FetcherExtraProps;

/**
 * Enable or disable zone-level authenticated origin pulls. 'enabled' should be set true either before/after the certificate is uploaded to see the certificate in use.
 */
export const zoneLevelAuthenticatedOriginPullsSetEnablementForZone = (
  variables: ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesEnabledResponse,
    ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneError,
    ZoneLevelAuthenticatedOriginPullsSetEnablementForZoneRequestBody,
    {},
    {},
    ZoneLevelAuthenticatedOriginPullsSetEnablementForZonePathParams
  >({ url: '/zones/{zoneId}/origin_tls_client_auth/settings', method: 'put', ...variables, signal });

export type ZoneLevelAuthenticatedOriginPullsDeleteCertificatePathParams = {
  certificateId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type ZoneLevelAuthenticatedOriginPullsDeleteCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesComponentsSchemasCertificateResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type ZoneLevelAuthenticatedOriginPullsDeleteCertificateVariables = {
  pathParams: ZoneLevelAuthenticatedOriginPullsDeleteCertificatePathParams;
} & FetcherExtraProps;

export const zoneLevelAuthenticatedOriginPullsDeleteCertificate = (
  variables: ZoneLevelAuthenticatedOriginPullsDeleteCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesComponentsSchemasCertificateResponseSingle,
    ZoneLevelAuthenticatedOriginPullsDeleteCertificateError,
    undefined,
    {},
    {},
    ZoneLevelAuthenticatedOriginPullsDeleteCertificatePathParams
  >({ url: '/zones/{zoneId}/origin_tls_client_auth/{certificateId}', method: 'delete', ...variables, signal });

export type ZoneLevelAuthenticatedOriginPullsGetCertificateDetailsPathParams = {
  certificateId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type ZoneLevelAuthenticatedOriginPullsGetCertificateDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesComponentsSchemasCertificateResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type ZoneLevelAuthenticatedOriginPullsGetCertificateDetailsVariables = {
  pathParams: ZoneLevelAuthenticatedOriginPullsGetCertificateDetailsPathParams;
} & FetcherExtraProps;

export const zoneLevelAuthenticatedOriginPullsGetCertificateDetails = (
  variables: ZoneLevelAuthenticatedOriginPullsGetCertificateDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesComponentsSchemasCertificateResponseSingle,
    ZoneLevelAuthenticatedOriginPullsGetCertificateDetailsError,
    undefined,
    {},
    {},
    ZoneLevelAuthenticatedOriginPullsGetCertificateDetailsPathParams
  >({ url: '/zones/{zoneId}/origin_tls_client_auth/{certificateId}', method: 'get', ...variables, signal });

export type PageShieldGetSettingsPathParams = {
  zoneId: Schemas.PageShieldId;
};

export type PageShieldGetSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PageShieldApiResponseCommonFailure;
}>;

export type PageShieldGetSettingsResponse = Schemas.PageShieldApiGetResponseCollection & {
  result?: Schemas.PageShieldGetZoneSettingsResponse;
};

export type PageShieldGetSettingsVariables = {
  pathParams: PageShieldGetSettingsPathParams;
} & FetcherExtraProps;

/**
 * Fetches the Page Shield settings.
 */
export const pageShieldGetSettings = (variables: PageShieldGetSettingsVariables, signal?: AbortSignal) =>
  fetch<PageShieldGetSettingsResponse, PageShieldGetSettingsError, undefined, {}, {}, PageShieldGetSettingsPathParams>({
    url: '/zones/{zoneId}/page_shield',
    method: 'get',
    ...variables,
    signal
  });

export type PageShieldUpdateSettingsPathParams = {
  zoneId: Schemas.PageShieldId;
};

export type PageShieldUpdateSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PageShieldApiResponseCommonFailure;
}>;

export type PageShieldUpdateSettingsResponse = Schemas.PageShieldZoneSettingsResponseSingle & {
  result?: Schemas.PageShieldUpdateZoneSettingsResponse;
};

export type PageShieldUpdateSettingsRequestBody = {
  enabled?: Schemas.PageShieldEnabled;
  use_cloudflare_reporting_endpoint?: Schemas.PageShieldUseCloudflareReportingEndpoint;
  use_connection_url_path?: Schemas.PageShieldUseConnectionUrlPath;
};

export type PageShieldUpdateSettingsVariables = {
  body?: PageShieldUpdateSettingsRequestBody;
  pathParams: PageShieldUpdateSettingsPathParams;
} & FetcherExtraProps;

/**
 * Updates Page Shield settings.
 */
export const pageShieldUpdateSettings = (variables: PageShieldUpdateSettingsVariables, signal?: AbortSignal) =>
  fetch<
    PageShieldUpdateSettingsResponse,
    PageShieldUpdateSettingsError,
    PageShieldUpdateSettingsRequestBody,
    {},
    {},
    PageShieldUpdateSettingsPathParams
  >({ url: '/zones/{zoneId}/page_shield', method: 'put', ...variables, signal });

export type PageShieldListConnectionsPathParams = {
  zoneId: Schemas.PageShieldId;
};

export type PageShieldListConnectionsQueryParams = {
  /**
   * @example blog.cloudflare.com,www.example
   */
  exclude_urls?: string;
  /**
   * @example blog.cloudflare.com,www.example
   */
  urls?: string;
  /**
   * @example blog.cloudflare.com,www.example*,*cloudflare.com
   */
  hosts?: string;
  /**
   * @example 2
   */
  page?: string;
  /**
   * @example 100
   * @maximum 100
   * @minimum 1
   */
  per_page?: number;
  /**
   * @example first_seen_at
   */
  order_by?: 'first_seen_at' | 'last_seen_at';
  /**
   * @example asc
   */
  direction?: 'asc' | 'desc';
  /**
   * @example true
   */
  prioritize_malicious?: boolean;
  /**
   * @example true
   */
  exclude_cdn_cgi?: boolean;
  /**
   * @example active,inactive
   */
  status?: string;
  /**
   * @example [see original specs]
   */
  page_url?: string;
  /**
   * @example csv
   */
  ['export']?: 'csv';
};

export type PageShieldListConnectionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PageShieldApiResponseCommonFailure;
}>;

export type PageShieldListConnectionsVariables = {
  pathParams: PageShieldListConnectionsPathParams;
  queryParams?: PageShieldListConnectionsQueryParams;
} & FetcherExtraProps;

/**
 * Lists all connections detected by Page Shield.
 */
export const pageShieldListConnections = (variables: PageShieldListConnectionsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.PageShieldListZoneConnectionsResponse,
    PageShieldListConnectionsError,
    undefined,
    {},
    PageShieldListConnectionsQueryParams,
    PageShieldListConnectionsPathParams
  >({ url: '/zones/{zoneId}/page_shield/connections', method: 'get', ...variables, signal });

export type PageShieldGetConnectionPathParams = {
  zoneId: Schemas.PageShieldId;
  connectionId: Schemas.PageShieldId;
};

export type PageShieldGetConnectionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PageShieldApiResponseCommonFailure;
}>;

export type PageShieldGetConnectionVariables = {
  pathParams: PageShieldGetConnectionPathParams;
} & FetcherExtraProps;

/**
 * Fetches a connection detected by Page Shield by connection ID.
 */
export const pageShieldGetConnection = (variables: PageShieldGetConnectionVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.PageShieldGetZoneConnectionResponse,
    PageShieldGetConnectionError,
    undefined,
    {},
    {},
    PageShieldGetConnectionPathParams
  >({ url: '/zones/{zoneId}/page_shield/connections/{connectionId}', method: 'get', ...variables, signal });

export type PageShieldListCookiesPathParams = {
  zoneId: Schemas.PageShieldId;
};

export type PageShieldListCookiesQueryParams = {
  /**
   * @example blog.cloudflare.com,www.example*,*cloudflare.com
   */
  hosts?: string;
  /**
   * @example 2
   */
  page?: string;
  /**
   * @example 100
   * @maximum 100
   * @minimum 1
   */
  per_page?: number;
  /**
   * @example first_seen_at
   */
  order_by?: 'first_seen_at' | 'last_seen_at';
  /**
   * @example asc
   */
  direction?: 'asc' | 'desc';
  /**
   * @example [see original specs]
   */
  page_url?: string;
  /**
   * @example csv
   */
  ['export']?: 'csv';
  /**
   * @example session_id
   * @maxLength 1024
   */
  name?: string;
  /**
   * @example true
   */
  secure?: boolean;
  /**
   * @example true
   */
  http_only?: boolean;
  /**
   * @example strict
   */
  same_site?: 'lax' | 'strict' | 'none';
  /**
   * @example first_party
   */
  type?: 'first_party' | 'unknown';
  /**
   * @example /
   * @maxLength 1024
   */
  path?: string;
  /**
   * @example example.com
   * @maxLength 1024
   */
  domain?: string;
};

export type PageShieldListCookiesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PageShieldApiResponseCommonFailure;
}>;

export type PageShieldListCookiesVariables = {
  pathParams: PageShieldListCookiesPathParams;
  queryParams?: PageShieldListCookiesQueryParams;
} & FetcherExtraProps;

/**
 * Lists all cookies collected by Page Shield.
 */
export const pageShieldListCookies = (variables: PageShieldListCookiesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.PageShieldListZoneCookiesResponse,
    PageShieldListCookiesError,
    undefined,
    {},
    PageShieldListCookiesQueryParams,
    PageShieldListCookiesPathParams
  >({ url: '/zones/{zoneId}/page_shield/cookies', method: 'get', ...variables, signal });

export type PageShieldGetCookiePathParams = {
  zoneId: Schemas.PageShieldId;
  cookieId: Schemas.PageShieldId;
};

export type PageShieldGetCookieError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PageShieldApiResponseCommonFailure;
}>;

export type PageShieldGetCookieVariables = {
  pathParams: PageShieldGetCookiePathParams;
} & FetcherExtraProps;

/**
 * Fetches a cookie collected by Page Shield by cookie ID.
 */
export const pageShieldGetCookie = (variables: PageShieldGetCookieVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.PageShieldGetZoneCookieResponse,
    PageShieldGetCookieError,
    undefined,
    {},
    {},
    PageShieldGetCookiePathParams
  >({ url: '/zones/{zoneId}/page_shield/cookies/{cookieId}', method: 'get', ...variables, signal });

export type PageShieldListPoliciesPathParams = {
  zoneId: Schemas.PageShieldId;
};

export type PageShieldListPoliciesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PageShieldApiResponseCommonFailure;
}>;

export type PageShieldListPoliciesVariables = {
  pathParams: PageShieldListPoliciesPathParams;
} & FetcherExtraProps;

/**
 * Lists all Page Shield policies.
 */
export const pageShieldListPolicies = (variables: PageShieldListPoliciesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.PageShieldListZonePoliciesResponse,
    PageShieldListPoliciesError,
    undefined,
    {},
    {},
    PageShieldListPoliciesPathParams
  >({ url: '/zones/{zoneId}/page_shield/policies', method: 'get', ...variables, signal });

export type PageShieldCreatePolicyPathParams = {
  zoneId: Schemas.PageShieldId;
};

export type PageShieldCreatePolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PageShieldApiResponseCommonFailure;
}>;

export type PageShieldCreatePolicyVariables = {
  body: Schemas.PageShieldPolicy;
  pathParams: PageShieldCreatePolicyPathParams;
} & FetcherExtraProps;

/**
 * Create a Page Shield policy.
 */
export const pageShieldCreatePolicy = (variables: PageShieldCreatePolicyVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.PageShieldGetZonePolicyResponse,
    PageShieldCreatePolicyError,
    Schemas.PageShieldPolicy,
    {},
    {},
    PageShieldCreatePolicyPathParams
  >({ url: '/zones/{zoneId}/page_shield/policies', method: 'post', ...variables, signal });

export type PageShieldDeletePolicyPathParams = {
  zoneId: Schemas.PageShieldId;
  policyId: Schemas.PageShieldId;
};

export type PageShieldDeletePolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PageShieldApiResponseCommonFailure;
}>;

export type PageShieldDeletePolicyVariables = {
  pathParams: PageShieldDeletePolicyPathParams;
} & FetcherExtraProps;

/**
 * Delete a Page Shield policy by ID.
 */
export const pageShieldDeletePolicy = (variables: PageShieldDeletePolicyVariables, signal?: AbortSignal) =>
  fetch<undefined, PageShieldDeletePolicyError, undefined, {}, {}, PageShieldDeletePolicyPathParams>({
    url: '/zones/{zoneId}/page_shield/policies/{policyId}',
    method: 'delete',
    ...variables,
    signal
  });

export type PageShieldGetPolicyPathParams = {
  zoneId: Schemas.PageShieldId;
  policyId: Schemas.PageShieldId;
};

export type PageShieldGetPolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PageShieldApiResponseCommonFailure;
}>;

export type PageShieldGetPolicyVariables = {
  pathParams: PageShieldGetPolicyPathParams;
} & FetcherExtraProps;

/**
 * Fetches a Page Shield policy by ID.
 */
export const pageShieldGetPolicy = (variables: PageShieldGetPolicyVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.PageShieldGetZonePolicyResponse,
    PageShieldGetPolicyError,
    undefined,
    {},
    {},
    PageShieldGetPolicyPathParams
  >({ url: '/zones/{zoneId}/page_shield/policies/{policyId}', method: 'get', ...variables, signal });

export type PageShieldUpdatePolicyPathParams = {
  zoneId: Schemas.PageShieldId;
  policyId: Schemas.PageShieldId;
};

export type PageShieldUpdatePolicyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PageShieldApiResponseCommonFailure;
}>;

export type PageShieldUpdatePolicyRequestBody = {
  action?: Schemas.PageShieldPolicyAction;
  description?: Schemas.PageShieldPolicyDescription;
  enabled?: Schemas.PageShieldPolicyEnabled;
  expression?: Schemas.PageShieldPolicyExpression;
  value?: Schemas.PageShieldPolicyValue;
};

export type PageShieldUpdatePolicyVariables = {
  body?: PageShieldUpdatePolicyRequestBody;
  pathParams: PageShieldUpdatePolicyPathParams;
} & FetcherExtraProps;

/**
 * Update a Page Shield policy by ID.
 */
export const pageShieldUpdatePolicy = (variables: PageShieldUpdatePolicyVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.PageShieldGetZonePolicyResponse,
    PageShieldUpdatePolicyError,
    PageShieldUpdatePolicyRequestBody,
    {},
    {},
    PageShieldUpdatePolicyPathParams
  >({ url: '/zones/{zoneId}/page_shield/policies/{policyId}', method: 'put', ...variables, signal });

export type PageShieldListScriptsPathParams = {
  zoneId: Schemas.PageShieldId;
};

export type PageShieldListScriptsQueryParams = {
  /**
   * @example blog.cloudflare.com,www.example
   */
  exclude_urls?: string;
  /**
   * @example blog.cloudflare.com,www.example
   */
  urls?: string;
  /**
   * @example blog.cloudflare.com,www.example*,*cloudflare.com
   */
  hosts?: string;
  /**
   * @example 2
   */
  page?: string;
  /**
   * @example 100
   * @maximum 100
   * @minimum 1
   */
  per_page?: number;
  /**
   * @example first_seen_at
   */
  order_by?: 'first_seen_at' | 'last_seen_at';
  /**
   * @example asc
   */
  direction?: 'asc' | 'desc';
  /**
   * @example true
   */
  prioritize_malicious?: boolean;
  /**
   * @default true
   * @example true
   */
  exclude_cdn_cgi?: boolean;
  /**
   * @default true
   * @example true
   */
  exclude_duplicates?: boolean;
  /**
   * @example active,inactive
   */
  status?: string;
  /**
   * @example [see original specs]
   */
  page_url?: string;
  /**
   * @example csv
   */
  ['export']?: 'csv';
};

export type PageShieldListScriptsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PageShieldApiResponseCommonFailure;
}>;

export type PageShieldListScriptsVariables = {
  pathParams: PageShieldListScriptsPathParams;
  queryParams?: PageShieldListScriptsQueryParams;
} & FetcherExtraProps;

/**
 * Lists all scripts detected by Page Shield.
 */
export const pageShieldListScripts = (variables: PageShieldListScriptsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.PageShieldListZoneScriptsResponse,
    PageShieldListScriptsError,
    undefined,
    {},
    PageShieldListScriptsQueryParams,
    PageShieldListScriptsPathParams
  >({ url: '/zones/{zoneId}/page_shield/scripts', method: 'get', ...variables, signal });

export type PageShieldGetScriptPathParams = {
  zoneId: Schemas.PageShieldId;
  scriptId: Schemas.PageShieldId;
};

export type PageShieldGetScriptError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.PageShieldApiResponseCommonFailure;
}>;

export type PageShieldGetScriptVariables = {
  pathParams: PageShieldGetScriptPathParams;
} & FetcherExtraProps;

/**
 * Fetches a script detected by Page Shield by script ID.
 */
export const pageShieldGetScript = (variables: PageShieldGetScriptVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.PageShieldGetZoneScriptResponse,
    PageShieldGetScriptError,
    undefined,
    {},
    {},
    PageShieldGetScriptPathParams
  >({ url: '/zones/{zoneId}/page_shield/scripts/{scriptId}', method: 'get', ...variables, signal });

export type PageRulesListPageRulesPathParams = {
  zoneId: Schemas.ZonesIdentifier;
};

export type PageRulesListPageRulesQueryParams = {
  /**
   * @default priority
   * @example status
   */
  order?: 'status' | 'priority';
  /**
   * @default desc
   * @example desc
   */
  direction?: 'asc' | 'desc';
  /**
   * @default all
   */
  match?: 'any' | 'all';
  /**
   * @default disabled
   * @example active
   */
  status?: 'active' | 'disabled';
};

export type PageRulesListPageRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesSchemasApiResponseCommonFailure;
}>;

export type PageRulesListPageRulesResponse = Schemas.ZonesSchemasApiResponseCommon & {
  result?: Schemas.ZonesPageRule[];
};

export type PageRulesListPageRulesVariables = {
  pathParams: PageRulesListPageRulesPathParams;
  queryParams?: PageRulesListPageRulesQueryParams;
} & FetcherExtraProps;

/**
 * Fetches Page Rules in a zone.
 */
export const pageRulesListPageRules = (variables: PageRulesListPageRulesVariables, signal?: AbortSignal) =>
  fetch<
    PageRulesListPageRulesResponse,
    PageRulesListPageRulesError,
    undefined,
    {},
    PageRulesListPageRulesQueryParams,
    PageRulesListPageRulesPathParams
  >({ url: '/zones/{zoneId}/pagerules', method: 'get', ...variables, signal });

export type PageRulesCreateAPageRulePathParams = {
  zoneId: Schemas.ZonesIdentifier;
};

export type PageRulesCreateAPageRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesSchemasApiResponseCommonFailure;
}>;

export type PageRulesCreateAPageRuleResponse = Schemas.ZonesApiResponseSingle & {
  result?: Schemas.ZonesPageRule;
};

export type PageRulesCreateAPageRuleRequestBody = {
  actions: Schemas.ZonesActions;
  priority?: Schemas.ZonesPriority;
  status?: Schemas.ZonesStatus;
  targets: Schemas.ZonesTargets;
};

export type PageRulesCreateAPageRuleVariables = {
  body: PageRulesCreateAPageRuleRequestBody;
  pathParams: PageRulesCreateAPageRulePathParams;
} & FetcherExtraProps;

/**
 * Creates a new Page Rule.
 */
export const pageRulesCreateAPageRule = (variables: PageRulesCreateAPageRuleVariables, signal?: AbortSignal) =>
  fetch<
    PageRulesCreateAPageRuleResponse,
    PageRulesCreateAPageRuleError,
    PageRulesCreateAPageRuleRequestBody,
    {},
    {},
    PageRulesCreateAPageRulePathParams
  >({ url: '/zones/{zoneId}/pagerules', method: 'post', ...variables, signal });

export type AvailablePageRulesSettingsListAvailablePageRulesSettingsPathParams = {
  zoneId: Schemas.ZonesIdentifier;
};

export type AvailablePageRulesSettingsListAvailablePageRulesSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesSchemasApiResponseCommonFailure;
}>;

export type AvailablePageRulesSettingsListAvailablePageRulesSettingsResponse = Schemas.ZonesSchemasApiResponseCommon & {
  result?: Schemas.ZonesSettings;
};

export type AvailablePageRulesSettingsListAvailablePageRulesSettingsVariables = {
  pathParams: AvailablePageRulesSettingsListAvailablePageRulesSettingsPathParams;
} & FetcherExtraProps;

/**
 * Returns a list of settings (and their details) that Page Rules can apply to matching requests.
 */
export const availablePageRulesSettingsListAvailablePageRulesSettings = (
  variables: AvailablePageRulesSettingsListAvailablePageRulesSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    AvailablePageRulesSettingsListAvailablePageRulesSettingsResponse,
    AvailablePageRulesSettingsListAvailablePageRulesSettingsError,
    undefined,
    {},
    {},
    AvailablePageRulesSettingsListAvailablePageRulesSettingsPathParams
  >({ url: '/zones/{zoneId}/pagerules/settings', method: 'get', ...variables, signal });

export type PageRulesDeleteAPageRulePathParams = {
  pageruleId: Schemas.ZonesIdentifier;
  zoneId: Schemas.ZonesIdentifier;
};

export type PageRulesDeleteAPageRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesSchemasApiResponseCommonFailure;
}>;

export type PageRulesDeleteAPageRuleVariables = {
  pathParams: PageRulesDeleteAPageRulePathParams;
} & FetcherExtraProps;

/**
 * Deletes an existing Page Rule.
 */
export const pageRulesDeleteAPageRule = (variables: PageRulesDeleteAPageRuleVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ZonesSchemasApiResponseSingleId,
    PageRulesDeleteAPageRuleError,
    undefined,
    {},
    {},
    PageRulesDeleteAPageRulePathParams
  >({ url: '/zones/{zoneId}/pagerules/{pageruleId}', method: 'delete', ...variables, signal });

export type PageRulesGetAPageRulePathParams = {
  pageruleId: Schemas.ZonesIdentifier;
  zoneId: Schemas.ZonesIdentifier;
};

export type PageRulesGetAPageRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesSchemasApiResponseCommonFailure;
}>;

export type PageRulesGetAPageRuleResponse = Schemas.ZonesApiResponseSingle & {
  result?: Schemas.ZonesPageRule;
};

export type PageRulesGetAPageRuleVariables = {
  pathParams: PageRulesGetAPageRulePathParams;
} & FetcherExtraProps;

/**
 * Fetches the details of a Page Rule.
 */
export const pageRulesGetAPageRule = (variables: PageRulesGetAPageRuleVariables, signal?: AbortSignal) =>
  fetch<PageRulesGetAPageRuleResponse, PageRulesGetAPageRuleError, undefined, {}, {}, PageRulesGetAPageRulePathParams>({
    url: '/zones/{zoneId}/pagerules/{pageruleId}',
    method: 'get',
    ...variables,
    signal
  });

export type PageRulesEditAPageRulePathParams = {
  pageruleId: Schemas.ZonesIdentifier;
  zoneId: Schemas.ZonesIdentifier;
};

export type PageRulesEditAPageRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesSchemasApiResponseCommonFailure;
}>;

export type PageRulesEditAPageRuleResponse = Schemas.ZonesApiResponseSingle & {
  result?: Schemas.ZonesPageRule;
};

export type PageRulesEditAPageRuleRequestBody = {
  actions?: Schemas.ZonesActions;
  priority?: Schemas.ZonesPriority;
  status?: Schemas.ZonesStatus;
  targets?: Schemas.ZonesTargets;
};

export type PageRulesEditAPageRuleVariables = {
  body?: PageRulesEditAPageRuleRequestBody;
  pathParams: PageRulesEditAPageRulePathParams;
} & FetcherExtraProps;

/**
 * Updates one or more fields of an existing Page Rule.
 */
export const pageRulesEditAPageRule = (variables: PageRulesEditAPageRuleVariables, signal?: AbortSignal) =>
  fetch<
    PageRulesEditAPageRuleResponse,
    PageRulesEditAPageRuleError,
    PageRulesEditAPageRuleRequestBody,
    {},
    {},
    PageRulesEditAPageRulePathParams
  >({ url: '/zones/{zoneId}/pagerules/{pageruleId}', method: 'patch', ...variables, signal });

export type PageRulesUpdateAPageRulePathParams = {
  pageruleId: Schemas.ZonesIdentifier;
  zoneId: Schemas.ZonesIdentifier;
};

export type PageRulesUpdateAPageRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesSchemasApiResponseCommonFailure;
}>;

export type PageRulesUpdateAPageRuleResponse = Schemas.ZonesApiResponseSingle & {
  result?: Schemas.ZonesPageRule;
};

export type PageRulesUpdateAPageRuleRequestBody = {
  actions: Schemas.ZonesActions;
  priority?: Schemas.ZonesPriority;
  status?: Schemas.ZonesStatus;
  targets: Schemas.ZonesTargets;
};

export type PageRulesUpdateAPageRuleVariables = {
  body: PageRulesUpdateAPageRuleRequestBody;
  pathParams: PageRulesUpdateAPageRulePathParams;
} & FetcherExtraProps;

/**
 * Replaces the configuration of an existing Page Rule. The configuration of the updated Page Rule will exactly match the data passed in the API request.
 */
export const pageRulesUpdateAPageRule = (variables: PageRulesUpdateAPageRuleVariables, signal?: AbortSignal) =>
  fetch<
    PageRulesUpdateAPageRuleResponse,
    PageRulesUpdateAPageRuleError,
    PageRulesUpdateAPageRuleRequestBody,
    {},
    {},
    PageRulesUpdateAPageRulePathParams
  >({ url: '/zones/{zoneId}/pagerules/{pageruleId}', method: 'put', ...variables, signal });

export type ZonePurgePathParams = {
  zoneId: Schemas.CachePurgeIdentifier;
};

export type ZonePurgeError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CachePurgeApiResponseSingleId & Schemas.CachePurgeApiResponseCommonFailure;
}>;

export type ZonePurgeVariables = {
  body?:
    | Schemas.CachePurgeFlexPurgeByTags
    | Schemas.CachePurgeFlexPurgeByHostnames
    | Schemas.CachePurgeFlexPurgeByPrefixes
    | Schemas.CachePurgeEverything
    | Schemas.CachePurgeSingleFile
    | Schemas.CachePurgeSingleFileWithUrlAndHeaders;
  pathParams: ZonePurgePathParams;
} & FetcherExtraProps;

/**
 * ### Purge All Cached Content
 * Removes ALL files from Cloudflare's cache. All tiers can purge everything.
 * ```
 * {"purge_everything": true}
 * ```
 *
 * ### Purge Cached Content by URL
 * Granularly removes one or more files from Cloudflare's cache by specifying URLs. All tiers can purge by URL.
 *
 * To purge files with custom cache keys, include the headers used to compute the cache key as in the example. If you have a device type or geo in your cache key, you will need to include the CF-Device-Type or CF-IPCountry headers. If you have lang in your cache key, you will need to include the Accept-Language header.
 *
 * **NB:** When including the Origin header, be sure to include the **scheme** and **hostname**. The port number can be omitted if it is the default port (80 for http, 443 for https), but must be included otherwise.
 *
 * **NB:** For Zones on Free/Pro/Business plan, you may purge up to 30 URLs in one API call. For Zones on Enterprise plan, you may purge up to 500 URLs in one API call.
 *
 * Single file purge example with files:
 * ```
 * {"files": ["http://www.example.com/css/styles.css", "http://www.example.com/js/index.js"]}
 * ```
 * Single file purge example with url and header pairs:
 * ```
 * {"files": [{url: "http://www.example.com/cat_picture.jpg", headers: { "CF-IPCountry": "US", "CF-Device-Type": "desktop", "Accept-Language": "zh-CN" }}, {url: "http://www.example.com/dog_picture.jpg", headers: { "CF-IPCountry": "EU", "CF-Device-Type": "mobile", "Accept-Language": "en-US" }}]}
 * ```
 *
 * ### Purge Cached Content by Tag, Host or Prefix
 * Granularly removes one or more files from Cloudflare's cache either by specifying the host, the associated Cache-Tag, or a Prefix. Only Enterprise customers are permitted to purge by Tag, Host or Prefix.
 *
 * **NB:** Cache-Tag, host, and prefix purging each have a rate limit of 30,000 purge API calls in every 24 hour period. You may purge up to 30 tags, hosts, or prefixes in one API call. This rate limit can be raised for customers who need to purge at higher volume.
 *
 * Flex purge with tags:
 * ```
 * {"tags": ["a-cache-tag", "another-cache-tag"]}
 * ```
 * Flex purge with hosts:
 * ```
 * {"hosts": ["www.example.com", "images.example.com"]}
 * ```
 * Flex purge with prefixes:
 * ```
 * {"prefixes": ["www.example.com/foo", "images.example.com/bar/baz"]}
 * ```
 */
export const zonePurge = (variables: ZonePurgeVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.CachePurgeApiResponseSingleId,
    ZonePurgeError,
    | Schemas.CachePurgeFlexPurgeByTags
    | Schemas.CachePurgeFlexPurgeByHostnames
    | Schemas.CachePurgeFlexPurgeByPrefixes
    | Schemas.CachePurgeEverything
    | Schemas.CachePurgeSingleFile
    | Schemas.CachePurgeSingleFileWithUrlAndHeaders,
    {},
    {},
    ZonePurgePathParams
  >({ url: '/zones/{zoneId}/purge_cache', method: 'post', ...variables, signal });

export type RateLimitsForAZoneListRateLimitsPathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type RateLimitsForAZoneListRateLimitsQueryParams = {
  /**
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 1000
   * @minimum 1
   */
  per_page?: number;
};

export type RateLimitsForAZoneListRateLimitsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallRatelimitResponseCollection & Schemas.FirewallApiResponseCommonFailure;
}>;

export type RateLimitsForAZoneListRateLimitsVariables = {
  pathParams: RateLimitsForAZoneListRateLimitsPathParams;
  queryParams?: RateLimitsForAZoneListRateLimitsQueryParams;
} & FetcherExtraProps;

/**
 * Fetches the rate limits for a zone.
 */
export const rateLimitsForAZoneListRateLimits = (
  variables: RateLimitsForAZoneListRateLimitsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallRatelimitResponseCollection,
    RateLimitsForAZoneListRateLimitsError,
    undefined,
    {},
    RateLimitsForAZoneListRateLimitsQueryParams,
    RateLimitsForAZoneListRateLimitsPathParams
  >({ url: '/zones/{zoneId}/rate_limits', method: 'get', ...variables, signal });

export type RateLimitsForAZoneCreateARateLimitPathParams = {
  zoneId: Schemas.FirewallIdentifier;
};

export type RateLimitsForAZoneCreateARateLimitError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallRatelimitResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type RateLimitsForAZoneCreateARateLimitRequestBody = {
  action: Schemas.FirewallAction;
  match: Schemas.FirewallMatch;
  period: Schemas.FirewallPeriod;
  threshold: Schemas.FirewallThreshold;
};

export type RateLimitsForAZoneCreateARateLimitVariables = {
  body: RateLimitsForAZoneCreateARateLimitRequestBody;
  pathParams: RateLimitsForAZoneCreateARateLimitPathParams;
} & FetcherExtraProps;

/**
 * Creates a new rate limit for a zone. Refer to the object definition for a list of required attributes.
 */
export const rateLimitsForAZoneCreateARateLimit = (
  variables: RateLimitsForAZoneCreateARateLimitVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallRatelimitResponseSingle,
    RateLimitsForAZoneCreateARateLimitError,
    RateLimitsForAZoneCreateARateLimitRequestBody,
    {},
    {},
    RateLimitsForAZoneCreateARateLimitPathParams
  >({ url: '/zones/{zoneId}/rate_limits', method: 'post', ...variables, signal });

export type RateLimitsForAZoneDeleteARateLimitPathParams = {
  rateLimitId: Schemas.FirewallRateLimitId;
  zoneId: Schemas.FirewallIdentifier;
};

export type RateLimitsForAZoneDeleteARateLimitError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: (Schemas.FirewallRatelimitResponseSingle & {
    result?: {
      id?: Schemas.FirewallId;
    };
  }) &
    Schemas.FirewallApiResponseCommonFailure;
}>;

export type RateLimitsForAZoneDeleteARateLimitResponse = Schemas.FirewallRatelimitResponseSingle & {
  result?: {
    id?: Schemas.FirewallId;
  };
};

export type RateLimitsForAZoneDeleteARateLimitVariables = {
  pathParams: RateLimitsForAZoneDeleteARateLimitPathParams;
} & FetcherExtraProps;

/**
 * Deletes an existing rate limit.
 */
export const rateLimitsForAZoneDeleteARateLimit = (
  variables: RateLimitsForAZoneDeleteARateLimitVariables,
  signal?: AbortSignal
) =>
  fetch<
    RateLimitsForAZoneDeleteARateLimitResponse,
    RateLimitsForAZoneDeleteARateLimitError,
    undefined,
    {},
    {},
    RateLimitsForAZoneDeleteARateLimitPathParams
  >({ url: '/zones/{zoneId}/rate_limits/{rateLimitId}', method: 'delete', ...variables, signal });

export type RateLimitsForAZoneGetARateLimitPathParams = {
  rateLimitId: Schemas.FirewallRateLimitId;
  zoneId: Schemas.FirewallIdentifier;
};

export type RateLimitsForAZoneGetARateLimitError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallRatelimitResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type RateLimitsForAZoneGetARateLimitVariables = {
  pathParams: RateLimitsForAZoneGetARateLimitPathParams;
} & FetcherExtraProps;

/**
 * Fetches the details of a rate limit.
 */
export const rateLimitsForAZoneGetARateLimit = (
  variables: RateLimitsForAZoneGetARateLimitVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallRatelimitResponseSingle,
    RateLimitsForAZoneGetARateLimitError,
    undefined,
    {},
    {},
    RateLimitsForAZoneGetARateLimitPathParams
  >({ url: '/zones/{zoneId}/rate_limits/{rateLimitId}', method: 'get', ...variables, signal });

export type RateLimitsForAZoneUpdateARateLimitPathParams = {
  rateLimitId: Schemas.FirewallRateLimitId;
  zoneId: Schemas.FirewallIdentifier;
};

export type RateLimitsForAZoneUpdateARateLimitError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.FirewallRatelimitResponseSingle & Schemas.FirewallApiResponseCommonFailure;
}>;

export type RateLimitsForAZoneUpdateARateLimitRequestBody = {
  action: Schemas.FirewallAction;
  match: Schemas.FirewallMatch;
  period: Schemas.FirewallPeriod;
  threshold: Schemas.FirewallThreshold;
};

export type RateLimitsForAZoneUpdateARateLimitVariables = {
  body: RateLimitsForAZoneUpdateARateLimitRequestBody;
  pathParams: RateLimitsForAZoneUpdateARateLimitPathParams;
} & FetcherExtraProps;

/**
 * Updates an existing rate limit.
 */
export const rateLimitsForAZoneUpdateARateLimit = (
  variables: RateLimitsForAZoneUpdateARateLimitVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.FirewallRatelimitResponseSingle,
    RateLimitsForAZoneUpdateARateLimitError,
    RateLimitsForAZoneUpdateARateLimitRequestBody,
    {},
    {},
    RateLimitsForAZoneUpdateARateLimitPathParams
  >({ url: '/zones/{zoneId}/rate_limits/{rateLimitId}', method: 'put', ...variables, signal });

export type ListZoneRulesetsPathParams = {
  zoneId: Schemas.RulesetsZoneId;
};

export type ListZoneRulesetsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type ListZoneRulesetsVariables = {
  pathParams: ListZoneRulesetsPathParams;
} & FetcherExtraProps;

/**
 * Fetches all rulesets at the zone level.
 */
export const listZoneRulesets = (variables: ListZoneRulesetsVariables, signal?: AbortSignal) =>
  fetch<Responses.RulesetsRulesets, ListZoneRulesetsError, undefined, {}, {}, ListZoneRulesetsPathParams>({
    url: '/zones/{zoneId}/rulesets',
    method: 'get',
    ...variables,
    signal
  });

export type CreateZoneRulesetPathParams = {
  zoneId: Schemas.RulesetsZoneId;
};

export type CreateZoneRulesetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type CreateZoneRulesetVariables = {
  body?: RequestBodies.RulesetsCreateRuleset;
  pathParams: CreateZoneRulesetPathParams;
} & FetcherExtraProps;

/**
 * Creates a ruleset at the zone level.
 */
export const createZoneRuleset = (variables: CreateZoneRulesetVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RulesetsRuleset,
    CreateZoneRulesetError,
    RequestBodies.RulesetsCreateRuleset,
    {},
    {},
    CreateZoneRulesetPathParams
  >({ url: '/zones/{zoneId}/rulesets', method: 'post', ...variables, signal });

export type GetZoneEntrypointRulesetPathParams = {
  rulesetPhase: Schemas.RulesetsRulesetPhase;
  zoneId: Schemas.RulesetsZoneId;
};

export type GetZoneEntrypointRulesetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type GetZoneEntrypointRulesetVariables = {
  pathParams: GetZoneEntrypointRulesetPathParams;
} & FetcherExtraProps;

/**
 * Fetches the latest version of the zone entry point ruleset for a given phase.
 */
export const getZoneEntrypointRuleset = (variables: GetZoneEntrypointRulesetVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RulesetsRuleset,
    GetZoneEntrypointRulesetError,
    undefined,
    {},
    {},
    GetZoneEntrypointRulesetPathParams
  >({ url: '/zones/{zoneId}/rulesets/phases/{rulesetPhase}/entrypoint', method: 'get', ...variables, signal });

export type UpdateZoneEntrypointRulesetPathParams = {
  rulesetPhase: Schemas.RulesetsRulesetPhase;
  zoneId: Schemas.RulesetsZoneId;
};

export type UpdateZoneEntrypointRulesetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type UpdateZoneEntrypointRulesetVariables = {
  body?: RequestBodies.RulesetsUpdateEntrypointRuleset;
  pathParams: UpdateZoneEntrypointRulesetPathParams;
} & FetcherExtraProps;

/**
 * Updates a zone entry point ruleset, creating a new version.
 */
export const updateZoneEntrypointRuleset = (variables: UpdateZoneEntrypointRulesetVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RulesetsRuleset,
    UpdateZoneEntrypointRulesetError,
    RequestBodies.RulesetsUpdateEntrypointRuleset,
    {},
    {},
    UpdateZoneEntrypointRulesetPathParams
  >({ url: '/zones/{zoneId}/rulesets/phases/{rulesetPhase}/entrypoint', method: 'put', ...variables, signal });

export type ListZoneEntrypointRulesetVersionsPathParams = {
  rulesetPhase: Schemas.RulesetsRulesetPhase;
  zoneId: Schemas.RulesetsZoneId;
};

export type ListZoneEntrypointRulesetVersionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type ListZoneEntrypointRulesetVersionsVariables = {
  pathParams: ListZoneEntrypointRulesetVersionsPathParams;
} & FetcherExtraProps;

/**
 * Fetches the versions of a zone entry point ruleset.
 */
export const listZoneEntrypointRulesetVersions = (
  variables: ListZoneEntrypointRulesetVersionsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Responses.RulesetsRulesets,
    ListZoneEntrypointRulesetVersionsError,
    undefined,
    {},
    {},
    ListZoneEntrypointRulesetVersionsPathParams
  >({ url: '/zones/{zoneId}/rulesets/phases/{rulesetPhase}/entrypoint/versions', method: 'get', ...variables, signal });

export type GetZoneEntrypointRulesetVersionPathParams = {
  rulesetVersion: Schemas.RulesetsRulesetVersion;
  rulesetPhase: Schemas.RulesetsRulesetPhase;
  zoneId: Schemas.RulesetsZoneId;
};

export type GetZoneEntrypointRulesetVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type GetZoneEntrypointRulesetVersionVariables = {
  pathParams: GetZoneEntrypointRulesetVersionPathParams;
} & FetcherExtraProps;

/**
 * Fetches a specific version of a zone entry point ruleset.
 */
export const getZoneEntrypointRulesetVersion = (
  variables: GetZoneEntrypointRulesetVersionVariables,
  signal?: AbortSignal
) =>
  fetch<
    Responses.RulesetsRuleset,
    GetZoneEntrypointRulesetVersionError,
    undefined,
    {},
    {},
    GetZoneEntrypointRulesetVersionPathParams
  >({
    url: '/zones/{zoneId}/rulesets/phases/{rulesetPhase}/entrypoint/versions/{rulesetVersion}',
    method: 'get',
    ...variables,
    signal
  });

export type DeleteZoneRulesetPathParams = {
  rulesetId: Schemas.RulesetsRulesetId;
  zoneId: Schemas.RulesetsZoneId;
};

export type DeleteZoneRulesetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type DeleteZoneRulesetVariables = {
  pathParams: DeleteZoneRulesetPathParams;
} & FetcherExtraProps;

/**
 * Deletes all versions of an existing zone ruleset.
 */
export const deleteZoneRuleset = (variables: DeleteZoneRulesetVariables, signal?: AbortSignal) =>
  fetch<Responses.RulesetsEmpty, DeleteZoneRulesetError, undefined, {}, {}, DeleteZoneRulesetPathParams>({
    url: '/zones/{zoneId}/rulesets/{rulesetId}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetZoneRulesetPathParams = {
  rulesetId: Schemas.RulesetsRulesetId;
  zoneId: Schemas.RulesetsZoneId;
};

export type GetZoneRulesetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type GetZoneRulesetVariables = {
  pathParams: GetZoneRulesetPathParams;
} & FetcherExtraProps;

/**
 * Fetches the latest version of a zone ruleset.
 */
export const getZoneRuleset = (variables: GetZoneRulesetVariables, signal?: AbortSignal) =>
  fetch<Responses.RulesetsRuleset, GetZoneRulesetError, undefined, {}, {}, GetZoneRulesetPathParams>({
    url: '/zones/{zoneId}/rulesets/{rulesetId}',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateZoneRulesetPathParams = {
  rulesetId: Schemas.RulesetsRulesetId;
  zoneId: Schemas.RulesetsZoneId;
};

export type UpdateZoneRulesetError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type UpdateZoneRulesetVariables = {
  body?: RequestBodies.RulesetsUpdateRuleset;
  pathParams: UpdateZoneRulesetPathParams;
} & FetcherExtraProps;

/**
 * Updates a zone ruleset, creating a new version.
 */
export const updateZoneRuleset = (variables: UpdateZoneRulesetVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RulesetsRuleset,
    UpdateZoneRulesetError,
    RequestBodies.RulesetsUpdateRuleset,
    {},
    {},
    UpdateZoneRulesetPathParams
  >({ url: '/zones/{zoneId}/rulesets/{rulesetId}', method: 'put', ...variables, signal });

export type CreateZoneRulesetRulePathParams = {
  rulesetId: Schemas.RulesetsRulesetId;
  zoneId: Schemas.RulesetsZoneId;
};

export type CreateZoneRulesetRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type CreateZoneRulesetRuleVariables = {
  body?: RequestBodies.RulesetsRule;
  pathParams: CreateZoneRulesetRulePathParams;
} & FetcherExtraProps;

/**
 * Adds a new rule to a zone ruleset. The rule will be added to the end of the existing list of rules in the ruleset by default.
 */
export const createZoneRulesetRule = (variables: CreateZoneRulesetRuleVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RulesetsRuleset,
    CreateZoneRulesetRuleError,
    RequestBodies.RulesetsRule,
    {},
    {},
    CreateZoneRulesetRulePathParams
  >({ url: '/zones/{zoneId}/rulesets/{rulesetId}/rules', method: 'post', ...variables, signal });

export type DeleteZoneRulesetRulePathParams = {
  ruleId: Schemas.RulesetsRuleId;
  rulesetId: Schemas.RulesetsRulesetId;
  zoneId: Schemas.RulesetsZoneId;
};

export type DeleteZoneRulesetRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type DeleteZoneRulesetRuleVariables = {
  pathParams: DeleteZoneRulesetRulePathParams;
} & FetcherExtraProps;

/**
 * Deletes an existing rule from a zone ruleset.
 */
export const deleteZoneRulesetRule = (variables: DeleteZoneRulesetRuleVariables, signal?: AbortSignal) =>
  fetch<Responses.RulesetsRuleset, DeleteZoneRulesetRuleError, undefined, {}, {}, DeleteZoneRulesetRulePathParams>({
    url: '/zones/{zoneId}/rulesets/{rulesetId}/rules/{ruleId}',
    method: 'delete',
    ...variables,
    signal
  });

export type UpdateZoneRulesetRulePathParams = {
  ruleId: Schemas.RulesetsRuleId;
  rulesetId: Schemas.RulesetsRulesetId;
  zoneId: Schemas.RulesetsZoneId;
};

export type UpdateZoneRulesetRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type UpdateZoneRulesetRuleVariables = {
  body?: RequestBodies.RulesetsRule;
  pathParams: UpdateZoneRulesetRulePathParams;
} & FetcherExtraProps;

/**
 * Updates an existing rule in a zone ruleset.
 */
export const updateZoneRulesetRule = (variables: UpdateZoneRulesetRuleVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RulesetsRuleset,
    UpdateZoneRulesetRuleError,
    RequestBodies.RulesetsRule,
    {},
    {},
    UpdateZoneRulesetRulePathParams
  >({ url: '/zones/{zoneId}/rulesets/{rulesetId}/rules/{ruleId}', method: 'patch', ...variables, signal });

export type ListZoneRulesetVersionsPathParams = {
  rulesetId: Schemas.RulesetsRulesetId;
  zoneId: Schemas.RulesetsZoneId;
};

export type ListZoneRulesetVersionsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type ListZoneRulesetVersionsVariables = {
  pathParams: ListZoneRulesetVersionsPathParams;
} & FetcherExtraProps;

/**
 * Fetches the versions of a zone ruleset.
 */
export const listZoneRulesetVersions = (variables: ListZoneRulesetVersionsVariables, signal?: AbortSignal) =>
  fetch<Responses.RulesetsRulesets, ListZoneRulesetVersionsError, undefined, {}, {}, ListZoneRulesetVersionsPathParams>(
    { url: '/zones/{zoneId}/rulesets/{rulesetId}/versions', method: 'get', ...variables, signal }
  );

export type DeleteZoneRulesetVersionPathParams = {
  rulesetVersion: Schemas.RulesetsRulesetVersion;
  rulesetId: Schemas.RulesetsRulesetId;
  zoneId: Schemas.RulesetsZoneId;
};

export type DeleteZoneRulesetVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type DeleteZoneRulesetVersionVariables = {
  pathParams: DeleteZoneRulesetVersionPathParams;
} & FetcherExtraProps;

/**
 * Deletes an existing version of a zone ruleset.
 */
export const deleteZoneRulesetVersion = (variables: DeleteZoneRulesetVersionVariables, signal?: AbortSignal) =>
  fetch<Responses.RulesetsEmpty, DeleteZoneRulesetVersionError, undefined, {}, {}, DeleteZoneRulesetVersionPathParams>({
    url: '/zones/{zoneId}/rulesets/{rulesetId}/versions/{rulesetVersion}',
    method: 'delete',
    ...variables,
    signal
  });

export type GetZoneRulesetVersionPathParams = {
  rulesetVersion: Schemas.RulesetsRulesetVersion;
  rulesetId: Schemas.RulesetsRulesetId;
  zoneId: Schemas.RulesetsZoneId;
};

export type GetZoneRulesetVersionError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type GetZoneRulesetVersionVariables = {
  pathParams: GetZoneRulesetVersionPathParams;
} & FetcherExtraProps;

/**
 * Fetches a specific version of a zone ruleset.
 */
export const getZoneRulesetVersion = (variables: GetZoneRulesetVersionVariables, signal?: AbortSignal) =>
  fetch<Responses.RulesetsRuleset, GetZoneRulesetVersionError, undefined, {}, {}, GetZoneRulesetVersionPathParams>({
    url: '/zones/{zoneId}/rulesets/{rulesetId}/versions/{rulesetVersion}',
    method: 'get',
    ...variables,
    signal
  });

export type ListZoneRulesetVersionRulesByTagPathParams = {
  ruleTag: Schemas.RulesetsRuleCategory;
  rulesetVersion: Schemas.RulesetsRulesetVersion;
  rulesetId: Schemas.RulesetsRulesetId;
  zoneId: Schemas.RulesetsZoneId;
};

export type ListZoneRulesetVersionRulesByTagError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type ListZoneRulesetVersionRulesByTagVariables = {
  pathParams: ListZoneRulesetVersionRulesByTagPathParams;
} & FetcherExtraProps;

/**
 * Fetches the rules of a managed zone ruleset version for a given tag.
 */
export const listZoneRulesetVersionRulesByTag = (
  variables: ListZoneRulesetVersionRulesByTagVariables,
  signal?: AbortSignal
) =>
  fetch<
    Responses.RulesetsRuleset,
    ListZoneRulesetVersionRulesByTagError,
    undefined,
    {},
    {},
    ListZoneRulesetVersionRulesByTagPathParams
  >({
    url: '/zones/{zoneId}/rulesets/{rulesetId}/versions/{rulesetVersion}/by_tag/{ruleTag}',
    method: 'get',
    ...variables,
    signal
  });

export type SecondaryDnsSecondaryZoneForceAxfrPathParams = {
  zoneId: Schemas.SecondaryDnsIdentifier;
};

export type SecondaryDnsSecondaryZoneForceAxfrError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsForceResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsSecondaryZoneForceAxfrVariables = {
  pathParams: SecondaryDnsSecondaryZoneForceAxfrPathParams;
} & FetcherExtraProps;

/**
 * Sends AXFR zone transfer request to primary nameserver(s).
 */
export const secondaryDnsSecondaryZoneForceAxfr = (
  variables: SecondaryDnsSecondaryZoneForceAxfrVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SecondaryDnsForceResponse,
    SecondaryDnsSecondaryZoneForceAxfrError,
    undefined,
    {},
    {},
    SecondaryDnsSecondaryZoneForceAxfrPathParams
  >({ url: '/zones/{zoneId}/secondary_dns/force_axfr', method: 'post', ...variables, signal });

export type SecondaryDnsSecondaryZoneDeleteSecondaryZoneConfigurationPathParams = {
  zoneId: Schemas.SecondaryDnsIdentifier;
};

export type SecondaryDnsSecondaryZoneDeleteSecondaryZoneConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsIdResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsSecondaryZoneDeleteSecondaryZoneConfigurationVariables = {
  pathParams: SecondaryDnsSecondaryZoneDeleteSecondaryZoneConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Delete secondary zone configuration for incoming zone transfers.
 */
export const secondaryDnsSecondaryZoneDeleteSecondaryZoneConfiguration = (
  variables: SecondaryDnsSecondaryZoneDeleteSecondaryZoneConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SecondaryDnsIdResponse,
    SecondaryDnsSecondaryZoneDeleteSecondaryZoneConfigurationError,
    undefined,
    {},
    {},
    SecondaryDnsSecondaryZoneDeleteSecondaryZoneConfigurationPathParams
  >({ url: '/zones/{zoneId}/secondary_dns/incoming', method: 'delete', ...variables, signal });

export type SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsPathParams = {
  zoneId: Schemas.SecondaryDnsIdentifier;
};

export type SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsSingleResponseIncoming & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsVariables = {
  pathParams: SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get secondary zone configuration for incoming zone transfers.
 */
export const secondaryDnsSecondaryZoneSecondaryZoneConfigurationDetails = (
  variables: SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SecondaryDnsSingleResponseIncoming,
    SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsError,
    undefined,
    {},
    {},
    SecondaryDnsSecondaryZoneSecondaryZoneConfigurationDetailsPathParams
  >({ url: '/zones/{zoneId}/secondary_dns/incoming', method: 'get', ...variables, signal });

export type SecondaryDnsSecondaryZoneCreateSecondaryZoneConfigurationPathParams = {
  zoneId: Schemas.SecondaryDnsIdentifier;
};

export type SecondaryDnsSecondaryZoneCreateSecondaryZoneConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsSingleResponseIncoming & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsSecondaryZoneCreateSecondaryZoneConfigurationVariables = {
  body: Schemas.SecondaryDnsDnsSecondarySecondaryZone;
  pathParams: SecondaryDnsSecondaryZoneCreateSecondaryZoneConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Create secondary zone configuration for incoming zone transfers.
 */
export const secondaryDnsSecondaryZoneCreateSecondaryZoneConfiguration = (
  variables: SecondaryDnsSecondaryZoneCreateSecondaryZoneConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SecondaryDnsSingleResponseIncoming,
    SecondaryDnsSecondaryZoneCreateSecondaryZoneConfigurationError,
    Schemas.SecondaryDnsDnsSecondarySecondaryZone,
    {},
    {},
    SecondaryDnsSecondaryZoneCreateSecondaryZoneConfigurationPathParams
  >({ url: '/zones/{zoneId}/secondary_dns/incoming', method: 'post', ...variables, signal });

export type SecondaryDnsSecondaryZoneUpdateSecondaryZoneConfigurationPathParams = {
  zoneId: Schemas.SecondaryDnsIdentifier;
};

export type SecondaryDnsSecondaryZoneUpdateSecondaryZoneConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsSingleResponseIncoming & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsSecondaryZoneUpdateSecondaryZoneConfigurationVariables = {
  body: Schemas.SecondaryDnsDnsSecondarySecondaryZone;
  pathParams: SecondaryDnsSecondaryZoneUpdateSecondaryZoneConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Update secondary zone configuration for incoming zone transfers.
 */
export const secondaryDnsSecondaryZoneUpdateSecondaryZoneConfiguration = (
  variables: SecondaryDnsSecondaryZoneUpdateSecondaryZoneConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SecondaryDnsSingleResponseIncoming,
    SecondaryDnsSecondaryZoneUpdateSecondaryZoneConfigurationError,
    Schemas.SecondaryDnsDnsSecondarySecondaryZone,
    {},
    {},
    SecondaryDnsSecondaryZoneUpdateSecondaryZoneConfigurationPathParams
  >({ url: '/zones/{zoneId}/secondary_dns/incoming', method: 'put', ...variables, signal });

export type SecondaryDnsPrimaryZoneDeletePrimaryZoneConfigurationPathParams = {
  zoneId: Schemas.SecondaryDnsIdentifier;
};

export type SecondaryDnsPrimaryZoneDeletePrimaryZoneConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsIdResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsPrimaryZoneDeletePrimaryZoneConfigurationVariables = {
  pathParams: SecondaryDnsPrimaryZoneDeletePrimaryZoneConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Delete primary zone configuration for outgoing zone transfers.
 */
export const secondaryDnsPrimaryZoneDeletePrimaryZoneConfiguration = (
  variables: SecondaryDnsPrimaryZoneDeletePrimaryZoneConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SecondaryDnsIdResponse,
    SecondaryDnsPrimaryZoneDeletePrimaryZoneConfigurationError,
    undefined,
    {},
    {},
    SecondaryDnsPrimaryZoneDeletePrimaryZoneConfigurationPathParams
  >({ url: '/zones/{zoneId}/secondary_dns/outgoing', method: 'delete', ...variables, signal });

export type SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsPathParams = {
  zoneId: Schemas.SecondaryDnsIdentifier;
};

export type SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsSingleResponseOutgoing & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsVariables = {
  pathParams: SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get primary zone configuration for outgoing zone transfers.
 */
export const secondaryDnsPrimaryZonePrimaryZoneConfigurationDetails = (
  variables: SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SecondaryDnsSingleResponseOutgoing,
    SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsError,
    undefined,
    {},
    {},
    SecondaryDnsPrimaryZonePrimaryZoneConfigurationDetailsPathParams
  >({ url: '/zones/{zoneId}/secondary_dns/outgoing', method: 'get', ...variables, signal });

export type SecondaryDnsPrimaryZoneCreatePrimaryZoneConfigurationPathParams = {
  zoneId: Schemas.SecondaryDnsIdentifier;
};

export type SecondaryDnsPrimaryZoneCreatePrimaryZoneConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsSingleResponseOutgoing & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsPrimaryZoneCreatePrimaryZoneConfigurationVariables = {
  body: Schemas.SecondaryDnsSingleRequestOutgoing;
  pathParams: SecondaryDnsPrimaryZoneCreatePrimaryZoneConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Create primary zone configuration for outgoing zone transfers.
 */
export const secondaryDnsPrimaryZoneCreatePrimaryZoneConfiguration = (
  variables: SecondaryDnsPrimaryZoneCreatePrimaryZoneConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SecondaryDnsSingleResponseOutgoing,
    SecondaryDnsPrimaryZoneCreatePrimaryZoneConfigurationError,
    Schemas.SecondaryDnsSingleRequestOutgoing,
    {},
    {},
    SecondaryDnsPrimaryZoneCreatePrimaryZoneConfigurationPathParams
  >({ url: '/zones/{zoneId}/secondary_dns/outgoing', method: 'post', ...variables, signal });

export type SecondaryDnsPrimaryZoneUpdatePrimaryZoneConfigurationPathParams = {
  zoneId: Schemas.SecondaryDnsIdentifier;
};

export type SecondaryDnsPrimaryZoneUpdatePrimaryZoneConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsSingleResponseOutgoing & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsPrimaryZoneUpdatePrimaryZoneConfigurationVariables = {
  body: Schemas.SecondaryDnsSingleRequestOutgoing;
  pathParams: SecondaryDnsPrimaryZoneUpdatePrimaryZoneConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Update primary zone configuration for outgoing zone transfers.
 */
export const secondaryDnsPrimaryZoneUpdatePrimaryZoneConfiguration = (
  variables: SecondaryDnsPrimaryZoneUpdatePrimaryZoneConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SecondaryDnsSingleResponseOutgoing,
    SecondaryDnsPrimaryZoneUpdatePrimaryZoneConfigurationError,
    Schemas.SecondaryDnsSingleRequestOutgoing,
    {},
    {},
    SecondaryDnsPrimaryZoneUpdatePrimaryZoneConfigurationPathParams
  >({ url: '/zones/{zoneId}/secondary_dns/outgoing', method: 'put', ...variables, signal });

export type SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersPathParams = {
  zoneId: Schemas.SecondaryDnsIdentifier;
};

export type SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsDisableTransferResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersVariables = {
  pathParams: SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersPathParams;
} & FetcherExtraProps;

/**
 * Disable outgoing zone transfers for primary zone and clears IXFR backlog of primary zone.
 */
export const secondaryDnsPrimaryZoneDisableOutgoingZoneTransfers = (
  variables: SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SecondaryDnsDisableTransferResponse,
    SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersError,
    undefined,
    {},
    {},
    SecondaryDnsPrimaryZoneDisableOutgoingZoneTransfersPathParams
  >({ url: '/zones/{zoneId}/secondary_dns/outgoing/disable', method: 'post', ...variables, signal });

export type SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersPathParams = {
  zoneId: Schemas.SecondaryDnsIdentifier;
};

export type SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsEnableTransferResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersVariables = {
  pathParams: SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersPathParams;
} & FetcherExtraProps;

/**
 * Enable outgoing zone transfers for primary zone.
 */
export const secondaryDnsPrimaryZoneEnableOutgoingZoneTransfers = (
  variables: SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SecondaryDnsEnableTransferResponse,
    SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersError,
    undefined,
    {},
    {},
    SecondaryDnsPrimaryZoneEnableOutgoingZoneTransfersPathParams
  >({ url: '/zones/{zoneId}/secondary_dns/outgoing/enable', method: 'post', ...variables, signal });

export type SecondaryDnsPrimaryZoneForceDnsNotifyPathParams = {
  zoneId: Schemas.SecondaryDnsIdentifier;
};

export type SecondaryDnsPrimaryZoneForceDnsNotifyError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsSchemasForceResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsPrimaryZoneForceDnsNotifyVariables = {
  pathParams: SecondaryDnsPrimaryZoneForceDnsNotifyPathParams;
} & FetcherExtraProps;

/**
 * Notifies the secondary nameserver(s) and clears IXFR backlog of primary zone.
 */
export const secondaryDnsPrimaryZoneForceDnsNotify = (
  variables: SecondaryDnsPrimaryZoneForceDnsNotifyVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SecondaryDnsSchemasForceResponse,
    SecondaryDnsPrimaryZoneForceDnsNotifyError,
    undefined,
    {},
    {},
    SecondaryDnsPrimaryZoneForceDnsNotifyPathParams
  >({ url: '/zones/{zoneId}/secondary_dns/outgoing/force_notify', method: 'post', ...variables, signal });

export type SecondaryDnsPrimaryZoneGetOutgoingZoneTransferStatusPathParams = {
  zoneId: Schemas.SecondaryDnsIdentifier;
};

export type SecondaryDnsPrimaryZoneGetOutgoingZoneTransferStatusError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecondaryDnsEnableTransferResponse & Schemas.SecondaryDnsApiResponseCommonFailure;
}>;

export type SecondaryDnsPrimaryZoneGetOutgoingZoneTransferStatusVariables = {
  pathParams: SecondaryDnsPrimaryZoneGetOutgoingZoneTransferStatusPathParams;
} & FetcherExtraProps;

/**
 * Get primary zone transfer status.
 */
export const secondaryDnsPrimaryZoneGetOutgoingZoneTransferStatus = (
  variables: SecondaryDnsPrimaryZoneGetOutgoingZoneTransferStatusVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SecondaryDnsEnableTransferResponse,
    SecondaryDnsPrimaryZoneGetOutgoingZoneTransferStatusError,
    undefined,
    {},
    {},
    SecondaryDnsPrimaryZoneGetOutgoingZoneTransferStatusPathParams
  >({ url: '/zones/{zoneId}/secondary_dns/outgoing/status', method: 'get', ...variables, signal });

export type DeleteSecurityTxtPathParams = {
  zoneId: Schemas.SecurityCenterIdentifier;
};

export type DeleteSecurityTxtError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecurityCenterApiResponseCommonFailure;
}>;

export type DeleteSecurityTxtResponse = Schemas.SecurityCenterApiResponseSingle;

export type DeleteSecurityTxtVariables = {
  pathParams: DeleteSecurityTxtPathParams;
} & FetcherExtraProps;

export const deleteSecurityTxt = (variables: DeleteSecurityTxtVariables, signal?: AbortSignal) =>
  fetch<DeleteSecurityTxtResponse, DeleteSecurityTxtError, undefined, {}, {}, DeleteSecurityTxtPathParams>({
    url: '/zones/{zoneId}/security-center/securitytxt',
    method: 'delete',
    ...variables,
    signal
  });

export type GetSecurityTxtPathParams = {
  zoneId: Schemas.SecurityCenterIdentifier;
};

export type GetSecurityTxtError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecurityCenterApiResponseCommonFailure;
}>;

export type GetSecurityTxtResponse = Schemas.SecurityCenterApiResponseCommon & {
  result?: Schemas.SecurityCenterSecurityTxt;
};

export type GetSecurityTxtVariables = {
  pathParams: GetSecurityTxtPathParams;
} & FetcherExtraProps;

export const getSecurityTxt = (variables: GetSecurityTxtVariables, signal?: AbortSignal) =>
  fetch<GetSecurityTxtResponse, GetSecurityTxtError, undefined, {}, {}, GetSecurityTxtPathParams>({
    url: '/zones/{zoneId}/security-center/securitytxt',
    method: 'get',
    ...variables,
    signal
  });

export type UpdateSecurityTxtPathParams = {
  zoneId: Schemas.SecurityCenterIdentifier;
};

export type UpdateSecurityTxtError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SecurityCenterApiResponseCommonFailure;
}>;

export type UpdateSecurityTxtResponse = Schemas.SecurityCenterApiResponseSingle;

export type UpdateSecurityTxtVariables = {
  body?: Schemas.SecurityCenterSecurityTxt;
  pathParams: UpdateSecurityTxtPathParams;
} & FetcherExtraProps;

export const updateSecurityTxt = (variables: UpdateSecurityTxtVariables, signal?: AbortSignal) =>
  fetch<
    UpdateSecurityTxtResponse,
    UpdateSecurityTxtError,
    Schemas.SecurityCenterSecurityTxt,
    {},
    {},
    UpdateSecurityTxtPathParams
  >({ url: '/zones/{zoneId}/security-center/securitytxt', method: 'put', ...variables, signal });

export type ZoneSettingsGetAllZoneSettingsPathParams = {
  zoneId: Schemas.ZonesIdentifier;
};

export type ZoneSettingsGetAllZoneSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesApiResponseCommonFailure;
}>;

export type ZoneSettingsGetAllZoneSettingsVariables = {
  pathParams: ZoneSettingsGetAllZoneSettingsPathParams;
} & FetcherExtraProps;

/**
 * Available settings for your user in relation to a zone.
 */
export const zoneSettingsGetAllZoneSettings = (
  variables: ZoneSettingsGetAllZoneSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZonesZoneSettingsResponseCollection,
    ZoneSettingsGetAllZoneSettingsError,
    undefined,
    {},
    {},
    ZoneSettingsGetAllZoneSettingsPathParams
  >({ url: '/zones/{zoneId}/settings', method: 'get', ...variables, signal });

export type ZoneSettingsEditZoneSettingsInfoPathParams = {
  zoneId: Schemas.ZonesIdentifier;
};

export type ZoneSettingsEditZoneSettingsInfoError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesApiResponseCommonFailure;
}>;

export type ZoneSettingsEditZoneSettingsInfoVariables = {
  body?: Schemas.ZonesMultipleSettings;
  pathParams: ZoneSettingsEditZoneSettingsInfoPathParams;
} & FetcherExtraProps;

/**
 * Edit settings for a zone.
 */
export const zoneSettingsEditZoneSettingsInfo = (
  variables: ZoneSettingsEditZoneSettingsInfoVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZonesZoneSettingsResponseCollection,
    ZoneSettingsEditZoneSettingsInfoError,
    Schemas.ZonesMultipleSettings,
    {},
    {},
    ZoneSettingsEditZoneSettingsInfoPathParams
  >({ url: '/zones/{zoneId}/settings', method: 'patch', ...variables, signal });

export type ZoneCacheSettingsGetAegisSettingPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type ZoneCacheSettingsGetAegisSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type ZoneCacheSettingsGetAegisSettingResponse = Schemas.CacheRulesZoneComplexCacheSettingsResponseSingle &
  Schemas.CacheRulesAegisResponseValue;

export type ZoneCacheSettingsGetAegisSettingVariables = {
  pathParams: ZoneCacheSettingsGetAegisSettingPathParams;
} & FetcherExtraProps;

/**
 * Aegis provides dedicated egress IPs (from Cloudflare to your origin) for your layer 7 WAF and CDN services. The egress IPs are reserved exclusively for your account so that you can increase your origin security by only allowing traffic from a small list of IP addresses.
 */
export const zoneCacheSettingsGetAegisSetting = (
  variables: ZoneCacheSettingsGetAegisSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneCacheSettingsGetAegisSettingResponse,
    ZoneCacheSettingsGetAegisSettingError,
    undefined,
    {},
    {},
    ZoneCacheSettingsGetAegisSettingPathParams
  >({ url: '/zones/{zoneId}/settings/aegis', method: 'get', ...variables, signal });

export type ZoneCacheSettingsChangeAegisSettingPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type ZoneCacheSettingsChangeAegisSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type ZoneCacheSettingsChangeAegisSettingResponse = Schemas.CacheRulesZoneComplexCacheSettingsResponseSingle &
  Schemas.CacheRulesAegisResponseValue;

export type ZoneCacheSettingsChangeAegisSettingRequestBody = {
  value: Schemas.CacheRulesAegisValue;
};

export type ZoneCacheSettingsChangeAegisSettingVariables = {
  body: ZoneCacheSettingsChangeAegisSettingRequestBody;
  pathParams: ZoneCacheSettingsChangeAegisSettingPathParams;
} & FetcherExtraProps;

/**
 * Aegis provides dedicated egress IPs (from Cloudflare to your origin) for your layer 7 WAF and CDN services. The egress IPs are reserved exclusively for your account so that you can increase your origin security by only allowing traffic from a small list of IP addresses.
 */
export const zoneCacheSettingsChangeAegisSetting = (
  variables: ZoneCacheSettingsChangeAegisSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneCacheSettingsChangeAegisSettingResponse,
    ZoneCacheSettingsChangeAegisSettingError,
    ZoneCacheSettingsChangeAegisSettingRequestBody,
    {},
    {},
    ZoneCacheSettingsChangeAegisSettingPathParams
  >({ url: '/zones/{zoneId}/settings/aegis', method: 'patch', ...variables, signal });

export type ZoneSettingsGetFontsSettingPathParams = {
  zoneId: Schemas.SpeedIdentifier;
};

export type ZoneSettingsGetFontsSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SpeedApiResponseCommonFailure;
}>;

export type ZoneSettingsGetFontsSettingResponse = Schemas.SpeedApiResponseCommon & {
  result?: Schemas.SpeedCloudflareFonts;
};

export type ZoneSettingsGetFontsSettingVariables = {
  pathParams: ZoneSettingsGetFontsSettingPathParams;
} & FetcherExtraProps;

/**
 * Enhance your website's font delivery with Cloudflare Fonts. Deliver Google Hosted fonts from your own domain,
 * boost performance, and enhance user privacy. Refer to the Cloudflare Fonts documentation for more information.
 */
export const zoneSettingsGetFontsSetting = (variables: ZoneSettingsGetFontsSettingVariables, signal?: AbortSignal) =>
  fetch<
    ZoneSettingsGetFontsSettingResponse,
    ZoneSettingsGetFontsSettingError,
    undefined,
    {},
    {},
    ZoneSettingsGetFontsSettingPathParams
  >({ url: '/zones/{zoneId}/settings/fonts', method: 'get', ...variables, signal });

export type ZoneSettingsChangeFontsSettingPathParams = {
  zoneId: Schemas.SpeedIdentifier;
};

export type ZoneSettingsChangeFontsSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SpeedApiResponseCommonFailure;
}>;

export type ZoneSettingsChangeFontsSettingResponse = Schemas.SpeedApiResponseCommon & {
  result?: Schemas.SpeedCloudflareFonts;
};

export type ZoneSettingsChangeFontsSettingRequestBody = {
  value: Schemas.SpeedCloudflareFontsValue;
};

export type ZoneSettingsChangeFontsSettingVariables = {
  body: ZoneSettingsChangeFontsSettingRequestBody;
  pathParams: ZoneSettingsChangeFontsSettingPathParams;
} & FetcherExtraProps;

/**
 * Enhance your website's font delivery with Cloudflare Fonts. Deliver Google Hosted fonts from your own domain,
 * boost performance, and enhance user privacy. Refer to the Cloudflare Fonts documentation for more information.
 */
export const zoneSettingsChangeFontsSetting = (
  variables: ZoneSettingsChangeFontsSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneSettingsChangeFontsSettingResponse,
    ZoneSettingsChangeFontsSettingError,
    ZoneSettingsChangeFontsSettingRequestBody,
    {},
    {},
    ZoneSettingsChangeFontsSettingPathParams
  >({ url: '/zones/{zoneId}/settings/fonts', method: 'patch', ...variables, signal });

export type ZoneCacheSettingsGetOriginMaxHttpVersionSettingPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type ZoneCacheSettingsGetOriginMaxHttpVersionSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type ZoneCacheSettingsGetOriginMaxHttpVersionSettingResponse =
  Schemas.CacheRulesZoneCacheSettingsResponseSingle & Schemas.CacheRulesOriginMaxHttpVersionResponseValue;

export type ZoneCacheSettingsGetOriginMaxHttpVersionSettingVariables = {
  pathParams: ZoneCacheSettingsGetOriginMaxHttpVersionSettingPathParams;
} & FetcherExtraProps;

/**
 * Origin Max HTTP Setting Version sets the highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to [Enable HTTP/2 to Origin](https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/), for more information.). The default value is "2" for all plan types except ENT where it is "1"
 */
export const zoneCacheSettingsGetOriginMaxHttpVersionSetting = (
  variables: ZoneCacheSettingsGetOriginMaxHttpVersionSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneCacheSettingsGetOriginMaxHttpVersionSettingResponse,
    ZoneCacheSettingsGetOriginMaxHttpVersionSettingError,
    undefined,
    {},
    {},
    ZoneCacheSettingsGetOriginMaxHttpVersionSettingPathParams
  >({ url: '/zones/{zoneId}/settings/origin_max_http_version', method: 'get', ...variables, signal });

export type ZoneCacheSettingsChangeOriginMaxHttpVersionSettingPathParams = {
  zoneId: Schemas.CacheRulesIdentifier;
};

export type ZoneCacheSettingsChangeOriginMaxHttpVersionSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheRulesApiResponseCommonFailure;
}>;

export type ZoneCacheSettingsChangeOriginMaxHttpVersionSettingResponse =
  Schemas.CacheRulesZoneCacheSettingsResponseSingle & Schemas.CacheRulesOriginMaxHttpVersionResponseValue;

export type ZoneCacheSettingsChangeOriginMaxHttpVersionSettingRequestBody = {
  value: Schemas.CacheRulesOriginMaxHttpVersionValue;
};

export type ZoneCacheSettingsChangeOriginMaxHttpVersionSettingVariables = {
  body: ZoneCacheSettingsChangeOriginMaxHttpVersionSettingRequestBody;
  pathParams: ZoneCacheSettingsChangeOriginMaxHttpVersionSettingPathParams;
} & FetcherExtraProps;

/**
 * Origin Max HTTP Setting Version sets the highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to [Enable HTTP/2 to Origin](https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/), for more information.). The default value is "2" for all plan types except ENT where it is "1"
 */
export const zoneCacheSettingsChangeOriginMaxHttpVersionSetting = (
  variables: ZoneCacheSettingsChangeOriginMaxHttpVersionSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneCacheSettingsChangeOriginMaxHttpVersionSettingResponse,
    ZoneCacheSettingsChangeOriginMaxHttpVersionSettingError,
    ZoneCacheSettingsChangeOriginMaxHttpVersionSettingRequestBody,
    {},
    {},
    ZoneCacheSettingsChangeOriginMaxHttpVersionSettingPathParams
  >({ url: '/zones/{zoneId}/settings/origin_max_http_version', method: 'patch', ...variables, signal });

export type WebAnalyticsGetRumStatusPathParams = {
  zoneId: Schemas.RumIdentifier;
};

export type WebAnalyticsGetRumStatusError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.RumApiResponseCommonFailure;
}>;

export type WebAnalyticsGetRumStatusVariables = {
  pathParams: WebAnalyticsGetRumStatusPathParams;
} & FetcherExtraProps;

/**
 * Retrieves RUM status for a zone.
 */
export const webAnalyticsGetRumStatus = (variables: WebAnalyticsGetRumStatusVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.RumRumSiteResponseSingle,
    WebAnalyticsGetRumStatusError,
    undefined,
    {},
    {},
    WebAnalyticsGetRumStatusPathParams
  >({ url: '/zones/{zoneId}/settings/rum', method: 'get', ...variables, signal });

export type WebAnalyticsToggleRumPathParams = {
  zoneId: Schemas.RumIdentifier;
};

export type WebAnalyticsToggleRumError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.RumApiResponseCommonFailure;
}>;

export type WebAnalyticsToggleRumVariables = {
  body?: Schemas.RumToggleRumRequest;
  pathParams: WebAnalyticsToggleRumPathParams;
} & FetcherExtraProps;

/**
 * Toggles RUM on/off for an existing zone
 */
export const webAnalyticsToggleRum = (variables: WebAnalyticsToggleRumVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.RumRumSiteResponseSingle,
    WebAnalyticsToggleRumError,
    Schemas.RumToggleRumRequest,
    {},
    {},
    WebAnalyticsToggleRumPathParams
  >({ url: '/zones/{zoneId}/settings/rum', method: 'patch', ...variables, signal });

export type ZoneSettingsGetSpeedBrainSettingPathParams = {
  zoneId: Schemas.SpeedIdentifier;
};

export type ZoneSettingsGetSpeedBrainSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SpeedApiResponseCommonFailure;
}>;

export type ZoneSettingsGetSpeedBrainSettingResponse = Schemas.SpeedApiResponseCommon & {
  result?: Schemas.SpeedCloudflareSpeedBrainResponse;
};

export type ZoneSettingsGetSpeedBrainSettingVariables = {
  pathParams: ZoneSettingsGetSpeedBrainSettingPathParams;
} & FetcherExtraProps;

/**
 * Speed Brain lets compatible browsers speculate on content which can be prefetched or preloaded, making website
 * navigation faster. Refer to the Cloudflare Speed Brain documentation for more information.
 */
export const zoneSettingsGetSpeedBrainSetting = (
  variables: ZoneSettingsGetSpeedBrainSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneSettingsGetSpeedBrainSettingResponse,
    ZoneSettingsGetSpeedBrainSettingError,
    undefined,
    {},
    {},
    ZoneSettingsGetSpeedBrainSettingPathParams
  >({ url: '/zones/{zoneId}/settings/speed_brain', method: 'get', ...variables, signal });

export type ZoneSettingsChangeSpeedBrainSettingPathParams = {
  zoneId: Schemas.SpeedIdentifier;
};

export type ZoneSettingsChangeSpeedBrainSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SpeedApiResponseCommonFailure;
}>;

export type ZoneSettingsChangeSpeedBrainSettingResponse = Schemas.SpeedApiResponseCommon & {
  result?: Schemas.SpeedCloudflareSpeedBrainResponse;
};

export type ZoneSettingsChangeSpeedBrainSettingRequestBody = {
  /**
   * Whether the feature is enabled or disabled.
   */
  value: 'on' | 'off';
};

export type ZoneSettingsChangeSpeedBrainSettingVariables = {
  body: ZoneSettingsChangeSpeedBrainSettingRequestBody;
  pathParams: ZoneSettingsChangeSpeedBrainSettingPathParams;
} & FetcherExtraProps;

/**
 * Speed Brain lets compatible browsers speculate on content which can be prefetched or preloaded, making website
 * navigation faster. Refer to the Cloudflare Speed Brain documentation for more information.
 */
export const zoneSettingsChangeSpeedBrainSetting = (
  variables: ZoneSettingsChangeSpeedBrainSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneSettingsChangeSpeedBrainSettingResponse,
    ZoneSettingsChangeSpeedBrainSettingError,
    ZoneSettingsChangeSpeedBrainSettingRequestBody,
    {},
    {},
    ZoneSettingsChangeSpeedBrainSettingPathParams
  >({ url: '/zones/{zoneId}/settings/speed_brain', method: 'patch', ...variables, signal });

export type GetZonesZoneIdentifierZarazConfigPathParams = {
  zoneId: Schemas.ZarazIdentifier;
};

export type GetZonesZoneIdentifierZarazConfigError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZarazApiResponseCommonFailure;
}>;

export type GetZonesZoneIdentifierZarazConfigVariables = {
  pathParams: GetZonesZoneIdentifierZarazConfigPathParams;
} & FetcherExtraProps;

/**
 * Gets latest Zaraz configuration for a zone. It can be preview or published configuration, whichever was the last updated. Secret variables values will not be included.
 */
export const getZonesZoneIdentifierZarazConfig = (
  variables: GetZonesZoneIdentifierZarazConfigVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZarazZarazConfigResponse,
    GetZonesZoneIdentifierZarazConfigError,
    undefined,
    {},
    {},
    GetZonesZoneIdentifierZarazConfigPathParams
  >({ url: '/zones/{zoneId}/settings/zaraz/config', method: 'get', ...variables, signal });

export type PutZonesZoneIdentifierZarazConfigPathParams = {
  zoneId: Schemas.ZarazIdentifier;
};

export type PutZonesZoneIdentifierZarazConfigError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZarazApiResponseCommonFailure;
}>;

export type PutZonesZoneIdentifierZarazConfigVariables = {
  body?: Schemas.ZarazZarazConfigBody;
  pathParams: PutZonesZoneIdentifierZarazConfigPathParams;
} & FetcherExtraProps;

/**
 * Updates Zaraz configuration for a zone.
 */
export const putZonesZoneIdentifierZarazConfig = (
  variables: PutZonesZoneIdentifierZarazConfigVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZarazZarazConfigResponse,
    PutZonesZoneIdentifierZarazConfigError,
    Schemas.ZarazZarazConfigBody,
    {},
    {},
    PutZonesZoneIdentifierZarazConfigPathParams
  >({ url: '/zones/{zoneId}/settings/zaraz/config', method: 'put', ...variables, signal });

export type GetZonesZoneIdentifierZarazDefaultPathParams = {
  zoneId: Schemas.ZarazIdentifier;
};

export type GetZonesZoneIdentifierZarazDefaultError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZarazApiResponseCommonFailure;
}>;

export type GetZonesZoneIdentifierZarazDefaultVariables = {
  pathParams: GetZonesZoneIdentifierZarazDefaultPathParams;
} & FetcherExtraProps;

/**
 * Gets default Zaraz configuration for a zone.
 */
export const getZonesZoneIdentifierZarazDefault = (
  variables: GetZonesZoneIdentifierZarazDefaultVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZarazZarazConfigResponse,
    GetZonesZoneIdentifierZarazDefaultError,
    undefined,
    {},
    {},
    GetZonesZoneIdentifierZarazDefaultPathParams
  >({ url: '/zones/{zoneId}/settings/zaraz/default', method: 'get', ...variables, signal });

export type GetZonesZoneIdentifierZarazExportPathParams = {
  zoneId: Schemas.ZarazIdentifier;
};

export type GetZonesZoneIdentifierZarazExportError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZarazApiResponseCommonFailure;
}>;

export type GetZonesZoneIdentifierZarazExportVariables = {
  pathParams: GetZonesZoneIdentifierZarazExportPathParams;
} & FetcherExtraProps;

/**
 * Exports full current published Zaraz configuration for a zone, secret variables included.
 */
export const getZonesZoneIdentifierZarazExport = (
  variables: GetZonesZoneIdentifierZarazExportVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZarazZarazConfigReturn,
    GetZonesZoneIdentifierZarazExportError,
    undefined,
    {},
    {},
    GetZonesZoneIdentifierZarazExportPathParams
  >({ url: '/zones/{zoneId}/settings/zaraz/export', method: 'get', ...variables, signal });

export type GetZonesZoneIdentifierZarazHistoryPathParams = {
  zoneId: Schemas.ZarazIdentifier;
};

export type GetZonesZoneIdentifierZarazHistoryQueryParams = {
  /**
   * Ordinal number to start listing the results with. Default value is 0.
   *
   * @minimum 0
   */
  offset?: number;
  /**
   * Maximum amount of results to list. Default value is 10.
   *
   * @minimum 1
   */
  limit?: number;
  /**
   * The field to sort by. Default is updated_at.
   */
  sortField?: 'id' | 'user_id' | 'description' | 'created_at' | 'updated_at';
  /**
   * Sorting order. Default is DESC.
   */
  sortOrder?: 'DESC' | 'ASC';
};

export type GetZonesZoneIdentifierZarazHistoryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZarazApiResponseCommonFailure;
}>;

export type GetZonesZoneIdentifierZarazHistoryVariables = {
  pathParams: GetZonesZoneIdentifierZarazHistoryPathParams;
  queryParams?: GetZonesZoneIdentifierZarazHistoryQueryParams;
} & FetcherExtraProps;

/**
 * Lists a history of published Zaraz configuration records for a zone.
 */
export const getZonesZoneIdentifierZarazHistory = (
  variables: GetZonesZoneIdentifierZarazHistoryVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZarazZarazHistoryResponse,
    GetZonesZoneIdentifierZarazHistoryError,
    undefined,
    {},
    GetZonesZoneIdentifierZarazHistoryQueryParams,
    GetZonesZoneIdentifierZarazHistoryPathParams
  >({ url: '/zones/{zoneId}/settings/zaraz/history', method: 'get', ...variables, signal });

export type PutZonesZoneIdentifierZarazHistoryPathParams = {
  zoneId: Schemas.ZarazIdentifier;
};

export type PutZonesZoneIdentifierZarazHistoryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZarazApiResponseCommonFailure;
}>;

export type PutZonesZoneIdentifierZarazHistoryVariables = {
  body?: number;
  pathParams: PutZonesZoneIdentifierZarazHistoryPathParams;
} & FetcherExtraProps;

/**
 * Restores a historical published Zaraz configuration by ID for a zone.
 */
export const putZonesZoneIdentifierZarazHistory = (
  variables: PutZonesZoneIdentifierZarazHistoryVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZarazZarazConfigResponse,
    PutZonesZoneIdentifierZarazHistoryError,
    number,
    {},
    {},
    PutZonesZoneIdentifierZarazHistoryPathParams
  >({ url: '/zones/{zoneId}/settings/zaraz/history', method: 'put', ...variables, signal });

export type GetZonesZoneIdentifierZarazConfigHistoryPathParams = {
  zoneId: Schemas.ZarazIdentifier;
};

export type GetZonesZoneIdentifierZarazConfigHistoryQueryParams = {
  /**
   * Comma separated list of Zaraz configuration IDs
   */
  ids: number[];
};

export type GetZonesZoneIdentifierZarazConfigHistoryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZarazApiResponseCommonFailure;
}>;

export type GetZonesZoneIdentifierZarazConfigHistoryVariables = {
  pathParams: GetZonesZoneIdentifierZarazConfigHistoryPathParams;
  queryParams: GetZonesZoneIdentifierZarazConfigHistoryQueryParams;
} & FetcherExtraProps;

/**
 * Gets a history of published Zaraz configurations by ID(s) for a zone.
 */
export const getZonesZoneIdentifierZarazConfigHistory = (
  variables: GetZonesZoneIdentifierZarazConfigHistoryVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZarazZarazConfigHistoryResponse,
    GetZonesZoneIdentifierZarazConfigHistoryError,
    undefined,
    {},
    GetZonesZoneIdentifierZarazConfigHistoryQueryParams,
    GetZonesZoneIdentifierZarazConfigHistoryPathParams
  >({ url: '/zones/{zoneId}/settings/zaraz/history/configs', method: 'get', ...variables, signal });

export type PostZonesZoneIdentifierZarazPublishPathParams = {
  zoneId: Schemas.ZarazIdentifier;
};

export type PostZonesZoneIdentifierZarazPublishError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZarazApiResponseCommonFailure;
}>;

export type PostZonesZoneIdentifierZarazPublishResponse = Schemas.ZarazApiResponseCommon & {
  /**
   * @example Config has been published successfully
   */
  result?: string;
};

export type PostZonesZoneIdentifierZarazPublishVariables = {
  body?: string;
  pathParams: PostZonesZoneIdentifierZarazPublishPathParams;
} & FetcherExtraProps;

/**
 * Publish current Zaraz preview configuration for a zone.
 */
export const postZonesZoneIdentifierZarazPublish = (
  variables: PostZonesZoneIdentifierZarazPublishVariables,
  signal?: AbortSignal
) =>
  fetch<
    PostZonesZoneIdentifierZarazPublishResponse,
    PostZonesZoneIdentifierZarazPublishError,
    string,
    {},
    {},
    PostZonesZoneIdentifierZarazPublishPathParams
  >({ url: '/zones/{zoneId}/settings/zaraz/publish', method: 'post', ...variables, signal });

export type GetZonesZoneIdentifierZarazWorkflowPathParams = {
  zoneId: Schemas.ZarazIdentifier;
};

export type GetZonesZoneIdentifierZarazWorkflowError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZarazApiResponseCommonFailure;
}>;

export type GetZonesZoneIdentifierZarazWorkflowVariables = {
  pathParams: GetZonesZoneIdentifierZarazWorkflowPathParams;
} & FetcherExtraProps;

/**
 * Gets Zaraz workflow for a zone.
 */
export const getZonesZoneIdentifierZarazWorkflow = (
  variables: GetZonesZoneIdentifierZarazWorkflowVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZarazZarazWorkflowResponse,
    GetZonesZoneIdentifierZarazWorkflowError,
    undefined,
    {},
    {},
    GetZonesZoneIdentifierZarazWorkflowPathParams
  >({ url: '/zones/{zoneId}/settings/zaraz/workflow', method: 'get', ...variables, signal });

export type PutZonesZoneIdentifierZarazWorkflowPathParams = {
  zoneId: Schemas.ZarazIdentifier;
};

export type PutZonesZoneIdentifierZarazWorkflowError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZarazApiResponseCommonFailure;
}>;

export type PutZonesZoneIdentifierZarazWorkflowVariables = {
  body?: Schemas.ZarazZarazWorkflow;
  pathParams: PutZonesZoneIdentifierZarazWorkflowPathParams;
} & FetcherExtraProps;

/**
 * Updates Zaraz workflow for a zone.
 */
export const putZonesZoneIdentifierZarazWorkflow = (
  variables: PutZonesZoneIdentifierZarazWorkflowVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.ZarazZarazWorkflowResponse,
    PutZonesZoneIdentifierZarazWorkflowError,
    Schemas.ZarazZarazWorkflow,
    {},
    {},
    PutZonesZoneIdentifierZarazWorkflowPathParams
  >({ url: '/zones/{zoneId}/settings/zaraz/workflow', method: 'put', ...variables, signal });

export type ZoneSettingsGetSingleSettingPathParams = {
  zoneId: Schemas.ZonesIdentifier;
  settingId: Schemas.ZonesSettingName;
};

export type ZoneSettingsGetSingleSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesApiResponseCommonFailure;
}>;

export type ZoneSettingsGetSingleSettingResponse = Schemas.ZonesApiResponseCommon & {
  result?: Schemas.ZonesSetting;
};

export type ZoneSettingsGetSingleSettingVariables = {
  pathParams: ZoneSettingsGetSingleSettingPathParams;
} & FetcherExtraProps;

/**
 * Fetch a single zone setting by name
 */
export const zoneSettingsGetSingleSetting = (variables: ZoneSettingsGetSingleSettingVariables, signal?: AbortSignal) =>
  fetch<
    ZoneSettingsGetSingleSettingResponse,
    ZoneSettingsGetSingleSettingError,
    undefined,
    {},
    {},
    ZoneSettingsGetSingleSettingPathParams
  >({ url: '/zones/{zoneId}/settings/{settingId}', method: 'get', ...variables, signal });

export type ZoneSettingsEditSingleSettingPathParams = {
  zoneId: Schemas.ZonesIdentifier;
  settingId: Schemas.ZonesSettingName;
};

export type ZoneSettingsEditSingleSettingError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ZonesApiResponseCommonFailure;
}>;

export type ZoneSettingsEditSingleSettingResponse = Schemas.ZonesApiResponseCommon & {
  result?: Schemas.ZonesSetting;
};

export type ZoneSettingsEditSingleSettingVariables = {
  body?: Schemas.ZonesSetting;
  pathParams: ZoneSettingsEditSingleSettingPathParams;
} & FetcherExtraProps;

/**
 * Updates a single zone setting by the identifier
 */
export const zoneSettingsEditSingleSetting = (
  variables: ZoneSettingsEditSingleSettingVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneSettingsEditSingleSettingResponse,
    ZoneSettingsEditSingleSettingError,
    Schemas.ZonesSetting,
    {},
    {},
    ZoneSettingsEditSingleSettingPathParams
  >({ url: '/zones/{zoneId}/settings/{settingId}', method: 'patch', ...variables, signal });

export type ZoneSnippetsPathParams = {
  zoneId: Schemas.SnippetsIdentifier;
};

export type ZoneSnippetsError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.SnippetsApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.SnippetsApiResponseCommonFailure;
    }
>;

export type ZoneSnippetsResponse = Schemas.SnippetsApiResponseCommon & {
  /**
   * List of all zone snippets
   */
  result?: Schemas.SnippetsSnippet[];
};

export type ZoneSnippetsVariables = {
  pathParams: ZoneSnippetsPathParams;
} & FetcherExtraProps;

export const zoneSnippets = (variables: ZoneSnippetsVariables, signal?: AbortSignal) =>
  fetch<ZoneSnippetsResponse, ZoneSnippetsError, undefined, {}, {}, ZoneSnippetsPathParams>({
    url: '/zones/{zoneId}/snippets',
    method: 'get',
    ...variables,
    signal
  });

export type ZoneSnippetsSnippetRulesDeletePathParams = {
  zoneId: Schemas.SnippetsIdentifier;
};

export type ZoneSnippetsSnippetRulesDeleteError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.SnippetsApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.SnippetsApiResponseCommonFailure;
    }
>;

export type ZoneSnippetsSnippetRulesDeleteResponse = Schemas.SnippetsApiResponseCommon;

export type ZoneSnippetsSnippetRulesDeleteVariables = {
  pathParams: ZoneSnippetsSnippetRulesDeletePathParams;
} & FetcherExtraProps;

export const zoneSnippetsSnippetRulesDelete = (
  variables: ZoneSnippetsSnippetRulesDeleteVariables,
  signal?: AbortSignal
) =>
  fetch<
    ZoneSnippetsSnippetRulesDeleteResponse,
    ZoneSnippetsSnippetRulesDeleteError,
    undefined,
    {},
    {},
    ZoneSnippetsSnippetRulesDeletePathParams
  >({ url: '/zones/{zoneId}/snippets/snippet_rules', method: 'delete', ...variables, signal });

export type ZoneSnippetsSnippetRulesPathParams = {
  zoneId: Schemas.SnippetsIdentifier;
};

export type ZoneSnippetsSnippetRulesError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.SnippetsApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.SnippetsApiResponseCommonFailure;
    }
>;

export type ZoneSnippetsSnippetRulesResponse = Schemas.SnippetsApiResponseCommon & {
  result?: Schemas.SnippetsRules;
};

export type ZoneSnippetsSnippetRulesVariables = {
  pathParams: ZoneSnippetsSnippetRulesPathParams;
} & FetcherExtraProps;

export const zoneSnippetsSnippetRules = (variables: ZoneSnippetsSnippetRulesVariables, signal?: AbortSignal) =>
  fetch<
    ZoneSnippetsSnippetRulesResponse,
    ZoneSnippetsSnippetRulesError,
    undefined,
    {},
    {},
    ZoneSnippetsSnippetRulesPathParams
  >({ url: '/zones/{zoneId}/snippets/snippet_rules', method: 'get', ...variables, signal });

export type ZoneSnippetsSnippetRulesPutPathParams = {
  zoneId: Schemas.SnippetsIdentifier;
};

export type ZoneSnippetsSnippetRulesPutError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.SnippetsApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.SnippetsApiResponseCommonFailure;
    }
>;

export type ZoneSnippetsSnippetRulesPutResponse = Schemas.SnippetsApiResponseCommon & {
  result?: Schemas.SnippetsRules;
};

export type ZoneSnippetsSnippetRulesPutRequestBody = {
  rules?: Schemas.SnippetsRules;
};

export type ZoneSnippetsSnippetRulesPutVariables = {
  body?: ZoneSnippetsSnippetRulesPutRequestBody;
  pathParams: ZoneSnippetsSnippetRulesPutPathParams;
} & FetcherExtraProps;

export const zoneSnippetsSnippetRulesPut = (variables: ZoneSnippetsSnippetRulesPutVariables, signal?: AbortSignal) =>
  fetch<
    ZoneSnippetsSnippetRulesPutResponse,
    ZoneSnippetsSnippetRulesPutError,
    ZoneSnippetsSnippetRulesPutRequestBody,
    {},
    {},
    ZoneSnippetsSnippetRulesPutPathParams
  >({ url: '/zones/{zoneId}/snippets/snippet_rules', method: 'put', ...variables, signal });

export type ZoneSnippetsSnippetDeletePathParams = {
  zoneId: Schemas.SnippetsIdentifier;
  snippetName: Schemas.SnippetsSnippetName;
};

export type ZoneSnippetsSnippetDeleteError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.SnippetsApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.SnippetsApiResponseCommonFailure;
    }
>;

export type ZoneSnippetsSnippetDeleteResponse = Schemas.SnippetsApiResponseCommon;

export type ZoneSnippetsSnippetDeleteVariables = {
  pathParams: ZoneSnippetsSnippetDeletePathParams;
} & FetcherExtraProps;

export const zoneSnippetsSnippetDelete = (variables: ZoneSnippetsSnippetDeleteVariables, signal?: AbortSignal) =>
  fetch<
    ZoneSnippetsSnippetDeleteResponse,
    ZoneSnippetsSnippetDeleteError,
    undefined,
    {},
    {},
    ZoneSnippetsSnippetDeletePathParams
  >({ url: '/zones/{zoneId}/snippets/{snippetName}', method: 'delete', ...variables, signal });

export type ZoneSnippetsSnippetPathParams = {
  zoneId: Schemas.SnippetsIdentifier;
  snippetName: Schemas.SnippetsSnippetName;
};

export type ZoneSnippetsSnippetError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.SnippetsApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.SnippetsApiResponseCommonFailure;
    }
>;

export type ZoneSnippetsSnippetResponse = Schemas.SnippetsApiResponseCommon & {
  result?: Schemas.SnippetsSnippet;
};

export type ZoneSnippetsSnippetVariables = {
  pathParams: ZoneSnippetsSnippetPathParams;
} & FetcherExtraProps;

export const zoneSnippetsSnippet = (variables: ZoneSnippetsSnippetVariables, signal?: AbortSignal) =>
  fetch<ZoneSnippetsSnippetResponse, ZoneSnippetsSnippetError, undefined, {}, {}, ZoneSnippetsSnippetPathParams>({
    url: '/zones/{zoneId}/snippets/{snippetName}',
    method: 'get',
    ...variables,
    signal
  });

export type ZoneSnippetsSnippetPutPathParams = {
  zoneId: Schemas.SnippetsIdentifier;
  snippetName: Schemas.SnippetsSnippetName;
};

export type ZoneSnippetsSnippetPutError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.SnippetsApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.SnippetsApiResponseCommonFailure;
    }
>;

export type ZoneSnippetsSnippetPutResponse = Schemas.SnippetsApiResponseCommon & {
  result?: Schemas.SnippetsSnippet;
};

export type ZoneSnippetsSnippetPutRequestBody = {
  /**
   * Content files of uploaded snippet
   *
   * @example export { async function fetch(request, env) {return new Response('some_response') } }
   */
  files?: string;
  metadata?: {
    /**
     * Main module name of uploaded snippet
     *
     * @example main.js
     */
    main_module?: string;
  };
};

export type ZoneSnippetsSnippetPutVariables = {
  body?: ZoneSnippetsSnippetPutRequestBody;
  pathParams: ZoneSnippetsSnippetPutPathParams;
} & FetcherExtraProps;

export const zoneSnippetsSnippetPut = (variables: ZoneSnippetsSnippetPutVariables, signal?: AbortSignal) =>
  fetch<
    ZoneSnippetsSnippetPutResponse,
    ZoneSnippetsSnippetPutError,
    ZoneSnippetsSnippetPutRequestBody,
    {},
    {},
    ZoneSnippetsSnippetPutPathParams
  >({ url: '/zones/{zoneId}/snippets/{snippetName}', method: 'put', ...variables, signal });

export type ZoneSnippetsSnippetContentPathParams = {
  zoneId: Schemas.SnippetsIdentifier;
  snippetName: Schemas.SnippetsSnippetName;
};

export type ZoneSnippetsSnippetContentError = Fetcher.ErrorWrapper<
  | {
      status: 400;
      payload: Schemas.SnippetsApiResponseCommonFailure;
    }
  | {
      status: 500;
      payload: Schemas.SnippetsApiResponseCommonFailure;
    }
>;

export type ZoneSnippetsSnippetContentResponse = {
  /**
   * Content files of uploaded snippet
   *
   * @example export { async function fetch(request, env) {return new Response('some_response') } }
   */
  files?: string;
};

export type ZoneSnippetsSnippetContentVariables = {
  pathParams: ZoneSnippetsSnippetContentPathParams;
} & FetcherExtraProps;

export const zoneSnippetsSnippetContent = (variables: ZoneSnippetsSnippetContentVariables, signal?: AbortSignal) =>
  fetch<
    ZoneSnippetsSnippetContentResponse,
    ZoneSnippetsSnippetContentError,
    undefined,
    {},
    {},
    ZoneSnippetsSnippetContentPathParams
  >({ url: '/zones/{zoneId}/snippets/{snippetName}/content', method: 'get', ...variables, signal });

export type SpectrumAggregateAnalyticsGetCurrentAggregatedAnalyticsPathParams = {
  zoneId: Schemas.SpectrumAnalyticsIdentifier;
};

export type SpectrumAggregateAnalyticsGetCurrentAggregatedAnalyticsQueryParams = {
  appID?: Schemas.SpectrumAnalyticsAppIdParam;
  /**
   * @example PDX
   * @maxLength 3
   */
  colo_name?: string;
};

export type SpectrumAggregateAnalyticsGetCurrentAggregatedAnalyticsError = Fetcher.ErrorWrapper<{
  status: ClientErrorStatus;
  payload: Schemas.SpectrumAnalyticsApiResponseCommonFailure;
}>;

export type SpectrumAggregateAnalyticsGetCurrentAggregatedAnalyticsVariables = {
  pathParams: SpectrumAggregateAnalyticsGetCurrentAggregatedAnalyticsPathParams;
  queryParams?: SpectrumAggregateAnalyticsGetCurrentAggregatedAnalyticsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves analytics aggregated from the last minute of usage on Spectrum applications underneath a given zone.
 */
export const spectrumAggregateAnalyticsGetCurrentAggregatedAnalytics = (
  variables: SpectrumAggregateAnalyticsGetCurrentAggregatedAnalyticsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SpectrumAnalyticsQueryResponseAggregate,
    SpectrumAggregateAnalyticsGetCurrentAggregatedAnalyticsError,
    undefined,
    {},
    SpectrumAggregateAnalyticsGetCurrentAggregatedAnalyticsQueryParams,
    SpectrumAggregateAnalyticsGetCurrentAggregatedAnalyticsPathParams
  >({ url: '/zones/{zoneId}/spectrum/analytics/aggregate/current', method: 'get', ...variables, signal });

export type SpectrumAnalyticsByTimeGetAnalyticsByTimePathParams = {
  zoneId: Schemas.SpectrumAnalyticsIdentifier;
};

export type SpectrumAnalyticsByTimeGetAnalyticsByTimeQueryParams = {
  dimensions?: Schemas.SpectrumAnalyticsDimensions;
  sort?: Schemas.SpectrumAnalyticsSort;
  until?: Schemas.SpectrumAnalyticsUntil;
  metrics?: Schemas.SpectrumAnalyticsMetrics;
  filters?: Schemas.SpectrumAnalyticsFilters;
  since?: Schemas.SpectrumAnalyticsSince;
  /**
   * @example minute
   */
  time_delta: 'year' | 'quarter' | 'month' | 'week' | 'day' | 'hour' | 'dekaminute' | 'minute';
};

export type SpectrumAnalyticsByTimeGetAnalyticsByTimeError = Fetcher.ErrorWrapper<{
  status: ClientErrorStatus;
  payload: Schemas.SpectrumAnalyticsApiResponseCommonFailure;
}>;

export type SpectrumAnalyticsByTimeGetAnalyticsByTimeVariables = {
  pathParams: SpectrumAnalyticsByTimeGetAnalyticsByTimePathParams;
  queryParams: SpectrumAnalyticsByTimeGetAnalyticsByTimeQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of aggregate metrics grouped by time interval.
 */
export const spectrumAnalyticsByTimeGetAnalyticsByTime = (
  variables: SpectrumAnalyticsByTimeGetAnalyticsByTimeVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SpectrumAnalyticsQueryResponseSingle,
    SpectrumAnalyticsByTimeGetAnalyticsByTimeError,
    undefined,
    {},
    SpectrumAnalyticsByTimeGetAnalyticsByTimeQueryParams,
    SpectrumAnalyticsByTimeGetAnalyticsByTimePathParams
  >({ url: '/zones/{zoneId}/spectrum/analytics/events/bytime', method: 'get', ...variables, signal });

export type SpectrumAnalyticsSummaryGetAnalyticsSummaryPathParams = {
  zoneId: Schemas.SpectrumAnalyticsIdentifier;
};

export type SpectrumAnalyticsSummaryGetAnalyticsSummaryQueryParams = {
  dimensions?: Schemas.SpectrumAnalyticsDimensions;
  sort?: Schemas.SpectrumAnalyticsSort;
  until?: Schemas.SpectrumAnalyticsUntil;
  metrics?: Schemas.SpectrumAnalyticsMetrics;
  filters?: Schemas.SpectrumAnalyticsFilters;
  since?: Schemas.SpectrumAnalyticsSince;
};

export type SpectrumAnalyticsSummaryGetAnalyticsSummaryError = Fetcher.ErrorWrapper<{
  status: ClientErrorStatus;
  payload: Schemas.SpectrumAnalyticsApiResponseCommonFailure;
}>;

export type SpectrumAnalyticsSummaryGetAnalyticsSummaryVariables = {
  pathParams: SpectrumAnalyticsSummaryGetAnalyticsSummaryPathParams;
  queryParams?: SpectrumAnalyticsSummaryGetAnalyticsSummaryQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of summarised aggregate metrics over a given time period.
 */
export const spectrumAnalyticsSummaryGetAnalyticsSummary = (
  variables: SpectrumAnalyticsSummaryGetAnalyticsSummaryVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SpectrumAnalyticsQueryResponseSingle,
    SpectrumAnalyticsSummaryGetAnalyticsSummaryError,
    undefined,
    {},
    SpectrumAnalyticsSummaryGetAnalyticsSummaryQueryParams,
    SpectrumAnalyticsSummaryGetAnalyticsSummaryPathParams
  >({ url: '/zones/{zoneId}/spectrum/analytics/events/summary', method: 'get', ...variables, signal });

export type SpectrumApplicationsListSpectrumApplicationsPathParams = {
  zoneId: Schemas.SpectrumConfigZoneIdentifier;
};

export type SpectrumApplicationsListSpectrumApplicationsQueryParams = {
  /**
   * @example 1
   * @minimum 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 100
   * @minimum 1
   */
  per_page?: number;
  /**
   * @default asc
   * @example desc
   */
  direction?: 'asc' | 'desc';
  /**
   * @default dns
   * @example protocol
   */
  order?: 'protocol' | 'app_id' | 'created_on' | 'modified_on' | 'dns';
};

export type SpectrumApplicationsListSpectrumApplicationsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SpectrumConfigApiResponseCommonFailure;
}>;

export type SpectrumApplicationsListSpectrumApplicationsVariables = {
  pathParams: SpectrumApplicationsListSpectrumApplicationsPathParams;
  queryParams?: SpectrumApplicationsListSpectrumApplicationsQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves a list of currently existing Spectrum applications inside a zone.
 */
export const spectrumApplicationsListSpectrumApplications = (
  variables: SpectrumApplicationsListSpectrumApplicationsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SpectrumConfigAppConfigCollection,
    SpectrumApplicationsListSpectrumApplicationsError,
    undefined,
    {},
    SpectrumApplicationsListSpectrumApplicationsQueryParams,
    SpectrumApplicationsListSpectrumApplicationsPathParams
  >({ url: '/zones/{zoneId}/spectrum/apps', method: 'get', ...variables, signal });

export type SpectrumApplicationsCreateSpectrumApplicationUsingANameForTheOriginPathParams = {
  zoneId: Schemas.SpectrumConfigZoneIdentifier;
};

export type SpectrumApplicationsCreateSpectrumApplicationUsingANameForTheOriginError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SpectrumConfigApiResponseCommonFailure;
}>;

export type SpectrumApplicationsCreateSpectrumApplicationUsingANameForTheOriginVariables = {
  body?: Schemas.SpectrumConfigUpdateAppConfig;
  pathParams: SpectrumApplicationsCreateSpectrumApplicationUsingANameForTheOriginPathParams;
} & FetcherExtraProps;

/**
 * Creates a new Spectrum application from a configuration using a name for the origin.
 */
export const spectrumApplicationsCreateSpectrumApplicationUsingANameForTheOrigin = (
  variables: SpectrumApplicationsCreateSpectrumApplicationUsingANameForTheOriginVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SpectrumConfigAppConfigSingle,
    SpectrumApplicationsCreateSpectrumApplicationUsingANameForTheOriginError,
    Schemas.SpectrumConfigUpdateAppConfig,
    {},
    {},
    SpectrumApplicationsCreateSpectrumApplicationUsingANameForTheOriginPathParams
  >({ url: '/zones/{zoneId}/spectrum/apps', method: 'post', ...variables, signal });

export type SpectrumApplicationsDeleteSpectrumApplicationPathParams = {
  appId: Schemas.SpectrumConfigAppIdentifier;
  zoneId: Schemas.SpectrumConfigZoneIdentifier;
};

export type SpectrumApplicationsDeleteSpectrumApplicationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SpectrumConfigApiResponseCommonFailure;
}>;

export type SpectrumApplicationsDeleteSpectrumApplicationVariables = {
  pathParams: SpectrumApplicationsDeleteSpectrumApplicationPathParams;
} & FetcherExtraProps;

/**
 * Deletes a previously existing application.
 */
export const spectrumApplicationsDeleteSpectrumApplication = (
  variables: SpectrumApplicationsDeleteSpectrumApplicationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SpectrumConfigApiResponseSingleId,
    SpectrumApplicationsDeleteSpectrumApplicationError,
    undefined,
    {},
    {},
    SpectrumApplicationsDeleteSpectrumApplicationPathParams
  >({ url: '/zones/{zoneId}/spectrum/apps/{appId}', method: 'delete', ...variables, signal });

export type SpectrumApplicationsGetSpectrumApplicationConfigurationPathParams = {
  appId: Schemas.SpectrumConfigAppIdentifier;
  zoneId: Schemas.SpectrumConfigZoneIdentifier;
};

export type SpectrumApplicationsGetSpectrumApplicationConfigurationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.SpectrumConfigApiResponseCommonFailure;
}>;

export type SpectrumApplicationsGetSpectrumApplicationConfigurationVariables = {
  pathParams: SpectrumApplicationsGetSpectrumApplicationConfigurationPathParams;
} & FetcherExtraProps;

/**
 * Gets the application configuration of a specific application inside a zone.
 */
export const spectrumApplicationsGetSpectrumApplicationConfiguration = (
  variables: SpectrumApplicationsGetSpectrumApplicationConfigurationVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SpectrumConfigAppConfigSingle,
    SpectrumApplicationsGetSpectrumApplicationConfigurationError,
    undefined,
    {},
    {},
    SpectrumApplicationsGetSpectrumApplicationConfigurationPathParams
  >({ url: '/zones/{zoneId}/spectrum/apps/{appId}', method: 'get', ...variables, signal });

export type SpectrumApplicationsUpdateSpectrumApplicationConfigurationUsingANameForTheOriginPathParams = {
  appId: Schemas.SpectrumConfigAppIdentifier;
  zoneId: Schemas.SpectrumConfigZoneIdentifier;
};

export type SpectrumApplicationsUpdateSpectrumApplicationConfigurationUsingANameForTheOriginError =
  Fetcher.ErrorWrapper<{
    status: 400;
    payload: Schemas.SpectrumConfigApiResponseCommonFailure;
  }>;

export type SpectrumApplicationsUpdateSpectrumApplicationConfigurationUsingANameForTheOriginVariables = {
  body?: Schemas.SpectrumConfigUpdateAppConfig;
  pathParams: SpectrumApplicationsUpdateSpectrumApplicationConfigurationUsingANameForTheOriginPathParams;
} & FetcherExtraProps;

/**
 * Updates a previously existing application's configuration that uses a name for the origin.
 */
export const spectrumApplicationsUpdateSpectrumApplicationConfigurationUsingANameForTheOrigin = (
  variables: SpectrumApplicationsUpdateSpectrumApplicationConfigurationUsingANameForTheOriginVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.SpectrumConfigAppConfigSingle,
    SpectrumApplicationsUpdateSpectrumApplicationConfigurationUsingANameForTheOriginError,
    Schemas.SpectrumConfigUpdateAppConfig,
    {},
    {},
    SpectrumApplicationsUpdateSpectrumApplicationConfigurationUsingANameForTheOriginPathParams
  >({ url: '/zones/{zoneId}/spectrum/apps/{appId}', method: 'put', ...variables, signal });

export type SpeedGetAvailabilitiesPathParams = {
  zoneId: Schemas.ObservatoryIdentifier;
};

export type SpeedGetAvailabilitiesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ObservatoryApiResponseCommonFailure;
}>;

export type SpeedGetAvailabilitiesVariables = {
  pathParams: SpeedGetAvailabilitiesPathParams;
} & FetcherExtraProps;

/**
 * Retrieves quota for all plans, as well as the current zone quota.
 */
export const speedGetAvailabilities = (variables: SpeedGetAvailabilitiesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ObservatoryAvailabilitiesResponse,
    SpeedGetAvailabilitiesError,
    undefined,
    {},
    {},
    SpeedGetAvailabilitiesPathParams
  >({ url: '/zones/{zoneId}/speed_api/availabilities', method: 'get', ...variables, signal });

export type SpeedListPagesPathParams = {
  zoneId: Schemas.ObservatoryIdentifier;
};

export type SpeedListPagesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ObservatoryApiResponseCommonFailure;
}>;

export type SpeedListPagesVariables = {
  pathParams: SpeedListPagesPathParams;
} & FetcherExtraProps;

/**
 * Lists all webpages which have been tested.
 */
export const speedListPages = (variables: SpeedListPagesVariables, signal?: AbortSignal) =>
  fetch<Schemas.ObservatoryPagesResponseCollection, SpeedListPagesError, undefined, {}, {}, SpeedListPagesPathParams>({
    url: '/zones/{zoneId}/speed_api/pages',
    method: 'get',
    ...variables,
    signal
  });

export type SpeedDeleteTestsPathParams = {
  zoneId: Schemas.ObservatoryIdentifier;
  url: Schemas.ObservatoryUrl;
};

export type SpeedDeleteTestsQueryParams = {
  /**
   * A test region.
   *
   * @example us-central1
   * @default us-central1
   */
  region?: Schemas.ObservatoryRegion & void;
};

export type SpeedDeleteTestsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ObservatoryApiResponseCommonFailure;
}>;

export type SpeedDeleteTestsVariables = {
  pathParams: SpeedDeleteTestsPathParams;
  queryParams?: SpeedDeleteTestsQueryParams;
} & FetcherExtraProps;

/**
 * Deletes all tests for a specific webpage from a specific region. Deleted tests are still counted as part of the quota.
 */
export const speedDeleteTests = (variables: SpeedDeleteTestsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ObservatoryCountResponse,
    SpeedDeleteTestsError,
    undefined,
    {},
    SpeedDeleteTestsQueryParams,
    SpeedDeleteTestsPathParams
  >({ url: '/zones/{zoneId}/speed_api/pages/{url}/tests', method: 'delete', ...variables, signal });

export type SpeedListTestHistoryPathParams = {
  zoneId: Schemas.ObservatoryIdentifier;
  url: Schemas.ObservatoryUrl;
};

export type SpeedListTestHistoryQueryParams = {
  /**
   * @default 1
   */
  page?: number;
  /**
   * @default 20
   * @maximum 50
   * @minimum 5
   */
  per_page?: number;
  /**
   * A test region.
   *
   * @example us-central1
   * @default us-central1
   */
  region?: Schemas.ObservatoryRegion & void;
};

export type SpeedListTestHistoryError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ObservatoryApiResponseCommonFailure;
}>;

export type SpeedListTestHistoryVariables = {
  pathParams: SpeedListTestHistoryPathParams;
  queryParams?: SpeedListTestHistoryQueryParams;
} & FetcherExtraProps;

/**
 * Test history (list of tests) for a specific webpage.
 */
export const speedListTestHistory = (variables: SpeedListTestHistoryVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ObservatoryPageTestResponseCollection,
    SpeedListTestHistoryError,
    undefined,
    {},
    SpeedListTestHistoryQueryParams,
    SpeedListTestHistoryPathParams
  >({ url: '/zones/{zoneId}/speed_api/pages/{url}/tests', method: 'get', ...variables, signal });

export type SpeedCreateTestPathParams = {
  zoneId: Schemas.ObservatoryIdentifier;
  url: Schemas.ObservatoryUrl;
};

export type SpeedCreateTestError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ObservatoryApiResponseCommonFailure;
}>;

export type SpeedCreateTestRequestBody = {
  /**
   * A test region.
   *
   * @example us-central1
   * @default us-central1
   */
  region?: Schemas.ObservatoryRegion & void;
};

export type SpeedCreateTestVariables = {
  body?: SpeedCreateTestRequestBody;
  pathParams: SpeedCreateTestPathParams;
} & FetcherExtraProps;

/**
 * Starts a test for a specific webpage, in a specific region.
 */
export const speedCreateTest = (variables: SpeedCreateTestVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ObservatoryPageTestResponseSingle,
    SpeedCreateTestError,
    SpeedCreateTestRequestBody,
    {},
    {},
    SpeedCreateTestPathParams
  >({ url: '/zones/{zoneId}/speed_api/pages/{url}/tests', method: 'post', ...variables, signal });

export type SpeedGetTestPathParams = {
  zoneId: Schemas.ObservatoryIdentifier;
  url: Schemas.ObservatoryUrl;
  testId: string;
};

export type SpeedGetTestError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ObservatoryApiResponseCommonFailure;
}>;

export type SpeedGetTestVariables = {
  pathParams: SpeedGetTestPathParams;
} & FetcherExtraProps;

/**
 * Retrieves the result of a specific test.
 */
export const speedGetTest = (variables: SpeedGetTestVariables, signal?: AbortSignal) =>
  fetch<Schemas.ObservatoryPageTestResponseSingle, SpeedGetTestError, undefined, {}, {}, SpeedGetTestPathParams>({
    url: '/zones/{zoneId}/speed_api/pages/{url}/tests/{testId}',
    method: 'get',
    ...variables,
    signal
  });

export type SpeedListPageTrendPathParams = {
  zoneId: Schemas.ObservatoryIdentifier;
  url: Schemas.ObservatoryUrl;
};

export type SpeedListPageTrendQueryParams = {
  region: Schemas.ObservatoryRegion;
  deviceType: Schemas.ObservatoryDeviceType;
  start: Schemas.ObservatoryTimestamp;
  end?: Schemas.ObservatoryTimestamp;
  /**
   * The timezone of the start and end timestamps.
   */
  tz: string;
  /**
   * A comma-separated list of metrics to include in the results.
   *
   * @example performanceScore,ttfb,fcp,si,lcp,tti,tbt,cls
   */
  metrics: string;
};

export type SpeedListPageTrendError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ObservatoryApiResponseCommonFailure;
}>;

export type SpeedListPageTrendVariables = {
  pathParams: SpeedListPageTrendPathParams;
  queryParams: SpeedListPageTrendQueryParams;
} & FetcherExtraProps;

/**
 * Lists the core web vital metrics trend over time for a specific page.
 */
export const speedListPageTrend = (variables: SpeedListPageTrendVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ObservatoryTrendResponse,
    SpeedListPageTrendError,
    undefined,
    {},
    SpeedListPageTrendQueryParams,
    SpeedListPageTrendPathParams
  >({ url: '/zones/{zoneId}/speed_api/pages/{url}/trend', method: 'get', ...variables, signal });

export type SpeedDeleteTestSchedulePathParams = {
  zoneId: Schemas.ObservatoryIdentifier;
  url: Schemas.ObservatoryUrl;
};

export type SpeedDeleteTestScheduleQueryParams = {
  /**
   * A test region.
   *
   * @example us-central1
   * @default us-central1
   */
  region?: Schemas.ObservatoryRegion & void;
};

export type SpeedDeleteTestScheduleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ObservatoryApiResponseCommonFailure;
}>;

export type SpeedDeleteTestScheduleVariables = {
  pathParams: SpeedDeleteTestSchedulePathParams;
  queryParams?: SpeedDeleteTestScheduleQueryParams;
} & FetcherExtraProps;

/**
 * Deletes a scheduled test for a page.
 */
export const speedDeleteTestSchedule = (variables: SpeedDeleteTestScheduleVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ObservatoryCountResponse,
    SpeedDeleteTestScheduleError,
    undefined,
    {},
    SpeedDeleteTestScheduleQueryParams,
    SpeedDeleteTestSchedulePathParams
  >({ url: '/zones/{zoneId}/speed_api/schedule/{url}', method: 'delete', ...variables, signal });

export type SpeedGetScheduledTestPathParams = {
  zoneId: Schemas.ObservatoryIdentifier;
  url: Schemas.ObservatoryUrl;
};

export type SpeedGetScheduledTestQueryParams = {
  /**
   * A test region.
   *
   * @example us-central1
   * @default us-central1
   */
  region?: Schemas.ObservatoryRegion & void;
};

export type SpeedGetScheduledTestError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ObservatoryApiResponseCommonFailure;
}>;

export type SpeedGetScheduledTestVariables = {
  pathParams: SpeedGetScheduledTestPathParams;
  queryParams?: SpeedGetScheduledTestQueryParams;
} & FetcherExtraProps;

/**
 * Retrieves the test schedule for a page in a specific region.
 */
export const speedGetScheduledTest = (variables: SpeedGetScheduledTestVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ObservatoryScheduleResponseSingle,
    SpeedGetScheduledTestError,
    undefined,
    {},
    SpeedGetScheduledTestQueryParams,
    SpeedGetScheduledTestPathParams
  >({ url: '/zones/{zoneId}/speed_api/schedule/{url}', method: 'get', ...variables, signal });

export type SpeedCreateScheduledTestPathParams = {
  zoneId: Schemas.ObservatoryIdentifier;
  url: Schemas.ObservatoryUrl;
};

export type SpeedCreateScheduledTestQueryParams = {
  /**
   * A test region.
   *
   * @example us-central1
   * @default us-central1
   */
  region?: Schemas.ObservatoryRegion & void;
};

export type SpeedCreateScheduledTestError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.ObservatoryApiResponseCommonFailure;
}>;

export type SpeedCreateScheduledTestVariables = {
  pathParams: SpeedCreateScheduledTestPathParams;
  queryParams?: SpeedCreateScheduledTestQueryParams;
} & FetcherExtraProps;

/**
 * Creates a scheduled test for a page.
 */
export const speedCreateScheduledTest = (variables: SpeedCreateScheduledTestVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.ObservatoryCreateScheduleResponse,
    SpeedCreateScheduledTestError,
    undefined,
    {},
    SpeedCreateScheduledTestQueryParams,
    SpeedCreateScheduledTestPathParams
  >({ url: '/zones/{zoneId}/speed_api/schedule/{url}', method: 'post', ...variables, signal });

export type AnalyzeCertificateAnalyzeCertificatePathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type AnalyzeCertificateAnalyzeCertificateError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesCertificateAnalyzeResponse &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type AnalyzeCertificateAnalyzeCertificateRequestBody = {
  bundle_method?: Schemas.TlsCertificatesAndHostnamesBundleMethod;
  certificate?: Schemas.TlsCertificatesAndHostnamesCertificate;
};

export type AnalyzeCertificateAnalyzeCertificateVariables = {
  body?: AnalyzeCertificateAnalyzeCertificateRequestBody;
  pathParams: AnalyzeCertificateAnalyzeCertificatePathParams;
} & FetcherExtraProps;

/**
 * Returns the set of hostnames, the signature algorithm, and the expiration date of the certificate.
 */
export const analyzeCertificateAnalyzeCertificate = (
  variables: AnalyzeCertificateAnalyzeCertificateVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesCertificateAnalyzeResponse,
    AnalyzeCertificateAnalyzeCertificateError,
    AnalyzeCertificateAnalyzeCertificateRequestBody,
    {},
    {},
    AnalyzeCertificateAnalyzeCertificatePathParams
  >({ url: '/zones/{zoneId}/ssl/analyze', method: 'post', ...variables, signal });

export type CertificatePacksListCertificatePacksPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CertificatePacksListCertificatePacksQueryParams = {
  /**
   * @example all
   */
  status?: 'all';
};

export type CertificatePacksListCertificatePacksError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesCertificatePackResponseCollection &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CertificatePacksListCertificatePacksVariables = {
  pathParams: CertificatePacksListCertificatePacksPathParams;
  queryParams?: CertificatePacksListCertificatePacksQueryParams;
} & FetcherExtraProps;

/**
 * For a given zone, list all active certificate packs.
 */
export const certificatePacksListCertificatePacks = (
  variables: CertificatePacksListCertificatePacksVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesCertificatePackResponseCollection,
    CertificatePacksListCertificatePacksError,
    undefined,
    {},
    CertificatePacksListCertificatePacksQueryParams,
    CertificatePacksListCertificatePacksPathParams
  >({ url: '/zones/{zoneId}/ssl/certificate_packs', method: 'get', ...variables, signal });

export type CertificatePacksOrderAdvancedCertificateManagerCertificatePackPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CertificatePacksOrderAdvancedCertificateManagerCertificatePackError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesAdvancedCertificatePackResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CertificatePacksOrderAdvancedCertificateManagerCertificatePackRequestBody = {
  certificate_authority: Schemas.TlsCertificatesAndHostnamesSchemasCertificateAuthority;
  cloudflare_branding?: Schemas.TlsCertificatesAndHostnamesCloudflareBranding;
  hosts: Schemas.TlsCertificatesAndHostnamesSchemasHosts;
  type: Schemas.TlsCertificatesAndHostnamesAdvancedType;
  validation_method: Schemas.TlsCertificatesAndHostnamesValidationMethod;
  validity_days: Schemas.TlsCertificatesAndHostnamesValidityDays;
};

export type CertificatePacksOrderAdvancedCertificateManagerCertificatePackVariables = {
  body: CertificatePacksOrderAdvancedCertificateManagerCertificatePackRequestBody;
  pathParams: CertificatePacksOrderAdvancedCertificateManagerCertificatePackPathParams;
} & FetcherExtraProps;

/**
 * For a given zone, order an advanced certificate pack.
 */
export const certificatePacksOrderAdvancedCertificateManagerCertificatePack = (
  variables: CertificatePacksOrderAdvancedCertificateManagerCertificatePackVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesAdvancedCertificatePackResponseSingle,
    CertificatePacksOrderAdvancedCertificateManagerCertificatePackError,
    CertificatePacksOrderAdvancedCertificateManagerCertificatePackRequestBody,
    {},
    {},
    CertificatePacksOrderAdvancedCertificateManagerCertificatePackPathParams
  >({ url: '/zones/{zoneId}/ssl/certificate_packs/order', method: 'post', ...variables, signal });

export type CertificatePacksGetCertificatePackQuotasPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CertificatePacksGetCertificatePackQuotasError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesCertificatePackQuotaResponse &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CertificatePacksGetCertificatePackQuotasVariables = {
  pathParams: CertificatePacksGetCertificatePackQuotasPathParams;
} & FetcherExtraProps;

/**
 * For a given zone, list certificate pack quotas.
 */
export const certificatePacksGetCertificatePackQuotas = (
  variables: CertificatePacksGetCertificatePackQuotasVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesCertificatePackQuotaResponse,
    CertificatePacksGetCertificatePackQuotasError,
    undefined,
    {},
    {},
    CertificatePacksGetCertificatePackQuotasPathParams
  >({ url: '/zones/{zoneId}/ssl/certificate_packs/quota', method: 'get', ...variables, signal });

export type CertificatePacksDeleteAdvancedCertificateManagerCertificatePackPathParams = {
  certificatePackId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CertificatePacksDeleteAdvancedCertificateManagerCertificatePackError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesDeleteAdvancedCertificatePackResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CertificatePacksDeleteAdvancedCertificateManagerCertificatePackVariables = {
  pathParams: CertificatePacksDeleteAdvancedCertificateManagerCertificatePackPathParams;
} & FetcherExtraProps;

/**
 * For a given zone, delete an advanced certificate pack.
 */
export const certificatePacksDeleteAdvancedCertificateManagerCertificatePack = (
  variables: CertificatePacksDeleteAdvancedCertificateManagerCertificatePackVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesDeleteAdvancedCertificatePackResponseSingle,
    CertificatePacksDeleteAdvancedCertificateManagerCertificatePackError,
    undefined,
    {},
    {},
    CertificatePacksDeleteAdvancedCertificateManagerCertificatePackPathParams
  >({ url: '/zones/{zoneId}/ssl/certificate_packs/{certificatePackId}', method: 'delete', ...variables, signal });

export type CertificatePacksGetCertificatePackPathParams = {
  certificatePackId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CertificatePacksGetCertificatePackError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesCertificatePackResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CertificatePacksGetCertificatePackVariables = {
  pathParams: CertificatePacksGetCertificatePackPathParams;
} & FetcherExtraProps;

/**
 * For a given zone, get a certificate pack.
 */
export const certificatePacksGetCertificatePack = (
  variables: CertificatePacksGetCertificatePackVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesCertificatePackResponseSingle,
    CertificatePacksGetCertificatePackError,
    undefined,
    {},
    {},
    CertificatePacksGetCertificatePackPathParams
  >({ url: '/zones/{zoneId}/ssl/certificate_packs/{certificatePackId}', method: 'get', ...variables, signal });

export type CertificatePacksRestartValidationForAdvancedCertificateManagerCertificatePackPathParams = {
  certificatePackId: Schemas.TlsCertificatesAndHostnamesIdentifier;
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type CertificatePacksRestartValidationForAdvancedCertificateManagerCertificatePackError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesAdvancedCertificatePackResponseSingle &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type CertificatePacksRestartValidationForAdvancedCertificateManagerCertificatePackRequestBody = {
  cloudflare_branding?: Schemas.TlsCertificatesAndHostnamesCloudflareBranding;
};

export type CertificatePacksRestartValidationForAdvancedCertificateManagerCertificatePackVariables = {
  body?: CertificatePacksRestartValidationForAdvancedCertificateManagerCertificatePackRequestBody;
  pathParams: CertificatePacksRestartValidationForAdvancedCertificateManagerCertificatePackPathParams;
} & FetcherExtraProps;

/**
 * For a given zone, restart validation or add cloudflare branding for an advanced certificate pack.  The former is only a validation operation for a Certificate Pack in a validation_timed_out status.
 */
export const certificatePacksRestartValidationForAdvancedCertificateManagerCertificatePack = (
  variables: CertificatePacksRestartValidationForAdvancedCertificateManagerCertificatePackVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesAdvancedCertificatePackResponseSingle,
    CertificatePacksRestartValidationForAdvancedCertificateManagerCertificatePackError,
    CertificatePacksRestartValidationForAdvancedCertificateManagerCertificatePackRequestBody,
    {},
    {},
    CertificatePacksRestartValidationForAdvancedCertificateManagerCertificatePackPathParams
  >({ url: '/zones/{zoneId}/ssl/certificate_packs/{certificatePackId}', method: 'patch', ...variables, signal });

export type UniversalSslSettingsForAZoneUniversalSslSettingsDetailsPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type UniversalSslSettingsForAZoneUniversalSslSettingsDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesSslUniversalSettingsResponse &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type UniversalSslSettingsForAZoneUniversalSslSettingsDetailsVariables = {
  pathParams: UniversalSslSettingsForAZoneUniversalSslSettingsDetailsPathParams;
} & FetcherExtraProps;

/**
 * Get Universal SSL Settings for a Zone.
 */
export const universalSslSettingsForAZoneUniversalSslSettingsDetails = (
  variables: UniversalSslSettingsForAZoneUniversalSslSettingsDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesSslUniversalSettingsResponse,
    UniversalSslSettingsForAZoneUniversalSslSettingsDetailsError,
    undefined,
    {},
    {},
    UniversalSslSettingsForAZoneUniversalSslSettingsDetailsPathParams
  >({ url: '/zones/{zoneId}/ssl/universal/settings', method: 'get', ...variables, signal });

export type UniversalSslSettingsForAZoneEditUniversalSslSettingsPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type UniversalSslSettingsForAZoneEditUniversalSslSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesSslUniversalSettingsResponse &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type UniversalSslSettingsForAZoneEditUniversalSslSettingsVariables = {
  body?: Schemas.TlsCertificatesAndHostnamesUniversal;
  pathParams: UniversalSslSettingsForAZoneEditUniversalSslSettingsPathParams;
} & FetcherExtraProps;

/**
 * Patch Universal SSL Settings for a Zone.
 */
export const universalSslSettingsForAZoneEditUniversalSslSettings = (
  variables: UniversalSslSettingsForAZoneEditUniversalSslSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesSslUniversalSettingsResponse,
    UniversalSslSettingsForAZoneEditUniversalSslSettingsError,
    Schemas.TlsCertificatesAndHostnamesUniversal,
    {},
    {},
    UniversalSslSettingsForAZoneEditUniversalSslSettingsPathParams
  >({ url: '/zones/{zoneId}/ssl/universal/settings', method: 'patch', ...variables, signal });

export type SslVerificationSslVerificationDetailsPathParams = {
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type SslVerificationSslVerificationDetailsQueryParams = {
  /**
   * @example true
   */
  retry?: true;
};

export type SslVerificationSslVerificationDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesSslVerificationResponseCollection &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type SslVerificationSslVerificationDetailsVariables = {
  pathParams: SslVerificationSslVerificationDetailsPathParams;
  queryParams?: SslVerificationSslVerificationDetailsQueryParams;
} & FetcherExtraProps;

/**
 * Get SSL Verification Info for a Zone.
 */
export const sslVerificationSslVerificationDetails = (
  variables: SslVerificationSslVerificationDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesSslVerificationResponseCollection,
    SslVerificationSslVerificationDetailsError,
    undefined,
    {},
    SslVerificationSslVerificationDetailsQueryParams,
    SslVerificationSslVerificationDetailsPathParams
  >({ url: '/zones/{zoneId}/ssl/verification', method: 'get', ...variables, signal });

export type SslVerificationEditSslCertificatePackValidationMethodPathParams = {
  certificatePackId: Schemas.TlsCertificatesAndHostnamesCertPackUuid;
  zoneId: Schemas.TlsCertificatesAndHostnamesIdentifier;
};

export type SslVerificationEditSslCertificatePackValidationMethodError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.TlsCertificatesAndHostnamesSslValidationMethodResponseCollection &
    Schemas.TlsCertificatesAndHostnamesApiResponseCommonFailure;
}>;

export type SslVerificationEditSslCertificatePackValidationMethodVariables = {
  body: Schemas.TlsCertificatesAndHostnamesComponentsSchemasValidationMethod;
  pathParams: SslVerificationEditSslCertificatePackValidationMethodPathParams;
} & FetcherExtraProps;

/**
 * Edit SSL validation method for a certificate pack. A PATCH request will request an immediate validation check on any certificate, and return the updated status. If a validation method is provided, the validation will be immediately attempted using that method.
 */
export const sslVerificationEditSslCertificatePackValidationMethod = (
  variables: SslVerificationEditSslCertificatePackValidationMethodVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.TlsCertificatesAndHostnamesSslValidationMethodResponseCollection,
    SslVerificationEditSslCertificatePackValidationMethodError,
    Schemas.TlsCertificatesAndHostnamesComponentsSchemasValidationMethod,
    {},
    {},
    SslVerificationEditSslCertificatePackValidationMethodPathParams
  >({ url: '/zones/{zoneId}/ssl/verification/{certificatePackId}', method: 'patch', ...variables, signal });

export type DeleteUrlNormalizationPathParams = {
  zoneId: Schemas.RulesetsZoneId;
};

export type DeleteUrlNormalizationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type DeleteUrlNormalizationVariables = {
  pathParams: DeleteUrlNormalizationPathParams;
} & FetcherExtraProps;

/**
 * Deletes the URL Normalization settings.
 */
export const deleteUrlNormalization = (variables: DeleteUrlNormalizationVariables, signal?: AbortSignal) =>
  fetch<Responses.RulesetsEmpty, DeleteUrlNormalizationError, undefined, {}, {}, DeleteUrlNormalizationPathParams>({
    url: '/zones/{zoneId}/url_normalization',
    method: 'delete',
    ...variables,
    signal
  });

export type GetUrlNormalizationPathParams = {
  zoneId: Schemas.RulesetsZoneId;
};

export type GetUrlNormalizationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type GetUrlNormalizationVariables = {
  pathParams: GetUrlNormalizationPathParams;
} & FetcherExtraProps;

/**
 * Fetches the current URL Normalization settings.
 */
export const getUrlNormalization = (variables: GetUrlNormalizationVariables, signal?: AbortSignal) =>
  fetch<Responses.RulesetsUrlNormalization, GetUrlNormalizationError, undefined, {}, {}, GetUrlNormalizationPathParams>(
    { url: '/zones/{zoneId}/url_normalization', method: 'get', ...variables, signal }
  );

export type UpdateUrlNormalizationPathParams = {
  zoneId: Schemas.RulesetsZoneId;
};

export type UpdateUrlNormalizationError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Responses.RulesetsFailure;
}>;

export type UpdateUrlNormalizationVariables = {
  body: RequestBodies.RulesetsUrlNormalization;
  pathParams: UpdateUrlNormalizationPathParams;
} & FetcherExtraProps;

/**
 * Updates the URL Normalization settings.
 */
export const updateUrlNormalization = (variables: UpdateUrlNormalizationVariables, signal?: AbortSignal) =>
  fetch<
    Responses.RulesetsUrlNormalization,
    UpdateUrlNormalizationError,
    RequestBodies.RulesetsUrlNormalization,
    {},
    {},
    UpdateUrlNormalizationPathParams
  >({ url: '/zones/{zoneId}/url_normalization', method: 'put', ...variables, signal });

export type WaitingRoomListWaitingRoomsPathParams = {
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomListWaitingRoomsQueryParams = {
  /**
   * Page number of paginated results.
   *
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * Maximum number of results per page. Must be a multiple of 5.
   *
   * @default 25
   * @maximum 1000
   * @minimum 5
   */
  per_page?: number;
};

export type WaitingRoomListWaitingRoomsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomResponseCollection & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomListWaitingRoomsVariables = {
  pathParams: WaitingRoomListWaitingRoomsPathParams;
  queryParams?: WaitingRoomListWaitingRoomsQueryParams;
} & FetcherExtraProps;

/**
 * Lists waiting rooms.
 */
export const waitingRoomListWaitingRooms = (variables: WaitingRoomListWaitingRoomsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WaitingroomResponseCollection,
    WaitingRoomListWaitingRoomsError,
    undefined,
    {},
    WaitingRoomListWaitingRoomsQueryParams,
    WaitingRoomListWaitingRoomsPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms', method: 'get', ...variables, signal });

export type WaitingRoomCreateWaitingRoomPathParams = {
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomCreateWaitingRoomError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomSingleResponse & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomCreateWaitingRoomVariables = {
  body: Schemas.WaitingroomQueryWaitingroom;
  pathParams: WaitingRoomCreateWaitingRoomPathParams;
} & FetcherExtraProps;

/**
 * Creates a new waiting room.
 */
export const waitingRoomCreateWaitingRoom = (variables: WaitingRoomCreateWaitingRoomVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WaitingroomSingleResponse,
    WaitingRoomCreateWaitingRoomError,
    Schemas.WaitingroomQueryWaitingroom,
    {},
    {},
    WaitingRoomCreateWaitingRoomPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms', method: 'post', ...variables, signal });

export type WaitingRoomCreateACustomWaitingRoomPagePreviewPathParams = {
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomCreateACustomWaitingRoomPagePreviewError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomPreviewResponse & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomCreateACustomWaitingRoomPagePreviewVariables = {
  body: Schemas.WaitingroomQueryPreview;
  pathParams: WaitingRoomCreateACustomWaitingRoomPagePreviewPathParams;
} & FetcherExtraProps;

/**
 * Creates a waiting room page preview. Upload a custom waiting room page for preview. You will receive a preview URL in the form `http://waitingrooms.dev/preview/<uuid>`. You can use the following query parameters to change the state of the preview:
 * 1. `force_queue`: Boolean indicating if all users will be queued in the waiting room and no one will be let into the origin website (also known as queueAll).
 * 2. `queue_is_full`: Boolean indicating if the waiting room's queue is currently full and not accepting new users at the moment.
 * 3. `queueing_method`: The queueing method currently used by the waiting room.
 * 	- **fifo** indicates a FIFO queue.
 * 	- **random** indicates a Random queue.
 * 	- **passthrough** indicates a Passthrough queue. Keep in mind that the waiting room page will only be displayed if `force_queue=true` or `event=prequeueing` — for other cases the request will pass through to the origin. For our preview, this will be a fake origin website returning "Welcome".
 * 	- **reject** indicates a Reject queue.
 * 4. `event`: Used to preview a waiting room event.
 * 	- **none** indicates no event is occurring.
 * 	- **prequeueing** indicates that an event is prequeueing (between `prequeue_start_time` and `event_start_time`).
 * 	- **started** indicates that an event has started (between `event_start_time` and `event_end_time`).
 * 5. `shuffle_at_event_start`: Boolean indicating if the event will shuffle users in the prequeue when it starts. This can only be set to **true** if an event is active (`event` is not **none**).
 *
 * For example, you can make a request to `http://waitingrooms.dev/preview/<uuid>?force_queue=false&queue_is_full=false&queueing_method=random&event=started&shuffle_at_event_start=true`
 * 6. `waitTime`: Non-zero, positive integer indicating the estimated wait time in minutes. The default value is 10 minutes.
 *
 * For example, you can make a request to `http://waitingrooms.dev/preview/<uuid>?waitTime=50` to configure the estimated wait time as 50 minutes.
 */
export const waitingRoomCreateACustomWaitingRoomPagePreview = (
  variables: WaitingRoomCreateACustomWaitingRoomPagePreviewVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WaitingroomPreviewResponse,
    WaitingRoomCreateACustomWaitingRoomPagePreviewError,
    Schemas.WaitingroomQueryPreview,
    {},
    {},
    WaitingRoomCreateACustomWaitingRoomPagePreviewPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/preview', method: 'post', ...variables, signal });

export type WaitingRoomGetZoneSettingsPathParams = {
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomGetZoneSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomZoneSettingsResponse & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomGetZoneSettingsVariables = {
  pathParams: WaitingRoomGetZoneSettingsPathParams;
} & FetcherExtraProps;

export const waitingRoomGetZoneSettings = (variables: WaitingRoomGetZoneSettingsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WaitingroomZoneSettingsResponse,
    WaitingRoomGetZoneSettingsError,
    undefined,
    {},
    {},
    WaitingRoomGetZoneSettingsPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/settings', method: 'get', ...variables, signal });

export type WaitingRoomPatchZoneSettingsPathParams = {
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomPatchZoneSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomZoneSettingsResponse & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomPatchZoneSettingsVariables = {
  body?: Schemas.WaitingroomZoneSettings;
  pathParams: WaitingRoomPatchZoneSettingsPathParams;
} & FetcherExtraProps;

export const waitingRoomPatchZoneSettings = (variables: WaitingRoomPatchZoneSettingsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WaitingroomZoneSettingsResponse,
    WaitingRoomPatchZoneSettingsError,
    Schemas.WaitingroomZoneSettings,
    {},
    {},
    WaitingRoomPatchZoneSettingsPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/settings', method: 'patch', ...variables, signal });

export type WaitingRoomUpdateZoneSettingsPathParams = {
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomUpdateZoneSettingsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomZoneSettingsResponse & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomUpdateZoneSettingsVariables = {
  body?: Schemas.WaitingroomZoneSettings;
  pathParams: WaitingRoomUpdateZoneSettingsPathParams;
} & FetcherExtraProps;

export const waitingRoomUpdateZoneSettings = (
  variables: WaitingRoomUpdateZoneSettingsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WaitingroomZoneSettingsResponse,
    WaitingRoomUpdateZoneSettingsError,
    Schemas.WaitingroomZoneSettings,
    {},
    {},
    WaitingRoomUpdateZoneSettingsPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/settings', method: 'put', ...variables, signal });

export type WaitingRoomDeleteWaitingRoomPathParams = {
  waitingRoomId: Schemas.WaitingroomWaitingRoomId;
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomDeleteWaitingRoomError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomWaitingRoomIdResponse & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomDeleteWaitingRoomVariables = {
  pathParams: WaitingRoomDeleteWaitingRoomPathParams;
} & FetcherExtraProps;

/**
 * Deletes a waiting room.
 */
export const waitingRoomDeleteWaitingRoom = (variables: WaitingRoomDeleteWaitingRoomVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WaitingroomWaitingRoomIdResponse,
    WaitingRoomDeleteWaitingRoomError,
    undefined,
    {},
    {},
    WaitingRoomDeleteWaitingRoomPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/{waitingRoomId}', method: 'delete', ...variables, signal });

export type WaitingRoomWaitingRoomDetailsPathParams = {
  waitingRoomId: Schemas.WaitingroomWaitingRoomId;
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomWaitingRoomDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomSingleResponse & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomWaitingRoomDetailsVariables = {
  pathParams: WaitingRoomWaitingRoomDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetches a single configured waiting room.
 */
export const waitingRoomWaitingRoomDetails = (
  variables: WaitingRoomWaitingRoomDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WaitingroomSingleResponse,
    WaitingRoomWaitingRoomDetailsError,
    undefined,
    {},
    {},
    WaitingRoomWaitingRoomDetailsPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/{waitingRoomId}', method: 'get', ...variables, signal });

export type WaitingRoomPatchWaitingRoomPathParams = {
  waitingRoomId: Schemas.WaitingroomWaitingRoomId;
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomPatchWaitingRoomError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomSingleResponse & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomPatchWaitingRoomVariables = {
  body: Schemas.WaitingroomQueryWaitingroom;
  pathParams: WaitingRoomPatchWaitingRoomPathParams;
} & FetcherExtraProps;

/**
 * Patches a configured waiting room.
 */
export const waitingRoomPatchWaitingRoom = (variables: WaitingRoomPatchWaitingRoomVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WaitingroomSingleResponse,
    WaitingRoomPatchWaitingRoomError,
    Schemas.WaitingroomQueryWaitingroom,
    {},
    {},
    WaitingRoomPatchWaitingRoomPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/{waitingRoomId}', method: 'patch', ...variables, signal });

export type WaitingRoomUpdateWaitingRoomPathParams = {
  waitingRoomId: Schemas.WaitingroomWaitingRoomId;
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomUpdateWaitingRoomError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomSingleResponse & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomUpdateWaitingRoomVariables = {
  body: Schemas.WaitingroomQueryWaitingroom;
  pathParams: WaitingRoomUpdateWaitingRoomPathParams;
} & FetcherExtraProps;

/**
 * Updates a configured waiting room.
 */
export const waitingRoomUpdateWaitingRoom = (variables: WaitingRoomUpdateWaitingRoomVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WaitingroomSingleResponse,
    WaitingRoomUpdateWaitingRoomError,
    Schemas.WaitingroomQueryWaitingroom,
    {},
    {},
    WaitingRoomUpdateWaitingRoomPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/{waitingRoomId}', method: 'put', ...variables, signal });

export type WaitingRoomListEventsPathParams = {
  waitingRoomId: Schemas.WaitingroomWaitingRoomId;
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomListEventsQueryParams = {
  /**
   * Page number of paginated results.
   *
   * @default 1
   * @minimum 1
   */
  page?: number;
  /**
   * Maximum number of results per page. Must be a multiple of 5.
   *
   * @default 25
   * @maximum 1000
   * @minimum 5
   */
  per_page?: number;
};

export type WaitingRoomListEventsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomEventResponseCollection & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomListEventsVariables = {
  pathParams: WaitingRoomListEventsPathParams;
  queryParams?: WaitingRoomListEventsQueryParams;
} & FetcherExtraProps;

/**
 * Lists events for a waiting room.
 */
export const waitingRoomListEvents = (variables: WaitingRoomListEventsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WaitingroomEventResponseCollection,
    WaitingRoomListEventsError,
    undefined,
    {},
    WaitingRoomListEventsQueryParams,
    WaitingRoomListEventsPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/{waitingRoomId}/events', method: 'get', ...variables, signal });

export type WaitingRoomCreateEventPathParams = {
  waitingRoomId: Schemas.WaitingroomWaitingRoomId;
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomCreateEventError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomEventResponse & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomCreateEventVariables = {
  body: Schemas.WaitingroomQueryEvent;
  pathParams: WaitingRoomCreateEventPathParams;
} & FetcherExtraProps;

/**
 * Only available for the Waiting Room Advanced subscription. Creates an event for a waiting room. An event takes place during a specified period of time, temporarily changing the behavior of a waiting room. While the event is active, some of the properties in the event's configuration may either override or inherit from the waiting room's configuration. Note that events cannot overlap with each other, so only one event can be active at a time.
 */
export const waitingRoomCreateEvent = (variables: WaitingRoomCreateEventVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WaitingroomEventResponse,
    WaitingRoomCreateEventError,
    Schemas.WaitingroomQueryEvent,
    {},
    {},
    WaitingRoomCreateEventPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/{waitingRoomId}/events', method: 'post', ...variables, signal });

export type WaitingRoomDeleteEventPathParams = {
  eventId: Schemas.WaitingroomEventId;
  waitingRoomId: Schemas.WaitingroomWaitingRoomId;
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomDeleteEventError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomEventIdResponse & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomDeleteEventVariables = {
  pathParams: WaitingRoomDeleteEventPathParams;
} & FetcherExtraProps;

/**
 * Deletes an event for a waiting room.
 */
export const waitingRoomDeleteEvent = (variables: WaitingRoomDeleteEventVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WaitingroomEventIdResponse,
    WaitingRoomDeleteEventError,
    undefined,
    {},
    {},
    WaitingRoomDeleteEventPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/{waitingRoomId}/events/{eventId}', method: 'delete', ...variables, signal });

export type WaitingRoomEventDetailsPathParams = {
  eventId: Schemas.WaitingroomEventId;
  waitingRoomId: Schemas.WaitingroomWaitingRoomId;
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomEventDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomEventResponse & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomEventDetailsVariables = {
  pathParams: WaitingRoomEventDetailsPathParams;
} & FetcherExtraProps;

/**
 * Fetches a single configured event for a waiting room.
 */
export const waitingRoomEventDetails = (variables: WaitingRoomEventDetailsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WaitingroomEventResponse,
    WaitingRoomEventDetailsError,
    undefined,
    {},
    {},
    WaitingRoomEventDetailsPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/{waitingRoomId}/events/{eventId}', method: 'get', ...variables, signal });

export type WaitingRoomPatchEventPathParams = {
  eventId: Schemas.WaitingroomEventId;
  waitingRoomId: Schemas.WaitingroomWaitingRoomId;
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomPatchEventError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomEventResponse & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomPatchEventVariables = {
  body: Schemas.WaitingroomQueryEvent;
  pathParams: WaitingRoomPatchEventPathParams;
} & FetcherExtraProps;

/**
 * Patches a configured event for a waiting room.
 */
export const waitingRoomPatchEvent = (variables: WaitingRoomPatchEventVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WaitingroomEventResponse,
    WaitingRoomPatchEventError,
    Schemas.WaitingroomQueryEvent,
    {},
    {},
    WaitingRoomPatchEventPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/{waitingRoomId}/events/{eventId}', method: 'patch', ...variables, signal });

export type WaitingRoomUpdateEventPathParams = {
  eventId: Schemas.WaitingroomEventId;
  waitingRoomId: Schemas.WaitingroomWaitingRoomId;
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomUpdateEventError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomEventResponse & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomUpdateEventVariables = {
  body: Schemas.WaitingroomQueryEvent;
  pathParams: WaitingRoomUpdateEventPathParams;
} & FetcherExtraProps;

/**
 * Updates a configured event for a waiting room.
 */
export const waitingRoomUpdateEvent = (variables: WaitingRoomUpdateEventVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WaitingroomEventResponse,
    WaitingRoomUpdateEventError,
    Schemas.WaitingroomQueryEvent,
    {},
    {},
    WaitingRoomUpdateEventPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/{waitingRoomId}/events/{eventId}', method: 'put', ...variables, signal });

export type WaitingRoomPreviewActiveEventDetailsPathParams = {
  eventId: Schemas.WaitingroomEventId;
  waitingRoomId: Schemas.WaitingroomWaitingRoomId;
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomPreviewActiveEventDetailsError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomEventDetailsResponse & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomPreviewActiveEventDetailsVariables = {
  pathParams: WaitingRoomPreviewActiveEventDetailsPathParams;
} & FetcherExtraProps;

/**
 * Previews an event's configuration as if it was active. Inherited fields from the waiting room will be displayed with their current values.
 */
export const waitingRoomPreviewActiveEventDetails = (
  variables: WaitingRoomPreviewActiveEventDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WaitingroomEventDetailsResponse,
    WaitingRoomPreviewActiveEventDetailsError,
    undefined,
    {},
    {},
    WaitingRoomPreviewActiveEventDetailsPathParams
  >({
    url: '/zones/{zoneId}/waiting_rooms/{waitingRoomId}/events/{eventId}/details',
    method: 'get',
    ...variables,
    signal
  });

export type WaitingRoomListWaitingRoomRulesPathParams = {
  waitingRoomId: Schemas.WaitingroomWaitingRoomId;
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomListWaitingRoomRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomRulesResponseCollection & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomListWaitingRoomRulesVariables = {
  pathParams: WaitingRoomListWaitingRoomRulesPathParams;
} & FetcherExtraProps;

/**
 * Lists rules for a waiting room.
 */
export const waitingRoomListWaitingRoomRules = (
  variables: WaitingRoomListWaitingRoomRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WaitingroomRulesResponseCollection,
    WaitingRoomListWaitingRoomRulesError,
    undefined,
    {},
    {},
    WaitingRoomListWaitingRoomRulesPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/{waitingRoomId}/rules', method: 'get', ...variables, signal });

export type WaitingRoomCreateWaitingRoomRulePathParams = {
  waitingRoomId: Schemas.WaitingroomWaitingRoomId;
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomCreateWaitingRoomRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomRulesResponseCollection & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomCreateWaitingRoomRuleVariables = {
  body: Schemas.WaitingroomCreateRule;
  pathParams: WaitingRoomCreateWaitingRoomRulePathParams;
} & FetcherExtraProps;

/**
 * Only available for the Waiting Room Advanced subscription. Creates a rule for a waiting room.
 */
export const waitingRoomCreateWaitingRoomRule = (
  variables: WaitingRoomCreateWaitingRoomRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WaitingroomRulesResponseCollection,
    WaitingRoomCreateWaitingRoomRuleError,
    Schemas.WaitingroomCreateRule,
    {},
    {},
    WaitingRoomCreateWaitingRoomRulePathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/{waitingRoomId}/rules', method: 'post', ...variables, signal });

export type WaitingRoomReplaceWaitingRoomRulesPathParams = {
  waitingRoomId: Schemas.WaitingroomWaitingRoomId;
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomReplaceWaitingRoomRulesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomRulesResponseCollection & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomReplaceWaitingRoomRulesVariables = {
  body?: Schemas.WaitingroomUpdateRules;
  pathParams: WaitingRoomReplaceWaitingRoomRulesPathParams;
} & FetcherExtraProps;

/**
 * Only available for the Waiting Room Advanced subscription. Replaces all rules for a waiting room.
 */
export const waitingRoomReplaceWaitingRoomRules = (
  variables: WaitingRoomReplaceWaitingRoomRulesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WaitingroomRulesResponseCollection,
    WaitingRoomReplaceWaitingRoomRulesError,
    Schemas.WaitingroomUpdateRules,
    {},
    {},
    WaitingRoomReplaceWaitingRoomRulesPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/{waitingRoomId}/rules', method: 'put', ...variables, signal });

export type WaitingRoomDeleteWaitingRoomRulePathParams = {
  ruleId: Schemas.WaitingroomRuleId;
  waitingRoomId: Schemas.WaitingroomWaitingRoomId;
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomDeleteWaitingRoomRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomRulesResponseCollection & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomDeleteWaitingRoomRuleVariables = {
  pathParams: WaitingRoomDeleteWaitingRoomRulePathParams;
} & FetcherExtraProps;

/**
 * Deletes a rule for a waiting room.
 */
export const waitingRoomDeleteWaitingRoomRule = (
  variables: WaitingRoomDeleteWaitingRoomRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WaitingroomRulesResponseCollection,
    WaitingRoomDeleteWaitingRoomRuleError,
    undefined,
    {},
    {},
    WaitingRoomDeleteWaitingRoomRulePathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/{waitingRoomId}/rules/{ruleId}', method: 'delete', ...variables, signal });

export type WaitingRoomPatchWaitingRoomRulePathParams = {
  ruleId: Schemas.WaitingroomRuleId;
  waitingRoomId: Schemas.WaitingroomWaitingRoomId;
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomPatchWaitingRoomRuleError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomRulesResponseCollection & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomPatchWaitingRoomRuleVariables = {
  body: Schemas.WaitingroomPatchRule;
  pathParams: WaitingRoomPatchWaitingRoomRulePathParams;
} & FetcherExtraProps;

/**
 * Patches a rule for a waiting room.
 */
export const waitingRoomPatchWaitingRoomRule = (
  variables: WaitingRoomPatchWaitingRoomRuleVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WaitingroomRulesResponseCollection,
    WaitingRoomPatchWaitingRoomRuleError,
    Schemas.WaitingroomPatchRule,
    {},
    {},
    WaitingRoomPatchWaitingRoomRulePathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/{waitingRoomId}/rules/{ruleId}', method: 'patch', ...variables, signal });

export type WaitingRoomGetWaitingRoomStatusPathParams = {
  waitingRoomId: Schemas.WaitingroomWaitingRoomId;
  zoneId: Schemas.WaitingroomIdentifier;
};

export type WaitingRoomGetWaitingRoomStatusError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WaitingroomStatusResponse & Schemas.WaitingroomApiResponseCommonFailure;
}>;

export type WaitingRoomGetWaitingRoomStatusVariables = {
  pathParams: WaitingRoomGetWaitingRoomStatusPathParams;
} & FetcherExtraProps;

/**
 * Fetches the status of a configured waiting room. Response fields include:
 * 1. `status`: String indicating the status of the waiting room. The possible status are:
 * 	- **not_queueing** indicates that the configured thresholds have not been met and all users are going through to the origin.
 * 	- **queueing** indicates that the thresholds have been met and some users are held in the waiting room.
 * 	- **event_prequeueing** indicates that an event is active and is currently prequeueing users before it starts.
 * 2. `event_id`: String of the current event's `id` if an event is active, otherwise an empty string.
 * 3. `estimated_queued_users`: Integer of the estimated number of users currently waiting in the queue.
 * 4. `estimated_total_active_users`: Integer of the estimated number of users currently active on the origin.
 * 5. `max_estimated_time_minutes`: Integer of the maximum estimated time currently presented to the users.
 */
export const waitingRoomGetWaitingRoomStatus = (
  variables: WaitingRoomGetWaitingRoomStatusVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.WaitingroomStatusResponse,
    WaitingRoomGetWaitingRoomStatusError,
    undefined,
    {},
    {},
    WaitingRoomGetWaitingRoomStatusPathParams
  >({ url: '/zones/{zoneId}/waiting_rooms/{waitingRoomId}/status', method: 'get', ...variables, signal });

export type Web3HostnameListWeb3HostnamesPathParams = {
  zoneId: Schemas.Web3Identifier;
};

export type Web3HostnameListWeb3HostnamesError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.Web3CollectionResponse & Schemas.Web3ApiResponseCommonFailure;
}>;

export type Web3HostnameListWeb3HostnamesVariables = {
  pathParams: Web3HostnameListWeb3HostnamesPathParams;
} & FetcherExtraProps;

export const web3HostnameListWeb3Hostnames = (
  variables: Web3HostnameListWeb3HostnamesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.Web3CollectionResponse,
    Web3HostnameListWeb3HostnamesError,
    undefined,
    {},
    {},
    Web3HostnameListWeb3HostnamesPathParams
  >({ url: '/zones/{zoneId}/web3/hostnames', method: 'get', ...variables, signal });

export type Web3HostnameCreateWeb3HostnamePathParams = {
  zoneId: Schemas.Web3Identifier;
};

export type Web3HostnameCreateWeb3HostnameError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.Web3SingleResponse & Schemas.Web3ApiResponseCommonFailure;
}>;

export type Web3HostnameCreateWeb3HostnameVariables = {
  body: Schemas.Web3CreateRequest;
  pathParams: Web3HostnameCreateWeb3HostnamePathParams;
} & FetcherExtraProps;

export const web3HostnameCreateWeb3Hostname = (
  variables: Web3HostnameCreateWeb3HostnameVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.Web3SingleResponse,
    Web3HostnameCreateWeb3HostnameError,
    Schemas.Web3CreateRequest,
    {},
    {},
    Web3HostnameCreateWeb3HostnamePathParams
  >({ url: '/zones/{zoneId}/web3/hostnames', method: 'post', ...variables, signal });

export type Web3HostnameDeleteWeb3HostnamePathParams = {
  identifier: Schemas.Web3Identifier;
  zoneId: Schemas.Web3Identifier;
};

export type Web3HostnameDeleteWeb3HostnameError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.Web3ApiResponseSingleId & Schemas.Web3ApiResponseCommonFailure;
}>;

export type Web3HostnameDeleteWeb3HostnameVariables = {
  pathParams: Web3HostnameDeleteWeb3HostnamePathParams;
} & FetcherExtraProps;

export const web3HostnameDeleteWeb3Hostname = (
  variables: Web3HostnameDeleteWeb3HostnameVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.Web3ApiResponseSingleId,
    Web3HostnameDeleteWeb3HostnameError,
    undefined,
    {},
    {},
    Web3HostnameDeleteWeb3HostnamePathParams
  >({ url: '/zones/{zoneId}/web3/hostnames/{identifier}', method: 'delete', ...variables, signal });

export type Web3HostnameWeb3HostnameDetailsPathParams = {
  identifier: Schemas.Web3Identifier;
  zoneId: Schemas.Web3Identifier;
};

export type Web3HostnameWeb3HostnameDetailsError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.Web3SingleResponse & Schemas.Web3ApiResponseCommonFailure;
}>;

export type Web3HostnameWeb3HostnameDetailsVariables = {
  pathParams: Web3HostnameWeb3HostnameDetailsPathParams;
} & FetcherExtraProps;

export const web3HostnameWeb3HostnameDetails = (
  variables: Web3HostnameWeb3HostnameDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.Web3SingleResponse,
    Web3HostnameWeb3HostnameDetailsError,
    undefined,
    {},
    {},
    Web3HostnameWeb3HostnameDetailsPathParams
  >({ url: '/zones/{zoneId}/web3/hostnames/{identifier}', method: 'get', ...variables, signal });

export type Web3HostnameEditWeb3HostnamePathParams = {
  identifier: Schemas.Web3Identifier;
  zoneId: Schemas.Web3Identifier;
};

export type Web3HostnameEditWeb3HostnameError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.Web3SingleResponse & Schemas.Web3ApiResponseCommonFailure;
}>;

export type Web3HostnameEditWeb3HostnameVariables = {
  body?: Schemas.Web3ModifyRequest;
  pathParams: Web3HostnameEditWeb3HostnamePathParams;
} & FetcherExtraProps;

export const web3HostnameEditWeb3Hostname = (variables: Web3HostnameEditWeb3HostnameVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.Web3SingleResponse,
    Web3HostnameEditWeb3HostnameError,
    Schemas.Web3ModifyRequest,
    {},
    {},
    Web3HostnameEditWeb3HostnamePathParams
  >({ url: '/zones/{zoneId}/web3/hostnames/{identifier}', method: 'patch', ...variables, signal });

export type Web3HostnameIpfsUniversalPathGatewayContentListDetailsPathParams = {
  identifier: Schemas.Web3Identifier;
  zoneId: Schemas.Web3Identifier;
};

export type Web3HostnameIpfsUniversalPathGatewayContentListDetailsError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.Web3ContentListDetailsResponse & Schemas.Web3ApiResponseCommonFailure;
}>;

export type Web3HostnameIpfsUniversalPathGatewayContentListDetailsVariables = {
  pathParams: Web3HostnameIpfsUniversalPathGatewayContentListDetailsPathParams;
} & FetcherExtraProps;

export const web3HostnameIpfsUniversalPathGatewayContentListDetails = (
  variables: Web3HostnameIpfsUniversalPathGatewayContentListDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.Web3ContentListDetailsResponse,
    Web3HostnameIpfsUniversalPathGatewayContentListDetailsError,
    undefined,
    {},
    {},
    Web3HostnameIpfsUniversalPathGatewayContentListDetailsPathParams
  >({
    url: '/zones/{zoneId}/web3/hostnames/{identifier}/ipfs_universal_path/content_list',
    method: 'get',
    ...variables,
    signal
  });

export type Web3HostnameUpdateIpfsUniversalPathGatewayContentListPathParams = {
  identifier: Schemas.Web3Identifier;
  zoneId: Schemas.Web3Identifier;
};

export type Web3HostnameUpdateIpfsUniversalPathGatewayContentListError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.Web3ContentListDetailsResponse & Schemas.Web3ApiResponseCommonFailure;
}>;

export type Web3HostnameUpdateIpfsUniversalPathGatewayContentListVariables = {
  body: Schemas.Web3ContentListUpdateRequest;
  pathParams: Web3HostnameUpdateIpfsUniversalPathGatewayContentListPathParams;
} & FetcherExtraProps;

export const web3HostnameUpdateIpfsUniversalPathGatewayContentList = (
  variables: Web3HostnameUpdateIpfsUniversalPathGatewayContentListVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.Web3ContentListDetailsResponse,
    Web3HostnameUpdateIpfsUniversalPathGatewayContentListError,
    Schemas.Web3ContentListUpdateRequest,
    {},
    {},
    Web3HostnameUpdateIpfsUniversalPathGatewayContentListPathParams
  >({
    url: '/zones/{zoneId}/web3/hostnames/{identifier}/ipfs_universal_path/content_list',
    method: 'put',
    ...variables,
    signal
  });

export type Web3HostnameListIpfsUniversalPathGatewayContentListEntriesPathParams = {
  identifier: Schemas.Web3Identifier;
  zoneId: Schemas.Web3Identifier;
};

export type Web3HostnameListIpfsUniversalPathGatewayContentListEntriesError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.Web3ContentListEntryCollectionResponse & Schemas.Web3ApiResponseCommonFailure;
}>;

export type Web3HostnameListIpfsUniversalPathGatewayContentListEntriesVariables = {
  pathParams: Web3HostnameListIpfsUniversalPathGatewayContentListEntriesPathParams;
} & FetcherExtraProps;

export const web3HostnameListIpfsUniversalPathGatewayContentListEntries = (
  variables: Web3HostnameListIpfsUniversalPathGatewayContentListEntriesVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.Web3ContentListEntryCollectionResponse,
    Web3HostnameListIpfsUniversalPathGatewayContentListEntriesError,
    undefined,
    {},
    {},
    Web3HostnameListIpfsUniversalPathGatewayContentListEntriesPathParams
  >({
    url: '/zones/{zoneId}/web3/hostnames/{identifier}/ipfs_universal_path/content_list/entries',
    method: 'get',
    ...variables,
    signal
  });

export type Web3HostnameCreateIpfsUniversalPathGatewayContentListEntryPathParams = {
  identifier: Schemas.Web3Identifier;
  zoneId: Schemas.Web3Identifier;
};

export type Web3HostnameCreateIpfsUniversalPathGatewayContentListEntryError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.Web3ContentListEntrySingleResponse & Schemas.Web3ApiResponseCommonFailure;
}>;

export type Web3HostnameCreateIpfsUniversalPathGatewayContentListEntryVariables = {
  body: Schemas.Web3ContentListEntryCreateRequest;
  pathParams: Web3HostnameCreateIpfsUniversalPathGatewayContentListEntryPathParams;
} & FetcherExtraProps;

export const web3HostnameCreateIpfsUniversalPathGatewayContentListEntry = (
  variables: Web3HostnameCreateIpfsUniversalPathGatewayContentListEntryVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.Web3ContentListEntrySingleResponse,
    Web3HostnameCreateIpfsUniversalPathGatewayContentListEntryError,
    Schemas.Web3ContentListEntryCreateRequest,
    {},
    {},
    Web3HostnameCreateIpfsUniversalPathGatewayContentListEntryPathParams
  >({
    url: '/zones/{zoneId}/web3/hostnames/{identifier}/ipfs_universal_path/content_list/entries',
    method: 'post',
    ...variables,
    signal
  });

export type Web3HostnameDeleteIpfsUniversalPathGatewayContentListEntryPathParams = {
  contentListEntryIdentifier: Schemas.Web3Identifier;
  identifier: Schemas.Web3Identifier;
  zoneId: Schemas.Web3Identifier;
};

export type Web3HostnameDeleteIpfsUniversalPathGatewayContentListEntryError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.Web3ApiResponseSingleId & Schemas.Web3ApiResponseCommonFailure;
}>;

export type Web3HostnameDeleteIpfsUniversalPathGatewayContentListEntryVariables = {
  pathParams: Web3HostnameDeleteIpfsUniversalPathGatewayContentListEntryPathParams;
} & FetcherExtraProps;

export const web3HostnameDeleteIpfsUniversalPathGatewayContentListEntry = (
  variables: Web3HostnameDeleteIpfsUniversalPathGatewayContentListEntryVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.Web3ApiResponseSingleId,
    Web3HostnameDeleteIpfsUniversalPathGatewayContentListEntryError,
    undefined,
    {},
    {},
    Web3HostnameDeleteIpfsUniversalPathGatewayContentListEntryPathParams
  >({
    url: '/zones/{zoneId}/web3/hostnames/{identifier}/ipfs_universal_path/content_list/entries/{contentListEntryIdentifier}',
    method: 'delete',
    ...variables,
    signal
  });

export type Web3HostnameIpfsUniversalPathGatewayContentListEntryDetailsPathParams = {
  contentListEntryIdentifier: Schemas.Web3Identifier;
  identifier: Schemas.Web3Identifier;
  zoneId: Schemas.Web3Identifier;
};

export type Web3HostnameIpfsUniversalPathGatewayContentListEntryDetailsError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.Web3ContentListEntrySingleResponse & Schemas.Web3ApiResponseCommonFailure;
}>;

export type Web3HostnameIpfsUniversalPathGatewayContentListEntryDetailsVariables = {
  pathParams: Web3HostnameIpfsUniversalPathGatewayContentListEntryDetailsPathParams;
} & FetcherExtraProps;

export const web3HostnameIpfsUniversalPathGatewayContentListEntryDetails = (
  variables: Web3HostnameIpfsUniversalPathGatewayContentListEntryDetailsVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.Web3ContentListEntrySingleResponse,
    Web3HostnameIpfsUniversalPathGatewayContentListEntryDetailsError,
    undefined,
    {},
    {},
    Web3HostnameIpfsUniversalPathGatewayContentListEntryDetailsPathParams
  >({
    url: '/zones/{zoneId}/web3/hostnames/{identifier}/ipfs_universal_path/content_list/entries/{contentListEntryIdentifier}',
    method: 'get',
    ...variables,
    signal
  });

export type Web3HostnameEditIpfsUniversalPathGatewayContentListEntryPathParams = {
  contentListEntryIdentifier: Schemas.Web3Identifier;
  identifier: Schemas.Web3Identifier;
  zoneId: Schemas.Web3Identifier;
};

export type Web3HostnameEditIpfsUniversalPathGatewayContentListEntryError = Fetcher.ErrorWrapper<{
  status: 500;
  payload: Schemas.Web3ContentListEntrySingleResponse & Schemas.Web3ApiResponseCommonFailure;
}>;

export type Web3HostnameEditIpfsUniversalPathGatewayContentListEntryVariables = {
  body: Schemas.Web3ContentListEntryCreateRequest;
  pathParams: Web3HostnameEditIpfsUniversalPathGatewayContentListEntryPathParams;
} & FetcherExtraProps;

export const web3HostnameEditIpfsUniversalPathGatewayContentListEntry = (
  variables: Web3HostnameEditIpfsUniversalPathGatewayContentListEntryVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.Web3ContentListEntrySingleResponse,
    Web3HostnameEditIpfsUniversalPathGatewayContentListEntryError,
    Schemas.Web3ContentListEntryCreateRequest,
    {},
    {},
    Web3HostnameEditIpfsUniversalPathGatewayContentListEntryPathParams
  >({
    url: '/zones/{zoneId}/web3/hostnames/{identifier}/ipfs_universal_path/content_list/entries/{contentListEntryIdentifier}',
    method: 'put',
    ...variables,
    signal
  });

export type WorkerRoutesListRoutesPathParams = {
  zoneId: Schemas.WorkersIdentifier;
};

export type WorkerRoutesListRoutesError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersRouteResponseCollection & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerRoutesListRoutesVariables = {
  pathParams: WorkerRoutesListRoutesPathParams;
} & FetcherExtraProps;

/**
 * Returns routes for a zone.
 */
export const workerRoutesListRoutes = (variables: WorkerRoutesListRoutesVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersRouteResponseCollection,
    WorkerRoutesListRoutesError,
    undefined,
    {},
    {},
    WorkerRoutesListRoutesPathParams
  >({ url: '/zones/{zoneId}/workers/routes', method: 'get', ...variables, signal });

export type WorkerRoutesCreateRoutePathParams = {
  zoneId: Schemas.WorkersIdentifier;
};

export type WorkerRoutesCreateRouteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseSingle & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerRoutesCreateRouteVariables = {
  body: Schemas.WorkersRouteNoId;
  pathParams: WorkerRoutesCreateRoutePathParams;
} & FetcherExtraProps;

/**
 * Creates a route that maps a URL pattern to a Worker.
 */
export const workerRoutesCreateRoute = (variables: WorkerRoutesCreateRouteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersApiResponseSingle,
    WorkerRoutesCreateRouteError,
    Schemas.WorkersRouteNoId,
    {},
    {},
    WorkerRoutesCreateRoutePathParams
  >({ url: '/zones/{zoneId}/workers/routes', method: 'post', ...variables, signal });

export type WorkerRoutesDeleteRoutePathParams = {
  routeId: Schemas.WorkersIdentifier;
  zoneId: Schemas.WorkersIdentifier;
};

export type WorkerRoutesDeleteRouteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersApiResponseSingle & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerRoutesDeleteRouteVariables = {
  pathParams: WorkerRoutesDeleteRoutePathParams;
} & FetcherExtraProps;

/**
 * Deletes a route.
 */
export const workerRoutesDeleteRoute = (variables: WorkerRoutesDeleteRouteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersApiResponseSingle,
    WorkerRoutesDeleteRouteError,
    undefined,
    {},
    {},
    WorkerRoutesDeleteRoutePathParams
  >({ url: '/zones/{zoneId}/workers/routes/{routeId}', method: 'delete', ...variables, signal });

export type WorkerRoutesGetRoutePathParams = {
  routeId: Schemas.WorkersIdentifier;
  zoneId: Schemas.WorkersIdentifier;
};

export type WorkerRoutesGetRouteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersRouteResponseSingle & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerRoutesGetRouteVariables = {
  pathParams: WorkerRoutesGetRoutePathParams;
} & FetcherExtraProps;

/**
 * Returns information about a route, including URL pattern and Worker.
 */
export const workerRoutesGetRoute = (variables: WorkerRoutesGetRouteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersRouteResponseSingle,
    WorkerRoutesGetRouteError,
    undefined,
    {},
    {},
    WorkerRoutesGetRoutePathParams
  >({ url: '/zones/{zoneId}/workers/routes/{routeId}', method: 'get', ...variables, signal });

export type WorkerRoutesUpdateRoutePathParams = {
  routeId: Schemas.WorkersIdentifier;
  zoneId: Schemas.WorkersIdentifier;
};

export type WorkerRoutesUpdateRouteError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.WorkersRouteResponseSingle & Schemas.WorkersApiResponseCommonFailure;
}>;

export type WorkerRoutesUpdateRouteVariables = {
  body: Schemas.WorkersRouteNoId;
  pathParams: WorkerRoutesUpdateRoutePathParams;
} & FetcherExtraProps;

/**
 * Updates the URL pattern or Worker associated with a route.
 */
export const workerRoutesUpdateRoute = (variables: WorkerRoutesUpdateRouteVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.WorkersRouteResponseSingle,
    WorkerRoutesUpdateRouteError,
    Schemas.WorkersRouteNoId,
    {},
    {},
    WorkerRoutesUpdateRoutePathParams
  >({ url: '/zones/{zoneId}/workers/routes/{routeId}', method: 'put', ...variables, signal });

export type SslDetectorAutomaticModeGetEnrollmentPathParams = {
  zoneTag: Schemas.CacheZoneIdentifier;
};

export type SslDetectorAutomaticModeGetEnrollmentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheApiResponseCommonFailure;
}>;

export type SslDetectorAutomaticModeGetEnrollmentVariables = {
  pathParams: SslDetectorAutomaticModeGetEnrollmentPathParams;
} & FetcherExtraProps;

/**
 * If the system is enabled, the response will include next_scheduled_scan, representing the next time this zone will be scanned and the zone's ssl/tls encryption mode is potentially upgraded by the system. If the system is disabled, next_scheduled_scan will not be present in the response body.
 */
export const sslDetectorAutomaticModeGetEnrollment = (
  variables: SslDetectorAutomaticModeGetEnrollmentVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CacheAutomaticUpgraderResponse,
    SslDetectorAutomaticModeGetEnrollmentError,
    undefined,
    {},
    {},
    SslDetectorAutomaticModeGetEnrollmentPathParams
  >({ url: '/zones/{zoneTag}/settings/ssl_automatic_mode', method: 'get', ...variables, signal });

export type SslDetectorAutomaticModePatchEnrollmentPathParams = {
  zoneTag: Schemas.CacheZoneIdentifier;
};

export type SslDetectorAutomaticModePatchEnrollmentError = Fetcher.ErrorWrapper<{
  status: 400;
  payload: Schemas.CacheApiResponseCommonFailure;
}>;

export type SslDetectorAutomaticModePatchEnrollmentVariables = {
  body: Schemas.CacheSchemasPatch;
  pathParams: SslDetectorAutomaticModePatchEnrollmentPathParams;
} & FetcherExtraProps;

/**
 * The automatic system is enabled when this endpoint is hit with value in the request body is set to "auto", and disabled when the request body value is set to "custom".
 */
export const sslDetectorAutomaticModePatchEnrollment = (
  variables: SslDetectorAutomaticModePatchEnrollmentVariables,
  signal?: AbortSignal
) =>
  fetch<
    Schemas.CacheAutomaticUpgraderResponse,
    SslDetectorAutomaticModePatchEnrollmentError,
    Schemas.CacheSchemasPatch,
    {},
    {},
    SslDetectorAutomaticModePatchEnrollmentPathParams
  >({ url: '/zones/{zoneTag}/settings/ssl_automatic_mode', method: 'patch', ...variables, signal });

export const operationsByTag = {
  accounts: { accountsListAccounts, accountCreation, accountDeletion, accountsAccountDetails, accountsUpdateAccount },
  requestForInformationRFI: {
    cloudforceOneRequestList,
    cloudforceOneRequestConstants,
    cloudforceOneRequestNew,
    cloudforceOneRequestQuota,
    cloudforceOneRequestTypes,
    cloudforceOneRequestDelete,
    cloudforceOneRequestGet,
    cloudforceOneRequestUpdate,
    cloudforceOneRequestAssetList,
    cloudforceOneRequestAssetNew,
    cloudforceOneRequestAssetDelete,
    cloudforceOneRequestAssetGet,
    cloudforceOneRequestAssetUpdate,
    cloudforceOneRequestMessageList,
    cloudforceOneRequestMessageNew,
    cloudforceOneRequestMessageDelete,
    cloudforceOneRequestMessageUpdate
  },
  priorityIntelligenceRequirementsPIR: {
    cloudforceOnePriorityList,
    cloudforceOnePriorityNew,
    cloudforceOnePriorityQuota,
    cloudforceOnePriorityDelete,
    cloudforceOnePriorityGet,
    cloudforceOnePriorityUpdate
  },
  customPagesForAnAccount: {
    customPagesForAnAccountListCustomPages,
    customPagesForAnAccountGetACustomPage,
    customPagesForAnAccountUpdateACustomPage
  },
  lists: {
    listsGetBulkOperationStatus,
    listsGetAListItem,
    listsGetLists,
    listsCreateAList,
    listsDeleteAList,
    listsGetAList,
    listsUpdateAList,
    listsDeleteListItems,
    listsGetListItems,
    listsCreateListItems,
    listsUpdateAllListItems
  },
  tsengAbuseComplaintProcessorOther: { submitAbuseReport },
  accessApplications: {
    accessApplicationsListAccessApplications,
    accessApplicationsAddAnApplication,
    accessApplicationsDeleteAnAccessApplication,
    accessApplicationsGetAnAccessApplication,
    accessApplicationsUpdateAnAccessApplication,
    accessApplicationsRevokeServiceTokens,
    accessApplicationsTestAccessPolicies
  },
  accessShortLivedCertificateCAs: {
    accessShortLivedCertificateCAsListShortLivedCertificateCAs,
    accessShortLivedCertificateCAsDeleteAShortLivedCertificateCa,
    accessShortLivedCertificateCAsGetAShortLivedCertificateCa,
    accessShortLivedCertificateCAsCreateAShortLivedCertificateCa
  },
  accessApplicationScopedPolicies: {
    accessPoliciesListAccessAppPolicies,
    accessPoliciesCreateAnAccessPolicy,
    accessPoliciesDeleteAnAccessPolicy,
    accessPoliciesGetAnAccessPolicy,
    accessPoliciesUpdateAnAccessPolicy
  },
  accessBookmarkApplicationsDeprecated: {
    accessBookmarkApplicationsDeprecatedListBookmarkApplications,
    accessBookmarkApplicationsDeprecatedDeleteABookmarkApplication,
    accessBookmarkApplicationsDeprecatedGetABookmarkApplication,
    accessBookmarkApplicationsDeprecatedCreateABookmarkApplication,
    accessBookmarkApplicationsDeprecatedUpdateABookmarkApplication
  },
  accessMTLSAuthentication: {
    accessMtlsAuthenticationListMtlsCertificates,
    accessMtlsAuthenticationAddAnMtlsCertificate,
    accessMtlsAuthenticationListMtlsCertificatesHostnameSettings,
    accessMtlsAuthenticationUpdateAnMtlsCertificateSettings,
    accessMtlsAuthenticationDeleteAnMtlsCertificate,
    accessMtlsAuthenticationGetAnMtlsCertificate,
    accessMtlsAuthenticationUpdateAnMtlsCertificate
  },
  accessCustomPages: {
    accessCustomPagesListCustomPages,
    accessCustomPagesCreateACustomPage,
    accessCustomPagesDeleteACustomPage,
    accessCustomPagesGetACustomPage,
    accessCustomPagesUpdateACustomPage
  },
  gatewayCA: { accessGatewayCaListSSHCa, accessGatewayCaAddAnSSHCa, accessGatewayCaDeleteAnSSHCa },
  accessGroups: {
    accessGroupsListAccessGroups,
    accessGroupsCreateAnAccessGroup,
    accessGroupsDeleteAnAccessGroup,
    accessGroupsGetAnAccessGroup,
    accessGroupsUpdateAnAccessGroup
  },
  accessIdentityProviders: {
    accessIdentityProvidersListAccessIdentityProviders,
    accessIdentityProvidersAddAnAccessIdentityProvider,
    accessIdentityProvidersDeleteAnAccessIdentityProvider,
    accessIdentityProvidersGetAnAccessIdentityProvider,
    accessIdentityProvidersUpdateAnAccessIdentityProvider
  },
  accessKeyConfiguration: {
    accessKeyConfigurationGetTheAccessKeyConfiguration,
    accessKeyConfigurationUpdateTheAccessKeyConfiguration,
    accessKeyConfigurationRotateAccessKeys
  },
  accessAuthenticationLogs: { accessAuthenticationLogsGetAccessAuthenticationLogs },
  zeroTrustOrganization: {
    zeroTrustOrganizationGetYourZeroTrustOrganization,
    zeroTrustOrganizationCreateYourZeroTrustOrganization,
    zeroTrustOrganizationUpdateYourZeroTrustOrganization,
    zeroTrustOrganizationGetYourZeroTrustOrganizationDohSettings,
    zeroTrustOrganizationUpdateYourZeroTrustOrganizationDohSettings,
    zeroTrustOrganizationRevokeAllAccessTokensForAUser
  },
  accessReusablePolicies: {
    accessPoliciesListAccessReusablePolicies,
    accessPoliciesCreateAnAccessReusablePolicy,
    accessPoliciesDeleteAnAccessReusablePolicy,
    accessPoliciesGetAnAccessReusablePolicy,
    accessPoliciesUpdateAnAccessReusablePolicy
  },
  accessPolicyTester: { accessPolicyTests, accessPolicyTestsGetAnUpdate, accessPolicyTestsGetAUserPage },
  zeroTrustSeats: { zeroTrustSeatsUpdateAUserSeat },
  accessServiceTokens: {
    accessServiceTokensListServiceTokens,
    accessServiceTokensCreateAServiceToken,
    accessServiceTokensDeleteAServiceToken,
    accessServiceTokensGetAServiceToken,
    accessServiceTokensUpdateAServiceToken,
    accessServiceTokensRefreshAServiceToken,
    accessServiceTokensRotateAServiceToken
  },
  accessTags: {
    accessTagsListTags,
    accessTagsCreateTag,
    accessTagsDeleteATag,
    accessTagsGetATag,
    accessTagsUpdateATag
  },
  zeroTrustUsers: {
    zeroTrustUsersGetUsers,
    zeroTrustUsersGetActiveSessions,
    zeroTrustUsersGetActiveSession,
    zeroTrustUsersGetFailedLogins,
    zeroTrustUsersGetLastSeenIdentity
  },
  iPAddressManagementAddressMaps: {
    ipAddressManagementAddressMapsListAddressMaps,
    ipAddressManagementAddressMapsCreateAddressMap,
    ipAddressManagementAddressMapsDeleteAddressMap,
    ipAddressManagementAddressMapsAddressMapDetails,
    ipAddressManagementAddressMapsUpdateAddressMap,
    ipAddressManagementAddressMapsRemoveAnAccountMembershipFromAnAddressMap,
    ipAddressManagementAddressMapsAddAnAccountMembershipToAnAddressMap,
    ipAddressManagementAddressMapsRemoveAnIpFromAnAddressMap,
    ipAddressManagementAddressMapsAddAnIpToAnAddressMap,
    ipAddressManagementAddressMapsRemoveAZoneMembershipFromAnAddressMap,
    ipAddressManagementAddressMapsAddAZoneMembershipToAnAddressMap
  },
  iPAddressManagementPrefixes: {
    ipAddressManagementPrefixesUploadLoaDocument,
    ipAddressManagementPrefixesDownloadLoaDocument,
    ipAddressManagementPrefixesListPrefixes,
    ipAddressManagementPrefixesAddPrefix,
    ipAddressManagementPrefixesDeletePrefix,
    ipAddressManagementPrefixesPrefixDetails,
    ipAddressManagementPrefixesUpdatePrefixDescription
  },
  iPAddressManagementBGPPrefixes: {
    ipAddressManagementPrefixesListBgpPrefixes,
    ipAddressManagementPrefixesCreateBgpPrefix,
    ipAddressManagementPrefixesFetchBgpPrefix,
    ipAddressManagementPrefixesUpdateBgpPrefix
  },
  iPAddressManagementDynamicAdvertisement: {
    ipAddressManagementDynamicAdvertisementGetAdvertisementStatus,
    ipAddressManagementDynamicAdvertisementUpdatePrefixDynamicAdvertisementStatus
  },
  iPAddressManagementServiceBindings: {
    ipAddressManagementServiceBindingsListServiceBindings,
    ipAddressManagementServiceBindingsCreateServiceBinding,
    ipAddressManagementServiceBindingsDeleteServiceBinding,
    ipAddressManagementServiceBindingsGetServiceBinding,
    ipAddressManagementServiceBindingsListServices
  },
  iPAddressManagementPrefixDelegation: {
    ipAddressManagementPrefixDelegationListPrefixDelegations,
    ipAddressManagementPrefixDelegationCreatePrefixDelegation,
    ipAddressManagementPrefixDelegationDeletePrefixDelegation
  },
  dLSRegionalServices: {
    dlsAccountRegionalHostnamesAccountListRegions,
    dlsAccountRegionalHostnamesAccountListHostnames,
    dlsAccountRegionalHostnamesAccountCreateHostname,
    dlsAccountRegionalHostnamesAccountDeleteHostname,
    dlsAccountRegionalHostnamesAccountFetchHostname,
    dlsAccountRegionalHostnamesAccountPatchHostname
  },
  aIGatewayEvaluations: {
    aigConfigListEvaluators,
    aigConfigListEvaluations,
    aigConfigCreateEvaluations,
    aigConfigDeleteEvaluations,
    aigConfigFetchEvaluations
  },
  aIGatewayGateways: {
    aigConfigListGateway,
    aigConfigCreateGateway,
    aigConfigDeleteGateway,
    aigConfigFetchGateway,
    aigConfigUpdateGateway
  },
  aIGatewayDatasets: {
    aigConfigListDataset,
    aigConfigCreateDataset,
    aigConfigDeleteDataset,
    aigConfigFetchDataset,
    aigConfigUpdateDataset
  },
  aIGatewayLogs: {
    aigConfigDeleteGatewayLogs,
    aigConfigListGatewayLogs,
    aigConfigGetGatewayLogDetail,
    aigConfigPatchGatewayLog,
    aigConfigGetGatewayLogRequest,
    aigConfigGetGatewayLogResponse
  },
  workersAI: {
    workersAiSearchAuthor,
    workersAiGetModelSchema,
    workersAiSearchModel,
    workersAiPostRunModel,
    workersAiSearchTask
  },
  workersAIFinetune: {
    workersAiListFinetunes,
    workersAiCreateFinetune,
    workersAiListPublicFinetunes,
    workersAiUploadFinetuneAsset
  },
  workersAITextEmbeddings: {
    workersAiPostRunCfBaaiBgeBaseEnV15,
    workersAiPostRunCfBaaiBgeLargeEnV15,
    workersAiPostRunCfBaaiBgeSmallEnV15
  },
  workersAITextToImage: {
    workersAiPostRunCfBlackForestLabsFlux1Schnell,
    workersAiPostRunCfBytedanceStableDiffusionXlLightning,
    workersAiPostRunCfLykonDreamshaper8Lcm,
    workersAiPostRunCfRunwaymlStableDiffusionV15Img2img,
    workersAiPostRunCfRunwaymlStableDiffusionV15Inpainting,
    workersAiPostRunCfStabilityaiStableDiffusionXlBase10
  },
  workersAITextGeneration: {
    workersAiPostRunCfDeepseekAiDeepseekMath7bInstruct,
    workersAiPostRunCfDefogSqlcoder7b2,
    workersAiPostRunCfFblgitUnaCybertron7bV2Bf16,
    workersAiPostRunCfGoogleGemma2bItLora,
    workersAiPostRunCfGoogleGemma7bItLora,
    workersAiPostRunCfMetaLlamaLlama27bChatHfLora,
    workersAiPostRunCfMetaLlama27bChatFp16,
    workersAiPostRunCfMetaLlama27bChatInt8,
    workersAiPostRunCfMetaLlama38bInstruct,
    workersAiPostRunCfMetaLlama38bInstructAwq,
    workersAiPostRunCfMetaLlama3170bInstruct,
    workersAiPostRunCfMetaLlama3170bInstructPreview,
    workersAiPostRunCfMetaLlama3170bPreview,
    workersAiPostRunCfMetaLlama318bInstruct,
    workersAiPostRunCfMetaLlama318bInstructAwq,
    workersAiPostRunCfMetaLlama318bInstructFast,
    workersAiPostRunCfMetaLlama318bInstructFp8,
    workersAiPostRunCfMetaLlama318bPreview,
    workersAiPostRunCfMetaLlama3211bVisionInstruct,
    workersAiPostRunCfMetaLlama321bInstruct,
    workersAiPostRunCfMetaLlama323bInstruct,
    workersAiPostRunCfMetaLlama3370bInstructFp8Fast,
    workersAiPostRunCfMicrosoftPhi2,
    workersAiPostRunCfMistralMistral7bInstructV01,
    workersAiPostRunCfMistralMistral7bInstructV02Lora,
    workersAiPostRunCfOpenchatOpenchat350106,
    workersAiPostRunCfQwenQwen1505bChat,
    workersAiPostRunCfQwenQwen1518bChat,
    workersAiPostRunCfQwenQwen1514bChatAwq,
    workersAiPostRunCfQwenQwen157bChatAwq,
    workersAiPostRunCfTheblokeDiscolmGerman7bV1Awq,
    workersAiPostRunCfTiiuaeFalcon7bInstruct,
    workersAiPostRunCfTinyllamaTinyllama11bChatV10,
    workersAiPostRunHfGoogleGemma7bIt,
    workersAiPostRunHfMetaLlamaMetaLlama38bInstruct,
    workersAiPostRunHfMistralMistral7bInstructV02,
    workersAiPostRunHfMistralaiMistral7bInstructV02,
    workersAiPostRunHfNexusflowStarlingLm7bBeta,
    workersAiPostRunHfNousresearchHermes2ProMistral7b,
    workersAiPostRunHfTheblokeDeepseekCoder67bBaseAwq,
    workersAiPostRunHfTheblokeDeepseekCoder67bInstructAwq,
    workersAiPostRunHfTheblokeLlama213bChatAwq,
    workersAiPostRunHfTheblokeLlamaguard7bAwq,
    workersAiPostRunHfTheblokeMistral7bInstructV01Awq,
    workersAiPostRunHfTheblokeNeuralChat7bV31Awq,
    workersAiPostRunHfTheblokeOpenhermes25Mistral7bAwq,
    workersAiPostRunHfTheblokeZephyr7bBetaAwq
  },
  workersAISummarization: { workersAiPostRunCfFacebookBartLargeCnn },
  workersAIObjectDetection: { workersAiPostRunCfFacebookDetrResnet50 },
  workersAITextClassification: { workersAiPostRunCfHuggingfaceDistilbertSst2Int8 },
  workersAITranslation: { workersAiPostRunCfMetaM2m10012b },
  workersAIImageClassification: { workersAiPostRunCfMicrosoftResnet50 },
  workersAIAutomaticSpeechRecognition: {
    workersAiPostRunCfOpenaiWhisper,
    workersAiPostRunCfOpenaiWhisperLargeV3Turbo,
    workersAiPostRunCfOpenaiWhisperTinyEn
  },
  notificationAlertTypes: { notificationAlertTypesGetAlertTypes },
  notificationMechanismEligibility: { notificationMechanismEligibilityGetDeliveryMechanismEligibility },
  notificationDestinationsWithPagerDuty: {
    notificationDestinationsWithPagerDutyDeletePagerDutyServices,
    notificationDestinationsWithPagerDutyListPagerDutyServices,
    notificationDestinationsWithPagerDutyConnectPagerDuty,
    notificationDestinationsWithPagerDutyConnectPagerDutyToken
  },
  notificationWebhooks: {
    notificationWebhooksListWebhooks,
    notificationWebhooksCreateAWebhook,
    notificationWebhooksDeleteAWebhook,
    notificationWebhooksGetAWebhook,
    notificationWebhooksUpdateAWebhook
  },
  notificationHistory: { notificationHistoryListHistory },
  notificationPolicies: {
    notificationPoliciesListNotificationPolicies,
    notificationPoliciesCreateANotificationPolicy,
    notificationPoliciesDeleteANotificationPolicy,
    notificationPoliciesGetANotificationPolicy,
    notificationPoliciesUpdateANotificationPolicy
  },
  auditLogs: {
    auditLogsGetAccountAuditLogs,
    auditLogsV2GetAccountAuditLogs,
    auditLogsGetOrganizationAuditLogs,
    auditLogsGetUserAuditLogs
  },
  accountBillingProfile: { accountBillingProfileDeprecatedBillingProfileDetails },
  botnetThreatFeed: {
    botnetThreatFeedGetDayReport,
    botnetThreatFeedGetFullReport,
    botnetThreatFeedListAsn,
    botnetThreatFeedDeleteAsn
  },
  phishingURLScanner: { phishingUrlScannerSubmitSuspiciousUrlForScanning },
  phishingURLInformation: { phishingUrlInformationGetResultsForAUrlScan },
  callsApps: {
    callsAppsList,
    callsAppsCreateANewApp,
    callsAppsDeleteApp,
    callsAppsRetrieveAppDetails,
    callsAppsUpdateAppDetails
  },
  callsTURNKeys: {
    callsTurnKeyList,
    callsTurnKeyCreate,
    callsDeleteTurnKey,
    callsRetrieveTurnKeyDetails,
    callsUpdateTurnKey
  },
  cloudflareTunnel: {
    cloudflareTunnelListCloudflareTunnels,
    cloudflareTunnelCreateACloudflareTunnel,
    cloudflareTunnelDeleteACloudflareTunnel,
    cloudflareTunnelGetACloudflareTunnel,
    cloudflareTunnelUpdateACloudflareTunnel,
    cloudflareTunnelCleanUpCloudflareTunnelConnections,
    cloudflareTunnelListCloudflareTunnelConnections,
    cloudflareTunnelGetCloudflareTunnelConnector,
    cloudflareTunnelGetACloudflareTunnelManagementToken,
    cloudflareTunnelGetACloudflareTunnelToken,
    cloudflareTunnelListAllTunnels,
    cloudflareTunnelListWarpConnectorTunnels,
    cloudflareTunnelCreateAWarpConnectorTunnel,
    cloudflareTunnelDeleteAWarpConnectorTunnel,
    cloudflareTunnelGetAWarpConnectorTunnel,
    cloudflareTunnelUpdateAWarpConnectorTunnel,
    cloudflareTunnelGetAWarpConnectorTunnelToken
  },
  cloudflareTunnelConfiguration: {
    cloudflareTunnelConfigurationGetConfiguration,
    cloudflareTunnelConfigurationPutConfiguration
  },
  turnstile: {
    accountsTurnstileWidgetsList,
    accountsTurnstileWidgetCreate,
    accountsTurnstileWidgetDelete,
    accountsTurnstileWidgetGet,
    accountsTurnstileWidgetUpdate,
    accountsTurnstileWidgetRotateSecret
  },
  accountLevelCustomNameservers: {
    accountLevelCustomNameserversListAccountCustomNameservers,
    accountLevelCustomNameserversAddAccountCustomNameserver,
    accountLevelCustomNameserversGetEligibleZonesForAccountCustomNameservers,
    accountLevelCustomNameserversDeleteAccountCustomNameserver
  },
  d1: {
    cloudflareD1ListDatabases,
    cloudflareD1CreateDatabase,
    cloudflareD1DeleteDatabase,
    cloudflareD1GetDatabase,
    cloudflareD1ExportDatabase,
    cloudflareD1ImportDatabase,
    cloudflareD1QueryDatabase,
    cloudflareD1RawDatabaseQuery
  },
  devices: {
    devicesListDevices,
    devicesListDeviceSettingsPolicies,
    devicesGetDefaultDeviceSettingsPolicy,
    devicesUpdateDefaultDeviceSettingsPolicy,
    devicesCreateDeviceSettingsPolicy,
    devicesGetSplitTunnelExcludeList,
    devicesSetSplitTunnelExcludeList,
    devicesGetLocalDomainFallbackList,
    devicesSetLocalDomainFallbackList,
    devicesGetSplitTunnelIncludeList,
    devicesSetSplitTunnelIncludeList,
    devicesDeleteDeviceSettingsPolicy,
    devicesGetDeviceSettingsPolicyById,
    devicesUpdateDeviceSettingsPolicy,
    devicesGetSplitTunnelExcludeListForADeviceSettingsPolicy,
    devicesSetSplitTunnelExcludeListForADeviceSettingsPolicy,
    devicesGetLocalDomainFallbackListForADeviceSettingsPolicy,
    devicesSetLocalDomainFallbackListForADeviceSettingsPolicy,
    devicesGetSplitTunnelIncludeListForADeviceSettingsPolicy,
    devicesSetSplitTunnelIncludeListForADeviceSettingsPolicy,
    devicesRevokeDevices,
    devicesUnrevokeDevices,
    devicesDeviceDetails,
    devicesListAdminOverrideCodeForDevice,
    devicesGetPolicyCertificates,
    devicesUpdatePolicyCertificates
  },
  deviceDEXTests: {
    deviceDexTestDetails,
    deviceDexTestCreateDeviceDexTest,
    deviceDexTestDeleteDeviceDexTest,
    deviceDexTestGetDeviceDexTest,
    deviceDexTestUpdateDeviceDexTest
  },
  deviceManagedNetworks: {
    deviceManagedNetworksListDeviceManagedNetworks,
    deviceManagedNetworksCreateDeviceManagedNetwork,
    deviceManagedNetworksDeleteDeviceManagedNetwork,
    deviceManagedNetworksDeviceManagedNetworkDetails,
    deviceManagedNetworksUpdateDeviceManagedNetwork
  },
  devicePostureRules: {
    devicePostureRulesListDevicePostureRules,
    devicePostureRulesCreateDevicePostureRule,
    devicePostureRulesDeleteDevicePostureRule,
    devicePostureRulesDevicePostureRulesDetails,
    devicePostureRulesUpdateDevicePostureRule
  },
  devicePostureIntegrations: {
    devicePostureIntegrationsListDevicePostureIntegrations,
    devicePostureIntegrationsCreateDevicePostureIntegration,
    devicePostureIntegrationsDeleteDevicePostureIntegration,
    devicePostureIntegrationsDevicePostureIntegrationDetails,
    devicePostureIntegrationsUpdateDevicePostureIntegration
  },
  zeroTrustAccounts: {
    zeroTrustAccountsGetDeviceSettingsForZeroTrustAccount,
    zeroTrustAccountsPatchDeviceSettingsForTheZeroTrustAccount,
    zeroTrustAccountsUpdateDeviceSettingsForTheZeroTrustAccount,
    zeroTrustAccountsGetZeroTrustAccountInformation,
    zeroTrustAccountsCreateZeroTrustAccount,
    zeroTrustAccountsGetZeroTrustAccountConfiguration,
    zeroTrustAccountsPatchZeroTrustAccountConfiguration,
    zeroTrustAccountsUpdateZeroTrustAccountConfiguration,
    zeroTrustAccountsGetZeroTrustCertificateConfiguration,
    zeroTrustAccountsGetLoggingSettingsForTheZeroTrustAccount,
    zeroTrustAccountsUpdateLoggingSettingsForTheZeroTrustAccount
  },
  dEXSyntheticApplicationMonitoring: {
    dexEndpointsListColos,
    devicesLiveStatus,
    dexFleetStatusDevices,
    dexFleetStatusLive,
    dexFleetStatusOverTime,
    dexEndpointsHttpTestDetails,
    dexEndpointsHttpTestPercentiles,
    dexEndpointsListTestsOverview,
    dexEndpointsTestsUniqueDevices,
    dexEndpointsTracerouteTestResultNetworkPath,
    dexEndpointsTracerouteTestDetails,
    dexEndpointsTracerouteTestNetworkPath,
    dexEndpointsTracerouteTestPercentiles
  },
  dEXRemoteCommands: {
    getCommands,
    postCommands,
    getCommandsEligibleDevices,
    getCommandsQuota,
    getCommandsEligibleUsers,
    getCommandsCommandIdDownloadsFilename
  },
  diagnostics: { diagnosticsTraceroute },
  dLPDatasets: {
    dlpDatasetsReadAll,
    dlpDatasetsCreate,
    dlpDatasetsDelete,
    dlpDatasetsRead,
    dlpDatasetsUpdate,
    dlpDatasetsCreateVersion,
    dlpDatasetsUploadVersion,
    dlpDatasetsDefineColumns,
    dlpDatasetsUploadDatasetColumn
  },
  dLPEmail: {
    dlpEmailScannerGetAccountMapping,
    dlpEmailScannerCreateAccountMapping,
    dlpEmailScannerListAllRules,
    dlpEmailScannerUpdateRulePriorities,
    dlpEmailScannerCreateRule,
    dlpEmailScannerDeleteRule,
    dlpEmailScannerGetRule,
    dlpEmailScannerUpdateRule
  },
  dLPEntries: {
    dlpEntriesListAllEntries,
    dlpEntriesCreateEntry,
    dlpEntriesDeleteEntry,
    dlpEntriesGetDlpEntry,
    dlpEntriesUpdateEntry
  },
  dLPSettings: { dlpLimitsGet, dlpPatternValidate, dlpPayloadLogGet, dlpPayloadLogPut },
  dLPProfiles: {
    dlpProfilesListAllProfiles,
    dlpProfilesCreateCustomProfiles,
    dlpProfilesDeleteCustomProfile,
    dlpProfilesGetCustomProfile,
    dlpProfilesUpdateCustomProfile,
    dlpProfilesGetPredefinedProfile,
    dlpProfilesUpdatePredefinedProfile,
    dlpProfilesGetDlpProfile
  },
  dNSFirewall: {
    dnsFirewallListDnsFirewallClusters,
    dnsFirewallCreateDnsFirewallCluster,
    dnsFirewallDeleteDnsFirewallCluster,
    dnsFirewallDnsFirewallClusterDetails,
    dnsFirewallUpdateDnsFirewallCluster,
    dnsFirewallShowDnsFirewallClusterReverseDns,
    dnsFirewallUpdateDnsFirewallClusterReverseDns
  },
  dNSFirewallAnalytics: { dnsFirewallAnalyticsTable, dnsFirewallAnalyticsByTime },
  dNSSettingsForAnAccount: { dnsSettingsForAnAccountListDnsSettings, dnsSettingsForAnAccountUpdateDnsSettings },
  dNSInternalViewsForAnAccount: {
    dnsViewsForAnAccountListInternalDnsViews,
    dnsViewsForAnAccountCreateInternalDnsViews,
    dnsViewsForAnAccountDeleteInternalDnsView,
    dnsViewsForAnAccountGetInternalDnsView,
    dnsViewsForAnAccountUpdateInternalDnsView
  },
  emailSecurity: {
    emailSecurityInvestigate,
    emailSecurityPostBulkMessageMove,
    emailSecurityPostPreview,
    emailSecurityPostRelease,
    emailSecurityGetMessage,
    emailSecurityGetMessageDetections,
    emailSecurityPostMessageMove,
    emailSecurityGetMessagePreview,
    emailSecurityGetMessageRaw,
    emailSecurityPostReclassify,
    emailSecurityGetMessageTrace,
    emailSecuritySubmissions
  },
  emailSecuritySettings: {
    emailSecurityListAllowPolicies,
    emailSecurityCreateAllowPolicy,
    emailSecurityDeleteAllowPolicy,
    emailSecurityGetAllowPolicy,
    emailSecurityUpdateAllowPolicy,
    emailSecurityListBlockedSenders,
    emailSecurityCreateBlockedSender,
    emailSecurityDeleteBlockedSender,
    emailSecurityGetBlockedSender,
    emailSecurityUpdateBlockedSender,
    emailSecurityDeleteDomains,
    emailSecurityListDomains,
    emailSecurityDeleteDomain,
    emailSecurityGetDomain,
    emailSecurityUpdateDomain,
    emailSecurityListDisplayNames,
    emailSecurityCreateDisplayName,
    emailSecurityDeleteDisplayName,
    emailSecurityGetDisplayName,
    emailSecurityUpdateDisplayName,
    emailSecurityListTrustedDomains,
    emailSecurityCreateTrustedDomain,
    emailSecurityDeleteTrustedDomain,
    emailSecurityGetTrustedDomain,
    emailSecurityUpdateTrustedDomain
  },
  emailRoutingDestinationAddresses: {
    emailRoutingDestinationAddressesListDestinationAddresses,
    emailRoutingDestinationAddressesCreateADestinationAddress,
    emailRoutingDestinationAddressesDeleteDestinationAddress,
    emailRoutingDestinationAddressesGetADestinationAddress
  },
  r2Bucket: {
    r2GetEventNotificationConfigs,
    r2EventNotificationDeleteConfig,
    r2PutEventNotificationConfig,
    r2ListBuckets,
    r2CreateBucket,
    r2DeleteBucket,
    r2GetBucket,
    r2DeleteBucketCorsPolicy,
    r2GetBucketCorsPolicy,
    r2PutBucketCorsPolicy,
    r2ListCustomDomains,
    r2AddCustomDomain,
    r2DeleteCustomDomain,
    r2GetCustomDomainSettings,
    r2EditCustomDomainSettings,
    r2GetBucketPublicPolicy,
    r2PutBucketPublicPolicy,
    r2GetBucketLifecycleConfiguration,
    r2PutBucketLifecycleConfiguration,
    r2DeleteBucketSippyConfig,
    r2GetBucketSippyConfig,
    r2PutBucketSippyConfig,
    r2CreateTempAccessCredentials
  },
  iPAccessRulesForAnAccount: {
    ipAccessRulesForAnAccountListIpAccessRules,
    ipAccessRulesForAnAccountCreateAnIpAccessRule,
    ipAccessRulesForAnAccountDeleteAnIpAccessRule,
    ipAccessRulesForAnAccountGetAnIpAccessRule,
    ipAccessRulesForAnAccountUpdateAnIpAccessRule
  },
  zeroTrustGatewayApplicationAndApplicationTypeMappings: {
    zeroTrustGatewayApplicationAndApplicationTypeMappingsListApplicationAndApplicationTypeMappings
  },
  zeroTrustSSHSettings: {
    zeroTrustGetAuditSshSettings,
    zeroTrustUpdateAuditSshSettings,
    zeroTrustRotateSshAccountSeed
  },
  zeroTrustGatewayCategories: { zeroTrustGatewayCategoriesListCategories },
  zeroTrustCertificates: {
    zeroTrustCertificatesListZeroTrustCertificates,
    zeroTrustCertificatesCreateZeroTrustCertificate,
    zeroTrustCertificatesDeleteZeroTrustCertificate,
    zeroTrustCertificatesZeroTrustCertificateDetails,
    zeroTrustCertificatesActivateZeroTrustCertificate,
    zeroTrustCertificatesDeactivateZeroTrustCertificate
  },
  zeroTrustLists: {
    zeroTrustListsListZeroTrustLists,
    zeroTrustListsCreateZeroTrustList,
    zeroTrustListsDeleteZeroTrustList,
    zeroTrustListsZeroTrustListDetails,
    zeroTrustListsPatchZeroTrustList,
    zeroTrustListsUpdateZeroTrustList,
    zeroTrustListsZeroTrustListItems
  },
  zeroTrustGatewayLocations: {
    zeroTrustGatewayLocationsListZeroTrustGatewayLocations,
    zeroTrustGatewayLocationsCreateZeroTrustGatewayLocation,
    zeroTrustGatewayLocationsDeleteZeroTrustGatewayLocation,
    zeroTrustGatewayLocationsZeroTrustGatewayLocationDetails,
    zeroTrustGatewayLocationsUpdateZeroTrustGatewayLocation
  },
  zeroTrustGatewayProxyEndpoints: {
    zeroTrustGatewayProxyEndpointsListProxyEndpoints,
    zeroTrustGatewayProxyEndpointsCreateProxyEndpoint,
    zeroTrustGatewayProxyEndpointsDeleteProxyEndpoint,
    zeroTrustGatewayProxyEndpointsProxyEndpointDetails,
    zeroTrustGatewayProxyEndpointsUpdateProxyEndpoint
  },
  zeroTrustGatewayRules: {
    zeroTrustGatewayRulesListZeroTrustGatewayRules,
    zeroTrustGatewayRulesCreateZeroTrustGatewayRule,
    zeroTrustGatewayRulesDeleteZeroTrustGatewayRule,
    zeroTrustGatewayRulesZeroTrustGatewayRuleDetails,
    zeroTrustGatewayRulesUpdateZeroTrustGatewayRule,
    zeroTrustGatewayRulesResetExpirationZeroTrustGatewayRule
  },
  hyperdrive: { listHyperdrive, createHyperdrive, deleteHyperdrive, getHyperdrive, patchHyperdrive, updateHyperdrive },
  accountPermissionGroups: { accountPermissionGroupList, accountPermissionGroupDetails },
  accountResourceGroups: {
    accountResourceGroupList,
    accountResourceGroupCreate,
    accountResourceGroupDelete,
    accountResourceGroupDetails,
    accountResourceGroupUpdate
  },
  cloudflareImages: {
    cloudflareImagesListImages,
    cloudflareImagesUploadAnImageViaUrl,
    cloudflareImagesImagesUsageStatistics,
    cloudflareImagesDeleteImage,
    cloudflareImagesImageDetails,
    cloudflareImagesUpdateImage,
    cloudflareImagesBaseImage,
    cloudflareImagesListImagesV2,
    cloudflareImagesCreateAuthenticatedDirectUploadUrlV2
  },
  cloudflareImagesKeys: {
    cloudflareImagesKeysListSigningKeys,
    cloudflareImagesKeysDeleteSigningKey,
    cloudflareImagesKeysAddSigningKey
  },
  cloudflareImagesVariants: {
    cloudflareImagesVariantsListVariants,
    cloudflareImagesVariantsCreateAVariant,
    cloudflareImagesVariantsDeleteAVariant,
    cloudflareImagesVariantsVariantDetails,
    cloudflareImagesVariantsUpdateAVariant
  },
  infrastructureAccessTargets: {
    infraTargetsList,
    infraTargetsPost,
    infraTargetsDeleteBatch,
    infraTargetsPutBatch,
    infraTargetsDelete,
    infraTargetsGet,
    infraTargetsPut
  },
  aSNIntelligence: { asnIntelligenceGetAsnOverview, asnIntelligenceGetAsnSubnets },
  securityCenterInsights: {
    getSecurityCenterIssueTypes,
    getSecurityCenterIssues,
    getSecurityCenterIssueCountsByClass,
    getSecurityCenterIssueCountsBySeverity,
    getSecurityCenterIssueCountsByType,
    archiveSecurityCenterInsight
  },
  passiveDNSByIP: { passiveDnsByIpGetPassiveDnsByIp },
  domainIntelligence: { domainIntelligenceGetDomainDetails, domainIntelligenceGetMultipleDomainDetails },
  domainHistory: { domainHistoryGetDomainHistory },
  customIndicatorFeeds: {
    customIndicatorFeedsGetIndicatorFeeds,
    customIndicatorFeedsCreateIndicatorFeeds,
    customIndicatorFeedsAddPermission,
    customIndicatorFeedsRemovePermission,
    customIndicatorFeedsViewPermissions,
    customIndicatorFeedsGetIndicatorFeedMetadata,
    customIndicatorFeedsUpdateIndicatorFeedMetadata,
    customIndicatorFeedsGetIndicatorFeedData,
    customIndicatorFeedsUpdateIndicatorFeedData,
    customIndicatorFeedsDownloadIndicatorFeedData
  },
  iPIntelligence: { ipIntelligenceGetIpOverview },
  iPList: { ipListGetIpLists },
  miscategorization: { miscategorizationCreateMiscategorization },
  sinkholeConfig: { sinkholeConfigGetSinkholes },
  wHOISRecord: { whoisRecordGetWhoisRecord },
  accountLoadBalancerMonitors: {
    accountLoadBalancerMonitorsListMonitors,
    accountLoadBalancerMonitorsCreateMonitor,
    accountLoadBalancerMonitorsDeleteMonitor,
    accountLoadBalancerMonitorsMonitorDetails,
    accountLoadBalancerMonitorsPatchMonitor,
    accountLoadBalancerMonitorsUpdateMonitor,
    accountLoadBalancerMonitorsPreviewMonitor,
    accountLoadBalancerMonitorsListMonitorReferences,
    accountLoadBalancerMonitorsPreviewResult
  },
  accountLoadBalancerPools: {
    accountLoadBalancerPoolsListPools,
    accountLoadBalancerPoolsPatchPools,
    accountLoadBalancerPoolsCreatePool,
    accountLoadBalancerPoolsDeletePool,
    accountLoadBalancerPoolsPoolDetails,
    accountLoadBalancerPoolsPatchPool,
    accountLoadBalancerPoolsUpdatePool,
    accountLoadBalancerPoolsPoolHealthDetails,
    accountLoadBalancerPoolsPreviewPool,
    accountLoadBalancerPoolsListPoolReferences
  },
  loadBalancerRegions: { loadBalancerRegionsListRegions, loadBalancerRegionsGetRegion },
  accountLoadBalancerSearch: { accountLoadBalancerSearchSearchResources },
  logpushJobsForAnAccount: {
    getAccountsAccountIdLogpushDatasetsDatasetIdFields,
    getAccountsAccountIdLogpushDatasetsDatasetIdJobs,
    getAccountsAccountIdLogpushJobs,
    postAccountsAccountIdLogpushJobs,
    deleteAccountsAccountIdLogpushJobsJobId,
    getAccountsAccountIdLogpushJobsJobId,
    putAccountsAccountIdLogpushJobsJobId,
    postAccountsAccountIdLogpushOwnership,
    postAccountsAccountIdLogpushOwnershipValidate,
    deleteAccountsAccountIdLogpushValidateDestination,
    deleteAccountsAccountIdLogpushValidateDestinationExists,
    postAccountsAccountIdLogpushValidateOrigin
  },
  logcontrolCMBConfigForAnAccount: {
    deleteAccountsAccountIdLogsControlCmbConfig,
    getAccountsAccountIdLogsControlCmbConfig,
    postAccountsAccountIdLogsControlCmbConfig
  },
  magicAccountApps: {
    magicAccountAppsListApps,
    magicAccountAppsAddApp,
    magicAccountAppsDeleteApp,
    magicAccountAppsUpdateApp
  },
  magicInterconnects: {
    magicInterconnectsListInterconnects,
    magicInterconnectsUpdateMultipleInterconnects,
    magicInterconnectsListInterconnectDetails,
    magicInterconnectsUpdateInterconnect
  },
  magicConnectors: { mconnConnectorList, mconnConnectorFetch, mconnConnectorUpdate, mconnConnectorReplace },
  magicGRETunnels: {
    magicGreTunnelsListGreTunnels,
    magicGreTunnelsCreateGreTunnels,
    magicGreTunnelsUpdateMultipleGreTunnels,
    magicGreTunnelsDeleteGreTunnel,
    magicGreTunnelsListGreTunnelDetails,
    magicGreTunnelsUpdateGreTunnel
  },
  magicIPsecTunnels: {
    magicIpsecTunnelsListIpsecTunnels,
    magicIpsecTunnelsCreateIpsecTunnels,
    magicIpsecTunnelsUpdateMultipleIpsecTunnels,
    magicIpsecTunnelsDeleteIpsecTunnel,
    magicIpsecTunnelsListIpsecTunnelDetails,
    magicIpsecTunnelsUpdateIpsecTunnel,
    magicIpsecTunnelsGeneratePreSharedKeyPskForIpsecTunnels
  },
  magicStaticRoutes: {
    magicStaticRoutesDeleteManyRoutes,
    magicStaticRoutesListRoutes,
    magicStaticRoutesCreateRoutes,
    magicStaticRoutesUpdateManyRoutes,
    magicStaticRoutesDeleteRoute,
    magicStaticRoutesRouteDetails,
    magicStaticRoutesUpdateRoute
  },
  magicSites: {
    magicSitesListSites,
    magicSitesCreateSite,
    magicSitesDeleteSite,
    magicSitesSiteDetails,
    magicSitesPatchSite,
    magicSitesUpdateSite
  },
  magicSiteACLs: {
    magicSiteAclsListAcls,
    magicSiteAclsCreateAcl,
    magicSiteAclsDeleteAcl,
    magicSiteAclsAclDetails,
    magicSiteAclsPatchAcl,
    magicSiteAclsUpdateAcl
  },
  magicSiteAppConfigs: {
    magicSiteAppConfigsListAppConfigs,
    magicSiteAppConfigsAddAppConfig,
    magicSiteAppConfigsDeleteAppConfig,
    magicSiteAppConfigsUpdateAppConfig
  },
  magicSiteLANs: {
    magicSiteLansListLans,
    magicSiteLansCreateLan,
    magicSiteLansDeleteLan,
    magicSiteLansLanDetails,
    magicSiteLansPatchLan,
    magicSiteLansUpdateLan
  },
  magicSiteWANs: {
    magicSiteWansListWans,
    magicSiteWansCreateWan,
    magicSiteWansDeleteWan,
    magicSiteWansWanDetails,
    magicSiteWansPatchWan,
    magicSiteWansUpdateWan
  },
  accountMembers: {
    accountMembersListMembers,
    accountMembersAddMember,
    accountMembersRemoveMember,
    accountMembersMemberDetails,
    accountMembersUpdateMember
  },
  magicNetworkMonitoringConfiguration: {
    magicNetworkMonitoringConfigurationDeleteAccountConfiguration,
    magicNetworkMonitoringConfigurationListAccountConfiguration,
    magicNetworkMonitoringConfigurationUpdateAccountConfigurationFields,
    magicNetworkMonitoringConfigurationCreateAccountConfiguration,
    magicNetworkMonitoringConfigurationUpdateAnEntireAccountConfiguration,
    magicNetworkMonitoringConfigurationListRulesAndAccountConfiguration
  },
  magicNetworkMonitoringRules: {
    magicNetworkMonitoringRulesListRules,
    magicNetworkMonitoringRulesCreateRules,
    magicNetworkMonitoringRulesUpdateRules,
    magicNetworkMonitoringRulesDeleteRule,
    magicNetworkMonitoringRulesGetRule,
    magicNetworkMonitoringRulesUpdateRule,
    magicNetworkMonitoringRulesUpdateAdvertisementForRule
  },
  mTLSCertificateManagement: {
    mTlsCertificateManagementListMTlsCertificates,
    mTlsCertificateManagementUploadMTlsCertificate,
    mTlsCertificateManagementDeleteMTlsCertificate,
    mTlsCertificateManagementGetMTlsCertificate,
    mTlsCertificateManagementListMTlsCertificateAssociations
  },
  pagesProject: {
    pagesProjectGetProjects,
    pagesProjectCreateProject,
    pagesProjectDeleteProject,
    pagesProjectGetProject,
    pagesProjectUpdateProject
  },
  pagesDeployment: {
    pagesDeploymentGetDeployments,
    pagesDeploymentCreateDeployment,
    pagesDeploymentDeleteDeployment,
    pagesDeploymentGetDeploymentInfo,
    pagesDeploymentGetDeploymentLogs,
    pagesDeploymentRetryDeployment,
    pagesDeploymentRollbackDeployment
  },
  pagesDomains: {
    pagesDomainsGetDomains,
    pagesDomainsAddDomain,
    pagesDomainsDeleteDomain,
    pagesDomainsGetDomain,
    pagesDomainsPatchDomain
  },
  pagesBuildCache: { pagesPurgeBuildCache },
  magicPCAPCollection: {
    magicPcapCollectionListPacketCaptureRequests,
    magicPcapCollectionCreatePcapRequest,
    magicPcapCollectionListPcaPsBucketOwnership,
    magicPcapCollectionAddBucketsForFullPacketCaptures,
    magicPcapCollectionValidateBucketsForFullPacketCaptures,
    magicPcapCollectionDeleteBucketsForFullPacketCaptures,
    magicPcapCollectionGetPcapRequest,
    magicPcapCollectionDownloadSimplePcap
  },
  queue: {
    queuesList,
    queuesCreate,
    queuesDelete,
    queuesGet,
    queuesUpdate,
    queuesListConsumers,
    queuesCreateConsumer,
    queuesDeleteConsumer,
    queuesUpdateConsumer,
    queuesAckMessages,
    queuesPullMessages
  },
  registrarDomains: { registrarDomainsListDomains, registrarDomainsGetDomain, registrarDomainsUpdateDomain },
  accountRequestTracer: { accountRequestTracerRequestTrace },
  accountRoles: { accountRolesListRoles, accountRolesRoleDetails },
  accountRulesets: {
    listAccountRulesets,
    createAccountRuleset,
    getAccountEntrypointRuleset,
    updateAccountEntrypointRuleset,
    listAccountEntrypointRulesetVersions,
    getAccountEntrypointRulesetVersion,
    deleteAccountRuleset,
    getAccountRuleset,
    updateAccountRuleset,
    createAccountRulesetRule,
    deleteAccountRulesetRule,
    updateAccountRulesetRule,
    listAccountRulesetVersions,
    deleteAccountRulesetVersion,
    getAccountRulesetVersion,
    listAccountRulesetVersionRulesByTag
  },
  webAnalytics: {
    webAnalyticsCreateSite,
    webAnalyticsListSites,
    webAnalyticsDeleteSite,
    webAnalyticsGetSite,
    webAnalyticsUpdateSite,
    webAnalyticsCreateRule,
    webAnalyticsDeleteRule,
    webAnalyticsUpdateRule,
    webAnalyticsListRules,
    webAnalyticsModifyRules,
    webAnalyticsGetRumStatus,
    webAnalyticsToggleRum
  },
  secondaryDNSACL: {
    secondaryDnsAclListAcLs,
    secondaryDnsAclCreateAcl,
    secondaryDnsAclDeleteAcl,
    secondaryDnsAclAclDetails,
    secondaryDnsAclUpdateAcl
  },
  secondaryDNSPeer: {
    secondaryDnsPeerListPeers,
    secondaryDnsPeerCreatePeer,
    secondaryDnsPeerDeletePeer,
    secondaryDnsPeerPeerDetails,
    secondaryDnsPeerUpdatePeer
  },
  secondaryDNSTSIG: {
    secondaryDnsTsigListTsiGs,
    secondaryDnsTsigCreateTsig,
    secondaryDnsTsigDeleteTsig,
    secondaryDnsTsigTsigDetails,
    secondaryDnsTsigUpdateTsig
  },
  resourceSharing: {
    sharesList,
    shareCreate,
    shareDelete,
    sharesGetById,
    shareUpdate,
    shareRecipientsList,
    shareRecipientCreate,
    shareRecipientDelete,
    shareRecipientsGetById,
    shareResourcesList,
    shareResourceCreate,
    shareResourceDelete,
    shareResourcesGetById,
    shareResourceUpdate,
    organizationSharesList
  },
  workersKVRequestAnalyticsDeprecated: { workersKvRequestAnalyticsQueryRequestAnalytics },
  workersKVStoredDataAnalyticsDeprecated: { workersKvStoredDataAnalyticsQueryStoredDataAnalytics },
  workersKVNamespace: {
    workersKvNamespaceListNamespaces,
    workersKvNamespaceCreateANamespace,
    workersKvNamespaceRemoveANamespace,
    workersKvNamespaceGetANamespace,
    workersKvNamespaceRenameANamespace,
    workersKvNamespaceDeleteMultipleKeyValuePairsDeprecated,
    workersKvNamespaceWriteMultipleKeyValuePairs,
    workersKvNamespaceDeleteMultipleKeyValuePairs,
    workersKvNamespaceListANamespaceSKeys,
    workersKvNamespaceReadTheMetadataForAKey,
    workersKvNamespaceDeleteKeyValuePair,
    workersKvNamespaceReadKeyValuePair,
    workersKvNamespaceWriteKeyValuePairWithMetadata
  },
  streamVideos: {
    streamVideosListVideos,
    streamVideosInitiateVideoUploadsUsingTus,
    streamVideosUploadVideosFromAUrl,
    streamVideosUploadVideosViaDirectUploadUrLs,
    streamVideosStorageUsage,
    streamVideosDeleteVideo,
    streamVideosRetrieveVideoDetails,
    streamVideosUpdateVideoDetails,
    streamVideosRetreieveEmbedCodeHtml,
    streamVideosCreateSignedUrlTokensForVideos
  },
  streamVideoClipping: { streamVideoClippingClipVideosGivenAStartAndEndTime },
  streamSigningKeys: {
    streamSigningKeysListSigningKeys,
    streamSigningKeysCreateSigningKeys,
    streamSigningKeysDeleteSigningKeys
  },
  streamLiveInputs: {
    streamLiveInputsListLiveInputs,
    streamLiveInputsCreateALiveInput,
    streamLiveInputsDeleteALiveInput,
    streamLiveInputsRetrieveALiveInput,
    streamLiveInputsUpdateALiveInput,
    streamLiveInputsListAllOutputsAssociatedWithASpecifiedLiveInput,
    streamLiveInputsCreateANewOutputConnectedToALiveInput,
    streamLiveInputsDeleteAnOutput,
    streamLiveInputsUpdateAnOutput
  },
  streamWatermarkProfile: {
    streamWatermarkProfileListWatermarkProfiles,
    streamWatermarkProfileCreateWatermarkProfilesViaBasicUpload,
    streamWatermarkProfileDeleteWatermarkProfiles,
    streamWatermarkProfileWatermarkProfileDetails
  },
  streamWebhook: { streamWebhookDeleteWebhooks, streamWebhookViewWebhooks, streamWebhookCreateWebhooks },
  streamAudioTracks: { listAudioTracks, addAudioTrack, deleteAudioTracks, editAudioTracks },
  streamSubtitlesCaptions: {
    streamSubtitlesCaptionsListCaptionsOrSubtitles,
    streamSubtitlesCaptionsDeleteCaptionsOrSubtitles,
    streamSubtitlesCaptionsGetCaptionOrSubtitleForLanguage,
    streamSubtitlesCaptionsUploadCaptionsOrSubtitles,
    streamSubtitlesCaptionsGenerateCaptionOrSubtitleForLanguage,
    streamSubtitlesCaptionsGetVttCaptionOrSubtitle
  },
  streamMP4Downloads: {
    streamMP4DownloadsDeleteDownloads,
    streamMP4DownloadsListDownloads,
    streamMP4DownloadsCreateDownloads
  },
  accountSubscriptions: {
    accountSubscriptionsListSubscriptions,
    accountSubscriptionsCreateSubscription,
    accountSubscriptionsDeleteSubscription,
    accountSubscriptionsUpdateSubscription
  },
  tunnelRouting: {
    tunnelRouteListTunnelRoutes,
    tunnelRouteCreateATunnelRoute,
    tunnelRouteGetTunnelRouteByIp,
    tunnelRouteDeleteATunnelRouteWithCidr,
    tunnelRouteUpdateATunnelRouteWithCidr,
    tunnelRouteCreateATunnelRouteWithCidr,
    tunnelRouteDeleteATunnelRoute,
    tunnelRouteGetTunnelRoute,
    tunnelRouteUpdateATunnelRoute
  },
  tunnelVirtualNetwork: {
    tunnelVirtualNetworkListVirtualNetworks,
    tunnelVirtualNetworkCreateAVirtualNetwork,
    tunnelVirtualNetworkDelete,
    tunnelVirtualNetworkGet,
    tunnelVirtualNetworkUpdate
  },
  accountOwnedAPITokens: {
    accountApiTokensListTokens,
    accountApiTokensCreateToken,
    accountApiTokensListPermissionGroups,
    accountApiTokensVerifyToken,
    accountApiTokensDeleteToken,
    accountApiTokensTokenDetails,
    accountApiTokensUpdateToken,
    accountApiTokensRollToken
  },
  uRLScanner: {
    urlscannerGetResponseText,
    urlscannerSearchScans,
    urlscannerCreateScan,
    urlscannerGetScan,
    urlscannerGetScanHar,
    urlscannerGetScanScreenshot
  },
  uRLScannerBeta: {
    urlscannerCreateScanBulkV2,
    urlscannerGetScanDomV2,
    urlscannerGetScanHarV2,
    urlscannerGetResponseV2,
    urlscannerGetScanV2,
    urlscannerCreateScanV2,
    urlscannerGetScanScreenshotV2,
    urlscannerSearchScansV2
  },
  vectorizeBetaDeprecated: {
    vectorizeDeprecatedListVectorizeIndexes,
    vectorizeDeprecatedCreateVectorizeIndex,
    vectorizeDeprecatedDeleteVectorizeIndex,
    vectorizeDeprecatedGetVectorizeIndex,
    vectorizeDeprecatedUpdateVectorizeIndex,
    vectorizeDeprecatedDeleteVectorsById,
    vectorizeDeprecatedGetVectorsById,
    vectorizeDeprecatedInsertVector,
    vectorizeDeprecatedQueryVector,
    vectorizeDeprecatedUpsertVector
  },
  vectorize: {
    vectorizeListVectorizeIndexes,
    vectorizeCreateVectorizeIndex,
    vectorizeDeleteVectorizeIndex,
    vectorizeGetVectorizeIndex,
    vectorizeDeleteVectorsById,
    vectorizeGetVectorsById,
    vectorizeIndexInfo,
    vectorizeInsertVector,
    vectorizeCreateMetadataIndex,
    vectorizeDeleteMetadataIndex,
    vectorizeListMetadataIndexes,
    vectorizeQueryVector,
    vectorizeUpsertVector
  },
  workerAccountSettings: {
    workerAccountSettingsFetchWorkerAccountSettings,
    workerAccountSettingsCreateWorkerAccountSettings
  },
  workerScript: {
    workerAssetsUpload,
    workerScriptListWorkers,
    workerScriptDeleteWorker,
    workerScriptDownloadWorker,
    workerScriptUploadWorkerModule,
    workerScriptUpdateCreateAssetsUploadSession,
    workerScriptPutContent,
    workerScriptGetContent,
    workerScriptSettingsGetSettings,
    workerScriptSettingsPatchSettings,
    workerScriptGetSettings,
    workerScriptPatchSettings,
    workerScriptGetSubdomain,
    workerScriptPostSubdomain,
    workerScriptFetchUsageModel,
    workerScriptUpdateUsageModel
  },
  workersForPlatforms: {
    namespaceWorkerList,
    namespaceWorkerCreate,
    namespaceWorkerDeleteNamespace,
    namespaceWorkerGetNamespace,
    namespaceWorkerScriptDeleteWorker,
    namespaceWorkerScriptWorkerDetails,
    namespaceWorkerScriptUploadWorkerModule,
    namespaceWorkerScriptUpdateCreateAssetsUploadSession,
    namespaceWorkerGetScriptBindings,
    namespaceWorkerGetScriptContent,
    namespaceWorkerPutScriptContent,
    namespaceWorkerListScriptSecrets,
    namespaceWorkerPutScriptSecrets,
    namespaceWorkerGetScriptSecrets,
    namespaceWorkerGetScriptSettings,
    namespaceWorkerPatchScriptSettings,
    namespaceWorkerGetScriptTags,
    namespaceWorkerPutScriptTags,
    namespaceWorkerDeleteScriptTag,
    namespaceWorkerPutScriptTag
  },
  workerDomain: {
    workerDomainListDomains,
    workerDomainAttachToDomain,
    workerDomainDetachFromDomain,
    workerDomainGetADomain
  },
  durableObjectsNamespace: { durableObjectsNamespaceListNamespaces, durableObjectsNamespaceListObjects },
  workerDeployments: { workerDeploymentsListDeployments, workerDeploymentsCreateDeployment },
  workerCronTrigger: { workerCronTriggerGetCronTriggers, workerCronTriggerUpdateCronTriggers },
  workerTailLogs: {
    getAccountsAccountIdWorkersScriptsScriptNameTails,
    workerTailLogsStartTail,
    workerTailLogsDeleteTail
  },
  workerVersions: { workerVersionsListVersions, workerVersionsUploadVersion, workerVersionsGetVersionDetail },
  workerEnvironment: {
    workerEnvironmentGetScriptContent,
    workerEnvironmentPutScriptContent,
    workerScriptEnvironmentGetSettings,
    workerScriptEnvironmentPatchSettings
  },
  workerSubdomain: { workerSubdomainGetSubdomain, workerSubdomainCreateSubdomain },
  workflows: {
    worListWorkflows,
    worGetWorkflowDetails,
    worCreateOrModifyWorkflow,
    worListWorkflowInstances,
    worCreateNewWorkflowInstance,
    worDescribeWorkflowInstance,
    worChangeStatusWorkflowInstance,
    worListWorkflowVersions,
    worDescribeWorkflowVersions
  },
  zeroTrustConnectivitySettings: {
    zeroTrustAccountsGetConnectivitySettings,
    zeroTrustAccountsPatchConnectivitySettings
  },
  zeroTrustRiskScoring: {
    dlpRiskScoreBehaviorsGet,
    dlpRiskScoreBehaviorsPut,
    dlpRiskScoreSummaryGet,
    dlpRiskScoreSummaryGetForUser,
    dlpRiskScoreResetPost
  },
  zeroTrustRiskScoringIntegrations: {
    dlpZtRiskScoreIntegrationList,
    dlpZtRiskScoreIntegrationCreate,
    dlpZtRiskScoreIntegrationGetByReferenceId,
    dlpZtRiskScoreIntegrationDelete,
    dlpZtRiskScoreIntegrationGet,
    dlpZtRiskScoreIntegrationUpdate
  },
  originCA: { originCaListCertificates, originCaCreateCertificate, originCaRevokeCertificate, originCaGetCertificate },
  cloudflareIPs: { cloudflareIPsCloudflareIpDetails },
  usersAccountMemberships: {
    userSAccountMembershipsListMemberships,
    userSAccountMembershipsDeleteMembership,
    userSAccountMembershipsMembershipDetails,
    userSAccountMembershipsUpdateMembership
  },
  radarAIBots: { radarGetAiBotsSummaryByUserAgent, radarGetAiBotsTimeseriesGroupByUserAgent },
  radarAnnotations: { radarGetAnnotations, radarGetAnnotationsOutages, radarGetAnnotationsOutagesTop },
  radarAS112: {
    radarGetDnsAs112TimeseriesByDnssec,
    radarGetDnsAs112TimeseriesByEdns,
    radarGetDnsAs112TimeseriesByIpVersion,
    radarGetDnsAs112TimeseriesByProtocol,
    radarGetDnsAs112TimeseriesByQueryType,
    radarGetDnsAs112TimeseriesByResponseCodes,
    radarGetDnsAs112Timeseries,
    radarGetDnsAs112TimeseriesGroupByDnssec,
    radarGetDnsAs112TimeseriesGroupByEdns,
    radarGetDnsAs112TimeseriesGroupByIpVersion,
    radarGetDnsAs112TimeseriesGroupByProtocol,
    radarGetDnsAs112TimeseriesGroupByQueryType,
    radarGetDnsAs112TimeseriesGroupByResponseCodes,
    radarGetDnsAs112TopLocations,
    radarGetDnsAs112TopLocationsByDnssec,
    radarGetDnsAs112TopLocationsByEdns,
    radarGetDnsAs112TopLocationsByIpVersion
  },
  radarAttacks: {
    radarGetAttacksLayer3Summary,
    radarGetAttacksLayer3SummaryByBitrate,
    radarGetAttacksLayer3SummaryByDuration,
    radarGetAttacksLayer3SummaryByIpVersion,
    radarGetAttacksLayer3SummaryByProtocol,
    radarGetAttacksLayer3SummaryByVector,
    radarGetAttacksLayer3TimeseriesByBytes,
    radarGetAttacksLayer3TimeseriesGroups,
    radarGetAttacksLayer3TimeseriesGroupByBitrate,
    radarGetAttacksLayer3TimeseriesGroupByDuration,
    radarGetAttacksLayer3TimeseriesGroupByIndustry,
    radarGetAttacksLayer3TimeseriesGroupByIpVersion,
    radarGetAttacksLayer3TimeseriesGroupByProtocol,
    radarGetAttacksLayer3TimeseriesGroupByVector,
    radarGetAttacksLayer3TimeseriesGroupByVertical,
    radarGetAttacksLayer3TopAttacks,
    radarGetAttacksLayer3TopIndustries,
    radarGetAttacksLayer3TopOriginLocations,
    radarGetAttacksLayer3TopTargetLocations,
    radarGetAttacksLayer3TopVerticals,
    radarGetAttacksLayer7Summary,
    radarGetAttacksLayer7SummaryByHttpMethod,
    radarGetAttacksLayer7SummaryByHttpVersion,
    radarGetAttacksLayer7SummaryByIpVersion,
    radarGetAttacksLayer7SummaryByManagedRules,
    radarGetAttacksLayer7SummaryByMitigationProduct,
    radarGetAttacksLayer7Timeseries,
    radarGetAttacksLayer7TimeseriesGroup,
    radarGetAttacksLayer7TimeseriesGroupByHttpMethod,
    radarGetAttacksLayer7TimeseriesGroupByHttpVersion,
    radarGetAttacksLayer7TimeseriesGroupByIndustry,
    radarGetAttacksLayer7TimeseriesGroupByIpVersion,
    radarGetAttacksLayer7TimeseriesGroupByManagedRules,
    radarGetAttacksLayer7TimeseriesGroupByMitigationProduct,
    radarGetAttacksLayer7TimeseriesGroupByVertical,
    radarGetAttacksLayer7TopOriginAs,
    radarGetAttacksLayer7TopAttacks,
    radarGetAttacksLayer7TopIndustries,
    radarGetAttacksLayer7TopOriginLocation,
    radarGetAttacksLayer7TopTargetLocation,
    radarGetAttacksLayer7TopVerticals
  },
  radarBGP: {
    radarGetBgpHijacksEvents,
    radarGetBgpIpsTimeseries,
    radarGetBgpRouteLeakEvents,
    radarGetBgpRoutesAsns,
    radarGetBgpPfx2asMoas,
    radarGetBgpPfx2as,
    radarGetBgpRoutesStats,
    radarGetBgpTimeseries,
    radarGetBgpTopAses,
    radarGetBgpTopAsnsByPrefixes,
    radarGetBgpTopPrefixes
  },
  radarDatasets: { radarGetReportsDatasets, radarPostReportsDatasetDownloadUrl, radarGetReportsDatasetDownload },
  radarDNS: { radarGetDnsTopAses, radarGetDnsTopLocations },
  radarEmailRouting: {
    radarGetEmailRoutingSummaryByArc,
    radarGetEmailRoutingSummaryByDkim,
    radarGetEmailRoutingSummaryByDmarc,
    radarGetEmailRoutingSummaryByEncrypted,
    radarGetEmailRoutingSummaryByIpVersion,
    radarGetEmailRoutingSummaryBySpf,
    radarGetEmailRoutingTimeseriesGroupByArc,
    radarGetEmailRoutingTimeseriesGroupByDkim,
    radarGetEmailRoutingTimeseriesGroupByDmarc,
    radarGetEmailRoutingTimeseriesGroupByEncrypted,
    radarGetEmailRoutingTimeseriesGroupByIpVersion,
    radarGetEmailRoutingTimeseriesGroupBySpf
  },
  radarEmailSecurity: {
    radarGetEmailSecuritySummaryByArc,
    radarGetEmailSecuritySummaryByDkim,
    radarGetEmailSecuritySummaryByDmarc,
    radarGetEmailSecuritySummaryByMalicious,
    radarGetEmailSecuritySummaryBySpam,
    radarGetEmailSecuritySummaryBySpf,
    radarGetEmailSecuritySummaryBySpoof,
    radarGetEmailSecuritySummaryByThreatCategory,
    radarGetEmailSecuritySummaryByTlsVersion,
    radarGetEmailSecurityTimeseriesGroupByArc,
    radarGetEmailSecurityTimeseriesGroupByDkim,
    radarGetEmailSecurityTimeseriesGroupByDmarc,
    radarGetEmailSecurityTimeseriesGroupByMalicious,
    radarGetEmailSecurityTimeseriesGroupBySpam,
    radarGetEmailSecurityTimeseriesGroupBySpf,
    radarGetEmailSecurityTimeseriesGroupBySpoof,
    radarGetEmailSecurityTimeseriesGroupByThreatCategory,
    radarGetEmailSecurityTimeseriesGroupByTlsVersion,
    radarGetEmailSecurityTopTldsByMessages,
    radarGetEmailSecurityTopTldsByMalicious,
    radarGetEmailSecurityTopTldsBySpam,
    radarGetEmailSecurityTopTldsBySpoof
  },
  radarEntities: {
    radarGetEntitiesAsnList,
    radarGetEntitiesAsnByIp,
    radarGetEntitiesAsnById,
    radarGetAsnsRel,
    radarGetEntitiesIp,
    radarGetEntitiesLocations,
    radarGetEntitiesLocationByAlpha2
  },
  radarHttp: {
    radarGetHttpSummaryByBotClass,
    radarGetHttpSummaryByDeviceType,
    radarGetHttpSummaryByHttpProtocol,
    radarGetHttpSummaryByHttpVersion,
    radarGetHttpSummaryByIpVersion,
    radarGetHttpSummaryByOperatingSystem,
    radarGetHttpSummaryByPostQuantum,
    radarGetHttpSummaryByTlsVersion,
    radarGetHttpTimeseries,
    radarGetHttpTimeseriesGroupByBotClass,
    radarGetHttpTimeseriesGroupByBrowsers,
    radarGetHttpTimeseriesGroupByBrowserFamilies,
    radarGetHttpTimeseriesGroupByDeviceType,
    radarGetHttpTimeseriesGroupByHttpProtocol,
    radarGetHttpTimeseriesGroupByHttpVersion,
    radarGetHttpTimeseriesGroupByIpVersion,
    radarGetHttpTimeseriesGroupByOperatingSystem,
    radarGetHttpTimeseriesGroupByPostQuantum,
    radarGetHttpTimeseriesGroupByTlsVersion,
    radarGetHttpTopAsesByHttpRequests,
    radarGetHttpTopAsesByBotClass,
    radarGetHttpTopAsesByBrowserFamily,
    radarGetHttpTopAsesByDeviceType,
    radarGetHttpTopAsesByHttpProtocol,
    radarGetHttpTopAsesByHttpVersion,
    radarGetHttpTopAsesByIpVersion,
    radarGetHttpTopAsesByOperatingSystem,
    radarGetHttpTopAsesByTlsVersion,
    radarGetHttpTopBrowsers,
    radarGetHttpTopBrowserFamilies,
    radarGetHttpTopLocationsByHttpRequests,
    radarGetHttpTopLocationsByBotClass,
    radarGetHttpTopLocationsByBrowserFamily,
    radarGetHttpTopLocationsByDeviceType,
    radarGetHttpTopLocationsByHttpProtocol,
    radarGetHttpTopLocationsByHttpVersion,
    radarGetHttpTopLocationsByIpVersion,
    radarGetHttpTopLocationsByOperatingSystem,
    radarGetHttpTopLocationsByTlsVersion
  },
  radarNetflows: {
    radarGetNetflowsSummary,
    radarGetNetflowsTimeseries,
    radarGetNetflowsTopAses,
    radarGetNetflowsTopLocations
  },
  radarQuality: {
    radarGetQualityIndexSummary,
    radarGetQualityIndexTimeseriesGroup,
    radarGetQualitySpeedHistogram,
    radarGetQualitySpeedSummary,
    radarGetQualitySpeedTopAses,
    radarGetQualitySpeedTopLocations
  },
  radarRanking: { radarGetRankingDomainDetails, radarGetRankingDomainTimeseries, radarGetRankingTopDomains },
  radarSearch: { radarGetSearchGlobal },
  radarTCPResetsTimeouts: { radarGetTcpResetsTimeoutsSummary, radarGetTcpResetsTimeoutsTimeseriesGroup },
  radarTrafficAnomalies: { radarGetTrafficAnomalies, radarGetTrafficAnomaliesTop },
  radarVerifiedBots: { radarGetVerifiedBotsTopByHttpRequests, radarGetVerifiedBotsTopCategoriesByHttpRequests },
  user: { userUserDetails, userEditUser },
  userBillingHistory: { userBillingHistoryDeprecatedBillingHistoryDetails },
  userBillingProfile: { userBillingProfileDeprecatedBillingProfileDetails },
  iPAccessRulesForAUser: {
    ipAccessRulesForAUserListIpAccessRules,
    ipAccessRulesForAUserCreateAnIpAccessRule,
    ipAccessRulesForAUserDeleteAnIpAccessRule,
    ipAccessRulesForAUserUpdateAnIpAccessRule
  },
  usersInvites: { userSInvitesListInvitations, userSInvitesInvitationDetails, userSInvitesRespondToInvitation },
  loadBalancerMonitors: {
    loadBalancerMonitorsListMonitors,
    loadBalancerMonitorsCreateMonitor,
    loadBalancerMonitorsDeleteMonitor,
    loadBalancerMonitorsMonitorDetails,
    loadBalancerMonitorsPatchMonitor,
    loadBalancerMonitorsUpdateMonitor,
    loadBalancerMonitorsPreviewMonitor,
    loadBalancerMonitorsListMonitorReferences,
    loadBalancerMonitorsPreviewResult
  },
  loadBalancerPools: {
    loadBalancerPoolsListPools,
    loadBalancerPoolsPatchPools,
    loadBalancerPoolsCreatePool,
    loadBalancerPoolsDeletePool,
    loadBalancerPoolsPoolDetails,
    loadBalancerPoolsPatchPool,
    loadBalancerPoolsUpdatePool,
    loadBalancerPoolsPoolHealthDetails,
    loadBalancerPoolsPreviewPool,
    loadBalancerPoolsListPoolReferences
  },
  loadBalancerHealthcheckEvents: { loadBalancerHealthcheckEventsListHealthcheckEvents },
  usersOrganizations: {
    userSOrganizationsListOrganizations,
    userSOrganizationsLeaveOrganization,
    userSOrganizationsOrganizationDetails
  },
  userSubscription: {
    userSubscriptionGetUserSubscriptions,
    userSubscriptionDeleteUserSubscription,
    userSubscriptionUpdateUserSubscription
  },
  userAPITokens: {
    userApiTokensListTokens,
    userApiTokensCreateToken,
    permissionGroupsListPermissionGroups,
    userApiTokensVerifyToken,
    userApiTokensDeleteToken,
    userApiTokensTokenDetails,
    userApiTokensUpdateToken,
    userApiTokensRollToken
  },
  zone: { zonesGet, zonesPost, zones0Delete, zones0Get, zones0Patch, putZonesZoneIdActivationCheck, zonePurge },
  zoneSubscription: {
    zoneSubscriptionZoneSubscriptionDetails,
    zoneSubscriptionCreateZoneSubscription,
    zoneSubscriptionUpdateZoneSubscription
  },
  zoneAnalyticsDeprecated: { zoneAnalyticsDeprecatedGetAnalyticsByCoLocations, zoneAnalyticsDeprecatedGetDashboard },
  customPagesForAZone: {
    customPagesForAZoneListCustomPages,
    customPagesForAZoneGetACustomPage,
    customPagesForAZoneUpdateACustomPage
  },
  sSLTLSModeRecommendation: { sslTlsModeRecommendationSslTlsRecommendation },
  zoneLevelAccessApplications: {
    zoneLevelAccessApplicationsListAccessApplications,
    zoneLevelAccessApplicationsAddABookmarkApplication,
    zoneLevelAccessApplicationsDeleteAnAccessApplication,
    zoneLevelAccessApplicationsGetAnAccessApplication,
    zoneLevelAccessApplicationsUpdateABookmarkApplication,
    zoneLevelAccessApplicationsRevokeServiceTokens,
    zoneLevelAccessApplicationsTestAccessPolicies
  },
  zoneLevelAccessShortLivedCertificateCAs: {
    zoneLevelAccessShortLivedCertificateCAsListShortLivedCertificateCAs,
    zoneLevelAccessShortLivedCertificateCAsDeleteAShortLivedCertificateCa,
    zoneLevelAccessShortLivedCertificateCAsGetAShortLivedCertificateCa,
    zoneLevelAccessShortLivedCertificateCAsCreateAShortLivedCertificateCa
  },
  zoneLevelAccessPolicies: {
    zoneLevelAccessPoliciesListAccessPolicies,
    zoneLevelAccessPoliciesCreateAnAccessPolicy,
    zoneLevelAccessPoliciesDeleteAnAccessPolicy,
    zoneLevelAccessPoliciesGetAnAccessPolicy,
    zoneLevelAccessPoliciesUpdateAnAccessPolicy
  },
  zoneLevelAccessMTLSAuthentication: {
    zoneLevelAccessMtlsAuthenticationListMtlsCertificates,
    zoneLevelAccessMtlsAuthenticationAddAnMtlsCertificate,
    zoneLevelAccessMtlsAuthenticationListMtlsCertificatesHostnameSettings,
    zoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificateSettings,
    zoneLevelAccessMtlsAuthenticationDeleteAnMtlsCertificate,
    zoneLevelAccessMtlsAuthenticationGetAnMtlsCertificate,
    zoneLevelAccessMtlsAuthenticationUpdateAnMtlsCertificate
  },
  zoneLevelAccessGroups: {
    zoneLevelAccessGroupsListAccessGroups,
    zoneLevelAccessGroupsCreateAnAccessGroup,
    zoneLevelAccessGroupsDeleteAnAccessGroup,
    zoneLevelAccessGroupsGetAnAccessGroup,
    zoneLevelAccessGroupsUpdateAnAccessGroup
  },
  zoneLevelAccessIdentityProviders: {
    zoneLevelAccessIdentityProvidersListAccessIdentityProviders,
    zoneLevelAccessIdentityProvidersAddAnAccessIdentityProvider,
    zoneLevelAccessIdentityProvidersDeleteAnAccessIdentityProvider,
    zoneLevelAccessIdentityProvidersGetAnAccessIdentityProvider,
    zoneLevelAccessIdentityProvidersUpdateAnAccessIdentityProvider
  },
  zoneLevelZeroTrustOrganization: {
    zoneLevelZeroTrustOrganizationGetYourZeroTrustOrganization,
    zoneLevelZeroTrustOrganizationCreateYourZeroTrustOrganization,
    zoneLevelZeroTrustOrganizationUpdateYourZeroTrustOrganization,
    zoneLevelZeroTrustOrganizationRevokeAllAccessTokensForAUser
  },
  zoneLevelAccessServiceTokens: {
    zoneLevelAccessServiceTokensListServiceTokens,
    zoneLevelAccessServiceTokensCreateAServiceToken,
    zoneLevelAccessServiceTokensDeleteAServiceToken,
    zoneLevelAccessServiceTokensGetAServiceToken,
    zoneLevelAccessServiceTokensUpdateAServiceToken
  },
  totalTLS: { totalTlsTotalTlsSettingsDetails, totalTlsEnableOrDisableTotalTls },
  argoAnalyticsForZone: { argoAnalyticsForZoneArgoAnalyticsForAZone },
  argoAnalyticsForGeolocation: { argoAnalyticsForGeolocationArgoAnalyticsForAZoneAtDifferentPoPs },
  aPIShieldSettings: {
    apiShieldSettingsRetrieveInformationAboutSpecificConfigurationProperties,
    apiShieldSettingsSetConfigurationProperties
  },
  aPIShieldAPIDiscovery: {
    apiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZoneAsOpenapi,
    apiShieldApiDiscoveryRetrieveDiscoveredOperationsOnAZone,
    apiShieldApiPatchDiscoveredOperations,
    apiShieldApiPatchDiscoveredOperation
  },
  aPIShieldWAFExpressionTemplates: { apiShieldExpressionTemplatesFallthrough },
  aPIShieldEndpointManagement: {
    apiShieldEndpointManagementDeleteMultipleOperations,
    apiShieldEndpointManagementRetrieveInformationAboutAllOperationsOnAZone,
    apiShieldEndpointManagementAddOperationsToAZone,
    apiShieldEndpointManagementAddOperationToAZone,
    apiShieldEndpointManagementDeleteAnOperation,
    apiShieldEndpointManagementRetrieveInformationAboutAnOperation,
    apiShieldEndpointManagementRetrieveOperationsAndFeaturesAsOpenApiSchemas
  },
  aPIShieldSchemaValidation20: {
    apiShieldSchemaValidationUpdateMultipleOperationLevelSettings,
    apiShieldSchemaValidationRetrieveOperationLevelSettings,
    apiShieldSchemaValidationUpdateOperationLevelSettings,
    apiShieldSchemaValidationRetrieveZoneLevelSettings,
    apiShieldSchemaValidationPatchZoneLevelSettings,
    apiShieldSchemaValidationUpdateZoneLevelSettings,
    apiShieldSchemaValidationRetrieveInformationAboutAllSchemas,
    apiShieldSchemaValidationPostSchema,
    apiShieldSchemaValidationRetrieveUserSchemaHosts,
    apiShieldSchemaDeleteASchema,
    apiShieldSchemaValidationRetrieveInformationAboutSpecificSchema,
    apiShieldSchemaValidationEnableValidationForASchema,
    apiShieldSchemaValidationExtractOperationsFromSchema
  },
  argoSmartRouting: { argoSmartRoutingGetArgoSmartRoutingSetting, argoSmartRoutingPatchArgoSmartRoutingSetting },
  tieredCaching: { tieredCachingGetTieredCachingSetting, tieredCachingPatchTieredCachingSetting },
  zoneRatePlan: {
    zoneRatePlanListAvailablePlans,
    zoneRatePlanAvailablePlanDetails,
    zoneRatePlanListAvailableRatePlans
  },
  botSettings: { botManagementForAZoneGetConfig, botManagementForAZoneUpdateConfig },
  zoneCacheSettings: {
    zoneCacheSettingsGetCacheReserveSetting,
    zoneCacheSettingsChangeCacheReserveSetting,
    zoneCacheSettingsGetCacheReserveClear,
    zoneCacheSettingsStartCacheReserveClear,
    zoneCacheSettingsGetRegionalTieredCacheSetting,
    zoneCacheSettingsChangeRegionalTieredCacheSetting,
    zoneCacheSettingsDeleteVariantsSetting,
    zoneCacheSettingsGetVariantsSetting,
    zoneCacheSettingsChangeVariantsSetting,
    zoneCacheSettingsGetAegisSetting,
    zoneCacheSettingsGetOriginMaxHttpVersionSetting
  },
  originPostQuantum: {
    zoneCacheSettingsGetOriginPostQuantumEncryptionSetting,
    zoneCacheSettingsChangeOriginPostQuantumEncryptionSetting
  },
  smartTieredCache: {
    smartTieredCacheDeleteSmartTieredCacheSetting,
    smartTieredCacheGetSmartTieredCacheSetting,
    smartTieredCachePatchSmartTieredCacheSetting
  },
  aPIShieldClientCertificatesForAZone: {
    clientCertificateForAZoneListHostnameAssociations,
    clientCertificateForAZonePutHostnameAssociations,
    clientCertificateForAZoneListClientCertificates,
    clientCertificateForAZoneCreateClientCertificate,
    clientCertificateForAZoneDeleteClientCertificate,
    clientCertificateForAZoneClientCertificateDetails,
    clientCertificateForAZoneEditClientCertificate
  },
  zoneCloudConnectorRulesGET: { zoneCloudConnectorRules },
  zoneCloudConnectorRulesPUT: { zoneCloudConenctorRulesPut },
  contentScanning: {
    wafContentScanningDisable,
    wafContentScanningEnable,
    wafContentScanningListCustomScanExpressions,
    wafContentScanningAddCustomScanExpressions,
    wafContentScanningDeleteCustomScanExpressions,
    wafContentScanningGetStatus
  },
  customSSLForAZone: {
    customSslForAZoneListSslConfigurations,
    customSslForAZoneCreateSslConfiguration,
    customSslForAZoneRePrioritizeSslCertificates,
    customSslForAZoneDeleteSslConfiguration,
    customSslForAZoneSslConfigurationDetails,
    customSslForAZoneEditSslConfiguration
  },
  customHostnameForAZone: {
    customHostnameForAZoneListCustomHostnames,
    customHostnameForAZoneCreateCustomHostname,
    customHostnameForAZoneDeleteCustomHostnameAndAnyIssuedSslCertificates,
    customHostnameForAZoneCustomHostnameDetails,
    customHostnameForAZoneEditCustomHostname
  },
  customHostnameFallbackOriginForAZone: {
    customHostnameFallbackOriginForAZoneDeleteFallbackOriginForCustomHostnames,
    customHostnameFallbackOriginForAZoneGetFallbackOriginForCustomHostnames,
    customHostnameFallbackOriginForAZoneUpdateFallbackOriginForCustomHostnames
  },
  accountLevelCustomNameserversUsageForAZone: {
    accountLevelCustomNameserversUsageForAZoneGetAccountCustomNameserverRelatedZoneMetadata,
    accountLevelCustomNameserversUsageForAZoneSetAccountCustomNameserverRelatedZoneMetadata
  },
  dCVDelegation: { dcvDelegationUuidGet },
  dNSAnalytics: { dnsAnalyticsTable, dnsAnalyticsByTime },
  dNSRecordsForAZone: {
    dnsRecordsForAZoneListDnsRecords,
    dnsRecordsForAZoneCreateDnsRecord,
    dnsRecordsForAZoneBatchDnsRecords,
    dnsRecordsForAZoneExportDnsRecords,
    dnsRecordsForAZoneImportDnsRecords,
    dnsRecordsForAZoneScanDnsRecords,
    dnsRecordsForAZoneDeleteDnsRecord,
    dnsRecordsForAZoneDnsRecordDetails,
    dnsRecordsForAZonePatchDnsRecord,
    dnsRecordsForAZoneUpdateDnsRecord
  },
  dNSSettingsForAZone: { dnsSettingsForAZoneListDnsSettings, dnsSettingsForAZoneUpdateDnsSettings },
  dnssec: { dnssecDeleteDnssecRecords, dnssecDnssecDetails, dnssecEditDnssecStatus },
  emailRoutingSettings: {
    emailRoutingSettingsGetEmailRoutingSettings,
    emailRoutingSettingsDisableEmailRouting,
    emailRoutingSettingsDisableEmailRoutingDns,
    emailRoutingSettingsEmailRoutingDnsSettings,
    emailRoutingSettingsUnlockEmailRoutingDns,
    emailRoutingSettingsEnableEmailRoutingDns,
    emailRoutingSettingsEnableEmailRouting
  },
  emailRoutingRoutingRules: {
    emailRoutingRoutingRulesListRoutingRules,
    emailRoutingRoutingRulesCreateRoutingRule,
    emailRoutingRoutingRulesGetCatchAllRule,
    emailRoutingRoutingRulesUpdateCatchAllRule,
    emailRoutingRoutingRulesDeleteRoutingRule,
    emailRoutingRoutingRulesGetRoutingRule,
    emailRoutingRoutingRulesUpdateRoutingRule
  },
  filters: {
    filtersDeleteFilters,
    filtersListFilters,
    filtersCreateFilters,
    filtersUpdateFilters,
    filtersDeleteAFilter,
    filtersGetAFilter,
    filtersUpdateAFilter
  },
  iPAccessRulesForAZone: {
    ipAccessRulesForAZoneListIpAccessRules,
    ipAccessRulesForAZoneCreateAnIpAccessRule,
    ipAccessRulesForAZoneDeleteAnIpAccessRule,
    ipAccessRulesForAZoneUpdateAnIpAccessRule
  },
  zoneLockdown: {
    zoneLockdownListZoneLockdownRules,
    zoneLockdownCreateAZoneLockdownRule,
    zoneLockdownDeleteAZoneLockdownRule,
    zoneLockdownGetAZoneLockdownRule,
    zoneLockdownUpdateAZoneLockdownRule
  },
  firewallRules: {
    firewallRulesDeleteFirewallRules,
    firewallRulesListFirewallRules,
    firewallRulesUpdatePriorityOfFirewallRules,
    firewallRulesCreateFirewallRules,
    firewallRulesUpdateFirewallRules,
    firewallRulesDeleteAFirewallRule,
    firewallRulesGetAFirewallRule,
    firewallRulesUpdatePriorityOfAFirewallRule,
    firewallRulesUpdateAFirewallRule
  },
  userAgentBlockingRules: {
    userAgentBlockingRulesListUserAgentBlockingRules,
    userAgentBlockingRulesCreateAUserAgentBlockingRule,
    userAgentBlockingRulesDeleteAUserAgentBlockingRule,
    userAgentBlockingRulesGetAUserAgentBlockingRule,
    userAgentBlockingRulesUpdateAUserAgentBlockingRule
  },
  wAFOverrides: {
    wafOverridesListWafOverrides,
    wafOverridesCreateAWafOverride,
    wafOverridesDeleteAWafOverride,
    wafOverridesGetAWafOverride,
    wafOverridesUpdateWafOverride
  },
  wAFPackages: { wafPackagesListWafPackages, wafPackagesGetAWafPackage, wafPackagesUpdateAWafPackage },
  wAFRuleGroups: { wafRuleGroupsListWafRuleGroups, wafRuleGroupsGetAWafRuleGroup, wafRuleGroupsUpdateAWafRuleGroup },
  wAFRules: { wafRulesListWafRules, wafRulesGetAWafRule, wafRulesUpdateAWafRule },
  healthChecks: {
    healthChecksListHealthChecks,
    healthChecksCreateHealthCheck,
    healthChecksCreatePreviewHealthCheck,
    healthChecksDeletePreviewHealthCheck,
    healthChecksHealthCheckPreviewDetails,
    healthChecksDeleteHealthCheck,
    healthChecksHealthCheckDetails,
    healthChecksPatchHealthCheck,
    healthChecksUpdateHealthCheck
  },
  zoneHolds: { zones0HoldDelete, zones0HoldGet, zones0HoldPatch, zones0HoldPost },
  perHostnameTLSSettings: { perHostnameTlsSettingsList, perHostnameTlsSettingsDelete, perHostnameTlsSettingsPut },
  keylessSSLForAZone: {
    keylessSslForAZoneListKeylessSslConfigurations,
    keylessSslForAZoneCreateKeylessSslConfiguration,
    keylessSslForAZoneDeleteKeylessSslConfiguration,
    keylessSslForAZoneGetKeylessSslConfiguration,
    keylessSslForAZoneEditKeylessSslConfiguration
  },
  leakedCredentialChecks: {
    wafProductApiLeakedCredentialsGetStatus,
    wafProductApiLeakedCredentialsSetStatus,
    wafProductApiLeakedCredentialsListDetections,
    wafProductApiLeakedCredentialsCreateDetection,
    wafProductApiLeakedCredentialsDeleteDetection,
    wafProductApiLeakedCredentialsUpdateDetection
  },
  loadBalancers: {
    loadBalancersListLoadBalancers,
    loadBalancersCreateLoadBalancer,
    loadBalancersDeleteLoadBalancer,
    loadBalancersLoadBalancerDetails,
    loadBalancersPatchLoadBalancer,
    loadBalancersUpdateLoadBalancer
  },
  logpushJobsForAZone: {
    getZonesZoneIdLogpushDatasetsDatasetIdFields,
    getZonesZoneIdLogpushDatasetsDatasetIdJobs,
    getZonesZoneIdLogpushJobs,
    postZonesZoneIdLogpushJobs,
    deleteZonesZoneIdLogpushJobsJobId,
    getZonesZoneIdLogpushJobsJobId,
    putZonesZoneIdLogpushJobsJobId,
    postZonesZoneIdLogpushOwnership,
    postZonesZoneIdLogpushOwnershipValidate,
    postZonesZoneIdLogpushValidateDestination,
    postZonesZoneIdLogpushValidateDestinationExists,
    postZonesZoneIdLogpushValidateOrigin
  },
  instantLogsJobsForAZone: { getZonesZoneIdLogpushEdgeJobs, postZonesZoneIdLogpushEdgeJobs },
  logsReceived: {
    getZonesZoneIdLogsControlRetentionFlag,
    postZonesZoneIdLogsControlRetentionFlag,
    getZonesZoneIdLogsRayidsRayId,
    getZonesZoneIdLogsReceived,
    getZonesZoneIdLogsReceivedFields
  },
  managedTransforms: { deleteManagedTransforms, listManagedTransforms, updateManagedTransforms },
  zoneLevelAuthenticatedOriginPulls: {
    zoneLevelAuthenticatedOriginPullsListCertificates,
    zoneLevelAuthenticatedOriginPullsUploadCertificate,
    zoneLevelAuthenticatedOriginPullsGetEnablementSettingForZone,
    zoneLevelAuthenticatedOriginPullsSetEnablementForZone,
    zoneLevelAuthenticatedOriginPullsDeleteCertificate,
    zoneLevelAuthenticatedOriginPullsGetCertificateDetails
  },
  perHostnameAuthenticatedOriginPull: {
    perHostnameAuthenticatedOriginPullEnableOrDisableAHostnameForClientAuthentication,
    perHostnameAuthenticatedOriginPullListCertificates,
    perHostnameAuthenticatedOriginPullUploadAHostnameClientCertificate,
    perHostnameAuthenticatedOriginPullDeleteHostnameClientCertificate,
    perHostnameAuthenticatedOriginPullGetTheHostnameClientCertificate,
    perHostnameAuthenticatedOriginPullGetTheHostnameStatusForClientAuthentication
  },
  pageShield: {
    pageShieldGetSettings,
    pageShieldUpdateSettings,
    pageShieldListConnections,
    pageShieldGetConnection,
    pageShieldListCookies,
    pageShieldGetCookie,
    pageShieldListPolicies,
    pageShieldCreatePolicy,
    pageShieldDeletePolicy,
    pageShieldGetPolicy,
    pageShieldUpdatePolicy,
    pageShieldListScripts,
    pageShieldGetScript
  },
  pageRules: {
    pageRulesListPageRules,
    pageRulesCreateAPageRule,
    pageRulesDeleteAPageRule,
    pageRulesGetAPageRule,
    pageRulesEditAPageRule,
    pageRulesUpdateAPageRule
  },
  availablePageRulesSettings: { availablePageRulesSettingsListAvailablePageRulesSettings },
  rateLimitsForAZone: {
    rateLimitsForAZoneListRateLimits,
    rateLimitsForAZoneCreateARateLimit,
    rateLimitsForAZoneDeleteARateLimit,
    rateLimitsForAZoneGetARateLimit,
    rateLimitsForAZoneUpdateARateLimit
  },
  zoneRulesets: {
    listZoneRulesets,
    createZoneRuleset,
    getZoneEntrypointRuleset,
    updateZoneEntrypointRuleset,
    listZoneEntrypointRulesetVersions,
    getZoneEntrypointRulesetVersion,
    deleteZoneRuleset,
    getZoneRuleset,
    updateZoneRuleset,
    createZoneRulesetRule,
    deleteZoneRulesetRule,
    updateZoneRulesetRule,
    listZoneRulesetVersions,
    deleteZoneRulesetVersion,
    getZoneRulesetVersion,
    listZoneRulesetVersionRulesByTag
  },
  secondaryDNSSecondaryZone: {
    secondaryDnsSecondaryZoneForceAxfr,
    secondaryDnsSecondaryZoneDeleteSecondaryZoneConfiguration,
    secondaryDnsSecondaryZoneSecondaryZoneConfigurationDetails,
    secondaryDnsSecondaryZoneCreateSecondaryZoneConfiguration,
    secondaryDnsSecondaryZoneUpdateSecondaryZoneConfiguration
  },
  secondaryDNSPrimaryZone: {
    secondaryDnsPrimaryZoneDeletePrimaryZoneConfiguration,
    secondaryDnsPrimaryZonePrimaryZoneConfigurationDetails,
    secondaryDnsPrimaryZoneCreatePrimaryZoneConfiguration,
    secondaryDnsPrimaryZoneUpdatePrimaryZoneConfiguration,
    secondaryDnsPrimaryZoneDisableOutgoingZoneTransfers,
    secondaryDnsPrimaryZoneEnableOutgoingZoneTransfers,
    secondaryDnsPrimaryZoneForceDnsNotify,
    secondaryDnsPrimaryZoneGetOutgoingZoneTransferStatus
  },
  securityTxt: { deleteSecurityTxt, getSecurityTxt, updateSecurityTxt },
  zoneSettings: {
    zoneSettingsGetAllZoneSettings,
    zoneSettingsEditZoneSettingsInfo,
    zoneCacheSettingsChangeAegisSetting,
    zoneSettingsGetFontsSetting,
    zoneSettingsChangeFontsSetting,
    zoneCacheSettingsChangeOriginMaxHttpVersionSetting,
    zoneSettingsGetSpeedBrainSetting,
    zoneSettingsChangeSpeedBrainSetting,
    zoneSettingsGetSingleSetting,
    zoneSettingsEditSingleSetting
  },
  zaraz: {
    getZonesZoneIdentifierZarazConfig,
    putZonesZoneIdentifierZarazConfig,
    getZonesZoneIdentifierZarazDefault,
    getZonesZoneIdentifierZarazExport,
    getZonesZoneIdentifierZarazHistory,
    putZonesZoneIdentifierZarazHistory,
    getZonesZoneIdentifierZarazConfigHistory,
    postZonesZoneIdentifierZarazPublish,
    getZonesZoneIdentifierZarazWorkflow,
    putZonesZoneIdentifierZarazWorkflow
  },
  zoneSnippets: {
    zoneSnippets,
    zoneSnippetsSnippetRulesDelete,
    zoneSnippetsSnippetRules,
    zoneSnippetsSnippetRulesPut,
    zoneSnippetsSnippetDelete,
    zoneSnippetsSnippet,
    zoneSnippetsSnippetPut,
    zoneSnippetsSnippetContent
  },
  spectrumAnalytics: {
    spectrumAggregateAnalyticsGetCurrentAggregatedAnalytics,
    spectrumAnalyticsByTimeGetAnalyticsByTime,
    spectrumAnalyticsSummaryGetAnalyticsSummary
  },
  spectrumApplications: {
    spectrumApplicationsListSpectrumApplications,
    spectrumApplicationsCreateSpectrumApplicationUsingANameForTheOrigin,
    spectrumApplicationsDeleteSpectrumApplication,
    spectrumApplicationsGetSpectrumApplicationConfiguration,
    spectrumApplicationsUpdateSpectrumApplicationConfigurationUsingANameForTheOrigin
  },
  observatory: {
    speedGetAvailabilities,
    speedListPages,
    speedDeleteTests,
    speedListTestHistory,
    speedCreateTest,
    speedGetTest,
    speedListPageTrend,
    speedDeleteTestSchedule,
    speedGetScheduledTest,
    speedCreateScheduledTest
  },
  analyzeCertificate: { analyzeCertificateAnalyzeCertificate },
  certificatePacks: {
    certificatePacksListCertificatePacks,
    certificatePacksOrderAdvancedCertificateManagerCertificatePack,
    certificatePacksGetCertificatePackQuotas,
    certificatePacksDeleteAdvancedCertificateManagerCertificatePack,
    certificatePacksGetCertificatePack,
    certificatePacksRestartValidationForAdvancedCertificateManagerCertificatePack
  },
  universalSSLSettingsForAZone: {
    universalSslSettingsForAZoneUniversalSslSettingsDetails,
    universalSslSettingsForAZoneEditUniversalSslSettings
  },
  sSLVerification: { sslVerificationSslVerificationDetails, sslVerificationEditSslCertificatePackValidationMethod },
  uRLNormalization: { deleteUrlNormalization, getUrlNormalization, updateUrlNormalization },
  waitingRoom: {
    waitingRoomListWaitingRooms,
    waitingRoomCreateWaitingRoom,
    waitingRoomCreateACustomWaitingRoomPagePreview,
    waitingRoomGetZoneSettings,
    waitingRoomPatchZoneSettings,
    waitingRoomUpdateZoneSettings,
    waitingRoomDeleteWaitingRoom,
    waitingRoomWaitingRoomDetails,
    waitingRoomPatchWaitingRoom,
    waitingRoomUpdateWaitingRoom,
    waitingRoomListEvents,
    waitingRoomCreateEvent,
    waitingRoomDeleteEvent,
    waitingRoomEventDetails,
    waitingRoomPatchEvent,
    waitingRoomUpdateEvent,
    waitingRoomPreviewActiveEventDetails,
    waitingRoomListWaitingRoomRules,
    waitingRoomCreateWaitingRoomRule,
    waitingRoomReplaceWaitingRoomRules,
    waitingRoomDeleteWaitingRoomRule,
    waitingRoomPatchWaitingRoomRule,
    waitingRoomGetWaitingRoomStatus
  },
  web3Hostname: {
    web3HostnameListWeb3Hostnames,
    web3HostnameCreateWeb3Hostname,
    web3HostnameDeleteWeb3Hostname,
    web3HostnameWeb3HostnameDetails,
    web3HostnameEditWeb3Hostname,
    web3HostnameIpfsUniversalPathGatewayContentListDetails,
    web3HostnameUpdateIpfsUniversalPathGatewayContentList,
    web3HostnameListIpfsUniversalPathGatewayContentListEntries,
    web3HostnameCreateIpfsUniversalPathGatewayContentListEntry,
    web3HostnameDeleteIpfsUniversalPathGatewayContentListEntry,
    web3HostnameIpfsUniversalPathGatewayContentListEntryDetails,
    web3HostnameEditIpfsUniversalPathGatewayContentListEntry
  },
  workerRoutes: {
    workerRoutesListRoutes,
    workerRoutesCreateRoute,
    workerRoutesDeleteRoute,
    workerRoutesGetRoute,
    workerRoutesUpdateRoute
  },
  automaticSSLTLS: { sslDetectorAutomaticModeGetEnrollment, sslDetectorAutomaticModePatchEnrollment }
};
