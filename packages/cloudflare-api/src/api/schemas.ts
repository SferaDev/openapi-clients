/**
 * Generated by @openapi-codegen
 *
 * @version 4.0.0
 */
/**
 * The account id
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type AaaAccountId = string;

export type AaaAlertTypes = {
  description?: AaaDescription;
  display_name?: AaaDisplayName;
  filter_options?: AaaFilterOptions;
  type?: AaaType;
};

/**
 * Message body included in the notification sent.
 *
 * @example SSL certificate has expired
 */
export type AaaAlertBody = string;

/**
 * Optional specification of how often to re-alert from the same incident, not support on all alert types.
 *
 * @example 30m
 * @x-auditable true
 */
export type AaaAlertInterval = string;

/**
 * Refers to which event will trigger a Notification dispatch. You can use the endpoint to get available alert types which then will give you a list of possible values.
 *
 * @example universal_ssl_event_type
 * @x-auditable true
 */
export type AaaAlertType =
  | "access_custom_certificate_expiration_type"
  | "advanced_ddos_attack_l4_alert"
  | "advanced_ddos_attack_l7_alert"
  | "advanced_http_alert_error"
  | "bgp_hijack_notification"
  | "billing_usage_alert"
  | "block_notification_block_removed"
  | "block_notification_new_block"
  | "block_notification_review_rejected"
  | "bot_traffic_basic_alert"
  | "brand_protection_alert"
  | "brand_protection_digest"
  | "clickhouse_alert_fw_anomaly"
  | "clickhouse_alert_fw_ent_anomaly"
  | "cloudforce_one_request_notification"
  | "custom_analytics"
  | "custom_bot_detection_alert"
  | "custom_ssl_certificate_event_type"
  | "dedicated_ssl_certificate_event_type"
  | "device_connectivity_anomaly_alert"
  | "dos_attack_l4"
  | "dos_attack_l7"
  | "expiring_service_token_alert"
  | "failing_logpush_job_disabled_alert"
  | "fbm_auto_advertisement"
  | "fbm_dosd_attack"
  | "fbm_volumetric_attack"
  | "health_check_status_notification"
  | "hostname_aop_custom_certificate_expiration_type"
  | "http_alert_edge_error"
  | "http_alert_origin_error"
  | "image_notification"
  | "image_resizing_notification"
  | "incident_alert"
  | "load_balancing_health_alert"
  | "load_balancing_pool_enablement_alert"
  | "logo_match_alert"
  | "magic_tunnel_health_check_event"
  | "magic_wan_tunnel_health"
  | "maintenance_event_notification"
  | "mtls_certificate_store_certificate_expiration_type"
  | "pages_event_alert"
  | "radar_notification"
  | "real_origin_monitoring"
  | "scriptmonitor_alert_new_code_change_detections"
  | "scriptmonitor_alert_new_hosts"
  | "scriptmonitor_alert_new_malicious_hosts"
  | "scriptmonitor_alert_new_malicious_scripts"
  | "scriptmonitor_alert_new_malicious_url"
  | "scriptmonitor_alert_new_max_length_resource_url"
  | "scriptmonitor_alert_new_resources"
  | "secondary_dns_all_primaries_failing"
  | "secondary_dns_primaries_failing"
  | "secondary_dns_warning"
  | "secondary_dns_zone_successfully_updated"
  | "secondary_dns_zone_validation_warning"
  | "security_insights_alert"
  | "sentinel_alert"
  | "stream_live_notifications"
  | "synthetic_test_latency_alert"
  | "synthetic_test_low_availability_alert"
  | "traffic_anomalies_alert"
  | "tunnel_health_event"
  | "tunnel_update_event"
  | "universal_ssl_event_type"
  | "web_analytics_metrics_update"
  | "zone_aop_custom_certificate_expiration_type";

export type AaaApiResponseCollection = AaaApiResponseCommon & {
  result_info?: AaaSchemasResultInfo;
};

export type AaaApiResponseCommon = {
  errors: AaaMessages;
  messages: AaaMessages;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type AaaApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: AaaMessages;
  messages: AaaMessages;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

export type AaaApiResponseSingle = AaaApiResponseCommon;

export type AaaAuditLogs = {
  action?: {
    /**
     * A boolean that indicates if the action attempted was successful.
     *
     * @example true
     */
    result?: boolean;
    /**
     * A short string that describes the action that was performed.
     *
     * @example change_setting
     */
    type?: string;
  };
  actor?: {
    /**
     * The email of the user that performed the action.
     *
     * @example michelle@example.com
     * @format email
     */
    email?: string;
    /**
     * The ID of the actor that performed the action. If a user performed the action, this will be their User ID.
     *
     * @example f6b5de0326bb5182b8a4840ee01ec774
     */
    id?: string;
    /**
     * The IP address of the request that performed the action.
     *
     * @example 198.41.129.166
     */
    ip?: string;
    /**
     * The type of actor, whether a User, Cloudflare Admin, or an Automated System.
     *
     * @example user
     */
    type?: "user" | "admin" | "Cloudflare";
  };
  /**
   * A string that uniquely identifies the audit log.
   *
   * @example d5b0f326-1232-4452-8858-1089bd7168ef
   */
  id?: string;
  /**
   * The source of the event.
   *
   * @example API
   */
  interface?: string;
  /**
   * An object which can lend more context to the action being logged. This is a flexible value and varies between different actions.
   *
   * @example {"name":"security_level","type":"firewall","value":"high","zone_name":"example.com"}
   */
  metadata?: Record<string, any>;
  /**
   * The new value of the resource that was modified.
   *
   * @example low
   */
  newValue?: string;
  /**
   * The value of the resource before it was modified.
   *
   * @example high
   */
  oldValue?: string;
  owner?: {
    id?: AaaIdentifier;
  };
  resource?: {
    /**
     * An identifier for the resource that was affected by the action.
     *
     * @example 023e105f4ecef8ad9ca31a8372d0c353
     */
    id?: string;
    /**
     * A short string that describes the resource that was affected by the action.
     *
     * @example zone
     */
    type?: string;
  };
  /**
   * A UTC RFC3339 timestamp that specifies when the action being logged occured.
   *
   * @example 2017-04-26T17:31:07Z
   * @format date-time
   */
  when?: string;
};

export type AaaAuditLogsV2 = {
  /**
   * Contains account related information.
   */
  account?: {
    /**
     * A unique identifier for the account.
     *
     * @example 4bb334f7c94c4a29a045f03944f072e5
     */
    id?: string;
    /**
     * A string that identifies the account name.
     *
     * @example Example Account
     */
    name?: string;
  };
  /**
   * Provides information about the action performed.
   */
  action?: {
    /**
     * A short description of the action performed.
     *
     * @example Add Member
     */
    description?: string;
    /**
     * The result of the action, indicating success or failure.
     *
     * @example success
     */
    result?: string;
    /**
     * A timestamp indicating when the action was logged.
     *
     * @example 2024-04-26T17:31:07Z
     * @format date-time
     */
    time?: string;
    /**
     * A short string that describes the action that was performed.
     *
     * @example create
     */
    type?: string;
  };
  /**
   * Provides details about the actor who performed the action.
   */
  actor?: {
    /**
     * @example dash
     */
    context?: "api_key" | "api_token" | "dash" | "oauth" | "origin_ca_key";
    /**
     * The email of the actor who performed the action.
     *
     * @example alice@example.com
     * @format email
     */
    email?: string;
    /**
     * The ID of the actor who performed the action. If a user performed the action, this will be their User ID.
     *
     * @example f6b5de0326bb5182b8a4840ee01ec774
     */
    id?: string;
    /**
     * The IP address of the request that performed the action.
     *
     * @example 198.41.129.166
     * @format ipv4 | ipv6
     */
    ip_address?: string;
    /**
     * Filters by the API token ID when the actor context is an api_token.
     */
    token_id?: string;
    /**
     * Filters by the API token name when the actor context is an api_token.
     */
    token_name?: string;
    /**
     * The type of actor.
     *
     * @example user
     */
    type?: "account" | "cloudflare_admin" | "system" | "user";
  };
  id?: AaaSchemasIdentifier;
  /**
   * Provides raw information about the request and response.
   */
  raw?: {
    /**
     * The Cloudflare Ray ID for the request.
     *
     * @example 8e9b1c60ef9e1c9a
     */
    cf_ray_id?: string;
    /**
     * The HTTP method of the request.
     *
     * @example POST
     */
    method?: string;
    /**
     * The HTTP response status code returned by the API.
     *
     * @example 200
     */
    status_code?: number;
    /**
     * The URI of the request.
     *
     * @example /accounts/4bb334f7c94c4a29a045f03944f072e5/members
     */
    uri?: string;
    /**
     * The client's user agent string sent with the request.
     *
     * @example Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) Safari/605.1.15
     */
    user_agent?: string;
  };
  /**
   * Provides details about the affected resource.
   */
  resource?: {
    /**
     * The unique identifier for the affected resource.
     */
    id?: string;
    /**
     * The Cloudflare product associated with the resource.
     *
     * @example members
     */
    product?: string;
    request?: Record<string, any>;
    response?: Record<string, any>;
    /**
     * The scope of the resource.
     *
     * @example accounts
     */
    scope?: Record<string, any>;
    /**
     * The type of the resource.
     */
    type?: string;
  };
  /**
   * Provides details about the zone affected by the action.
   */
  zone?: {
    /**
     * A string that identifies the zone id.
     */
    id?: string;
    /**
     * A string that identifies the zone name.
     *
     * @example example.com
     */
    name?: string;
  };
};

export type AaaAuditLogsV2ResponseCollection = {
  errors?: AaaSchemasMessages;
  result?: AaaAuditLogsV2[];
  result_info?: AaaResultInfo;
  /**
   * Indicates whether the API call was successful
   *
   * @example true
   */
  success?: true;
};

export type AaaAuditLogsResponseCollection =
  | {
      errors?: AaaMessages;
      messages?: AaaMessages;
      result?: AaaAuditLogs[];
      /**
       * @example true
       */
      success?: boolean;
    }
  | AaaApiResponseCommon;

/**
 * Limit the returned results to history records older than the specified date. This must be a timestamp that conforms to RFC3339.
 *
 * @example 2022-05-20T20:29:58.679897Z
 * @format date-time
 */
export type AaaBefore = string;

export type AaaComponentsSchemasApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: AaaMessages;
  messages: AaaMessages;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

/**
 * Description of the notification policy (if present).
 *
 * @example Universal Certificate validation status, issuance, renewal, and expiration notices
 */
export type AaaComponentsSchemasDescription = string;

/**
 * The name of the webhook destination. This will be included in the request body when you receive a webhook notification.
 *
 * @example Slack Webhook
 * @x-auditable true
 */
export type AaaComponentsSchemasName = string;

export type AaaComponentsSchemasResponseCollection =
  AaaApiResponseCollection & {
    result?: AaaPagerduty[];
  };

/**
 * Type of webhook endpoint.
 *
 * @example slack
 * @x-auditable true
 */
export type AaaComponentsSchemasType = "slack" | "generic" | "gchat";

/**
 * Timestamp of when the webhook destination was created.
 *
 * @example 2020-10-26T18:25:04.532316Z
 * @format date-time
 * @x-auditable true
 */
export type AaaCreatedAt = string;

/**
 * Describes the alert type.
 *
 * @example High levels of 5xx HTTP errors at your origin
 * @x-auditable true
 */
export type AaaDescription = string;

/**
 * Alert type name.
 *
 * @example Origin Error Rate Alert
 * @x-auditable true
 */
export type AaaDisplayName = string;

export type AaaEligibility = {
  eligible?: AaaEligible;
  ready?: AaaReady;
  type?: AaaSchemasType;
};

/**
 * Determines whether or not the account is eligible for the delivery mechanism.
 *
 * @example true
 * @x-auditable true
 */
export type AaaEligible = boolean;

/**
 * Whether or not the Notification policy is enabled.
 *
 * @default true
 * @example true
 * @x-auditable true
 */
export type AaaEnabled = boolean;

/**
 * Format of additional configuration options (filters) for the alert type. Data type of filters during policy creation: Array of strings.
 *
 * @example {"AvailableValues":null,"ComparisonOperator":"==","Key":"zones","Range":"1-n"}
 * @example {"AvailableValues":[{"Description":"Service-Level Objective of 99.7","ID":"99.7"},{"Description":"Service-Level Objective of 99.8","ID":"99.8"}],"ComparisonOperator":">=","Key":"slo","Range":"0-1"}
 */
export type AaaFilterOptions = any[];

/**
 * Optional filters that allow you to be alerted only on a subset of events for that alert type based on some criteria. This is only available for select alert types. See alert type documentation for more details.
 *
 * @example {"slo":["99.9"]}
 */
export type AaaFilters = {
  /**
   * Usage depends on specific alert type
   */
  actions?: string[];
  /**
   * Used for configuring radar_notification
   */
  affected_asns?: string[];
  /**
   * Used for configuring incident_alert
   *
   * @example 4c231tkdlpcl
   */
  affected_components?: string[];
  /**
   * Used for configuring radar_notification
   */
  affected_locations?: string[];
  /**
   * Used for configuring maintenance_event_notification
   */
  airport_code?: string[];
  /**
   * Usage depends on specific alert type
   */
  alert_trigger_preferences?: string[];
  /**
   * Usage depends on specific alert type
   */
  alert_trigger_preferences_value?: string[];
  /**
   * Used for configuring load_balancing_pool_enablement_alert
   */
  enabled?: string[];
  /**
   * Used for configuring pages_event_alert
   */
  environment?: string[];
  /**
   * Used for configuring pages_event_alert
   */
  event?: string[];
  /**
   * Used for configuring load_balancing_health_alert
   */
  event_source?: string[];
  /**
   * Usage depends on specific alert type
   */
  event_type?: string[];
  /**
   * Usage depends on specific alert type
   */
  group_by?: string[];
  /**
   * Used for configuring health_check_status_notification
   */
  health_check_id?: string[];
  /**
   * Used for configuring incident_alert
   */
  incident_impact?: (
    | "INCIDENT_IMPACT_NONE"
    | "INCIDENT_IMPACT_MINOR"
    | "INCIDENT_IMPACT_MAJOR"
    | "INCIDENT_IMPACT_CRITICAL"
  )[];
  /**
   * Used for configuring stream_live_notifications
   */
  input_id?: string[];
  /**
   * Used for configuring security_insights_alert
   */
  insight_class?: string[];
  /**
   * Used for configuring billing_usage_alert
   */
  limit?: string[];
  /**
   * Used for configuring logo_match_alert
   */
  logo_tag?: string[];
  /**
   * Used for configuring advanced_ddos_attack_l4_alert
   */
  megabits_per_second?: string[];
  /**
   * Used for configuring load_balancing_health_alert
   */
  new_health?: string[];
  /**
   * Used for configuring tunnel_health_event
   */
  new_status?: string[];
  /**
   * Used for configuring advanced_ddos_attack_l4_alert
   */
  packets_per_second?: string[];
  /**
   * Usage depends on specific alert type
   */
  pool_id?: string[];
  /**
   * Usage depends on specific alert type
   */
  pop_names?: string[];
  /**
   * Used for configuring billing_usage_alert
   */
  product?: string[];
  /**
   * Used for configuring pages_event_alert
   */
  project_id?: string[];
  /**
   * Used for configuring advanced_ddos_attack_l4_alert
   */
  protocol?: string[];
  /**
   * Usage depends on specific alert type
   */
  query_tag?: string[];
  /**
   * Used for configuring advanced_ddos_attack_l7_alert
   */
  requests_per_second?: string[];
  /**
   * Usage depends on specific alert type
   */
  selectors?: string[];
  /**
   * Used for configuring clickhouse_alert_fw_ent_anomaly
   */
  services?: string[];
  /**
   * Usage depends on specific alert type
   */
  slo?: string[];
  /**
   * Used for configuring health_check_status_notification
   */
  status?: string[];
  /**
   * Used for configuring advanced_ddos_attack_l7_alert
   */
  target_hostname?: string[];
  /**
   * Used for configuring advanced_ddos_attack_l4_alert
   */
  target_ip?: string[];
  /**
   * Used for configuring advanced_ddos_attack_l7_alert
   */
  target_zone_name?: string[];
  /**
   * Used for configuring traffic_anomalies_alert
   */
  traffic_exclusions?: "security_events"[];
  /**
   * Used for configuring tunnel_health_event
   */
  tunnel_id?: string[];
  /**
   * Usage depends on specific alert type
   */
  tunnel_name?: string[];
  /**
   * Usage depends on specific alert type
   */
  where?: string[];
  /**
   * Usage depends on specific alert type
   */
  zones?: string[];
};

export type AaaHistory = {
  alert_body?: AaaAlertBody;
  alert_type?: AaaSchemasAlertType;
  description?: AaaComponentsSchemasDescription;
  id?: AaaUuid;
  mechanism?: AaaMechanism;
  mechanism_type?: AaaMechanismType;
  name?: AaaSchemasName;
  policy_id?: AaaPolicyId;
  sent?: AaaSent;
};

export type AaaHistoryComponentsSchemasResponseCollection =
  AaaApiResponseCollection & {
    /**
     * @example {"alert_body":{"data":{"custom_csr_id":"","expires_on":null,"hosts":[],"id":"11111111111","issuer":"","method":"txt","serial_number":"","settings":null,"signature":"","status":"","type":"","uploaded_on":null,"validation_errors":[],"validation_records":[{"cname":"","cname_target":"","emails":[],"http_body":"","http_url":"","txt_name":"_acme-challenge.example.com","txt_value":"11111111111"}]},"metadata":{"account":null,"event":{"created_at":null,"id":"","type":"ssl.certificate.validation.failed"},"zone":{"id":"11111111111"}}},"alert_type":"universal_ssl_event_type","description":"Universal Certificate validation status, issuance, renewal, and expiration notices.","id":"f174e90a-fafe-4643-bbbc-4a0ed4fc8415","mechanism":"test@example.com","mechanism_type":"email","name":"SSL Notification Event Policy","policy_id":"35040955-3102-4710-938c-0f4eaf736e25","sent":"2021-10-08T17:52:17.571336Z"}
     */
    result?: AaaHistory[];
    /**
     * @example {"count":1,"page":1,"per_page":20}
     */
    result_info?: Record<string, any>;
  };

export type AaaIdResponse = AaaApiResponseSingle & {
  result?: {
    id?: AaaUuid;
  };
};

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type AaaIdentifier = string;

/**
 * The token integration key
 *
 * @example 8c71e667571b4f61b94d9e4b12158038
 * @maxLength 32
 */
export type AaaIntegrationToken = string;

/**
 * Timestamp of the last time an attempt to dispatch a notification to this webhook failed.
 *
 * @example 2020-10-26T18:25:04.532316Z
 * @format date-time
 * @x-auditable true
 */
export type AaaLastFailure = string;

/**
 * Timestamp of the last time Cloudflare was able to successfully dispatch a notification using this webhook.
 *
 * @example 2020-10-26T18:25:04.532316Z
 * @format date-time
 * @x-auditable true
 */
export type AaaLastSuccess = string;

/**
 * The mechanism to which the notification has been dispatched.
 *
 * @example test@example.com
 * @x-auditable true
 */
export type AaaMechanism = string;

/**
 * The type of mechanism to which the notification has been dispatched. This can be email/pagerduty/webhook based on the mechanism configured.
 *
 * @example email
 */
export type AaaMechanismType = "email" | "pagerduty" | "webhook";

/**
 * List of IDs that will be used when dispatching a notification. IDs for email type will be the email address.
 *
 * @example {"email":[{"id":"test@example.com"}],"pagerduty":[{"id":"e8133a15-00a4-4d69-aec1-32f70c51f6e5"}],"webhooks":[{"id":"14cc1190-5d2b-4b98-a696-c424cb2ad05f"}]}
 */
export type AaaMechanisms = {
  email?: {
    /**
     * The email address
     *
     * @x-auditable true
     */
    id?: string;
  }[];
  pagerduty?: {
    id?: AaaUuid;
  }[];
  webhooks?: {
    id?: AaaUuid;
  }[];
};

export type AaaMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * The name of the pagerduty service.
 *
 * @example My PagerDuty Service
 * @x-auditable true
 */
export type AaaName = string;

export type AaaPagerduty = {
  id?: AaaUuid;
  name?: AaaName;
};

/**
 * Number of items per page.
 *
 * @default 25
 * @maximum 1000
 * @minimum 5
 */
export type AaaPerPage = number;

export type AaaPolicies = {
  alert_interval?: AaaAlertInterval;
  alert_type?: AaaAlertType;
  created?: AaaTimestamp;
  description?: AaaSchemasDescription;
  enabled?: AaaEnabled;
  filters?: AaaFilters;
  id?: AaaPolicyId;
  mechanisms?: AaaMechanisms;
  modified?: AaaTimestamp;
  name?: AaaSchemasName;
};

export type AaaPoliciesComponentsSchemasResponseCollection =
  AaaApiResponseCollection & {
    result?: AaaPolicies[];
  };

/**
 * The unique identifier of a notification policy
 *
 * @example 0da2b59e-f118-439d-8097-bdfb215203c9
 * @maxLength 36
 * @x-auditable true
 */
export type AaaPolicyId = string;

/**
 * Beta flag. Users can create a policy with a mechanism that is not ready, but we cannot guarantee successful delivery of notifications.
 *
 * @example true
 * @x-auditable true
 */
export type AaaReady = boolean;

export type AaaResponseCollection = AaaApiResponseCollection & {
  /**
   * @example {"Origin Monitoring":[{"description":"High levels of 5xx HTTP errors at your origin.","display_name":"Origin Error Rate Alert","filter_options":[{"AvailableValues":null,"ComparisonOperator":"==","Key":"zones","Range":"1-n"},{"AvailableValues":[{"Description":"Service-Level Objective of 99.7","ID":"99.7"},{"Description":"Service-Level Objective of 99.8","ID":"99.8"}],"ComparisonOperator":">=","Key":"slo","Range":"0-1"}],"type":"http_alert_origin_error"}]}
   */
  result?: {
    [key: string]: AaaAlertTypes[];
  };
};

/**
 * Provides information about the result of the request, including count and cursor.
 */
export type AaaResultInfo = {
  /**
   * The number of records returned in the response.
   *
   * @example 1
   */
  count?: string;
  /**
   * The cursor token used for pagination.
   *
   * @example ASqdKd7dKgxh-aZ8bm0mZos1BtW4BdEqifCzNkEeGRzi_5SN_-362Y8sF-C1TRn60_6rd3z2dIajf9EAPyQ_NmIeAMkacmaJPXipqvP7PLU4t72wyqBeJfjmjdE=
   */
  cursor?: string;
};

/**
 * Type of notification that has been dispatched.
 *
 * @example universal_ssl_event_type
 */
export type AaaSchemasAlertType = string;

export type AaaSchemasApiResponseCommonFailure = {
  /**
   * A list of error messages.
   */
  errors: {
    /**
     * A text description of this message.
     *
     * @example No route for the URI
     */
    message: string;
  }[];
  messages?: {
    message?: string;
  }[];
  /**
   * Indicates whether the API call was failed
   *
   * @example false
   */
  success: false;
};

/**
 * Optional description for the Notification policy.
 *
 * @example Something describing the policy.
 * @x-auditable true
 */
export type AaaSchemasDescription = string;

/**
 * A unique identifier for the audit log entry.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type AaaSchemasIdentifier = string;

export type AaaSchemasMessages = {
  message: string;
}[];

/**
 * Name of the policy.
 *
 * @example SSL Notification Event Policy
 * @x-auditable true
 */
export type AaaSchemasName = string;

export type AaaSchemasResponseCollection = AaaApiResponseCollection & {
  /**
   * @example {"email":{"eligible":true,"ready":true,"type":"email"}}
   */
  result?: {
    [key: string]: AaaEligibility[];
  };
};

export type AaaSchemasResultInfo = {
  /**
   * Total number of results for the requested service
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters
   *
   * @example 2000
   */
  total_count?: number;
};

export type AaaSchemasSingleResponse = AaaApiResponseSingle & {
  result?: AaaWebhooks;
};

/**
 * Determines type of delivery mechanism.
 *
 * @example email
 * @x-auditable true
 */
export type AaaSchemasType = "email" | "pagerduty" | "webhook";

/**
 * Optional secret that will be passed in the `cf-webhook-auth` header when dispatching generic webhook notifications or formatted for supported destinations. Secrets are not returned in any API response body.
 *
 * @x-sensitive true
 */
export type AaaSecret = string;

export type AaaSensitiveIdResponse = AaaApiResponseSingle & {
  result?: {
    id?: AaaToken;
  };
};

/**
 * Timestamp of when the notification was dispatched in ISO 8601 format.
 *
 * @example 2021-10-08T17:52:17.571336Z
 * @format date-time
 */
export type AaaSent = string;

export type AaaSingleResponse = AaaApiResponseSingle & {
  result?: AaaPolicies;
};

/**
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type AaaTimestamp = string;

/**
 * token in form of UUID
 *
 * @example a313ba7d-3e46-4c0e-a408-08fafbc3816a
 * @maxLength 36
 * @x-sensitive true
 */
export type AaaToken = string;

/**
 * Use this value when creating and updating a notification policy.
 *
 * @example http_alert_origin_error
 * @x-auditable true
 */
export type AaaType = string;

/**
 * The POST endpoint to call when dispatching a notification.
 *
 * @example https://hooks.slack.com/services/Ds3fdBFbV/456464Gdd
 */
export type AaaUrl = string;

/**
 * UUID
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 * @x-auditable true
 */
export type AaaUuid = string;

/**
 * The unique identifier of a webhook
 *
 * @example b115d5ec-15c6-41ee-8b76-92c449b5227b
 * @maxLength 36
 * @x-auditable true
 */
export type AaaWebhookId = string;

export type AaaWebhooks = {
  created_at?: AaaCreatedAt;
  id?: AaaWebhookId;
  last_failure?: AaaLastFailure;
  last_success?: AaaLastSuccess;
  name?: AaaComponentsSchemasName;
  secret?: AaaSecret;
  type?: AaaComponentsSchemasType;
  url?: AaaUrl;
};

export type AaaWebhooksComponentsSchemasResponseCollection =
  AaaApiResponseCollection & {
    result?: AaaWebhooks[];
  };

/**
 * Report has invalid type
 */
export type AbuseReportsBadActError = string;

/**
 * Provided value has invalid size
 */
export type AbuseReportsBadAddressError = string;

/**
 * Provided value has invalid size
 */
export type AbuseReportsBadAgentNameError = string;

/**
 * Provided value has invalid size
 */
export type AbuseReportsBadCityError = string;

/**
 * Comment maximum length of 2000 characters exceeded
 */
export type AbuseReportsBadCommentsError = string;

/**
 * Provided value has invalid size
 */
export type AbuseReportsBadCountryError = string;

/**
 * Provided email was invalid
 */
export type AbuseReportsBadEmailError = string;

/**
 * Invalid IP passed to api
 */
export type AbuseReportsBadIPError = string;

/**
 * Please provide a more detailed description of the infringement between 1 and 5000 characters
 */
export type AbuseReportsBadJustError = string;

/**
 * Missing a required field
 */
export type AbuseReportsBadNameError = string;

/**
 * Invalid Port and Protocol passed to api
 */
export type AbuseReportsBadPortsProtocolError = string;

/**
 * Provided value has invalid size
 */
export type AbuseReportsBadStateError = string;

/**
 * Invalid URL (http://example.com/) Invalid URL Scheme (http or https) Missing hostname in url Missing a required field Could not determine encoding of field
 */
export type AbuseReportsBadUrlsError = string;

export type AbuseReportsCSAMReport = {
  act?: AbuseReportsReportType;
  /**
   * A valid email of the abuse reporter. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   */
  email?: string;
  /**
   * Should match the value provided in `email`
   */
  email2?: string;
  /**
   * Text not exceeding 255 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 255
   * @minLength 1
   */
  name?: string;
  /**
   * A list of valid URLs separated by ‘\n’ (new line character). The list of the URLs should not exceed 250 URLs. All URLs should have the same hostname. Each URL should be unique. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   */
  urls: string;
  /**
   * Any additional comments about the infringement not exceeding 2000 characters
   *
   * @maxLength 2000
   * @minLength 1
   */
  comments?: string;
  /**
   * Text not exceeding 100 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 100
   * @minLength 1
   */
  company?: string;
  /**
   * Text containing 2 characters
   *
   * @maxLength 2
   * @minLength 2
   */
  reported_country?: string;
  /**
   * Text not exceeding 255 characters
   *
   * @maxLength 255
   * @minLength 1
   */
  reported_user_agent?: string;
  /**
   * Text not exceeding 20 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 20
   * @minLength 1
   */
  tele?: string;
  /**
   * Text not exceeding 255 characters
   *
   * @maxLength 255
   * @minLength 1
   */
  title?: string;
  /**
   * Text not exceeding 255 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 255
   * @minLength 1
   */
  country?: string;
  /**
   * Notification type based on the abuse type. NOTE: Copyright (DMCA) and Trademark reports cannot be anonymous.
   */
  host_notification: "send" | "send-anon";
  /**
   * A detailed description of the infringement, including any necessary access details and the exact steps needed to view the content, not exceeding 5000 characters.
   *
   * @maxLength 5000
   * @minLength 1
   */
  justification: string;
  /**
   * Notification type based on the abuse type. NOTE: Copyright (DMCA) and Trademark reports cannot be anonymous.
   */
  ncmec_notification: "send" | "send-anon";
  /**
   * Notification type based on the abuse type. NOTE: Copyright (DMCA) and Trademark reports cannot be anonymous.
   */
  owner_notification: "send" | "send-anon" | "none";
};

/**
 * Failed while reading from database Failed while writing to the database This service error will trigger an alert for Cloudflare engineers to investigate the cause resolve it.
 */
export type AbuseReportsDBError = string;

export type AbuseReportsDMCAReport = {
  act?: AbuseReportsReportType;
  /**
   * A valid email of the abuse reporter. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   */
  email?: string;
  /**
   * Should match the value provided in `email`
   */
  email2?: string;
  /**
   * Text not exceeding 255 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 255
   * @minLength 1
   */
  name?: string;
  /**
   * A list of valid URLs separated by ‘\n’ (new line character). The list of the URLs should not exceed 250 URLs. All URLs should have the same hostname. Each URL should be unique. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   */
  urls?: string;
  /**
   * Any additional comments about the infringement not exceeding 2000 characters
   *
   * @maxLength 2000
   * @minLength 1
   */
  comments?: string;
  /**
   * Text not exceeding 100 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 100
   * @minLength 1
   */
  company?: string;
  /**
   * Text containing 2 characters
   *
   * @maxLength 2
   * @minLength 2
   */
  reported_country?: string;
  /**
   * Text not exceeding 255 characters
   *
   * @maxLength 255
   * @minLength 1
   */
  reported_user_agent?: string;
  /**
   * Text not exceeding 20 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 20
   * @minLength 1
   */
  tele?: string;
  /**
   * Text not exceeding 255 characters
   *
   * @maxLength 255
   * @minLength 1
   */
  title?: string;
  /**
   * Text not exceeding 100 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 100
   * @minLength 1
   */
  address1: string;
  /**
   * The name of the copyright holder. Text not exceeding 60 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 60
   * @minLength 1
   */
  agent_name: string;
  /**
   * Can be `0` for false or `1` for true. Must be value: 1 for DMCA reports
   */
  agree: 1;
  /**
   * Text not exceeding 255 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 255
   * @minLength 1
   */
  city: string;
  /**
   * Text not exceeding 255 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 255
   * @minLength 1
   */
  country: string;
  /**
   * Notification type based on the abuse type. NOTE: Copyright (DMCA) and Trademark reports cannot be anonymous.
   */
  host_notification: "send";
  /**
   * Text not exceeding 255 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 255
   * @minLength 1
   */
  original_work: string;
  /**
   * Notification type based on the abuse type. NOTE: Copyright (DMCA) and Trademark reports cannot be anonymous.
   */
  owner_notification: "send";
  /**
   * Required for DMCA reports, should be same as Name. An affirmation that all information in the report is true and accurate while agreeing to the policies of Cloudflare's abuse reports
   */
  signature: string;
  /**
   * Text not exceeding 255 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 255
   * @minLength 1
   */
  state: string;
};

/**
 * You have already submitted this URL in the last 7 days
 */
export type AbuseReportsDedupeError = string;

/**
 * Provided emails did not match
 */
export type AbuseReportsDiffEmailError = string;

/**
 * Failed to send confirmation email
 */
export type AbuseReportsEmailError = string;

export type AbuseReportsErrorCode =
  | AbuseReportsBadActError
  | AbuseReportsBadAddressError
  | AbuseReportsBadAgentNameError
  | AbuseReportsBadCityError
  | AbuseReportsBadCountryError
  | AbuseReportsBadPortsProtocolError
  | AbuseReportsBadStateError
  | AbuseReportsMaxIPsError
  | AbuseReportsPortsProtocolError
  | AbuseReportsBadCommentsError
  | AbuseReportsBadEmailError
  | AbuseReportsBadIPError
  | AbuseReportsBadJustError
  | AbuseReportsBadNameError
  | AbuseReportsBadUrlsError
  | AbuseReportsDBError
  | AbuseReportsDedupeError
  | AbuseReportsDiffEmailError
  | AbuseReportsEmailError
  | AbuseReportsInternalError
  | AbuseReportsInvalidNotifyError
  | AbuseReportsMustNotifyError
  | AbuseReportsNoAgreeError
  | AbuseReportsNoOriginalWorkError
  | AbuseReportsNoSigError
  | AbuseReportsUnexpectedActError
  | AbuseReportsUnknownError
  | AbuseReportsUrlNotOrangeError
  | AbuseReportsUrlNotvalidError;

export type AbuseReportsGeneralReport = {
  act?: AbuseReportsReportType;
  /**
   * A valid email of the abuse reporter. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   */
  email?: string;
  /**
   * Should match the value provided in `email`
   */
  email2?: string;
  /**
   * Text not exceeding 255 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 255
   * @minLength 1
   */
  name: string;
  /**
   * A list of valid URLs separated by ‘\n’ (new line character). The list of the URLs should not exceed 250 URLs. All URLs should have the same hostname. Each URL should be unique. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   */
  urls: string;
  /**
   * Any additional comments about the infringement not exceeding 2000 characters
   *
   * @maxLength 2000
   * @minLength 1
   */
  comments?: string;
  /**
   * Text not exceeding 100 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 100
   * @minLength 1
   */
  company?: string;
  /**
   * Text containing 2 characters
   *
   * @maxLength 2
   * @minLength 2
   */
  reported_country?: string;
  /**
   * Text not exceeding 255 characters
   *
   * @maxLength 255
   * @minLength 1
   */
  reported_user_agent?: string;
  /**
   * Text not exceeding 20 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 20
   * @minLength 1
   */
  tele?: string;
  /**
   * Text not exceeding 255 characters
   *
   * @maxLength 255
   * @minLength 1
   */
  title?: string;
  /**
   * A list of IP addresses separated by ‘\n’ (new line character). The list of destination IPs should not exceed 30 IP addresses. Each one of the IP addresses ought to be unique.
   */
  destination_ips?: string;
  /**
   * Notification type based on the abuse type. NOTE: Copyright (DMCA) and Trademark reports cannot be anonymous.
   */
  host_notification: "send" | "send-anon";
  /**
   * A detailed description of the infringement, including any necessary access details and the exact steps needed to view the content, not exceeding 5000 characters.
   *
   * @maxLength 5000
   * @minLength 1
   */
  justification: string;
  /**
   * Notification type based on the abuse type. NOTE: Copyright (DMCA) and Trademark reports cannot be anonymous.
   */
  owner_notification: "send" | "send-anon" | "none";
  /**
   * A comma separated list of ports and protocols e.g. 80/TCP, 22/UDP. The total size of the field should not exceed 2000 characters. Each individual port/protocol should not exceed 100 characters. The list should not have more than 30 unique ports and protocols.
   */
  ports_protocols?: string;
  /**
   * A list of IP addresses separated by ‘\n’ (new line character). The list of source IPs should not exceed 30 IP addresses. Each one of the IP addresses ought to be unique.
   */
  source_ips?: string;
};

/**
 * Failed to translate email
 */
export type AbuseReportsInternalError = string;

/**
 * Invalid value for notification preference
 */
export type AbuseReportsInvalidNotifyError = string;

/**
 * Provided value has invalid size
 */
export type AbuseReportsMaxIPsError = string;

/**
 * Please pick one party to notify about this report
 */
export type AbuseReportsMustNotifyError = string;

export type AbuseReportsNCSEIReport = {
  act?: AbuseReportsReportType;
  /**
   * A valid email of the abuse reporter. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   */
  email?: string;
  /**
   * Should match the value provided in `email`
   */
  email2?: string;
  /**
   * Text not exceeding 255 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 255
   * @minLength 1
   */
  name: string;
  /**
   * A list of valid URLs separated by ‘\n’ (new line character). The list of the URLs should not exceed 250 URLs. All URLs should have the same hostname. Each URL should be unique. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   */
  urls: string;
  /**
   * Any additional comments about the infringement not exceeding 2000 characters
   *
   * @maxLength 2000
   * @minLength 1
   */
  comments?: string;
  /**
   * Text not exceeding 100 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 100
   * @minLength 1
   */
  company?: string;
  /**
   * Text containing 2 characters
   *
   * @maxLength 2
   * @minLength 2
   */
  reported_country?: string;
  /**
   * Text not exceeding 255 characters
   *
   * @maxLength 255
   * @minLength 1
   */
  reported_user_agent?: string;
  /**
   * Text not exceeding 20 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 20
   * @minLength 1
   */
  tele?: string;
  /**
   * Text not exceeding 255 characters
   *
   * @maxLength 255
   * @minLength 1
   */
  title?: string;
  /**
   * Text not exceeding 255 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 255
   * @minLength 1
   */
  country?: string;
  /**
   * Notification type based on the abuse type. NOTE: Copyright (DMCA) and Trademark reports cannot be anonymous.
   */
  host_notification: "send" | "send-anon";
  /**
   * If the submitter is the target of NCSEI in the URLs of the abuse report.
   */
  ncsei_subject_representation: boolean;
  /**
   * Notification type based on the abuse type. NOTE: Copyright (DMCA) and Trademark reports cannot be anonymous.
   */
  owner_notification: "send" | "send-anon" | "none";
};

/**
 * Must acknowledge that you are bound by 512(f), that you have a good faith belief about the material, and that you have the authority to act
 */
export type AbuseReportsNoAgreeError = string;

/**
 * Original Work section must be between 1 and 2000 characters
 */
export type AbuseReportsNoOriginalWorkError = string;

/**
 * Signature must match your name
 */
export type AbuseReportsNoSigError = string;

export type AbuseReportsOptionalBaseReportFields = {
  /**
   * Any additional comments about the infringement not exceeding 2000 characters
   *
   * @maxLength 2000
   * @minLength 1
   */
  comments?: string;
  /**
   * Text not exceeding 100 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 100
   * @minLength 1
   */
  company?: string;
  /**
   * Text containing 2 characters
   *
   * @maxLength 2
   * @minLength 2
   */
  reported_country?: string;
  /**
   * Text not exceeding 255 characters
   *
   * @maxLength 255
   * @minLength 1
   */
  reported_user_agent?: string;
  /**
   * Text not exceeding 20 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 20
   * @minLength 1
   */
  tele?: string;
  /**
   * Text not exceeding 255 characters
   *
   * @maxLength 255
   * @minLength 1
   */
  title?: string;
};

export type AbuseReportsPhishingReport = {
  act?: AbuseReportsReportType;
  /**
   * A valid email of the abuse reporter. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   */
  email?: string;
  /**
   * Should match the value provided in `email`
   */
  email2?: string;
  /**
   * Text not exceeding 255 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 255
   * @minLength 1
   */
  name: string;
  /**
   * A list of valid URLs separated by ‘\n’ (new line character). The list of the URLs should not exceed 250 URLs. All URLs should have the same hostname. Each URL should be unique. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   */
  urls: string;
  /**
   * Any additional comments about the infringement not exceeding 2000 characters
   *
   * @maxLength 2000
   * @minLength 1
   */
  comments?: string;
  /**
   * Text not exceeding 100 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 100
   * @minLength 1
   */
  company?: string;
  /**
   * Text containing 2 characters
   *
   * @maxLength 2
   * @minLength 2
   */
  reported_country?: string;
  /**
   * Text not exceeding 255 characters
   *
   * @maxLength 255
   * @minLength 1
   */
  reported_user_agent?: string;
  /**
   * Text not exceeding 20 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 20
   * @minLength 1
   */
  tele?: string;
  /**
   * Text not exceeding 255 characters
   *
   * @maxLength 255
   * @minLength 1
   */
  title?: string;
  /**
   * Notification type based on the abuse type. NOTE: Copyright (DMCA) and Trademark reports cannot be anonymous.
   */
  host_notification: "send" | "send-anon";
  /**
   * A detailed description of the infringement, including any necessary access details and the exact steps needed to view the content, not exceeding 5000 characters.
   *
   * @maxLength 5000
   * @minLength 20
   */
  justification: string;
  /**
   * Text not exceeding 255 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 255
   * @minLength 1
   */
  original_work?: string;
  /**
   * Notification type based on the abuse type. NOTE: Copyright (DMCA) and Trademark reports cannot be anonymous.
   */
  owner_notification: "send" | "send-anon";
};

/**
 * Provided value has invalid size
 */
export type AbuseReportsPortsProtocolError = string;

export type AbuseReportsRegistrarWhoisReport = {
  act?: AbuseReportsReportType;
  /**
   * A valid email of the abuse reporter. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   */
  email: string;
  /**
   * Should match the value provided in `email`
   */
  email2: string;
  /**
   * Text not exceeding 255 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 255
   * @minLength 1
   */
  name: string;
  /**
   * A list of valid URLs separated by ‘\n’ (new line character). The list of the URLs should not exceed 250 URLs. All URLs should have the same hostname. Each URL should be unique. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   */
  urls: string;
  /**
   * Any additional comments about the infringement not exceeding 2000 characters
   *
   * @maxLength 2000
   * @minLength 1
   */
  comments?: string;
  /**
   * Text not exceeding 100 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 100
   * @minLength 1
   */
  company?: string;
  /**
   * Text containing 2 characters
   *
   * @maxLength 2
   * @minLength 2
   */
  reported_country?: string;
  /**
   * Text not exceeding 255 characters
   *
   * @maxLength 255
   * @minLength 1
   */
  reported_user_agent?: string;
  /**
   * Text not exceeding 20 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 20
   * @minLength 1
   */
  tele?: string;
  /**
   * Text not exceeding 255 characters
   *
   * @maxLength 255
   * @minLength 1
   */
  title?: string;
  /**
   * Notification type based on the abuse type. NOTE: Copyright (DMCA) and Trademark reports cannot be anonymous.
   */
  owner_notification: "send" | "send-anon" | "none";
};

/**
 * The abuse report type.
 *
 * @example abuse_general
 */
export type AbuseReportsReportType =
  | "abuse_dmca"
  | "abuse_trademark"
  | "abuse_general"
  | "abuse_phishing"
  | "abuse_children"
  | "abuse_threat"
  | "abuse_registrar_whois"
  | "abuse_ncsei";

export type AbuseReportsRequiredBaseReportFields = {
  act: AbuseReportsReportType;
  /**
   * A valid email of the abuse reporter. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   */
  email: string;
  /**
   * Should match the value provided in `email`
   */
  email2: string;
  /**
   * Text not exceeding 255 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 255
   * @minLength 1
   */
  name: string;
  /**
   * A list of valid URLs separated by ‘\n’ (new line character). The list of the URLs should not exceed 250 URLs. All URLs should have the same hostname. Each URL should be unique. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   */
  urls: string;
};

export type AbuseReportsSubmitErrorResponse = {
  error_code: AbuseReportsErrorCode;
  /**
   * The error message for the error
   */
  msg: string;
  request: {
    act: AbuseReportsReportType;
  };
  /**
   * The result should be 'error' for successful response
   */
  result: string;
};

export type AbuseReportsSubmitReportRequest =
  | (Omit<AbuseReportsDMCAReport, "act"> & {
      act: "abuse_dmca";
    })
  | (Omit<AbuseReportsTrademarkReport, "act"> & {
      act: "abuse_trademark";
    })
  | (Omit<AbuseReportsGeneralReport, "act"> & {
      act: "abuse_general";
    })
  | (Omit<AbuseReportsPhishingReport, "act"> & {
      act: "abuse_phishing";
    })
  | (Omit<AbuseReportsCSAMReport, "act"> & {
      act: "abuse_children";
    })
  | (Omit<AbuseReportsThreatReport, "act"> & {
      act: "abuse_threat";
    })
  | (Omit<AbuseReportsRegistrarWhoisReport, "act"> & {
      act: "abuse_registrar_whois";
    })
  | (Omit<AbuseReportsNCSEIReport, "act"> & {
      act: "abuse_ncsei";
    });

export type AbuseReportsSubmitReportResponse = {
  /**
   * The identifier for the submitted abuse report.
   */
  abuse_rand: string;
  request: {
    act: AbuseReportsReportType;
  };
  /**
   * The result should be 'success' for successful response
   */
  result: string;
};

export type AbuseReportsThreatReport = {
  act?: AbuseReportsReportType;
  /**
   * A valid email of the abuse reporter. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   */
  email?: string;
  /**
   * Should match the value provided in `email`
   */
  email2?: string;
  /**
   * Text not exceeding 255 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 255
   * @minLength 1
   */
  name: string;
  /**
   * A list of valid URLs separated by ‘\n’ (new line character). The list of the URLs should not exceed 250 URLs. All URLs should have the same hostname. Each URL should be unique. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   */
  urls: string;
  /**
   * Any additional comments about the infringement not exceeding 2000 characters
   *
   * @maxLength 2000
   * @minLength 1
   */
  comments?: string;
  /**
   * Text not exceeding 100 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 100
   * @minLength 1
   */
  company?: string;
  /**
   * Text containing 2 characters
   *
   * @maxLength 2
   * @minLength 2
   */
  reported_country?: string;
  /**
   * Text not exceeding 255 characters
   *
   * @maxLength 255
   * @minLength 1
   */
  reported_user_agent?: string;
  /**
   * Text not exceeding 20 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 20
   * @minLength 1
   */
  tele?: string;
  /**
   * Text not exceeding 255 characters
   *
   * @maxLength 255
   * @minLength 1
   */
  title?: string;
  /**
   * Notification type based on the abuse type. NOTE: Copyright (DMCA) and Trademark reports cannot be anonymous.
   */
  host_notification: "send" | "send-anon";
  /**
   * A detailed description of the infringement, including any necessary access details and the exact steps needed to view the content, not exceeding 5000 characters.
   *
   * @maxLength 5000
   * @minLength 1
   */
  justification: string;
  /**
   * Notification type based on the abuse type. NOTE: Copyright (DMCA) and Trademark reports cannot be anonymous.
   */
  owner_notification: "send" | "send-anon";
};

export type AbuseReportsTrademarkReport = {
  act?: AbuseReportsReportType;
  /**
   * A valid email of the abuse reporter. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   */
  email?: string;
  /**
   * Should match the value provided in `email`
   */
  email2?: string;
  /**
   * Text not exceeding 255 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 255
   * @minLength 1
   */
  name?: string;
  /**
   * A list of valid URLs separated by ‘\n’ (new line character). The list of the URLs should not exceed 250 URLs. All URLs should have the same hostname. Each URL should be unique. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   */
  urls?: string;
  /**
   * Any additional comments about the infringement not exceeding 2000 characters
   *
   * @maxLength 2000
   * @minLength 1
   */
  comments?: string;
  /**
   * Text not exceeding 100 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 100
   * @minLength 1
   */
  company?: string;
  /**
   * Text containing 2 characters
   *
   * @maxLength 2
   * @minLength 2
   */
  reported_country?: string;
  /**
   * Text not exceeding 255 characters
   *
   * @maxLength 255
   * @minLength 1
   */
  reported_user_agent?: string;
  /**
   * Text not exceeding 20 characters. This field may be released by Cloudflare to third parties such as the Lumen Database (https://lumendatabase.org/).
   *
   * @maxLength 20
   * @minLength 1
   */
  tele?: string;
  /**
   * Text not exceeding 255 characters
   *
   * @maxLength 255
   * @minLength 1
   */
  title?: string;
  /**
   * Notification type based on the abuse type. NOTE: Copyright (DMCA) and Trademark reports cannot be anonymous.
   */
  host_notification: "send";
  /**
   * A detailed description of the infringement, including any necessary access details and the exact steps needed to view the content, not exceeding 5000 characters.
   *
   * @maxLength 5000
   * @minLength 1
   */
  justification: string;
  /**
   * Notification type based on the abuse type. NOTE: Copyright (DMCA) and Trademark reports cannot be anonymous.
   */
  owner_notification: "send";
  /**
   * Text not exceeding 1000 characters
   *
   * @maxLength 1000
   * @minLength 1
   */
  trademark_number: string;
  /**
   * Text not exceeding 1000 characters
   *
   * @maxLength 1000
   * @minLength 1
   */
  trademark_office: string;
  /**
   * Text not exceeding 1000 characters
   *
   * @maxLength 1000
   * @minLength 1
   */
  trademark_symbol: string;
};

/**
 * Report has the wrong type
 */
export type AbuseReportsUnexpectedActError = string;

/**
 * An unexpected error occurred
 */
export type AbuseReportsUnknownError = string;

/**
 * A URL contains a domain that is not active on Cloudflare
 */
export type AbuseReportsUrlNotOrangeError = string;

/**
 * You have entered URLs that contain more than 1 unique hostname. A single report may only include 1 unique hostname (i.e, www.example.com). To report URLs related to another hostname (i.e. other.example.com) you'll need to file a separate report.
 */
export type AbuseReportsUrlNotvalidError = string;

export type AccessAccessRequests = {
  action?: AccessAction;
  allowed?: AccessAllowed;
  app_domain?: AccessAppDomain;
  app_uid?: AccessAppUid;
  connection?: AccessConnection;
  created_at?: AccessTimestamp;
  ip_address?: AccessIp;
  ray_id?: AccessRayId;
  user_email?: AccessComponentsSchemasEmail;
};

export type AccessAccessRequestsComponentsSchemasResponseCollection =
  AccessApiResponseCommon & {
    result?: AccessAccessRequests[];
  };

/**
 * Matches an Access group.
 */
export type AccessAccessGroupRule = {
  group: {
    /**
     * The ID of a previously created Access group.
     *
     * @example aa0a4aab-672b-4bdb-bc33-a59f1130a11f
     */
    id: string;
  };
};

/**
 * True if the seat is part of Access.
 *
 * @example false
 * @x-auditable true
 */
export type AccessAccessSeat = boolean;

/**
 * The event that occurred, such as a login attempt.
 *
 * @example login
 */
export type AccessAction = string;

/**
 * The number of active devices registered to the user.
 *
 * @example 2
 */
export type AccessActiveDeviceCount = number;

export type AccessActiveSessionResponse = AccessApiResponseSingle & {
  result?: AccessIdentity & {
    /**
     * @example true
     */
    isActive?: boolean;
  };
};

export type AccessActiveSessionsResponse = AccessApiResponseCollection & {
  result?: {
    /**
     * @example 1694813506
     */
    expiration?: number;
    metadata?: {
      apps?: {
        [key: string]: {
          /**
           * @example test.example.com
           */
          hostname?: string;
          /**
           * @example app name
           */
          name?: string;
          /**
           * @example self_hosted
           */
          type?: string;
          /**
           * @example cc2a8145-0128-4429-87f3-872c4d380c4e
           */
          uid?: string;
        };
      };
      /**
       * @example 1694813506
       */
      expires?: number;
      /**
       * @example 1694791905
       */
      iat?: number;
      /**
       * @example X1aXj1lFVcqqyoXF
       */
      nonce?: string;
      /**
       * @example 21600
       */
      ttl?: number;
    };
    name?: string;
  }[];
};

/**
 * Allows all HTTP request headers.
 *
 * @example true
 */
export type AccessAllowAllHeaders = boolean;

/**
 * Allows all HTTP request methods.
 */
export type AccessAllowAllMethods = boolean;

/**
 * Allows all origins.
 */
export type AccessAllowAllOrigins = boolean;

/**
 * When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value.
 *
 * @example false
 * @x-auditable true
 */
export type AccessAllowAuthenticateViaWarp = boolean;

/**
 * When set to `true`, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
 */
export type AccessAllowCredentials = boolean;

/**
 * Enables using Identity Provider email alias as SSH username.
 *
 * @x-auditable true
 */
export type AccessAllowEmailAlias = boolean;

/**
 * Enables loading application content in an iFrame.
 *
 * @example true
 */
export type AccessAllowIframe = boolean;

/**
 * The result of the authentication event.
 *
 * @default false
 */
export type AccessAllowed = boolean;

/**
 * Allowed HTTP request headers.
 */
export type AccessAllowedHeaders = string[];

/**
 * The identity providers your users can select when connecting to this application. Defaults to all IdPs configured in your account.
 */
export type AccessAllowedIdps = string[];

/**
 * Allowed HTTP request methods.
 *
 * @example GET
 */
export type AccessAllowedMethods = (
  | "GET"
  | "POST"
  | "HEAD"
  | "PUT"
  | "DELETE"
  | "CONNECT"
  | "OPTIONS"
  | "TRACE"
  | "PATCH"
)[];

/**
 * Allowed origins.
 *
 * @example https://example.com
 */
export type AccessAllowedOrigins = string[];

/**
 * Matches any valid Access Service Token
 */
export type AccessAnyValidServiceTokenRule = {
  /**
   * An empty object which matches on all service tokens.
   *
   * @example {}
   * @x-stainless-empty-object true
   */
  any_valid_service_token: Record<string, any>;
};

export type AccessApiResponseCollection = AccessApiResponseCommon & {
  result_info?: {
    /**
     * Total number of results for the requested service.
     *
     * @example 1
     */
    count?: number;
    /**
     * Current page within paginated list of results.
     *
     * @example 1
     */
    page?: number;
    /**
     * Number of results per page of results.
     *
     * @example 20
     */
    per_page?: number;
    /**
     * Total results available without any search parameters.
     *
     * @example 2000
     */
    total_count?: number;
  };
};

export type AccessApiResponseCommon = {
  errors: AccessMessages;
  messages: AccessMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type AccessApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: AccessMessages;
  messages: AccessMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type AccessApiResponseSingle = AccessApiResponseCommon;

export type AccessAppPoliciesComponentsSchemasIdResponse =
  AccessApiResponseSingle & {
    result?: {
      id?: AccessUuid;
    };
  };

export type AccessAppPoliciesComponentsSchemasResponseCollection =
  AccessApiResponseCollection & {
    result?: AccessAppPolicyResponse[];
  };

export type AccessAppPoliciesComponentsSchemasSingleResponse =
  AccessApiResponseSingle & {
    result?: AccessAppPolicyResponse;
  };

/**
 * Number of access applications currently using this policy.
 *
 * @example 2
 * @x-auditable true
 */
export type AccessAppCount = number;

/**
 * The URL of the Access application.
 *
 * @example test.example.com/admin
 */
export type AccessAppDomain = string;

export type AccessAppId = AccessIdentifier | AccessUuid;

/**
 * The image URL of the logo shown in the App Launcher header.
 *
 * @example https://www.cloudflare.com/img/logo-web-badges/cf-logo-on-white-bg.svg
 */
export type AccessAppLauncherLogoUrl = string;

export type AccessAppLauncherProps = {
  allowed_idps?: AccessAllowedIdps;
  app_launcher_logo_url?: AccessAppLauncherLogoUrl;
  auto_redirect_to_identity?: AccessSchemasAutoRedirectToIdentity;
  bg_color?: AccessBgColor;
  /**
   * @example authdomain.cloudflareaccess.com
   */
  domain?: AccessDomain;
  footer_links?: AccessFooterLinks;
  header_bg_color?: AccessHeaderBgColor;
  landing_page_design?: AccessLandingPageDesign;
  /**
   * @default App Launcher
   * @example App Launcher
   */
  name?: AccessAppsComponentsSchemasName;
  session_duration?: AccessSchemasSessionDuration;
  skip_app_launcher_login_page?: AccessSkipAppLauncherLoginPage;
  /**
   * The application type.
   *
   * @example app_launcher
   */
  type: AccessType;
};

/**
 * Displays the application in the App Launcher.
 *
 * @default true
 * @example true
 */
export type AccessAppLauncherVisible = boolean;

/**
 * A JSON that links a reusable policy to an application.
 */
export type AccessAppPolicyLink = {
  id?: AccessSchemasUuid;
  precedence?: AccessPrecedence;
};

export type AccessAppPolicyRequest = {
  precedence?: AccessPrecedence;
} & AccessPolicyReq;

export type AccessAppPolicyResponse = AccessPolicyResp & {
  precedence?: AccessPrecedence;
};

export type AccessAppReqEmbeddedPolicies = {
  /**
   * The policies that Access applies to the application, in ascending order of precedence. Items can reference existing policies or create new policies exclusive to the application.
   */
  policies?: (
    | AccessAppPolicyLink
    | (void & AccessSchemasUuid)
    | (Record<string, any> & {
        id?: AccessSchemasUuid;
      } & AccessAppPolicyRequest)
  )[];
};

export type AccessAppReqEmbeddedScimConfig = {
  scim_config?: AccessScimConfig;
};

export type AccessAppRequest =
  | (AccessSelfHostedProps &
      AccessAppReqEmbeddedPolicies &
      AccessAppReqEmbeddedScimConfig)
  | (AccessSaasProps &
      AccessAppReqEmbeddedPolicies &
      AccessAppReqEmbeddedScimConfig)
  | (AccessSshProps &
      AccessAppReqEmbeddedPolicies &
      AccessAppReqEmbeddedScimConfig)
  | (AccessVncProps &
      AccessAppReqEmbeddedPolicies &
      AccessAppReqEmbeddedScimConfig)
  | (AccessAppLauncherProps &
      AccessAppReqEmbeddedPolicies &
      AccessAppReqEmbeddedScimConfig)
  | (AccessWarpProps &
      AccessAppReqEmbeddedPolicies &
      AccessAppReqEmbeddedScimConfig)
  | (AccessBisoProps &
      AccessAppReqEmbeddedPolicies &
      AccessAppReqEmbeddedScimConfig)
  | (AccessBookmarkProps & AccessAppReqEmbeddedScimConfig)
  | (AccessInfraProps & AccessInfraAppReqEmbeddedPolicies)
  | (AccessRdpProps &
      AccessAppReqEmbeddedPolicies &
      AccessAppReqEmbeddedScimConfig);

/**
 * The policies that Access applies to the application.
 */
export type AccessAppRespEmbeddedPolicies = {
  policies?: AccessAppPolicyResponse[];
};

/**
 * Contains the targets secured by the application.
 */
export type AccessAppRespEmbeddedTargetCriteriaInfra = {
  target_criteria?: AccessTargetCriteriaInfraApp[];
};

/**
 * Contains the targets secured by the application.
 */
export type AccessAppRespEmbeddedTargetCriteriaSelfHosted = {
  target_criteria?: AccessTargetCriteriaSelfHostedApp[];
};

export type AccessAppResponse =
  | (AccessBasicAppResponseProps &
      AccessSelfHostedProps &
      AccessAppRespEmbeddedPolicies)
  | (AccessBasicAppResponseProps &
      AccessSaasProps &
      AccessAppRespEmbeddedPolicies)
  | (AccessBasicAppResponseProps &
      AccessSshProps &
      AccessAppRespEmbeddedPolicies)
  | (AccessBasicAppResponseProps &
      AccessVncProps &
      AccessAppRespEmbeddedPolicies)
  | (AccessBasicAppResponseProps &
      AccessAppLauncherProps &
      AccessAppRespEmbeddedPolicies)
  | (AccessBasicAppResponseProps &
      AccessWarpProps &
      AccessAppRespEmbeddedPolicies)
  | (AccessBasicAppResponseProps &
      AccessBisoProps &
      AccessAppRespEmbeddedPolicies)
  | (AccessBasicAppResponseProps & AccessBookmarkProps)
  | (AccessBasicAppResponseProps &
      AccessInfraProps &
      AccessInfraAppRespEmbeddedPolicies)
  | (AccessBasicAppResponseProps &
      AccessRdpProps &
      AccessAppRespEmbeddedPolicies);

export type AccessAppSettingsRequest = {
  allow_iframe?: AccessAllowIframe;
  skip_interstitial?: AccessSkipInterstitial;
};

export type AccessAppSettingsResponse = {
  allow_iframe?: AccessAllowIframe;
  skip_interstitial?: AccessSkipInterstitial;
};

/**
 * The unique identifier for the Access application.
 *
 * @example df7e2w5f-02b7-4d9d-af26-8d1988fca630
 */
export type AccessAppUid = string;

/**
 * A group of email addresses that can approve a temporary authentication request.
 */
export type AccessApprovalGroup = {
  /**
   * The number of approvals needed to obtain access.
   *
   * @example 1
   * @minimum 0
   */
  approvals_needed: number;
  /**
   * A list of emails that can approve the access request.
   *
   * @example test@cloudflare.com
   * @example test2@cloudflare.com
   */
  email_addresses?: string[];
  /**
   * The UUID of an re-usable email list.
   */
  email_list_uuid?: string;
};

/**
 * Administrators who can approve a temporary authentication request.
 *
 * @example {"approvals_needed":1,"email_addresses":["test1@cloudflare.com","test2@cloudflare.com"]}
 * @example {"approvals_needed":3,"email_list_uuid":"597147a1-976b-4ef2-9af0-81d5d007fc34"}
 */
export type AccessApprovalGroups = AccessApprovalGroup[];

/**
 * Requires the user to request access from an administrator at the start of each session.
 *
 * @example true
 */
export type AccessApprovalRequired = boolean;

export type AccessApps =
  | (AccessSchemasBasicAppResponseProps & AccessSchemasSelfHostedProps)
  | (AccessSchemasBasicAppResponseProps & AccessSchemasSaasProps)
  | (AccessSchemasBasicAppResponseProps & AccessSchemasSshProps)
  | (AccessSchemasBasicAppResponseProps & AccessSchemasVncProps)
  | (AccessSchemasBasicAppResponseProps & AccessSchemasAppLauncherProps)
  | (AccessSchemasBasicAppResponseProps & AccessSchemasWarpProps)
  | (AccessSchemasBasicAppResponseProps & AccessSchemasBisoProps)
  | (AccessSchemasBasicAppResponseProps & AccessSchemasBookmarkProps);

/**
 * The name of the application.
 *
 * @example Admin Site
 */
export type AccessAppsComponentsSchemasName = string;

export type AccessAppsComponentsSchemasResponseCollection =
  AccessApiResponseCollection & {
    result?: AccessAppResponse[];
  };

export type AccessAppsComponentsSchemasResponseCollection2 =
  AccessApiResponseCollection & {
    result?: AccessApps[];
  };

/**
 * The amount of time that tokens issued for this application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
 *
 * @default 24h
 * @example 24h
 */
export type AccessAppsComponentsSchemasSessionDuration = string;

export type AccessAppsComponentsSchemasSingleResponse =
  AccessApiResponseSingle & {
    result?: AccessAppResponse;
  };

export type AccessAppsComponentsSchemasSingleResponse2 =
  AccessApiResponseSingle & {
    result?: AccessApps;
  };

/**
 * The hostnames of the applications that will use this certificate.
 */
export type AccessAssociatedHostnames = string[];

/**
 * The Application Audience (AUD) tag. Identifies the application associated with the CA.
 *
 * @example 737646a56ab1df6ec9bddc7e5ca84eaf3b0768850f3ffb5d74f1534911fe3893
 * @maxLength 64
 * @x-auditable true
 */
export type AccessAud = string;

/**
 * Matches an Azure Authentication Context.
 * Requires an Azure identity provider.
 */
export type AccessAuthContextRule = {
  auth_context: {
    /**
     * The ACID of an Authentication context.
     *
     * @example ea85612a-29c8-46c2-bacb-669d65136971
     */
    ac_id: string;
    /**
     * The ID of an Authentication context.
     *
     * @example aa0a4aab-672b-4bdb-bc33-a59f1130a11f
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     *
     * @example ea85612a-29c8-46c2-bacb-669d65136971
     */
    identity_provider_id: string;
  };
};

/**
 * The unique subdomain assigned to your Zero Trust organization.
 *
 * @example test.cloudflareaccess.com
 * @x-auditable true
 */
export type AccessAuthDomain = string;

/**
 * Enforce different MFA options
 */
export type AccessAuthenticationMethodRule = {
  auth_method: {
    /**
     * The type of authentication method https://datatracker.ietf.org/doc/html/rfc8176#section-2.
     *
     * @example mfa
     */
    auth_method: string;
  };
};

/**
 * When set to `true`, users skip the identity provider selection step during login.
 *
 * @default false
 * @x-auditable true
 */
export type AccessAutoRedirectToIdentity = boolean;

export type AccessAzureAD = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessGenericOauthConfig &
    AccessCustomClaimsSupport & {
      /**
       * Should Cloudflare try to load authentication contexts from your account
       *
       * @x-auditable true
       */
      conditional_access_enabled?: boolean;
      /**
       * Your Azure directory uuid
       *
       * @example <your azure directory uuid>
       * @x-auditable true
       */
      directory_id?: string;
      /**
       * Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction_required error. prompt=select_account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
       *
       * @x-auditable true
       */
      prompt?: "login" | "select_account" | "none";
      /**
       * Should Cloudflare try to load groups from your account
       *
       * @x-auditable true
       */
      support_groups?: boolean;
    };
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     *
     * @x-auditable true
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

/**
 * Matches an Azure group.
 * Requires an Azure identity provider.
 */
export type AccessAzureGroupRule = {
  azureAD: {
    /**
     * The ID of an Azure group.
     *
     * @example aa0a4aab-672b-4bdb-bc33-a59f1130a11f
     */
    id: string;
    /**
     * The ID of your Azure identity provider.
     *
     * @example ea85612a-29c8-46c2-bacb-669d65136971
     */
    identity_provider_id: string;
  };
};

export type AccessBasePolicyReq = {
  decision: AccessDecision;
  exclude?: AccessSchemasExclude;
  include: AccessSchemasInclude;
  name: AccessPolicyComponentsSchemasName;
  require?: AccessSchemasRequire;
};

export type AccessBasePolicyResp = {
  created_at?: AccessTimestamp;
  decision?: AccessDecision;
  exclude?: AccessSchemasExclude;
  id?: AccessSchemasUuid;
  include?: AccessSchemasInclude;
  name?: AccessPolicyComponentsSchemasName;
  require?: AccessSchemasRequire;
  updated_at?: AccessTimestamp;
};

export type AccessBasicAppResponseProps = {
  aud?: AccessSchemasAud;
  created_at?: AccessTimestamp;
  id?: AccessUuid;
  scim_config?: AccessScimConfig;
  updated_at?: AccessTimestamp;
};

/**
 * The background color of the App Launcher page.
 *
 * @example #ff0000
 */
export type AccessBgColor = string;

export type AccessBisoProps = {
  allowed_idps?: AccessAllowedIdps;
  app_launcher_logo_url?: AccessAppLauncherLogoUrl;
  auto_redirect_to_identity?: AccessSchemasAutoRedirectToIdentity;
  bg_color?: AccessBgColor;
  /**
   * @example authdomain.cloudflareaccess.com/browser
   */
  domain?: AccessDomain;
  footer_links?: AccessFooterLinks;
  header_bg_color?: AccessHeaderBgColor;
  landing_page_design?: AccessLandingPageDesign;
  /**
   * @default Clientless Web Isolation
   * @example Clientless Web Isolation
   */
  name?: AccessAppsComponentsSchemasName;
  session_duration?: AccessSchemasSessionDuration;
  skip_app_launcher_login_page?: AccessSkipAppLauncherLoginPage;
  /**
   * The application type.
   *
   * @example biso
   */
  type: AccessType;
};

export type AccessBookmarkProps = {
  app_launcher_visible?: AccessAppLauncherVisible;
  /**
   * The URL or domain of the bookmark.
   *
   * @example https://mybookmark.com
   */
  domain?: string;
  logo_url?: AccessLogoUrl;
  name?: AccessAppsComponentsSchemasName;
  tags?: AccessTags;
  /**
   * The application type.
   *
   * @example bookmark
   */
  type?: AccessType & void;
};

export type AccessBookmarks = {
  app_launcher_visible?: AccessSchemasAppLauncherVisible;
  created_at?: AccessTimestamp;
  domain?: AccessSchemasDomain;
  /**
   * The unique identifier for the Bookmark application.
   */
  id?: string;
  logo_url?: AccessSchemasLogoUrl;
  name?: AccessBookmarksComponentsSchemasName;
  updated_at?: AccessTimestamp;
};

/**
 * The name of the Bookmark application.
 *
 * @example My Website
 * @x-auditable true
 */
export type AccessBookmarksComponentsSchemasName = string;

export type AccessBookmarksComponentsSchemasResponseCollection =
  AccessApiResponseCollection & {
    result?: AccessBookmarks[];
  };

export type AccessBookmarksComponentsSchemasSingleResponse =
  AccessApiResponseSingle & {
    result?: AccessBookmarks;
  };

/**
 * The background color of the log in button on the landing page.
 *
 * @example #ff0000
 */
export type AccessButtonColor = string;

/**
 * The color of the text in the log in button on the landing page.
 *
 * @example #ff0000
 */
export type AccessButtonTextColor = string;

export type AccessCa = {
  aud?: AccessAud;
  id?: AccessSchemasId;
  public_key?: AccessPublicKey;
};

export type AccessCaComponentsSchemasIdResponse = AccessApiResponseSingle & {
  result?: {
    id?: AccessComponentsSchemasId;
  };
};

export type AccessCaComponentsSchemasResponseCollection =
  AccessApiResponseCollection & {
    result?: AccessCa[];
  };

export type AccessCaComponentsSchemasResponseCollection2 =
  AccessApiResponseCollection & {
    result?: AccessSchemasCa[];
  };

export type AccessCaComponentsSchemasSingleResponse =
  AccessApiResponseSingle & {
    result?: AccessCa;
  };

export type AccessCaComponentsSchemasSingleResponse2 =
  AccessApiResponseSingle & {
    result?: AccessSchemasCa;
  };

export type AccessCentrify = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessGenericOauthConfig &
    AccessCustomClaimsSupport & {
      /**
       * Your centrify account url
       *
       * @example https://abc123.my.centrify.com/
       * @x-auditable true
       */
      centrify_account?: string;
      /**
       * Your centrify app id
       *
       * @example exampleapp
       * @x-auditable true
       */
      centrify_app_id?: string;
    };
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     *
     * @x-auditable true
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

/**
 * Matches any valid client certificate.
 *
 * @example {"certificate":{}}
 */
export type AccessCertificateRule = {
  /**
   * @example {}
   * @x-stainless-empty-object true
   */
  certificate: Record<string, any>;
};

export type AccessCertificates = {
  associated_hostnames?: AccessAssociatedHostnames;
  created_at?: AccessTimestamp;
  expires_on?: AccessTimestamp;
  fingerprint?: AccessFingerprint;
  /**
   * The ID of the application that will use this certificate.
   *
   * @x-auditable true
   */
  id?: string;
  name?: AccessCertificatesComponentsSchemasName;
  updated_at?: AccessTimestamp;
};

/**
 * The name of the certificate.
 *
 * @example Allow devs
 * @x-auditable true
 */
export type AccessCertificatesComponentsSchemasName = string;

/**
 * The name of the certificate.
 *
 * @example Allow devs
 */
export type AccessCertificatesComponentsSchemasName2 = string;

export type AccessCertificatesComponentsSchemasResponseCollection =
  AccessApiResponseCollection & {
    result?: AccessCertificates[];
  };

export type AccessCertificatesComponentsSchemasResponseCollection2 =
  AccessApiResponseCollection & {
    result?: AccessComponentsSchemasCertificates[];
  };

export type AccessCertificatesComponentsSchemasSingleResponse =
  AccessApiResponseSingle & {
    result?: AccessCertificates;
  };

export type AccessCertificatesComponentsSchemasSingleResponse2 =
  AccessApiResponseSingle & {
    result?: AccessComponentsSchemasCertificates;
  };

/**
 * The unique Cloudflare-generated Id of the SCIM Group resource; also known as the "Id".
 *
 * @example a2abeb50-59c9-4c01-8c5c-963d3bf5700f
 */
export type AccessCfResourceId = string;

/**
 * The Client ID for the service token. Access will check for this value in the `CF-Access-Client-ID` request header.
 *
 * @example 88bf3b6d86161464f6509f7219099e57.access.example.com
 */
export type AccessClientId = string;

/**
 * The Client Secret for the service token. Access will check for this value in the `CF-Access-Client-Secret` request header.
 *
 * @example bdd31cbc4dec990953e39163fbbb194c93313ca9f0a6e420346af9d326b1d2a5
 * @x-sensitive true
 */
export type AccessClientSecret = string;

/**
 * Matches a specific common name.
 */
export type AccessCommonNameRule = {
  common_name: {
    /**
     * The common name to match.
     *
     * @example james@example.com
     */
    common_name: string;
  };
};

/**
 * The Application Audience (AUD) tag. Identifies the application associated with the CA.
 *
 * @example 737646a56ab1df6ec9bddc7e5ca84eaf3b0768850f3ffb5d74f1534911fe3893
 * @maxLength 64
 */
export type AccessComponentsSchemasAud = string;

export type AccessComponentsSchemasCertificates = {
  associated_hostnames?: AccessSchemasAssociatedHostnames;
  created_at?: AccessTimestamp;
  expires_on?: AccessTimestamp;
  fingerprint?: AccessFingerprint;
  /**
   * The ID of the application that will use this certificate.
   */
  id?: void;
  name?: AccessCertificatesComponentsSchemasName2;
  updated_at?: AccessTimestamp;
};

/**
 * The domain and path that Access will secure.
 *
 * @example test.example.com/admin
 */
export type AccessComponentsSchemasDomain = string;

/**
 * The email address of the authenticating user.
 *
 * @example user@example.com
 * @format email
 */
export type AccessComponentsSchemasEmail = string;

/**
 * Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
 */
export type AccessComponentsSchemasExclude = AccessRule[];

export type AccessComponentsSchemasGroups = {
  created_at?: AccessTimestamp;
  exclude?: AccessExclude;
  id?: AccessUuid;
  include?: AccessInclude;
  name?: AccessGroupsComponentsSchemasName2;
  require?: AccessRequire;
  updated_at?: AccessTimestamp;
};

/**
 * The ID of the CA.
 *
 * @example 7eddae4619b50ab1361ba8ae9bd72269a432fea041529ed9
 * @maxLength 48
 */
export type AccessComponentsSchemasId = string;

export type AccessComponentsSchemasIdResponse = AccessApiResponseCommon & {
  result?: {
    id?: AccessUuid;
  };
};

/**
 * @example 699d98642c564d2e855e9661899b7252
 * @x-auditable true
 */
export type AccessComponentsSchemasIdentifier = string;

/**
 * The name of the identity provider, shown to users on the login page.
 *
 * @example Widget Corps IDP
 */
export type AccessComponentsSchemasName = string;

/**
 * Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
 */
export type AccessComponentsSchemasRequire = AccessRule[];

export type AccessComponentsSchemasResponseCollection =
  AccessApiResponseCollection & {
    result?: AccessServiceTokens[];
  };

/**
 * The amount of time that tokens issued for the application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
 *
 * @default 24h
 * @example 24h
 */
export type AccessComponentsSchemasSessionDuration = string;

export type AccessComponentsSchemasSingleResponse = AccessApiResponseSingle & {
  result?: AccessIdentityProviders;
};

/**
 * The application type.
 *
 * @example self_hosted
 */
export type AccessComponentsSchemasType =
  | "self_hosted"
  | "saas"
  | "ssh"
  | "vnc"
  | "app_launcher"
  | "warp"
  | "biso"
  | "bookmark"
  | "dash_sso";

/**
 * The IdP used to authenticate.
 *
 * @example saml
 */
export type AccessConnection = string;

/**
 * The rules that define how users may connect to the targets secured by your application.
 */
export type AccessConnectionRules = {
  ssh?: AccessConnectionRulesSsh;
};

/**
 * The SSH-specific rules that define how users may connect to the targets secured by your application.
 */
export type AccessConnectionRulesSsh = {
  allow_email_alias?: AccessAllowEmailAlias;
  usernames: AccessUsernames;
};

export type AccessCorsHeaders = {
  allow_all_headers?: AccessAllowAllHeaders;
  allow_all_methods?: AccessAllowAllMethods;
  allow_all_origins?: AccessAllowAllOrigins;
  allow_credentials?: AccessAllowCredentials;
  allowed_headers?: AccessAllowedHeaders;
  allowed_methods?: AccessAllowedMethods;
  allowed_origins?: AccessAllowedOrigins;
  max_age?: AccessMaxAge;
};

/**
 * Matches a specific country
 */
export type AccessCountryRule = {
  geo: {
    /**
     * The country code that should be matched.
     *
     * @example US
     */
    country_code: string;
  };
};

export type AccessCreateResponse = AccessApiResponseSingle & {
  result?: {
    client_id?: AccessClientId;
    client_secret?: AccessClientSecret;
    created_at?: AccessTimestamp;
    duration?: AccessDuration;
    /**
     * The ID of the service token.
     */
    id?: string;
    name?: AccessSchemasName;
    updated_at?: AccessTimestamp;
  };
};

export type AccessCustomClaimsSupport = {
  /**
   * Custom claims
   *
   * @example email_verified
   * @example preferred_username
   * @example custom_claim_name
   * @x-auditable true
   */
  claims?: string[];
  /**
   * The claim name for email in the id_token response.
   *
   * @example custom_claim_name
   * @x-auditable true
   */
  email_claim_name?: string;
};

/**
 * Custom page name.
 *
 * @x-auditable true
 */
export type AccessCustomPagesComponentsSchemasName = string;

export type AccessCustomPagesComponentsSchemasResponseCollection =
  AccessApiResponseCollection & {
    result?: AccessCustomPageWithoutHtml[];
  };

export type AccessCustomPagesComponentsSchemasSingleResponse =
  AccessApiResponseSingle & {
    result?: AccessCustomPage;
  };

/**
 * The custom error message shown to a user when they are denied access to the application.
 */
export type AccessCustomDenyMessage = string;

/**
 * The custom URL a user is redirected to when they are denied access to the application when failing identity-based rules.
 */
export type AccessCustomDenyUrl = string;

/**
 * The custom URL a user is redirected to when they are denied access to the application when failing non-identity rules.
 */
export type AccessCustomNonIdentityDenyUrl = string;

export type AccessCustomPage = {
  app_count?: AccessSchemasAppCount;
  created_at?: AccessTimestamp;
  /**
   * Custom page HTML.
   *
   * @example <html><body><h1>Access Denied</h1></body></html>
   * @x-auditable true
   */
  custom_html: string;
  name: AccessCustomPagesComponentsSchemasName;
  type: AccessSchemasType;
  uid?: AccessUuid;
  updated_at?: AccessTimestamp;
};

export type AccessCustomPageWithoutHtml = {
  app_count?: AccessSchemasAppCount;
  created_at?: AccessTimestamp;
  name: AccessCustomPagesComponentsSchemasName;
  type: AccessSchemasType;
  uid?: AccessUuid;
  updated_at?: AccessTimestamp;
};

export type AccessCustomPages = {
  /**
   * The uid of the custom page to use when a user is denied access after failing a non-identity rule.
   *
   * @example 699d98642c564d2e855e9661899b7252
   */
  forbidden?: string;
  /**
   * The uid of the custom page to use when a user is denied access.
   *
   * @example 699d98642c564d2e855e9661899b7252
   */
  identity_denied?: string;
};

/**
 * The number of days until the next key rotation.
 *
 * @example 1
 * @x-auditable true
 */
export type AccessDaysUntilNextRotation = number;

/**
 * The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
 *
 * @example allow
 */
export type AccessDecision = "allow" | "deny" | "non_identity" | "bypass";

/**
 * List of destinations secured by Access. This supersedes `self_hosted_domains` to allow for more flexibility in defining different types of domains. If `destinations` are provided, then `self_hosted_domains` will be ignored.
 *
 * @example {"type":"public","uri":"test.example.com/admin"}
 * @example {"type":"public","uri":"test.anotherexample.com/staff"}
 * @example {"cidr":"10.5.0.0/24","port_range":"80-90","type":"private"}
 * @example {"cidr":"10.5.0.3/32","port_range":"80","type":"private"}
 * @example {"type":"private","uri":"private-sni.example.com"}
 */
export type AccessDestinations = (
  | {
      type?: "public";
      /**
       * The URI of the destination. Public destinations' URIs can include a domain and path with [wildcards](https://developers.cloudflare.com/cloudflare-one/policies/access/app-paths/).
       */
      uri?: string;
    }
  | {
      /**
       * The CIDR range of the destination. Single IPs will be computed as /32.
       */
      cidr?: string;
      /**
       * The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
       */
      hostname?: string;
      /**
       * The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
       */
      l4_protocol?: "tcp" | "udp";
      /**
       * The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
       */
      port_range?: string;
      type?: "private";
      /**
       * The VNET ID to match the destination. When omitted, all VNETs will match.
       */
      vnet_id?: string;
    }
)[];

export type AccessDevicePostureCheck = {
  /**
   * @x-auditable true
   */
  exists?: boolean;
  /**
   * @x-auditable true
   */
  path?: string;
};

/**
 * Enforces a device posture rule has run successfully
 */
export type AccessDevicePostureRule = {
  device_posture: {
    /**
     * The ID of a device posture integration.
     *
     * @example aa0a4aab-672b-4bdb-bc33-a59f1130a11f
     */
    integration_uid: string;
  };
};

/**
 * @example {"last_authenticated":1638832687}
 */
export type AccessDeviceSession = {
  /**
   * @x-auditable true
   */
  last_authenticated?: number;
};

/**
 * The chronological order used to sort the logs.
 *
 * @default desc
 * @example desc
 */
export type AccessDirection = "desc" | "asc";

/**
 * The duration the DoH JWT is valid for. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.  Note that the maximum duration for this setting is the same as the key rotation period on the account. Default expiration is 24h
 *
 * @example 800h
 * @x-auditable true
 */
export type AccessDohJwtDuration = string;

/**
 * The primary hostname and path secured by Access. This domain will be displayed if the app is visible in the App Launcher.
 *
 * @example test.example.com/admin
 */
export type AccessDomain = string;

/**
 * Match an entire email domain.
 */
export type AccessDomainRule = {
  email_domain: {
    /**
     * The email domain to match.
     *
     * @example example.com
     */
    domain: string;
  };
};

/**
 * The duration for how long the service token will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h. The default is 1 year in hours (8760h).
 *
 * @default 8760h
 * @example 60m
 * @x-auditable true
 */
export type AccessDuration = string;

/**
 * The email address of the SCIM User resource.
 *
 * @example john.smith@example.com
 */
export type AccessEmail = string;

/**
 * Matches an email address from a list.
 */
export type AccessEmailListRule = {
  email_list: {
    /**
     * The ID of a previously created email list.
     *
     * @example aa0a4aab-672b-4bdb-bc33-a59f1130a11f
     */
    id: string;
  };
};

/**
 * Matches a specific email.
 */
export type AccessEmailRule = {
  email: {
    /**
     * The email of the user.
     *
     * @example test@example.com
     * @format email
     */
    email: string;
  };
};

export type AccessEmptyResponse = {
  /**
   * @example true
   */
  result?: true | false;
  /**
   * @example true
   */
  success?: true | false;
};

/**
 * Enables the binding cookie, which increases security against compromised authorization tokens and CSRF attacks.
 *
 * @default false
 */
export type AccessEnableBindingCookie = boolean;

/**
 * Matches everyone.
 */
export type AccessEveryoneRule = {
  /**
   * An empty object which matches on all users.
   *
   * @example {}
   * @x-stainless-empty-object true
   */
  everyone: Record<string, any>;
};

/**
 * Rules evaluated with a NOT logical operator. To match a policy, a user cannot meet any of the Exclude rules.
 */
export type AccessExclude = AccessRule[];

/**
 * The IdP-generated Id of the SCIM resource.
 *
 * @example all_employees
 */
export type AccessExternalId = string;

/**
 * Create Allow or Block policies which evaluate the user based on custom criteria.
 */
export type AccessExternalEvaluationRule = {
  external_evaluation: {
    /**
     * The API endpoint containing your business logic.
     *
     * @example https://eval.example.com
     */
    evaluate_url: string;
    /**
     * The API endpoint containing the key that Access uses to verify that the response came from your API.
     *
     * @example https://eval.example.com/keys
     */
    keys_url: string;
  };
};

export type AccessFacebook = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessGenericOauthConfig;
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     *
     * @x-auditable true
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessFailedLoginResponse = AccessApiResponseCollection & {
  result?: {
    expiration?: number;
    /**
     * @example {"app_name":"Test App","aud":"39691c1480a2352a18ece567debc2b32552686cbd38eec0887aa18d5d3f00c04","datetime":"2022-02-02T21:54:34.914Z","ray_id":"6d76a8a42ead4133","user_email":"test@cloudflare.com","user_uuid":"57171132-e453-4ee8-b2a5-8cbaad333207"}
     */
    metadata?: Record<string, any>;
  }[];
};

export type AccessFeatureAppProps = {
  allowed_idps?: AccessAllowedIdps;
  app_launcher_logo_url?: AccessAppLauncherLogoUrl;
  auto_redirect_to_identity?: AccessSchemasAutoRedirectToIdentity;
  bg_color?: AccessBgColor;
  domain?: AccessDomain;
  footer_links?: AccessFooterLinks;
  header_bg_color?: AccessHeaderBgColor;
  landing_page_design?: AccessLandingPageDesign;
  name?: AccessAppsComponentsSchemasName;
  session_duration?: AccessSchemasSessionDuration;
  skip_app_launcher_login_page?: AccessSkipAppLauncherLoginPage;
  type: AccessType;
};

/**
 * The MD5 fingerprint of the certificate.
 *
 * @example MD5 Fingerprint=1E:80:0F:7A:FD:31:55:96:DE:D5:CB:E2:F0:91:F6:91
 */
export type AccessFingerprint = string;

/**
 * The links in the App Launcher footer.
 *
 * @example {"name":"Cloudflare's Privacy Policy","url":"https://www.cloudflare.com/privacypolicy/"}
 */
export type AccessFooterLinks = {
  /**
   * The hypertext in the footer link.
   *
   * @example Cloudflare's Privacy Policy
   */
  name: string;
  /**
   * the hyperlink in the footer link.
   *
   * @example https://www.cloudflare.com/privacypolicy/
   */
  url: string;
}[];

export type AccessGatewayCaComponentsSchemasResponseCollection =
  AccessApiResponseCollection & {
    result?: AccessSchemasCertificates[];
  };

export type AccessGatewayCaComponentsSchemasSingleResponse =
  AccessApiResponseSingle & {
    result?: AccessSchemasCertificates;
  };

/**
 * True if the seat is part of Gateway.
 *
 * @example false
 * @x-auditable true
 */
export type AccessGatewaySeat = boolean;

export type AccessGenericOauthConfig = {
  /**
   * Your OAuth Client ID
   *
   * @example <your client id>
   */
  client_id?: string;
  /**
   * Your OAuth Client Secret
   *
   * @example <your client secret>
   * @x-sensitive true
   */
  client_secret?: string;
};

/**
 * @example {"country":"US"}
 */
export type AccessGeo = {
  /**
   * @x-auditable true
   */
  country?: string;
};

export type AccessGithub = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessGenericOauthConfig;
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     *
     * @x-auditable true
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

/**
 * Matches a Github organization.
 * Requires a Github identity provider.
 */
export type AccessGithubOrganizationRule = {
  ["github-organization"]: {
    /**
     * The ID of your Github identity provider.
     *
     * @example ea85612a-29c8-46c2-bacb-669d65136971
     */
    identity_provider_id: string;
    /**
     * The name of the organization.
     *
     * @example cloudflare
     */
    name: string;
    /**
     * The name of the team
     *
     * @example api-team
     */
    team?: string;
  };
};

export type AccessGoogle = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessGenericOauthConfig & AccessCustomClaimsSupport;
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     *
     * @x-auditable true
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessGoogleApps = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessGenericOauthConfig &
    AccessCustomClaimsSupport & {
      /**
       * Your companies TLD
       *
       * @example mycompany.com
       */
      apps_domain?: string;
    };
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     *
     * @x-auditable true
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessGroups = {
  /**
   * The display name of the SCIM Group resource.
   *
   * @example ALL EMPLOYEES
   */
  displayName?: string;
  externalId?: AccessExternalId;
  id?: AccessId;
  meta?: AccessMeta;
  /**
   * The list of URIs which indicate the attributes contained within a SCIM resource.
   *
   * @example urn:ietf:params:scim:schemas:core:2.0:Group
   */
  schemas?: string[];
};

/**
 * The display name of the SCIM Group resource.
 *
 * @example ALL_EMPLOYEES
 */
export type AccessGroupsName = string;

/**
 * The name of the Access group.
 *
 * @example Allow devs
 * @x-auditable true
 */
export type AccessGroupsComponentsSchemasName = string;

/**
 * The name of the Access group.
 *
 * @example Allow devs
 */
export type AccessGroupsComponentsSchemasName2 = string;

export type AccessGroupsComponentsSchemasResponseCollection =
  AccessApiResponseCollection & {
    result?: AccessComponentsSchemasGroups[];
  };

export type AccessGroupsComponentsSchemasSingleResponse =
  AccessApiResponseSingle & {
    result?: AccessSchemasGroups;
  };

export type AccessGroupsComponentsSchemasSingleResponse2 =
  AccessApiResponseSingle & {
    result?: AccessComponentsSchemasGroups;
  };

/**
 * Matches a group in Google Workspace.
 * Requires a Google Workspace identity provider.
 */
export type AccessGsuiteGroupRule = {
  gsuite: {
    /**
     * The email of the Google Workspace group.
     *
     * @example devs@cloudflare.com
     */
    email: string;
    /**
     * The ID of your Google Workspace identity provider.
     *
     * @example ea85612a-29c8-46c2-bacb-669d65136971
     */
    identity_provider_id: string;
  };
};

/**
 * The background color of the App Launcher header.
 *
 * @example #ff0000
 */
export type AccessHeaderBgColor = string;

/**
 * Enables the HttpOnly cookie attribute, which increases security against XSS attacks.
 *
 * @default true
 * @example true
 */
export type AccessHttpOnlyCookieAttribute = boolean;

/**
 * The unique Cloudflare-generated Id of the SCIM resource.
 *
 * @example bd97ef8d-7986-43e3-9ee0-c25dda33e4b0
 */
export type AccessId = string;

export type AccessIdResponse = AccessApiResponseSingle & {
  result?: {
    id?: AccessUuid;
  };
};

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type AccessIdentifier = string;

export type AccessIdentity = {
  /**
   * @example 1234567890
   * @x-auditable true
   */
  account_id?: string;
  /**
   * @example NONE
   * @x-auditable true
   */
  auth_status?: string;
  /**
   * @example
   */
  common_name?: string;
  devicePosture?: {
    [key: string]: AccessSchemasDevicePostureRule;
  };
  /**
   * @example
   */
  device_id?: string;
  device_sessions?: AccessStringKeyMapDeviceSession;
  /**
   * @example test@cloudflare.com
   */
  email?: string;
  geo?: AccessGeo;
  /**
   * @example 1694791905
   */
  iat?: number;
  idp?: {
    id?: string;
    type?: string;
  };
  /**
   * @example 127.0.0.0
   */
  ip?: string;
  /**
   * @example false
   */
  is_gateway?: boolean;
  /**
   * @example false
   */
  is_warp?: boolean;
  mtls_auth?: {
    auth_status?: string;
    cert_issuer_dn?: string;
    cert_issuer_ski?: string;
    cert_presented?: boolean;
    cert_serial?: string;
  };
  /**
   * @example
   */
  service_token_id?: string;
  /**
   * @example false
   */
  service_token_status?: boolean;
  /**
   * @example 57cf8cf2-f55a-4588-9ac9-f5e41e9f09b4
   */
  user_uuid?: string;
  /**
   * @example 2
   */
  version?: number;
};

export type AccessIdentityProvider = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: Record<string, any>;
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     *
     * @x-auditable true
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessIdentityProviders =
  | AccessAzureAD
  | AccessCentrify
  | AccessFacebook
  | AccessGithub
  | AccessGoogle
  | AccessGoogleApps
  | AccessLinkedin
  | AccessOidc
  | AccessOkta
  | AccessOnelogin
  | AccessPingone
  | AccessSaml
  | AccessYandex
  | AccessOnetimepin;

export type AccessIdentityProvidersComponentsSchemasResponseCollection =
  AccessApiResponseCollection & {
    result?: (
      | AccessSchemasAzureAD
      | AccessSchemasCentrify
      | AccessSchemasFacebook
      | AccessSchemasGithub
      | AccessSchemasGoogle
      | AccessSchemasGoogleApps
      | AccessSchemasLinkedin
      | AccessSchemasOidc
      | AccessSchemasOkta
      | AccessSchemasOnelogin
      | AccessSchemasPingone
      | AccessSchemasSaml
      | AccessSchemasYandex
      | AccessSchemasOnetimepin
    )[];
  };

export type AccessIdentityProvidersComponentsSchemasSingleResponse =
  AccessApiResponseSingle & {
    result?: AccessSchemasIdentityProviders;
  };

/**
 * The unique Id of the IdP that has SCIM enabled.
 *
 * @example df7e2w5f-02b7-4d9d-af26-8d1988fca630
 * @example 0194ae2c-efcf-7cfb-8884-055f1a161fa5
 */
export type AccessIdpId = string[];

/**
 * The IdP-generated Id of the SCIM Group resource; also known as the "external Id".
 *
 * @example all_employees
 */
export type AccessIdpResourceId = string;

/**
 * The URL of the image shown on the landing page.
 *
 * @example https://www.cloudflare.com/img/logo-web-badges/cf-logo-on-white-bg.svg
 */
export type AccessImageUrl = string;

/**
 * Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
 */
export type AccessInclude = AccessRule[];

export type AccessInfraAppReqEmbeddedPolicies = {
  /**
   * The policies that Access applies to the application.
   */
  policies?: AccessInfraPolicyReq[];
};

/**
 * The policies that Access applies to the application.
 */
export type AccessInfraAppRespEmbeddedPolicies = {
  policies?: AccessInfraPolicyResp[];
};

export type AccessInfraPolicyReq = AccessBasePolicyReq & {
  connection_rules?: AccessConnectionRules;
};

export type AccessInfraPolicyResp = AccessBasePolicyResp & {
  connection_rules?: AccessConnectionRules;
};

/**
 * Contains the targets secured by the application.
 */
export type AccessInfraProps = {
  name?: AccessAppsComponentsSchemasName;
  /**
   * The application type.
   *
   * @example infrastructure
   */
  type?: AccessType & void;
} & AccessAppRespEmbeddedTargetCriteriaInfra;

/**
 * The IP address of the authenticating user.
 *
 * @example 198.41.129.166
 */
export type AccessIp = string;

/**
 * Matches an IP address from a list.
 */
export type AccessIpListRule = {
  ip_list: {
    /**
     * The ID of a previously created IP list.
     *
     * @example aa0a4aab-672b-4bdb-bc33-a59f1130a11f
     */
    id: string;
  };
};

/**
 * Matches an IP address block.
 */
export type AccessIpRule = {
  ip: {
    /**
     * An IPv4 or IPv6 CIDR block.
     *
     * @example 2400:cb00:21:10a::/64
     */
    ip: string;
  };
};

/**
 * Whether this is the default group
 *
 * @x-auditable true
 */
export type AccessIsDefault = boolean;

/**
 * Lock all settings as Read-Only in the Dashboard, regardless of user permission. Updates may only be made via the API or Terraform for this account when enabled.
 *
 * @example false
 * @x-auditable true
 */
export type AccessIsUiReadOnly = boolean;

/**
 * Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
 *
 * @example false
 */
export type AccessIsolationRequired = boolean;

export type AccessKeyConfig = {
  days_until_next_rotation?: AccessDaysUntilNextRotation;
  key_rotation_interval_days?: AccessKeyRotationIntervalDays;
  last_key_rotation_at?: AccessLastKeyRotationAt;
};

/**
 * The number of days between key rotations.
 *
 * @example 30
 * @maximum 365
 * @minimum 21
 * @x-auditable true
 */
export type AccessKeyRotationIntervalDays = number;

export type AccessKeysComponentsSchemasSingleResponse =
  AccessApiResponseSingle & {
    result?: AccessKeyConfig;
  };

/**
 * The design of the App Launcher landing page shown to users when they log in.
 */
export type AccessLandingPageDesign = {
  button_color?: AccessButtonColor;
  button_text_color?: AccessButtonTextColor;
  image_url?: AccessImageUrl;
  message?: AccessMessage;
  title?: AccessTitle;
};

/**
 * The timestamp of the previous key rotation.
 *
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type AccessLastKeyRotationAt = string;

export type AccessLastSeenIdentityResponse = AccessApiResponseSingle & {
  result?: AccessIdentity;
};

/**
 * The time at which the user last successfully logged in.
 *
 * @example 2020-07-01T05:20:00Z
 * @format date-time
 */
export type AccessLastSuccessfulLogin = string;

/**
 * The maximum number of update logs to retrieve.
 *
 * @default 20
 * @example 10
 */
export type AccessLimit = number;

/**
 * Matches OAuth 2.0 access tokens issued by the specified Access OIDC SaaS application. Only compatible with non_identity and bypass decisions.
 */
export type AccessLinkedAppTokenRule = {
  linked_app_token: {
    /**
     * The ID of an Access OIDC SaaS application
     *
     * @example aa0a4aab-672b-4bdb-bc33-a59f1130a11f
     */
    app_uid: string;
  };
};

export type AccessLinkedin = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessGenericOauthConfig;
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     *
     * @x-auditable true
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessLoginDesign = {
  /**
   * The background color on your login page.
   *
   * @example #c5ed1b
   */
  background_color?: string;
  /**
   * The text at the bottom of your login page.
   *
   * @example This is an example description.
   */
  footer_text?: string;
  /**
   * The text at the top of your login page.
   *
   * @example This is an example description.
   */
  header_text?: string;
  /**
   * The URL of the logo on your login page.
   *
   * @example https://example.com/logo.png
   */
  logo_path?: string;
  /**
   * The text color on your login page.
   *
   * @example #c5ed1b
   */
  text_color?: string;
};

/**
 * Matches a specific identity provider id.
 */
export type AccessLoginMethodRule = {
  login_method: {
    /**
     * The ID of an identity provider.
     *
     * @example aa0a4aab-672b-4bdb-bc33-a59f1130a11f
     */
    id: string;
  };
};

/**
 * The image URL for the logo shown in the App Launcher dashboard.
 *
 * @example https://www.cloudflare.com/img/logo-web-badges/cf-logo-on-white-bg.svg
 */
export type AccessLogoUrl = string;

/**
 * The maximum number of seconds the results of a preflight request can be cached.
 *
 * @example -1
 * @maximum 86400
 * @minimum -1
 */
export type AccessMaxAge = number;

/**
 * The message shown on the landing page.
 *
 * @example Log in below to reach your applications behind Access.
 */
export type AccessMessage = string;

export type AccessMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * The metadata of the SCIM resource.
 */
export type AccessMeta = {
  /**
   * The timestamp of when the SCIM resource was created.
   *
   * @example 2025-01-01T00:00:00Z
   * @format date-time
   */
  created?: string;
  /**
   * The timestamp of when the SCIM resource was last modified.
   *
   * @example 2025-01-02T00:00:00Z
   * @format date-time
   */
  lastModified?: string;
};

/**
 * The name of your Zero Trust organization.
 *
 * @example Widget Corps Internal Applications
 * @x-auditable true
 */
export type AccessName = string;

export type AccessNameResponse = AccessApiResponseSingle & {
  result?: {
    name?: AccessTagsComponentsSchemasName;
  };
};

/**
 * @example X1aXj1lFVcqqyoXF
 */
export type AccessNonce = string;

export type AccessOidc = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessGenericOauthConfig &
    AccessCustomClaimsSupport & {
      /**
       * The authorization_endpoint URL of your IdP
       *
       * @example https://accounts.google.com/o/oauth2/auth
       */
      auth_url?: string;
      /**
       * The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
       *
       * @example https://www.googleapis.com/oauth2/v3/certs
       */
      certs_url?: string;
      /**
       * Enable Proof Key for Code Exchange (PKCE)
       */
      pkce_enabled?: boolean;
      /**
       * OAuth scopes
       *
       * @example openid
       * @example email
       * @example profile
       */
      scopes?: string[];
      /**
       * The token_endpoint URL of your IdP
       *
       * @example https://accounts.google.com/o/oauth2/token
       */
      token_url?: string;
    };
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     *
     * @x-auditable true
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

/**
 * Matches an OIDC claim.
 * Requires an OIDC identity provider.
 */
export type AccessOidcClaimRule = {
  oidc: {
    /**
     * The name of the OIDC claim.
     *
     * @example group
     */
    claim_name: string;
    /**
     * The OIDC claim value to look for.
     *
     * @example devs@cloudflare.com
     */
    claim_value: string;
    /**
     * The ID of your OIDC identity provider.
     *
     * @example ea85612a-29c8-46c2-bacb-669d65136971
     */
    identity_provider_id: string;
  };
};

export type AccessOidcSaasApp = {
  /**
   * The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
   *
   * @example 5m
   */
  access_token_lifetime?: string;
  /**
   * If client secret should be required on the token endpoint when authorization_code_with_pkce grant is used.
   *
   * @example true
   */
  allow_pkce_without_client_secret?: boolean;
  /**
   * The URL where this applications tile redirects users
   *
   * @example https://example.com/login
   */
  app_launcher_url?: string;
  /**
   * Identifier of the authentication protocol used for the saas app. Required for OIDC.
   *
   * @example oidc
   */
  auth_type?: "saml" | "oidc";
  /**
   * The application client id
   *
   * @example oidc client id
   */
  client_id?: string;
  /**
   * The application client secret, only returned on POST request.
   *
   * @example oidc client secret
   * @x-sensitive true
   */
  client_secret?: string;
  created_at?: AccessTimestamp;
  custom_claims?: {
    /**
     * The name of the claim.
     *
     * @example family_name
     */
    name?: string;
    /**
     * If the claim is required when building an OIDC token.
     *
     * @example true
     */
    required?: boolean;
    /**
     * The scope of the claim.
     *
     * @example profile
     */
    scope?: "groups" | "profile" | "email" | "openid";
    source?: {
      /**
       * The name of the IdP claim.
       *
       * @example last_name
       */
      name?: string;
      /**
       * A mapping from IdP ID to claim name.
       *
       * @example {"exampleIdPID1":"ClaimName1","exampleIdPID2":"ClaimName2"}
       */
      name_by_idp?: {
        [key: string]: string;
      };
    };
  }[];
  /**
   * The OIDC flows supported by this application
   *
   * @example authorization_code
   */
  grant_types?: (
    | "authorization_code"
    | "authorization_code_with_pkce"
    | "refresh_tokens"
    | "hybrid"
    | "implicit"
  )[];
  /**
   * A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
   *
   * @example ^GROUP_FILTER-*$
   */
  group_filter_regex?: string;
  hybrid_and_implicit_options?: {
    /**
     * If an Access Token should be returned from the OIDC Authorization endpoint
     */
    return_access_token_from_authorization_endpoint?: boolean;
    /**
     * If an ID Token should be returned from the OIDC Authorization endpoint
     */
    return_id_token_from_authorization_endpoint?: boolean;
  };
  /**
   * The Access public certificate that will be used to verify your identity.
   *
   * @example example unique name
   */
  public_key?: string;
  /**
   * The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
   *
   * @example https://example.com
   */
  redirect_uris?: string[];
  refresh_token_options?: {
    /**
     * How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
     *
     * @example 30d
     */
    lifetime?: string;
  };
  /**
   * Define the user information shared with access, "offline_access" scope will be automatically enabled if refresh tokens are enabled
   *
   * @example openid
   * @example groups
   * @example email
   * @example profile
   */
  scopes?: ("openid" | "groups" | "email" | "profile")[];
  updated_at?: AccessTimestamp;
};

export type AccessOkta = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessGenericOauthConfig &
    AccessCustomClaimsSupport & {
      /**
       * Your okta authorization server id
       *
       * @example aus9o8wzkhckw9TLa0h7z
       */
      authorization_server_id?: string;
      /**
       * Your okta account url
       *
       * @example https://dev-abc123.oktapreview.com
       * @x-auditable true
       */
      okta_account?: string;
    };
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     *
     * @x-auditable true
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

/**
 * Matches an Okta group.
 * Requires an Okta identity provider.
 */
export type AccessOktaGroupRule = {
  okta: {
    /**
     * The ID of your Okta identity provider.
     *
     * @example ea85612a-29c8-46c2-bacb-669d65136971
     */
    identity_provider_id: string;
    /**
     * The name of the Okta group.
     *
     * @example devs
     */
    name: string;
  };
};

export type AccessOnelogin = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessGenericOauthConfig &
    AccessCustomClaimsSupport & {
      /**
       * Your OneLogin account url
       *
       * @example https://mycompany.onelogin.com
       * @x-auditable true
       */
      onelogin_account?: string;
    };
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     *
     * @x-auditable true
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessOnetimepin = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: {
    redirect_url?: string;
  };
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     *
     * @x-auditable true
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

/**
 * Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if cors_headers is set.
 *
 * @example true
 */
export type AccessOptionsPreflightBypass = boolean;

export type AccessOrganizations = {
  allow_authenticate_via_warp?: AccessAllowAuthenticateViaWarp;
  auth_domain?: AccessAuthDomain;
  auto_redirect_to_identity?: AccessAutoRedirectToIdentity;
  created_at?: AccessTimestamp;
  custom_pages?: AccessCustomPages;
  is_ui_read_only?: AccessIsUiReadOnly;
  login_design?: AccessLoginDesign;
  name?: AccessName;
  session_duration?: AccessSessionDuration;
  ui_read_only_toggle_reason?: AccessUiReadOnlyToggleReason;
  updated_at?: AccessTimestamp;
  user_seat_expiration_inactive_time?: AccessUserSeatExpirationInactiveTime;
  warp_auth_session_duration?: AccessWarpAuthSessionDuration;
};

/**
 * @example 699d98642c564d2e855e9661899b7252
 */
export type AccessOrganizationsComponentsSchemasIdentifier = void;

/**
 * The name of your Zero Trust organization.
 *
 * @example Widget Corps Internal Applications
 */
export type AccessOrganizationsComponentsSchemasName = string;

export type AccessOrganizationsComponentsSchemasSingleResponse =
  AccessApiResponseSingle & {
    result?: AccessSchemasOrganizations;
  };

/**
 * Enables cookie paths to scope an application's JWT to the application path. If disabled, the JWT will scope to the hostname by default
 *
 * @default false
 * @example true
 */
export type AccessPathCookieAttribute = boolean;

/**
 * The percentage of (processed) users approved based on policy evaluation results.
 *
 * @example 25
 * @x-auditable true
 */
export type AccessPercentApproved = number;

/**
 * The percentage of (processed) users blocked based on policy evaluation results.
 *
 * @example 25
 * @x-auditable true
 */
export type AccessPercentBlocked = number;

/**
 * The percentage of (processed) users errored based on policy evaluation results.
 *
 * @example 25
 * @x-auditable true
 */
export type AccessPercentErrored = number;

/**
 * The percentage of users processed so far (of the entire user base).
 *
 * @example 50
 */
export type AccessPercentUsersProcessed = number;

export type AccessPingone = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessGenericOauthConfig &
    AccessCustomClaimsSupport & {
      /**
       * Your PingOne environment identifier
       *
       * @example 342b5660-0c32-4936-a5a4-ce21fae57b0a
       * @x-auditable true
       */
      ping_env_id?: string;
    };
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     *
     * @x-auditable true
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessPolicies = {
  approval_groups?: AccessSchemasApprovalGroups;
  approval_required?: AccessSchemasApprovalRequired;
  created_at?: AccessTimestamp;
  decision?: AccessSchemasDecision;
  exclude?: AccessComponentsSchemasExclude;
  id?: AccessUuid;
  include?: AccessInclude;
  isolation_required?: AccessSchemasIsolationRequired;
  name?: AccessPoliciesComponentsSchemasName;
  precedence?: AccessSchemasPrecedence;
  purpose_justification_prompt?: AccessPurposeJustificationPrompt;
  purpose_justification_required?: AccessSchemasPurposeJustificationRequired;
  require?: AccessComponentsSchemasRequire;
  updated_at?: AccessTimestamp;
};

/**
 * The name of the Access policy.
 *
 * @example Allow devs
 */
export type AccessPoliciesComponentsSchemasName = string;

export type AccessPoliciesComponentsSchemasResponseCollection =
  AccessApiResponseCollection & {
    result?: AccessPolicies[];
  };

export type AccessPoliciesComponentsSchemasSingleResponse =
  AccessApiResponseSingle & {
    result?: AccessPolicies;
  };

export type AccessPolicyCheckResponse = AccessApiResponseSingle & {
  result?: {
    app_state?: {
      app_uid?: AccessUuid;
      /**
       * @example 737646a56ab1df6ec9bddc7e5ca84eaf3b0768850f3ffb5d74f1534911fe389
       */
      aud?: string;
      /**
       * @example test.com
       */
      hostname?: string;
      /**
       * @example Test App
       */
      name?: string;
      /**
       * @example {"decision":"allow","exclude":[],"include":[{"_type":"email","email":"testuser@gmail.com"}],"precedence":0,"require":[],"status":"Success"}
       */
      policies?: Record<string, any>[];
      /**
       * @example Success
       */
      status?: string;
    };
    user_identity?: {
      /**
       * @example 41ecfbb341f033e52b46742756aabb8b
       */
      account_id?: string;
      /**
       * @example {}
       */
      device_sessions?: Record<string, any>;
      /**
       * @example testuser@gmail.com
       */
      email?: string;
      geo?: {
        /**
         * @example US
         */
        country?: string;
      };
      iat?: number;
      /**
       * @example 1164449231815010287495
       */
      id?: string;
      /**
       * @example false
       */
      is_gateway?: boolean;
      /**
       * @example false
       */
      is_warp?: boolean;
      /**
       * @example Test User
       */
      name?: string;
      user_uuid?: AccessUuid;
      version?: number;
    };
  };
};

/**
 * The name of the Access policy.
 *
 * @example Allow devs
 */
export type AccessPolicyComponentsSchemasName = string;

export type AccessPolicyInitReq = {
  policies?: (AccessPolicyReq | string)[];
};

export type AccessPolicyInitResp = AccessApiResponseSingle & {
  result?: {
    id?: AccessPolicyTestId;
    status?: AccessStatus;
  };
};

export type AccessPolicyReq = AccessBasePolicyReq & {
  approval_groups?: AccessApprovalGroups;
  approval_required?: AccessApprovalRequired;
  isolation_required?: AccessIsolationRequired;
  purpose_justification_prompt?: AccessPurposeJustificationPrompt;
  purpose_justification_required?: AccessPurposeJustificationRequired;
  session_duration?: AccessComponentsSchemasSessionDuration;
};

export type AccessPolicyResp = AccessBasePolicyResp & {
  approval_groups?: AccessApprovalGroups;
  approval_required?: AccessApprovalRequired;
  isolation_required?: AccessIsolationRequired;
  purpose_justification_prompt?: AccessPurposeJustificationPrompt;
  purpose_justification_required?: AccessPurposeJustificationRequired;
  session_duration?: AccessComponentsSchemasSessionDuration;
};

/**
 * The UUID of the policy test.
 *
 * @example f1a8b3c9d4e5f6789a0b1c2d3e4f5678a9b0c1d2e3f4a5b67890c1d2e3f4b5a6
 * @maxLength 64
 * @x-auditable true
 */
export type AccessPolicyTestId = string;

export type AccessPolicyUpdateResp = AccessApiResponseSingle & {
  result?: {
    id?: AccessPolicyTestId;
    percent_approved?: AccessPercentApproved;
    percent_blocked?: AccessPercentBlocked;
    percent_errored?: AccessPercentErrored;
    percent_users_processed?: AccessPercentUsersProcessed;
    status?: AccessUpdateStatus;
    total_users?: AccessTotalUsers;
    users_approved?: AccessUsersApproved;
    users_blocked?: AccessUsersBlocked;
    users_errored?: AccessUsersErrored;
  };
};

export type AccessPolicyUsers = {
  email?: AccessSchemasEmail;
  id?: AccessUuid;
  name?: AccessUsersComponentsSchemasName;
  status?: AccessUserResult;
};

export type AccessPolicyUsersResp = AccessApiResponseSingle & {
  /**
   * Page of processed users.
   */
  result?: AccessPolicyUsers[];
};

/**
 * The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
 *
 * @example 22
 */
export type AccessPort = number;

/**
 * The order of execution for this policy. Must be unique for each policy within an app.
 */
export type AccessPrecedence = number;

/**
 * The communication protocol your application secures.
 *
 * @example SSH
 * @x-auditable true
 */
export type AccessProtocolInfraApp = "SSH";

/**
 * The communication protocol your application secures.
 *
 * @example RDP
 * @x-auditable true
 */
export type AccessProtocolSelfHostedApp = "RDP";

/**
 * The public key to add to your SSH server configuration.
 *
 * @example ecdsa-sha2-nistp256 xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx/xxxxxxxxxxxxxxxxxxxxx/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx= open-ssh-ca@cloudflareaccess.org
 */
export type AccessPublicKey = string;

/**
 * A custom message that will appear on the purpose justification screen.
 *
 * @example Please enter a justification for entering this protected domain.
 */
export type AccessPurposeJustificationPrompt = string;

/**
 * Require users to enter a justification when they log in to the application.
 *
 * @example true
 */
export type AccessPurposeJustificationRequired = boolean;

/**
 * The unique identifier for the request to Cloudflare.
 *
 * @example 187d944c61940c77
 * @maxLength 16
 */
export type AccessRayId = string;

/**
 * Contains the targets secured by the application.
 */
export type AccessRdpProps = {
  target_criteria?: AccessTargetCriteriaSelfHostedApp[];
  allow_authenticate_via_warp?: AccessSchemasAllowAuthenticateViaWarp;
  allow_iframe?: AccessAllowIframe;
  allowed_idps?: AccessAllowedIdps;
  app_launcher_visible?: AccessAppLauncherVisible;
  auto_redirect_to_identity?: AccessSchemasAutoRedirectToIdentity;
  cors_headers?: AccessCorsHeaders;
  custom_deny_message?: AccessCustomDenyMessage;
  custom_deny_url?: AccessCustomDenyUrl;
  custom_non_identity_deny_url?: AccessCustomNonIdentityDenyUrl;
  custom_pages?: AccessSchemasCustomPages;
  destinations?: AccessDestinations;
  domain: AccessDomain;
  enable_binding_cookie?: AccessEnableBindingCookie;
  http_only_cookie_attribute?: AccessHttpOnlyCookieAttribute;
  logo_url?: AccessLogoUrl;
  name?: AccessAppsComponentsSchemasName;
  options_preflight_bypass?: AccessOptionsPreflightBypass;
  path_cookie_attribute?: AccessPathCookieAttribute;
  read_service_tokens_from_header?: AccessReadServiceTokensFromHeader;
  same_site_cookie_attribute?: AccessSameSiteCookieAttribute;
  self_hosted_domains?: AccessSelfHostedDomains;
  service_auth_401_redirect?: AccessServiceAuth401Redirect;
  session_duration?: AccessSchemasSessionDuration;
  skip_interstitial?: AccessSkipInterstitial;
  tags?: AccessTags;
  /**
   * The application type.
   *
   * @example rdp
   */
  type: AccessType & void;
};

/**
 * Allows matching Access Service Tokens passed HTTP in a single header with this name.
 * This works as an alternative to the (CF-Access-Client-Id, CF-Access-Client-Secret) pair of headers.
 * The header value will be interpreted as a json object similar to:
 *   {
 *     "cf-access-client-id": "88bf3b6d86161464f6509f7219099e57.access.example.com",
 *     "cf-access-client-secret": "bdd31cbc4dec990953e39163fbbb194c93313ca9f0a6e420346af9d326b1d2a5"
 *   }
 *
 * @example Authorization
 */
export type AccessReadServiceTokensFromHeader = string;

/**
 * The request method of the SCIM request.
 *
 * @example DELETE
 * @example PATCH
 */
export type AccessRequestMethod = ("DELETE" | "PATCH" | "POST" | "PUT")[];

/**
 * The unique Cloudflare-generated Id of the SCIM resource.
 *
 * @example bd97ef8d-7986-43e3-9ee0-c25dda33e4b0
 */
export type AccessRequestsCfResourceId = string;

/**
 * The IdP-generated Id of the SCIM resource.
 */
export type AccessRequestsIdpResourceId = string;

/**
 * The status of the SCIM request.
 *
 * @example FAILURE
 * @example SUCCESS
 */
export type AccessRequestsStatus = ("FAILURE" | "SUCCESS")[];

/**
 * Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules.
 */
export type AccessRequire = AccessRule[];

/**
 * The display name of the SCIM Group resource.
 *
 * @example ALL_EMPLOYEES
 */
export type AccessResourceGroupName = string;

/**
 * The resource type of the SCIM request.
 *
 * @example USER
 * @example GROUP
 */
export type AccessResourceType = ("USER" | "GROUP")[];

/**
 * The email address of the SCIM User resource.
 *
 * @example john.smith@example.com
 * @format email
 */
export type AccessResourceUserEmail = string;

export type AccessResponseCollection = AccessApiResponseCollection & {
  result?: (
    | AccessAzureAD
    | AccessCentrify
    | AccessFacebook
    | AccessGithub
    | AccessGoogle
    | AccessGoogleApps
    | AccessLinkedin
    | AccessOidc
    | AccessOkta
    | AccessOnelogin
    | AccessPingone
    | AccessSaml
    | AccessYandex
  )[];
};

export type AccessResponseCollectionHostnames = AccessApiResponseCollection & {
  result?: AccessSettings[];
};

export type AccessResponses = {
  /**
   * The unique Cloudflare-generated Id of the SCIM resource.
   *
   * @example bd97ef8d-7986-43e3-9ee0-c25dda33e4b0
   */
  cf_resource_id?: string;
  /**
   * The error message which is generated when the status of the SCIM request is 'FAILURE'.
   *
   * @example Invalid JSON body
   */
  error_description?: string;
  /**
   * The unique Id of the IdP that has SCIM enabled.
   *
   * @example df7e2w5f-02b7-4d9d-af26-8d1988fca630
   */
  idp_id?: string;
  /**
   * The IdP-generated Id of the SCIM resource.
   *
   * @example all_employees
   */
  idp_resource_id?: string;
  logged_at?: AccessTimestamp;
  /**
   * The JSON-encoded string body of the SCIM request.
   *
   * @example {}}
   */
  request_body?: string;
  /**
   * The request method of the SCIM request.
   *
   * @example DELETE
   */
  request_method?: string;
  /**
   * The display name of the SCIM Group resource if it exists.
   *
   * @example ALL_EMPLOYEES
   */
  resource_group_name?: string;
  /**
   * The resource type of the SCIM request.
   *
   * @example GROUP
   */
  resource_type?: string;
  /**
   * The email address of the SCIM User resource if it exists.
   *
   * @example john.smith@example.com
   * @format email
   */
  resource_user_email?: string;
  /**
   * The status of the SCIM request.
   *
   * @example FAILURE
   */
  status?: string;
};

export type AccessReusablePoliciesComponentsSchemasIdResponse =
  AccessApiResponseSingle & {
    result?: {
      id?: AccessSchemasUuid;
    };
  };

export type AccessReusablePoliciesComponentsSchemasResponseCollection =
  AccessApiResponseCollection & {
    result?: AccessReusablePolicyResp[];
  };

export type AccessReusablePoliciesComponentsSchemasSingleResponse =
  AccessApiResponseSingle & {
    result?: AccessReusablePolicyResp;
  };

export type AccessReusablePolicyResp = AccessPolicyResp & {
  app_count?: AccessAppCount;
  reusable?: true;
};

export type AccessRule =
  | AccessAccessGroupRule
  | AccessAnyValidServiceTokenRule
  | AccessAuthContextRule
  | AccessAuthenticationMethodRule
  | AccessAzureGroupRule
  | AccessCertificateRule
  | AccessCommonNameRule
  | AccessCountryRule
  | AccessDevicePostureRule
  | AccessDomainRule
  | AccessEmailListRule
  | AccessEmailRule
  | AccessEveryoneRule
  | AccessExternalEvaluationRule
  | AccessGithubOrganizationRule
  | AccessGsuiteGroupRule
  | AccessLoginMethodRule
  | AccessIpListRule
  | AccessIpRule
  | AccessOktaGroupRule
  | AccessSamlGroupRule
  | AccessOidcClaimRule
  | AccessServiceTokenRule
  | AccessLinkedAppTokenRule;

export type AccessSaasProps = {
  allowed_idps?: AccessAllowedIdps;
  app_launcher_visible?: AccessAppLauncherVisible;
  auto_redirect_to_identity?: AccessSchemasAutoRedirectToIdentity;
  custom_pages?: AccessSchemasCustomPages;
  logo_url?: AccessLogoUrl;
  name?: AccessAppsComponentsSchemasName;
  saas_app?: AccessSamlSaasApp | AccessOidcSaasApp;
  tags?: AccessTags;
  /**
   * The application type.
   *
   * @example saas
   */
  type?: AccessType & void;
};

/**
 * Sets the SameSite cookie setting, which provides increased security against CSRF attacks.
 *
 * @example strict
 */
export type AccessSameSiteCookieAttribute = string;

export type AccessSaml = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: {
    /**
     * A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
     *
     * @example group
     * @example department_code
     * @example divison
     */
    attributes?: string[];
    /**
     * The attribute name for email in the SAML response.
     *
     * @example Email
     * @x-auditable true
     */
    email_attribute_name?: string;
    /**
     * Add a list of attribute names that will be returned in the response header from the Access callback.
     */
    header_attributes?: {
      /**
       * attribute name from the IDP
       */
      attribute_name?: string;
      /**
       * header that will be added on the request to the origin
       */
      header_name?: string;
    }[];
    /**
     * X509 certificate to verify the signature in the SAML authentication response
     */
    idp_public_certs?: string[];
    /**
     * IdP Entity ID or Issuer URL
     *
     * @example https://whoami.com
     * @x-auditable true
     */
    issuer_url?: string;
    /**
     * Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
     *
     * @default false
     */
    sign_request?: boolean;
    /**
     * URL to send the SAML authentication requests to
     *
     * @example https://edgeaccess.org/idp/saml/login
     * @x-auditable true
     */
    sso_target_url?: string;
  };
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     *
     * @x-auditable true
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

/**
 * Matches a SAML group.
 * Requires a SAML identity provider.
 */
export type AccessSamlGroupRule = {
  saml: {
    /**
     * The name of the SAML attribute.
     *
     * @example group
     */
    attribute_name: string;
    /**
     * The SAML attribute value to look for.
     *
     * @example devs@cloudflare.com
     */
    attribute_value: string;
    /**
     * The ID of your SAML identity provider.
     *
     * @example ea85612a-29c8-46c2-bacb-669d65136971
     */
    identity_provider_id: string;
  };
};

export type AccessSamlSaasApp = {
  /**
   * Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
   *
   * @example saml
   */
  auth_type?: "saml" | "oidc";
  /**
   * The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
   *
   * @example https://example.com
   */
  consumer_service_url?: string;
  created_at?: AccessTimestamp;
  custom_attributes?: {
    /**
     * The SAML FriendlyName of the attribute.
     *
     * @example Last Name
     */
    friendly_name?: string;
    /**
     * The name of the attribute.
     *
     * @example family_name
     */
    name?: string;
    /**
     * A globally unique name for an identity or service provider.
     *
     * @example urn:oasis:names:tc:SAML:2.0:attrname-format:basic
     */
    name_format?:
      | "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified"
      | "urn:oasis:names:tc:SAML:2.0:attrname-format:basic"
      | "urn:oasis:names:tc:SAML:2.0:attrname-format:uri";
    /**
     * If the attribute is required when building a SAML assertion.
     *
     * @example true
     */
    required?: boolean;
    source?: {
      /**
       * The name of the IdP attribute.
       *
       * @example last_name
       */
      name?: string;
      /**
       * A mapping from IdP ID to attribute name.
       */
      name_by_idp?: {
        /**
         * The UID of the IdP.
         *
         * @example exampleIdPID1
         */
        idp_id?: string;
        /**
         * The name of the IdP provided attribute.
         *
         * @example AttributeName1
         */
        source_name?: string;
      }[];
    };
  }[];
  /**
   * The URL that the user will be redirected to after a successful login for IDP initiated logins.
   *
   * @example https://example.com
   */
  default_relay_state?: string;
  /**
   * The unique identifier for your SaaS application.
   *
   * @example https://example.cloudflareaccess.com
   * @x-stainless-configurability computed_optional
   */
  idp_entity_id?: string;
  /**
   * The format of the name identifier sent to the SaaS application.
   *
   * @example id
   */
  name_id_format?: "id" | "email";
  /**
   * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
   *
   * @example $substringBefore(email, '@') & '+sandbox@' & $substringAfter(email, '@')
   */
  name_id_transform_jsonata?: string;
  /**
   * The Access public certificate that will be used to verify your identity.
   *
   * @example example unique name
   * @x-stainless-configurability computed_optional
   */
  public_key?: string;
  /**
   * A [JSONata] (https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml_attributes or oidc_fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
   *
   * @example $ ~>| groups | {'group_name': name} |
   */
  saml_attribute_transform_jsonata?: string;
  /**
   * A globally unique name for an identity or service provider.
   *
   * @example example unique name
   */
  sp_entity_id?: string;
  /**
   * The endpoint where your SaaS application will send login requests.
   *
   * @example https://example.cloudflareaccess.com/cdn-cgi/access/sso/saml/b3f58a2b414e0b51d45c8c2af26fccca0e27c63763c426fa52f98dcf0b3b3bfd
   * @x-stainless-configurability computed_optional
   */
  sso_endpoint?: string;
  updated_at?: AccessTimestamp;
};

/**
 * True if the user has authenticated with Cloudflare Access.
 *
 * @example false
 */
export type AccessSchemasAccessSeat = boolean;

/**
 * When set to true, users can authenticate to this application using their WARP session.  When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication.
 *
 * @example true
 */
export type AccessSchemasAllowAuthenticateViaWarp = boolean;

/**
 * Allowed HTTP request headers.
 */
export type AccessSchemasAllowedHeaders = any[];

/**
 * Allowed origins.
 *
 * @example https://example.com
 */
export type AccessSchemasAllowedOrigins = any[];

/**
 * Number of apps the custom page is assigned to.
 *
 * @x-auditable true
 */
export type AccessSchemasAppCount = number;

export type AccessSchemasAppLauncherProps = {
  allowed_idps?: AccessAllowedIdps;
  auto_redirect_to_identity?: AccessSchemasAutoRedirectToIdentity;
  /**
   * @example authdomain.cloudflareaccess.com
   */
  domain?: AccessComponentsSchemasDomain;
  /**
   * @default App Launcher
   * @example App Launcher
   */
  name?: AccessAppsComponentsSchemasName;
  session_duration?: AccessAppsComponentsSchemasSessionDuration;
  /**
   * The application type.
   *
   * @example app_launcher
   */
  type: AccessComponentsSchemasType;
};

/**
 * Displays the application in the App Launcher.
 *
 * @example true
 * @x-auditable true
 */
export type AccessSchemasAppLauncherVisible = boolean;

/**
 * A group of email addresses that can approve a temporary authentication request.
 */
export type AccessSchemasApprovalGroup = {
  /**
   * The number of approvals needed to obtain access.
   *
   * @example 1
   * @minimum 0
   */
  approvals_needed: number;
  /**
   * A list of emails that can approve the access request.
   *
   * @example test@cloudflare.com
   * @example test2@cloudflare.com
   */
  email_addresses?: any[];
  /**
   * The UUID of an re-usable email list.
   */
  email_list_uuid?: string;
};

/**
 * Administrators who can approve a temporary authentication request.
 *
 * @example {"approvals_needed":1,"email_addresses":["test1@cloudflare.com","test2@cloudflare.com"]}
 * @example {"approvals_needed":3,"email_list_uuid":"597147a1-976b-4ef2-9af0-81d5d007fc34"}
 */
export type AccessSchemasApprovalGroups = AccessSchemasApprovalGroup[];

/**
 * Requires the user to request access from an administrator at the start of each session.
 *
 * @default false
 * @example true
 */
export type AccessSchemasApprovalRequired = boolean;

/**
 * The hostnames of the applications that will use this certificate.
 */
export type AccessSchemasAssociatedHostnames = string[];

/**
 * Audience tag.
 *
 * @example 737646a56ab1df6ec9bddc7e5ca84eaf3b0768850f3ffb5d74f1534911fe3893
 * @maxLength 64
 */
export type AccessSchemasAud = string;

/**
 * The unique subdomain assigned to your Zero Trust organization.
 *
 * @example test.cloudflareaccess.com
 */
export type AccessSchemasAuthDomain = string;

/**
 * When set to `true`, users skip the identity provider selection step during login. You must specify only one identity provider in allowed_idps.
 *
 * @default false
 */
export type AccessSchemasAutoRedirectToIdentity = boolean;

export type AccessSchemasAzureAD = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessSchemasGenericOauthConfig & {
    /**
     * Should Cloudflare try to load authentication contexts from your account
     */
    conditional_access_enabled?: boolean;
    /**
     * Your Azure directory uuid
     *
     * @example <your azure directory uuid>
     */
    directory_id?: string;
    /**
     * Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction_required error. prompt=select_account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
     */
    prompt?: "login" | "select_account" | "none";
    /**
     * Should Cloudflare try to load groups from your account
     */
    support_groups?: boolean;
  };
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests. If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessSchemasBasicAppResponseProps = {
  aud?: AccessSchemasAud;
  created_at?: AccessTimestamp;
  id?: AccessUuid;
  scim_config?: AccessSchemasScimConfig;
  updated_at?: AccessTimestamp;
};

export type AccessSchemasBisoProps = {
  allowed_idps?: AccessAllowedIdps;
  auto_redirect_to_identity?: AccessSchemasAutoRedirectToIdentity;
  /**
   * @example authdomain.cloudflareaccess.com/browser
   */
  domain?: AccessComponentsSchemasDomain;
  /**
   * @default Clientless Web Isolation
   * @example Clientless Web Isolation
   */
  name?: AccessAppsComponentsSchemasName;
  session_duration?: AccessAppsComponentsSchemasSessionDuration;
  /**
   * The application type.
   *
   * @example biso
   */
  type: AccessComponentsSchemasType;
};

export type AccessSchemasBookmarkProps = {
  /**
   * @default true
   */
  app_launcher_visible?: void;
  /**
   * The URL or domain of the bookmark.
   *
   * @example https://mybookmark.com
   */
  domain: void;
  logo_url?: AccessLogoUrl;
  name?: AccessAppsComponentsSchemasName;
  /**
   * The application type.
   *
   * @example bookmark
   */
  type: string;
};

export type AccessSchemasCa = {
  aud?: AccessComponentsSchemasAud;
  id?: AccessComponentsSchemasId;
  public_key?: AccessPublicKey;
};

export type AccessSchemasCentrify = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessSchemasGenericOauthConfig & {
    /**
     * Your centrify account url
     *
     * @example https://abc123.my.centrify.com/
     */
    centrify_account?: string;
    /**
     * Your centrify app id
     *
     * @example exampleapp
     */
    centrify_app_id?: string;
  };
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests. If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessSchemasCertificates = {
  /**
   * The key ID of this certificate.
   *
   * @x-auditable true
   */
  id?: string;
  /**
   * The public key of this certificate.
   */
  public_key?: string;
};

export type AccessSchemasCorsHeaders = {
  allow_all_headers?: AccessAllowAllHeaders;
  allow_all_methods?: AccessAllowAllMethods;
  allow_all_origins?: AccessAllowAllOrigins;
  allow_credentials?: AccessAllowCredentials;
  allowed_headers?: AccessSchemasAllowedHeaders;
  allowed_methods?: AccessAllowedMethods;
  allowed_origins?: AccessSchemasAllowedOrigins;
  max_age?: AccessMaxAge;
};

export type AccessSchemasCreateResponse = AccessApiResponseSingle & {
  result?: {
    client_id?: AccessClientId;
    client_secret?: AccessClientSecret;
    created_at?: AccessTimestamp;
    duration?: AccessSchemasDuration;
    /**
     * The ID of the service token.
     */
    id?: string;
    name?: AccessServiceTokensComponentsSchemasName;
    updated_at?: AccessTimestamp;
  };
};

/**
 * The custom URL a user is redirected to when they are denied access to the application.
 */
export type AccessSchemasCustomDenyUrl = string;

/**
 * The custom pages that will be displayed when applicable for this application
 */
export type AccessSchemasCustomPages = string[];

/**
 * The action Access will take if a user matches this policy.
 *
 * @example allow
 */
export type AccessSchemasDecision =
  | "allow"
  | "deny"
  | "non_identity"
  | "bypass";

export type AccessSchemasDevicePostureRule = {
  check?: AccessDevicePostureCheck;
  data?: Record<string, any>;
  /**
   * @x-auditable true
   */
  description?: string;
  error?: string;
  /**
   * @x-auditable true
   */
  id?: string;
  /**
   * @x-auditable true
   */
  rule_name?: string;
  /**
   * @x-auditable true
   */
  success?: boolean;
  /**
   * @x-auditable true
   */
  timestamp?: string;
  /**
   * @x-auditable true
   */
  type?: string;
};

/**
 * The domain of the Bookmark application.
 *
 * @example example.com
 * @x-auditable true
 */
export type AccessSchemasDomain = string;

/**
 * The duration for how long the service token will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h. The default is 1 year in hours (8760h).
 *
 * @default 8760h
 * @example 60m
 */
export type AccessSchemasDuration = string;

/**
 * The email of the user.
 *
 * @example jdoe@example.com
 * @format email
 */
export type AccessSchemasEmail = string;

export type AccessSchemasEmptyResponse = {
  result?: Record<string, any> | null;
  /**
   * @example true
   */
  success?: true | false;
};

/**
 * Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules.
 */
export type AccessSchemasExclude = AccessRule[];

export type AccessSchemasFacebook = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessSchemasGenericOauthConfig;
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests. If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessSchemasFeatureAppProps = {
  allowed_idps?: AccessAllowedIdps;
  auto_redirect_to_identity?: AccessSchemasAutoRedirectToIdentity;
  domain?: AccessComponentsSchemasDomain;
  name?: AccessAppsComponentsSchemasName;
  session_duration?: AccessAppsComponentsSchemasSessionDuration;
  type: AccessComponentsSchemasType;
};

/**
 * True if the user has logged into the WARP client.
 *
 * @example false
 */
export type AccessSchemasGatewaySeat = boolean;

export type AccessSchemasGenericOauthConfig = {
  /**
   * Your OAuth Client ID
   *
   * @example <your client id>
   */
  client_id?: string;
  /**
   * Your OAuth Client Secret
   *
   * @example <your client secret>
   * @x-sensitive true
   */
  client_secret?: string;
};

export type AccessSchemasGithub = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessSchemasGenericOauthConfig;
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests. If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessSchemasGoogle = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessSchemasGenericOauthConfig;
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests. If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessSchemasGoogleApps = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessSchemasGenericOauthConfig & {
    /**
     * Your companies TLD
     *
     * @example mycompany.com
     */
    apps_domain?: string;
  };
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests. If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessSchemasGroups = {
  created_at?: AccessTimestamp;
  exclude?: AccessExclude;
  id?: AccessUuid;
  include?: AccessInclude;
  is_default?: AccessRequire;
  name?: AccessGroupsComponentsSchemasName;
  require?: AccessRequire;
  updated_at?: AccessTimestamp;
};

/**
 * The ID of the CA.
 *
 * @example 7eddae4619b50ab1361ba8ae9bd72269a432fea041529ed9
 * @maxLength 48
 * @x-auditable true
 */
export type AccessSchemasId = string;

export type AccessSchemasIdResponse = AccessApiResponseSingle & {
  result?: {
    id?: AccessSchemasId;
  };
};

/**
 * Identifier.
 *
 * @example 699d98642c564d2e855e9661899b7252
 * @maxLength 32
 * @x-auditable true
 */
export type AccessSchemasIdentifier = AccessIdentifier & void;

export type AccessSchemasIdentityProvider = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: Record<string, any>;
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests. If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessSchemasIdentityProviders =
  | AccessSchemasAzureAD
  | AccessSchemasCentrify
  | AccessSchemasFacebook
  | AccessSchemasGithub
  | AccessSchemasGoogle
  | AccessSchemasGoogleApps
  | AccessSchemasLinkedin
  | AccessSchemasOidc
  | AccessSchemasOkta
  | AccessSchemasOnelogin
  | AccessSchemasPingone
  | AccessSchemasSaml
  | AccessSchemasYandex;

/**
 * Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules.
 */
export type AccessSchemasInclude = AccessRule[];

/**
 * Lock all settings as Read-Only in the Dashboard, regardless of user permission. Updates may only be made via the API or Terraform for this account when enabled.
 *
 * @example false
 */
export type AccessSchemasIsUiReadOnly = boolean;

/**
 * Require this application to be served in an isolated browser for users matching this policy.
 *
 * @default false
 * @example false
 */
export type AccessSchemasIsolationRequired = boolean;

export type AccessSchemasLinkedin = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessSchemasGenericOauthConfig;
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests. If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessSchemasLoginDesign = {
  /**
   * The background color on your login page.
   *
   * @example #c5ed1b
   */
  background_color?: string;
  /**
   * The text at the bottom of your login page.
   *
   * @example This is an example description.
   */
  footer_text?: string;
  /**
   * The text at the top of your login page.
   *
   * @example This is an example description.
   */
  header_text?: string;
  /**
   * The URL of the logo on your login page.
   *
   * @example https://example.com/logo.png
   */
  logo_path?: string;
  /**
   * The text color on your login page.
   *
   * @example #c5ed1b
   */
  text_color?: string;
};

/**
 * The image URL for the logo shown in the App Launcher dashboard.
 *
 * @example https://www.cloudflare.com/img/logo-web-badges/cf-logo-on-white-bg.svg
 * @x-auditable true
 */
export type AccessSchemasLogoUrl = string;

/**
 * The name of the service token.
 *
 * @example CI/CD token
 * @x-auditable true
 */
export type AccessSchemasName = string;

export type AccessSchemasOidc = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessSchemasGenericOauthConfig & {
    /**
     * The authorization_endpoint URL of your IdP
     *
     * @example https://accounts.google.com/o/oauth2/auth
     */
    auth_url?: string;
    /**
     * The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
     *
     * @example https://www.googleapis.com/oauth2/v3/certs
     */
    certs_url?: string;
    /**
     * List of custom claims that will be pulled from your id_token and added to your signed Access JWT token.
     *
     * @example given_name
     * @example locale
     */
    claims?: string[];
    /**
     * OAuth scopes
     *
     * @example openid
     * @example email
     * @example profile
     */
    scopes?: string[];
    /**
     * The token_endpoint URL of your IdP
     *
     * @example https://accounts.google.com/o/oauth2/token
     */
    token_url?: string;
  };
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests. If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessSchemasOidcSaasApp = {
  /**
   * The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
   *
   * @example 5m
   */
  access_token_lifetime?: string;
  /**
   * If client secret should be required on the token endpoint when authorization_code_with_pkce grant is used.
   *
   * @example true
   */
  allow_pkce_without_client_secret?: boolean;
  /**
   * The URL where this applications tile redirects users
   *
   * @example https://example.com/login
   */
  app_launcher_url?: string;
  /**
   * Identifier of the authentication protocol used for the saas app. Required for OIDC.
   *
   * @example oidc
   */
  auth_type?: "saml" | "oidc";
  /**
   * The application client id
   *
   * @example oidc client id
   */
  client_id?: string;
  /**
   * The application client secret, only returned on POST request.
   *
   * @example oidc client secret
   * @x-sensitive true
   */
  client_secret?: string;
  created_at?: AccessTimestamp;
  custom_claims?: {
    /**
     * The name of the claim.
     *
     * @example family_name
     */
    name?: string;
    /**
     * If the claim is required when building an OIDC token.
     *
     * @example true
     */
    required?: boolean;
    /**
     * The scope of the claim.
     *
     * @example profile
     */
    scope?: "groups" | "profile" | "email" | "openid";
    source?: {
      /**
       * The name of the IdP claim.
       *
       * @example last_name
       */
      name?: string;
      /**
       * A mapping from IdP ID to attribute name.
       */
      name_by_idp?: {
        /**
         * The UID of the IdP.
         *
         * @example exampleIdPID1
         */
        idp_id?: string;
        /**
         * The name of the IdP provided attribute.
         *
         * @example AttributeName1
         */
        source_name?: string;
      }[];
    };
  }[];
  /**
   * The OIDC flows supported by this application
   *
   * @example authorization_code
   */
  grant_types?: (
    | "authorization_code"
    | "authorization_code_with_pkce"
    | "refresh_tokens"
    | "hybrid"
    | "implicit"
  )[];
  /**
   * A regex to filter Cloudflare groups returned in ID token and userinfo endpoint.
   *
   * @example ^GROUP_FILTER-*$
   */
  group_filter_regex?: string;
  hybrid_and_implicit_options?: {
    /**
     * If an Access Token should be returned from the OIDC Authorization endpoint
     */
    return_access_token_from_authorization_endpoint?: boolean;
    /**
     * If an ID Token should be returned from the OIDC Authorization endpoint
     */
    return_id_token_from_authorization_endpoint?: boolean;
  };
  /**
   * The Access public certificate that will be used to verify your identity.
   *
   * @example example unique name
   */
  public_key?: string;
  /**
   * The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
   *
   * @example https://example.com
   */
  redirect_uris?: string[];
  refresh_token_options?: {
    /**
     * How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
     *
     * @example 30d
     */
    lifetime?: string;
  };
  /**
   * Define the user information shared with access, "offline_access" scope will be automatically enabled if refresh tokens are enabled
   *
   * @example openid
   * @example groups
   * @example email
   * @example profile
   */
  scopes?: ("openid" | "groups" | "email" | "profile")[];
  updated_at?: AccessTimestamp;
};

export type AccessSchemasOkta = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessSchemasGenericOauthConfig & {
    /**
     * Your okta account url
     *
     * @example https://dev-abc123.oktapreview.com
     */
    okta_account?: string;
  };
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests. If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessSchemasOnelogin = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessSchemasGenericOauthConfig & {
    /**
     * Your OneLogin account url
     *
     * @example https://mycompany.onelogin.com
     */
    onelogin_account?: string;
  };
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests. If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessSchemasOnetimepin = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: {
    redirect_url?: string;
  };
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests. If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

/**
 * Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if cors_headers is set.
 *
 * @default false
 * @example true
 */
export type AccessSchemasOptionsPreflightBypass = boolean;

export type AccessSchemasOrganizations = {
  auth_domain?: AccessSchemasAuthDomain;
  created_at?: AccessTimestamp;
  is_ui_read_only?: AccessSchemasIsUiReadOnly;
  login_design?: AccessSchemasLoginDesign;
  name?: AccessOrganizationsComponentsSchemasName;
  ui_read_only_toggle_reason?: AccessUiReadOnlyToggleReason;
  updated_at?: AccessTimestamp;
  user_seat_expiration_inactive_time?: AccessSchemasUserSeatExpirationInactiveTime;
};

export type AccessSchemasPingone = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessSchemasGenericOauthConfig & {
    /**
     * Your PingOne environment identifier
     *
     * @example 342b5660-0c32-4936-a5a4-ce21fae57b0a
     */
    ping_env_id?: string;
  };
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests. If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessSchemasPolicyCheckResponse = AccessApiResponseSingle & {
  result?: {
    app_state?: {
      app_uid?: AccessUuid;
      /**
       * @example 737646a56ab1df6ec9bddc7e5ca84eaf3b0768850f3ffb5d74f1534911fe389
       */
      aud?: string;
      /**
       * @example test.com
       */
      hostname?: string;
      /**
       * @example Test App
       */
      name?: string;
      /**
       * @example {"decision":"allow","exclude":[],"include":[{"_type":"email","email":"testuser@gmail.com"}],"precedence":0,"require":[],"status":"Success"}
       */
      policies?: any[];
      /**
       * @example Success
       */
      status?: string;
    };
    user_identity?: {
      /**
       * @example 41ecfbb341f033e52b46742756aabb8b
       */
      account_id?: string;
      /**
       * @example {}
       */
      device_sessions?: Record<string, any>;
      /**
       * @example testuser@gmail.com
       */
      email?: string;
      geo?: {
        /**
         * @example US
         */
        country?: string;
      };
      iat?: number;
      /**
       * @example 1164449231815010287495
       */
      id?: string;
      /**
       * @example false
       */
      is_gateway?: boolean;
      /**
       * @example false
       */
      is_warp?: boolean;
      /**
       * @example Test User
       */
      name?: string;
      user_uuid?: AccessUuid;
      version?: number;
    };
  };
};

/**
 * The order of execution for this policy. Must be unique for each policy.
 */
export type AccessSchemasPrecedence = number;

/**
 * Require users to enter a justification when they log in to the application.
 *
 * @default false
 * @example true
 */
export type AccessSchemasPurposeJustificationRequired = boolean;

/**
 * Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules.
 */
export type AccessSchemasRequire = AccessRule[];

export type AccessSchemasResponseCollection = AccessApiResponseCollection & {
  result?: AccessSchemasGroups[];
};

export type AccessSchemasResponseCollectionHostnames =
  AccessApiResponseCollection & {
    result?: AccessSchemasSettings[];
  };

export type AccessSchemasSaasProps = {
  allowed_idps?: AccessAllowedIdps;
  app_launcher_visible?: AccessAppLauncherVisible;
  auto_redirect_to_identity?: AccessSchemasAutoRedirectToIdentity;
  logo_url?: AccessLogoUrl;
  name?: AccessAppsComponentsSchemasName;
  saas_app?: AccessSchemasSamlSaasApp | AccessSchemasOidcSaasApp;
  /**
   * The application type.
   *
   * @example saas
   */
  type?: string;
};

export type AccessSchemasSaml = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: {
    /**
     * A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
     *
     * @example group
     * @example department_code
     * @example divison
     */
    attributes?: string[];
    /**
     * The attribute name for email in the SAML response.
     *
     * @example Email
     */
    email_attribute_name?: string;
    /**
     * Add a list of attribute names that will be returned in the response header from the Access callback.
     */
    header_attributes?: {
      /**
       * attribute name from the IDP
       */
      attribute_name?: string;
      /**
       * header that will be added on the request to the origin
       */
      header_name?: string;
    }[];
    /**
     * X509 certificate to verify the signature in the SAML authentication response
     */
    idp_public_certs?: string[];
    /**
     * IdP Entity ID or Issuer URL
     *
     * @example https://whoami.com
     */
    issuer_url?: string;
    /**
     * Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
     */
    sign_request?: boolean;
    /**
     * URL to send the SAML authentication requests to
     *
     * @example https://edgeaccess.org/idp/saml/login
     */
    sso_target_url?: string;
  };
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests. If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

export type AccessSchemasSamlSaasApp = {
  /**
   * Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
   *
   * @example saml
   */
  auth_type?: "saml" | "oidc";
  /**
   * The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
   *
   * @example https://example.com
   */
  consumer_service_url?: string;
  created_at?: AccessTimestamp;
  custom_attributes?: {
    /**
     * The SAML FriendlyName of the attribute.
     *
     * @example Last Name
     */
    friendly_name?: string;
    /**
     * The name of the attribute.
     *
     * @example family_name
     */
    name?: string;
    /**
     * A globally unique name for an identity or service provider.
     *
     * @example urn:oasis:names:tc:SAML:2.0:attrname-format:basic
     */
    name_format?:
      | "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified"
      | "urn:oasis:names:tc:SAML:2.0:attrname-format:basic"
      | "urn:oasis:names:tc:SAML:2.0:attrname-format:uri";
    /**
     * If the attribute is required when building a SAML assertion.
     *
     * @example true
     */
    required?: boolean;
    source?: {
      /**
       * The name of the IdP attribute.
       *
       * @example last_name
       */
      name?: string;
      /**
       * A mapping from IdP ID to attribute name.
       *
       * @example {"exampleIdPID1":"AttributeName1","exampleIdPID2":"AttributeName2"}
       */
      name_by_idp?: {
        [key: string]: string;
      };
    };
  }[];
  /**
   * The unique identifier for your SaaS application.
   *
   * @example https://example.cloudflareaccess.com
   * @x-stainless-configurability computed_optional
   */
  idp_entity_id?: string;
  /**
   * The format of the name identifier sent to the SaaS application.
   *
   * @example id
   */
  name_id_format?: "id" | "email";
  /**
   * A [JSONata](https://jsonata.org/) expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the `name_id_format` setting.
   *
   * @example $substringBefore(email, '@') & '+sandbox@' & $substringAfter(email, '@')
   */
  name_id_transform_jsonata?: string;
  /**
   * The Access public certificate that will be used to verify your identity.
   *
   * @example example unique name
   * @x-stainless-configurability computed_optional
   */
  public_key?: string;
  /**
   * A globally unique name for an identity or service provider.
   *
   * @example example unique name
   */
  sp_entity_id?: string;
  /**
   * The endpoint where your SaaS application will send login requests.
   *
   * @example https://example.cloudflareaccess.com/cdn-cgi/access/sso/saml/b3f58a2b414e0b51d45c8c2af26fccca0e27c63763c426fa52f98dcf0b3b3bfd
   * @x-stainless-configurability computed_optional
   */
  sso_endpoint?: string;
  updated_at?: AccessTimestamp;
};

/**
 * Configuration for provisioning to this application via SCIM. This is currently in closed beta.
 */
export type AccessSchemasScimConfig = {
  authentication?:
    | AccessSchemasScimConfigSingleAuthentication
    | AccessSchemasScimConfigMultiAuthentication;
  /**
   * If false, we propagate DELETE requests to the target application for SCIM resources. If true, we only set `active` to false on the SCIM resource. This is useful because some targets do not support DELETE operations.
   */
  deactivate_on_delete?: boolean;
  /**
   * Whether SCIM provisioning is turned on for this application.
   */
  enabled?: boolean;
  /**
   * The UID of the IdP to use as the source for SCIM resources to provision to this application.
   */
  idp_uid: string;
  /**
   * A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
   */
  mappings?: AccessScimConfigMapping[];
  /**
   * The base URI for the application's SCIM-compatible API.
   */
  remote_uri: string;
};

/**
 * Attributes for configuring OAuth Bearer Token authentication scheme for SCIM provisioning to an application.
 */
export type AccessSchemasScimConfigAuthenticationOauthBearerToken = {
  /**
   * The authentication scheme to use when making SCIM requests to this application.
   */
  scheme: "oauthbearertoken";
  /**
   * Token used to authenticate with the remote SCIM service.
   */
  token: string;
};

/**
 * Multiple authentication schemes
 */
export type AccessSchemasScimConfigMultiAuthentication =
  AccessSchemasScimConfigSingleAuthentication[];

export type AccessSchemasScimConfigSingleAuthentication =
  | AccessScimConfigAuthenticationHttpBasic
  | AccessSchemasScimConfigAuthenticationOauthBearerToken
  | AccessScimConfigAuthenticationOauth2
  | AccessScimConfigAuthenticationAccessServiceToken;

/**
 * The unique API identifier for the Zero Trust seat.
 */
export type AccessSchemasSeatUid = string;

export type AccessSchemasSelfHostedProps = {
  allow_iframe?: AccessAllowIframe;
  allowed_idps?: AccessAllowedIdps;
  app_launcher_visible?: AccessAppLauncherVisible;
  auto_redirect_to_identity?: AccessSchemasAutoRedirectToIdentity;
  cors_headers?: AccessSchemasCorsHeaders;
  custom_deny_message?: AccessCustomDenyMessage;
  custom_deny_url?: AccessSchemasCustomDenyUrl;
  domain: AccessComponentsSchemasDomain;
  enable_binding_cookie?: AccessEnableBindingCookie;
  http_only_cookie_attribute?: AccessHttpOnlyCookieAttribute;
  logo_url?: AccessLogoUrl;
  name?: AccessAppsComponentsSchemasName;
  options_preflight_bypass?: AccessSchemasOptionsPreflightBypass;
  same_site_cookie_attribute?: AccessSameSiteCookieAttribute;
  service_auth_401_redirect?: AccessServiceAuth401Redirect;
  session_duration?: AccessAppsComponentsSchemasSessionDuration;
  skip_interstitial?: AccessSkipInterstitial;
  /**
   * The application type.
   *
   * @example self_hosted
   */
  type: string;
};

export type AccessSchemasServiceTokens = {
  client_id?: AccessClientId;
  created_at?: AccessTimestamp;
  duration?: AccessSchemasDuration;
  expires_at?: AccessTimestamp;
  /**
   * UUID.
   *
   * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
   * @maxLength 36
   * @x-auditable true
   */
  id?: void & AccessUuid;
  last_seen_at?: AccessTimestamp;
  name?: AccessServiceTokensComponentsSchemasName;
  updated_at?: AccessTimestamp;
};

/**
 * The amount of time that tokens issued for this application will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h. Note: unsupported for infrastructure type applications.
 *
 * @default 24h
 * @example 24h
 */
export type AccessSchemasSessionDuration = string;

export type AccessSchemasSettings = {
  /**
   * Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
   *
   * @example false
   */
  china_network: boolean;
  /**
   * Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
   *
   * @example true
   */
  client_certificate_forwarding: boolean;
  /**
   * The hostname that these settings apply to.
   *
   * @example admin.example.com
   */
  hostname: string;
};

export type AccessSchemasSingleResponse = AccessApiResponseSingle & {
  result?: AccessServiceTokens;
};

export type AccessSchemasSshProps = {
  allow_iframe?: AccessAllowIframe;
  allowed_idps?: AccessAllowedIdps;
  app_launcher_visible?: AccessAppLauncherVisible;
  auto_redirect_to_identity?: AccessSchemasAutoRedirectToIdentity;
  cors_headers?: AccessSchemasCorsHeaders;
  custom_deny_message?: AccessCustomDenyMessage;
  custom_deny_url?: AccessSchemasCustomDenyUrl;
  domain: AccessComponentsSchemasDomain;
  enable_binding_cookie?: AccessEnableBindingCookie;
  http_only_cookie_attribute?: AccessHttpOnlyCookieAttribute;
  logo_url?: AccessLogoUrl;
  name?: AccessAppsComponentsSchemasName;
  options_preflight_bypass?: AccessSchemasOptionsPreflightBypass;
  same_site_cookie_attribute?: AccessSameSiteCookieAttribute;
  service_auth_401_redirect?: AccessServiceAuth401Redirect;
  session_duration?: AccessAppsComponentsSchemasSessionDuration;
  skip_interstitial?: AccessSkipInterstitial;
  /**
   * The application type.
   *
   * @example ssh
   */
  type: string;
};

/**
 * Custom page type.
 *
 * @x-auditable true
 */
export type AccessSchemasType = "identity_denied" | "forbidden";

/**
 * The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat count. Must be in the format `300ms` or `2h45m`. Valid time units are: `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`.
 *
 * @example 720h
 */
export type AccessSchemasUserSeatExpirationInactiveTime = string;

export type AccessSchemasUsers = {
  access_seat?: AccessSchemasAccessSeat;
  active_device_count?: AccessActiveDeviceCount;
  created_at?: AccessTimestamp;
  email?: AccessSchemasEmail;
  gateway_seat?: AccessSchemasGatewaySeat;
  id?: AccessUuid;
  last_successful_login?: AccessLastSuccessfulLogin;
  name?: AccessUsersComponentsSchemasName;
  seat_uid?: AccessSchemasSeatUid;
  uid?: AccessUid;
  updated_at?: AccessTimestamp;
};

/**
 * The UUID of the policy
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 */
export type AccessSchemasUuid = string;

export type AccessSchemasVncProps = {
  allow_iframe?: AccessAllowIframe;
  allowed_idps?: AccessAllowedIdps;
  app_launcher_visible?: AccessAppLauncherVisible;
  auto_redirect_to_identity?: AccessSchemasAutoRedirectToIdentity;
  cors_headers?: AccessSchemasCorsHeaders;
  custom_deny_message?: AccessCustomDenyMessage;
  custom_deny_url?: AccessSchemasCustomDenyUrl;
  domain: AccessComponentsSchemasDomain;
  enable_binding_cookie?: AccessEnableBindingCookie;
  http_only_cookie_attribute?: AccessHttpOnlyCookieAttribute;
  logo_url?: AccessLogoUrl;
  name?: AccessAppsComponentsSchemasName;
  options_preflight_bypass?: AccessSchemasOptionsPreflightBypass;
  same_site_cookie_attribute?: AccessSameSiteCookieAttribute;
  service_auth_401_redirect?: AccessServiceAuth401Redirect;
  session_duration?: AccessAppsComponentsSchemasSessionDuration;
  skip_interstitial?: AccessSkipInterstitial;
  /**
   * The application type.
   *
   * @example vnc
   */
  type: string;
};

export type AccessSchemasWarpProps = {
  allowed_idps?: AccessAllowedIdps;
  auto_redirect_to_identity?: AccessSchemasAutoRedirectToIdentity;
  /**
   * @example authdomain.cloudflareaccess.com/warp
   */
  domain?: AccessComponentsSchemasDomain;
  /**
   * @default Warp Login App
   * @example Warp Login App
   */
  name?: AccessAppsComponentsSchemasName;
  session_duration?: AccessAppsComponentsSchemasSessionDuration;
  /**
   * The application type.
   *
   * @example warp
   */
  type: AccessComponentsSchemasType;
};

export type AccessSchemasYandex = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessSchemasGenericOauthConfig;
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests. If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

/**
 * Configuration for provisioning to this application via SCIM. This is currently in closed beta.
 */
export type AccessScimConfig = {
  authentication?:
    | AccessScimConfigSingleAuthentication
    | AccessScimConfigMultiAuthentication;
  /**
   * If false, propagates DELETE requests to the target application for SCIM resources. If true, sets 'active' to false on the SCIM resource. Note: Some targets do not support DELETE operations.
   */
  deactivate_on_delete?: boolean;
  /**
   * Whether SCIM provisioning is turned on for this application.
   */
  enabled?: boolean;
  /**
   * The UID of the IdP to use as the source for SCIM resources to provision to this application.
   */
  idp_uid: string;
  /**
   * A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned.
   */
  mappings?: AccessScimConfigMapping[];
  /**
   * The base URI for the application's SCIM-compatible API.
   */
  remote_uri: string;
};

/**
 * Attributes for configuring Access Service Token authentication scheme for SCIM provisioning to an application.
 */
export type AccessScimConfigAuthenticationAccessServiceToken = {
  /**
   * Client ID of the Access service token used to authenticate with the remote service.
   */
  client_id: string;
  /**
   * Client secret of the Access service token used to authenticate with the remote service.
   *
   * @x-sensitive true
   */
  client_secret: string;
  /**
   * The authentication scheme to use when making SCIM requests to this application.
   */
  scheme: "access_service_token";
};

/**
 * Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application.
 */
export type AccessScimConfigAuthenticationHttpBasic = {
  /**
   * Password used to authenticate with the remote SCIM service.
   */
  password: string;
  /**
   * The authentication scheme to use when making SCIM requests to this application.
   */
  scheme: "httpbasic";
  /**
   * User name used to authenticate with the remote SCIM service.
   */
  user: string;
};

/**
 * Attributes for configuring OAuth 2 authentication scheme for SCIM provisioning to an application.
 */
export type AccessScimConfigAuthenticationOauth2 = {
  /**
   * URL used to generate the auth code used during token generation.
   */
  authorization_url: string;
  /**
   * Client ID used to authenticate when generating a token for authenticating with the remote SCIM service.
   */
  client_id: string;
  /**
   * Secret used to authenticate when generating a token for authenticating with the remove SCIM service.
   *
   * @x-sensitive true
   */
  client_secret: string;
  /**
   * The authentication scheme to use when making SCIM requests to this application.
   */
  scheme: "oauth2";
  /**
   * The authorization scopes to request when generating the token used to authenticate with the remove SCIM service.
   */
  scopes?: string[];
  /**
   * URL used to generate the token used to authenticate with the remote SCIM service.
   */
  token_url: string;
};

/**
 * Attributes for configuring OAuth Bearer Token authentication scheme for SCIM provisioning to an application.
 */
export type AccessScimConfigAuthenticationOauthBearerToken = {
  /**
   * The authentication scheme to use when making SCIM requests to this application.
   */
  scheme: "oauthbearertoken";
  /**
   * Token used to authenticate with the remote SCIM service.
   *
   * @x-sensitive true
   */
  token: string;
};

/**
 * Transformations and filters applied to resources before they are provisioned in the remote SCIM service.
 */
export type AccessScimConfigMapping = {
  /**
   * Whether or not this mapping is enabled.
   */
  enabled?: boolean;
  /**
   * A [SCIM filter expression](https://datatracker.ietf.org/doc/html/rfc7644#section-3.4.2.2) that matches resources that should be provisioned to this application.
   *
   * @example title pr or userType eq "Intern"
   */
  filter?: string;
  /**
   * Whether or not this mapping applies to creates, updates, or deletes.
   */
  operations?: {
    /**
     * Whether or not this mapping applies to create (POST) operations.
     */
    create?: boolean;
    /**
     * Whether or not this mapping applies to DELETE operations.
     */
    ["delete"]?: boolean;
    /**
     * Whether or not this mapping applies to update (PATCH/PUT) operations.
     */
    update?: boolean;
  };
  /**
   * Which SCIM resource type this mapping applies to.
   *
   * @example urn:ietf:params:scim:schemas:core:2.0:User
   */
  schema: string;
  /**
   * The level of adherence to outbound resource schemas when provisioning to this mapping. ‘Strict’ removes unknown values, while ‘passthrough’ passes unknown values to the target.
   */
  strictness?: "strict" | "passthrough";
  /**
   * A [JSONata](https://jsonata.org/) expression that transforms the resource before provisioning it in the application.
   *
   * @example $merge([$, {'userName': $substringBefore($.userName, '@') & '+test@' & $substringAfter($.userName, '@')}])
   */
  transform_jsonata?: string;
};

/**
 * Multiple authentication schemes
 */
export type AccessScimConfigMultiAuthentication =
  AccessScimConfigSingleAuthentication[];

export type AccessScimConfigSingleAuthentication =
  | AccessScimConfigAuthenticationHttpBasic
  | AccessScimConfigAuthenticationOauthBearerToken
  | AccessScimConfigAuthenticationOauth2
  | AccessScimConfigAuthenticationAccessServiceToken;

export type AccessScimGroupsResponse = AccessApiResponseCollection & {
  result?: AccessGroups[];
};

export type AccessScimUpdateLogsResponse = AccessApiResponseCollection & {
  result?: AccessResponses[];
};

export type AccessScimUsersResponse = AccessApiResponseCollection & {
  result?: AccessUsers[];
};

export type AccessSeat = {
  access_seat: AccessAccessSeat;
  gateway_seat: AccessGatewaySeat;
  seat_uid: AccessSeatUid;
};

/**
 * The unique API identifier for the Zero Trust seat.
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 * @x-auditable true
 */
export type AccessSeatUid = string;

export type AccessSeats = {
  access_seat?: AccessAccessSeat;
  created_at?: AccessTimestamp;
  gateway_seat?: AccessGatewaySeat;
  seat_uid?: AccessSeatUid;
  updated_at?: AccessTimestamp;
};

export type AccessSeatsComponentsSchemasResponseCollection =
  AccessApiResponseCollection & {
    result?: AccessSeats[];
  };

export type AccessSeatsDefinition = AccessSeat[];

/**
 * List of public domains that Access will secure. This field is deprecated in favor of `destinations` and will be supported until **November 21, 2025.** If `destinations` are provided, then `self_hosted_domains` will be ignored.
 *
 * @deprecated true
 * @example test.example.com/admin
 * @example test.anotherexample.com/staff
 */
export type AccessSelfHostedDomains = string[];

export type AccessSelfHostedProps = {
  allow_authenticate_via_warp?: AccessSchemasAllowAuthenticateViaWarp;
  allow_iframe?: AccessAllowIframe;
  allowed_idps?: AccessAllowedIdps;
  app_launcher_visible?: AccessAppLauncherVisible;
  auto_redirect_to_identity?: AccessSchemasAutoRedirectToIdentity;
  cors_headers?: AccessCorsHeaders;
  custom_deny_message?: AccessCustomDenyMessage;
  custom_deny_url?: AccessCustomDenyUrl;
  custom_non_identity_deny_url?: AccessCustomNonIdentityDenyUrl;
  custom_pages?: AccessSchemasCustomPages;
  destinations?: AccessDestinations;
  domain: AccessDomain;
  enable_binding_cookie?: AccessEnableBindingCookie;
  http_only_cookie_attribute?: AccessHttpOnlyCookieAttribute;
  logo_url?: AccessLogoUrl;
  name?: AccessAppsComponentsSchemasName;
  options_preflight_bypass?: AccessOptionsPreflightBypass;
  path_cookie_attribute?: AccessPathCookieAttribute;
  read_service_tokens_from_header?: AccessReadServiceTokensFromHeader;
  same_site_cookie_attribute?: AccessSameSiteCookieAttribute;
  self_hosted_domains?: AccessSelfHostedDomains;
  service_auth_401_redirect?: AccessServiceAuth401Redirect;
  session_duration?: AccessSchemasSessionDuration;
  skip_interstitial?: AccessSkipInterstitial;
  tags?: AccessTags;
  /**
   * The application type.
   *
   * @example self_hosted
   */
  type: AccessType & void;
};

export type AccessServiceTokens = {
  client_id?: AccessClientId;
  created_at?: AccessTimestamp;
  duration?: AccessDuration;
  expires_at?: AccessTimestamp;
  /**
   * UUID.
   *
   * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
   * @maxLength 36
   * @x-auditable true
   */
  id?: void & AccessUuid;
  last_seen_at?: AccessTimestamp;
  name?: AccessSchemasName;
  updated_at?: AccessTimestamp;
};

/**
 * The name of the service token.
 *
 * @example CI/CD token
 */
export type AccessServiceTokensComponentsSchemasName = string;

export type AccessServiceTokensComponentsSchemasResponseCollection =
  AccessApiResponseCollection & {
    result?: AccessSchemasServiceTokens[];
  };

export type AccessServiceTokensComponentsSchemasSingleResponse =
  AccessApiResponseSingle & {
    result?: AccessSchemasServiceTokens;
  };

/**
 * Returns a 401 status code when the request is blocked by a Service Auth policy.
 *
 * @example true
 */
export type AccessServiceAuth401Redirect = boolean;

/**
 * Matches a specific Access Service Token
 */
export type AccessServiceTokenRule = {
  service_token: {
    /**
     * The ID of a Service Token.
     *
     * @example aa0a4aab-672b-4bdb-bc33-a59f1130a11f
     */
    token_id: string;
  };
};

/**
 * The amount of time that tokens issued for applications will be valid. Must be in the format `300ms` or `2h45m`. Valid time units are: ns, us (or µs), ms, s, m, h.
 *
 * @example 24h
 */
export type AccessSessionDuration = string;

export type AccessSettings = {
  /**
   * Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
   *
   * @example false
   * @x-auditable true
   */
  china_network: boolean;
  /**
   * Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
   *
   * @example true
   * @x-auditable true
   */
  client_certificate_forwarding: boolean;
  /**
   * The hostname that these settings apply to.
   *
   * @example admin.example.com
   * @x-auditable true
   */
  hostname: string;
};

/**
 * the timestamp of the earliest update log.
 *
 * @example 2025-01-01T00:00:00Z
 * @format date-time
 */
export type AccessSince = string;

export type AccessSingleResponse = AccessApiResponseSingle &
  Record<string, any> & {
    result?: AccessOrganizations;
  };

export type AccessSingleResponseUpdate = AccessApiResponseSingle & {
  result?: AccessAppSettingsResponse;
};

export type AccessSingleResponseWithoutHtml = AccessApiResponseSingle & {
  result?: AccessCustomPageWithoutHtml;
};

/**
 * Determines when to skip the App Launcher landing page.
 *
 * @default false
 * @example true
 */
export type AccessSkipAppLauncherLoginPage = boolean;

/**
 * Enables automatic authentication through cloudflared.
 *
 * @example true
 */
export type AccessSkipInterstitial = boolean;

export type AccessSshProps = {
  allow_authenticate_via_warp?: AccessSchemasAllowAuthenticateViaWarp;
  allow_iframe?: AccessAllowIframe;
  allowed_idps?: AccessAllowedIdps;
  app_launcher_visible?: AccessAppLauncherVisible;
  auto_redirect_to_identity?: AccessSchemasAutoRedirectToIdentity;
  cors_headers?: AccessCorsHeaders;
  custom_deny_message?: AccessCustomDenyMessage;
  custom_deny_url?: AccessCustomDenyUrl;
  custom_non_identity_deny_url?: AccessCustomNonIdentityDenyUrl;
  custom_pages?: AccessSchemasCustomPages;
  destinations?: AccessDestinations;
  domain: AccessDomain;
  enable_binding_cookie?: AccessEnableBindingCookie;
  http_only_cookie_attribute?: AccessHttpOnlyCookieAttribute;
  logo_url?: AccessLogoUrl;
  name?: AccessAppsComponentsSchemasName;
  options_preflight_bypass?: AccessOptionsPreflightBypass;
  path_cookie_attribute?: AccessPathCookieAttribute;
  read_service_tokens_from_header?: AccessReadServiceTokensFromHeader;
  same_site_cookie_attribute?: AccessSameSiteCookieAttribute;
  self_hosted_domains?: AccessSelfHostedDomains;
  service_auth_401_redirect?: AccessServiceAuth401Redirect;
  session_duration?: AccessSchemasSessionDuration;
  skip_interstitial?: AccessSkipInterstitial;
  tags?: AccessTags;
  /**
   * The application type.
   *
   * @example ssh
   */
  type: AccessType & void;
};

/**
 * The status of the policy test request.
 *
 * @example success
 * @x-auditable true
 */
export type AccessStatus = "success";

export type AccessStringKeyMapDeviceSession = {
  [key: string]: AccessDeviceSession;
};

/**
 * A tag
 */
export type AccessTag = {
  /**
   * The number of applications that have this tag
   *
   * @example 1
   * @x-auditable true
   */
  app_count?: number;
  created_at?: AccessTimestamp;
  name: AccessTagsComponentsSchemasName;
  updated_at?: AccessTimestamp;
};

/**
 * A tag
 */
export type AccessTagWithoutAppCount = {
  created_at?: AccessTimestamp;
  name: AccessTagsComponentsSchemasName;
  updated_at?: AccessTimestamp;
};

/**
 * The tags you want assigned to an application. Tags are used to filter applications in the App Launcher dashboard.
 */
export type AccessTags = string[];

/**
 * The name of the tag
 *
 * @example engineers
 */
export type AccessTagsComponentsSchemasName = string;

export type AccessTagsComponentsSchemasResponseCollection =
  AccessApiResponseCollection & {
    result?: AccessTag[];
  };

export type AccessTagsComponentsSchemasSingleResponse =
  AccessApiResponseSingle & {
    result?: AccessTag;
  };

/**
 * Contains a map of target attribute keys to target attribute values.
 *
 * @example {"hostname":["test-server","production-server"]}
 */
export type AccessTargetAttributes = {
  [key: string]: string[];
};

export type AccessTargetCriteriaBase = {
  port: AccessPort;
  target_attributes: AccessTargetAttributes;
};

export type AccessTargetCriteriaInfraApp = AccessTargetCriteriaBase & {
  protocol?: AccessProtocolInfraApp;
};

export type AccessTargetCriteriaSelfHostedApp = AccessTargetCriteriaBase & {
  protocol?: AccessProtocolSelfHostedApp;
};

/**
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type AccessTimestamp = string;

/**
 * The title shown on the landing page.
 *
 * @default Welcome!
 * @example Welcome back!
 */
export type AccessTitle = string;

/**
 * The total number of users in the user base.
 *
 * @example 20
 * @x-auditable true
 */
export type AccessTotalUsers = number;

/**
 * The application type.
 *
 * @example self_hosted
 */
export type AccessType =
  | "self_hosted"
  | "saas"
  | "ssh"
  | "vnc"
  | "app_launcher"
  | "warp"
  | "biso"
  | "bookmark"
  | "dash_sso"
  | "infrastructure"
  | "rdp";

/**
 * A description of the reason why the UI read only field is being toggled.
 *
 * @example Temporarily turn off the UI read only lock to make a change via the UI
 */
export type AccessUiReadOnlyToggleReason = string;

/**
 * The unique API identifier for the user.
 */
export type AccessUid = string;

/**
 * the timestamp of the most-recent update log.
 *
 * @example 2025-01-02T00:00:00Z
 * @format date-time
 */
export type AccessUntil = string;

/**
 * The status of the policy test.
 *
 * @example complete
 * @x-auditable true
 */
export type AccessUpdateStatus =
  | "blocked"
  | "processing"
  | "exceeded time"
  | "complete";

/**
 * Policy evaluation result for an individual user.
 *
 * @example approved
 * @x-auditable true
 */
export type AccessUserResult = "approved" | "blocked" | "error";

/**
 * The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat count.  Minimum value for this setting is 1 month (730h). Must be in the format `300ms` or `2h45m`. Valid time units are: `ns`, `us` (or `µs`), `ms`, `s`, `m`, `h`.
 *
 * @example 730h
 * @x-auditable true
 */
export type AccessUserSeatExpirationInactiveTime = string;

/**
 * The username of the SCIM User resource.
 *
 * @example John Smith
 */
export type AccessUsername = string;

/**
 * Contains the Unix usernames that may be used when connecting over SSH.
 *
 * @example root
 * @example ubuntu
 */
export type AccessUsernames = string[];

export type AccessUsers = {
  /**
   * Determines the status of the SCIM User resource.
   *
   * @example true
   */
  active?: boolean;
  /**
   * The name of the SCIM User resource.
   *
   * @example John Smith
   */
  displayName?: string;
  emails?: {
    /**
     * Indicates if the email address is the primary email belonging to the SCIM User resource.
     *
     * @example true
     */
    primary?: boolean;
    /**
     * Indicates the type of the email address.
     *
     * @example work
     */
    type?: string;
    /**
     * The email address of the SCIM User resource.
     *
     * @example john.smith@example.com
     * @format email
     */
    value?: string;
  }[];
  /**
   * The IdP-generated Id of the SCIM resource.
   *
   * @example john_smith
   */
  externalId?: string;
  id?: AccessId;
  meta?: AccessMeta;
  /**
   * The list of URIs which indicate the attributes contained within a SCIM resource.
   *
   * @example urn:ietf:params:scim:schemas:core:2.0:User
   */
  schemas?: string[];
};

/**
 * The unique Cloudflare-generated Id of the SCIM User resource; also known as the "Id".
 *
 * @example bd97ef8d-7986-43e3-9ee0-c25dda33e4b0
 */
export type AccessUsersCfResourceId = string;

/**
 * The IdP-generated Id of the SCIM User resource; also known as the "external Id".
 *
 * @example john_smith_01
 */
export type AccessUsersIdpResourceId = string;

/**
 * The name of the SCIM User resource.
 *
 * @example John Smith
 */
export type AccessUsersName = string;

/**
 * The number of (processed) users approved based on policy evaluation results.
 *
 * @example 5
 * @x-auditable true
 */
export type AccessUsersApproved = number;

/**
 * The number of (processed) users blocked based on policy evaluation results.
 *
 * @example 5
 * @x-auditable true
 */
export type AccessUsersBlocked = number;

/**
 * The name of the user.
 *
 * @example Jane Doe
 */
export type AccessUsersComponentsSchemasName = string;

export type AccessUsersComponentsSchemasResponseCollection =
  AccessApiResponseCollection & {
    result_info?: {
      /**
       * @example 1
       */
      count?: void;
      /**
       * @example 1
       */
      page?: void;
      /**
       * @example 100
       */
      per_page?: void;
      /**
       * @example 1
       */
      total_count?: void;
    };
  } & {
    result?: AccessSchemasUsers[];
  };

/**
 * The number of (processed) users errored based on policy evaluation results.
 *
 * @example 5
 */
export type AccessUsersErrored = number;

/**
 * UUID.
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 * @x-auditable true
 */
export type AccessUuid = string;

export type AccessVncProps = {
  allow_authenticate_via_warp?: AccessSchemasAllowAuthenticateViaWarp;
  allow_iframe?: AccessAllowIframe;
  allowed_idps?: AccessAllowedIdps;
  app_launcher_visible?: AccessAppLauncherVisible;
  auto_redirect_to_identity?: AccessSchemasAutoRedirectToIdentity;
  cors_headers?: AccessCorsHeaders;
  custom_deny_message?: AccessCustomDenyMessage;
  custom_deny_url?: AccessCustomDenyUrl;
  custom_non_identity_deny_url?: AccessCustomNonIdentityDenyUrl;
  custom_pages?: AccessSchemasCustomPages;
  destinations?: AccessDestinations;
  domain: AccessDomain;
  enable_binding_cookie?: AccessEnableBindingCookie;
  http_only_cookie_attribute?: AccessHttpOnlyCookieAttribute;
  logo_url?: AccessLogoUrl;
  name?: AccessAppsComponentsSchemasName;
  options_preflight_bypass?: AccessOptionsPreflightBypass;
  path_cookie_attribute?: AccessPathCookieAttribute;
  read_service_tokens_from_header?: AccessReadServiceTokensFromHeader;
  same_site_cookie_attribute?: AccessSameSiteCookieAttribute;
  self_hosted_domains?: AccessSelfHostedDomains;
  service_auth_401_redirect?: AccessServiceAuth401Redirect;
  session_duration?: AccessSchemasSessionDuration;
  skip_interstitial?: AccessSkipInterstitial;
  tags?: AccessTags;
  /**
   * The application type.
   *
   * @example vnc
   */
  type: AccessType & void;
};

/**
 * The amount of time that tokens issued for applications will be valid. Must be in the format `30m` or `2h45m`. Valid time units are: m, h.
 *
 * @example 24h
 * @x-auditable true
 */
export type AccessWarpAuthSessionDuration = string;

export type AccessWarpProps = {
  allowed_idps?: AccessAllowedIdps;
  app_launcher_logo_url?: AccessAppLauncherLogoUrl;
  auto_redirect_to_identity?: AccessSchemasAutoRedirectToIdentity;
  bg_color?: AccessBgColor;
  /**
   * @example authdomain.cloudflareaccess.com/warp
   */
  domain?: AccessDomain;
  footer_links?: AccessFooterLinks;
  header_bg_color?: AccessHeaderBgColor;
  landing_page_design?: AccessLandingPageDesign;
  /**
   * @default Warp Login App
   * @example Warp Login App
   */
  name?: AccessAppsComponentsSchemasName;
  session_duration?: AccessSchemasSessionDuration;
  skip_app_launcher_login_page?: AccessSkipAppLauncherLoginPage;
  /**
   * The application type.
   *
   * @example warp
   */
  type: AccessType;
};

export type AccessYandex = {
  /**
   * The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   */
  config: AccessGenericOauthConfig;
  id?: AccessUuid;
  name: AccessComponentsSchemasName;
  /**
   * The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider.
   */
  scim_config?: {
    /**
     * A flag to enable or disable SCIM for the identity provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    enabled?: boolean;
    /**
     * Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
     *
     * @default no_action
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    identity_update_behavior?: "automatic" | "reauth" | "no_action";
    /**
     * The base URL of Cloudflare's SCIM V2.0 API endpoint.
     *
     * @x-auditable true
     */
    scim_base_url?: string;
    /**
     * A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    seat_deprovision?: boolean;
    /**
     * A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
     *
     * @x-sensitive true
     */
    secret?: string;
    /**
     * A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
     *
     * @default false
     * @x-auditable true
     * @x-stainless-terraform-configurability computed_optional
     */
    user_deprovision?: boolean;
  };
  /**
   * The type of identity provider. To determine the value for a specific provider, refer to our [developer documentation](https://developers.cloudflare.com/cloudflare-one/identity/idp-integration/).
   *
   * @example onetimepin
   */
  type:
    | "onetimepin"
    | "azureAD"
    | "saml"
    | "centrify"
    | "facebook"
    | "github"
    | "google-apps"
    | "google"
    | "linkedin"
    | "oidc"
    | "okta"
    | "onelogin"
    | "pingone"
    | "yandex";
};

/**
 * Identifier of a Cloudflare account.
 *
 * @example 258def64c72dae45f3e4c8516e2111f2
 * @maxLength 32
 * @x-auditable true
 */
export type AddressingAccountIdentifier = string;

export type AddressingAddressMaps = {
  can_delete?: AddressingCanDelete;
  can_modify_ips?: AddressingCanModifyIps;
  created_at?: AddressingTimestamp;
  default_sni?: AddressingDefaultSni;
  description?: AddressingSchemasDescription;
  enabled?: AddressingEnabled;
  id?: AddressingAddressMapIdentifier;
  modified_at?: AddressingTimestamp;
};

export type AddressingAddressMapsIp = {
  created_at?: AddressingTimestamp;
  ip?: AddressingIp;
};

export type AddressingAddressMapsMembership = {
  can_delete?: AddressingSchemasCanDelete;
  created_at?: AddressingTimestamp;
  identifier?: AddressingIdentifier;
  kind?: AddressingKind;
};

/**
 * Identifier of an Address Map.
 *
 * @example 055817b111884e0227e1be16a0be6ee0
 * @maxLength 32
 * @x-auditable true
 */
export type AddressingAddressMapIdentifier = string;

/**
 * Prefix advertisement status to the Internet. This field is only not 'null' if on demand is enabled.
 *
 * @example true
 * @x-auditable true
 */
export type AddressingAdvertised = boolean | null;

export type AddressingAdvertisedResponse = AddressingApiResponseSingle & {
  result?: {
    advertised?: AddressingSchemasAdvertised;
    advertised_modified_at?: AddressingModifiedAtNullable;
  };
};

export type AddressingApiResponseCollection = AddressingApiResponseCommon & {
  result_info?: {
    /**
     * Total number of results for the requested service.
     *
     * @example 1
     */
    count?: number;
    /**
     * Current page within paginated list of results.
     *
     * @example 1
     */
    page?: number;
    /**
     * Number of results per page of results.
     *
     * @example 20
     */
    per_page?: number;
    /**
     * Total results available without any search parameters.
     *
     * @example 2000
     */
    total_count?: number;
  };
};

export type AddressingApiResponseCommon = {
  errors: AddressingMessages;
  messages: AddressingMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type AddressingApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: AddressingMessages;
  messages: AddressingMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type AddressingApiResponseSingle = AddressingApiResponseCommon;

/**
 * Approval state of the prefix (P = pending, V = active).
 *
 * @example P
 * @x-auditable true
 */
export type AddressingApproved = string;

/**
 * Autonomous System Number (ASN) the prefix will be advertised under.
 *
 * @example 209242
 * @x-auditable true
 */
export type AddressingAsn = number | null;

/**
 * Number of times to prepend the Cloudflare ASN to the BGP AS-Path attribute
 *
 * @default 0
 * @example 2
 * @maximum 3
 * @minimum 0
 * @x-auditable true
 */
export type AddressingAsnPrependCount = number;

export type AddressingBgpOnDemand = {
  advertised?: AddressingAdvertised;
  advertised_modified_at?: AddressingModifiedAtNullable;
  on_demand_enabled?: AddressingOnDemandEnabled;
  on_demand_locked?: AddressingOnDemandLocked;
};

export type AddressingBgpPrefixCreate = {
  cidr?: AddressingCidr;
};

/**
 * Identifier of BGP Prefix.
 *
 * @example 7009ba364c7a5760798ceb430e603b74
 * @maxLength 32
 * @x-auditable true
 */
export type AddressingBgpPrefixIdentifier = string;

export type AddressingBgpPrefixUpdateAdvertisement = {
  asn_prepend_count?: AddressingAsnPrependCount;
  on_demand?: {
    advertised?: boolean;
  };
  withdraw_if_no_route?: AddressingWithdrawIfNoRoute;
};

export type AddressingBgpSignalOpts = {
  enabled?: AddressingBgpSignalingEnabled;
  modified_at?: AddressingBgpSignalingModifiedAt;
};

/**
 * Whether control of advertisement of the prefix to the Internet is enabled to be performed via BGP signal
 *
 * @example false
 * @x-auditable true
 */
export type AddressingBgpSignalingEnabled = boolean;

/**
 * Last time BGP signaling control was toggled. This field is null if BGP signaling has never been enabled.
 *
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type AddressingBgpSignalingModifiedAt = string | null;

/**
 * If set to false, then the Address Map cannot be deleted via API. This is true for Cloudflare-managed maps.
 *
 * @example true
 * @x-auditable true
 */
export type AddressingCanDelete = boolean;

/**
 * If set to false, then the IPs on the Address Map cannot be modified via the API. This is true for Cloudflare-managed maps.
 *
 * @example true
 * @x-auditable true
 */
export type AddressingCanModifyIps = boolean;

/**
 * IP Prefix in Classless Inter-Domain Routing format.
 *
 * @example 192.0.2.0/24
 * @x-auditable true
 */
export type AddressingCidr = string;

export type AddressingComponentsSchemasResponseCollection =
  AddressingApiResponseCollection & {
    result?: AddressingAddressMaps[];
  };

export type AddressingComponentsSchemasSingleResponse =
  AddressingApiResponseSingle & {
    result?: AddressingAddressMaps;
  };

export type AddressingCreateBindingRequest = {
  cidr?: AddressingCidr;
  service_id?: AddressingServiceIdentifier;
};

/**
 * If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map. If Cloudflare receives a TLS handshake from a client without an SNI, it will respond with the default SNI on those IPs. The default SNI can be any valid zone or subdomain owned by the account.
 *
 * @example *.example.com
 * @x-auditable true
 */
export type AddressingDefaultSni = string | null;

/**
 * Account identifier for the account to which prefix is being delegated.
 *
 * @example b1946ac92492d2347c6235b4d2611184
 * @maxLength 32
 * @x-auditable true
 */
export type AddressingDelegatedAccountIdentifier = string;

/**
 * Identifier of a Delegation.
 *
 * @example d933b1530bc56c9953cf8ce166da8004
 * @maxLength 32
 * @x-auditable true
 */
export type AddressingDelegationIdentifier = string;

/**
 * Description of the prefix.
 *
 * @example Internal test prefix
 * @maxLength 1000
 * @x-auditable true
 */
export type AddressingDescription = string;

/**
 * Whether the Address Map is enabled or not. Cloudflare's DNS will not respond with IP addresses on an Address Map until the map is enabled.
 *
 * @default false
 * @example true
 * @x-auditable true
 */
export type AddressingEnabled = boolean | null;

/**
 * Name of LOA document. Max file size 10MB, and supported filetype is pdf.
 *
 * @example site_loa_doc.pdf
 * @x-auditable true
 */
export type AddressingFilename = string;

export type AddressingFullResponse = AddressingApiResponseSingle & {
  result?: AddressingAddressMaps & {
    ips?: AddressingIps;
    memberships?: AddressingMemberships;
  };
};

export type AddressingIdResponse = AddressingApiResponseSingle & {
  result?: {
    id?: AddressingDelegationIdentifier;
  };
};

/**
 * The identifier for the membership (eg. a zone or account tag).
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type AddressingIdentifier = string;

/**
 * An IPv4 or IPv6 address.
 *
 * @example 192.0.2.1
 * @x-auditable true
 */
export type AddressingIp = string;

/**
 * An IPv4 or IPv6 address.
 *
 * @example 192.0.2.1
 * @x-auditable true
 */
export type AddressingIpAddress = string;

export type AddressingIpamBgpPrefixes = {
  asn?: AddressingAsn;
  asn_prepend_count?: AddressingAsnPrependCount;
  bgp_signal_opts?: AddressingBgpSignalOpts;
  cidr?: AddressingCidr;
  created_at?: AddressingTimestamp;
  id?: AddressingBgpPrefixIdentifier;
  modified_at?: AddressingTimestamp;
  on_demand?: AddressingBgpOnDemand;
  withdraw_if_no_route?: AddressingWithdrawIfNoRoute;
};

export type AddressingIpamDelegations = {
  cidr?: AddressingCidr;
  created_at?: AddressingTimestamp;
  delegated_account_id?: AddressingDelegatedAccountIdentifier;
  id?: AddressingDelegationIdentifier;
  modified_at?: AddressingTimestamp;
  parent_prefix_id?: AddressingPrefixIdentifier;
};

export type AddressingIpamPrefixes = {
  account_id?: AddressingAccountIdentifier;
  advertised?: AddressingAdvertised;
  advertised_modified_at?: AddressingModifiedAtNullable;
  approved?: AddressingApproved;
  asn?: AddressingAsn;
  cidr?: AddressingCidr;
  created_at?: AddressingTimestamp;
  description?: AddressingDescription;
  id?: AddressingPrefixIdentifier;
  loa_document_id?: AddressingLoaDocumentIdentifier;
  modified_at?: AddressingTimestamp;
  on_demand_enabled?: AddressingOnDemandEnabled;
  on_demand_locked?: AddressingOnDemandLocked;
};

/**
 * The set of IPs on the Address Map.
 */
export type AddressingIps = AddressingAddressMapsIp[];

/**
 * The type of the membership.
 *
 * @example zone
 * @x-auditable true
 */
export type AddressingKind = "zone" | "account";

/**
 * Identifier for the uploaded LOA document.
 *
 * @example d933b1530bc56c9953cf8ce166da8004
 * @maxLength 32
 * @x-auditable true
 */
export type AddressingLoaDocumentIdentifier = string | null;

export type AddressingLoaUploadResponse = AddressingApiResponseSingle & {
  result?: {
    account_id?: AddressingAccountIdentifier;
    created?: AddressingTimestamp;
    filename?: AddressingFilename;
    id?: AddressingLoaDocumentIdentifier;
    size_bytes?: AddressingSizeBytes;
    verified?: AddressingVerified;
    verified_at?: AddressingVerifiedAt;
  };
};

/**
 * Zones and Accounts which will be assigned IPs on this Address Map. A zone membership will take priority over an account membership.
 */
export type AddressingMemberships = AddressingAddressMapsMembership[];

export type AddressingMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * Last time the advertisement status was changed. This field is only not 'null' if on demand is enabled.
 *
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type AddressingModifiedAtNullable = string | null;

/**
 * Whether advertisement of the prefix to the Internet may be dynamically enabled or disabled.
 *
 * @example true
 * @x-auditable true
 */
export type AddressingOnDemandEnabled = boolean;

/**
 * Whether advertisement status of the prefix is locked, meaning it cannot be changed.
 *
 * @example false
 * @x-auditable true
 */
export type AddressingOnDemandLocked = boolean;

/**
 * Identifier of an IP Prefix.
 *
 * @example 2af39739cc4e3b5910c918468bb89828
 * @maxLength 32
 * @x-auditable true
 */
export type AddressingPrefixIdentifier = string;

/**
 * Status of a Service Binding's deployment to the Cloudflare network
 */
export type AddressingProvisioning = {
  /**
   * When a binding has been deployed to a majority of Cloudflare datacenters, the binding will become active and can be used with its associated service.
   *
   * @example provisioning
   * @x-auditable true
   */
  state?: "provisioning" | "active";
};

export type AddressingResponseCollection = AddressingApiResponseCollection & {
  result?: AddressingIpamPrefixes[];
};

export type AddressingResponseCollectionBgp =
  AddressingApiResponseCollection & {
    result?: AddressingIpamBgpPrefixes[];
  };

/**
 * Advertisement status of the prefix. If `true`, the BGP route for the prefix is advertised to the Internet. If
 * `false`, the BGP route is withdrawn.
 *
 * @example true
 * @x-auditable true
 */
export type AddressingSchemasAdvertised = boolean;

/**
 * Controls whether the membership can be deleted via the API or not.
 *
 * @example true
 * @x-auditable true
 */
export type AddressingSchemasCanDelete = boolean;

/**
 * An optional description field which may be used to describe the types of IPs or zones on the map.
 *
 * @example My Ecommerce zones
 * @x-auditable true
 */
export type AddressingSchemasDescription = string | null;

export type AddressingSchemasResponseCollection =
  AddressingApiResponseCollection & {
    result?: AddressingIpamDelegations[];
  };

export type AddressingSchemasSingleResponse = AddressingApiResponseSingle & {
  result?: AddressingIpamDelegations;
};

export type AddressingServiceBinding = {
  cidr?: AddressingCidr;
  id?: AddressingServiceBindingIdentifier;
  provisioning?: AddressingProvisioning;
  service_id?: AddressingServiceIdentifier;
  service_name?: AddressingServiceName;
};

/**
 * Identifier of a Service Binding.
 *
 * @example 0429b49b6a5155297b78e75a44b09e14
 * @maxLength 32
 * @x-auditable true
 */
export type AddressingServiceBindingIdentifier = string;

/**
 * Identifier of a Service on the Cloudflare network. Available services and their IDs may be found in the
 * **List Services** endpoint.
 *
 * @example 2db684ee7ca04e159946fd05b99e1bcd
 * @maxLength 32
 * @x-auditable true
 */
export type AddressingServiceIdentifier = string;

/**
 * Name of a service running on the Cloudflare network
 *
 * @example Magic Transit
 * @x-auditable true
 */
export type AddressingServiceName = string;

export type AddressingSingleResponse = AddressingApiResponseSingle & {
  result?: AddressingIpamPrefixes;
};

export type AddressingSingleResponseBgp = AddressingApiResponseSingle & {
  result?: AddressingIpamBgpPrefixes;
};

/**
 * File size of the uploaded LOA document.
 *
 * @example 444
 * @x-auditable true
 */
export type AddressingSizeBytes = number;

/**
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type AddressingTimestamp = string;

/**
 * Whether the LOA has been verified by Cloudflare staff.
 *
 * @example true
 * @x-auditable true
 */
export type AddressingVerified = boolean;

/**
 * Timestamp of the moment the LOA was marked as validated.
 *
 * @format date-time
 * @x-auditable true
 */
export type AddressingVerifiedAt = string | null;

/**
 * Controls whether the BGP prefix is automatically withdrawn when prefix is withdrawn from Magic routing table (for Magic Transit customers using Direct CNI)
 *
 * @default false
 * @example true
 * @x-auditable true
 */
export type AddressingWithdrawIfNoRoute = boolean;

/**
 * Identifier of a zone.
 *
 * @example 8ac8489932db6327334c9b6d58544cfe
 * @maxLength 32
 * @x-auditable true
 */
export type AddressingZoneIdentifier = string;

export type ApiShieldApiResponseCollection = ApiShieldApiResponseCommon & {
  result_info?: {
    /**
     * Total number of results for the requested service.
     *
     * @example 1
     */
    count?: number;
    /**
     * Current page within paginated list of results.
     *
     * @example 1
     */
    page?: number;
    /**
     * Number of results per page of results.
     *
     * @example 20
     */
    per_page?: number;
    /**
     * Total results available without any search parameters.
     *
     * @example 2000
     */
    total_count?: number;
  };
};

export type ApiShieldApiResponseCommon = {
  errors: ApiShieldMessages;
  messages: ApiShieldMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type ApiShieldApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: ApiShieldMessages;
  messages: ApiShieldMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type ApiShieldApiResponseSingle = ApiShieldApiResponseCommon;

/**
 * * `ML` - Discovered operation was sourced using ML API Discovery * `SessionIdentifier` - Discovered operation was sourced using Session Identifier API Discovery * `LabelDiscovery` - Discovered operation was identified to have a specific label
 *
 * @x-auditable true
 */
export type ApiShieldApiDiscoveryOrigin =
  | "ML"
  | "SessionIdentifier"
  | "LabelDiscovery";

/**
 * @example {"3818d821-5901-4147-a474-f5f5aec1d54e":{"state":"ignored"},"b17c8043-99a0-4202-b7d9-8f7cdbee02cd":{"state":"review"}}
 */
export type ApiShieldApiDiscoveryPatchMultipleRequest = {
  [key: string]: ApiShieldApiDiscoveryPatchMultipleRequestEntry;
};

/**
 * Mappings of discovered operations (keys) to objects describing their state
 */
export type ApiShieldApiDiscoveryPatchMultipleRequestEntry = {
  state?: ApiShieldApiDiscoveryStatePatch;
};

/**
 * State of operation in API Discovery
 *   * `review` - Operation is not saved into API Shield Endpoint Management
 *   * `saved` - Operation is saved into API Shield Endpoint Management
 *   * `ignored` - Operation is marked as ignored
 *
 * @x-auditable true
 */
export type ApiShieldApiDiscoveryState = "review" | "saved" | "ignored";

/**
 * Mark state of operation in API Discovery
 *   * `review` - Mark operation as for review
 *   * `ignored` - Mark operation as ignored
 *
 * @x-auditable true
 */
export type ApiShieldApiDiscoveryStatePatch = "review" | "ignored";

/**
 * Auth ID Characteristic
 */
export type ApiShieldAuthIdCharacteristic = {
  /**
   * The name of the characteristic field, i.e., the header or cookie name.
   *
   * @example authorization
   * @maxLength 128
   * @x-auditable true
   */
  name: string;
  /**
   * The type of characteristic.
   *
   * @example header
   * @x-auditable true
   */
  type: "header" | "cookie";
};

/**
 * Auth ID Characteristic extracted from JWT Token Claims
 */
export type ApiShieldAuthIdCharacteristicJwtClaim = {
  /**
   * Claim location expressed as `$(token_config_id):$(json_path)`, where `token_config_id`
   * is the ID of the token configuration used in validating the JWT, and `json_path` is a RFC 9535
   * JSONPath (https://goessner.net/articles/JsonPath/, https://www.rfc-editor.org/rfc/rfc9535.html).
   * The JSONPath expression may be in dot or bracket notation, may only specify literal keys
   * or array indexes, and must return a singleton value, which will be interpreted as a string.
   *
   * @example e0de1a3a-8c2c-4f90-98d8-cbdf0a3f2cb5:$.foo.bar[0].baz
   * @maxLength 128
   * @pattern ^(?<token_config_id>[a-z0-9\-]{32,36}):\$(?<json_path>.*?)$
   * @x-auditable true
   */
  name: string;
  /**
   * The type of characteristic.
   *
   * @example jwt
   * @x-auditable true
   */
  type: "jwt";
};

/**
 * @maxItems 10
 * @uniqueItems true
 */
export type ApiShieldAuthIdCharacteristics = (
  | ApiShieldAuthIdCharacteristic
  | ApiShieldAuthIdCharacteristicJwtClaim
)[];

/**
 * The total number of auth-ids seen across this calculation.
 *
 * @x-auditable true
 */
export type ApiShieldAuthIdTokens = number;

export type ApiShieldBasicOperation = {
  endpoint: ApiShieldEndpoint;
  host: ApiShieldHost;
  method: ApiShieldMethod;
};

/**
 * Upper and lower bound for percentile estimate
 */
export type ApiShieldConfidenceIntervalsBounds = {
  /**
   * Lower bound for percentile estimate
   *
   * @example 20.5
   * @x-auditable true
   */
  lower?: number;
  /**
   * Upper bound for percentile estimate
   *
   * @example 30.4
   * @x-auditable true
   */
  upper?: number;
};

export type ApiShieldConfiguration = {
  auth_id_characteristics: ApiShieldAuthIdCharacteristics;
};

export type ApiShieldConfigurationSingleResponse =
  ApiShieldApiResponseCommon & {
    result: ApiShieldConfiguration;
  };

/**
 * The number of data points used for the threshold suggestion calculation.
 *
 * @x-auditable true
 */
export type ApiShieldDataPoints = number;

export type ApiShieldDiscoveryOperation = {
  features?: ApiShieldTrafficStats;
  id: ApiShieldSchemasUuid;
  last_updated: ApiShieldSchemasTimestamp;
  /**
   * API discovery engine(s) that discovered this operation
   */
  origin: ApiShieldApiDiscoveryOrigin[];
  state: ApiShieldApiDiscoveryState;
} & ApiShieldBasicOperation;

/**
 * The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with {varN}, starting with {var1}, during insertion. This will further be Cloudflare-normalized upon insertion. See: https://developers.cloudflare.com/rules/normalization/how-it-works/.
 *
 * @example /api/v1/users/{var1}
 * @format uri-template
 * @maxLength 4096
 * @pattern ^/.*$
 * @x-auditable true
 */
export type ApiShieldEndpoint = string;

export type ApiShieldGlobalSettingChangeBase = {
  /**
   * The default mitigation action used
   * Mitigation actions are as follows:
   *
   *   - `"log"` - log request when request does not conform to schema
   *   - `"block"` - deny access to the site when request does not conform to schema
   *   - `"none"` - skip running schema validation
   *
   * @example block
   * @x-auditable true
   */
  validation_default_mitigation_action?: "none" | "log" | "block";
  /**
   * When set, this overrides both zone level and operation level mitigation actions.
   *
   *   - `"none"` - skip running schema validation entirely for the request
   *   - `null` - clears any existing override
   *
   * @x-auditable true
   */
  validation_override_mitigation_action?: "none" | any | null;
};

export type ApiShieldGlobalSettings = {
  /**
   * The default mitigation action used
   *
   * Mitigation actions are as follows:
   *
   *   - `log` - log request when request does not conform to schema
   *   - `block` - deny access to the site when request does not conform to schema
   *   - `none` - skip running schema validation
   *
   * @example block
   * @x-auditable true
   */
  validation_default_mitigation_action: "none" | "log" | "block";
  /**
   * When not null, this overrides global both zone level and operation level mitigation actions. This can serve as a quick way to disable schema validation for the whole zone.
   *
   *   - `"none"` will skip running schema validation entirely for the request
   *
   * @x-auditable true
   */
  validation_override_mitigation_action?: "none";
};

/**
 * RFC3986-compliant host.
 *
 * @example www.example.com
 * @format hostname
 * @maxLength 255
 * @x-auditable true
 */
export type ApiShieldHost = string;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type ApiShieldIdentifier = string;

/**
 * Kind of schema
 *
 * @example openapi_v3
 * @x-auditable true
 */
export type ApiShieldKind = "openapi_v3";

export type ApiShieldMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * The HTTP method used to access the endpoint.
 *
 * @example GET
 * @x-auditable true
 */
export type ApiShieldMethod =
  | "GET"
  | "POST"
  | "HEAD"
  | "OPTIONS"
  | "PUT"
  | "DELETE"
  | "CONNECT"
  | "PATCH"
  | "TRACE";

export type ApiShieldMultipleOperationResponse = ApiShieldApiResponseCommon & {
  result: ApiShieldOperation[];
};

export type ApiShieldMultipleOperationResponsePaginated =
  ApiShieldApiResponseCollection & {
    result: ApiShieldOperation[];
  };

export type ApiShieldObjectWithOperationId = {
  /**
   * The ID of the operation
   *
   * @x-auditable true
   */
  operation_id: string & ApiShieldSchemasUuid;
};

/**
 * A OpenAPI 3.0.0 compliant schema.
 *
 * @example {"info":{"title":"OpenAPI JSON schema for www.example.com","version":"1.0"},"openapi":"3.0.0","paths":{"... Further paths ...":{},"/api/v1/users/{var1}":{"get":{"parameters":[{"in":"path","name":"var1","required":true,"schema":{"type":"string"}}]}}},"servers":[{"url":"www.example.com"}]}
 */
export type ApiShieldOpenapi = Record<string, any>;

/**
 * A OpenAPI 3.0.0 compliant schema.
 *
 * @example {"info":{"title":"OpenAPI JSON schema for www.example.com","version":"1.0"},"openapi":"3.0.0","paths":{"... Further paths ...":{},"/api/v1/users/{var1}":{"get":{"parameters":[{"in":"path","name":"var1","required":true,"schema":{"type":"string"}}]}}},"servers":[{"url":"www.example.com"}]}
 */
export type ApiShieldOpenapiWithThresholds = Record<string, any>;

/**
 * @default {}
 */
export type ApiShieldOperation = ApiShieldStandardOperation &
  ({
    features?: ApiShieldOperationFeatures;
  } | null);

/**
 * @example {"api_routing":{"last_updated":"2014-01-01T05:20:00.12345Z","route":"https://api.example.com/api/service"}}
 */
export type ApiShieldOperationFeatureApiRouting = {
  /**
   * API Routing settings on endpoint.
   */
  api_routing?: {
    last_updated?: ApiShieldTimestamp;
    /**
     * Target route.
     *
     * @example https://api.example.com/api/service
     * @x-auditable true
     */
    route?: string;
  };
};

/**
 * @example {"confidence_intervals":{"last_updated":"2014-01-01T05:20:00.12345Z","suggested_threshold":{"confidence_intervals":{"p90":{"lower":23.1,"upper":23.9},"p95":{"lower":22,"upper":24.1},"p99":{"lower":20.2,"upper":30}},"mean":23.5}}}
 */
export type ApiShieldOperationFeatureConfidenceIntervals = {
  confidence_intervals?: {
    last_updated?: ApiShieldTimestamp;
    suggested_threshold?: {
      confidence_intervals?: {
        p90?: ApiShieldConfidenceIntervalsBounds;
        p95?: ApiShieldConfidenceIntervalsBounds;
        p99?: ApiShieldConfidenceIntervalsBounds;
      };
      /**
       * Suggested threshold.
       *
       * @example 25.5
       * @x-auditable true
       */
      mean?: number;
    };
  };
};

export type ApiShieldOperationFeatureParameterSchemas = {
  parameter_schemas: {
    last_updated?: ApiShieldTimestamp;
    parameter_schemas?: ApiShieldParameterSchemasDefinition;
  };
};

export type ApiShieldOperationFeatureSchemaInfo = {
  schema_info?: {
    /**
     * Schema active on endpoint.
     */
    active_schema?: {
      created_at?: ApiShieldTimestamp;
      id?: ApiShieldSchemasUuid;
      /**
       * True if schema is Cloudflare-provided.
       *
       * @example true
       * @x-auditable true
       */
      is_learned?: boolean;
      /**
       * Schema file name.
       *
       * @example api-endpoints-8694824bf5c04d019edcbf399c03c103-api-discovery.example.com-thresholds.json
       * @x-auditable true
       */
      name?: string;
    };
    /**
     * True if a Cloudflare-provided learned schema is available for this endpoint.
     *
     * @example true
     * @x-auditable true
     */
    learned_available?: boolean;
    /**
     * Action taken on requests failing validation.
     *
     * @example block
     * @x-auditable true
     */
    mitigation_action?: "none" | "log" | "block" | null;
  };
};

export type ApiShieldOperationFeatureThresholds = {
  thresholds?: {
    auth_id_tokens?: ApiShieldAuthIdTokens;
    data_points?: ApiShieldDataPoints;
    last_updated?: ApiShieldTimestamp;
    p50?: ApiShieldP50;
    p90?: ApiShieldP90;
    p99?: ApiShieldP99;
    period_seconds?: ApiShieldPeriodSeconds;
    requests?: ApiShieldRequests;
    suggested_threshold?: ApiShieldSuggestedThreshold;
  };
};

export type ApiShieldOperationFeatures =
  | ApiShieldOperationFeatureThresholds
  | ApiShieldOperationFeatureParameterSchemas
  | ApiShieldOperationFeatureApiRouting
  | ApiShieldOperationFeatureConfidenceIntervals
  | ApiShieldOperationFeatureSchemaInfo;

/**
 * When set, this applies a mitigation action to this operation
 *
 *   - `log` log request when request does not conform to schema for this operation
 *   - `block` deny access to the site when request does not conform to schema for this operation
 *   - `none` will skip mitigation for this operation
 *   - `null` indicates that no operation level mitigation is in place, see Zone Level Schema Validation Settings for mitigation action that will be applied
 *
 * @example block
 * @x-auditable true
 */
export type ApiShieldOperationMitigationAction =
  | "log"
  | "block"
  | "none"
  | any
  | null;

export type ApiShieldOperationSchemaValidationSettings = {
  mitigation_action?: ApiShieldOperationMitigationAction;
  operation_id?: ApiShieldSchemasUuid;
};

export type ApiShieldOperationSchemaValidationSettingsModifyRequest = {
  mitigation_action?: ApiShieldOperationMitigationAction;
};

/**
 * @example {"3818d821-5901-4147-a474-f5f5aec1d54e":{"mitigation_action":"log"},"b17c8043-99a0-4202-b7d9-8f7cdbee02cd":{"mitigation_action":"block"}}
 */
export type ApiShieldOperationSchemaValidationSettingsMultipleRequest = {
  [key: string]: ApiShieldOperationSchemaValidationSettingsMultipleRequestEntry;
};

/**
 * Operation ID to mitigation action mappings
 */
export type ApiShieldOperationSchemaValidationSettingsMultipleRequestEntry = {
  mitigation_action?: ApiShieldOperationMitigationAction;
};

/**
 * The p50 quantile of requests (in period_seconds).
 *
 * @x-auditable true
 */
export type ApiShieldP50 = number;

/**
 * The p90 quantile of requests (in period_seconds).
 *
 * @x-auditable true
 */
export type ApiShieldP90 = number;

/**
 * The p99 quantile of requests (in period_seconds).
 *
 * @x-auditable true
 */
export type ApiShieldP99 = number;

/**
 * An operation schema object containing a response.
 *
 * @example {"parameters":[{"description":"Sufficient requests have been observed for this parameter to provide high confidence in this parameter schema.","in":"path","name":"var1","required":true,"schema":{"maximum":10,"minimum":1,"type":"integer"}}],"responses":null}
 */
export type ApiShieldParameterSchemasDefinition = {
  /**
   * An array containing the learned parameter schemas.
   *
   * @example {"description":"Sufficient requests have been observed for this parameter to provide high confidence in this parameter schema.","in":"path","name":"var1","required":true,"schema":{"maximum":10,"minimum":1,"type":"integer"}}
   */
  parameters?: Record<string, any>[];
  /**
   * An empty response object. This field is required to yield a valid operation schema.
   */
  responses?: Record<string, any> | null;
};

export type ApiShieldPatchDiscoveriesResponse = ApiShieldApiResponseCommon & {
  result: ApiShieldApiDiscoveryPatchMultipleRequest;
};

export type ApiShieldPatchDiscoveryResponse = ApiShieldApiResponseCommon & {
  result: {
    state?: ApiShieldApiDiscoveryState;
  };
};

/**
 * Operation ID to per operation setting mapping
 *
 * @example {"3818d821-5901-4147-a474-f5f5aec1d54e":{"mitigation_action":"log"},"b17c8043-99a0-4202-b7d9-8f7cdbee02cd":{"mitigation_action":"block"}}
 */
export type ApiShieldPerOperationBulkSettings = {
  [key: string]: ApiShieldPerOperationSetting;
};

export type ApiShieldPerOperationSetting = {
  /**
   * When set, this applies a mitigation action to this operation which supersedes a global schema validation setting just for this operation
   *
   *   - `"log"` - log request when request does not conform to schema for this operation
   *   - `"block"` - deny access to the site when request does not conform to schema for this operation
   *   - `"none"` - will skip mitigation for this operation
   *
   * @example block
   * @x-auditable true
   */
  mitigation_action: "log" | "block" | "none";
  operation_id: ApiShieldSchemasUuid;
};

export type ApiShieldPerOperationSettingChangeBase = {
  /**
   * When set, this applies a mitigation action to this operation
   *
   *   - `"log"` - log request when request does not conform to schema for this operation
   *   - `"block"` - deny access to the site when request does not conform to schema for this operation
   *   - `"none"` - will skip mitigation for this operation
   *   - `null` - clears any mitigation action
   *
   * @example block
   * @x-auditable true
   */
  mitigation_action?: "log" | "block" | "none" | any | null;
};

/**
 * The period over which this threshold is suggested.
 *
 * @x-auditable true
 */
export type ApiShieldPeriodSeconds = number;

/**
 * Requests information about certain properties.
 *
 * @example auth_id_characteristics
 * @uniqueItems true
 */
export type ApiShieldProperties = "auth_id_characteristics"[];

export type ApiShieldPublicSchema = {
  created_at: ApiShieldSchemasTimestamp;
  kind: ApiShieldKind;
  /**
   * Name of the schema
   *
   * @example petstore schema
   * @x-auditable true
   */
  name: string;
  schema_id: ApiShieldSchemasUuid;
  /**
   * Source of the schema
   *
   * @example <schema file bytes>
   * @x-auditable true
   */
  source?: string;
  validation_enabled?: ApiShieldValidationEnabled;
};

export type ApiShieldPublicSchemaSuccessResult = ApiShieldApiResponseCommon & {
  result: ApiShieldSchemasPublicSchema;
};

export type ApiShieldRequestExpressionTemplatesFallthrough = {
  /**
   * List of hosts to be targeted in the expression
   *
   * @example {zone}.domain1.tld
   * @example domain2.tld
   */
  hosts: string[];
};

/**
 * The estimated number of requests covered by these calculations.
 *
 * @x-auditable true
 */
export type ApiShieldRequests = number;

export type ApiShieldResponseExpressionTemplatesFallthrough = {
  /**
   * WAF Expression for fallthrough
   *
   * @example (cf.api_gateway.fallthrough_detected)
   * @x-auditable true
   */
  expression: string;
  /**
   * Title for the expression
   *
   * @example Fallthrough Expression for [zone.domain.tld]
   * @x-auditable true
   */
  title: string;
};

export type ApiShieldResponseUserSchemasHosts = {
  created_at: ApiShieldSchemasTimestamp;
  /**
   * Hosts serving the schema, e.g zone.host.com
   */
  hosts: string[];
  /**
   * Name of the schema
   *
   * @example petstore schema
   * @x-auditable true
   */
  name: string;
  schema_id: ApiShieldSchemasUuid;
};

export type ApiShieldSchemaResponseWithThresholds =
  ApiShieldApiResponseCommon & {
    result: {
      schemas?: ApiShieldOpenapiWithThresholds[];
      /**
       * @x-auditable true
       */
      timestamp?: string;
    };
  };

export type ApiShieldSchemaHosts = {
  created_at: ApiShieldSchemasTimestamp;
  /**
   * Hosts serving the schema, e.g zone.host.com
   *
   * @x-auditable true
   */
  hosts: string[];
  /**
   * Name of the schema
   *
   * @example petstore schema
   * @x-auditable true
   */
  name: string;
  /**
   * A unique identifier of this schema
   *
   * @x-auditable true
   * @format uuid
   */
  schema_id: ApiShieldSchemasUuid & string;
};

export type ApiShieldSchemaIssueNotification = {
  /**
   * A unique error code that describes the kind of issue with the schema
   *
   * @minimum 1000
   */
  code: number;
  /**
   * A short text explaining the issue with the schema
   */
  message: string;
  source?: {
    /**
     * A list of JSON path expression(s) that describe the location(s) of the issue within the provided resource. See [https://goessner.net/articles/JsonPath/](https://goessner.net/articles/JsonPath/) for JSONPath specification.
     */
    locations?: string[];
  } | null;
};

export type ApiShieldSchemaResponseDiscovery = ApiShieldApiResponseCommon & {
  result: {
    schemas: ApiShieldOpenapi[];
    timestamp: ApiShieldSchemasTimestamp;
  };
};

export type ApiShieldSchemaUploadDetailsErrorsCritical = {
  /**
   * Diagnostic critical error events that occurred during processing.
   */
  critical?: ApiShieldSchemaUploadLogEvent[];
  /**
   * Diagnostic error events that occurred during processing.
   */
  errors?: ApiShieldSchemaUploadLogEvent[];
};

export type ApiShieldSchemaUploadDetailsWarningsOnly = {
  /**
   * Diagnostic warning events that occurred during processing. These events are non-critical errors found within the schema.
   */
  warnings?: ApiShieldSchemaUploadLogEvent[];
};

export type ApiShieldSchemaUploadFailure = ApiShieldApiResponseCommonFailure & {
  upload_details?: ApiShieldSchemaUploadDetailsErrorsCritical;
};

export type ApiShieldSchemaUploadLogEvent = {
  /**
   * Code that identifies the event that occurred.
   *
   * @example 28
   * @x-auditable true
   */
  code: number;
  /**
   * JSONPath location(s) in the schema where these events were encountered.  See [https://goessner.net/articles/JsonPath/](https://goessner.net/articles/JsonPath/) for JSONPath specification.
   */
  locations?: string[];
  /**
   * Diagnostic message that describes the event.
   *
   * @example unsupported media type: application/octet-stream
   * @x-auditable true
   */
  message?: string;
};

export type ApiShieldSchemaUploadResponse = {
  schema: ApiShieldPublicSchema;
  upload_details?: ApiShieldSchemaUploadDetailsWarningsOnly;
};

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type ApiShieldSchemasIdentifier = ApiShieldIdentifier & string;

/**
 * A schema used in schema validation
 */
export type ApiShieldSchemasPublicSchema = {
  created_at: ApiShieldSchemasTimestamp;
  /**
   * The kind of the schema
   *
   * @example openapi_v3
   * @x-auditable true
   */
  kind: "openapi_v3";
  /**
   * A human-readable name for the schema
   *
   * @example petstore schema
   * @x-auditable true
   */
  name: string;
  /**
   * A unique identifier of this schema
   *
   * @x-auditable true
   * @format uuid
   */
  schema_id: ApiShieldSchemasUuid & string;
  /**
   * The raw schema, e.g., the OpenAPI schema, either as JSON or YAML
   *
   * @example <schema file contents>
   * @x-auditable true
   */
  source: string;
  /**
   * An indicator if this schema is enabled
   *
   * @x-auditable true
   */
  validation_enabled?: boolean;
};

/**
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type ApiShieldSchemasTimestamp = ApiShieldTimestamp & string;

/**
 * UUID.
 *
 * @minLength 36
 * @x-auditable true
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 */
export type ApiShieldSchemasUuid = string & ApiShieldUuid;

export type ApiShieldSingleOperationResponse = ApiShieldApiResponseCommon & {
  result: ApiShieldOperation;
};

export type ApiShieldStandardOperation = ApiShieldBasicOperation & {
  last_updated: ApiShieldSchemasTimestamp;
  operation_id: ApiShieldSchemasUuid;
};

/**
 * The suggested threshold in requests done by the same auth_id or period_seconds.
 *
 * @x-auditable true
 */
export type ApiShieldSuggestedThreshold = number;

/**
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type ApiShieldTimestamp = string;

export type ApiShieldTrafficStats = {
  traffic_stats?: {
    last_updated: ApiShieldSchemasTimestamp;
    /**
     * The period in seconds these statistics were computed over
     *
     * @example 3600
     * @x-auditable true
     */
    period_seconds: number;
    /**
     * The average number of requests seen during this period
     *
     * @example 1987.06
     * @format float
     * @x-auditable true
     */
    requests: number;
  };
};

/**
 * UUID.
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 * @x-auditable true
 */
export type ApiShieldUuid = string;

/**
 * The default mitigation action used when there is no mitigation action defined on the operation
 *
 * Mitigation actions are as follows:
 *
 *   * `log` - log request when request does not conform to schema
 *   * `block` - deny access to the site when request does not conform to schema
 *
 * A special value of of `none` will skip running schema validation entirely for the request when there is no mitigation action defined on the operation
 *
 * @example block
 * @x-auditable true
 */
export type ApiShieldValidationDefaultMitigationAction =
  | "none"
  | "log"
  | "block";

/**
 * The default mitigation action used when there is no mitigation action defined on the operation
 * Mitigation actions are as follows:
 *
 *   * `log` - log request when request does not conform to schema
 *   * `block` - deny access to the site when request does not conform to schema
 *
 * A special value of of `none` will skip running schema validation entirely for the request when there is no mitigation action defined on the operation
 *
 * `null` will have no effect.
 *
 * @example block
 * @x-auditable true
 */
export type ApiShieldValidationDefaultMitigationActionPatch =
  | "none"
  | "log"
  | "block"
  | any
  | null;

/**
 * Flag whether schema is enabled for validation.
 *
 * @x-auditable true
 */
export type ApiShieldValidationEnabled = boolean;

/**
 * When set, this overrides both zone level and operation level mitigation actions.
 *
 *   - `none` will skip running schema validation entirely for the request
 *   - `null` indicates that no override is in place
 *
 * @example disable_override
 * @x-auditable true
 */
export type ApiShieldValidationOverrideMitigationAction = "none" | any | null;

/**
 * When set, this overrides both zone level and operation level mitigation actions.
 *
 *   - `none` will skip running schema validation entirely for the request
 *
 * To clear any override, use the special value `disable_override`
 *
 * `null` will have no effect.
 *
 * @example none
 * @x-auditable true
 */
export type ApiShieldValidationOverrideMitigationActionPatch =
  | "none"
  | "disable_override"
  | any
  | null;

/**
 * When set, this overrides both zone level and operation level mitigation actions.
 *
 *   - `none` will skip running schema validation entirely for the request
 *   - `null` indicates that no override is in place
 *
 * To clear any override, use the special value `disable_override` or `null`
 *
 * @example none
 * @x-auditable true
 */
export type ApiShieldValidationOverrideMitigationActionWrite =
  | "none"
  | "disable_override"
  | any
  | null;

export type ApiShieldZoneSchemaValidationSettings = {
  validation_default_mitigation_action?: ApiShieldValidationDefaultMitigationAction;
  validation_override_mitigation_action?: ApiShieldValidationOverrideMitigationAction;
};

export type ApiShieldZoneSchemaValidationSettingsPatch = {
  validation_default_mitigation_action?: ApiShieldValidationDefaultMitigationActionPatch;
  validation_override_mitigation_action?: ApiShieldValidationOverrideMitigationActionPatch;
};

export type ApiShieldZoneSchemaValidationSettingsPut = {
  validation_default_mitigation_action: ApiShieldValidationDefaultMitigationAction;
  validation_override_mitigation_action?: ApiShieldValidationOverrideMitigationActionWrite;
};

export type ArgoAnalyticsApiResponseCommon = {
  errors: ArgoAnalyticsMessages;
  messages: ArgoAnalyticsMessages;
  result: Record<string, any> | any[] | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type ArgoAnalyticsApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: ArgoAnalyticsMessages;
  messages: ArgoAnalyticsMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

export type ArgoAnalyticsApiResponseSingle = {
  errors: ArgoAnalyticsMessages;
  messages: ArgoAnalyticsMessages;
  result: (Record<string, any> | null) | (string | null) | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type ArgoAnalyticsIdentifier = string;

export type ArgoAnalyticsMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

export type ArgoAnalyticsResponseSingle = ArgoAnalyticsApiResponseSingle & {
  result?: Record<string, any>;
};

export type ArgoConfigApiResponseCommon = {
  errors: ArgoConfigMessages;
  messages: ArgoConfigMessages;
  /**
   * Describes a successful API response.
   *
   * @example true
   */
  success: true;
};

export type ArgoConfigApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: ArgoConfigMessages;
  messages: ArgoConfigMessages;
  result: any | null;
  /**
   * Describes a failed API response.
   *
   * @example false
   */
  success: false;
};

export type ArgoConfigApiResponseSingle = ArgoConfigApiResponseCommon;

/**
 * Specifies the zone associated with the API call.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type ArgoConfigIdentifier = string;

export type ArgoConfigMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * Configures the enablement of Argo Smart Routing.
 */
export type ArgoConfigPatch = {
  value: ArgoConfigValue;
};

export type ArgoConfigResponseSingle = ArgoConfigApiResponseSingle & {
  result?: Record<string, any>;
};

/**
 * Enables Argo Smart Routing.
 *
 * @example on
 * @x-auditable true
 */
export type ArgoConfigValue = "on" | "off";

export type BillSubsApiAccountSubscriptionResponseCollection =
  BillSubsApiApiResponseCollection & {
    result?: BillSubsApiSubscription[];
  };

export type BillSubsApiAccountSubscriptionResponseSingle =
  BillSubsApiApiResponseSingle & {
    result?: BillSubsApiSubscription;
  };

/**
 * The billing item action.
 *
 * @example subscription
 * @maxLength 30
 */
export type BillSubsApiAction = string;

/**
 * The amount associated with this billing item.
 *
 * @example 20.99
 */
export type BillSubsApiAmount = number;

export type BillSubsApiApiResponseCollection = {
  errors: BillSubsApiMessages;
  messages: BillSubsApiMessages;
  result: Record<string, any> | any[] | string | null;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
  result_info?: BillSubsApiResultInfo;
};

export type BillSubsApiApiResponseCommon = {
  errors: BillSubsApiMessages;
  messages: BillSubsApiMessages;
  result: Record<string, any> | any[] | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type BillSubsApiApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: BillSubsApiMessages;
  messages: BillSubsApiMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

export type BillSubsApiApiResponseSingle = {
  errors: BillSubsApiMessages;
  messages: BillSubsApiMessages;
  result: (Record<string, any> | null) | (string | null) | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type BillSubsApiAvailableRatePlan = {
  can_subscribe?: BillSubsApiCanSubscribe;
  currency?: BillSubsApiCurrency;
  externally_managed?: BillSubsApiExternallyManaged;
  frequency?: BillSubsApiSchemasFrequency;
  id?: BillSubsApiIdentifier;
  is_subscribed?: BillSubsApiIsSubscribed;
  legacy_discount?: BillSubsApiLegacyDiscount;
  legacy_id?: BillSubsApiLegacyId;
  name?: BillSubsApiSchemasName;
  price?: BillSubsApiSchemasPrice;
};

export type BillSubsApiBillingHistory = {
  action: BillSubsApiAction;
  amount: BillSubsApiAmount;
  currency: BillSubsApiCurrency;
  description: BillSubsApiDescription;
  id: BillSubsApiComponentsSchemasIdentifier;
  occurred_at: BillSubsApiOccurredAt;
  type: BillSubsApiType;
  zone: BillSubsApiSchemasZone;
};

export type BillSubsApiBillingHistoryCollection =
  BillSubsApiApiResponseCollection & {
    result?: BillSubsApiBillingHistory[];
  };

export type BillSubsApiBillingResponseSingle = BillSubsApiApiResponseSingle & {
  result?: {
    /**
     * @example type
     */
    account_type?: string;
    /**
     * @example 123 Main Street
     */
    address?: string;
    /**
     * @example Apt 1
     */
    address2?: string;
    /**
     * @example 0
     */
    balance?: string;
    /**
     * @example 12
     */
    card_expiry_month?: number;
    /**
     * @example 2099
     */
    card_expiry_year?: number;
    /**
     * @example 4242424242424242
     */
    card_number?: string;
    /**
     * @example Anytown
     */
    city?: string;
    /**
     * @example Company
     */
    company?: string;
    /**
     * @example Anycountry
     */
    country?: string;
    /**
     * @example 2014-03-01T12:21:59.3456Z
     * @format date-time
     */
    created_on?: string;
    /**
     * @example sample_data
     */
    device_data?: string;
    /**
     * @example 2014-03-01T12:21:59.3456Z
     * @format date-time
     */
    edited_on?: string;
    /**
     * @example johndoe@gmail.com
     */
    enterprise_billing_email?: string;
    /**
     * @example johndoe@gmail.com
     */
    enterprise_primary_email?: string;
    /**
     * @example John
     */
    first_name?: string;
    id?: BillSubsApiComponentsSchemasIdentifier;
    /**
     * @example false
     */
    is_partner?: boolean;
    /**
     * @example Doe
     */
    last_name?: string;
    /**
     * @example 2014-03-01T12:21:59.3456Z
     * @format date-time
     */
    next_bill_date?: string;
    /**
     * @example 123 Main Street
     */
    payment_address?: string;
    /**
     * @example Apt 1
     */
    payment_address2?: string;
    /**
     * @example Anytown
     */
    payment_city?: string;
    /**
     * @example Anycountry
     */
    payment_country?: string;
    /**
     * @example johndoe@gmail.com
     */
    payment_email?: string;
    /**
     * @example John
     */
    payment_first_name?: string;
    /**
     * @example gateway
     */
    payment_gateway?: string;
    /**
     * @example Doe
     */
    payment_last_name?: string;
    /**
     * @example abc123
     */
    payment_nonce?: string;
    /**
     * @example state
     */
    payment_state?: string;
    /**
     * @example 12345
     */
    payment_zipcode?: string;
    /**
     * @example johndoe@gmail.com
     */
    primary_email?: string;
    /**
     * @example AnyState
     */
    state?: string;
    /**
     * @example type
     */
    tax_id_type?: string;
    /**
     * @example 1234567899
     */
    telephone?: string;
    /**
     * @example false
     */
    use_legacy?: boolean;
    /**
     * @example 1111
     */
    validation_code?: string;
    /**
     * @example GB123456789
     */
    vat?: string;
    /**
     * @example 12345
     */
    zipcode?: string;
  };
};

/**
 * Indicates whether you can subscribe to this plan.
 *
 * @default false
 * @example true
 */
export type BillSubsApiCanSubscribe = boolean;

export type BillSubsApiComponentValue = {
  ["default"]?: BillSubsApiDefault;
  name?: BillSubsApiComponentsSchemasName;
  unit_price?: BillSubsApiUnitPrice;
};

/**
 * The list of add-ons subscribed to.
 */
export type BillSubsApiComponentValues = BillSubsApiComponentValue2[];

/**
 * Billing item identifier tag.
 *
 * @example b69a9f3492637782896352daae219e7d
 * @maxLength 32
 */
export type BillSubsApiComponentsSchemasIdentifier = string;

/**
 * The unique component.
 *
 * @example page_rules
 */
export type BillSubsApiComponentsSchemasName =
  | "zones"
  | "page_rules"
  | "dedicated_certificates"
  | "dedicated_certificates_custom";

/**
 * The monetary unit in which pricing information is displayed.
 *
 * @example USD
 */
export type BillSubsApiCurrency = string;

/**
 * The end of the current period and also when the next billing is due.
 *
 * @example 2014-03-31T12:20:00Z
 * @format date-time
 */
export type BillSubsApiCurrentPeriodEnd = string;

/**
 * When the current billing period started. May match initial_period_start if this is the first period.
 *
 * @example 2014-05-11T12:20:00Z
 * @format date-time
 */
export type BillSubsApiCurrentPeriodStart = string;

/**
 * The default amount allocated.
 *
 * @example 5
 */
export type BillSubsApiDefault = number;

/**
 * The billing item description.
 *
 * @example The billing item description
 * @maxLength 255
 */
export type BillSubsApiDescription = string;

/**
 * The duration of the plan subscription.
 *
 * @example 1
 */
export type BillSubsApiDuration = number;

/**
 * Indicates whether this plan is managed externally.
 *
 * @default false
 * @example false
 */
export type BillSubsApiExternallyManaged = boolean;

/**
 * How often the subscription is renewed automatically.
 *
 * @example monthly
 */
export type BillSubsApiFrequency =
  | "weekly"
  | "monthly"
  | "quarterly"
  | "yearly";

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type BillSubsApiIdentifier = string;

/**
 * app install id.
 */
export type BillSubsApiInstallId = string;

/**
 * Indicates whether you are currently subscribed to this plan.
 *
 * @default false
 * @example false
 */
export type BillSubsApiIsSubscribed = boolean;

/**
 * Indicates whether this plan has a legacy discount applied.
 *
 * @default false
 * @example false
 */
export type BillSubsApiLegacyDiscount = boolean;

/**
 * The legacy identifier for this rate plan, if any.
 *
 * @example free
 */
export type BillSubsApiLegacyId = string;

export type BillSubsApiMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * The domain name
 *
 * @example example.com
 * @maxLength 253
 * @pattern ^([a-zA-Z0-9][\-a-zA-Z0-9]*\.)+[\-a-zA-Z0-9]{2,20}$
 */
export type BillSubsApiName = string;

/**
 * When the billing item was created.
 *
 * @example 2014-03-01T12:21:59.3456Z
 * @format date-time
 */
export type BillSubsApiOccurredAt = string;

export type BillSubsApiPlanResponseCollection =
  BillSubsApiApiResponseCollection & {
    result?: BillSubsApiSchemasRatePlan[];
  };

/**
 * The price of the subscription that will be billed, in US dollars.
 *
 * @example 20
 */
export type BillSubsApiPrice = number;

export type BillSubsApiRatePlan = {
  components?: BillSubsApiSchemasComponentValues;
  currency?: BillSubsApiCurrency;
  duration?: BillSubsApiDuration;
  frequency?: BillSubsApiSchemasFrequency;
  id?: BillSubsApiRatePlanComponentsSchemasIdentifier;
  name?: BillSubsApiSchemasName;
};

/**
 * Plan identifier tag.
 *
 * @example free
 */
export type BillSubsApiRatePlanComponentsSchemasIdentifier = string;

export type BillSubsApiResultInfo = {
  /**
   * Total number of results for the requested service
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters
   *
   * @example 2000
   */
  total_count?: number;
};

/**
 * Array of available components values for the plan.
 */
export type BillSubsApiSchemasComponentValues = BillSubsApiComponentValue[];

/**
 * The frequency at which you will be billed for this plan.
 *
 * @example monthly
 */
export type BillSubsApiSchemasFrequency =
  | "weekly"
  | "monthly"
  | "quarterly"
  | "yearly";

/**
 * Subscription identifier tag.
 *
 * @example 506e3185e9c882d175a2d0cb0093d9f2
 * @maxLength 32
 */
export type BillSubsApiSchemasIdentifier = string;

/**
 * The plan name.
 *
 * @example Free Plan
 * @maxLength 80
 */
export type BillSubsApiSchemasName = string;

/**
 * The amount you will be billed for this plan.
 *
 * @example 0
 */
export type BillSubsApiSchemasPrice = number;

export type BillSubsApiSchemasRatePlan = BillSubsApiRatePlan;

export type BillSubsApiSchemasZone = {
  name?: string;
};

/**
 * The state that the subscription is in.
 *
 * @example Paid
 */
export type BillSubsApiState =
  | "Trial"
  | "Provisioned"
  | "Paid"
  | "AwaitingPayment"
  | "Cancelled"
  | "Failed"
  | "Expired";

export type BillSubsApiSubscription = BillSubsApiSubscriptionV2;

export type BillSubsApiSubscriptionV2 = {
  app?: {
    install_id?: BillSubsApiInstallId;
  };
  component_values?: BillSubsApiComponentValues;
  currency?: BillSubsApiCurrency;
  current_period_end?: BillSubsApiCurrentPeriodEnd;
  current_period_start?: BillSubsApiCurrentPeriodStart;
  frequency?: BillSubsApiFrequency;
  id?: BillSubsApiSchemasIdentifier;
  price?: BillSubsApiPrice;
  rate_plan?: BillSubsApiRatePlan2;
  state?: BillSubsApiState;
  zone?: BillSubsApiZone;
};

/**
 * The billing item type.
 *
 * @example charge
 * @maxLength 30
 */
export type BillSubsApiType = string;

/**
 * The unit price of the addon.
 *
 * @example 1
 */
export type BillSubsApiUnitPrice = number;

export type BillSubsApiUserSubscriptionResponseCollection =
  BillSubsApiApiResponseCollection & {
    result?: BillSubsApiSubscription[];
  };

export type BillSubsApiUserSubscriptionResponseSingle =
  BillSubsApiApiResponseSingle & {
    result?: Record<string, any>;
  };

/**
 * A simple zone object. May have null properties if not a zone subscription.
 */
export type BillSubsApiZone = {
  id?: BillSubsApiIdentifier;
  name?: BillSubsApiName;
};

export type BillSubsApiZoneSubscriptionResponseSingle =
  BillSubsApiApiResponseSingle & {
    result?: BillSubsApiSubscription;
  };

/**
 * Enable rule to block AI Scrapers and Crawlers. Please note the value `only_on_ad_pages` is currently not available for Enterprise customers.
 *
 * @example block
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type BotManagementAiBotsProtection =
  | "block"
  | "disabled"
  | "only_on_ad_pages";

export type BotManagementApiResponseCommon = {
  errors: BotManagementMessages;
  messages: BotManagementMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type BotManagementApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: BotManagementMessages;
  messages: BotManagementMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type BotManagementApiResponseSingle = BotManagementApiResponseCommon;

/**
 * Automatically update to the newest bot detection models created by Cloudflare as they are released. [Learn more.](https://developers.cloudflare.com/bots/reference/machine-learning-models#model-versions-and-release-notes)
 *
 * @example true
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type BotManagementAutoUpdateModel = boolean;

export type BotManagementBaseConfig = {
  ai_bots_protection?: BotManagementAiBotsProtection;
  crawler_protection?: BotManagementCrawlerProtection;
  enable_js?: BotManagementEnableJs;
  using_latest_model?: BotManagementUsingLatestModel;
};

export type BotManagementBmSubscriptionConfig = BotManagementBaseConfig & {
  auto_update_model?: BotManagementAutoUpdateModel;
  /**
   * A read-only field that shows which unauthorized settings are currently active on the zone. These settings typically result from upgrades or downgrades.
   */
  stale_zone_configuration?: {
    fight_mode?: BotManagementFightModeTurnedOn;
    optimize_wordpress?: BotManagementOptimizeWordpressTurnedOn;
    sbfm_definitely_automated?: BotManagementSbfmDefinitelyAutomatedTurnedOn;
    sbfm_likely_automated?: BotManagementSbfmLikelyAutomatedTurnedOn;
    sbfm_static_resource_protection?: BotManagementSbfmStaticResourceProtectionTurnedOn;
    sbfm_verified_bots?: BotManagementSbfmVerifiedBotsTurnedOn;
  };
  suppress_session_score?: BotManagementSuppressSessionScore;
};

export type BotManagementBotFightModeConfig = BotManagementBaseConfig & {
  fight_mode?: BotManagementFightMode;
  /**
   * A read-only field that shows which unauthorized settings are currently active on the zone. These settings typically result from upgrades or downgrades.
   */
  stale_zone_configuration?: {
    optimize_wordpress?: BotManagementOptimizeWordpressTurnedOn;
    sbfm_definitely_automated?: BotManagementSbfmDefinitelyAutomatedTurnedOn;
    sbfm_likely_automated?: BotManagementSbfmLikelyAutomatedTurnedOn;
    sbfm_static_resource_protection?: BotManagementSbfmStaticResourceProtectionTurnedOn;
    sbfm_verified_bots?: BotManagementSbfmVerifiedBotsTurnedOn;
    suppress_session_score?: BotManagementSuppressSessionScoreTurnedOff;
  };
};

export type BotManagementBotManagementResponseBody =
  BotManagementApiResponseSingle & {
    result?:
      | BotManagementBotFightModeConfig
      | BotManagementSbfmDefinitelyConfig
      | BotManagementSbfmLikelyConfig
      | BotManagementBmSubscriptionConfig;
  };

export type BotManagementConfigSingle =
  | BotManagementBotFightModeConfig
  | BotManagementSbfmDefinitelyConfig
  | BotManagementSbfmLikelyConfig
  | BotManagementBmSubscriptionConfig;

/**
 * Enable rule to punish AI Scrapers and Crawlers via a link maze.
 *
 * @example enabled
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type BotManagementCrawlerProtection = "enabled" | "disabled";

/**
 * Use lightweight, invisible JavaScript detections to improve Bot Management. [Learn more about JavaScript Detections](https://developers.cloudflare.com/bots/reference/javascript-detections/).
 *
 * @example true
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type BotManagementEnableJs = boolean;

/**
 * Whether to enable Bot Fight Mode.
 *
 * @example true
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type BotManagementFightMode = boolean;

/**
 * Indicates that the zone's Bot Fight Mode is turned on.
 *
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type BotManagementFightModeTurnedOn = boolean;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type BotManagementIdentifier = string;

export type BotManagementMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * Whether to optimize Super Bot Fight Mode protections for Wordpress.
 *
 * @example true
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type BotManagementOptimizeWordpress = boolean;

/**
 * Indicates that the zone's wordpress optimization for SBFM is turned on.
 *
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type BotManagementOptimizeWordpressTurnedOn = boolean;

/**
 * Super Bot Fight Mode (SBFM) action to take on definitely automated requests.
 *
 * @example allow
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type BotManagementSbfmDefinitelyAutomated =
  | "allow"
  | "block"
  | "managed_challenge";

/**
 * Indicates that the zone's definitely automated requests are being blocked or challenged.
 *
 * @x-auditable true
 */
export type BotManagementSbfmDefinitelyAutomatedTurnedOn = string;

export type BotManagementSbfmDefinitelyConfig = BotManagementBaseConfig & {
  optimize_wordpress?: BotManagementOptimizeWordpress;
  sbfm_definitely_automated?: BotManagementSbfmDefinitelyAutomated;
  sbfm_static_resource_protection?: BotManagementSbfmStaticResourceProtection;
  sbfm_verified_bots?: BotManagementSbfmVerifiedBots;
  /**
   * A read-only field that shows which unauthorized settings are currently active on the zone. These settings typically result from upgrades or downgrades.
   */
  stale_zone_configuration?: {
    fight_mode?: BotManagementFightModeTurnedOn;
    sbfm_likely_automated?: BotManagementSbfmLikelyAutomatedTurnedOn;
  };
};

/**
 * Super Bot Fight Mode (SBFM) action to take on likely automated requests.
 *
 * @example allow
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type BotManagementSbfmLikelyAutomated =
  | "allow"
  | "block"
  | "managed_challenge";

/**
 * Indicates that the zone's likely automated requests are being blocked or challenged.
 *
 * @x-auditable true
 */
export type BotManagementSbfmLikelyAutomatedTurnedOn = string;

export type BotManagementSbfmLikelyConfig = BotManagementBaseConfig & {
  optimize_wordpress?: BotManagementOptimizeWordpress;
  sbfm_definitely_automated?: BotManagementSbfmDefinitelyAutomated;
  sbfm_likely_automated?: BotManagementSbfmLikelyAutomated;
  sbfm_static_resource_protection?: BotManagementSbfmStaticResourceProtection;
  sbfm_verified_bots?: BotManagementSbfmVerifiedBots;
  /**
   * A read-only field that shows which unauthorized settings are currently active on the zone. These settings typically result from upgrades or downgrades.
   */
  stale_zone_configuration?: {
    fight_mode?: BotManagementFightModeTurnedOn;
  };
};

/**
 * Super Bot Fight Mode (SBFM) to enable static resource protection.
 * Enable if static resources on your application need bot protection.
 * Note: Static resource protection can also result in legitimate traffic being blocked.
 *
 * @example true
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type BotManagementSbfmStaticResourceProtection = boolean;

/**
 * Indicates that the zone's static resource protection is turned on.
 *
 * @x-auditable true
 */
export type BotManagementSbfmStaticResourceProtectionTurnedOn = string;

/**
 * Super Bot Fight Mode (SBFM) action to take on verified bots requests.
 *
 * @example allow
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type BotManagementSbfmVerifiedBots = "allow" | "block";

/**
 * Indicates that the zone's verified bot requests are being blocked.
 *
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type BotManagementSbfmVerifiedBotsTurnedOn = string;

/**
 * Whether to disable tracking the highest bot score for a session in the Bot Management cookie.
 *
 * @default false
 * @example false
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type BotManagementSuppressSessionScore = boolean;

/**
 * Indicates that the zone's session score tracking is disabled.
 *
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type BotManagementSuppressSessionScoreTurnedOff = boolean;

/**
 * A read-only field that indicates whether the zone currently is running the latest ML model.
 *
 * @example true
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type BotManagementUsingLatestModel = boolean;

export type BrandProtectionApiError = {
  /**
   * Error code
   */
  code?: number;
  /**
   * Errors
   */
  errors?: {
    [key: string]: any;
  };
  /**
   * Error message
   */
  message?: string;
  /**
   * Error name
   */
  status?: string;
};

export type BrandProtectionApiImageFile = {
  /**
   * @format binary
   */
  image?: Blob;
};

export type BrandProtectionApiLogo = {
  id?: number;
  tag?: string;
  upload_path?: string;
};

export type BrandProtectionApiLogoMatch = {
  matches?: {
    [key: string]: any;
  }[];
  total?: number;
};

export type BrandProtectionApiPaginationMetadata = {
  first_page?: number;
  last_page?: number;
  next_page?: number;
  page?: number;
  previous_page?: number;
  total?: number;
  total_pages?: number;
};

export type BrandProtectionApiQuery = {
  /**
   * @format date-time
   */
  max_time?: string | null;
  /**
   * @format date-time
   */
  min_time?: string | null;
  scan?: boolean;
  string_matches?: void;
  tag?: string;
};

export type BrandProtectionApiQueryMatch = {
  matches?: {
    [key: string]: any;
  }[];
  total?: number;
};

export type BrandProtectionApiURLInfo = {
  result?: {
    [key: string]: any;
  }[];
};

export type BrandProtectionApiURLSubmit = {
  skipped_urls?: {
    [key: string]: any;
  }[];
  submitted_urls?: {
    [key: string]: any;
  }[];
};

export type CachePurgeEverything = {
  /**
   * For more information, please refer to [purge everything documentation page](https://developers.cloudflare.com/cache/how-to/purge-cache/purge-everything/).
   *
   * @example true
   * @x-auditable true
   */
  purge_everything?: boolean;
};

export type CachePurgeFlexPurgeByHostnames = {
  /**
   * For more information purging by hostnames, please refer to [purge by hostname documentation page](https://developers.cloudflare.com/cache/how-to/purge-cache/purge-by-hostname/).
   *
   * @example www.example.com
   * @example images.example.com
   */
  hosts?: string[];
};

export type CachePurgeFlexPurgeByPrefixes = {
  /**
   * For more information on purging by prefixes, please refer to [purge by prefix documentation page](https://developers.cloudflare.com/cache/how-to/purge-cache/purge_by_prefix/).
   *
   * @example www.example.com/foo
   * @example images.example.com/bar/baz
   */
  prefixes?: string[];
};

export type CachePurgeFlexPurgeByTags = {
  /**
   * For more information on cache tags and purging by tags, please refer to [purge by cache-tags documentation page](https://developers.cloudflare.com/cache/how-to/purge-cache/purge-by-tags/).
   *
   * @example a-cache-tag
   * @example another-cache-tag
   */
  tags?: string[];
};

export type CachePurgeSingleFile = {
  /**
   * For more information on purging files, please refer to [purge by single-file documentation page](https://developers.cloudflare.com/cache/how-to/purge-cache/purge-by-single-file/).
   *
   * @example http://www.example.com/css/styles.css
   * @example http://www.example.com/js/index.js
   */
  files?: string[];
};

export type CachePurgeSingleFileWithUrlAndHeaders = {
  /**
   * For more information on purging files with URL and headers, please refer to [purge by single-file documentation page](https://developers.cloudflare.com/cache/how-to/purge-cache/purge-by-single-file/).
   *
   * @example {"headers":{"Accept-Language":"zh-CN","CF-Device-Type":"desktop","CF-IPCountry":"US"},"url":"http://www.example.com/cat_picture.jpg"}
   * @example {"headers":{"Accept-Language":"en-US","CF-Device-Type":"mobile","CF-IPCountry":"EU"},"url":"http://www.example.com/dog_picture.jpg"}
   */
  files?: {
    /**
     * @example <HTTP header object>
     */
    headers?: {
      [key: string]: string;
    };
    /**
     * @example http://www.example.com/cat_picture.jpg
     * @x-auditable true
     */
    url?: string;
  }[];
};

export type CachePurgeApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: CachePurgeMessages;
  messages: CachePurgeMessages;
  result: Record<string, any> | null;
  /**
   * Indicates the API call's success or failure.
   *
   * @example false
   */
  success: boolean;
};

export type CachePurgeApiResponseSingleId = {
  errors: CachePurgeMessages;
  messages: CachePurgeMessages;
  result?: {
    id: CachePurgeIdentifier;
  } | null;
  /**
   * Indicates the API call's success or failure.
   *
   * @example true
   */
  success: boolean;
};

/**
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type CachePurgeIdentifier = string;

export type CachePurgeMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * Aegis provides dedicated egress IPs (from Cloudflare to your origin) for your layer 7 WAF and CDN services. The egress IPs are reserved exclusively for your account so that you can increase your origin security by only allowing traffic from a small list of IP addresses.
 */
export type CacheRulesAegis = {
  /**
   * ID of the zone setting.
   *
   * @x-auditable true
   * @example aegis
   */
  id: "aegis";
  /**
   * Last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string | null;
  value?: CacheRulesAegisValue;
};

export type CacheRulesAegisResponseValue = {
  result?: CacheRulesAegis;
};

/**
 * Value of the zone setting.
 */
export type CacheRulesAegisValue = {
  /**
   * Whether the feature is enabled or not.
   *
   * @x-auditable true
   */
  enabled?: boolean;
  /**
   * Egress pool id which refers to a grouping of dedicated egress IPs through which Cloudflare will connect to origin.
   *
   * @example pool-id
   * @x-auditable true
   */
  pool_id?: string;
};

export type CacheRulesApiResponseCommon = {
  errors: CacheRulesMessages;
  messages: CacheRulesMessages;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type CacheRulesApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: CacheRulesMessages;
  messages: CacheRulesMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

export type CacheRulesBase = {
  /**
   * Identifier of the zone setting.
   *
   * @x-auditable true
   */
  id: string;
  /**
   * Last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string | null;
};

/**
 * Increase cache lifetimes by automatically storing all cacheable files into Cloudflare's persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve) for more information.
 */
export type CacheRulesCacheReserve = {
  /**
   * ID of the zone setting.
   *
   * @x-auditable true
   * @example cache_reserve
   */
  id: "cache_reserve";
  /**
   * Last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string | null;
};

/**
 * You can use Cache Reserve Clear to clear your Cache Reserve, but you must first disable Cache Reserve. In most cases, this will be accomplished within 24 hours. You cannot re-enable Cache Reserve while this process is ongoing. Keep in mind that you cannot undo or cancel this operation.
 */
export type CacheRulesCacheReserveClear = {
  /**
   * ID of the zone setting.
   *
   * @x-auditable true
   * @example cache_reserve_clear
   */
  id: "cache_reserve_clear";
  /**
   * Last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string | null;
};

/**
 * The time that the latest Cache Reserve Clear operation completed.
 *
 * @example 2023-10-02T12:00:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type CacheRulesCacheReserveClearEndTs = string;

export type CacheRulesCacheReserveClearResponseValue = {
  /**
   * You can use Cache Reserve Clear to clear your Cache Reserve, but you must first disable Cache Reserve. In most cases, this will be accomplished within 24 hours. You cannot re-enable Cache Reserve while this process is ongoing. Keep in mind that you cannot undo or cancel this operation.
   */
  result?: CacheRulesCacheReserveClear & {
    end_ts?: CacheRulesCacheReserveClearEndTs;
    start_ts: CacheRulesCacheReserveClearStartTs;
    state: CacheRulesCacheReserveClearState;
  };
};

/**
 * The time that the latest Cache Reserve Clear operation started.
 *
 * @example 2023-10-02T10:00:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type CacheRulesCacheReserveClearStartTs = string;

/**
 * The current state of the Cache Reserve Clear operation.
 *
 * @example In-progress
 * @x-auditable true
 */
export type CacheRulesCacheReserveClearState = "In-progress" | "Completed";

export type CacheRulesCacheReserveResponseValue = {
  /**
   * Increase cache lifetimes by automatically storing all cacheable files into Cloudflare's persistent object storage buckets. Requires Cache Reserve subscription. Note: using Tiered Cache with Cache Reserve is highly recommended to reduce Reserve operations costs. See the [developer docs](https://developers.cloudflare.com/cache/about/cache-reserve) for more information.
   */
  result?: CacheRulesCacheReserve & {
    value: CacheRulesCacheReserveValue;
  };
};

/**
 * Value of the Cache Reserve zone setting.
 *
 * @default off
 * @x-auditable true
 */
export type CacheRulesCacheReserveValue = "on" | "off";

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type CacheRulesIdentifier = string;

export type CacheRulesMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * Origin H2 Max Streams configures the max number of concurrent requests that Cloudflare will send within the same connection when communicating with the origin server, if the origin supports it. Note that if your origin does not support H2 multiplexing, 5xx errors may be observed, particularly 520s. Also note that the default value is `100` for all plan types except Enterprise where it is `1`. `1` means that H2 multiplexing is disabled.
 */
export type CacheRulesOriginH2MaxStreams = {
  /**
   * Value of the zone setting.
   *
   * @x-auditable true
   * @example origin_h2_max_streams
   */
  id: "origin_h2_max_streams";
  /**
   * Last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string | null;
  value?: CacheRulesOriginH2MaxStreamsValue;
};

export type CacheRulesOriginH2MaxStreamsResponseValue = {
  result?: CacheRulesOriginH2MaxStreams;
};

/**
 * Value of the Origin H2 Max Streams Setting.
 *
 * @example 50
 * @maximum 1000
 * @minimum 1
 * @x-auditable true
 */
export type CacheRulesOriginH2MaxStreamsValue = number;

/**
 * Origin Max HTTP Setting Version sets the highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to [Enable HTTP/2 to Origin](https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/), for more information.). The default value is "2" for all plan types except Enterprise where it is "1"
 */
export type CacheRulesOriginMaxHttpVersion = {
  /**
   * Value of the zone setting.
   *
   * @x-auditable true
   * @example origin_max_http_version
   */
  id: "origin_max_http_version";
  /**
   * Last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string | null;
  value?: CacheRulesOriginMaxHttpVersionValue;
};

export type CacheRulesOriginMaxHttpVersionResponseValue = {
  result?: CacheRulesOriginMaxHttpVersion;
};

/**
 * Value of the Origin Max HTTP Version Setting.
 *
 * @x-auditable true
 */
export type CacheRulesOriginMaxHttpVersionValue = "2" | "1";

/**
 * Instructs Cloudflare to use Post-Quantum (PQ) key agreement algorithms when connecting to your origin. Preferred instructs Cloudflare to opportunistically send a Post-Quantum keyshare in the first message to the origin (for fastest connections when the origin supports and prefers PQ), supported means that PQ algorithms are advertised but only used when requested by the origin, and off means that PQ algorithms are not advertised
 */
export type CacheRulesOriginPostQuantumEncryption = {
  /**
   * Value of the zone setting.
   *
   * @x-auditable true
   * @example origin_pqe
   */
  id: "origin_pqe";
  /**
   * Last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string | null;
};

export type CacheRulesOriginPostQuantumEncryptionResponseValue = {
  /**
   * Instructs Cloudflare to use Post-Quantum (PQ) key agreement algorithms when connecting to your origin. Preferred instructs Cloudflare to opportunistically send a Post-Quantum keyshare in the first message to the origin (for fastest connections when the origin supports and prefers PQ), supported means that PQ algorithms are advertised but only used when requested by the origin, and off means that PQ algorithms are not advertised
   */
  result?: CacheRulesOriginPostQuantumEncryption & {
    value: CacheRulesOriginPostQuantumEncryptionValue;
  };
};

/**
 * Value of the Origin Post Quantum Encryption Setting.
 *
 * @default supported
 * @x-auditable true
 */
export type CacheRulesOriginPostQuantumEncryptionValue =
  | "preferred"
  | "supported"
  | "off";

/**
 * Update enablement of Tiered Caching
 */
export type CacheRulesPatch = {
  value: CacheRulesValue;
};

/**
 * Instructs Cloudflare to check a regional hub data center on the way to your upper tier. This can help improve performance for smart and custom tiered cache topologies.
 */
export type CacheRulesRegionalTieredCache = {
  /**
   * ID of the zone setting.
   *
   * @x-auditable true
   * @example tc_regional
   */
  id: "tc_regional";
  /**
   * Last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string | null;
};

export type CacheRulesRegionalTieredCacheResponseValue = {
  /**
   * Instructs Cloudflare to check a regional hub data center on the way to your upper tier. This can help improve performance for smart and custom tiered cache topologies.
   */
  result?: CacheRulesRegionalTieredCache & {
    value: CacheRulesRegionalTieredCacheValue;
  };
};

/**
 * Value of the Regional Tiered Cache zone setting.
 *
 * @default off
 * @x-auditable true
 */
export type CacheRulesRegionalTieredCacheValue = "on" | "off";

export type CacheRulesResultObject = {
  /**
   * Whether the setting is editable
   *
   * @x-auditable true
   */
  editable: boolean;
  /**
   * The identifier of the caching setting
   *
   * @x-auditable true
   */
  id: string;
  /**
   * The time when the setting was last modified
   *
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string;
  /**
   * The value of the feature
   *
   * @x-auditable true
   */
  value: string;
};

export type CacheRulesResultObjectComplex = {
  /**
   * Whether the setting is editable
   *
   * @x-auditable true
   */
  editable: boolean;
  /**
   * The identifier of the caching setting
   *
   * @x-auditable true
   */
  id: string;
  /**
   * The time when the setting was last modified
   *
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string;
  /**
   * The value of the feature
   *
   * @x-auditable true
   */
  value: Record<string, any>;
};

export type CacheRulesResultObjectDelete = {
  /**
   * Whether the setting is editable
   *
   * @x-auditable true
   */
  editable: boolean;
  /**
   * The identifier of the caching setting
   *
   * @x-auditable true
   */
  id: string;
  /**
   * The time when the setting was last modified
   *
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string;
};

export type CacheRulesSmartTieredCache = {
  /**
   * ID of the zone setting.
   *
   * @x-auditable true
   * @example tiered_cache_smart_topology_enable
   */
  id: "tiered_cache_smart_topology_enable";
  /**
   * Last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string | null;
};

/**
 * Update enablement of Smart Tiered Cache
 */
export type CacheRulesSmartTieredCachePatch = {
  /**
   * Enable or disable the Smart Tiered Cache
   *
   * @example on
   * @x-auditable true
   */
  value: "on" | "off";
};

export type CacheRulesSmartTieredCacheResponseValue = {
  result?: CacheRulesSmartTieredCache & {
    value: CacheRulesSmartTieredCacheValue;
  };
};

/**
 * Value of the Smart Tiered Cache zone setting.
 *
 * @default off
 * @x-auditable true
 */
export type CacheRulesSmartTieredCacheValue = "on" | "off";

export type CacheRulesTieredCache = {
  /**
   * ID of the zone setting.
   *
   * @x-auditable true
   * @example tiered_caching
   */
  id: "tiered_caching";
  /**
   * Last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string | null;
};

export type CacheRulesTieredCacheResponseValue = {
  result?: CacheRulesTieredCache & {
    value: CacheRulesTieredCacheValue;
  };
};

/**
 * Value of the Tiered Cache zone setting.
 *
 * @default off
 * @x-auditable true
 */
export type CacheRulesTieredCacheValue = "on" | "off";

/**
 * Enables Tiered Caching.
 *
 * @example on
 * @x-auditable true
 */
export type CacheRulesValue = "on" | "off";

/**
 * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
 */
export type CacheRulesVariants = {
  /**
   * ID of the zone setting.
   *
   * @x-auditable true
   * @example variants
   */
  id: "variants";
  /**
   * Last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string | null;
};

export type CacheRulesVariantsResponseValue = {
  /**
   * Variant support enables caching variants of images with certain file extensions in addition to the original. This only applies when the origin server sends the 'Vary: Accept' response header. If the origin server sends 'Vary: Accept' but does not serve the variant requested, the response will not be cached. This will be indicated with BYPASS cache status in the response headers.
   */
  result?: CacheRulesVariants & {
    value: CacheRulesVariantsValue;
  };
};

/**
 * Value of the zone setting.
 */
export type CacheRulesVariantsValue = {
  /**
   * List of strings with the MIME types of all the variants that should be served for avif.
   *
   * @example image/webp
   * @example image/jpeg
   * @uniqueItems true
   */
  avif?: string[];
  /**
   * List of strings with the MIME types of all the variants that should be served for bmp.
   *
   * @example image/webp
   * @example image/jpeg
   * @uniqueItems true
   */
  bmp?: string[];
  /**
   * List of strings with the MIME types of all the variants that should be served for gif.
   *
   * @example image/webp
   * @example image/jpeg
   * @uniqueItems true
   */
  gif?: string[];
  /**
   * List of strings with the MIME types of all the variants that should be served for jp2.
   *
   * @example image/webp
   * @example image/avif
   * @uniqueItems true
   */
  jp2?: string[];
  /**
   * List of strings with the MIME types of all the variants that should be served for jpeg.
   *
   * @example image/webp
   * @example image/avif
   * @uniqueItems true
   */
  jpeg?: string[];
  /**
   * List of strings with the MIME types of all the variants that should be served for jpg.
   *
   * @example image/webp
   * @example image/avif
   * @uniqueItems true
   */
  jpg?: string[];
  /**
   * List of strings with the MIME types of all the variants that should be served for jpg2.
   *
   * @example image/webp
   * @example image/avif
   * @uniqueItems true
   */
  jpg2?: string[];
  /**
   * List of strings with the MIME types of all the variants that should be served for png.
   *
   * @example image/webp
   * @example image/avif
   * @uniqueItems true
   */
  png?: string[];
  /**
   * List of strings with the MIME types of all the variants that should be served for tif.
   *
   * @example image/webp
   * @example image/avif
   * @uniqueItems true
   */
  tif?: string[];
  /**
   * List of strings with the MIME types of all the variants that should be served for tiff.
   *
   * @example image/webp
   * @example image/avif
   * @uniqueItems true
   */
  tiff?: string[];
  /**
   * List of strings with the MIME types of all the variants that should be served for webp.
   *
   * @example image/jpeg
   * @example image/avif
   * @uniqueItems true
   */
  webp?: string[];
};

export type CacheRulesZoneCacheSettingsDeleteResponseSingle =
  CacheRulesApiResponseCommon & {
    result?: CacheRulesResultObjectDelete;
  };

export type CacheRulesZoneCacheSettingsResponseSingle =
  CacheRulesApiResponseCommon & {
    result?: CacheRulesResultObject;
  };

export type CacheRulesZoneComplexCacheSettingsResponseSingle =
  CacheRulesApiResponseCommon & {
    result?: CacheRulesResultObjectComplex;
  };

export type CacheApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: CacheMessages;
  messages: CacheMessages;
  result: CacheResult;
  /**
   * Indicates the API call's success or failure.
   *
   * @example false
   */
  success: boolean;
};

export type CacheApiResponseSingleId = {
  errors: CacheMessages;
  messages: CacheMessages;
  result: CacheResult;
  /**
   * Indicates the API call's success or failure.
   *
   * @example true
   */
  success: boolean;
};

/**
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type CacheIdentifier = string;

export type CacheMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

export type CacheResult = {
  /**
   * Whether this setting can be updated or not.
   */
  editable: boolean;
  /**
   * @example ssl_automatic_mode
   */
  id: string;
  /**
   * Last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on: string;
  /**
   * Next time this zone will be scanned by the Automatic SSL/TLS.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  next_scheduled_scan?: string | null;
  /**
   * Current setting of the automatic SSL/TLS.
   *
   * @example auto
   */
  value: "auto" | "custom";
};

/**
 * Update enablement of Automatic SSL/TLS.
 */
export type CacheSchemasPatch = {
  value: CacheSchemasValue;
};

/**
 * Controls enablement of Automatic SSL/TLS.
 *
 * @example auto
 */
export type CacheSchemasValue = "auto" | "custom";

/**
 * The account identifier tag.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type CallsAccountIdentifier = string;

export type CallsApiResponseCommon = {
  errors: CallsMessages;
  messages: CallsMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type CallsApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: CallsMessages;
  messages: CallsMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type CallsApiResponseSingle = CallsApiResponseCommon;

export type CallsApp = {
  created?: CallsCreated;
  modified?: CallsModified;
  name?: CallsName;
  uid?: CallsIdentifier;
};

export type CallsAppEditableFields = {
  name?: CallsName;
};

export type CallsAppResponseCollection = CallsApiResponseCommon & {
  result?: CallsApp[];
};

export type CallsAppResponseSingle = CallsApiResponseSingle & {
  result?: CallsApp;
};

export type CallsAppResponseSingleWithSecret = CallsApiResponseSingle & {
  result?: CallsAppWithSecret;
};

export type CallsAppWithSecret = {
  created?: CallsCreated;
  modified?: CallsModified;
  name?: CallsName;
  secret?: CallsSecret;
  uid?: CallsIdentifier;
};

/**
 * The date and time the item was created.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 */
export type CallsCreated = string;

/**
 * A Cloudflare-generated unique identifier for a item.
 *
 * @example 2a95132c15732412d22c1476fa83f27a
 * @maxLength 32
 * @minLength 32
 * @x-auditable true
 */
export type CallsIdentifier = string;

export type CallsMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * The date and time the item was last modified.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 */
export type CallsModified = string;

/**
 * A short description of Calls app, not shown to end users.
 *
 * @default
 * @example production-realtime-app
 * @x-auditable true
 */
export type CallsName = string;

/**
 * Bearer token
 *
 * @example 66bcf64aa8907b9f9d90ac17746a77ce394c393b92b3916633dc02846e608ad4
 * @maxLength 64
 * @minLength 64
 * @x-sensitive true
 */
export type CallsSecret = string;

/**
 * Bearer token
 *
 * @example 66bcf64aa8907b9f9d90ac17746a77ce394c393b92b3916633dc02846e608ad4
 * @maxLength 64
 * @minLength 64
 * @x-sensitive true
 */
export type CallsTurnKey = string;

export type CallsTurnKeyCollection = CallsApiResponseCommon & {
  result?: CallsTurnKeyObject[];
};

export type CallsTurnKeyEditableFields = {
  name?: CallsTurnKeyName;
};

/**
 * A short description of a TURN key, not shown to end users.
 *
 * @default
 * @example my-turn-key
 * @x-auditable true
 */
export type CallsTurnKeyName = string;

export type CallsTurnKeyObject = {
  created?: CallsCreated;
  modified?: CallsModified;
  name?: CallsName;
  uid?: CallsIdentifier;
};

export type CallsTurnKeyResponseCollection = CallsApiResponseCommon & {
  result?: CallsTurnKeyObject[];
};

export type CallsTurnKeyResponseSingle = CallsApiResponseSingle & {
  result?: CallsTurnKeyObject;
};

export type CallsTurnKeySingleWithSecret = CallsApiResponseSingle & {
  result?: CallsTurnKeyWithKey;
};

export type CallsTurnKeyWithKey = {
  created?: CallsCreated;
  key?: CallsTurnKey;
  modified?: CallsModified;
  name?: CallsTurnKeyName;
  uid?: CallsIdentifier;
};

export type CloudConnectorApiResponseCommon = {
  errors: CloudConnectorMessages;
  messages: CloudConnectorMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type CloudConnectorApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: CloudConnectorMessages;
  messages: CloudConnectorMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type CloudConnectorIdentifier = string;

export type CloudConnectorMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * Cloud Provider type
 *
 * @example aws_s3
 * @x-auditable true
 */
export type CloudConnectorProvider =
  | "aws_s3"
  | "cloudflare_r2"
  | "gcp_storage"
  | "azure_storage";

export type CloudConnectorRule = {
  /**
   * @example Rule description
   * @x-auditable true
   */
  description?: string;
  /**
   * @example true
   * @x-auditable true
   */
  enabled?: boolean;
  /**
   * @example http.cookie eq "a=b"
   * @x-auditable true
   */
  expression?: string;
  /**
   * @example 95c365e17e1b46599cd99e5b231fac4e
   * @x-auditable true
   */
  id?: string;
  /**
   * Parameters of Cloud Connector Rule
   */
  parameters?: {
    /**
     * Host to perform Cloud Connection to
     *
     * @example examplebucket.s3.eu-north-1.amazonaws.com
     * @x-auditable true
     */
    host?: string;
  };
  provider?: CloudConnectorProvider;
};

/**
 * List of Cloud Connector rules
 */
export type CloudConnectorRules = CloudConnectorRule[];

export type CloudConnectorZoneIdentifier = CloudConnectorIdentifier;

/**
 * Indicates whether the API call was successful.
 *
 * @example true
 */
export type CloudflarePipelinesWorkerPipelinesCommonSuccess = boolean;

/**
 * Specifies the public ID of the account.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 */
export type CloudflarePipelinesWorkersPipelinesAccountId = string;

/**
 * Describes the configuration of a pipeline.
 */
export type CloudflarePipelinesWorkersPipelinesPipeline = {
  destination: {
    batch: {
      /**
       * Specifies rough maximum size of files.
       *
       * @default 100000000
       * @maximum 100000000
       * @minimum 1000
       */
      max_bytes: number;
      /**
       * Specifies duration to wait to aggregate batches files.
       *
       * @default 300
       * @maximum 300
       * @minimum 0.25
       */
      max_duration_s: number;
      /**
       * Specifies rough maximum number of rows per file.
       *
       * @default 10000000
       * @maximum 10000000
       * @minimum 100
       */
      max_rows: number;
    };
    compression: {
      /**
       * Specifies the desired compression algorithm and format.
       *
       * @default gzip
       * @example gzip
       */
      type: "none" | "gzip" | "deflate";
    };
    /**
     * Specifies the format of data to deliver.
     */
    format: "json";
    /**
     * @example {"bucket":"bucket","prefix":"base"}
     */
    path: {
      /**
       * Specifies the R2 Bucket to store files.
       *
       * @example bucket
       */
      bucket: string;
      /**
       * Specifies the name pattern to for individual data files.
       *
       * @example ${slug}${extension}
       */
      filename?: string;
      /**
       * Specifies the name pattern for directory.
       *
       * @example ${date}/${hour}
       */
      filepath?: string;
      /**
       * Specifies the base directory within the bucket.
       *
       * @example base
       */
      prefix?: string;
    };
    /**
     * Specifies the type of destination.
     */
    type: "r2";
  };
  /**
   * Indicates the endpoint URL to send traffic.
   *
   * @example https://123f8a8258064ed892a347f173372359.pipelines.cloudflare.com
   */
  endpoint: string;
  /**
   * Specifies the pipeline identifier.
   *
   * @example 123f8a8258064ed892a347f173372359
   */
  id: string;
  /**
   * Defines the name of the pipeline.
   *
   * @example sample_pipeline
   * @maxLength 128
   * @minLength 1
   */
  name: string;
  /**
   * @minItems 1
   */
  source: (
    | (Omit<CloudflarePipelinesWorkersPipelinesHttpSource, "type"> & {
        type: "http";
      })
    | (Omit<CloudflarePipelinesWorkersPipelinesBindingSource, "type"> & {
        type: "binding";
      })
  )[];
  /**
   * Indicates the version number of last saved configuration.
   *
   * @example 2
   */
  version: number;
};

export type CloudflarePipelinesWorkersPipelinesBindingSource = {
  /**
   * Specifies the format of source data.
   */
  format: "json";
  type: string;
};

export type CloudflarePipelinesWorkersPipelinesHttpSource = {
  /**
   * Specifies whether authentication is required to send to this pipeline via HTTP.
   */
  authentication?: boolean;
  cors?: {
    /**
     * Specifies allowed origins to allow Cross Origin HTTP Requests.
     *
     * @example *
     * @maxItems 5
     */
    origins?: (string | string)[];
  };
  /**
   * Specifies the format of source data.
   */
  format: "json";
  type: string;
};

export type CloudforceOnePortScanApiApiResponseCommon = {
  errors: CloudforceOnePortScanApiMessages;
  messages: CloudforceOnePortScanApiMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type CloudforceOnePortScanApiApiResponseCommonFailure = {
  /**
   * @example {"code":10433,"message":"request error"}
   */
  errors: CloudforceOnePortScanApiMessages;
  messages: CloudforceOnePortScanApiMessages;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: true;
};

/**
 * Defines the number of days between each scan (0 = One-off scan).
 *
 * @example 7
 */
export type CloudforceOnePortScanApiFrequency = number;

/**
 * Defines a list of IP addresses or CIDR blocks to scan. The maximum number of total IP addresses allowed is 5000.
 *
 * @example 1.1.1.1
 * @example 2606:4700:4700::1111
 */
export type CloudforceOnePortScanApiIps = string[];

export type CloudforceOnePortScanApiMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

export type CloudforceOnePortScanApiPort = {
  /**
   * @example 8080
   */
  number?: number;
  /**
   * @example tcp
   */
  proto?: string;
  /**
   * @example open
   */
  status?: string;
};

/**
 * Defines a list of ports to scan. Valid values are:"default", "all", or a comma-separated list of ports or range of ports (e.g. ["1-80", "443"]). "default" scans the 100 most commonly open ports.
 *
 * @example default
 */
export type CloudforceOnePortScanApiPorts = string[];

export type CloudforceOnePortScanApiScanConfig = {
  /**
   * @example abcd1234abcd1234abcd1234abcd1234
   */
  account_id: string;
  frequency: CloudforceOnePortScanApiFrequency;
  /**
   * Defines the Config ID.
   *
   * @example uuid
   */
  id: string;
  ips: CloudforceOnePortScanApiIps;
  ports: CloudforceOnePortScanApiPorts;
};

export type CloudforceOneRequestsApiResponseCommon = {
  errors: CloudforceOneRequestsMessages;
  messages: CloudforceOneRequestsMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type CloudforceOneRequestsApiResponseCommonFailure = {
  errors: CloudforceOneRequestsMessages;
  messages: CloudforceOneRequestsMessages;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: true;
};

/**
 * Asset file to upload.
 *
 * @example @/Users/me/example.docx
 */
export type CloudforceOneRequestsAssetContent = string;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type CloudforceOneRequestsIdentifier = string;

/**
 * List of labels.
 *
 * @example DoS
 * @example CVE
 * @x-auditable true
 */
export type CloudforceOneRequestsLabels = string[];

/**
 * Content of message.
 *
 * @example Can you elaborate on the type of DoS that occurred?
 * @x-auditable true
 */
export type CloudforceOneRequestsMessageContent = string;

export type CloudforceOneRequestsMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * @x-auditable true
 */
export type CloudforceOneRequestsPriority = "routine" | "high" | "urgent";

export type CloudforceOneRequestsPriorityEdit = {
  labels: CloudforceOneRequestsLabels;
  /**
   * Priority.
   *
   * @example 1
   * @x-auditable true
   */
  priority: number;
  /**
   * Requirement.
   *
   * @example DoS attacks carried out by CVEs
   * @x-auditable true
   */
  requirement: string;
  tlp: CloudforceOneRequestsTlp;
};

export type CloudforceOneRequestsPriorityItem = {
  /**
   * Priority creation time.
   *
   * @example 2022-04-01T05:20:00Z
   * @format date-time
   * @x-auditable true
   */
  created: CloudforceOneRequestsTime;
  id: CloudforceOneRequestsUuid;
  labels: CloudforceOneRequestsLabels;
  /**
   * Priority.
   *
   * @example 1
   * @x-auditable true
   */
  priority: number;
  /**
   * Requirement.
   *
   * @example DoS attacks carried out by CVEs
   * @x-auditable true
   */
  requirement: string;
  tlp: CloudforceOneRequestsTlp;
  /**
   * Priority last updated time.
   *
   * @example 2022-04-01T05:20:00Z
   * @format date-time
   * @x-auditable true
   */
  updated: CloudforceOneRequestsTime;
};

export type CloudforceOneRequestsPriorityList = {
  /**
   * Page number of results.
   */
  page: number;
  /**
   * Number of results per page.
   *
   * @example 10
   */
  per_page: number;
};

export type CloudforceOneRequestsQuota = {
  /**
   * Anniversary date is when annual quota limit is refreshed.
   *
   * @example 2022-04-01T05:20:00Z
   * @format date-time
   * @x-auditable true
   */
  anniversary_date?: CloudforceOneRequestsTime;
  /**
   * Quarter anniversary date is when quota limit is refreshed each quarter.
   *
   * @example 2022-04-01T05:20:00Z
   * @format date-time
   * @x-auditable true
   */
  quarter_anniversary_date?: CloudforceOneRequestsTime;
  /**
   * Tokens for the quarter.
   *
   * @example 120
   * @x-auditable true
   */
  quota?: number;
  /**
   * Tokens remaining for the quarter.
   *
   * @example 64
   * @x-auditable true
   */
  remaining?: number;
};

export type CloudforceOneRequestsRequestAssetEdit = {
  source?: CloudforceOneRequestsAssetContent;
};

export type CloudforceOneRequestsRequestAssetItem = {
  /**
   * Defines the asset creation time.
   *
   * @example 2022-04-01T05:20:00Z
   * @format date-time
   * @x-auditable true
   */
  created?: CloudforceOneRequestsTime;
  /**
   * Asset description.
   *
   * @example example description
   * @x-auditable true
   */
  description?: string;
  /**
   * Asset file type.
   *
   * @example docx
   * @x-auditable true
   */
  file_type?: string;
  /**
   * Asset ID.
   *
   * @x-auditable true
   */
  id: number;
  /**
   * Asset name.
   *
   * @example example.docx
   * @x-auditable true
   */
  name: string;
};

export type CloudforceOneRequestsRequestAssetList = {
  /**
   * Page number of results.
   */
  page: number;
  /**
   * Number of results per page.
   *
   * @example 10
   */
  per_page: number;
};

export type CloudforceOneRequestsRequestConstants = {
  /**
   * @example routine
   * @example high
   * @example urgent
   */
  priority?: CloudforceOneRequestsPriority[];
  /**
   * @example open
   * @example accepted
   * @example reported
   * @example approved
   * @example completed
   * @example declined
   */
  status?: CloudforceOneRequestsRequestStatus[];
  /**
   * @example clear
   * @example green
   * @example amber
   * @example amber-strict
   * @example red
   */
  tlp?: CloudforceOneRequestsTlp[];
};

/**
 * Request content.
 *
 * @example What regions were most effected by the recent DoS?
 */
export type CloudforceOneRequestsRequestContent = string;

export type CloudforceOneRequestsRequestEdit = {
  content?: CloudforceOneRequestsRequestContent;
  /**
   * Priority for analyzing the request.
   *
   * @example routine
   * @x-auditable true
   */
  priority?: string;
  request_type?: CloudforceOneRequestsRequestType;
  summary?: CloudforceOneRequestsRequestSummary;
  tlp?: CloudforceOneRequestsTlp;
};

export type CloudforceOneRequestsRequestItem = {
  completed?: CloudforceOneRequestsTime;
  content: CloudforceOneRequestsRequestContent;
  created: CloudforceOneRequestsTime;
  id: CloudforceOneRequestsUuid;
  /**
   * Tokens for the request messages.
   *
   * @example 1
   * @x-auditable true
   */
  message_tokens?: number;
  priority: CloudforceOneRequestsTime;
  readable_id?: CloudforceOneRequestsRequestReadableId;
  request: CloudforceOneRequestsRequestType;
  status?: CloudforceOneRequestsRequestStatus;
  summary: CloudforceOneRequestsRequestSummary;
  tlp: CloudforceOneRequestsTlp;
  /**
   * Tokens for the request.
   *
   * @example 16
   * @x-auditable true
   */
  tokens?: number;
  updated: CloudforceOneRequestsTime;
};

export type CloudforceOneRequestsRequestList = {
  /**
   * Retrieve requests completed after this time.
   *
   * @example 2022-04-01T05:20:00Z
   * @format date-time
   * @x-auditable true
   */
  completed_after?: CloudforceOneRequestsTime;
  /**
   * Retrieve requests completed before this time.
   *
   * @example 2022-04-01T05:20:00Z
   * @format date-time
   * @x-auditable true
   */
  completed_before?: CloudforceOneRequestsTime;
  /**
   * Retrieve requests created after this time.
   *
   * @example 2022-04-01T05:20:00Z
   * @format date-time
   * @x-auditable true
   */
  created_after?: CloudforceOneRequestsTime;
  /**
   * Retrieve requests created before this time.
   *
   * @example 2022-04-01T05:20:00Z
   * @format date-time
   * @x-auditable true
   */
  created_before?: CloudforceOneRequestsTime;
  /**
   * Page number of results.
   */
  page: number;
  /**
   * Number of results per page.
   *
   * @example 10
   */
  per_page: number;
  request_type?: CloudforceOneRequestsRequestType;
  /**
   * Field to sort results by.
   *
   * @example created
   */
  sort_by?: string;
  /**
   * Sort order (asc or desc).
   */
  sort_order?: "asc" | "desc";
  status?: CloudforceOneRequestsRequestStatus;
};

export type CloudforceOneRequestsRequestListItem = {
  /**
   * Request completion time.
   *
   * @example 2022-04-01T05:20:00Z
   * @format date-time
   * @x-auditable true
   */
  completed?: CloudforceOneRequestsTime;
  /**
   * Request creation time.
   *
   * @example 2022-04-01T05:20:00Z
   * @format date-time
   * @x-auditable true
   */
  created: CloudforceOneRequestsTime;
  id: CloudforceOneRequestsUuid;
  /**
   * Tokens for the request messages.
   *
   * @example 16
   * @x-auditable true
   */
  message_tokens?: number;
  priority: CloudforceOneRequestsPriority;
  readable_id?: CloudforceOneRequestsRequestReadableId;
  request: CloudforceOneRequestsRequestType;
  status?: CloudforceOneRequestsRequestStatus;
  summary: CloudforceOneRequestsRequestSummary;
  tlp: CloudforceOneRequestsTlp;
  /**
   * Tokens for the request.
   *
   * @x-auditable true
   */
  tokens?: number;
  /**
   * Request last updated time.
   *
   * @example 2022-04-01T05:20:00Z
   * @format date-time
   * @x-auditable true
   */
  updated: CloudforceOneRequestsTime;
};

export type CloudforceOneRequestsRequestMessageEdit = {
  content?: CloudforceOneRequestsMessageContent;
};

export type CloudforceOneRequestsRequestMessageItem = {
  /**
   * Author of message.
   *
   * @example user@domain.com
   * @x-auditable true
   */
  author: string;
  content: CloudforceOneRequestsMessageContent;
  /**
   * Defines the message creation time.
   *
   * @example 2022-04-01T05:20:00Z
   * @format date-time
   * @x-auditable true
   */
  created?: CloudforceOneRequestsTime;
  /**
   * Message ID.
   *
   * @x-auditable true
   */
  id: number;
  /**
   * Whether the message is a follow-on request.
   *
   * @x-auditable true
   */
  is_follow_on_request: boolean;
  /**
   * Defines the message last updated time.
   *
   * @example 2022-04-01T05:20:00Z
   * @format date-time
   * @x-auditable true
   */
  updated: CloudforceOneRequestsTime;
};

export type CloudforceOneRequestsRequestMessageList = {
  /**
   * Retrieve mes  ges created after this time.
   *
   * @example 2022-04-01T05:20:00Z
   * @format date-time
   * @x-auditable true
   */
  after?: CloudforceOneRequestsTime;
  /**
   * Retrieve messages created before this time.
   *
   * @example 2022-04-01T05:20:00Z
   * @format date-time
   * @x-auditable true
   */
  before?: CloudforceOneRequestsTime;
  /**
   * Page number of results.
   */
  page: number;
  /**
   * Number of results per page.
   *
   * @example 10
   */
  per_page: number;
  /**
   * Field to sort results by.
   *
   * @example created
   */
  sort_by?: string;
  /**
   * Sort order (asc or desc).
   */
  sort_order?: "asc" | "desc";
};

/**
 * Readable Request ID.
 *
 * @example RFI-2022-000001
 * @x-auditable true
 */
export type CloudforceOneRequestsRequestReadableId = string;

/**
 * Request Status.
 *
 * @x-auditable true
 */
export type CloudforceOneRequestsRequestStatus =
  | "open"
  | "accepted"
  | "reported"
  | "approved"
  | "completed"
  | "declined";

/**
 * Brief description of the request.
 *
 * @example DoS attack
 * @x-auditable true
 */
export type CloudforceOneRequestsRequestSummary = string;

/**
 * Requested information from request.
 *
 * @example Victomology
 * @x-auditable true
 */
export type CloudforceOneRequestsRequestType = string;

/**
 * @example Indicators of Compromise
 * @example Victomology
 */
export type CloudforceOneRequestsRequestTypes = string[];

/**
 * @example 2022-04-01T05:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type CloudforceOneRequestsTime = string;

/**
 * The CISA defined Traffic Light Protocol (TLP).
 *
 * @x-auditable true
 */
export type CloudforceOneRequestsTlp =
  | "clear"
  | "amber"
  | "amber-strict"
  | "green"
  | "red";

/**
 * UUID.
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 */
export type CloudforceOneRequestsUuid = string;

export type CloudforceOneWhoisApiResponseCommon = {
  errors: CloudforceOneWhoisSchemasMessages;
  messages: CloudforceOneWhoisSchemasMessages;
  /**
   * Returns a boolean for the success/failure of the API call.
   *
   * @example true
   */
  success: true;
};

export type CloudforceOneWhoisApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: CloudforceOneWhoisMessages;
  messages: CloudforceOneWhoisMessages;
  result: any | null;
  /**
   * Returns a boolean for the success/failure of the API call.
   *
   * @example false
   */
  success: false;
};

export type CloudforceOneWhoisApiResponseSingle =
  CloudforceOneWhoisApiResponseCommon;

/**
 * @example cloudflare.com
 */
export type CloudforceOneWhoisDomainName = string;

/**
 * Use to uniquely identify or reference the resource.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type CloudforceOneWhoisIdentifier = string;

export type CloudforceOneWhoisMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

export type CloudforceOneWhoisSchemasMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

export type CloudforceOneWhoisSchemasSingleResponse =
  CloudforceOneWhoisApiResponseSingle & {
    result?: CloudforceOneWhoisWhois;
  };

export type CloudforceOneWhoisWhois = {
  administrative_city?: string;
  administrative_country?: string;
  administrative_email?: string;
  administrative_fax?: string;
  administrative_fax_ext?: string;
  administrative_id?: string;
  administrative_name?: string;
  administrative_org?: string;
  administrative_phone?: string;
  administrative_phone_ext?: string;
  administrative_postal_code?: string;
  administrative_province?: string;
  administrative_referral_url?: string;
  administrative_street?: string;
  billing_city?: string;
  billing_country?: string;
  billing_email?: string;
  billing_fax?: string;
  billing_fax_ext?: string;
  billing_id?: string;
  billing_name?: string;
  billing_org?: string;
  billing_phone?: string;
  billing_phone_ext?: string;
  billing_postal_code?: string;
  billing_province?: string;
  billing_referral_url?: string;
  billing_street?: string;
  /**
   * @example 2009-02-17T22:07:54.000Z
   * @format date-time
   */
  created_date?: string;
  /**
   * @example 2009-02-17T22:07:54Z
   */
  created_date_raw?: string;
  /**
   * @example true
   */
  dnssec: boolean;
  domain: CloudforceOneWhoisDomainName;
  /**
   * @example 2033-02-17T22:07:54.000Z
   * @format date-time
   */
  expiration_date?: string;
  /**
   * @example 2033-02-17T22:07:54Z
   */
  expiration_date_raw?: string;
  /**
   * @example com
   */
  extension: string;
  /**
   * @example true
   */
  found: boolean;
  /**
   * @example 1542998887_DOMAIN_COM-VRSN
   */
  id?: string;
  /**
   * @example ns3.cloudflare.com
   * @example ns4.cloudflare.com
   * @example ns5.cloudflare.com
   * @example ns6.cloudflare.com
   * @example ns7.cloudflare.com
   */
  nameservers: string[];
  /**
   * @example cloudflare.com
   */
  punycode: string;
  registrant: string;
  registrant_city?: string;
  registrant_country?: string;
  registrant_email?: string;
  registrant_fax?: string;
  registrant_fax_ext?: string;
  registrant_id?: string;
  registrant_name?: string;
  registrant_org?: string;
  registrant_phone?: string;
  registrant_phone_ext?: string;
  registrant_postal_code?: string;
  registrant_province?: string;
  registrant_referral_url?: string;
  registrant_street?: string;
  /**
   * @example Cloudflare, Inc.
   */
  registrar: string;
  registrar_city?: string;
  registrar_country?: string;
  registrar_email?: string;
  registrar_fax?: string;
  registrar_fax_ext?: string;
  registrar_id?: string;
  registrar_name?: string;
  registrar_org?: string;
  registrar_phone?: string;
  registrar_phone_ext?: string;
  registrar_postal_code?: string;
  registrar_province?: string;
  registrar_referral_url?: string;
  registrar_street?: string;
  /**
   * @example clientdeleteprohibited
   * @example clienttransferprohibited
   * @example clientupdateprohibited
   * @example serverdeleteprohibited
   * @example servertransferprohibited
   * @example serverupdateprohibited
   */
  status?: string[];
  technical_city?: string;
  technical_country?: string;
  technical_email?: string;
  technical_fax?: string;
  technical_fax_ext?: string;
  technical_id?: string;
  technical_name?: string;
  technical_org?: string;
  technical_phone?: string;
  technical_phone_ext?: string;
  technical_postal_code?: string;
  technical_province?: string;
  technical_referral_url?: string;
  technical_street?: string;
  /**
   * @example 2024-01-09T16:45:28.000Z
   * @format date-time
   */
  updated_date?: string;
  /**
   * @example 2024-01-09T16:45:28Z
   */
  updated_date_raw?: string;
  /**
   * @example whois.cloudflare.com
   */
  whois_server?: string;
};

export type CustomIndicatorFeedsApiResponseCommon = {
  errors: CustomIndicatorFeedsSchemasMessages;
  messages: CustomIndicatorFeedsSchemasMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type CustomIndicatorFeedsApiResponseSingle =
  CustomIndicatorFeedsApiResponseCommon;

export type CustomIndicatorFeedsApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: CustomIndicatorFeedsMessages;
  messages: CustomIndicatorFeedsMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

/**
 * @example {"description":"example feed description","name":"example_feed_1"}
 */
export type CustomIndicatorFeedsCreateFeed = {
  description?: CustomIndicatorFeedsDescription;
  name?: CustomIndicatorFeedsName;
};

export type CustomIndicatorFeedsCreateFeedResponse =
  CustomIndicatorFeedsApiResponseSingle & {
    result?: CustomIndicatorFeedsIndicatorFeedItem;
  };

/**
 * The description of the example test
 *
 * @x-auditable true
 */
export type CustomIndicatorFeedsDescription = string;

/**
 * Indicator feed ID
 *
 * @example 12
 * @x-auditable true
 */
export type CustomIndicatorFeedsFeedId = number;

/**
 * The unique identifier for the indicator feed
 *
 * @x-auditable true
 */
export type CustomIndicatorFeedsId = number;

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type CustomIndicatorFeedsIdentifier = string;

/**
 * @example {"created_on":"2023-05-12T12:21:56.777653Z","description":"example feed description","id":1,"is_attributable":false,"is_downloadable":false,"is_public":false,"modified_on":"2023-06-18T03:13:34.123321Z","name":"example_feed_1"}
 */
export type CustomIndicatorFeedsIndicatorFeedItem = {
  /**
   * The date and time when the data entry was created
   *
   * @format date-time
   * @x-auditable true
   */
  created_on?: string;
  description?: CustomIndicatorFeedsDescription;
  id?: CustomIndicatorFeedsId;
  is_attributable?: CustomIndicatorFeedsIsAttributable;
  is_downloadable?: CustomIndicatorFeedsIsDownloadable;
  is_public?: CustomIndicatorFeedsIsPublic;
  /**
   * The date and time when the data entry was last modified
   *
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string;
  name?: CustomIndicatorFeedsName;
};

/**
 * @example {"created_on":"2023-05-12T12:21:56.777653Z","description":"example feed description","id":1,"is_attributable":false,"is_downloadable":false,"is_public":false,"latest_upload_status":"Complete","modified_on":"2023-06-18T03:13:34.123321Z","name":"example_feed_1"}
 */
export type CustomIndicatorFeedsIndicatorFeedMetadata = {
  /**
   * The date and time when the data entry was created
   *
   * @format date-time
   * @x-auditable true
   */
  created_on?: string;
  description?: CustomIndicatorFeedsDescription;
  id?: CustomIndicatorFeedsId;
  is_attributable?: CustomIndicatorFeedsIsAttributable;
  is_downloadable?: CustomIndicatorFeedsIsDownloadable;
  is_public?: CustomIndicatorFeedsIsPublic;
  /**
   * Status of the latest snapshot uploaded
   *
   * @x-auditable true
   */
  latest_upload_status?:
    | "Mirroring"
    | "Unifying"
    | "Loading"
    | "Provisioning"
    | "Complete"
    | "Error";
  /**
   * The date and time when the data entry was last modified
   *
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string;
  name?: CustomIndicatorFeedsName;
  provider_id?: CustomIndicatorFeedsProviderId;
  provider_name?: CustomIndicatorFeedsProviderName;
};

export type CustomIndicatorFeedsIndicatorFeedMetadataResponse =
  CustomIndicatorFeedsApiResponseSingle & {
    result?: CustomIndicatorFeedsIndicatorFeedMetadata;
  };

export type CustomIndicatorFeedsIndicatorFeedResponse =
  CustomIndicatorFeedsApiResponseCommon & {
    /**
     * @example {"created_on":"2023-05-12T12:21:56.777653Z","description":"user specified description 1","id":1,"modified_on":"2023-06-18T03:13:34.123321Z","name":"user_specified_name_1"}
     * @example {"created_on":"2023-05-21T21:43:52.867525Z","description":"User specified description 2","id":2,"modified_on":"2023-06-28T18:46:18.764425Z","name":"user_specified_name_2"}
     */
    result?: CustomIndicatorFeedsIndicatorFeedItem[];
  };

export type CustomIndicatorFeedsIndicatorFeedResponseSingle =
  CustomIndicatorFeedsApiResponseSingle & {
    result?: CustomIndicatorFeedsIndicatorFeedItem;
  };

/**
 * Whether the indicator feed can be attributed to a provider
 *
 * @x-auditable true
 */
export type CustomIndicatorFeedsIsAttributable = boolean;

/**
 * Whether the indicator feed can be downloaded
 *
 * @x-auditable true
 */
export type CustomIndicatorFeedsIsDownloadable = boolean;

/**
 * Whether the indicator feed is exposed to customers
 *
 * @x-auditable true
 */
export type CustomIndicatorFeedsIsPublic = boolean;

export type CustomIndicatorFeedsMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * The name of the indicator feed
 *
 * @x-auditable true
 */
export type CustomIndicatorFeedsName = string;

export type CustomIndicatorFeedsPermissionListItem = {
  description?: CustomIndicatorFeedsDescription;
  id?: CustomIndicatorFeedsId;
  is_attributable?: CustomIndicatorFeedsIsAttributable;
  is_downloadable?: CustomIndicatorFeedsIsDownloadable;
  is_public?: CustomIndicatorFeedsIsPublic;
  name?: CustomIndicatorFeedsName;
};

export type CustomIndicatorFeedsPermissionListItemResponse =
  CustomIndicatorFeedsApiResponseCommon & {
    /**
     * @example {"description":"An important indicator list","id":1,"is_attributable":false,"is_downloadable":false,"is_public":false,"name":"indicator_list_1"}
     * @example {"description":"An even more important indicator list","id":2,"is_attributable":true,"is_downloadable":false,"is_public":true,"name":"indicator_list_2"}
     */
    result?: CustomIndicatorFeedsPermissionListItem[];
  };

export type CustomIndicatorFeedsPermissionsRequest = {
  /**
   * The Cloudflare account tag of the account to change permissions on
   *
   * @example 823f45f16fd2f7e21e1e054aga4d2859
   * @x-auditable true
   */
  account_tag?: string;
  /**
   * The ID of the feed to add/remove permissions on
   *
   * @example 1
   * @x-auditable true
   */
  feed_id?: number;
};

export type CustomIndicatorFeedsPermissionsResponse =
  CustomIndicatorFeedsApiResponseSingle & {
    result?: CustomIndicatorFeedsPermissionsUpdate;
  };

export type CustomIndicatorFeedsPermissionsUpdate = {
  /**
   * Whether the update succeeded or not
   *
   * @x-auditable true
   */
  success?: boolean;
};

/**
 * The unique identifier for the provider
 *
 * @x-auditable true
 */
export type CustomIndicatorFeedsProviderId = string;

/**
 * The provider of the indicator feed
 *
 * @x-auditable true
 */
export type CustomIndicatorFeedsProviderName = string;

export type CustomIndicatorFeedsSchemasMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

export type CustomIndicatorFeedsUpdateFeed = {
  /**
   * Feed id
   *
   * @example 1
   * @x-auditable true
   */
  file_id?: number;
  /**
   * Name of the file unified in our system
   *
   * @example snapshot_file.unified
   * @x-auditable true
   */
  filename?: string;
  /**
   * Current status of upload, should be unified
   *
   * @example unified
   * @x-auditable true
   */
  status?: string;
};

export type CustomIndicatorFeedsUpdateFeedResponse =
  CustomIndicatorFeedsApiResponseSingle & {
    result?: CustomIndicatorFeedsUpdateFeed;
  };

export type CustomIndicatorFeedsUpdatePublicFieldRequest = {
  /**
   * The new description of the feed
   *
   * @example This is an example description
   * @x-auditable true
   */
  description?: string;
  /**
   * The new is_attributable value of the feed
   *
   * @example true
   * @x-auditable true
   */
  is_attributable?: boolean;
  /**
   * The new is_downloadable value of the feed
   *
   * @example true
   * @x-auditable true
   */
  is_downloadable?: boolean;
  /**
   * The new is_public value of the feed
   *
   * @example true
   * @x-auditable true
   */
  is_public?: boolean;
  /**
   * The new name of the feed
   *
   * @example indicator_list
   * @x-auditable true
   */
  name?: string;
};

export type CustomIndicatorFeedsUpdatePublicFieldResponse =
  CustomIndicatorFeedsApiResponseSingle & {
    result?: CustomIndicatorFeedsIndicatorFeedItem;
  };

export type CustomPagesApiResponseCollection = {
  errors: CustomPagesMessages;
  messages: CustomPagesMessages;
  result: Record<string, any> | any[] | string | null;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
  result_info?: CustomPagesResultInfo;
};

export type CustomPagesApiResponseCommon = {
  errors: CustomPagesMessages;
  messages: CustomPagesMessages;
  result: Record<string, any> | any[] | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type CustomPagesApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: CustomPagesMessages;
  messages: CustomPagesMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

export type CustomPagesApiResponseSingle = {
  errors: CustomPagesMessages;
  messages: CustomPagesMessages;
  result: Record<string, any> | string | string | null;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type CustomPagesCustomPagesResponseCollection =
  CustomPagesApiResponseCollection & {
    result?: Record<string, any>[];
  };

export type CustomPagesCustomPagesResponseSingle =
  CustomPagesApiResponseSingle & {
    result?: Record<string, any>;
  };

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type CustomPagesIdentifier = string;

export type CustomPagesMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

export type CustomPagesResultInfo = {
  /**
   * Total number of results for the requested service
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters
   *
   * @example 2000
   */
  total_count?: number;
};

/**
 * The custom page state.
 *
 * @example default
 */
export type CustomPagesState = "default" | "customized";

/**
 * The URL associated with the custom page.
 *
 * @default
 * @example http://www.example.com
 * @format uri
 */
export type CustomPagesUrl = string;

/**
 * Account identifier tag.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type D1AccountIdentifier = string;

export type D1ApiResponseCommon = {
  errors: D1Messages;
  messages: D1Messages;
  result: Record<string, any>;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type D1ApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: D1Messages;
  messages: D1Messages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

/**
 * Specifies the timestamp the resource was created as an ISO8601 string.
 *
 * @example 2022-11-15T18:25:44.442097Z
 * @format date-time
 * @x-auditable true
 */
export type D1CreatedAt = string;

/**
 * The details of the D1 database.
 */
export type D1DatabaseDetailsResponse = {
  created_at?: D1CreatedAt;
  file_size?: D1FileSize;
  name?: D1DatabaseName;
  num_tables?: D1TableCount;
  read_replication?: D1ReadReplicationDetails;
  uuid?: D1DatabaseIdentifier;
  version?: D1DatabaseVersion;
};

/**
 * D1 database identifier (UUID).
 *
 * @example xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
 * @x-auditable true
 */
export type D1DatabaseIdentifier = string;

/**
 * D1 database name.
 *
 * @example my-database
 * @pattern ^[a-z0-9][a-z0-9-_]*$
 * @x-auditable true
 */
export type D1DatabaseName = string;

export type D1DatabaseResponse = {
  created_at?: D1CreatedAt;
  name?: D1DatabaseName;
  uuid?: D1DatabaseIdentifier;
  version?: D1DatabaseVersion;
};

export type D1DatabaseUpdatePartialRequestBody = {
  /**
   * Configuration for D1 read replication.
   */
  read_replication?: {
    mode: D1ReadReplicationMode;
  };
};

export type D1DatabaseUpdateRequestBody = {
  /**
   * Configuration for D1 read replication.
   */
  read_replication: {
    mode: D1ReadReplicationMode;
  };
};

/**
 * @example production
 * @pattern ^(alpha|beta|production)$
 * @x-auditable true
 */
export type D1DatabaseVersion = string;

/**
 * The D1 database's size, in bytes.
 *
 * @example 12
 * @x-auditable true
 */
export type D1FileSize = number;

export type D1Messages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * @example firstParam
 * @example secondParam
 */
export type D1Params = string[];

/**
 * Specify the region to create the D1 primary, if available. If this option is omitted, the D1 will be created as close as possible to the current user.
 *
 * @example wnam
 * @x-auditable true
 */
export type D1PrimaryLocationHint =
  | "wnam"
  | "enam"
  | "weur"
  | "eeur"
  | "apac"
  | "oc";

export type D1QueryMeta = {
  /**
   * Denotes if the database has been altered in some way, like deleting rows.
   *
   * @x-auditable true
   */
  changed_db?: boolean;
  /**
   * Rough indication of how many rows were modified by the query, as provided by SQLite's `sqlite3_total_changes()`.
   *
   * @x-auditable true
   */
  changes?: number;
  /**
   * The duration of the SQL query execution inside the database. Does not include any network communication.
   *
   * @x-auditable true
   */
  duration?: number;
  /**
   * The row ID of the last inserted row in a table with an `INTEGER PRIMARY KEY` as provided by SQLite. Tables created with `WITHOUT ROWID` do not populate this.
   *
   * @x-auditable true
   */
  last_row_id?: number;
  /**
   * Number of rows read during the SQL query execution, including indices (not all rows are necessarily returned).
   *
   * @x-auditable true
   */
  rows_read?: number;
  /**
   * Number of rows written during the SQL query execution, including indices.
   *
   * @x-auditable true
   */
  rows_written?: number;
  /**
   * Denotes if the query has been handled by the database primary instance.
   *
   * @x-auditable true
   */
  served_by_primary?: boolean;
  served_by_region?: D1ServedByRegion;
  /**
   * Size of the database after the query committed, in bytes.
   *
   * @x-auditable true
   */
  size_after?: number;
  /**
   * Various durations for the query.
   */
  timings?: {
    /**
     * The duration of the SQL query execution inside the database. Does not include any network communication.
     *
     * @x-auditable true
     */
    sql_duration_ms?: number;
  };
};

export type D1QueryResultResponse = {
  meta?: D1QueryMeta;
  results?: Record<string, any>[];
  success?: boolean;
};

export type D1RawResultResponse = {
  meta?: D1QueryMeta;
  results?: {
    columns?: string[];
    rows?: (number | string | Record<string, any>)[][];
  };
  success?: boolean;
};

/**
 * Configuration for D1 read replication.
 */
export type D1ReadReplicationDetails = {
  mode: D1ReadReplicationMode;
};

/**
 * The read replication mode for the database. Use 'auto' to create replicas and allow D1 automatically place them around the world, or 'disabled' to not use any database replicas (it can take a few hours for all replicas to be deleted).
 *
 * @example auto
 * @x-auditable true
 */
export type D1ReadReplicationMode = "auto" | "disabled";

/**
 * Region location hint of the database instance that handled the query.
 *
 * @example EEUR
 * @x-auditable true
 */
export type D1ServedByRegion =
  | "WNAM"
  | "ENAM"
  | "WEUR"
  | "EEUR"
  | "APAC"
  | "OC";

/**
 * Your SQL query. Supports multiple statements, joined by semicolons, which will be executed as a batch.
 *
 * @example SELECT * FROM myTable WHERE field = ? OR field = ?;
 */
export type D1Sql = string;

/**
 * @example 12
 * @x-auditable true
 */
export type D1TableCount = number;

/**
 * @example 01a7362d577a6c3019a474fd6f485823
 * @maxLength 32
 */
export type DigitalExperienceMonitoringAccountIdentifier = string;

export type DigitalExperienceMonitoringAggregateStat = {
  avgMs?: number | null;
  /**
   * @format float
   */
  deltaPct?: number | null;
  timePeriod: DigitalExperienceMonitoringAggregateTimePeriod;
};

export type DigitalExperienceMonitoringAggregateTimePeriod = {
  units: "hours" | "days" | "testRuns";
  value: number;
};

export type DigitalExperienceMonitoringAggregateTimeSlot = {
  avgMs: number;
  timestamp: string;
};

export type DigitalExperienceMonitoringApiResponseCollection =
  DigitalExperienceMonitoringApiResponseCommon & {
    result_info?: {
      /**
       * Total number of results for the requested service.
       *
       * @example 1
       */
      count?: number;
      /**
       * Current page within paginated list of results.
       *
       * @example 1
       */
      page?: number;
      /**
       * Number of results per page of results.
       *
       * @example 20
       */
      per_page?: number;
      /**
       * Total results available without any search parameters.
       *
       * @example 2000
       */
      total_count?: number;
    };
  };

export type DigitalExperienceMonitoringApiResponseCollectionCommon =
  DigitalExperienceMonitoringApiResponseCommon & {
    result?: any[] | null;
  };

export type DigitalExperienceMonitoringApiResponseCommon = {
  errors: DigitalExperienceMonitoringMessages;
  messages: DigitalExperienceMonitoringMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type DigitalExperienceMonitoringApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: DigitalExperienceMonitoringMessages;
  messages: DigitalExperienceMonitoringMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type DigitalExperienceMonitoringApiResponseSingle =
  DigitalExperienceMonitoringApiResponseCommon;

/**
 * Cloudflare colo
 *
 * @example SJC
 */
export type DigitalExperienceMonitoringColo = string;

/**
 * array of colos.
 */
export type DigitalExperienceMonitoringColosResponse = Record<string, any>[];

/**
 * Unique identifier for a command
 *
 * @example 5758fefe-ae7e-4538-a39b-1fef6abcb909
 */
export type DigitalExperienceMonitoringCommandId = string;

export type DigitalExperienceMonitoringCommandsDevicesResponse = {
  /**
   * List of eligible devices
   */
  devices?: {
    /**
     * Device identifier (UUID v4)
     */
    deviceId?: string;
    /**
     * Device identifier (human readable)
     */
    deviceName?: string;
    /**
     * Whether the device is eligible for remote captures
     */
    eligible?: boolean;
    /**
     * If the device is not eligible, the reason why.
     */
    ineligibleReason?: string;
    /**
     * User contact email address
     */
    personEmail?: string;
    platform?: DigitalExperienceMonitoringPlatform;
    status?: DigitalExperienceMonitoringStatus;
    timestamp?: DigitalExperienceMonitoringTimestamp;
    version?: DigitalExperienceMonitoringVersion;
  }[];
};

export type DigitalExperienceMonitoringCommandsUsersResponse = {
  /**
   * List of user emails
   */
  userEmails?: string[];
};

export type DigitalExperienceMonitoringCpuPctByApp = {
  /**
   * @format float
   */
  cpu_pct?: number;
  name?: string;
}[];

export type DigitalExperienceMonitoringDevice = {
  alwaysOn?: boolean | null;
  batteryCharging?: boolean | null;
  /**
   * @format int64
   */
  batteryCycles?: number | null;
  /**
   * @format float
   */
  batteryPct?: number | null;
  colo: DigitalExperienceMonitoringColo;
  connectionType?: string | null;
  /**
   * @format float
   */
  cpuPct?: number | null;
  cpuPctByApp?: DigitalExperienceMonitoringCpuPctByApp[] | null;
  /**
   * Device identifier (UUID v4)
   */
  deviceId: string;
  deviceIpv4?: DigitalExperienceMonitoringIpInfo;
  deviceIpv6?: DigitalExperienceMonitoringIpInfo;
  /**
   * Device identifier (human readable)
   */
  deviceName?: string;
  /**
   * @format int64
   */
  diskReadBps?: number | null;
  /**
   * @format float
   */
  diskUsagePct?: number | null;
  /**
   * @format int64
   */
  diskWriteBps?: number | null;
  dohSubdomain?: string | null;
  /**
   * @format float
   */
  estimatedLossPct?: number | null;
  firewallEnabled?: boolean | null;
  gatewayIpv4?: DigitalExperienceMonitoringIpInfo;
  gatewayIpv6?: DigitalExperienceMonitoringIpInfo;
  /**
   * @format int64
   */
  handshakeLatencyMs?: number | null;
  ispIpv4?: DigitalExperienceMonitoringIpInfo;
  ispIpv6?: DigitalExperienceMonitoringIpInfo;
  metal?: string | null;
  mode: DigitalExperienceMonitoringMode;
  /**
   * @format int64
   */
  networkRcvdBps?: number | null;
  /**
   * @format int64
   */
  networkSentBps?: number | null;
  networkSsid?: string | null;
  personEmail?: DigitalExperienceMonitoringPersonEmail;
  platform: DigitalExperienceMonitoringPlatform;
  /**
   * @format int64
   */
  ramAvailableKb?: number | null;
  /**
   * @format float
   */
  ramUsedPct?: number | null;
  ramUsedPctByApp?: DigitalExperienceMonitoringRamUsedPctByApp[] | null;
  status: DigitalExperienceMonitoringStatus;
  switchLocked?: boolean | null;
  timestamp: DigitalExperienceMonitoringTimestamp;
  version: DigitalExperienceMonitoringVersion;
  /**
   * @format int64
   */
  wifiStrengthDbm?: number | null;
};

/**
 * The configuration object which contains the details for the WARP client to conduct the test.
 *
 * @example {"host":"https://dash.cloudflare.com","kind":"http","method":"GET"}
 */
export type DigitalExperienceMonitoringDeviceDexTestSchemasData = {
  /**
   * The desired endpoint to test.
   *
   * @example https://dash.cloudflare.com
   */
  host?: string;
  /**
   * The type of test.
   *
   * @example http
   */
  kind?: string;
  /**
   * The HTTP request method type.
   *
   * @example GET
   */
  method?: string;
};

/**
 * Additional details about the test.
 *
 * @example Checks the dash endpoint every 30 minutes
 */
export type DigitalExperienceMonitoringDeviceDexTestSchemasDescription = string;

/**
 * Determines whether or not the test is active.
 *
 * @example true
 */
export type DigitalExperienceMonitoringDeviceDexTestSchemasEnabled = boolean;

export type DigitalExperienceMonitoringDeviceDexTestSchemasHttp = {
  data: DigitalExperienceMonitoringDeviceDexTestSchemasData;
  description?: DigitalExperienceMonitoringDeviceDexTestSchemasDescription;
  enabled: DigitalExperienceMonitoringDeviceDexTestSchemasEnabled;
  interval: DigitalExperienceMonitoringDeviceDexTestSchemasInterval;
  name: DigitalExperienceMonitoringDeviceDexTestSchemasName;
  target_policies?: DigitalExperienceMonitoringDeviceDexTestTargetPolicies;
  targeted?: boolean;
  test_id?: DigitalExperienceMonitoringSchemasTestId;
};

/**
 * How often the test will run.
 *
 * @example 30m
 */
export type DigitalExperienceMonitoringDeviceDexTestSchemasInterval = string;

/**
 * The name of the DEX test. Must be unique.
 *
 * @example HTTP dash health check
 */
export type DigitalExperienceMonitoringDeviceDexTestSchemasName = string;

/**
 * DEX rules targeted by this test
 */
export type DigitalExperienceMonitoringDeviceDexTestTargetPolicies =
  DigitalExperienceMonitoringDexTargetPolicy[];

/**
 * Device-specific ID, given as UUID v4
 *
 * @example cb49c27f-7f97-49c5-b6f3-f7c01ead0fd7
 */
export type DigitalExperienceMonitoringDeviceId = string;

export type DigitalExperienceMonitoringDexDeleteResponseCollection =
  DigitalExperienceMonitoringApiResponseCommon & {
    result?: {
      dex_tests?: DigitalExperienceMonitoringDeviceDexTestSchemasHttp[];
    };
  };

export type DigitalExperienceMonitoringDexResponseCollection =
  DigitalExperienceMonitoringApiResponseCollectionCommon & {
    result?: DigitalExperienceMonitoringDeviceDexTestSchemasHttp[];
  };

export type DigitalExperienceMonitoringDexSingleResponse =
  DigitalExperienceMonitoringApiResponseSingle & {
    result?: DigitalExperienceMonitoringDeviceDexTestSchemasHttp;
  };

export type DigitalExperienceMonitoringDexTargetPolicy = {
  /**
   * Whether the DEX rule is the account default
   */
  ["default"]?: boolean;
  /**
   * The id of the DEX rule
   */
  id?: string;
  /**
   * The name of the DEX rule
   */
  name?: string;
};

export type DigitalExperienceMonitoringFleetStatusDevicesResponse =
  DigitalExperienceMonitoringApiResponseCollection & {
    result?: DigitalExperienceMonitoringDevice[];
  };

export type DigitalExperienceMonitoringFleetStatusLiveResponse =
  DigitalExperienceMonitoringApiResponseSingle & {
    result?: {
      deviceStats?: {
        byColo?: DigitalExperienceMonitoringLiveStat[] | null;
        byMode?: DigitalExperienceMonitoringLiveStat[] | null;
        byPlatform?: DigitalExperienceMonitoringLiveStat[] | null;
        byStatus?: DigitalExperienceMonitoringLiveStat[] | null;
        byVersion?: DigitalExperienceMonitoringLiveStat[] | null;
        uniqueDevicesTotal?: DigitalExperienceMonitoringUniqueDevicesTotal;
      };
    };
  };

export type DigitalExperienceMonitoringGetCommandsQuotaResponse = {
  /**
   * The remaining number of commands that can be initiated for an account
   */
  quota: number;
  /**
   * The number of commands that have been initiated for an account
   */
  quota_usage: number;
  /**
   * The time when the quota resets
   *
   * @format date-time
   */
  reset_time: string;
};

export type DigitalExperienceMonitoringGetCommandsResponse = {
  commands?: {
    /**
     * @format date-time
     */
    completed_date?: string | null;
    /**
     * @format date-time
     */
    created_date?: string;
    device_id?: string;
    filename?: string | null;
    id?: string;
    status?: string;
    type?: string;
    user_email?: string;
  }[];
};

export type DigitalExperienceMonitoringHttpDetailsPercentilesResponse = {
  dnsResponseTimeMs?: DigitalExperienceMonitoringPercentiles;
  resourceFetchTimeMs?: DigitalExperienceMonitoringPercentiles;
  serverResponseTimeMs?: DigitalExperienceMonitoringPercentiles;
};

export type DigitalExperienceMonitoringHttpDetailsResponse = {
  /**
   * The url of the HTTP synthetic application test
   *
   * @example http://example.com
   */
  host?: string;
  httpStats?: {
    availabilityPct: DigitalExperienceMonitoringTestStatPctOverTime;
    dnsResponseTimeMs: DigitalExperienceMonitoringTestStatOverTime;
    httpStatusCode: {
      status200: number;
      status300: number;
      status400: number;
      status500: number;
      /**
       * @example 2023-07-16 15:00:00+00
       */
      timestamp: string;
    }[];
    resourceFetchTimeMs: DigitalExperienceMonitoringTestStatOverTime;
    serverResponseTimeMs: DigitalExperienceMonitoringTestStatOverTime;
    /**
     * Count of unique devices that have run this test in the given time period
     *
     * @example 57
     */
    uniqueDevicesTotal: number;
  } | null;
  httpStatsByColo?: {
    availabilityPct: DigitalExperienceMonitoringTestStatPctOverTime;
    /**
     * @example DFW
     */
    colo: string;
    dnsResponseTimeMs: DigitalExperienceMonitoringTestStatOverTime;
    httpStatusCode: {
      status200: number;
      status300: number;
      status400: number;
      status500: number;
      /**
       * @example 2023-07-16 15:00:00+00
       */
      timestamp: string;
    }[];
    resourceFetchTimeMs: DigitalExperienceMonitoringTestStatOverTime;
    serverResponseTimeMs: DigitalExperienceMonitoringTestStatOverTime;
    /**
     * Count of unique devices that have run this test in the given time period
     *
     * @example 57
     */
    uniqueDevicesTotal: number;
  }[];
  /**
   * The interval at which the HTTP synthetic application test is set to run.
   *
   * @example 0h5m0s
   */
  interval?: string;
  kind?: "http";
  /**
   * The HTTP method to use when running the test
   *
   * @example GET
   */
  method?: string;
  /**
   * The name of the HTTP synthetic application test
   *
   * @example Atlassian Sign In Page
   */
  name?: string;
  target_policies?:
    | {
        /**
         * Whether the policy is the default for the account
         */
        ["default"]: boolean;
        id: string;
        name: string;
      }[]
    | null;
  targeted?: boolean;
};

export type DigitalExperienceMonitoringIpInfo = {
  address?: string | null;
  asn?: number | null;
  aso?: string | null;
  location?: {
    city?: string | null;
    country_iso?: string | null;
    state_iso?: string | null;
    zip?: string | null;
  };
  netmask?: string | null;
  version?: string | null;
};

export type DigitalExperienceMonitoringLiveStat = {
  uniqueDevicesTotal?: DigitalExperienceMonitoringUniqueDevicesTotal;
  value?: string;
};

export type DigitalExperienceMonitoringMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * The mode under which the WARP client is run
 *
 * @example proxy
 */
export type DigitalExperienceMonitoringMode = string;

/**
 * Page number of paginated results
 *
 * @default 1
 * @example 1
 * @minimum 1
 */
export type DigitalExperienceMonitoringPage = number;

/**
 * Number of items per page
 *
 * @example 10
 * @maximum 50
 * @minimum 1
 */
export type DigitalExperienceMonitoringPerPage = number;

export type DigitalExperienceMonitoringPercentiles = {
  /**
   * p50 observed in the time period
   */
  p50?: number | null;
  /**
   * p90 observed in the time period
   */
  p90?: number | null;
  /**
   * p95 observed in the time period
   */
  p95?: number | null;
  /**
   * p99 observed in the time period
   */
  p99?: number | null;
};

/**
 * User contact email address
 */
export type DigitalExperienceMonitoringPersonEmail = string;

/**
 * Operating system
 *
 * @example windows
 */
export type DigitalExperienceMonitoringPlatform = string;

export type DigitalExperienceMonitoringPostCommandsResponse = {
  /**
   * List of created commands
   */
  commands?: {
    /**
     * Command arguments
     */
    args?: {
      [key: string]: string;
    };
    /**
     * Identifier for the device associated with the command
     */
    device_id?: string;
    /**
     * Unique identifier for the command
     */
    id?: string;
    /**
     * Current status of the command
     */
    status?: "PENDING_EXEC" | "PENDING_UPLOAD" | "SUCCESS" | "FAILED";
    /**
     * Type of the command (e.g., "pcap" or "warp-diag")
     */
    type?: string;
  }[];
};

export type DigitalExperienceMonitoringRamUsedPctByApp = {
  name?: string;
  /**
   * @format float
   */
  ram_used_pct?: number;
}[];

/**
 * The unique identifier for the test.
 *
 * @example 372e67954025e0ba6aaa6d586b9e0b59
 * @maxLength 32
 */
export type DigitalExperienceMonitoringSchemasTestId = string;

/**
 * Number of minutes before current time
 *
 * @default 10
 * @example 10
 * @maximum 60
 * @minimum 1
 */
export type DigitalExperienceMonitoringSinceMinutes = number;

/**
 * Dimension to sort results by
 *
 * @default timestamp
 */
export type DigitalExperienceMonitoringSortBy =
  | "colo"
  | "device_id"
  | "mode"
  | "platform"
  | "status"
  | "timestamp"
  | "version";

/**
 * Specifies fleet status details source
 *
 * @default last_seen
 * @example last_seen
 */
export type DigitalExperienceMonitoringSource = "last_seen" | "hourly" | "raw";

/**
 * Network status
 *
 * @example connected
 */
export type DigitalExperienceMonitoringStatus = string;

export type DigitalExperienceMonitoringTestStatOverTime = {
  /**
   * average observed in the time period
   */
  avg?: number | null;
  /**
   * highest observed in the time period
   */
  max?: number | null;
  /**
   * lowest observed in the time period
   */
  min?: number | null;
  slots: {
    /**
     * @example 2023-07-16 15:00:00+00
     */
    timestamp: string;
    value: number;
  }[];
};

export type DigitalExperienceMonitoringTestStatPctOverTime = {
  /**
   * average observed in the time period
   *
   * @format float
   */
  avg?: number | null;
  /**
   * highest observed in the time period
   *
   * @format float
   */
  max?: number | null;
  /**
   * lowest  observed in the time period
   *
   * @format float
   */
  min?: number | null;
  slots: {
    /**
     * @example 2023-07-16 15:00:00+00
     */
    timestamp: string;
    /**
     * @format float
     */
    value: number;
  }[];
};

export type DigitalExperienceMonitoringTestsResponse = {
  overviewMetrics: {
    /**
     * percentage availability for all HTTP test results in response
     *
     * @format float
     */
    avgHttpAvailabilityPct?: number | null;
    /**
     * percentage availability for all traceroutes results in response
     *
     * @format float
     */
    avgTracerouteAvailabilityPct?: number | null;
    /**
     * number of  tests.
     */
    testsTotal: number;
  };
  /**
   * array of test results objects.
   */
  tests: {
    /**
     * date the test was created.
     */
    created: string;
    /**
     * the test description defined during configuration
     */
    description: string;
    /**
     * if true, then the test will run on targeted devices. Else, the test will not run.
     */
    enabled: boolean;
    host: string;
    httpResults?: {
      resourceFetchTime: DigitalExperienceMonitoringTimingAggregates;
    } | null;
    httpResultsByColo?: {
      /**
       * Cloudflare colo
       *
       * @example SJC
       */
      colo: string;
      resourceFetchTime: DigitalExperienceMonitoringTimingAggregates;
    }[];
    id: DigitalExperienceMonitoringUuid;
    /**
     * The interval at which the synthetic application test is set to run.
     */
    interval: string;
    /**
     * test type, http or traceroute
     */
    kind: "http" | "traceroute";
    /**
     * for HTTP, the method to use when running the test
     */
    method?: string;
    /**
     * name given to this test
     */
    name: string;
    target_policies?:
      | {
          /**
           * Whether the policy is the default for the account
           */
          ["default"]: boolean;
          id: string;
          name: string;
        }[]
      | null;
    targeted?: boolean;
    tracerouteResults?: {
      roundTripTime: DigitalExperienceMonitoringTimingAggregates;
    } | null;
    tracerouteResultsByColo?: {
      /**
       * Cloudflare colo
       *
       * @example SJC
       */
      colo: string;
      roundTripTime: DigitalExperienceMonitoringTimingAggregates;
    }[];
    updated: string;
  }[];
};

/**
 * Current time in ISO format
 *
 * @example 2023-10-11T00:00:00Z
 */
export type DigitalExperienceMonitoringTimeNow = string;

/**
 * Timestamp in ISO format
 *
 * @example 2023-10-11T00:00:00Z
 */
export type DigitalExperienceMonitoringTimestamp = string;

export type DigitalExperienceMonitoringTimingAggregates = {
  avgMs?: number | null;
  history: DigitalExperienceMonitoringAggregateStat[];
  overTime?: {
    timePeriod: DigitalExperienceMonitoringAggregateTimePeriod;
    values: DigitalExperienceMonitoringAggregateTimeSlot[];
  } | null;
};

export type DigitalExperienceMonitoringTracerouteDetailsPercentilesResponse = {
  hopsCount?: DigitalExperienceMonitoringPercentiles;
  packetLossPct?: DigitalExperienceMonitoringPercentiles;
  roundTripTimeMs?: DigitalExperienceMonitoringPercentiles;
};

export type DigitalExperienceMonitoringTracerouteDetailsResponse = {
  /**
   * The host of the Traceroute synthetic application test
   *
   * @example 1.1.1.1
   */
  host: string;
  /**
   * The interval at which the Traceroute synthetic application test is set to run.
   *
   * @example 0h5m0s
   */
  interval: string;
  kind: "traceroute";
  /**
   * The name of the Traceroute synthetic application test
   *
   * @example Atlassian Sign In Page
   */
  name: string;
  target_policies?:
    | {
        /**
         * Whether the policy is the default for the account
         */
        ["default"]: boolean;
        id: string;
        name: string;
      }[]
    | null;
  targeted?: boolean;
  tracerouteStats?: {
    availabilityPct: DigitalExperienceMonitoringTestStatPctOverTime;
    hopsCount: DigitalExperienceMonitoringTestStatOverTime;
    packetLossPct: DigitalExperienceMonitoringTestStatPctOverTime;
    roundTripTimeMs: DigitalExperienceMonitoringTestStatOverTime;
    /**
     * Count of unique devices that have run this test in the given time period
     *
     * @example 57
     */
    uniqueDevicesTotal: number;
  } | null;
  tracerouteStatsByColo?: {
    availabilityPct: DigitalExperienceMonitoringTestStatPctOverTime;
    /**
     * @example DFW
     */
    colo: string;
    hopsCount: DigitalExperienceMonitoringTestStatOverTime;
    packetLossPct: DigitalExperienceMonitoringTestStatPctOverTime;
    roundTripTimeMs: DigitalExperienceMonitoringTestStatOverTime;
    /**
     * Count of unique devices that have run this test in the given time period
     *
     * @example 57
     */
    uniqueDevicesTotal: number;
  }[];
};

export type DigitalExperienceMonitoringTracerouteTestNetworkPathResponse = {
  deviceName?: string;
  id: DigitalExperienceMonitoringUuid;
  /**
   * The interval at which the Traceroute synthetic application test is set to run.
   *
   * @example 0h5m0s
   */
  interval?: string;
  kind?: "traceroute";
  name?: string;
  networkPath?: {
    /**
     * Specifies the sampling applied, if any, to the slots response. When sampled, results shown represent the first test run to the start of each sampling interval.
     */
    sampling?: {
      unit: "hours";
      value: number;
    } | null;
    slots: {
      /**
       * Round trip time in ms of the client to app mile
       */
      clientToAppRttMs: number | null;
      /**
       * Round trip time in ms of the client to Cloudflare egress mile
       */
      clientToCfEgressRttMs: number | null;
      /**
       * Round trip time in ms of the client to Cloudflare ingress mile
       */
      clientToCfIngressRttMs: number | null;
      /**
       * Round trip time in ms of the client to ISP mile
       */
      clientToIspRttMs?: number | null;
      id: DigitalExperienceMonitoringUuid;
      /**
       * @example 2023-07-16 15:00:00+00
       */
      timestamp: string;
    }[];
  } | null;
  /**
   * The host of the Traceroute synthetic application test
   *
   * @example 1.1.1.1
   */
  url?: string;
};

export type DigitalExperienceMonitoringTracerouteTestResultNetworkPathResponse =
  {
    /**
     * name of the device associated with this network path response
     */
    deviceName?: string;
    /**
     * an array of the hops taken by the device to reach the end destination
     */
    hops: {
      asn?: number | null;
      aso?: string | null;
      ipAddress?: string | null;
      location?: {
        city?: string | null;
        state?: string | null;
        zip?: string | null;
      } | null;
      mile?:
        | "client-to-app"
        | "client-to-cf-egress"
        | "client-to-cf-ingress"
        | "client-to-isp"
        | null;
      name?: string | null;
      /**
       * @format float
       */
      packetLossPct?: number | null;
      rttMs?: number | null;
      ttl: number;
    }[];
    resultId: DigitalExperienceMonitoringUuid;
    testId?: DigitalExperienceMonitoringUuid;
    /**
     * name of the tracroute test
     */
    testName?: string;
  };

/**
 * Number of unique devices
 */
export type DigitalExperienceMonitoringUniqueDevicesTotal = number;

export type DigitalExperienceMonitoringUniqueDevicesResponse = {
  /**
   * total number of unique devices
   */
  uniqueDevicesTotal: number;
};

/**
 * API Resource UUID tag.
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 */
export type DigitalExperienceMonitoringUuid = string;

/**
 * WARP client version
 *
 * @example 1.0.0
 */
export type DigitalExperienceMonitoringVersion = string;

export type DigitalExperienceMonitoringWarpConfigChangeEvent = {
  device_id?: DigitalExperienceMonitoringUuid;
  device_registration?: DigitalExperienceMonitoringUuid;
  from?: DigitalExperienceMonitoringWarpConfigDetails;
  /**
   * The hostname of the machine the event is from
   */
  hostname?: string;
  /**
   * The serial number of the machine the event is from
   */
  serial_number?: string;
  timestamp?: DigitalExperienceMonitoringTimestamp;
  to?: DigitalExperienceMonitoringWarpConfigDetails;
  /**
   * Email tied to the device
   */
  user_email?: string;
};

export type DigitalExperienceMonitoringWarpConfigDetails = {
  /**
   * The account name.
   */
  account_name?: string;
  account_tag?: DigitalExperienceMonitoringUuid;
  /**
   * The name of the WARP configuration.
   */
  config_name?: string;
};

export type DigitalExperienceMonitoringWarpEventsResponse = (
  | DigitalExperienceMonitoringWarpToggleChangeEvent
  | DigitalExperienceMonitoringWarpConfigChangeEvent
)[];

export type DigitalExperienceMonitoringWarpToggleChangeEvent = {
  /**
   * The account name.
   */
  account_name?: string;
  /**
   * The public account identifier.
   */
  account_tag?: string;
  device_id?: DigitalExperienceMonitoringUuid;
  device_registration?: DigitalExperienceMonitoringUuid;
  /**
   * The hostname of the machine the event is from
   */
  hostname?: string;
  /**
   * The serial number of the machine the event is from
   */
  serial_number?: string;
  timestamp?: DigitalExperienceMonitoringTimestamp;
  /**
   * The state of the WARP toggle.
   */
  toggle?: "on" | "off";
  /**
   * Email tied to the device
   */
  user_email?: string;
};

export type DlpAddinAccountMapping = {
  /**
   * @format uuid
   */
  addin_identifier_token: string;
  auth_requirements: DlpAddinAuth;
};

export type DlpAddinAuth =
  | {
      allowed_microsoft_organizations: string[];
      type: "Org";
    }
  | {
      type: "NoAuth";
    };

export type DlpBehavior = {
  description: string;
  enabled: boolean;
  name: string;
  risk_level: DlpRiskLevel;
};

export type DlpBehaviors = {
  behaviors: {
    [key: string]: DlpBehavior;
  };
};

export type DlpConfidence = "low" | "medium" | "high" | "very_high";

/**
 * Scan the context of predefined entries to only return matches surrounded by keywords.
 *
 * @deprecated true
 */
export type DlpContextAwareness = {
  /**
   * If true, scan the context of predefined entries to only return matches surrounded by keywords.
   */
  enabled: boolean;
  skip: DlpSkipConfig;
};

export type DlpCreateEmailRule = {
  action: DlpEmailRuleAction;
  /**
   * Rule is triggered if all conditions match.
   */
  conditions: DlpEmailRuleCondition[];
  description?: string | null;
  enabled: boolean;
  name: string;
};

export type DlpCreateIntegrationBody = {
  integration_type: DlpRiskScoreIntegrationType;
  /**
   * A reference id that can be supplied by the client. Currently this should be set to the Access-Okta IDP ID (a UUIDv4).
   * https://developers.cloudflare.com/api/operations/access-identity-providers-get-an-access-identity-provider
   */
  reference_id?: string | null;
  /**
   * The base url of the tenant, e.g. "https://tenant.okta.com".
   *
   * @format uri
   */
  tenant_url: string;
};

export type DlpCustomEntry = {
  /**
   * @format date-time
   */
  created_at: string;
  enabled: boolean;
  /**
   * @format uuid
   */
  id: string;
  name: string;
  pattern: DlpPattern;
  /**
   * @format uuid
   */
  profile_id?: string | null;
  /**
   * @format date-time
   */
  updated_at: string;
};

export type DlpCustomEntryUpdate = DlpCustomEntryUpdateType & {
  enabled: boolean;
};

export type DlpCustomEntryUpdateType = {
  name: string;
  pattern: DlpPattern;
};

export type DlpCustomProfile = {
  /**
   * @default false
   */
  ai_context_enabled?: boolean;
  /**
   * Related DLP policies will trigger when the match count exceeds the number set.
   *
   * @default 0
   * @example 5
   * @format int32
   * @maximum 1000
   * @minimum 0
   */
  allowed_match_count: number;
  /**
   * @default low
   */
  confidence_threshold?: DlpConfidence;
  context_awareness?: DlpContextAwareness;
  /**
   * When the profile was created.
   *
   * @format date-time
   */
  created_at: string;
  /**
   * The description of the profile.
   */
  description?: string | null;
  entries: DlpEntry[];
  /**
   * The id of the profile (uuid).
   *
   * @format uuid
   */
  id: string;
  /**
   * The name of the profile.
   *
   * @x-auditable true
   */
  name: string;
  /**
   * @default false
   */
  ocr_enabled: boolean;
  /**
   * When the profile was lasted updated.
   *
   * @format date-time
   */
  updated_at: string;
};

export type DlpCustomProfileUpdate = {
  /**
   * @default false
   */
  ai_context_enabled?: boolean;
  /**
   * @format int32
   */
  allowed_match_count?: number | null;
  /**
   * @default low
   */
  confidence_threshold?: string | null;
  context_awareness?: DlpContextAwareness;
  /**
   * The description of the profile.
   */
  description?: string | null;
  /**
   * Custom entries from this profile.
   * If this field is omitted, entries owned by this profile will not be changed.
   *
   * @deprecated true
   */
  entries?: DlpProfileEntryUpdate[] | null;
  name: string;
  /**
   * @default false
   */
  ocr_enabled?: boolean;
  /**
   * Other entries, e.g. predefined or integration.
   */
  shared_entries?: DlpSharedEntryUpdate[];
};

export type DlpDataset = {
  case_sensitive?: boolean;
  columns: DlpDatasetColumn[];
  /**
   * @format date-time
   */
  created_at: string;
  /**
   * The description of the dataset.
   */
  description?: string | null;
  /**
   * @format int32
   * @minimum 0
   */
  encoding_version: number;
  /**
   * @format uuid
   */
  id: string;
  name: string;
  /**
   * @format int64
   */
  num_cells: number;
  secret: boolean;
  status: DlpDatasetUploadStatus;
  /**
   * When the dataset was last updated.
   *
   * This includes name or description changes as well as uploads.
   *
   * @format date-time
   */
  updated_at: string;
  uploads: DlpDatasetUpload[];
};

export type DlpDatasetArray = DlpDataset[];

export type DlpDatasetColumn = {
  /**
   * @format uuid
   */
  entry_id: string;
  header_name: string;
  /**
   * @format int64
   */
  num_cells: number;
  upload_status: DlpDatasetUploadStatus;
};

export type DlpDatasetColumnArray = DlpDatasetColumn[];

export type DlpDatasetCreation = {
  dataset: DlpDataset;
  /**
   * Encoding version to use for dataset.
   *
   * @format int32
   * @minimum 0
   */
  encoding_version: number;
  /**
   * @format int64
   * @minimum 0
   */
  max_cells: number;
  /**
   * The secret to use for Exact Data Match datasets. This is not present in
   * Custom Wordlists.
   *
   * @format password
   */
  secret?: string;
  /**
   * The version to use when uploading the dataset.
   *
   * @format int64
   */
  version: number;
};

export type DlpDatasetNewVersion = {
  case_sensitive?: boolean;
  columns?: DlpDatasetColumn[];
  /**
   * @format int32
   * @minimum 0
   */
  encoding_version: number;
  /**
   * @format int64
   * @minimum 0
   */
  max_cells: number;
  /**
   * @format password
   */
  secret?: string;
  /**
   * @format int64
   */
  version: number;
};

export type DlpDatasetUpdate = {
  /**
   * Determines if the words should be matched in a case-sensitive manner.
   *
   * Only required for custom word lists.
   */
  case_sensitive?: boolean;
  /**
   * The description of the dataset.
   */
  description?: string | null;
  /**
   * The name of the dataset, must be unique.
   */
  name?: string | null;
};

export type DlpDatasetUpload = {
  /**
   * @format int64
   */
  num_cells: number;
  status: DlpDatasetUploadStatus;
  /**
   * @format int64
   */
  version: number;
};

export type DlpDatasetUploadStatus =
  | "empty"
  | "uploading"
  | "pending"
  | "processing"
  | "failed"
  | "complete";

export type DlpDocumentFingerprint = {
  /**
   * @format date-time
   */
  created_at: string;
  /**
   * @default
   */
  description: string;
  /**
   * @format uuid
   */
  entry_id: string;
  file_name?: string | null;
  /**
   * @format uuid
   */
  id: string;
  /**
   * @format int32
   */
  match_percent: number;
  name: string;
  status: DlpDatasetUploadStatus;
  /**
   * @format date-time
   */
  updated_at: string;
  /**
   * @format int64
   */
  version?: number | null;
};

export type DlpDocumentFingerprintArray = DlpDocumentFingerprint[];

export type DlpDocumentFingerprintEntry = {
  /**
   * @format date-time
   */
  created_at: string;
  enabled: boolean;
  /**
   * @format uuid
   */
  id: string;
  name: string;
  /**
   * @format date-time
   */
  updated_at: string;
};

export type DlpDocumentFingerprintUpload = {
  /**
   * @format date-time
   */
  created_at: string;
  description: string;
  /**
   * @format uuid
   */
  entry_id: string;
  file_name: string;
  /**
   * @format uuid
   */
  id: string;
  /**
   * @format int32
   */
  match_percent: number;
  name: string;
  status: DlpDatasetUploadStatus;
  /**
   * @format date-time
   */
  updated_at: string;
  /**
   * @format int64
   */
  version: number;
};

export type DlpEmailRule = {
  action: DlpEmailRuleAction;
  /**
   * Rule is triggered if all conditions match.
   */
  conditions: DlpEmailRuleCondition[];
  /**
   * @format date-time
   */
  created_at: string;
  description?: string | null;
  enabled: boolean;
  name: string;
  /**
   * @format int32
   * @minimum 0
   */
  priority: number;
  /**
   * @format uuid
   */
  rule_id: string;
  /**
   * @format date-time
   */
  updated_at: string;
};

export type DlpEmailRuleAction = {
  action: "Block";
  message?: string | null;
};

export type DlpEmailRuleArray = DlpEmailRule[];

export type DlpEmailRuleCondition = {
  operator: DlpEmailRuleOperator;
  selector: DlpEmailRuleSelector;
  value: DlpEmailRuleValue;
};

export type DlpEmailRuleOperator =
  | "InList"
  | "NotInList"
  | "MatchRegex"
  | "NotMatchRegex";

export type DlpEmailRuleSelector = "Recipients" | "Sender" | "DLPProfiles";

export type DlpEmailRuleValue = string[] | string;

export type DlpEmpty = Record<string, any> | null;

export type DlpEntry =
  | (DlpCustomEntry & {
      type: "custom";
    })
  | (DlpPredefinedEntry & {
      type: "predefined";
    })
  | (DlpIntegrationEntry & {
      type: "integration";
    })
  | (DlpExactDataEntry & {
      type: "exact_data";
    })
  | (DlpDocumentFingerprintEntry & {
      type: "document_fingerprint";
    })
  | (DlpWordListEntry & {
      type: "word_list";
    });

export type DlpEntryConfidence = {
  /**
   * Indicates whether this entry has AI remote service validation.
   */
  ai_context_available: boolean;
  /**
   * Indicates whether this entry has any form of validation that is not an AI remote service.
   */
  available: boolean;
};

export type DlpEntryOfNewProfile = DlpNewCustomEntry | DlpNewWordListEntry;

export type DlpEntryUpdate = DlpEntryUpdateType & {
  enabled: boolean;
};

export type DlpEntryUpdateType =
  | (DlpCustomEntryUpdateType & {
      type: "custom";
    })
  | {
      type: "predefined";
    }
  | {
      type: "integration";
    };

export type DlpExactDataEntry = {
  /**
   * Only applies to custom word lists.
   * Determines if the words should be matched in a case-sensitive manner
   * Cannot be set to false if secret is true
   */
  case_sensitive: boolean;
  /**
   * @format date-time
   */
  created_at: string;
  enabled: boolean;
  /**
   * @format uuid
   */
  id: string;
  name: string;
  secret: boolean;
  /**
   * @format date-time
   */
  updated_at: string;
};

export type DlpIntegrationEntry = {
  /**
   * @format date-time
   */
  created_at: string;
  enabled: boolean;
  /**
   * @format uuid
   */
  id: string;
  name: string;
  /**
   * @format uuid
   */
  profile_id?: string | null;
  /**
   * @format date-time
   */
  updated_at: string;
};

export type DlpIntegrationProfile = {
  /**
   * @format date-time
   */
  created_at: string;
  /**
   * The description of the profile.
   */
  description?: string | null;
  entries: DlpEntry[];
  /**
   * @format uuid
   */
  id: string;
  name: string;
  /**
   * @format date-time
   */
  updated_at: string;
};

export type DlpLimits = {
  /**
   * @format int64
   * @minimum 0
   */
  max_dataset_cells: number;
};

export type DlpNewCustomEntry = {
  enabled: boolean;
  name: string;
  pattern: DlpPattern;
};

export type DlpNewCustomEntryWithId = DlpNewCustomEntry & {
  /**
   * @format uuid
   */
  entry_id: string;
};

export type DlpNewCustomProfile = {
  /**
   * @default false
   */
  ai_context_enabled?: boolean;
  /**
   * Related DLP policies will trigger when the match count exceeds the number set.
   *
   * @default 0
   * @example 5
   * @format int32
   * @maximum 1000
   * @minimum 0
   */
  allowed_match_count?: number;
  /**
   * @default low
   */
  confidence_threshold?: string | null;
  context_awareness?: DlpContextAwareness;
  /**
   * The description of the profile.
   */
  description?: string | null;
  entries: DlpEntryOfNewProfile[];
  name: string;
  /**
   * @default false
   */
  ocr_enabled?: boolean;
  /**
   * Entries from other profiles (e.g. pre-defined Cloudflare profiles, or your Microsoft Information Protection profiles).
   */
  shared_entries?: DlpNewSharedEntry[];
};

export type DlpNewDataset = {
  /**
   * Only applies to custom word lists.
   * Determines if the words should be matched in a case-sensitive manner
   * Cannot be set to false if `secret` is true or undefined
   */
  case_sensitive?: boolean;
  /**
   * The description of the dataset.
   */
  description?: string | null;
  /**
   * Dataset encoding version
   *
   * Non-secret custom word lists with no header are always version 1.
   * Secret EDM lists with no header are version 1.
   * Multicolumn CSV with headers are version 2.
   * Omitting this field provides the default value 0, which is interpreted
   * the same as 1.
   *
   * @format int32
   * @minimum 0
   */
  encoding_version?: number;
  name: string;
  /**
   * Generate a secret dataset.
   *
   * If true, the response will include a secret to use with the EDM encoder.
   * If false, the response has no secret and the dataset is uploaded in plaintext.
   */
  secret?: boolean;
};

export type DlpNewDatasetColumn =
  | {
      /**
       * @format uuid
       */
      entry_id: string;
    }
  | {
      entry_name: string;
    };

export type DlpNewDocumentFingerprint = {
  /**
   * @default
   */
  description?: string;
  /**
   * @format int32
   */
  match_percent: number;
  name: string;
};

export type DlpNewEntry = {
  enabled: boolean;
  name: string;
  pattern: DlpPattern;
  /**
   * @format uuid
   */
  profile_id: string;
};

/**
 * Struct for creating a new predefined or integration entry. Predefined or integration entries
 * can not be updated via the API so these fields will simply update the entry's settings
 */
export type DlpNewPredefinedEntry = {
  enabled: boolean;
  /**
   * @format uuid
   */
  entry_id: string;
  /**
   * This field is not actually used as the owning profile for a predefined entry is already set
   * to a predefined profile
   *
   * @format uuid
   */
  profile_id?: string | null;
};

export type DlpNewPredefinedProfile = DlpPredefinedProfileUpdate & {
  /**
   * @format uuid
   */
  profile_id: string;
};

export type DlpNewSharedEntry =
  | {
      enabled: boolean;
      /**
       * @format uuid
       */
      entry_id: string;
      entry_type: "custom";
    }
  | {
      enabled: boolean;
      /**
       * @format uuid
       */
      entry_id: string;
      entry_type: "predefined";
    }
  | {
      enabled: boolean;
      /**
       * @format uuid
       */
      entry_id: string;
      entry_type: "integration";
    }
  | {
      enabled: boolean;
      /**
       * @format uuid
       */
      entry_id: string;
      entry_type: "exact_data";
    }
  | {
      enabled: boolean;
      /**
       * @format uuid
       */
      entry_id: string;
      entry_type: "document_fingerprint";
    };

export type DlpNewWordListEntry = {
  enabled: boolean;
  name: string;
  words: string[];
};

export type DlpPattern = {
  regex: string;
  /**
   * @deprecated true
   */
  validation?: DlpValidation;
};

export type DlpPayloadLogSetting = {
  public_key?: string | null;
  /**
   * @format date-time
   */
  updated_at: string;
};

export type DlpPayloadLogSettingUpdate = {
  public_key?: string | null;
};

export type DlpPredefinedEntry = {
  confidence: DlpEntryConfidence;
  enabled: boolean;
  /**
   * @format uuid
   */
  id: string;
  name: string;
  /**
   * @format uuid
   */
  profile_id?: string | null;
};

export type DlpPredefinedEntryUpdate = {
  enabled: boolean;
};

export type DlpPredefinedProfile = {
  /**
   * @default false
   */
  ai_context_enabled?: boolean;
  /**
   * @format int32
   */
  allowed_match_count: number;
  /**
   * @default low
   */
  confidence_threshold?: DlpConfidence;
  context_awareness?: DlpContextAwareness;
  entries: DlpEntry[];
  /**
   * The id of the predefined profile (uuid).
   *
   * @format uuid
   */
  id: string;
  /**
   * The name of the predefined profile.
   */
  name: string;
  /**
   * @default false
   */
  ocr_enabled?: boolean;
  /**
   * Whether this profile can be accessed by anyone.
   */
  open_access?: boolean;
};

export type DlpPredefinedProfileEntryUpdate = {
  enabled: boolean;
  /**
   * @format uuid
   */
  id: string;
};

export type DlpPredefinedProfileUpdate = {
  /**
   * @default false
   */
  ai_context_enabled?: boolean;
  /**
   * @default 0
   * @example 5
   * @format int32
   * @maximum 1000
   * @minimum 0
   */
  allowed_match_count?: number | null;
  /**
   * @default low
   */
  confidence_threshold?: string | null;
  context_awareness?: DlpContextAwareness;
  /**
   * @deprecated true
   */
  entries?: DlpPredefinedProfileEntryUpdate[];
  /**
   * @default false
   */
  ocr_enabled?: boolean;
};

export type DlpProfile =
  | (DlpCustomProfile & {
      type: "custom";
    })
  | (DlpPredefinedProfile & {
      type: "predefined";
    })
  | (DlpIntegrationProfile & {
      type: "integration";
    });

export type DlpProfileArray = DlpProfile[];

export type DlpProfileEntryUpdate = DlpNewCustomEntryWithId | DlpNewCustomEntry;

export type DlpRegexValidationQuery = {
  /**
   * Maximum number of bytes that the regular expression can match.
   *
   * If this is `null` then there is no limit on the length. Patterns can use
   * `*` and `+`. Otherwise repeats should use a range `{m,n}` to restrict
   * patterns to the length. If this field is missing, then a default length
   * limit is used.
   *
   * Note that the length is specified in bytes. Since regular expressions
   * use UTF-8 the pattern `.` can match up to 4 bytes. Hence `.{1,256}`
   * has a maximum length of 1024 bytes.
   *
   * @format int32
   * @minimum 0
   */
  max_match_bytes?: number | null;
  regex: string;
};

export type DlpRegexValidationResult = {
  valid: boolean;
};

export type DlpRiskEvent = {
  event_details?: void;
  id: string;
  name: string;
  risk_level: DlpRiskLevel;
  /**
   * @format date-time
   */
  timestamp: string;
};

export type DlpRiskEvents = {
  email: string;
  events: DlpRiskEvent[];
  /**
   * @format date-time
   */
  last_reset_time?: string | null;
  name: string;
  risk_level?: DlpRiskLevel;
};

export type DlpRiskLevel = "low" | "medium" | "high";

export type DlpRiskScoreIntegration = {
  /**
   * The Cloudflare account tag.
   */
  account_tag: string;
  /**
   * Whether this integration is enabled and should export changes in risk score.
   */
  active: boolean;
  /**
   * When the integration was created in RFC3339 format.
   *
   * @format date-time
   */
  created_at: string;
  /**
   * The id of the integration, a UUIDv4.
   *
   * @format uuid
   */
  id: string;
  integration_type: DlpRiskScoreIntegrationType;
  /**
   * A reference ID defined by the client.
   * Should be set to the Access-Okta IDP integration ID.
   * Useful when the risk-score integration needs to be associated with a secondary asset and recalled using that ID.
   */
  reference_id: string;
  /**
   * The base URL for the tenant. E.g. "https://tenant.okta.com".
   */
  tenant_url: string;
  /**
   * The URL for the Shared Signals Framework configuration, e.g. "/.well-known/sse-configuration/{integration_uuid}/". https://openid.net/specs/openid-sse-framework-1_0.html#rfc.section.6.2.1.
   */
  well_known_url: string;
};

export type DlpRiskScoreIntegrationArray = DlpRiskScoreIntegration[];

export type DlpRiskScoreIntegrationType = "Okta";

export type DlpRiskSummary = {
  users: DlpUserRiskInfo[];
};

export type DlpSharedEntryUpdate =
  | {
      enabled: boolean;
      /**
       * @format uuid
       */
      entry_id: string;
      entry_type: "predefined";
    }
  | {
      enabled: boolean;
      /**
       * @format uuid
       */
      entry_id: string;
      entry_type: "integration";
    }
  | {
      enabled: boolean;
      /**
       * @format uuid
       */
      entry_id: string;
      entry_type: "exact_data";
    }
  | {
      enabled: boolean;
      /**
       * @format uuid
       */
      entry_id: string;
      entry_type: "document_fingerprint";
    };

/**
 * Content types to exclude from context analysis and return all matches.
 */
export type DlpSkipConfig = {
  /**
   * If the content type is a file, skip context analysis and return all matches.
   */
  files: boolean;
};

export type DlpUpdateAddinAccountMapping = {
  auth_requirements: DlpAddinAuth;
};

export type DlpUpdateBehavior = {
  enabled: boolean;
  risk_level: DlpRiskLevel;
};

export type DlpUpdateBehaviors = {
  behaviors: {
    [key: string]: DlpUpdateBehavior;
  };
};

export type DlpUpdateDocumentFingerprint = {
  description?: string | null;
  /**
   * @format int32
   */
  match_percent?: number | null;
  name?: string | null;
};

/**
 * Used to update multiple email rule priorities as an atomic action,
 * to support patterns such as swapping the priorities of two email rules.
 */
export type DlpUpdateEmailRulePriorities = {
  new_priorities: {
    [key: string]: number;
  };
};

export type DlpUpdateIntegrationBody = {
  /**
   * Whether this integration is enabled. If disabled, no risk changes will be exported to the third-party.
   */
  active: boolean;
  /**
   * A reference id that can be supplied by the client. Currently this should be set to the Access-Okta IDP ID (a UUIDv4).
   * https://developers.cloudflare.com/api/operations/access-identity-providers-get-an-access-identity-provider
   */
  reference_id?: string | null;
  /**
   * The base url of the tenant, e.g. "https://tenant.okta.com".
   *
   * @format uri
   */
  tenant_url: string;
};

export type DlpUserRiskInfo = {
  email: string;
  /**
   * @minimum 0
   */
  event_count: number;
  /**
   * @format date-time
   */
  last_event: string;
  max_risk_level: DlpRiskLevel;
  name: string;
  /**
   * @format uuid
   */
  user_id: string;
};

/**
 * @deprecated true
 */
export type DlpValidation = "luhn";

export type DlpWordListEntry = {
  /**
   * @format date-time
   */
  created_at: string;
  enabled: boolean;
  /**
   * @format uuid
   */
  id: string;
  name: string;
  /**
   * @format uuid
   */
  profile_id?: string | null;
  /**
   * @format date-time
   */
  updated_at: string;
  word_list: void;
};

export type DlpApiResponseCollection = DlpApiResponseCommon & {
  result_info?: {
    /**
     * Total number of results for the requested service.
     *
     * @example 1
     */
    count?: number;
    /**
     * Current page within paginated list of results.
     *
     * @example 1
     */
    page?: number;
    /**
     * Number of results per page of results.
     *
     * @example 20
     */
    per_page?: number;
    /**
     * Total results available without any search parameters.
     *
     * @example 2000
     */
    total_count?: number;
  };
};

export type DlpApiResponseCommon = {
  errors: DlpMessages;
  messages: DlpMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type DlpApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: DlpMessages;
  messages: DlpMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type DlpApiResponseSingle = DlpApiResponseCommon;

export type DlpMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

export type DlsApiResponseCollection = DlsApiResponseCommon & {
  result_info?: DlsResultInfo;
};

export type DlsApiResponseCommon = {
  errors: DlsMessages;
  messages: DlsMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type DlsApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: DlsMessages;
  messages: DlsMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

/**
 * DNS hostname to be regionalized, must be a subdomain of the zone. Wildcards are supported for one level, e.g `*.example.com`
 *
 * @example foo.example.com
 */
export type DlsHostname = string;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type DlsIdentifier = string;

export type DlsMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * Identifying key for the region
 *
 * @example ca
 */
export type DlsRegionKey = string;

export type DlsRegionalHostnameResponse = {
  /**
   * When the regional hostname was created
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  created_on: DlsTimestamp & void & void;
  hostname: DlsHostname;
  region_key: DlsRegionKey;
  routing?: DlsRouting;
};

export type DlsResultInfo = {
  /**
   * Total number of results for the requested service.
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results.
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results.
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters.
   *
   * @example 2000
   */
  total_count?: number;
};

/**
 * Configure which routing method to use for the regional hostname
 */
export type DlsRouting = string;

/**
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 */
export type DlsTimestamp = string;

export type DnsAnalyticsApiResponseCommon = {
  errors: DnsAnalyticsMessages;
  messages: DnsAnalyticsMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type DnsAnalyticsApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: DnsAnalyticsMessages;
  messages: DnsAnalyticsMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type DnsAnalyticsApiResponseSingle = DnsAnalyticsApiResponseCommon;

/**
 * Array with one row per combination of dimension values.
 */
export type DnsAnalyticsData = {
  /**
   * Array of dimension values, representing the combination of dimension values corresponding to this row.
   */
  dimensions: string[];
}[];

/**
 * A comma-separated list of dimensions to group results by.
 *
 * @example queryType
 */
export type DnsAnalyticsDimensions = string;

/**
 * Segmentation filter in 'attribute operator value' format.
 *
 * @example responseCode==NOERROR,queryType==A
 */
export type DnsAnalyticsFilters = string;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type DnsAnalyticsIdentifier = string;

/**
 * Limit number of returned metrics.
 *
 * @default 100000
 * @example 100
 */
export type DnsAnalyticsLimit = number;

export type DnsAnalyticsMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * A comma-separated list of metrics to query.
 *
 * @example queryCount,uncachedCount
 */
export type DnsAnalyticsMetrics = string;

export type DnsAnalyticsQuery = {
  /**
   * Array of dimension names.
   *
   * @example responseCode
   * @example queryName
   */
  dimensions: string[];
  filters?: DnsAnalyticsFilters;
  limit: DnsAnalyticsLimit;
  /**
   * Array of metric names.
   *
   * @example queryCount
   * @example responseTimeAvg
   */
  metrics: string[];
  since: DnsAnalyticsSince;
  /**
   * Array of dimensions to sort by, where each dimension may be prefixed by - (descending) or + (ascending).
   *
   * @example +responseCode
   * @example -queryName
   */
  sort?: string[];
  until: DnsAnalyticsUntil;
};

export type DnsAnalyticsReport = {
  data: DnsAnalyticsData;
  /**
   * Number of seconds between current time and last processed event, in another words how many seconds of data could be missing.
   *
   * @example 60
   * @minimum 0
   */
  data_lag: number;
  /**
   * Maximum results for each metric (object mapping metric names to values). Currently always an empty object.
   */
  max: Record<string, any>;
  /**
   * Minimum results for each metric (object mapping metric names to values). Currently always an empty object.
   */
  min: Record<string, any>;
  query: DnsAnalyticsQuery;
  /**
   * Total number of rows in the result.
   *
   * @example 100
   * @minimum 0
   */
  rows?: number;
  /**
   * Total results for metrics across all data (object mapping metric names to values).
   */
  totals: Record<string, any>;
};

export type DnsAnalyticsReportBytime = {
  data: DnsAnalyticsData;
  /**
   * Number of seconds between current time and last processed event, in another words how many seconds of data could be missing.
   *
   * @example 60
   * @minimum 0
   */
  data_lag: number;
  /**
   * Maximum results for each metric (object mapping metric names to values). Currently always an empty object.
   */
  max: Record<string, any>;
  /**
   * Minimum results for each metric (object mapping metric names to values). Currently always an empty object.
   */
  min?: Record<string, any>;
  query: DnsAnalyticsQuery;
  /**
   * Total number of rows in the result.
   *
   * @example 100
   * @minimum 0
   */
  rows?: number;
  /**
   * Total results for metrics across all data (object mapping metric names to values).
   */
  totals?: Record<string, any>;
  /**
   * Array of time intervals in the response data. Each interval is represented as an array containing two values: the start time, and the end time.
   */
  time_intervals: string[][];
};

export type DnsAnalyticsResult = {
  data: DnsAnalyticsData;
  /**
   * Number of seconds between current time and last processed event, in another words how many seconds of data could be missing.
   *
   * @example 60
   * @minimum 0
   */
  data_lag: number;
  /**
   * Maximum results for each metric (object mapping metric names to values). Currently always an empty object.
   */
  max: Record<string, any>;
  /**
   * Minimum results for each metric (object mapping metric names to values). Currently always an empty object.
   */
  min: Record<string, any>;
  query: DnsAnalyticsQuery;
  /**
   * Total number of rows in the result.
   *
   * @example 100
   * @minimum 0
   */
  rows: number;
  /**
   * Total results for metrics across all data (object mapping metric names to values).
   */
  totals: Record<string, any>;
};

/**
 * Start date and time of requesting data period in ISO 8601 format.
 *
 * @example 2023-11-11T12:00:00Z
 * @format date-time
 */
export type DnsAnalyticsSince = string;

/**
 * A comma-separated list of dimensions to sort by, where each dimension may be prefixed by - (descending) or + (ascending).
 *
 * @example +responseCode,-queryName
 */
export type DnsAnalyticsSort = string;

/**
 * Unit of time to group data by.
 *
 * @example hour
 */
export type DnsAnalyticsTimeDelta =
  | "all"
  | "auto"
  | "year"
  | "quarter"
  | "month"
  | "week"
  | "day"
  | "hour"
  | "dekaminute"
  | "minute";

/**
 * End date and time of requesting data period in ISO 8601 format.
 *
 * @example 2023-11-11T13:00:00Z
 * @format date-time
 */
export type DnsAnalyticsUntil = string;

/**
 * A single account custom nameserver.
 */
export type DnsCustomNameserversCustomNS = {
  /**
   * A and AAAA records associated with the nameserver.
   */
  dns_records: {
    /**
     * DNS record type.
     *
     * @example A
     * @x-auditable true
     */
    type?: "A" | "AAAA";
    /**
     * DNS record contents (an IPv4 or IPv6 address).
     *
     * @example 1.1.1.1
     * @x-auditable true
     */
    value?: string;
  }[];
  ns_name: DnsCustomNameserversNsName;
  ns_set?: DnsCustomNameserversNsSet;
  /**
   * Verification status of the nameserver.
   *
   * @deprecated true
   * @example verified
   * @x-auditable true
   */
  status: "moved" | "pending" | "verified";
  zone_tag: DnsCustomNameserversSchemasIdentifier;
};

export type DnsCustomNameserversCustomNSInput = {
  ns_name: DnsCustomNameserversNsName;
  ns_set?: DnsCustomNameserversNsSet;
};

export type DnsCustomNameserversAcnsResponseCollection =
  DnsCustomNameserversApiResponseCollection & {
    result?: DnsCustomNameserversCustomNS[];
  };

export type DnsCustomNameserversAcnsResponseSingle =
  DnsCustomNameserversApiResponseSingle & {
    result?: DnsCustomNameserversCustomNS;
  };

export type DnsCustomNameserversApiResponseCollection =
  DnsCustomNameserversApiResponseCommon & {
    result_info?: DnsCustomNameserversResultInfo;
  };

export type DnsCustomNameserversApiResponseCommon = {
  errors: DnsCustomNameserversMessages;
  messages: DnsCustomNameserversMessages;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type DnsCustomNameserversApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: DnsCustomNameserversMessages;
  messages: DnsCustomNameserversMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

export type DnsCustomNameserversApiResponseSingle =
  DnsCustomNameserversApiResponseCommon;

export type DnsCustomNameserversEmptyResponse =
  DnsCustomNameserversApiResponseCollection & {
    /**
     * @maxItems 0
     */
    result?: string[];
  };

export type DnsCustomNameserversGetResponse =
  DnsCustomNameserversApiResponseCollection & DnsCustomNameserversZoneMetadata;

/**
 * Account identifier tag.
 *
 * @example 372e67954025e0ba6aaa6d586b9e0b59
 * @maxLength 32
 * @x-auditable true
 */
export type DnsCustomNameserversIdentifier = string;

export type DnsCustomNameserversMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * The FQDN of the name server.
 *
 * @example ns1.example.com
 * @format hostname
 * @x-auditable true
 */
export type DnsCustomNameserversNsName = string;

/**
 * The number of the set that this name server belongs to.
 *
 * @default 1
 * @example 1
 * @maximum 5
 * @minimum 1
 * @x-auditable true
 */
export type DnsCustomNameserversNsSet = number;

export type DnsCustomNameserversResultInfo = {
  /**
   * Total number of results for the requested service
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters
   *
   * @example 2000
   */
  total_count?: number;
};

export type DnsCustomNameserversSchemasEmptyResponse =
  DnsCustomNameserversApiResponseCollection & {
    /**
     * @maxItems 0
     */
    result?: string[];
  };

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type DnsCustomNameserversSchemasIdentifier = string;

export type DnsCustomNameserversZoneMetadata = {
  /**
   * Whether zone uses account-level custom nameservers.
   *
   * @example true
   * @x-auditable true
   */
  enabled?: boolean;
  /**
   * The number of the name server set to assign to the zone.
   *
   * @default 1
   * @example 1
   * @maximum 5
   * @minimum 1
   * @x-auditable true
   */
  ns_set?: number;
};

export type DnsFirewallApiResponseCollection = DnsFirewallApiResponseCommon & {
  result_info?: {
    /**
     * Total number of results for the requested service.
     *
     * @example 1
     */
    count?: number;
    /**
     * Current page within paginated list of results.
     *
     * @example 1
     */
    page?: number;
    /**
     * Number of results per page of results.
     *
     * @example 20
     */
    per_page?: number;
    /**
     * Total results available without any search parameters.
     *
     * @example 2000
     */
    total_count?: number;
  };
};

export type DnsFirewallApiResponseCommon = {
  errors: DnsFirewallMessages;
  messages: DnsFirewallMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type DnsFirewallApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: DnsFirewallMessages;
  messages: DnsFirewallMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type DnsFirewallApiResponseSingle = DnsFirewallApiResponseCommon;

/**
 * Attack mitigation settings
 */
export type DnsFirewallAttackMitigation = {
  /**
   * When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
   *
   * @example true
   * @x-auditable true
   */
  enabled?: boolean;
  /**
   * Only mitigate attacks when upstream servers seem unhealthy
   *
   * @default true
   * @example false
   * @x-auditable true
   */
  only_when_upstream_unhealthy?: boolean;
} | null;

/**
 * Whether to refuse to answer queries for the ANY type
 *
 * @example true
 * @x-auditable true
 */
export type DnsFirewallDeprecateAnyRequests = boolean;

export type DnsFirewallDnsFirewallCluster = {
  attack_mitigation?: DnsFirewallAttackMitigation;
  deprecate_any_requests?: DnsFirewallDeprecateAnyRequests;
  ecs_fallback?: DnsFirewallEcsFallback;
  maximum_cache_ttl?: DnsFirewallMaximumCacheTtl;
  minimum_cache_ttl?: DnsFirewallMinimumCacheTtl;
  name?: DnsFirewallName;
  negative_cache_ttl?: DnsFirewallNegativeCacheTtl;
  ratelimit?: DnsFirewallRatelimit;
  retries?: DnsFirewallRetries;
  upstream_ips?: DnsFirewallUpstreamIps;
};

export type DnsFirewallDnsFirewallClusterPatch = DnsFirewallDnsFirewallCluster;

export type DnsFirewallDnsFirewallClusterPost = DnsFirewallDnsFirewallCluster;

export type DnsFirewallDnsFirewallClusterResponse =
  DnsFirewallDnsFirewallCluster & {
    dns_firewall_ips: DnsFirewallDnsFirewallIps;
    id: DnsFirewallIdentifier;
    modified_on: DnsFirewallModifiedOn;
  };

export type DnsFirewallDnsFirewallReverseDns = {
  /**
   * Map of cluster IP addresses to PTR record contents
   */
  ptr?: {
    [key: string]: string;
  };
};

export type DnsFirewallDnsFirewallReverseDnsPatch =
  DnsFirewallDnsFirewallReverseDns;

export type DnsFirewallDnsFirewallReverseDnsResponse =
  DnsFirewallDnsFirewallReverseDns;

/**
 * @example 203.0.113.1
 * @example 203.0.113.254
 * @example 2001:DB8:AB::CF
 * @example 2001:DB8:CD::CF
 */
export type DnsFirewallDnsFirewallIps = (string | string)[];

export type DnsFirewallDnsFirewallResponseCollection =
  DnsFirewallApiResponseCollection & {
    result?: DnsFirewallDnsFirewallClusterResponse[];
  };

export type DnsFirewallDnsFirewallSingleResponse =
  DnsFirewallApiResponseSingle & {
    result?: DnsFirewallDnsFirewallClusterResponse;
  };

/**
 * Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
 *
 * @example false
 * @x-auditable true
 */
export type DnsFirewallEcsFallback = boolean;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type DnsFirewallIdentifier = string;

/**
 * Maximum DNS cache TTL This setting sets an upper bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Higher TTLs will be decreased to the maximum defined here for caching purposes.
 *
 * @default 900
 * @example 900
 * @maximum 36000
 * @minimum 30
 * @x-auditable true
 */
export type DnsFirewallMaximumCacheTtl = number;

export type DnsFirewallMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * Minimum DNS cache TTL This setting sets a lower bound on DNS TTLs for purposes of caching between DNS Firewall and the upstream servers. Lower TTLs will be increased to the minimum defined here for caching purposes.
 *
 * @default 60
 * @example 60
 * @maximum 36000
 * @minimum 30
 * @x-auditable true
 */
export type DnsFirewallMinimumCacheTtl = number;

/**
 * Last modification of DNS Firewall cluster
 *
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type DnsFirewallModifiedOn = string;

/**
 * DNS Firewall cluster name
 *
 * @example My Awesome DNS Firewall cluster
 * @maxLength 160
 * @minLength 1
 * @x-auditable true
 */
export type DnsFirewallName = string;

/**
 * Negative DNS cache TTL This setting controls how long DNS Firewall should cache negative responses (e.g., NXDOMAIN) from the upstream servers.
 *
 * @example 900
 * @maximum 36000
 * @minimum 30
 * @x-auditable true
 */
export type DnsFirewallNegativeCacheTtl = number | null;

/**
 * Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
 *
 * @example 600
 * @maximum 1000000000
 * @minimum 100
 * @x-auditable true
 */
export type DnsFirewallRatelimit = number | null;

/**
 * Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
 *
 * @default 2
 * @example 2
 * @maximum 2
 * @minimum 0
 * @x-auditable true
 */
export type DnsFirewallRetries = number;

/**
 * @example 192.0.2.1
 * @example 198.51.100.1
 * @example 2001:DB8:100::CF
 * @minLength 1
 */
export type DnsFirewallUpstreamIps = (string | string)[];

export type DnsRecordsAAAARecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * A valid IPv6 address.
   *
   * @example 2400:cb00:2049::1
   * @format ipv6
   * @x-auditable true
   */
  content?: string;
  /**
   * Record type.
   *
   * @example AAAA
   * @x-auditable true
   */
  type?: "AAAA";
};

export type DnsRecordsARecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * A valid IPv4 address.
   *
   * @example 198.51.100.4
   * @format ipv4
   * @x-auditable true
   */
  content?: string;
  /**
   * Record type.
   *
   * @example A
   * @x-auditable true
   */
  type?: "A";
};

export type DnsRecordsCAARecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * Formatted CAA content. See 'data' to set CAA properties.
   *
   * @x-auditable true
   */
  content?: string;
  /**
   * Components of a CAA record.
   */
  data?: {
    /**
     * Flags for the CAA record.
     *
     * @example 1
     * @maximum 255
     * @minimum 0
     * @x-auditable true
     */
    flags?: number;
    /**
     * Name of the property controlled by this record (e.g.: issue, issuewild, iodef).
     *
     * @example issue
     * @x-auditable true
     */
    tag?: string;
    /**
     * Value of the record. This field's semantics depend on the chosen tag.
     *
     * @x-auditable true
     */
    value?: string;
  };
  /**
   * Record type.
   *
   * @example CAA
   * @x-auditable true
   */
  type?: "CAA";
};

export type DnsRecordsCERTRecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * Formatted CERT content. See 'data' to set CERT properties.
   */
  content?: string;
  /**
   * Components of a CERT record.
   */
  data?: {
    /**
     * Algorithm.
     *
     * @example 8
     * @maximum 255
     * @minimum 0
     */
    algorithm?: number;
    /**
     * Certificate.
     */
    certificate?: string;
    /**
     * Key Tag.
     *
     * @example 1
     * @maximum 65535
     * @minimum 0
     */
    key_tag?: number;
    /**
     * Type.
     *
     * @example 9
     * @maximum 65535
     * @minimum 0
     */
    type?: number;
  };
  /**
   * Record type.
   *
   * @example CERT
   * @x-auditable true
   */
  type?: "CERT";
};

export type DnsRecordsCNAMERecord = {
  comment?: DnsRecordsComment;
  name?: DnsRecordsName;
  proxied?: DnsRecordsProxied;
  settings?: DnsRecordsSettings;
  tags?: DnsRecordsTags;
  ttl?: DnsRecordsTtl;
  /**
   * A valid hostname. Must not match the record's name.
   *
   * @x-auditable true
   */
  content?: string;
  /**
   * Record type.
   *
   * @example CNAME
   * @x-auditable true
   */
  type?: "CNAME";
};

export type DnsRecordsDNSKEYRecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * Formatted DNSKEY content. See 'data' to set DNSKEY properties.
   */
  content?: string;
  /**
   * Components of a DNSKEY record.
   */
  data?: {
    /**
     * Algorithm.
     *
     * @example 5
     * @maximum 255
     * @minimum 0
     */
    algorithm?: number;
    /**
     * Flags.
     *
     * @example 1
     * @maximum 65535
     * @minimum 0
     */
    flags?: number;
    /**
     * Protocol.
     *
     * @example 3
     * @maximum 255
     * @minimum 0
     */
    protocol?: number;
    /**
     * Public Key.
     */
    public_key?: string;
  };
  /**
   * Record type.
   *
   * @example DNSKEY
   * @x-auditable true
   */
  type?: "DNSKEY";
};

export type DnsRecordsDSRecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * Formatted DS content. See 'data' to set DS properties.
   */
  content?: string;
  /**
   * Components of a DS record.
   */
  data?: {
    /**
     * Algorithm.
     *
     * @example 3
     * @maximum 255
     * @minimum 0
     */
    algorithm?: number;
    /**
     * Digest.
     */
    digest?: string;
    /**
     * Digest Type.
     *
     * @example 1
     * @maximum 255
     * @minimum 0
     */
    digest_type?: number;
    /**
     * Key Tag.
     *
     * @example 1
     * @maximum 65535
     * @minimum 0
     */
    key_tag?: number;
  };
  /**
   * Record type.
   *
   * @example DS
   * @x-auditable true
   */
  type?: "DS";
};

export type DnsRecordsHTTPSRecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * Formatted HTTPS content. See 'data' to set HTTPS properties.
   */
  content?: string;
  /**
   * Components of a HTTPS record.
   */
  data?: {
    /**
     * priority.
     *
     * @example 1
     * @maximum 65535
     * @minimum 0
     */
    priority?: number;
    /**
     * target.
     *
     * @example .
     */
    target?: string;
    /**
     * value.
     *
     * @example alpn="h3,h2" ipv4hint="127.0.0.1" ipv6hint="::1"
     */
    value?: string;
  };
  /**
   * Record type.
   *
   * @example HTTPS
   * @x-auditable true
   */
  type?: "HTTPS";
};

export type DnsRecordsLOCRecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * Formatted LOC content. See 'data' to set LOC properties.
   *
   * @example IN LOC 37 46 46 N 122 23 35 W 0m 100m 0m 0m
   */
  content?: string;
  /**
   * Components of a LOC record.
   */
  data?: {
    /**
     * Altitude of location in meters.
     *
     * @example 0
     * @maximum 42849672.95
     * @minimum -100000
     */
    altitude?: number;
    /**
     * Degrees of latitude.
     *
     * @example 37
     * @maximum 90
     * @minimum 0
     */
    lat_degrees?: number;
    /**
     * Latitude direction.
     *
     * @example N
     */
    lat_direction?: "N" | "S";
    /**
     * Minutes of latitude.
     *
     * @example 46
     * @maximum 59
     * @minimum 0
     */
    lat_minutes?: number;
    /**
     * Seconds of latitude.
     *
     * @example 46
     * @maximum 59.999
     * @minimum 0
     */
    lat_seconds?: number;
    /**
     * Degrees of longitude.
     *
     * @example 122
     * @maximum 180
     * @minimum 0
     */
    long_degrees?: number;
    /**
     * Longitude direction.
     *
     * @example W
     */
    long_direction?: "E" | "W";
    /**
     * Minutes of longitude.
     *
     * @example 23
     * @maximum 59
     * @minimum 0
     */
    long_minutes?: number;
    /**
     * Seconds of longitude.
     *
     * @example 35
     * @maximum 59.999
     * @minimum 0
     */
    long_seconds?: number;
    /**
     * Horizontal precision of location.
     *
     * @example 0
     * @maximum 90000000
     * @minimum 0
     */
    precision_horz?: number;
    /**
     * Vertical precision of location.
     *
     * @example 0
     * @maximum 90000000
     * @minimum 0
     */
    precision_vert?: number;
    /**
     * Size of location in meters.
     *
     * @example 100
     * @maximum 90000000
     * @minimum 0
     */
    size?: number;
  };
  /**
   * Record type.
   *
   * @example LOC
   * @x-auditable true
   */
  type?: "LOC";
};

export type DnsRecordsMXRecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * A valid mail server hostname.
   *
   * @example mx.example.com
   * @format hostname
   * @x-auditable true
   */
  content?: string;
  priority?: DnsRecordsPriority;
  /**
   * Record type.
   *
   * @example MX
   * @x-auditable true
   */
  type?: "MX";
};

export type DnsRecordsNAPTRRecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * Formatted NAPTR content. See 'data' to set NAPTR properties.
   */
  content?: string;
  /**
   * Components of a NAPTR record.
   */
  data?: {
    /**
     * Flags.
     */
    flags?: string;
    /**
     * Order.
     *
     * @example 100
     * @maximum 65535
     * @minimum 0
     */
    order?: number;
    /**
     * Preference.
     *
     * @example 10
     * @maximum 65535
     * @minimum 0
     */
    preference?: number;
    /**
     * Regex.
     */
    regex?: string;
    /**
     * Replacement.
     */
    replacement?: string;
    /**
     * Service.
     */
    service?: string;
  };
  /**
   * Record type.
   *
   * @example NAPTR
   * @x-auditable true
   */
  type?: "NAPTR";
};

export type DnsRecordsNSRecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * A valid name server host name.
   *
   * @example ns1.example.com
   * @x-auditable true
   */
  content?: string;
  /**
   * Record type.
   *
   * @example NS
   * @x-auditable true
   */
  type?: "NS";
};

export type DnsRecordsOPENPGPKEYRecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * A single Base64-encoded OpenPGP Transferable Public Key (RFC 4880 Section 11.1)
   */
  content?: string;
  /**
   * Record type.
   *
   * @example OPENPGPKEY
   * @x-auditable true
   */
  type?: "OPENPGPKEY";
};

export type DnsRecordsPTRRecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * Domain name pointing to the address.
   *
   * @example example.com
   * @x-auditable true
   */
  content?: string;
  /**
   * Record type.
   *
   * @example PTR
   * @x-auditable true
   */
  type?: "PTR";
};

export type DnsRecordsSMIMEARecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * Formatted SMIMEA content. See 'data' to set SMIMEA properties.
   */
  content?: string;
  /**
   * Components of a SMIMEA record.
   */
  data?: {
    /**
     * Certificate.
     */
    certificate?: string;
    /**
     * Matching Type.
     *
     * @example 0
     * @maximum 255
     * @minimum 0
     */
    matching_type?: number;
    /**
     * Selector.
     *
     * @example 0
     * @maximum 255
     * @minimum 0
     */
    selector?: number;
    /**
     * Usage.
     *
     * @example 3
     * @maximum 255
     * @minimum 0
     */
    usage?: number;
  };
  /**
   * Record type.
   *
   * @example SMIMEA
   * @x-auditable true
   */
  type?: "SMIMEA";
};

export type DnsRecordsSRVRecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * Priority, weight, port, and SRV target. See 'data' for setting the individual component values.
   *
   * @example 10 IN SRV 5 8806 example.com.
   */
  content?: string;
  /**
   * Components of a SRV record.
   */
  data?: {
    /**
     * The port of the service.
     *
     * @example 8806
     * @maximum 65535
     * @minimum 0
     */
    port?: number;
    priority?: DnsRecordsPriority;
    /**
     * A valid hostname.
     *
     * @example example.com
     * @format hostname
     */
    target?: string;
    /**
     * The record weight.
     *
     * @example 5
     * @maximum 65535
     * @minimum 0
     */
    weight?: number;
  };
  /**
   * Record type.
   *
   * @example SRV
   * @x-auditable true
   */
  type?: "SRV";
};

export type DnsRecordsSSHFPRecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * Formatted SSHFP content. See 'data' to set SSHFP properties.
   */
  content?: string;
  /**
   * Components of a SSHFP record.
   */
  data?: {
    /**
     * algorithm.
     *
     * @example 2
     * @maximum 255
     * @minimum 0
     */
    algorithm?: number;
    /**
     * fingerprint.
     */
    fingerprint?: string;
    /**
     * type.
     *
     * @example 1
     * @maximum 255
     * @minimum 0
     */
    type?: number;
  };
  /**
   * Record type.
   *
   * @example SSHFP
   * @x-auditable true
   */
  type?: "SSHFP";
};

export type DnsRecordsSVCBRecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * Formatted SVCB content. See 'data' to set SVCB properties.
   */
  content?: string;
  /**
   * Components of a SVCB record.
   */
  data?: {
    /**
     * priority.
     *
     * @example 1
     * @maximum 65535
     * @minimum 0
     */
    priority?: number;
    /**
     * target.
     *
     * @example .
     */
    target?: string;
    /**
     * value.
     *
     * @example alpn="h3,h2" ipv4hint="127.0.0.1" ipv6hint="::1"
     */
    value?: string;
  };
  /**
   * Record type.
   *
   * @example SVCB
   * @x-auditable true
   */
  type?: "SVCB";
};

export type DnsRecordsTLSARecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * Formatted TLSA content. See 'data' to set TLSA properties.
   */
  content?: string;
  /**
   * Components of a TLSA record.
   */
  data?: {
    /**
     * certificate.
     */
    certificate?: string;
    /**
     * Matching Type.
     *
     * @example 1
     * @maximum 255
     * @minimum 0
     */
    matching_type?: number;
    /**
     * Selector.
     *
     * @example 0
     * @maximum 255
     * @minimum 0
     */
    selector?: number;
    /**
     * Usage.
     *
     * @example 0
     * @maximum 255
     * @minimum 0
     */
    usage?: number;
  };
  /**
   * Record type.
   *
   * @example TLSA
   * @x-auditable true
   */
  type?: "TLSA";
};

export type DnsRecordsTXTRecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * Text content for the record. The content must consist of quoted "character strings" (RFC 1035), each with a length of up to 255 bytes. Strings exceeding this allowed maximum length are automatically split.
   *
   * Learn more at <https://www.cloudflare.com/learning/dns/dns-records/dns-txt-record/>.
   *
   * @example "v=spf1 include:example.com -all"
   */
  content?: string;
  /**
   * Record type.
   *
   * @example TXT
   * @x-auditable true
   */
  type?: "TXT";
};

export type DnsRecordsURIRecord = DnsRecordsDnsRecordSharedFields & {
  /**
   * Formatted URI content. See 'data' to set URI properties.
   */
  content?: string;
  /**
   * Components of a URI record.
   */
  data?: {
    /**
     * The record content.
     *
     * @example http://example.com/example.html
     */
    target?: string;
    /**
     * The record weight.
     *
     * @example 20
     * @maximum 65535
     * @minimum 0
     */
    weight?: number;
  };
  priority?: DnsRecordsPriority;
  /**
   * Record type.
   *
   * @example URI
   * @x-auditable true
   */
  type?: "URI";
};

export type DnsRecordsApiResponseCollection = DnsRecordsApiResponseCommon & {
  result_info?: {
    /**
     * Total number of results for the requested service.
     *
     * @example 1
     */
    count?: number;
    /**
     * Current page within paginated list of results.
     *
     * @example 1
     */
    page?: number;
    /**
     * Number of results per page of results.
     *
     * @example 20
     */
    per_page?: number;
    /**
     * Total results available without any search parameters.
     *
     * @example 2000
     */
    total_count?: number;
  };
};

export type DnsRecordsApiResponseCommon = {
  errors: DnsRecordsMessages;
  messages: DnsRecordsMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type DnsRecordsApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: DnsRecordsMessages;
  messages: DnsRecordsMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type DnsRecordsApiResponseSingle = DnsRecordsApiResponseCommon;

/**
 * Comments or notes about the DNS record. This field has no effect on DNS responses.
 *
 * @example Domain verification record
 * @x-auditable true
 */
export type DnsRecordsComment = string;

/**
 * Direction to order DNS records in.
 *
 * @default asc
 */
export type DnsRecordsDirection = "asc" | "desc";

export type DnsRecordsDnsRecordBatchDelete = {
  id?: DnsRecordsIdentifier;
};

export type DnsRecordsDnsRecordBatchPatch = DnsRecordsDnsRecordPatch & {
  id: DnsRecordsIdentifier;
};

export type DnsRecordsDnsRecordBatchPost = DnsRecordsDnsRecordPost;

export type DnsRecordsDnsRecordBatchPut = DnsRecordsDnsRecordPost & {
  id: DnsRecordsIdentifier;
};

export type DnsRecordsDnsRecordPatch =
  | DnsRecordsDnsRecordWithoutData
  | DnsRecordsDnsRecordWithData;

export type DnsRecordsDnsRecordPost =
  | DnsRecordsDnsRecordWithoutData
  | DnsRecordsDnsRecordWithData;

export type DnsRecordsDnsRecordResponse =
  | DnsRecordsDnsRecordWithoutData
  | DnsRecordsDnsRecordWithData;

export type DnsRecordsDnsRecordSharedFields = {
  comment?: DnsRecordsComment;
  name?: DnsRecordsName;
  proxied?: DnsRecordsProxied;
  settings?: DnsRecordsSettings;
  tags?: DnsRecordsTags;
  ttl?: DnsRecordsTtl;
};

export type DnsRecordsDnsRecordWithData =
  | DnsRecordsCAARecord
  | DnsRecordsCERTRecord
  | DnsRecordsDNSKEYRecord
  | DnsRecordsDSRecord
  | DnsRecordsHTTPSRecord
  | DnsRecordsLOCRecord
  | DnsRecordsNAPTRRecord
  | DnsRecordsSMIMEARecord
  | DnsRecordsSRVRecord
  | DnsRecordsSSHFPRecord
  | DnsRecordsSVCBRecord
  | DnsRecordsTLSARecord
  | DnsRecordsURIRecord;

export type DnsRecordsDnsRecordWithoutData =
  | DnsRecordsARecord
  | DnsRecordsAAAARecord
  | DnsRecordsCNAMERecord
  | DnsRecordsMXRecord
  | DnsRecordsNSRecord
  | DnsRecordsOPENPGPKEYRecord
  | DnsRecordsPTRRecord
  | DnsRecordsTXTRecord;

export type DnsRecordsDnsRequestBatchObject = {
  deletes?: DnsRecordsDnsRecordBatchDelete[];
  patches?: DnsRecordsDnsRecordBatchPatch[];
  posts?: DnsRecordsDnsRecordBatchPost[];
  puts?: DnsRecordsDnsRecordBatchPut[];
};

export type DnsRecordsDnsResponseBatchObject = {
  deletes?: DnsRecordsDnsRecordResponse[];
  patches?: DnsRecordsDnsRecordResponse[];
  posts?: DnsRecordsDnsRecordResponse[];
  puts?: DnsRecordsDnsRecordResponse[];
};

export type DnsRecordsDnsResponseBatch = DnsRecordsApiResponseSingle & {
  result?: DnsRecordsDnsResponseBatchObject;
};

export type DnsRecordsDnsResponseCollection =
  DnsRecordsApiResponseCollection & {
    result?: DnsRecordsDnsRecordResponse[];
  };

export type DnsRecordsDnsResponseImportScan = DnsRecordsApiResponseSingle & {
  result?: {
    /**
     * Number of DNS records added.
     *
     * @example 5
     */
    recs_added?: number;
    /**
     * Total number of DNS records parsed.
     *
     * @example 5
     */
    total_records_parsed?: number;
  };
};

export type DnsRecordsDnsResponseSingle = DnsRecordsApiResponseSingle & {
  result?: DnsRecordsDnsRecordResponse;
};

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type DnsRecordsIdentifier = string;

/**
 * Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead. Note that the interaction between tag filters is controlled by the `tag-match` parameter instead.
 *
 * @default all
 * @example any
 */
export type DnsRecordsMatch = "any" | "all";

export type DnsRecordsMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * Complete DNS record name, including the zone name, in Punycode.
 *
 * @example example.com
 * @maxLength 255
 * @minLength 1
 */
export type DnsRecordsName = string;

/**
 * Field to order DNS records by.
 *
 * @default type
 */
export type DnsRecordsOrder = "type" | "name" | "content" | "ttl" | "proxied";

/**
 * Page number of paginated results.
 *
 * @default 1
 * @minimum 1
 */
export type DnsRecordsPage = number;

/**
 * Number of DNS records per page.
 *
 * @default 100
 * @example 5
 * @maximum 5000000
 * @minimum 1
 */
export type DnsRecordsPerPage = number;

/**
 * Required for MX, SRV and URI records; unused by other record types. Records with lower priorities are preferred.
 *
 * @example 10
 * @maximum 65535
 * @minimum 0
 * @x-auditable true
 */
export type DnsRecordsPriority = number;

/**
 * Whether the record is receiving the performance and security benefits of Cloudflare.
 *
 * @default false
 * @example true
 */
export type DnsRecordsProxied = boolean;

/**
 * Allows searching in multiple properties of a DNS record simultaneously. This parameter is intended for human users, not automation. Its exact behavior is intentionally left unspecified and is subject to change in the future. This parameter works independently of the `match` setting. For automated searches, please use the other available parameters.
 *
 * @example www.cloudflare.com
 */
export type DnsRecordsSearch = string;

/**
 * Settings for the DNS record.
 */
export type DnsRecordsSettings = {
  /**
   * When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
   *
   * @default false
   * @example true
   * @x-auditable true
   */
  ipv4_only?: boolean;
  /**
   * When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
   *
   * @default false
   * @example true
   * @x-auditable true
   */
  ipv6_only?: boolean;
};

/**
 * Whether to match all tag search requirements or at least one (any). If set to `all`, acts like a logical AND between tag filters. If set to `any`, acts like a logical OR instead. Note that the regular `match` parameter is still used to combine the resulting condition with other filters that aren't related to tags.
 *
 * @default all
 * @example any
 */
export type DnsRecordsTagMatch = "any" | "all";

/**
 * Custom tags for the DNS record. This field has no effect on DNS responses.
 */
export type DnsRecordsTags = string[];

/**
 * Time To Live (TTL) of the DNS record in seconds. Setting to 1 means 'automatic'. Value must be between 60 and 86400, with the minimum reduced to 30 for Enterprise zones.
 *
 * @default 1
 * @example 3600
 */
export type DnsRecordsTtl = number | 1;

/**
 * Record type.
 *
 * @example A
 */
export type DnsRecordsType =
  | "A"
  | "AAAA"
  | "CAA"
  | "CERT"
  | "CNAME"
  | "DNSKEY"
  | "DS"
  | "HTTPS"
  | "LOC"
  | "MX"
  | "NAPTR"
  | "NS"
  | "OPENPGPKEY"
  | "PTR"
  | "SMIMEA"
  | "SRV"
  | "SSHFP"
  | "SVCB"
  | "TLSA"
  | "TXT"
  | "URI";

export type DnsSettingsAccountSettings = {
  zone_defaults?: DnsSettingsDnsSettingsAccount;
};

export type DnsSettingsApiResponseCollection = DnsSettingsApiResponseCommon & {
  result_info?: {
    /**
     * Total number of results for the requested service.
     *
     * @example 1
     */
    count?: number;
    /**
     * Current page within paginated list of results.
     *
     * @example 1
     */
    page?: number;
    /**
     * Number of results per page of results.
     *
     * @example 20
     */
    per_page?: number;
    /**
     * Total results available without any search parameters.
     *
     * @example 2000
     */
    total_count?: number;
  };
};

export type DnsSettingsApiResponseCommon = {
  errors: DnsSettingsMessages;
  messages: DnsSettingsMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type DnsSettingsApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: DnsSettingsMessages;
  messages: DnsSettingsMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type DnsSettingsApiResponseSingle = DnsSettingsApiResponseCommon;

/**
 * When the view was created.
 *
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type DnsSettingsCreatedTime = string;

/**
 * Direction to order DNS views in.
 *
 * @default asc
 */
export type DnsSettingsDirection = "asc" | "desc";

export type DnsSettingsDnsSettings = {
  flatten_all_cnames?: DnsSettingsFlattenAllCnames;
  foundation_dns?: DnsSettingsFoundationDns;
  internal_dns?: DnsSettingsInternalDns;
  multi_provider?: DnsSettingsMultiProvider;
  ns_ttl?: DnsSettingsNsTtl;
  secondary_overrides?: DnsSettingsSecondaryOverrides;
  soa?: DnsSettingsSoa;
  zone_mode?: DnsSettingsZoneMode;
};

export type DnsSettingsDnsSettingsAccount = DnsSettingsDnsSettings & {
  /**
   * Settings determining the nameservers through which the zone should be available.
   */
  nameservers?: {
    /**
     * Nameserver type
     *
     * @example cloudflare.standard
     * @x-auditable true
     */
    type:
      | "cloudflare.standard"
      | "cloudflare.standard.random"
      | "custom.account"
      | "custom.tenant";
  };
};

export type DnsSettingsDnsSettingsZone = DnsSettingsDnsSettings & {
  /**
   * Settings determining the nameservers through which the zone should be available.
   */
  nameservers?: {
    /**
     * Configured nameserver set to be used for this zone
     *
     * @example 1
     * @maximum 5
     * @minimum 1
     * @x-auditable true
     */
    ns_set?: number;
    /**
     * Nameserver type
     *
     * @example cloudflare.standard
     * @x-auditable true
     */
    type:
      | "cloudflare.standard"
      | "custom.account"
      | "custom.tenant"
      | "custom.zone";
  };
};

export type DnsSettingsDnsView = {
  created_time?: DnsSettingsCreatedTime;
  modified_time?: DnsSettingsModifiedTime;
  name?: DnsSettingsName;
  zones?: DnsSettingsZones;
};

export type DnsSettingsDnsViewPatch = DnsSettingsDnsView;

export type DnsSettingsDnsViewPost = DnsSettingsDnsView;

export type DnsSettingsDnsViewResponse = DnsSettingsDnsView & {
  id: DnsSettingsIdentifier;
};

export type DnsSettingsDnsResponseSingle = DnsSettingsApiResponseSingle & {
  result?: DnsSettingsAccountSettings;
};

export type DnsSettingsDnsViewResponseCollection =
  DnsSettingsApiResponseCollection & {
    result?: DnsSettingsDnsViewResponse[];
  };

export type DnsSettingsDnsViewResponseSingle = DnsSettingsApiResponseSingle & {
  result?: DnsSettingsDnsViewResponse;
};

/**
 * Whether to flatten all CNAME records in the zone. Note that, due to DNS limitations, a CNAME record at the zone apex will always be flattened.
 *
 * @example false
 * @x-auditable true
 */
export type DnsSettingsFlattenAllCnames = boolean;

/**
 * Whether to enable Foundation DNS Advanced Nameservers on the zone.
 *
 * @example false
 * @x-auditable true
 */
export type DnsSettingsFoundationDns = boolean;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type DnsSettingsIdentifier = string;

/**
 * Settings for this internal zone.
 */
export type DnsSettingsInternalDns = {
  /**
   * The ID of the zone to fallback to.
   *
   * @example {"description":"Identifier.","example":"023e105f4ecef8ad9ca31a8372d0c353","maxLength":32,"type":"string","x-auditable":true}
   */
  reference_zone_id?: string;
};

/**
 * Whether to match all search requirements or at least one (any). If set to `all`, acts like a logical AND between filters. If set to `any`, acts like a logical OR instead.
 *
 * @default all
 * @example any
 */
export type DnsSettingsMatch = "any" | "all";

export type DnsSettingsMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * When the view was last modified.
 *
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type DnsSettingsModifiedTime = string;

/**
 * Whether to enable multi-provider DNS, which causes Cloudflare to activate the zone even when non-Cloudflare NS records exist, and to respect NS records at the zone apex during outbound zone transfers.
 *
 * @example false
 * @x-auditable true
 */
export type DnsSettingsMultiProvider = boolean;

/**
 * The name of the view.
 *
 * @example my view
 * @maxLength 255
 * @minLength 1
 * @x-auditable true
 */
export type DnsSettingsName = string;

/**
 * The time to live (TTL) of the zone's nameserver (NS) records.
 *
 * @example 86400
 * @maximum 86400
 * @minimum 30
 * @x-auditable true
 */
export type DnsSettingsNsTtl = number;

/**
 * Field to order DNS views by.
 *
 * @default type
 */
export type DnsSettingsOrder = "name" | "created_on" | "modified_on";

/**
 * Page number of paginated results.
 *
 * @default 1
 * @minimum 1
 */
export type DnsSettingsPage = number;

/**
 * Number of DNS views per page.
 *
 * @default 100
 * @example 5
 * @maximum 5000000
 * @minimum 1
 */
export type DnsSettingsPerPage = number;

export type DnsSettingsSchemasDnsResponseSingle =
  DnsSettingsApiResponseSingle & {
    result?: DnsSettingsDnsSettingsZone;
  };

/**
 * Allows a Secondary DNS zone to use (proxied) override records and CNAME flattening at the zone apex.
 *
 * @example false
 * @x-auditable true
 */
export type DnsSettingsSecondaryOverrides = boolean;

/**
 * Components of the zone's SOA record.
 */
export type DnsSettingsSoa = {
  /**
   * Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
   *
   * @example 604800
   * @maximum 2419200
   * @minimum 86400
   * @x-auditable true
   */
  expire: number;
  /**
   * The time to live (TTL) for negative caching of records within the zone.
   *
   * @example 1800
   * @maximum 86400
   * @minimum 60
   * @x-auditable true
   */
  min_ttl: number;
  /**
   * The primary nameserver, which may be used for outbound zone transfers.
   *
   * @example kristina.ns.cloudflare.com
   * @x-auditable true
   */
  mname: string;
  /**
   * Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
   *
   * @example 10000
   * @maximum 86400
   * @minimum 600
   * @x-auditable true
   */
  refresh: number;
  /**
   * Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
   *
   * @example 2400
   * @maximum 86400
   * @minimum 600
   * @x-auditable true
   */
  retry: number;
  /**
   * The email address of the zone administrator, with the first label representing the local part of the email address.
   *
   * @example admin.example.com
   * @x-auditable true
   */
  rname: string;
  /**
   * The time to live (TTL) of the SOA record itself.
   *
   * @example 3600
   * @maximum 86400
   * @minimum 300
   * @x-auditable true
   */
  ttl: number;
};

/**
 * Whether the zone mode is a regular or CDN/DNS only zone.
 *
 * @example dns_only
 * @x-auditable true
 */
export type DnsSettingsZoneMode = "standard" | "cdn_only" | "dns_only";

/**
 * The list of zones linked to this view.
 */
export type DnsSettingsZones = string[];

/**
 * Algorithm key code.
 *
 * @example 13
 * @x-auditable true
 */
export type DnssecAlgorithm = string | null;

export type DnssecApiResponseCommon = {
  errors: DnssecMessages;
  messages: DnssecMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type DnssecApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: DnssecMessages;
  messages: DnssecMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type DnssecApiResponseSingle = DnssecApiResponseCommon;

export type DnssecDeleteDnssecResponseSingle = DnssecApiResponseSingle & {
  /**
   * @example
   */
  result?: string;
};

/**
 * Digest hash.
 *
 * @example 48E939042E82C22542CB377B580DFDC52A361CEFDC72E7F9107E2B6BD9306A45
 * @x-auditable true
 */
export type DnssecDigest = string | null;

/**
 * Type of digest algorithm.
 *
 * @example SHA256
 * @x-auditable true
 */
export type DnssecDigestAlgorithm = string | null;

/**
 * Coded type for digest algorithm.
 *
 * @example 2
 * @x-auditable true
 */
export type DnssecDigestType = string | null;

export type DnssecDnssec = {
  algorithm?: DnssecAlgorithm;
  digest?: DnssecDigest;
  digest_algorithm?: DnssecDigestAlgorithm;
  digest_type?: DnssecDigestType;
  dnssec_multi_signer?: DnssecDnssecMultiSigner;
  dnssec_presigned?: DnssecDnssecPresigned;
  dnssec_use_nsec3?: DnssecDnssecUseNsec3;
  ds?: DnssecDs;
  flags?: DnssecFlags;
  key_tag?: DnssecKeyTag;
  key_type?: DnssecKeyType;
  modified_on?: DnssecModifiedOn;
  public_key?: DnssecPublicKey;
  status?: DnssecStatus;
};

/**
 * If true, multi-signer DNSSEC is enabled on the zone, allowing multiple
 * providers to serve a DNSSEC-signed zone at the same time.
 * This is required for DNSKEY records (except those automatically
 * generated by Cloudflare) to be added to the zone.
 *
 * See [Multi-signer DNSSEC](https://developers.cloudflare.com/dns/dnssec/multi-signer-dnssec/) for details.
 *
 * @example false
 * @x-auditable true
 */
export type DnssecDnssecMultiSigner = boolean;

/**
 * If true, allows Cloudflare to transfer in a DNSSEC-signed zone
 * including signatures from an external provider, without requiring
 * Cloudflare to sign any records on the fly.
 *
 * Note that this feature has some limitations.
 * See [Cloudflare as Secondary](https://developers.cloudflare.com/dns/zone-setups/zone-transfers/cloudflare-as-secondary/setup/#dnssec) for details.
 *
 * @example true
 * @x-auditable true
 */
export type DnssecDnssecPresigned = boolean;

export type DnssecDnssecResponseSingle = DnssecApiResponseSingle & {
  result?: DnssecDnssec;
};

/**
 * If true, enables the use of NSEC3 together with DNSSEC on the zone.
 * Combined with setting dnssec_presigned to true, this enables the use of
 * NSEC3 records when transferring in from an external provider.
 * If dnssec_presigned is instead set to false (default), NSEC3 records will be
 * generated and signed at request time.
 *
 * See [DNSSEC with NSEC3](https://developers.cloudflare.com/dns/dnssec/enable-nsec3/) for details.
 *
 * @example false
 * @x-auditable true
 */
export type DnssecDnssecUseNsec3 = boolean;

/**
 * Full DS record.
 *
 * @example example.com. 3600 IN DS 16953 13 2 48E939042E82C22542CB377B580DFDC52A361CEFDC72E7F9107E2B6BD9306A45
 * @x-auditable true
 */
export type DnssecDs = string | null;

/**
 * Flag for DNSSEC record.
 *
 * @example 257
 * @x-auditable true
 */
export type DnssecFlags = number | null;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type DnssecIdentifier = string;

/**
 * Code for key tag.
 *
 * @example 42
 * @x-auditable true
 */
export type DnssecKeyTag = number | null;

/**
 * Algorithm key type.
 *
 * @example ECDSAP256SHA256
 * @x-auditable true
 */
export type DnssecKeyType = string | null;

export type DnssecMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * When DNSSEC was last modified.
 *
 * @example 2014-01-01T05:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type DnssecModifiedOn = string | null;

/**
 * Public key for DS record.
 *
 * @example oXiGYrSTO+LSCJ3mohc8EP+CzF9KxBj8/ydXJ22pKuZP3VAC3/Md/k7xZfz470CoRyZJ6gV6vml07IC3d8xqhA==
 * @x-auditable true
 */
export type DnssecPublicKey = string | null;

/**
 * Status of DNSSEC, based on user-desired state and presence of necessary records.
 *
 * @example active
 * @x-auditable true
 */
export type DnssecStatus =
  | "active"
  | "pending"
  | "disabled"
  | "pending-disabled"
  | "error";

export type DosApiResponseCommon = {
  errors: DosMessages;
  messages: DosMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type DosApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: DosMessages;
  messages: DosMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type DosAsn = number;

/**
 * @example US
 */
export type DosAsnCountry = string;

/**
 * @example CLOUDFLARENET
 */
export type DosAsnDescription = string;

/**
 * Infrastructure type of this ASN.
 *
 * @example hosting_provider
 */
export type DosAsnType = "hosting_provider" | "isp" | "organization";

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type DosIdentifier = string;

export type DosMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 */
export type DosTimestamp = string;

/**
 * Account Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @minLength 32
 */
export type EmailSecurityAccountId = string;

/**
 * @example {"comments":"Trust all messages send from test@example.com","created_at":"2023-11-14T22:13:20Z","id":2401,"is_acceptable_sender":false,"is_exempt_recipient":false,"is_recipient":false,"is_regex":false,"is_sender":true,"is_spoof":false,"is_trusted_sender":true,"last_modified":"2023-11-14T22:13:20Z","pattern":"test@example.com","pattern_type":"EMAIL","verify_sender":true}
 */
export type EmailSecurityAllowPolicy = {
  /**
   * @maxLength 1024
   * @x-auditable true
   */
  comments?: string | null;
  /**
   * Messages from this sender will be exempted from Spam, Spoof and Bulk dispositions.
   * Note: This will not exempt messages with Malicious or Suspicious dispositions.
   *
   * @x-auditable true
   */
  is_acceptable_sender?: boolean;
  /**
   * Messages to this recipient will bypass all detections.
   *
   * @x-auditable true
   */
  is_exempt_recipient?: boolean;
  /**
   * @deprecated true
   * @x-auditable true
   */
  is_recipient?: boolean;
  /**
   * @x-auditable true
   */
  is_regex: boolean;
  /**
   * @deprecated true
   * @x-auditable true
   */
  is_sender?: boolean;
  /**
   * @deprecated true
   * @x-auditable true
   */
  is_spoof?: boolean;
  /**
   * Messages from this sender will bypass all detections and link following.
   *
   * @x-auditable true
   */
  is_trusted_sender?: boolean;
  /**
   * @maxLength 1024
   * @minLength 1
   * @x-auditable true
   */
  pattern: string;
  pattern_type: EmailSecurityPatternType;
  /**
   * Enforce DMARC, SPF or DKIM authentication.
   * When on, Email Security only honors policies that pass authentication.
   *
   * @x-auditable true
   */
  verify_sender: boolean;
  /**
   * @format date-time
   * @x-auditable true
   */
  created_at: string;
  id: EmailSecurityAllowPolicyId;
  /**
   * @format date-time
   * @x-auditable true
   */
  last_modified: string;
};

/**
 * The unique identifier for the allow policy.
 *
 * @example 2401
 * @format int32
 */
export type EmailSecurityAllowPolicyId = number;

export type EmailSecurityApiResponseCommon = {
  errors: EmailSecurityMessage[];
  messages: EmailSecurityMessage[];
  /**
   * @example true
   */
  success: boolean;
};

export type EmailSecurityAttachment = {
  content_type?: string | null;
  detection?: EmailSecurityDispositionLabel & (string | null);
  encrypted?: boolean | null;
  name?: string | null;
  /**
   * @minimum 0
   */
  size: number;
};

/**
 * @example {"comments":"block sender with email test@example.com","created_at":"2023-11-14T22:13:20Z","id":2402,"is_regex":false,"last_modified":"2023-11-14T22:13:20Z","pattern":"test@example.com","pattern_type":"EMAIL"}
 */
export type EmailSecurityBlockedSender = {
  /**
   * @maxLength 1024
   * @x-auditable true
   */
  comments?: string | null;
  /**
   * @x-auditable true
   */
  is_regex?: boolean;
  /**
   * @maxLength 1024
   * @minLength 1
   * @x-auditable true
   */
  pattern?: string;
  pattern_type?: EmailSecurityPatternType;
  /**
   * @format date-time
   * @x-auditable true
   */
  created_at: string;
  id: EmailSecurityBlockedSenderId;
  /**
   * @format date-time
   * @x-auditable true
   */
  last_modified: string;
};

/**
 * The unique identifier for the allow policy.
 *
 * @example 2402
 * @format int32
 */
export type EmailSecurityBlockedSenderId = number;

/**
 * @example {"comments":"Trust all messages send from test@example.com","is_acceptable_sender":false,"is_exempt_recipient":false,"is_recipient":false,"is_regex":false,"is_sender":true,"is_spoof":false,"is_trusted_sender":true,"pattern":"test@example.com","pattern_type":"EMAIL","verify_sender":true}
 */
export type EmailSecurityCreateAllowPolicy = {
  /**
   * @maxLength 1024
   * @x-auditable true
   */
  comments?: string | null;
  /**
   * Messages from this sender will be exempted from Spam, Spoof and Bulk dispositions.
   * Note: This will not exempt messages with Malicious or Suspicious dispositions.
   *
   * @x-auditable true
   */
  is_acceptable_sender: boolean;
  /**
   * Messages to this recipient will bypass all detections.
   *
   * @x-auditable true
   */
  is_exempt_recipient: boolean;
  /**
   * @deprecated true
   * @x-auditable true
   */
  is_recipient?: boolean;
  /**
   * @x-auditable true
   */
  is_regex: boolean;
  /**
   * @deprecated true
   * @x-auditable true
   */
  is_sender?: boolean;
  /**
   * @deprecated true
   * @x-auditable true
   */
  is_spoof?: boolean;
  /**
   * Messages from this sender will bypass all detections and link following.
   *
   * @x-auditable true
   */
  is_trusted_sender: boolean;
  /**
   * @maxLength 1024
   * @minLength 1
   * @x-auditable true
   */
  pattern: string;
  pattern_type: EmailSecurityPatternType;
  /**
   * Enforce DMARC, SPF or DKIM authentication.
   * When on, Email Security only honors policies that pass authentication.
   *
   * @x-auditable true
   */
  verify_sender: boolean;
};

/**
 * @example {"comments":"block sender with email test@example.com","is_regex":false,"pattern":"test@example.com","pattern_type":"EMAIL"}
 */
export type EmailSecurityCreateBlockedSender = {
  /**
   * @maxLength 1024
   * @x-auditable true
   */
  comments?: string | null;
  /**
   * @x-auditable true
   */
  is_regex: boolean;
  /**
   * @maxLength 1024
   * @minLength 1
   * @x-auditable true
   */
  pattern: string;
  pattern_type: EmailSecurityPatternType;
};

export type EmailSecurityCreateDisplayName = {
  /**
   * @x-auditable true
   */
  email: string;
  /**
   * @x-auditable true
   */
  is_email_regex: boolean;
  /**
   * @maxLength 1024
   * @x-auditable true
   */
  name: string;
};

/**
 * @example {"comments":null,"is_recent":true,"is_regex":false,"is_similarity":false,"pattern":"example.com"}
 */
export type EmailSecurityCreateTrustedDomain = {
  /**
   * @maxLength 1024
   * @x-auditable true
   */
  comments?: string | null;
  /**
   * Select to prevent recently registered domains from triggering a
   * Suspicious or Malicious disposition.
   *
   * @x-auditable true
   */
  is_recent: boolean;
  /**
   * @x-auditable true
   */
  is_regex: boolean;
  /**
   * Select for partner or other approved domains that have similar
   * spelling to your connected domains. Prevents listed domains from
   * triggering a Spoof disposition.
   *
   * @x-auditable true
   */
  is_similarity: boolean;
  /**
   * @maxLength 1024
   * @minLength 1
   * @x-auditable true
   */
  pattern: string;
};

export type EmailSecurityDeliveryMode =
  | "DIRECT"
  | "BCC"
  | "JOURNAL"
  | "API"
  | "RETRO_SCAN";

export type EmailSecurityDisplayName = {
  /**
   * @x-auditable true
   */
  email?: string;
  /**
   * @x-auditable true
   */
  is_email_regex?: boolean;
  /**
   * @maxLength 1024
   * @x-auditable true
   */
  name?: string;
  comments?: string | null;
  /**
   * @format date-time
   */
  created_at: string;
  /**
   * @format int64
   */
  directory_id?: number | null;
  /**
   * @format int32
   */
  directory_node_id?: number | null;
  /**
   * @deprecated true
   */
  external_directory_node_id?: string | null;
  /**
   * @example 2403
   * @format int32
   */
  id: number;
  /**
   * @format date-time
   */
  last_modified: string;
  provenance?: string | null;
};

export type EmailSecurityDispositionLabel =
  | "MALICIOUS"
  | "MALICIOUS-BEC"
  | "SUSPICIOUS"
  | "SPOOF"
  | "SPAM"
  | "BULK"
  | "ENCRYPTED"
  | "EXTERNAL"
  | "UNKNOWN"
  | "NONE";

/**
 * @example {"allowed_delivery_modes":["API"],"authorization":null,"created_at":"2023-11-14T22:13:20Z","domain":"example.com","drop_dispositions":["MALICIOUS","SPAM"],"emails_processed":null,"folder":"Inbox","id":2400,"inbox_provider":"Microsoft","integration_id":"a5dbb180-60ea-4578-84bb-d01a5d4e50c3","ip_restrictions":[],"last_modified":"2023-11-14T22:13:20Z","lookback_hops":2,"o365_tenant_id":"c3c3239d-8858-47df-9618-0e2d9bdf6aa8","require_tls_inbound":false,"require_tls_outbound":true,"transport":"example.com"}
 */
export type EmailSecurityDomain = {
  allowed_delivery_modes: EmailSecurityDeliveryMode[];
  authorization?: {
    authorized: boolean;
    status_message?: string | null;
    /**
     * @format date-time
     */
    timestamp: string;
  } | null;
  /**
   * @format date-time
   */
  created_at: string;
  domain: string;
  drop_dispositions: EmailSecurityDispositionLabel[];
  emails_processed?: {
    /**
     * @format date-time
     */
    timestamp: string;
    /**
     * @format int32
     * @minimum 0
     */
    total_emails_processed: number;
    /**
     * @format int32
     * @minimum 0
     */
    total_emails_processed_previous: number;
  } | null;
  folder?: EmailSecurityScannableFolder & (string | null);
  /**
   * The unique identifier for the domain.
   *
   * @example 2400
   * @format int32
   */
  id: number;
  inbox_provider?: "Microsoft" | "Google" | null;
  /**
   * @format uuid
   */
  integration_id?: string | null;
  /**
   * @example 192.0.2.0/24
   * @example 2001:db8::/32
   */
  ip_restrictions: string[];
  /**
   * @format date-time
   */
  last_modified: string;
  /**
   * @format int32
   */
  lookback_hops: number;
  o365_tenant_id?: string | null;
  require_tls_inbound?: boolean | null;
  require_tls_outbound?: boolean | null;
  transport: string;
};

export type EmailSecurityLink = {
  href: string;
  text?: string | null;
};

/**
 * @example {"action_log":[],"alert_id":"4Njp3P0STMz2c02Q-2022-12-30T02:44:49","client_recipients":["email@example.com"],"delivery_mode":"DIRECT","detection_reasons":["Selector is a source of spam/uce : Smtp-Helo-Server-Ip=<b>127.0.0[dot]186</b>"],"edf_hash":null,"final_disposition":"MALICIOUS","findings":null,"from":"d1994@example.com","from_name":"Sender Name","id":"47JJcT1w6GztQV7-email@example.com","is_phish_submission":false,"is_quarantined":false,"message_id":"<4VAZPrAdg7IGNxdt1DWRNu0gvOeL_iZiwP4BQfo4DaE.Yw-woXuugQbeFhBpzwFQtqq_v2v1HOKznoMBqbciQpE@example.com>","postfix_id":"47JJcT1w6GztQV7","properties":{},"sent_date":"2019-11-21T00:22:01","subject":"listen, I highly recommend u to read that email, just to ensure not a thing will take place","threat_categories":["IPReputation","ASNReputation"],"to":["email@example.com"],"to_name":["Recipient Name"],"ts":"2019-11-20T23:22:01","validation":{"comment":null,"dkim":"pass","dmarc":"none","spf":"fail"}}
 */
export type EmailSecurityMailsearchMessage = {
  action_log: void;
  alert_id?: string | null;
  client_recipients: string[];
  delivery_mode?: EmailSecurityMessageDeliveryMode & (string | null);
  detection_reasons: string[];
  edf_hash?: string | null;
  final_disposition?: EmailSecurityDispositionLabel & (string | null);
  findings?:
    | {
        detail?: string | null;
        name?: string | null;
        value?: string | null;
      }[]
    | null;
  from?: string | null;
  from_name?: string | null;
  is_phish_submission: boolean;
  is_quarantined: boolean;
  message_id?: string | null;
  postfix_id: EmailSecurityPostfixId;
  properties: {
    allowlisted_pattern?: string;
    allowlisted_pattern_type?:
      | "quarantine_release"
      | "blocked_sender"
      | "acceptable_sender"
      | "allowed_sender"
      | "allowed_recipient"
      | "domain_similarity"
      | "domain_recency"
      | "managed_acceptable_sender";
    blocklisted_message?: boolean;
    blocklisted_pattern?: string;
    whitelisted_pattern_type?:
      | "quarantine_release"
      | "blocked_sender"
      | "acceptable_sender"
      | "allowed_sender"
      | "allowed_recipient"
      | "domain_similarity"
      | "domain_recency"
      | "managed_acceptable_sender";
  };
  sent_date?: string | null;
  subject?: string | null;
  threat_categories?: string[] | null;
  to?: string[] | null;
  to_name?: string[] | null;
  ts?: string;
  validation?: {
    comment?: string | null;
    dkim?: EmailSecurityValidationStatus & (string | null);
    dmarc?: EmailSecurityValidationStatus & (string | null);
    spf?: EmailSecurityValidationStatus & (string | null);
  } | null;
  /**
   * @x-auditable true
   */
  id: string;
};

export type EmailSecurityMessage = {
  /**
   * @format int32
   * @minimum 1000
   */
  code: number;
  message: string;
};

export type EmailSecurityMessageDeliveryMode =
  | "DIRECT"
  | "BCC"
  | "JOURNAL"
  | "REVIEW_SUBMISSION"
  | "DMARC_UNVERIFIED"
  | "DMARC_FAILURE_REPORT"
  | "DMARC_AGGREGATE_REPORT"
  | "THREAT_INTEL_SUBMISSION"
  | "SIMULATION_SUBMISSION"
  | "API"
  | "RETRO_SCAN";

export type EmailSecurityMessageHeader = {
  name: string;
  value: string;
};

export type EmailSecurityPatternType = "EMAIL" | "DOMAIN" | "IP" | "UNKNOWN";

/**
 * The identifier of the message.
 *
 * @example 4Njp3P0STMz2c02Q
 */
export type EmailSecurityPostfixId = string;

export type EmailSecurityReleaseResponse = {
  delivered?: string[] | null;
  failed?: string[] | null;
  undelivered?: string[] | null;
  postfix_id: EmailSecurityPostfixId;
};

export type EmailSecurityResultInfo = {
  /**
   * Total number of results for the requested service
   *
   * @example 1
   * @format int32
   */
  count: number;
  /**
   * Current page within paginated list of results
   *
   * @example 1
   * @format int32
   */
  page: number;
  /**
   * Number of results per page of results
   *
   * @example 20
   * @format int32
   */
  per_page: number;
  /**
   * Total results available without any search parameters
   *
   * @example 2000
   * @format int32
   */
  total_count: number;
};

export type EmailSecurityRetractionResponseItem = {
  /**
   * @format date-time
   */
  completed_timestamp: string;
  destination?: string | null;
  /**
   * @format int32
   */
  item_count: number;
  message_id?: string | null;
  operation?: string | null;
  recipient?: string | null;
  status?: string | null;
};

export type EmailSecurityScannableFolder = "AllItems" | "Inbox";

export type EmailSecuritySortingDirection = "asc" | "desc";

export type EmailSecuritySubmission = {
  original_disposition?: EmailSecurityDispositionLabel & (string | null);
  original_edf_hash?: string | null;
  outcome?: string | null;
  outcome_disposition?: EmailSecurityDispositionLabel & (string | null);
  requested_by?: string | null;
  requested_disposition?: EmailSecurityDispositionLabel & (string | null);
  /**
   * @format date-time
   */
  requested_ts: string;
  status?: string | null;
  subject?: string | null;
  submission_id: string;
  type?: string | null;
};

export type EmailSecurityThreatCategory = {
  description?: string | null;
  /**
   * @format int64
   */
  id: number;
  name?: string | null;
};

export type EmailSecurityTraceLine = {
  /**
   * @format int64
   */
  lineno: number;
  message: string;
  /**
   * @format date-time
   */
  ts: string;
};

/**
 * @example {"comments":null,"created_at":"2023-11-14T22:13:20Z","id":2401,"is_recent":true,"is_regex":false,"is_similarity":false,"last_modified":"2023-11-14T22:13:20Z","pattern":"example.com"}
 */
export type EmailSecurityTrustedDomain = {
  /**
   * @maxLength 1024
   * @x-auditable true
   */
  comments?: string | null;
  /**
   * Select to prevent recently registered domains from triggering a
   * Suspicious or Malicious disposition.
   *
   * @x-auditable true
   */
  is_recent?: boolean;
  /**
   * @x-auditable true
   */
  is_regex?: boolean;
  /**
   * Select for partner or other approved domains that have similar
   * spelling to your connected domains. Prevents listed domains from
   * triggering a Spoof disposition.
   *
   * @x-auditable true
   */
  is_similarity?: boolean;
  /**
   * @maxLength 1024
   * @minLength 1
   * @x-auditable true
   */
  pattern: string;
  /**
   * @format date-time
   * @x-auditable true
   */
  created_at: string;
  /**
   * The unique identifier for the trusted domain.
   *
   * @example 2401
   * @format int32
   */
  id: number;
  /**
   * @format date-time
   * @x-auditable true
   */
  last_modified: string;
};

/**
 * The unique identifier for the trusted domain.
 *
 * @example 2401
 * @format int32
 */
export type EmailSecurityTrustedDomainId = number;

export type EmailSecurityUpdateAllowPolicy = {
  /**
   * @maxLength 1024
   * @x-auditable true
   */
  comments?: string | null;
  /**
   * Messages from this sender will be exempted from Spam, Spoof and Bulk dispositions.
   * Note: This will not exempt messages with Malicious or Suspicious dispositions.
   *
   * @x-auditable true
   */
  is_acceptable_sender?: boolean | null;
  /**
   * Messages to this recipient will bypass all detections.
   *
   * @x-auditable true
   */
  is_exempt_recipient?: boolean | null;
  /**
   * @x-auditable true
   */
  is_regex?: boolean | null;
  /**
   * Messages from this sender will bypass all detections and link following.
   *
   * @x-auditable true
   */
  is_trusted_sender?: boolean | null;
  /**
   * @maxLength 1024
   * @minLength 1
   * @x-auditable true
   */
  pattern?: string | null;
  pattern_type?: EmailSecurityPatternType & (string | null);
  /**
   * Enforce DMARC, SPF or DKIM authentication.
   * When on, Email Security only honors policies that pass authentication.
   *
   * @x-auditable true
   */
  verify_sender?: boolean | null;
};

export type EmailSecurityUpdateBlockedSender = {
  /**
   * @x-auditable true
   */
  comments?: string | null;
  /**
   * @x-auditable true
   */
  is_regex?: boolean | null;
  /**
   * @minLength 1
   * @x-auditable true
   */
  pattern?: string | null;
  pattern_type?: EmailSecurityPatternType & (string | null);
};

export type EmailSecurityValidationStatus =
  | "pass"
  | "neutral"
  | "fail"
  | "error"
  | "none";

export type EmailAccountId = EmailIdentifier;

export type EmailAddresses = EmailDestinationAddressProperties;

export type EmailApiResponseCollection = EmailApiResponseCommon & {
  result_info?: {
    /**
     * Total number of results for the requested service.
     *
     * @example 1
     */
    count?: number;
    /**
     * Current page within paginated list of results.
     *
     * @example 1
     */
    page?: number;
    /**
     * Number of results per page of results.
     *
     * @example 20
     */
    per_page?: number;
    /**
     * Total results available without any search parameters.
     *
     * @example 2000
     */
    total_count?: number;
  };
};

export type EmailApiResponseCommon = {
  errors: EmailMessages;
  messages: EmailMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type EmailApiResponseSingle = EmailApiResponseCommon;

export type EmailCatchAllRule = {
  actions?: EmailRuleCatchallActions;
  enabled?: EmailRuleEnabled;
  id?: EmailRuleIdentifier;
  matchers?: EmailRuleCatchallMatchers;
  name?: EmailRuleName;
  tag?: EmailRuleTag;
};

export type EmailCatchAllRuleResponseSingle = EmailApiResponseSingle & {
  result?: EmailCatchAllRule;
};

export type EmailCreateDestinationAddressProperties = {
  email: EmailEmail;
};

export type EmailCreateRuleProperties = {
  actions: EmailRuleActions;
  enabled?: EmailRuleEnabled;
  matchers: EmailRuleMatchers;
  name?: EmailRuleName;
  priority?: EmailRulePriority;
};

/**
 * The date and time the destination address has been created.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 */
export type EmailCreated = string;

/**
 * Destination address identifier.
 *
 * @example ea95132c15732412d22c1476fa83f27a
 * @maxLength 32
 * @x-auditable true
 */
export type EmailDestinationAddressIdentifier = string;

export type EmailDestinationAddressProperties = {
  created?: EmailCreated;
  email?: EmailEmail;
  id?: EmailDestinationAddressIdentifier;
  modified?: EmailModified;
  tag?: EmailDestinationAddressTag;
  verified?: EmailVerified;
};

export type EmailDestinationAddressResponseSingle = EmailApiResponseSingle & {
  result?: EmailAddresses;
};

/**
 * Destination address tag. (Deprecated, replaced by destination address identifier)
 *
 * @deprecated true
 * @example ea95132c15732412d22c1476fa83f27a
 * @maxLength 32
 */
export type EmailDestinationAddressTag = string;

export type EmailDestinationAddressesResponseCollection =
  EmailApiResponseCollection & {
    result?: EmailAddresses[];
    result_info?: {
      /**
       * @example 1
       */
      count?: void;
      /**
       * @example 1
       */
      page?: void;
      /**
       * @example 20
       */
      per_page?: void;
      /**
       * @example 1
       */
      total_count?: void;
    };
  };

/**
 * List of records needed to enable an Email Routing zone.
 */
export type EmailDnsRecord = {
  /**
   * DNS record content.
   *
   * @example route1.mx.cloudflare.net
   */
  content?: string;
  /**
   * DNS record name (or @ for the zone apex).
   *
   * @example example.com
   * @maxLength 255
   * @x-auditable true
   */
  name?: string;
  /**
   * Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
   *
   * @example 12
   * @maximum 65535
   * @minimum 0
   * @x-auditable true
   */
  priority?: number;
  /**
   * Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
   *
   * @example 1
   * @x-auditable true
   */
  ttl?: number | 1;
  /**
   * DNS record type.
   *
   * @example NS
   * @x-auditable true
   */
  type?:
    | "A"
    | "AAAA"
    | "CNAME"
    | "HTTPS"
    | "TXT"
    | "SRV"
    | "LOC"
    | "MX"
    | "NS"
    | "CERT"
    | "DNSKEY"
    | "DS"
    | "NAPTR"
    | "SMIMEA"
    | "SSHFP"
    | "SVCB"
    | "TLSA"
    | "URI";
};

export type EmailDnsSettingsResponseCollection = EmailApiResponseCollection & {
  result?: EmailDnsRecord[];
};

/**
 * The contact email address of the user.
 *
 * @example user@example.com
 * @maxLength 90
 * @x-auditable true
 */
export type EmailEmail = string;

export type EmailEmailRoutingDnsQueryResponse = EmailApiResponseCollection & {
  result?: {
    errors?: EmailEmailRoutingGetResponseDnsErrors;
    record?: EmailDnsRecord[];
  };
};

export type EmailEmailRoutingGetResponseDnsError = {
  code?: string;
  missing?: EmailDnsRecord;
};

export type EmailEmailRoutingGetResponseDnsErrors =
  EmailEmailRoutingGetResponseDnsError[];

/**
 * The date and time the settings have been created.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 */
export type EmailEmailSettingCreated = string;

export type EmailEmailSettingDnsRequestBody = {
  name: EmailEmailSettingName;
} | null;

/**
 * State of the zone settings for Email Routing.
 *
 * @example true
 * @x-auditable true
 */
export type EmailEmailSettingEnabled = true | false;

/**
 * Email Routing settings identifier.
 *
 * @example 75610dab9e69410a82cf7e400a09ecec
 * @maxLength 32
 * @x-auditable true
 */
export type EmailEmailSettingIdentifier = string;

/**
 * The date and time the settings have been modified.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 */
export type EmailEmailSettingModified = string;

/**
 * Domain of your zone.
 *
 * @example example.net
 * @x-auditable true
 */
export type EmailEmailSettingName = string;

/**
 * Flag to check if the user skipped the configuration wizard.
 *
 * @example true
 */
export type EmailEmailSettingSkipWizard = true | false;

/**
 * Show the state of your account, and the type or configuration error.
 *
 * @example ready
 */
export type EmailEmailSettingStatus =
  | "ready"
  | "unconfigured"
  | "misconfigured"
  | "misconfigured/locked"
  | "unlocked";

/**
 * Email Routing settings tag. (Deprecated, replaced by Email Routing settings identifier)
 *
 * @deprecated true
 * @example 75610dab9e69410a82cf7e400a09ecec
 * @maxLength 32
 */
export type EmailEmailSettingTag = string;

export type EmailEmailSettingsProperties = {
  created?: EmailEmailSettingCreated;
  enabled: EmailEmailSettingEnabled;
  id: EmailEmailSettingIdentifier;
  modified?: EmailEmailSettingModified;
  name: EmailEmailSettingName;
  skip_wizard?: EmailEmailSettingSkipWizard;
  status?: EmailEmailSettingStatus;
  tag?: EmailEmailSettingTag;
};

export type EmailEmailSettingsResponseSingle = EmailApiResponseSingle & {
  result?: EmailSettings;
};

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type EmailIdentifier = string;

export type EmailMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * The date and time the destination address was last modified.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 */
export type EmailModified = string;

/**
 * Actions pattern.
 */
export type EmailRuleAction = {
  /**
   * Type of supported action.
   *
   * @example forward
   * @x-auditable true
   */
  type: "drop" | "forward" | "worker";
  value?: string[];
};

/**
 * List actions patterns.
 */
export type EmailRuleActions = EmailRuleAction[];

/**
 * Action for the catch-all routing rule.
 */
export type EmailRuleCatchallAction = {
  /**
   * Type of action for catch-all rule.
   *
   * @example forward
   * @x-auditable true
   */
  type: "drop" | "forward" | "worker";
  value?: string[];
};

/**
 * List actions for the catch-all routing rule.
 */
export type EmailRuleCatchallActions = EmailRuleCatchallAction[];

/**
 * Matcher for catch-all routing rule.
 */
export type EmailRuleCatchallMatcher = {
  /**
   * Type of matcher. Default is 'all'.
   *
   * @example all
   * @x-auditable true
   */
  type: "all";
};

/**
 * List of matchers for the catch-all routing rule.
 */
export type EmailRuleCatchallMatchers = EmailRuleCatchallMatcher[];

/**
 * Routing rule status.
 *
 * @default true
 * @example true
 * @x-auditable true
 */
export type EmailRuleEnabled = true | false;

/**
 * Routing rule identifier.
 *
 * @example a7e6fb77503c41d8a7f3113c6918f10c
 * @maxLength 32
 * @x-auditable true
 */
export type EmailRuleIdentifier = string;

/**
 * Matching pattern to forward your actions.
 */
export type EmailRuleMatcher = {
  /**
   * Field for type matcher.
   *
   * @example to
   * @x-auditable true
   */
  field?: "to";
  /**
   * Type of matcher.
   *
   * @example literal
   * @x-auditable true
   */
  type: "all" | "literal";
  /**
   * Value for matcher.
   *
   * @example test@example.com
   * @maxLength 90
   * @x-auditable true
   */
  value?: string;
};

/**
 * Matching patterns to forward to your actions.
 */
export type EmailRuleMatchers = EmailRuleMatcher[];

/**
 * Routing rule name.
 *
 * @example Send to user@example.net rule.
 * @maxLength 256
 * @x-auditable true
 */
export type EmailRuleName = string;

/**
 * Priority of the routing rule.
 *
 * @default 0
 * @minimum 0
 * @x-auditable true
 */
export type EmailRulePriority = number;

export type EmailRuleProperties = {
  actions?: EmailRuleActions;
  enabled?: EmailRuleEnabled;
  id?: EmailRuleIdentifier;
  matchers?: EmailRuleMatchers;
  name?: EmailRuleName;
  priority?: EmailRulePriority;
  tag?: EmailRuleTag;
};

export type EmailRuleResponseSingle = EmailApiResponseSingle & {
  result?: EmailRules;
};

/**
 * Routing rule tag. (Deprecated, replaced by routing rule identifier)
 *
 * @deprecated true
 * @example a7e6fb77503c41d8a7f3113c6918f10c
 * @maxLength 32
 */
export type EmailRuleTag = string;

export type EmailRules = EmailRuleProperties;

export type EmailRulesResponseCollection = EmailApiResponseCollection & {
  result?: EmailRules[];
  result_info?: {
    /**
     * @example 1
     */
    count?: void;
    /**
     * @example 1
     */
    page?: void;
    /**
     * @example 20
     */
    per_page?: void;
    /**
     * @example 1
     */
    total_count?: void;
  };
};

export type EmailSettings = EmailEmailSettingsProperties;

export type EmailUpdateCatchAllRuleProperties = {
  actions: EmailRuleCatchallActions;
  enabled?: EmailRuleEnabled;
  matchers: EmailRuleCatchallMatchers;
  name?: EmailRuleName;
};

export type EmailUpdateRuleProperties = {
  actions: EmailRuleActions;
  enabled?: EmailRuleEnabled;
  matchers: EmailRuleMatchers;
  name?: EmailRuleName;
  priority?: EmailRulePriority;
};

/**
 * The date and time the destination address has been verified. Null means not verified yet.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 */
export type EmailVerified = string;

export type EmailZoneId = EmailIdentifier;

/**
 * Defines an account identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type FirewallAccountIdentifier = string;

/**
 * The action to perform when the threshold of matched traffic within the configured period is exceeded.
 */
export type FirewallAction = {
  mode?: FirewallMode;
  response?: FirewallCustomResponse;
  timeout?: FirewallTimeout;
};

/**
 * The default action performed by the rules in the WAF package.
 *
 * @default challenge
 */
export type FirewallActionMode = "simulate" | "block" | "challenge";

/**
 * A summary of the purpose/function of the WAF package.
 *
 * @example Covers OWASP Top 10 vulnerabilities and more.
 */
export type FirewallAnomalyDescription = string;

/**
 * When a WAF package uses anomaly detection, each rule is given a score when triggered. If the total score of all triggered rules exceeds the sensitivity defined on the WAF package, the action defined on the package will be taken.
 *
 * @example anomaly
 */
export type FirewallAnomalyDetectionMode = string;

/**
 * The name of the WAF package.
 *
 * @example OWASP ModSecurity Core Rule Set
 */
export type FirewallAnomalyName = string;

export type FirewallAnomalyPackage = {
  description: FirewallAnomalyDescription;
  detection_mode: FirewallAnomalyDetectionMode;
  id: FirewallIdentifier;
  name: FirewallAnomalyName;
  status?: FirewallStatus;
  zone_id: FirewallIdentifier;
  action_mode?: FirewallActionMode;
  sensitivity?: FirewallSensitivity;
};

export type FirewallApiResponseCollection = {
  errors: FirewallMessages;
  messages: FirewallMessages;
  result: Record<string, any> | Record<string, any>[] | string | null;
  /**
   * Defines whether the API call was successful.
   *
   * @example true
   */
  success: true;
  result_info?: FirewallResultInfo;
};

export type FirewallApiResponseCommon = {
  errors: FirewallMessages;
  messages: FirewallMessages;
  result: Record<string, any> | Record<string, any>[] | string;
  /**
   * Defines whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type FirewallApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: FirewallMessages;
  messages: FirewallMessages;
  result: any | null;
  /**
   * Defines whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type FirewallApiResponseSingle = {
  errors: FirewallMessages;
  messages: FirewallMessages;
  result: (Record<string, any> | null) | (string | null) | string;
  /**
   * Defines whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type FirewallApiResponseSingleId = {
  errors: FirewallMessages;
  messages: FirewallMessages;
  result:
    | {
        id: FirewallIdentifier;
      }
    | Record<string, any>[]
    | string
    | null;
  /**
   * Defines whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type FirewallAsnConfiguration = {
  /**
   * The configuration target. You must set the target to `asn` when specifying an Autonomous System Number (ASN) in the rule.
   *
   * @example asn
   */
  target?: "asn";
  /**
   * The AS number to match.
   *
   * @example AS12345
   */
  value?: string;
};

/**
 * The response body to return. The value must conform to the configured content type.
 *
 * @example <error>This request has been rate-limited.</error>
 * @maxLength 10240
 */
export type FirewallBody = string;

/**
 * Criteria specifying when the current rate limit should be bypassed. You can specify that the rate limit should not apply to one or more URLs.
 */
export type FirewallBypass = {
  /**
   * @example url
   */
  name?: "url";
  /**
   * The URL to bypass.
   *
   * @example api.example.com/*
   */
  value?: string;
}[];

export type FirewallCidrConfiguration = {
  /**
   * The configuration target. You must set the target to `ip_range` when specifying an IP address range in the rule.
   *
   * @example ip_range
   */
  target?: "ip_range";
  /**
   * The IP address range to match. You can only use prefix lengths `/16` and `/24` for IPv4 ranges, and prefix lengths `/32`, `/48`, and `/64` for IPv6 ranges.
   *
   * @example 198.51.100.4/16
   */
  value?: string;
};

/**
 * The action to perform when the rule matches.
 *
 * @example execute
 * @pattern ^[a-z_]+$
 */
export type FirewallComponentsSchemasAction = string;

/**
 * An informative summary of the current URI-based WAF override.
 *
 * @example Enable Cloudflare Magento ruleset for shop.example.com
 * @maxLength 1024
 * @x-auditable true
 */
export type FirewallComponentsSchemasDescription = string | null;

/**
 * The unique identifier of the resource.
 *
 * @example de677e5818985db1285d0e80225f06e5
 * @maxLength 32
 */
export type FirewallComponentsSchemasIdentifier = string;

/**
 * The action to apply to a matched request.
 *
 * @example js_challenge
 * @maxLength 12
 */
export type FirewallComponentsSchemasMode =
  | "block"
  | "challenge"
  | "js_challenge"
  | "managed_challenge";

/**
 * When true, indicates that the firewall rule is currently paused.
 *
 * @example false
 */
export type FirewallComponentsSchemasPaused = boolean;

/**
 * The priority of the rule. Optional value used to define the processing order. A lower number indicates a higher priority. If not provided, rules with a defined priority will be processed before rules without a priority.
 *
 * @example 50
 * @maximum 2147483647
 * @minimum 0
 */
export type FirewallComponentsSchemasPriority = number;

/**
 * The reference of the rule (the rule ID by default).
 *
 * @example my_ref
 */
export type FirewallComponentsSchemasRef = string;

/**
 * The unique identifier of the User Agent Blocking rule.
 *
 * @example 372e67954025e0ba6aaa6d586b9e0b59
 * @maxLength 32
 * @x-auditable true
 */
export type FirewallComponentsUaRuleId = string;

/**
 * The rule configuration.
 */
export type FirewallConfiguration =
  | FirewallIpConfiguration
  | FirewallIpv6Configuration
  | FirewallCidrConfiguration
  | FirewallAsnConfiguration
  | FirewallCountryConfiguration;

/**
 * A list of IP addresses or CIDR ranges that will be allowed to access the URLs specified in the Zone Lockdown rule. You can include any number of `ip` or `ip_range` configurations.
 */
export type FirewallConfigurations = (
  | FirewallSchemasIpConfiguration
  | FirewallSchemasCidrConfiguration
)[];

/**
 * The content type of the body. Must be one of the following: `text/plain`, `text/xml`, or `application/json`.
 *
 * @example text/xml
 * @maxLength 50
 * @x-auditable true
 */
export type FirewallContentType = string;

export type FirewallCountryConfiguration = {
  /**
   * The configuration target. You must set the target to `country` when specifying a country code in the rule.
   *
   * @example country
   */
  target?: "country";
  /**
   * The two-letter ISO-3166-1 alpha-2 code to match. For more information, refer to [IP Access rules: Parameters](https://developers.cloudflare.com/waf/tools/ip-access-rules/parameters/#country).
   *
   * @example US
   * @x-auditable true
   */
  value?: string;
};

/**
 * The timestamp of when the rule was created.
 *
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type FirewallCreatedOn = string;

/**
 * A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
 * Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed_challenge", or "js_challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object.
 */
export type FirewallCustomResponse = {
  body?: FirewallBody;
  content_type?: FirewallContentType;
};

/**
 * When true, indicates that Cloudflare should also delete the associated filter if there are no other firewall rules referencing the filter.
 */
export type FirewallDeleteFilterIfUnused = boolean;

/**
 * When true, indicates that the firewall rule was deleted.
 *
 * @example true
 */
export type FirewallDeleted = boolean;

export type FirewallDeletedFilter = {
  deleted: FirewallDeleted;
  id: FirewallFiltersComponentsSchemasId;
};

/**
 * An informative summary of the rule. This value is sanitized and any tags will be removed.
 *
 * @example Prevent multiple login failures to mitigate brute force attacks
 * @maxLength 1024
 * @x-auditable true
 */
export type FirewallDescription = string;

/**
 * A string to search for in the description of existing rules.
 *
 * @example abusive
 * @x-auditable true
 */
export type FirewallDescriptionSearch = string;

/**
 * The mode that defines how rules within the package are evaluated during the course of a request. When a package uses anomaly detection mode (`anomaly` value), each rule is given a score when triggered. If the total score of all triggered rules exceeds the sensitivity defined in the WAF package, the action configured in the package will be performed. Traditional detection mode (`traditional` value) will decide the action to take when it is triggered by the request. If multiple rules are triggered, the action providing the highest protection will be applied (for example, a 'block' action will win over a 'challenge' action).
 *
 * @example traditional
 */
export type FirewallDetectionMode = "anomaly" | "traditional";

/**
 * When true, indicates that the rate limit is currently disabled.
 *
 * @example false
 * @x-auditable true
 */
export type FirewallDisabled = boolean;

/**
 * The contact email address of the user.
 *
 * @example user@example.com
 * @maxLength 90
 */
export type FirewallEmail = string;

/**
 * Whether the rule should be executed.
 *
 * @default true
 * @example true
 */
export type FirewallEnabled = boolean;

/**
 * The filter expression. For more information, refer to [Expressions](https://developers.cloudflare.com/ruleset-engine/rules-language/expressions/).
 *
 * @example (http.request.uri.path ~ ".*wp-login.php" or http.request.uri.path ~ ".*xmlrpc.php") and ip.addr ne 172.16.22.155
 */
export type FirewallExpression = string;

export type FirewallFilter = {
  description?: FirewallFiltersComponentsSchemasDescription;
  expression?: FirewallExpression;
  id?: FirewallFiltersComponentsSchemasId;
  paused?: FirewallFiltersComponentsSchemasPaused;
  ref?: FirewallSchemasRef;
};

export type FirewallFilterDeleteResponseCollection =
  FirewallApiResponseCollection & {
    result?: FirewallFilter[];
  };

export type FirewallFilterDeleteResponseSingle = FirewallApiResponseSingle & {
  result: {
    description?: FirewallFiltersComponentsSchemasDescription;
    expression?: FirewallExpression;
    id: FirewallFiltersComponentsSchemasId;
    paused?: FirewallFiltersComponentsSchemasPaused;
    ref?: FirewallSchemasRef;
  };
};

export type FirewallFilterResponseCollection = FirewallApiResponseCollection & {
  result?: FirewallFilter[];
};

export type FirewallFilterResponseSingle = FirewallApiResponseSingle & {
  result: FirewallFilter;
};

export type FirewallFilterRuleBase = {
  action?: FirewallSchemasAction;
  description?: FirewallFirewallRulesComponentsSchemasDescription;
  id?: FirewallFirewallRulesComponentsSchemasId;
  paused?: FirewallComponentsSchemasPaused;
  priority?: FirewallComponentsSchemasPriority;
  products?: FirewallProducts;
  ref?: FirewallRef;
};

export type FirewallFilterRuleResponse = FirewallFilterRuleBase & {
  filter?: FirewallFilter | FirewallDeletedFilter;
};

export type FirewallFilterRulesResponseCollection =
  FirewallApiResponseCollection & {
    result: FirewallFilterRuleResponse[];
  };

export type FirewallFilterRulesResponseCollectionDelete =
  FirewallApiResponseCollection & {
    result: FirewallFilterRuleResponse[];
  };

export type FirewallFilterRulesSingleResponse = FirewallApiResponseSingle & {
  result: FirewallFilterRuleResponse;
};

export type FirewallFilterRulesSingleResponseDelete =
  FirewallApiResponseSingle & {
    result: FirewallFilterRuleResponse;
  };

export type FirewallFilters = {
  /**
   * The target to search in existing rules.
   *
   * @example ip
   * @x-auditable true
   */
  ["configuration.target"]?: "ip" | "ip_range" | "asn" | "country";
  /**
   * The target value to search for in existing rules: an IP address, an IP address range, or a country code, depending on the provided `configuration.target`.
   * Notes: You can search for a single IPv4 address, an IP address range with a subnet of '/16' or '/24', or a two-letter ISO-3166-1 alpha-2 country code.
   *
   * @example 198.51.100.4
   */
  ["configuration.value"]?: string;
  /**
   * When set to `all`, all the search requirements must match. When set to `any`, only one of the search requirements has to match.
   *
   * @default all
   * @x-auditable true
   */
  match?: "any" | "all";
  mode?: FirewallSchemasMode;
  /**
   * The string to search for in the notes of existing IP Access rules.
   * Notes: For example, the string 'attack' would match IP Access rules with notes 'Attack 26/02' and 'Attack 27/02'. The search is case insensitive.
   *
   * @example my note
   * @x-auditable true
   */
  notes?: string;
};

/**
 * An informative summary of the filter.
 *
 * @example Restrict access from these browsers on this address range.
 * @maxLength 500
 */
export type FirewallFiltersComponentsSchemasDescription = string;

/**
 * The unique identifier of the filter.
 *
 * @example 372e67954025e0ba6aaa6d586b9e0b61
 * @maxLength 32
 * @minLength 32
 */
export type FirewallFiltersComponentsSchemasId = string;

/**
 * When true, indicates that the filter is currently paused.
 *
 * @example false
 */
export type FirewallFiltersComponentsSchemasPaused = boolean;

/**
 * An informative summary of the firewall rule.
 *
 * @example Blocks traffic identified during investigation for MIR-31
 * @maxLength 500
 */
export type FirewallFirewallRulesComponentsSchemasDescription = string;

/**
 * The unique identifier of the firewall rule.
 *
 * @example 372e67954025e0ba6aaa6d586b9e0b60
 * @maxLength 32
 */
export type FirewallFirewallRulesComponentsSchemasId = string;

export type FirewallFirewalluablock = {
  configuration?: FirewallSchemasConfiguration;
  description?: FirewallFirewalluablockComponentsSchemasDescription;
  id?: FirewallComponentsUaRuleId;
  mode?: FirewallComponentsSchemasMode;
  paused?: FirewallSchemasPaused;
};

/**
 * An informative summary of the rule.
 *
 * @example Prevent access from abusive clients identified by this User Agent to mitigate a DDoS attack
 * @maxLength 1024
 */
export type FirewallFirewalluablockComponentsSchemasDescription = string;

export type FirewallFirewalluablockResponseCollection = {
  result?: FirewallFirewalluablock[];
} & FirewallApiResponseCollection;

export type FirewallFirewalluablockResponseSingle = {
  result?: FirewallFirewalluablock;
} & FirewallApiResponseSingle;

/**
 * An object that allows you to enable or disable WAF rule groups for the current WAF override. Each key of this object must be the ID of a WAF rule group, and each value must be a valid WAF action (usually `default` or `disable`). When creating a new URI-based WAF override, you must provide a `groups` object or a `rules` object.
 *
 * @example {"ea8687e59929c1fd05ba97574ad43f77":"default"}
 */
export type FirewallGroups = {
  [key: string]: any;
};

/**
 * The name of the response header to match.
 *
 * @example Cf-Cache-Status
 * @x-auditable true
 */
export type FirewallHeaderName = string;

/**
 * The operator used when matching: `eq` means "equal" and `ne` means "not equal".
 *
 * @example ne
 * @x-auditable true
 */
export type FirewallHeaderOp = "eq" | "ne";

/**
 * The value of the response header, which must match exactly.
 *
 * @example HIT
 * @x-auditable true
 */
export type FirewallHeaderValue = string;

/**
 * The unique identifier of the rate limit.
 *
 * @example 372e67954025e0ba6aaa6d586b9e0b59
 * @maxLength 32
 * @x-auditable true
 */
export type FirewallId = string;

/**
 * Defines an identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type FirewallIdentifier = string;

export type FirewallIpConfiguration = {
  /**
   * The configuration target. You must set the target to `ip` when specifying an IP address in the rule.
   *
   * @example ip
   */
  target?: "ip";
  /**
   * The IP address to match. This address will be compared to the IP address of incoming requests.
   *
   * @example 198.51.100.4
   */
  value?: string;
};

/**
 * A single IP address range to search for in existing rules.
 *
 * @example 1.2.3.0/16
 * @x-auditable true
 */
export type FirewallIpRangeSearch = string;

/**
 * A single IP address to search for in existing rules.
 *
 * @example 1.2.3.4
 */
export type FirewallIpSearch = string;

export type FirewallIpv6Configuration = {
  /**
   * The configuration target. You must set the target to `ip6` when specifying an IPv6 address in the rule.
   *
   * @example ip6
   */
  target?: "ip6";
  /**
   * The IPv6 address to match.
   *
   * @example 2001:DB8:100::CF
   */
  value?: string;
};

/**
 * An informative summary of the rule.
 *
 * @example Restrict access to these endpoints to requests from a known IP address
 * @maxLength 1024
 */
export type FirewallLockdownsComponentsSchemasDescription = string;

/**
 * The unique identifier of the Zone Lockdown rule.
 *
 * @example 372e67954025e0ba6aaa6d586b9e0b59
 * @maxLength 32
 * @x-auditable true
 */
export type FirewallLockdownsComponentsSchemasId = string;

/**
 * Determines which traffic the rate limit counts towards the threshold.
 */
export type FirewallMatch = {
  headers?: {
    name?: FirewallHeaderName;
    op?: FirewallHeaderOp;
    value?: FirewallHeaderValue;
  }[];
  request?: {
    methods?: FirewallMethods;
    schemes?: FirewallSchemes;
    url?: FirewallUrl;
  };
  response?: {
    origin_traffic?: FirewallOriginTraffic;
  };
};

export type FirewallMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * The HTTP methods to match. You can specify a subset (for example, `['POST','PUT']`) or all methods (`['_ALL_']`). This field is optional when creating a rate limit.
 *
 * @example GET
 * @example POST
 */
export type FirewallMethods = (
  | "GET"
  | "POST"
  | "PUT"
  | "DELETE"
  | "PATCH"
  | "HEAD"
  | "_ALL_"
)[];

/**
 * The action to perform.
 *
 * @example challenge
 * @x-auditable true
 */
export type FirewallMode =
  | "simulate"
  | "ban"
  | "challenge"
  | "js_challenge"
  | "managed_challenge";

/**
 * The timestamp of when the rule was last modified.
 *
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type FirewallModifiedOn = string;

/**
 * The name of the WAF package.
 *
 * @example USER
 */
export type FirewallName = string;

/**
 * An informative summary of the rule, typically used as a reminder or explanation.
 *
 * @example This rule is enabled because of an event that occurred on date X.
 * @x-auditable true
 */
export type FirewallNotes = string;

/**
 * When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
 * Notes: This field is deprecated. Instead, use response headers and set "origin_traffic" to "false" to avoid legacy behaviour interacting with the "response_headers" property.
 *
 * @x-auditable true
 */
export type FirewallOriginTraffic = boolean;

export type FirewallOverride = {
  description?: FirewallComponentsSchemasDescription;
  groups?: FirewallGroups;
  id?: FirewallOverridesId;
  paused?: FirewallPaused;
  priority?: FirewallPriority;
  rewrite_action?: FirewallRewriteAction;
  rules?: FirewallRules;
  urls?: FirewallUrls;
};

export type FirewallOverrideResponseCollection =
  FirewallApiResponseCollection & {
    result: FirewallOverride[];
  };

export type FirewallOverrideResponseSingle = FirewallApiResponseSingle & {
  result: FirewallOverride;
};

/**
 * The unique identifier of the WAF override.
 *
 * @example de677e5818985db1285d0e80225f06e5
 * @maxLength 32
 * @x-auditable true
 */
export type FirewallOverridesId = string;

export type FirewallPackage =
  | FirewallPackageDefinition
  | FirewallAnomalyPackage;

export type FirewallPackageDefinition = {
  description: FirewallSchemasDescription;
  detection_mode: FirewallDetectionMode;
  id: FirewallIdentifier;
  name: FirewallName;
  status?: FirewallStatus;
  zone_id: FirewallIdentifier;
};

/**
 * Defines a package identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type FirewallPackageId = string;

export type FirewallPackageResponseCollection =
  | FirewallApiResponseCollection
  | {
      result?: FirewallPackage[];
    };

export type FirewallPackageResponseSingle =
  | FirewallApiResponseSingle
  | {
      result?: Record<string, any>;
    };

/**
 * When true, indicates that the rule is currently paused.
 *
 * @x-auditable true
 */
export type FirewallPaused = boolean;

/**
 * The time in seconds (an integer value) to count matching traffic. If the count exceeds the configured threshold within this period, Cloudflare will perform the configured action.
 *
 * @example 900
 * @maximum 86400
 * @minimum 10
 * @x-auditable true
 */
export type FirewallPeriod = number;

/**
 * The relative priority of the current URI-based WAF override when multiple overrides match a single URL. A lower number indicates higher priority. Higher priority overrides may overwrite values set by lower priority overrides.
 *
 * @example 1
 * @maximum 1000000000
 * @minimum -1000000000
 * @x-auditable true
 */
export type FirewallPriority = number;

export type FirewallProducts = (
  | "zoneLockdown"
  | "uaBlock"
  | "bic"
  | "hot"
  | "securityLevel"
  | "rateLimit"
  | "waf"
)[];

export type FirewallRateLimits = FirewallRatelimit;

/**
 * Defines the unique identifier of the rate limit.
 *
 * @example 372e67954025e0ba6aaa6d586b9e0b59
 * @maxLength 32
 */
export type FirewallRateLimitId = string;

export type FirewallRatelimit = {
  action?: FirewallAction;
  bypass?: FirewallBypass;
  description?: FirewallDescription;
  disabled?: FirewallDisabled;
  id?: FirewallId;
  match?: FirewallMatch;
  period?: FirewallPeriod;
  threshold?: FirewallThreshold;
};

export type FirewallRatelimitResponseCollection =
  FirewallApiResponseCollection & {
    result?: FirewallRateLimits[];
  };

export type FirewallRatelimitResponseSingle = FirewallApiResponseSingle & {
  result?: FirewallRateLimits;
};

/**
 * A short reference tag. Allows you to select related firewall rules.
 *
 * @example MIR-31
 * @maxLength 50
 */
export type FirewallRef = string;

export type FirewallResponseCollection = FirewallApiResponseCollection & {
  result?: FirewallSchemasRule[];
};

export type FirewallResponseSingle = FirewallApiResponseSingle & {
  result?: FirewallSchemasRule;
};

export type FirewallResultInfo = {
  /**
   * Defines the total number of results for the requested service.
   *
   * @example 1
   */
  count?: number;
  /**
   * Defines the current page within paginated list of results.
   *
   * @example 1
   */
  page?: number;
  /**
   * Defines the number of results per page of results.
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Defines the total results available without any search parameters.
   *
   * @example 2000
   */
  total_count?: number;
};

/**
 * Specifies that, when a WAF rule matches, its configured action will be replaced by the action configured in this object.
 */
export type FirewallRewriteAction = {
  block?: FirewallWafRewriteAction;
  challenge?: FirewallWafRewriteAction;
  ["default"]?: FirewallWafRewriteAction;
  disable?: FirewallWafRewriteAction;
  simulate?: FirewallWafRewriteAction;
};

export type FirewallRule = {
  /**
   * The available actions that a rule can apply to a matched request.
   *
   * @example whitelist
   * @example block
   * @example challenge
   * @example js_challenge
   * @example managed_challenge
   */
  allowed_modes: FirewallSchemasMode[];
  configuration: FirewallConfiguration;
  /**
   * The timestamp of when the rule was created.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  created_on?: string;
  id: FirewallSchemasIdentifier;
  mode: FirewallSchemasMode;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string;
  notes?: FirewallNotes;
};

export type FirewallRuleCollectionResponse = FirewallApiResponseCollection & {
  result?: FirewallRule[];
};

/**
 * Unique identifier for a rule.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type FirewallRuleIdentifier = string;

export type FirewallRuleSingleIdResponse = FirewallApiResponseSingle & {
  result?: {
    id?: FirewallSchemasIdentifier;
  };
};

export type FirewallRuleSingleResponse = FirewallApiResponseSingle & {
  result?: FirewallRule;
};

/**
 * An object that allows you to override the action of specific WAF rules. Each key of this object must be the ID of a WAF rule, and each value must be a valid WAF action. Unless you are disabling a rule, ensure that you also enable the rule group that this WAF rule belongs to. When creating a new URI-based WAF override, you must provide a `groups` object or a `rules` object.
 *
 * @example {"100015":"disable"}
 */
export type FirewallRules = {
  [key: string]: FirewallWafAction;
};

/**
 * An informative description of the rule.
 *
 * @default
 * @example Execute the OWASP ruleset when the IP address is not 1.1.1.1
 */
export type FirewallRulesComponentsSchemasDescription = string;

/**
 * The action to apply to a matched request. The `log` action is only available on an Enterprise plan.
 *
 * @example block
 */
export type FirewallSchemasAction =
  | "block"
  | "challenge"
  | "js_challenge"
  | "managed_challenge"
  | "allow"
  | "log"
  | "bypass";

export type FirewallSchemasCidrConfiguration = {
  /**
   * The configuration target. You must set the target to `ip_range` when specifying an IP address range in the Zone Lockdown rule.
   *
   * @example ip_range
   */
  target?: "ip_range";
  /**
   * The IP address range to match. You can only use prefix lengths `/16` and `/24`.
   *
   * @example 198.51.100.4/16
   */
  value?: string;
};

/**
 * The configuration object for the current rule.
 */
export type FirewallSchemasConfiguration = {
  /**
   * The configuration target for this rule. You must set the target to `ua` for User Agent Blocking rules.
   *
   * @example ua
   */
  target?: string;
  /**
   * The exact user agent string to match. This value will be compared to the received `User-Agent` HTTP header value.
   *
   * @example Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/603.2.4 (KHTML, like Gecko) Version/10.1.1 Safari/603.2.4
   */
  value?: string;
};

/**
 * A summary of the purpose/function of the WAF package.
 *
 * @example null
 */
export type FirewallSchemasDescription = string;

/**
 * A string to search for in the description of existing rules.
 *
 * @example endpoints
 * @x-auditable true
 */
export type FirewallSchemasDescriptionSearch = string;

/**
 * The expression defining which traffic will match the rule.
 *
 * @example ip.src ne 1.1.1.1
 */
export type FirewallSchemasExpression = string;

/**
 * The unique identifier of the IP Access rule.
 *
 * @example 92f17202ed8bd63d69a66b86a49a8f6b
 * @maxLength 32
 * @x-auditable true
 */
export type FirewallSchemasIdentifier = string;

export type FirewallSchemasIpConfiguration = {
  /**
   * The configuration target. You must set the target to `ip` when specifying an IP address in the Zone Lockdown rule.
   *
   * @example ip
   */
  target?: "ip";
  /**
   * The IP address to match. This address will be compared to the IP address of incoming requests.
   *
   * @example 198.51.100.4
   */
  value?: string;
};

/**
 * The action to apply to a matched request.
 *
 * @example challenge
 * @x-auditable true
 */
export type FirewallSchemasMode =
  | "block"
  | "challenge"
  | "whitelist"
  | "js_challenge"
  | "managed_challenge";

/**
 * When true, indicates that the rule is currently paused.
 *
 * @example false
 * @x-auditable true
 */
export type FirewallSchemasPaused = boolean;

/**
 * The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
 *
 * @example 5
 * @x-auditable true
 */
export type FirewallSchemasPriority = number;

/**
 * A short reference tag. Allows you to select related filters.
 *
 * @example FIL-100
 * @maxLength 50
 */
export type FirewallSchemasRef = string;

export type FirewallSchemasRule = FirewallRule & {
  /**
   * All zones owned by the user will have the rule applied.
   */
  scope?: {
    email?: FirewallEmail;
    id?: FirewallIdentifier;
    /**
     * Defines the scope of the rule.
     *
     * @example user
     */
    type?: "user" | "organization";
  };
};

/**
 * The URLs to include in the rule definition. You can use wildcards. Each entered URL will be escaped before use, which means you can only use simple wildcard patterns.
 */
export type FirewallSchemasUrls = string[];

/**
 * The HTTP schemes to match. You can specify one scheme (`['HTTPS']`), both schemes (`['HTTP','HTTPS']`), or all schemes (`['_ALL_']`). This field is optional.
 *
 * @example HTTP
 * @example HTTPS
 * @x-auditable true
 */
export type FirewallSchemes = string[];

/**
 * The sensitivity of the WAF package.
 *
 * @default high
 */
export type FirewallSensitivity = "high" | "medium" | "low" | "off";

/**
 * When set to `active`, indicates that the WAF package will be applied to the zone.
 *
 * @default active
 */
export type FirewallStatus = "active";

/**
 * The threshold that will trigger the configured mitigation action. Configure this value along with the `period` property to establish a threshold per period.
 *
 * @example 60
 * @minimum 1
 * @x-auditable true
 */
export type FirewallThreshold = number;

/**
 * The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
 * Notes: If "mode" is "challenge", "managed_challenge", or "js_challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
 *
 * @example 86400
 * @maximum 86400
 * @minimum 1
 * @x-auditable true
 */
export type FirewallTimeout = number;

export type FirewallUaConfiguration = {
  /**
   * The configuration target. You must set the target to `ua` when specifying a user agent in the rule.
   *
   * @example ua
   */
  target?: "ua";
  /**
   * the user agent to exactly match
   *
   * @example Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)
   * @x-auditable true
   */
  value?: string;
};

/**
 * A single URI to search for in the list of URLs of existing rules.
 *
 * @example /some/path
 * @x-auditable true
 */
export type FirewallUriSearch = string;

/**
 * The URL pattern to match, composed of a host and a path such as `example.org/path*`. Normalization is applied before the pattern is matched. `*` wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to `*` to match all traffic to your zone.
 *
 * @example *.example.org/path*
 * @maxLength 1024
 * @x-auditable true
 */
export type FirewallUrl = string;

/**
 * The URLs to include in the current WAF override. You can use wildcards. Each entered URL will be escaped before use, which means you can only use simple wildcard patterns.
 */
export type FirewallUrls = string[];

/**
 * The WAF rule action to apply.
 */
export type FirewallWafAction =
  | "challenge"
  | "block"
  | "simulate"
  | "disable"
  | "default";

/**
 * The WAF rule action to apply.
 *
 * @x-auditable true
 */
export type FirewallWafRewriteAction =
  | "challenge"
  | "block"
  | "simulate"
  | "disable"
  | "default";

export type FirewallZonelockdown = {
  configurations: FirewallConfigurations;
  created_on: FirewallCreatedOn;
  description: FirewallLockdownsComponentsSchemasDescription;
  id: FirewallLockdownsComponentsSchemasId;
  modified_on: FirewallModifiedOn;
  paused: FirewallSchemasPaused;
  urls: FirewallSchemasUrls;
};

export type FirewallZonelockdownResponseCollection =
  FirewallApiResponseCollection & {
    result: FirewallZonelockdown[];
  };

export type FirewallZonelockdownResponseSingle = FirewallApiResponseSingle & {
  result: FirewallZonelockdown;
};

/**
 * The hostname or IP address of the origin server to run health checks on.
 *
 * @example www.example.com
 */
export type HealthchecksAddress = string;

export type HealthchecksApiResponseCollection = {
  errors: HealthchecksMessages;
  messages: HealthchecksMessages;
  result: Record<string, any> | any[] | string | null;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
  result_info?: HealthchecksResultInfo;
};

export type HealthchecksApiResponseCommon = {
  errors: HealthchecksMessages;
  messages: HealthchecksMessages;
  result: Record<string, any> | any[] | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type HealthchecksApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: HealthchecksMessages;
  messages: HealthchecksMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

export type HealthchecksApiResponseSingle = {
  errors: HealthchecksMessages;
  messages: HealthchecksMessages;
  result:
    | (Record<string, any> | any[] | string)
    | (Record<string, any> | any[] | string);
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

/**
 * A list of regions from which to run health checks. Null means Cloudflare will pick a default region.
 *
 * @example WEU
 * @example ENAM
 */
export type HealthchecksCheckRegions =
  | (
      | "WNAM"
      | "ENAM"
      | "WEU"
      | "EEU"
      | "NSAM"
      | "SSAM"
      | "OC"
      | "ME"
      | "NAF"
      | "SAF"
      | "IN"
      | "SEAS"
      | "NEAS"
      | "ALL_REGIONS"
    )[]
  | null;

/**
 * The number of consecutive fails required from a health check before changing the health to unhealthy.
 *
 * @default 1
 */
export type HealthchecksConsecutiveFails = number;

/**
 * The number of consecutive successes required from a health check before changing the health to healthy.
 *
 * @default 1
 */
export type HealthchecksConsecutiveSuccesses = number;

/**
 * A human-readable description of the health check.
 *
 * @example Health check for www.example.com
 */
export type HealthchecksDescription = string;

/**
 * The current failure reason if status is unhealthy.
 *
 * @example
 */
export type HealthchecksFailureReason = string;

export type HealthchecksHealthchecks = {
  address?: HealthchecksAddress;
  check_regions?: HealthchecksCheckRegions;
  consecutive_fails?: HealthchecksConsecutiveFails;
  consecutive_successes?: HealthchecksConsecutiveSuccesses;
  created_on?: HealthchecksTimestamp;
  description?: HealthchecksDescription;
  failure_reason?: HealthchecksFailureReason;
  http_config?: HealthchecksHttpConfig;
  id?: HealthchecksIdentifier;
  interval?: HealthchecksInterval;
  modified_on?: HealthchecksTimestamp;
  name?: HealthchecksName;
  retries?: HealthchecksRetries;
  status?: HealthchecksStatus;
  suspended?: HealthchecksSuspended;
  tcp_config?: HealthchecksTcpConfig;
  timeout?: HealthchecksTimeout;
  type?: HealthchecksType;
};

/**
 * Parameters specific to an HTTP or HTTPS health check.
 */
export type HealthchecksHttpConfig = {
  /**
   * Do not validate the certificate when the health check uses HTTPS.
   *
   * @default false
   */
  allow_insecure?: boolean;
  /**
   * A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
   *
   * @example success
   */
  expected_body?: string;
  /**
   * The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
   *
   * @default 200
   * @example 2xx
   * @example 302
   */
  expected_codes?: string[] | null;
  /**
   * Follow redirects if the origin returns a 3xx status code.
   *
   * @default false
   */
  follow_redirects?: boolean;
  /**
   * The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
   *
   * @example {"Host":["example.com"],"X-App-ID":["abc123"]}
   */
  header?: {
    [key: string]: string[];
  } | null;
  /**
   * The HTTP method to use for the health check.
   *
   * @default GET
   */
  method?: "GET" | "HEAD";
  /**
   * The endpoint path to health check against.
   *
   * @default /
   * @example /health
   */
  path?: string;
  /**
   * Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
   *
   * @default 80
   */
  port?: number;
} | null;

export type HealthchecksIdResponse = HealthchecksApiResponseSingle & {
  result?: {
    id?: HealthchecksIdentifier;
  };
};

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type HealthchecksIdentifier = string;

/**
 * The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase load on the origin as we check from multiple locations.
 *
 * @default 60
 */
export type HealthchecksInterval = number;

export type HealthchecksMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * A short name to identify the health check. Only alphanumeric characters, hyphens and underscores are allowed.
 *
 * @example server-1
 */
export type HealthchecksName = string;

export type HealthchecksQueryHealthcheck = {
  address: HealthchecksAddress;
  check_regions?: HealthchecksCheckRegions;
  consecutive_fails?: HealthchecksConsecutiveFails;
  consecutive_successes?: HealthchecksConsecutiveSuccesses;
  description?: HealthchecksDescription;
  http_config?: HealthchecksHttpConfig;
  interval?: HealthchecksInterval;
  name: HealthchecksName;
  retries?: HealthchecksRetries;
  suspended?: HealthchecksSuspended;
  tcp_config?: HealthchecksTcpConfig;
  timeout?: HealthchecksTimeout;
  type?: HealthchecksType;
};

export type HealthchecksResponseCollection =
  HealthchecksApiResponseCollection & {
    result?: HealthchecksHealthchecks[];
  };

export type HealthchecksResultInfo = {
  /**
   * Total number of results for the requested service
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters
   *
   * @example 2000
   */
  total_count?: number;
};

/**
 * The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
 *
 * @default 2
 */
export type HealthchecksRetries = number;

export type HealthchecksSingleResponse = HealthchecksApiResponseSingle & {
  result?: HealthchecksHealthchecks;
};

/**
 * The current status of the origin server according to the health check.
 *
 * @example healthy
 */
export type HealthchecksStatus =
  | "unknown"
  | "healthy"
  | "unhealthy"
  | "suspended";

/**
 * If suspended, no health checks are sent to the origin.
 *
 * @default false
 */
export type HealthchecksSuspended = boolean;

/**
 * Parameters specific to TCP health check.
 */
export type HealthchecksTcpConfig = {
  /**
   * The TCP connection method to use for the health check.
   *
   * @default connection_established
   */
  method?: "connection_established";
  /**
   * Port number to connect to for the health check. Defaults to 80.
   *
   * @default 80
   */
  port?: number;
} | null;

/**
 * The timeout (in seconds) before marking the health check as failed.
 *
 * @default 5
 */
export type HealthchecksTimeout = number;

/**
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 */
export type HealthchecksTimestamp = string;

/**
 * The protocol to use for the health check. Currently supported protocols are 'HTTP', 'HTTPS' and 'TCP'.
 *
 * @default HTTP
 * @example HTTPS
 */
export type HealthchecksType = string;

export type HyperdriveApiResponseCollection = HyperdriveApiResponseCommon & {
  result_info?: HyperdriveResultInfo;
};

export type HyperdriveApiResponseCommon = {
  errors: HyperdriveMessages;
  messages: HyperdriveMessages;
  result: Record<string, any>;
  /**
   * Return the status of the API call success.
   *
   * @example true
   */
  success: true;
};

export type HyperdriveApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: HyperdriveMessages;
  messages: HyperdriveMessages;
  result: any | null;
  /**
   * Return the status of the API call success.
   *
   * @example false
   */
  success: false;
};

export type HyperdriveApiResponseSingle = HyperdriveApiResponseCommon;

export type HyperdriveHyperdriveCaching =
  | HyperdriveHyperdriveCachingDisabled
  | HyperdriveHyperdriveCachingEnabled;

export type HyperdriveHyperdriveCachingCommon = {
  /**
   * Set to true to disable caching of SQL responses. Default is false.
   *
   * @x-auditable true
   */
  disabled?: boolean;
};

export type HyperdriveHyperdriveCachingDisabled =
  HyperdriveHyperdriveCachingCommon;

export type HyperdriveHyperdriveCachingEnabled =
  HyperdriveHyperdriveCachingCommon & {
    /**
     * Specify the maximum duration items should persist in the cache. Not returned if set to the default (60).
     *
     * @example 60
     * @x-auditable true
     */
    max_age?: number;
    /**
     * Specify the number of seconds the cache may serve a stale response. Omitted if set to the default (15).
     *
     * @example 15
     * @x-auditable true
     */
    stale_while_revalidate?: number;
  };

export type HyperdriveHyperdriveConfig = {
  caching?: HyperdriveHyperdriveCaching;
  /**
   * Defines the creation time of the Hyperdrive configuration.
   *
   * @example 2017-01-01T00:00:00Z
   * @format date-time
   * @x-auditable true
   */
  created_on?: string;
  id: HyperdriveIdentifier;
  /**
   * Defines the last modified time of the Hyperdrive configuration.
   *
   * @example 2017-01-01T00:00:00Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string;
  mtls?: HyperdriveHyperdriveMtls;
  name: HyperdriveHyperdriveName;
  origin:
    | (HyperdriveHyperdriveDatabaseFull & HyperdriveInternetOrigin)
    | (HyperdriveHyperdriveDatabaseFull & HyperdriveOverAccessOrigin);
  origin_connection_limit?: HyperdriveHyperdriveOriginConnectionLimit;
};

export type HyperdriveHyperdriveConfigPatch = {
  caching?: HyperdriveHyperdriveCaching;
  mtls?: HyperdriveHyperdriveMtls;
  name?: HyperdriveHyperdriveName;
  origin?:
    | HyperdriveHyperdriveDatabase
    | (HyperdriveInternetOrigin | HyperdriveOverAccessOrigin);
  origin_connection_limit?: HyperdriveHyperdriveOriginConnectionLimit;
};

export type HyperdriveHyperdriveConfigResponse = HyperdriveHyperdriveConfig;

export type HyperdriveHyperdriveDatabase = {
  /**
   * Set the name of your origin database.
   *
   * @example postgres
   * @x-auditable true
   */
  database?: string;
  /**
   * Set the password needed to access your origin database. The API never returns this write-only value.
   *
   * @x-sensitive true
   */
  password?: string;
  scheme?: HyperdriveHyperdriveScheme;
  /**
   * Set the user of your origin database.
   *
   * @example postgres
   * @x-auditable true
   */
  user?: string;
};

export type HyperdriveHyperdriveDatabaseFull = HyperdriveHyperdriveDatabase;

export type HyperdriveHyperdriveMtls = {
  /**
   * Define CA certificate ID obtained after uploading CA cert.
   *
   * @example 00000000-0000-0000-0000-0000000000
   */
  ca_certificate_id?: string;
  /**
   * Define mTLS certificate ID obtained after uploading client cert.
   *
   * @example 00000000-0000-0000-0000-0000000000
   */
  mtls_certificate_id?: string;
  /**
   * Set SSL mode to 'require', 'verify-ca', or 'verify-full' to verify the CA.
   *
   * @example verify-full
   */
  sslmode?: string;
};

/**
 * @example example-hyperdrive
 * @x-auditable true
 */
export type HyperdriveHyperdriveName = string;

export type HyperdriveHyperdriveOrigin = HyperdriveHyperdriveDatabase &
  (HyperdriveInternetOrigin | HyperdriveOverAccessOrigin);

/**
 * The (soft) maximum number of connections the Hyperdrive is allowed to make to the origin database.
 *
 * @example 60
 * @maximum 100
 * @minimum 5
 * @x-auditable true
 */
export type HyperdriveHyperdriveOriginConnectionLimit = number;

/**
 * Specifies the URL scheme used to connect to your origin database.
 *
 * @x-auditable true
 */
export type HyperdriveHyperdriveScheme = "postgres" | "postgresql" | "mysql";

/**
 * Define configurations using a unique string identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type HyperdriveIdentifier = string;

export type HyperdriveInternetOrigin = {
  /**
   * Defines the host (hostname or IP) of your origin database.
   *
   * @example database.example.com
   * @x-auditable true
   */
  host: string;
  /**
   * Defines the port (default: 5432 for Postgres) of your origin database.
   *
   * @example 5432
   * @x-auditable true
   */
  port: number;
};

export type HyperdriveMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

export type HyperdriveOverAccessOrigin = {
  /**
   * Defines the Client ID of the Access token to use when connecting to the origin database.
   *
   * @example 0123456789abcdef0123456789abcdef.access
   * @x-auditable true
   */
  access_client_id: string;
  /**
   * Defines the Client Secret of the Access Token to use when connecting to the origin database. The API never returns this write-only value.
   *
   * @example 0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
   * @x-sensitive true
   */
  access_client_secret: string;
  /**
   * Defines the host (hostname or IP) of your origin database.
   *
   * @example database.example.com
   * @x-auditable true
   */
  host: string;
};

export type HyperdriveResultInfo = {
  /**
   * Defines the total number of results for the requested service.
   *
   * @example 1
   */
  count?: number;
  /**
   * Defines the current page within paginated list of results.
   *
   * @example 1
   */
  page?: number;
  /**
   * Defines the number of results per page of results.
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Defines the total results available without any search parameters.
   *
   * @example 2000
   */
  total_count?: number;
};

/**
 * Allow or deny operations against the resources.
 *
 * @example allow
 * @x-auditable true
 */
export type IamAccess = "allow" | "deny";

export type IamAccount = {
  /**
   * Timestamp for the creation of the account
   *
   * @example 2014-03-01T12:21:02.0000Z
   * @format date-time
   * @x-auditable true
   */
  created_on?: string;
  id: IamCommonComponentsSchemasIdentifier;
  /**
   * Account name
   *
   * @example Demo Account
   * @maxLength 100
   * @x-auditable true
   */
  name: string;
  /**
   * Account settings
   */
  settings?: {
    /**
     * Sets an abuse contact email to notify for abuse reports.
     *
     * @x-auditable true
     */
    abuse_contact_email?: string;
    /**
     * Indicates whether membership in this account requires that
     * Two-Factor Authentication is enabled
     *
     * @default false
     * @x-auditable true
     */
    enforce_twofactor?: boolean;
  };
};

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @minLength 32
 * @x-auditable true
 */
export type IamAccountIdentifier = IamCommonComponentsSchemasIdentifier;

export type IamApiResponseCollection = IamApiResponseCommon & {
  result_info?: IamResultInfo;
};

export type IamApiResponseCommon = {
  errors: IamSchemasMessages;
  messages: IamSchemasMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type IamApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: IamSchemasMessages;
  messages: IamSchemasMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type IamApiResponseSingle = IamApiResponseCommon;

export type IamApiResponseSingleId = IamApiResponseCommon & {
  result?: {
    id: IamCommonComponentsSchemasIdentifier;
  } | null;
};

/**
 * Enterprise only. Indicates whether or not API access is enabled specifically for this user on a given account.
 *
 * @example true
 * @x-auditable true
 */
export type IamApiAccessEnabled = boolean | null;

/**
 * List of IPv4/IPv6 CIDR addresses.
 *
 * @example 199.27.128.0/21
 * @example 2400:cb00::/32
 */
export type IamCidrList = string[];

/**
 * The unique activation code for the account membership.
 *
 * @example 05dd05cce12bbed97c0d87cd78e89bc2fd41a6cee72f27f6fc84af2e45c0fac0
 * @maxLength 64
 */
export type IamCode = string;

export type IamCollectionMemberResponseWithPolicies =
  IamApiResponseCollection & {
    result?: IamMemberWithPolicies[];
  };

export type IamCollectionMembershipResponse = IamApiResponseCollection & {
  result?: IamMembership[];
};

export type IamCollectionMembershipResponseWithPolicies =
  IamApiResponseCollection & {
    result?: IamMembershipWithPolicies[];
  };

export type IamCollectionOrganizationResponse = IamApiResponseCollection & {
  result?: IamOrganization[];
};

export type IamCollectionPermissionGroupsResponse = IamApiResponseCollection & {
  result?: IamPermissionGroups;
};

export type IamCollectionResourceGroupsResponse = IamApiResponseCollection & {
  result?: IamResourceGroups;
};

export type IamCollectionRoleResponse = IamApiResponseCollection & {
  result?: IamRole[];
};

export type IamCollectionTokensResponse = IamApiResponseCollection & {
  result?: IamTokenBase[];
};

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @minLength 32
 * @x-auditable true
 */
export type IamCommonComponentsSchemasIdentifier = string;

export type IamComponentsSchemasAccount = IamAccount;

/**
 * Whether the user is a member of the organization or has an invitation pending.
 *
 * @example member
 * @x-auditable true
 */
export type IamComponentsSchemasStatus = "member" | "invited";

export type IamCondition = {
  request_ip?: IamRequestIp;
};

/**
 * The country in which the user lives.
 *
 * @example US
 * @maxLength 30
 */
export type IamCountry = string | null;

export type IamCreateAccount = {
  /**
   * Account name
   */
  name: string;
  /**
   * the type of account being created. For self-serve customers, use standard. for enterprise customers, use enterprise.
   *
   * @example standard
   * @x-auditable true
   */
  type: "standard" | "enterprise";
  /**
   * information related to the tenant unit, and optionally, an id of the unit to create the account on. see https://developers.cloudflare.com/tenant/how-to/manage-accounts/
   */
  unit?: {
    /**
     * Tenant unit ID
     *
     * @example f267e341f3dd4697bd3b9f71dd96247f
     * @x-auditable true
     */
    id?: string;
  };
};

export type IamCreateMemberWithPolicies = {
  email: IamEmail;
  /**
   * Array of policies associated with this member.
   */
  policies: IamCreateMemberPolicy[];
  /**
   * @default pending
   * @x-auditable true
   */
  status?: "accepted" | "pending";
};

export type IamCreateMemberWithRoles = {
  email: IamEmail;
  /**
   * Array of roles associated with this member.
   */
  roles: IamRoleComponentsSchemasIdentifier[];
  /**
   * @default pending
   * @x-auditable true
   */
  status?: "accepted" | "pending";
};

/**
 * A scope is a combination of scope objects which provides additional context.
 */
export type IamCreateScope = {
  key: IamCreateResourceGroupScopeScopeKey;
  /**
   * A list of scope objects for additional context. The number of Scope objects should not be zero.
   */
  objects: IamCreateResourceGroupScopeScopeObject[];
};

export type IamCreateMemberPolicy = {
  access: IamAccess;
  id: IamIdentifier;
  permission_groups: IamMemberPermissionGroups;
  resource_groups: IamMemberResourceGroups;
};

export type IamCreatePayload = {
  condition?: IamCondition;
  expires_on?: IamExpiresOn;
  name: IamName;
  not_before?: IamNotBefore;
  policies: IamTokenPolicies;
};

/**
 * This is a combination of pre-defined resource name and identifier (like Account ID etc.)
 *
 * @example com.cloudflare.api.account.eb78d65290b24279ba6f44721b3ea3c4
 */
export type IamCreateResourceGroupScopeScopeKey = void;

/**
 * A scope object represents any resource that can have actions applied against invite.
 */
export type IamCreateResourceGroupScopeScopeObject = {
  key: IamCreateResourceGroupScopeScopeObjectKey;
};

/**
 * This is a combination of pre-defined resource name and identifier (like Zone ID etc.)
 *
 * @example com.cloudflare.api.account.zone.23f8d65290b24279ba6f44721b3eaad5
 */
export type IamCreateResourceGroupScopeScopeObjectKey = void;

export type IamCreateUserGroupBody = {
  /**
   * Name of the User group.
   *
   * @example My New User Group
   * @x-auditable true
   */
  name: string;
  /**
   * Policies attached to the User group
   */
  policies: IamUserGroupPolicyWriteBody[];
};

/**
 * A group of scoped resources.
 */
export type IamCreatedResourceGroupResponse = {
  /**
   * Identifier of the group.
   *
   * @example 6d7f2f5f5b1d4a0e9081fdc98d432fd1
   * @x-auditable true
   */
  id?: string;
  /**
   * Attributes associated to the resource group.
   *
   * @example {"editable":"false"}
   */
  meta?: Record<string, any>;
  scope?: IamCreateScope;
};

/**
 * Allow or deny operations against the resources.
 *
 * @example allow
 * @x-auditable true
 */
export type IamEffect = "allow" | "deny";

/**
 * The contact email address of the user.
 *
 * @example user@example.com
 * @maxLength 90
 * @x-auditable true
 */
export type IamEmail = string;

/**
 * The expiration time on or after which the JWT MUST NOT be accepted for processing.
 *
 * @example 2020-01-01T00:00:00Z
 * @format date-time
 * @x-auditable true
 */
export type IamExpiresOn = string;

/**
 * User's first name
 *
 * @example John
 * @maxLength 60
 * @x-auditable true
 */
export type IamFirstName = string | null;

/**
 * @example {"read":true,"write":false}
 */
export type IamGrants = {
  /**
   * @example true
   * @x-auditable true
   */
  read?: boolean;
  /**
   * @example true
   * @x-auditable true
   */
  write?: boolean;
};

/**
 * Policy identifier.
 *
 * @example f267e341f3dd4697bd3b9f71dd96247f
 * @x-auditable true
 */
export type IamIdentifier = string;

/**
 * Invite identifier tag.
 *
 * @example 4f5f0c14a2a41d5063dd301b2f829f04
 * @maxLength 32
 * @x-auditable true
 */
export type IamInviteComponentsSchemasIdentifier = string;

/**
 * The email address of the user who created the invite.
 *
 * @example user@example.com
 * @maxLength 90
 * @x-auditable true
 */
export type IamInvitedBy = string;

/**
 * Email address of the user to add to the organization.
 *
 * @example user@example.com
 * @maxLength 90
 * @x-auditable true
 */
export type IamInvitedMemberEmail = string;

/**
 * When the invite was sent.
 *
 * @example 2014-01-01T05:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type IamInvitedOn = string;

/**
 * The time on which the token was created.
 *
 * @example 2018-07-01T05:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type IamIssuedOn = string;

/**
 * User's last name
 *
 * @example Appleseed
 * @maxLength 60
 * @x-auditable true
 */
export type IamLastName = string | null;

/**
 * Last time the token was used.
 *
 * @example 2020-01-02T12:34:00Z
 * @format date-time
 * @x-auditable true
 */
export type IamLastUsedOn = string;

export type IamListMemberPolicy = {
  access?: IamAccess;
  id?: IamIdentifier;
  permission_groups?: IamPermissionGroups;
  resource_groups?: IamResourceGroups;
};

/**
 * A group of permissions.
 */
export type IamMemberPermissionGroup = {
  /**
   * Identifier of the group.
   *
   * @example c8fed203ed3043cba015a93ad1616f1f
   * @x-auditable true
   */
  id: string;
};

/**
 * A set of permission groups that are specified to the policy.
 *
 * @example {"id":"c8fed203ed3043cba015a93ad1616f1f"}
 * @example {"id":"82e64a83756745bbbb1c9c2701bf816b"}
 */
export type IamMemberPermissionGroups = IamMemberPermissionGroup[];

/**
 * A group of scoped resources.
 */
export type IamMemberResourceGroup = {
  /**
   * Identifier of the group.
   *
   * @example 6d7f2f5f5b1d4a0e9081fdc98d432fd1
   * @x-auditable true
   */
  id: string;
};

/**
 * A list of resource groups that the policy applies to.
 */
export type IamMemberResourceGroups = IamMemberResourceGroup[];

export type IamMemberWithPolicies = {
  id?: IamMembershipComponentsSchemasIdentifier;
  /**
   * Access policy for the membership
   */
  policies?: IamListMemberPolicy[];
  /**
   * Roles assigned to this Member.
   */
  roles?: IamRole[];
  /**
   * A member's status in the account.
   *
   * @example accepted
   * @x-auditable true
   */
  status?: "accepted" | "pending";
  /**
   * Details of the user associated to the membership.
   */
  user?: {
    email: IamEmail;
    first_name?: IamFirstName;
    id?: IamCommonComponentsSchemasIdentifier;
    last_name?: IamLastName;
    two_factor_authentication_enabled?: IamTwoFactorAuthenticationEnabled;
  };
};

export type IamMembership = {
  account?: IamSchemasAccount;
  api_access_enabled?: IamApiAccessEnabled;
  id?: IamMembershipComponentsSchemasIdentifier;
  /**
   * All access permissions for the user at the account.
   *
   * @example {"analytics":{"read":true,"write":false},"zones":{"read":true,"write":true}}
   */
  permissions?: IamPermissions;
  roles?: IamRoleNames;
  status?: IamSchemasStatus;
};

export type IamMembershipWithPolicies = {
  account?: IamSchemasAccount;
  api_access_enabled?: IamApiAccessEnabled;
  id?: IamMembershipComponentsSchemasIdentifier;
  /**
   * All access permissions for the user at the account.
   *
   * @example {"analytics":{"read":true,"write":false},"zones":{"read":true,"write":true}}
   */
  permissions?: IamPermissions;
  /**
   * Access policy for the membership
   */
  policies?: IamListMemberPolicy[];
  roles?: IamRoleNames;
  status?: IamSchemasStatus;
};

/**
 * Membership identifier tag.
 *
 * @example 4536bcfad5faccb111b47003c79917fa
 * @maxLength 32
 * @x-auditable true
 */
export type IamMembershipComponentsSchemasIdentifier = string;

export type IamMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * Last time the token was modified.
 *
 * @example 2018-07-02T05:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type IamModifiedOn = string;

/**
 * Token name.
 *
 * @example readonly token
 * @maxLength 120
 * @x-auditable true
 */
export type IamName = string;

/**
 * The time before which the token MUST NOT be accepted for processing.
 *
 * @example 2018-07-01T05:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type IamNotBefore = string;

export type IamOrganization = {
  id?: IamCommonComponentsSchemasIdentifier;
  name?: IamSchemasName;
  permissions?: IamSchemasPermissions;
  /**
   * List of roles that a user has within an organization.
   */
  roles?: string[];
  status?: IamComponentsSchemasStatus;
};

/**
 * A named group of permissions that map to a group of operations against resources.
 */
export type IamPermissionGroup = {
  /**
   * Identifier of the permission group.
   *
   * @example 6d7f2f5f5b1d4a0e9081fdc98d432fd1
   * @x-auditable true
   */
  id: string;
  /**
   * Attributes associated to the permission group.
   *
   * @example {"label":"load_balancer_admin","scopes":"com.cloudflare.api.account"}
   */
  meta?: {
    /**
     * @x-auditable true
     */
    key?: string;
    /**
     * @x-auditable true
     */
    value?: string;
  };
  /**
   * Name of the permission group.
   *
   * @example Load Balancer
   * @x-auditable true
   */
  name?: string;
};

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @minLength 32
 * @x-auditable true
 */
export type IamPermissionGroupIdentifier = IamCommonComponentsSchemasIdentifier;

/**
 * A set of permission groups that are specified to the policy.
 *
 * @example {"id":"c8fed203ed3043cba015a93ad1616f1f"}
 * @example {"id":"82e64a83756745bbbb1c9c2701bf816b"}
 */
export type IamPermissionGroupIds = {
  id: IamPermissionGroupIdentifier;
}[];

/**
 * A set of permission groups that are specified to the policy.
 *
 * @example {"id":"c8fed203ed3043cba015a93ad1616f1f","meta":{"label":"load_balancer_admin","scopes":"com.cloudflare.api.account"},"name":"Zone Read"}
 * @example {"id":"82e64a83756745bbbb1c9c2701bf816b","meta":{"label":"fbm_user","scopes":"com.cloudflare.api.account"},"name":"Magic Network Monitoring"}
 */
export type IamPermissionGroups = IamPermissionGroup[];

/**
 * @example {"analytics":{"read":true,"write":false},"zones":{"read":true,"write":true}}
 */
export type IamPermissions = {
  analytics?: IamGrants;
  billing?: IamGrants;
  cache_purge?: IamGrants;
  dns?: IamGrants;
  dns_records?: IamGrants;
  lb?: IamGrants;
  logs?: IamGrants;
  organization?: IamGrants;
  ssl?: IamGrants;
  waf?: IamGrants;
  zone_settings?: IamGrants;
  zones?: IamGrants;
};

export type IamPermissionsGroupResponseCollection = IamApiResponseCollection & {
  /**
   * @example {"id":"7cf72faf220841aabcfdfab81c43c4f6","name":"Billing Read","scopes":["com.cloudflare.api.account"]}
   * @example {"id":"9d24387c6e8544e2bc4024a03991339f","name":"Load Balancing: Monitors and Pools Read","scopes":["com.cloudflare.api.account"]}
   * @example {"id":"d2a1802cc9a34e30852f8b33869b2f3c","name":"Load Balancing: Monitors and Pools Write","scopes":["com.cloudflare.api.account"]}
   * @example {"id":"8b47d2786a534c08a1f94ee8f9f599ef","name":"Workers KV Storage Read","scopes":["com.cloudflare.api.account"]}
   * @example {"id":"f7f0eda5697f475c90846e879bab8666","name":"Workers KV Storage Write","scopes":["com.cloudflare.api.account"]}
   * @example {"id":"1a71c399035b4950a1bd1466bbe4f420","name":"Workers Scripts Read","scopes":["com.cloudflare.api.account"]}
   * @example {"id":"e086da7e2179491d91ee5f35b3ca210a","name":"Workers Scripts Write","scopes":["com.cloudflare.api.account"]}
   */
  result?: {
    /**
     * Public ID.
     *
     * @x-auditable true
     */
    id?: string;
    /**
     * Permission Group Name
     *
     * @x-auditable true
     */
    name?: string;
    /**
     * Resources to which the Permission Group is scoped
     */
    scopes?: (
      | "com.cloudflare.api.account"
      | "com.cloudflare.api.account.zone"
      | "com.cloudflare.api.user"
      | "com.cloudflare.edge.r2.bucket"
    )[];
  }[];
};

export type IamPolicyWithPermissionGroupsAndResources = {
  effect: IamEffect;
  id: IamIdentifier;
  permission_groups: IamPermissionGroups;
  resources: IamResources;
};

/**
 * Account name
 *
 * @example Demo Account
 * @maxLength 100
 * @x-auditable true
 */
export type IamPropertiesName = string;

export type IamRequestCreateResourceGroup = {
  /**
   * Name of the resource group
   *
   * @example NewResourceGroup
   */
  name: string;
  scope: IamCreateScope;
};

/**
 * Client IP restrictions.
 *
 * @example {"in":["123.123.123.0/24","2606:4700::/32"],"not_in":["123.123.123.100/24","2606:4700:4700::/48"]}
 */
export type IamRequestIp = {
  ["in"]?: IamCidrList;
  not_in?: IamCidrList;
};

export type IamRequestUpdateResourceGroup = {
  /**
   * Name of the resource group
   *
   * @example UpdatedResourceGroup
   */
  name?: string;
  scope?: IamCreateScope;
};

/**
 * A group of scoped resources.
 */
export type IamResourceGroup = {
  /**
   * Identifier of the resource group.
   *
   * @example 6d7f2f5f5b1d4a0e9081fdc98d432fd1
   * @x-auditable true
   */
  id: string;
  /**
   * Attributes associated to the resource group.
   *
   * @example {"editable":"false"}
   */
  meta?: {
    key?: string;
    value?: string;
  };
  /**
   * Name of the resource group.
   *
   * @example com.cloudflare.api.account.eb78d65290b24279ba6f44721b3ea3c4
   * @x-auditable true
   */
  name?: string;
  /**
   * The scope associated to the resource group
   */
  scope: IamScope[];
};

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @minLength 32
 * @x-auditable true
 */
export type IamResourceGroupIdentifier = IamCommonComponentsSchemasIdentifier;

/**
 * A set of resource groups that are specified to the policy.
 *
 * @example {"id":"6d7f2f5f5b1d4a0e9081fdc98d432fd1"}
 */
export type IamResourceGroupIds = {
  id: IamResourceGroupIdentifier;
}[];

/**
 * A list of resource groups that the policy applies to.
 */
export type IamResourceGroups = IamResourceGroup[];

/**
 * A list of resource names that the policy applies to.
 *
 * @example {"object":{"summary":"Nested object value","value":{"com.cloudflare.api.account.eb78d65290b24279ba6f44721b3ea3c4":{"com.cloudflare.api.account.zone.*":"*"}}},"string":{"summary":"Single string value","value":{"com.cloudflare.api.account.zone.22b1de5f1c0e4b3ea97bb1e963b06a43":"*"}}}
 */
export type IamResources = {
  [key: string]:
    | string
    | {
        [key: string]: string;
      };
};

export type IamResponseCollection = IamApiResponseCollection & {
  result?: Record<string, any>[];
};

export type IamResponseCollectionAccounts = IamApiResponseCollection & {
  result?: IamAccount[];
};

export type IamResponseCreate = IamApiResponseSingle & {
  result?: {
    value?: IamValue;
  };
};

export type IamResponseSingle = IamApiResponseSingle & {
  result?: Record<string, any>;
};

export type IamResponseSingleAccount = IamApiResponseSingle & {
  result?: IamAccount;
};

export type IamResponseSingleValue = IamApiResponseSingle & {
  result?: IamValue;
};

export type IamResultInfo = {
  /**
   * Total number of results for the requested service
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters
   *
   * @example 2000
   */
  total_count?: number;
};

export type IamRole = {
  /**
   * Description of role's permissions.
   *
   * @example Administrative access to the entire Account
   * @x-auditable true
   */
  description: string;
  id: IamRoleComponentsSchemasIdentifier;
  /**
   * Role name.
   *
   * @example Account Administrator
   * @maxLength 120
   * @x-auditable true
   */
  name: string;
  /**
   * @example {"analytics":{"read":true,"write":false},"zones":{"read":true,"write":true}}
   */
  permissions: IamPermissions & void;
};

/**
 * Role identifier tag.
 *
 * @example 3536bcfad5faccb999b47003c79917fb
 * @maxLength 32
 * @x-auditable true
 */
export type IamRoleComponentsSchemasIdentifier = string;

/**
 * List of role names the membership has for this account.
 */
export type IamRoleNames = string[];

export type IamSchemasAccount = IamAccount;

export type IamSchemasCollectionInviteResponse = IamApiResponseCollection & {
  result?: IamUserInvite[];
};

/**
 * When the invite is no longer active.
 *
 * @example 2014-01-01T05:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type IamSchemasExpiresOn = string;

export type IamSchemasMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * Organization name.
 *
 * @example Cloudflare, Inc.
 * @maxLength 100
 * @x-auditable true
 */
export type IamSchemasName = string;

/**
 * Access permissions for this User.
 */
export type IamSchemasPermissions = string[];

/**
 * Status of this membership.
 *
 * @example accepted
 * @x-auditable true
 */
export type IamSchemasStatus = "accepted" | "pending" | "rejected";

/**
 * A scope is a combination of scope objects which provides additional context.
 */
export type IamScope = {
  key: IamScopeKey;
  /**
   * A list of scope objects for additional context.
   */
  objects: IamScopeObject[];
};

/**
 * This is a combination of pre-defined resource name and identifier (like Account ID etc.)
 *
 * @example com.cloudflare.api.account.eb78d65290b24279ba6f44721b3ea3c4
 * @x-auditable true
 */
export type IamScopeKey = void;

/**
 * A scope object represents any resource that can have actions applied against invite.
 */
export type IamScopeObject = {
  key: IamScopeObjectKey;
};

/**
 * This is a combination of pre-defined resource name and identifier (like Zone ID etc.)
 *
 * @example com.cloudflare.api.account.zone.23f8d65290b24279ba6f44721b3eaad5
 * @x-auditable true
 */
export type IamScopeObjectKey = void;

export type IamSingleInviteResponse = IamApiResponseSingle & {
  result?: IamUserInvite;
};

export type IamSingleMemberResponseWithPolicies = IamApiResponseSingle & {
  result?: IamMemberWithPolicies;
};

export type IamSingleMembershipResponse = IamApiResponseSingle & {
  result?: IamMembership;
};

export type IamSingleMembershipResponseWithPolicies = IamApiResponseSingle & {
  result?: IamMembershipWithPolicies;
};

export type IamSingleOrganizationResponse = IamApiResponseSingle & {
  result?: Record<string, any>;
};

export type IamSingleRoleResponse = IamApiResponseSingle & {
  result?: IamRole;
};

export type IamSingleTokenCreateResponse = IamApiResponseSingle & {
  result?: IamTokenWithValue;
};

export type IamSingleTokenResponse = IamApiResponseSingle & {
  result?: IamTokenBase;
};

export type IamSingleUserResponse = IamApiResponseSingle & {
  result?: {
    /**
     * Lists the betas that the user is participating in.
     */
    betas?: string[];
    country?: IamCountry;
    first_name?: IamFirstName;
    /**
     * Indicates whether user has any business zones
     *
     * @default false
     */
    has_business_zones?: boolean;
    /**
     * Indicates whether user has any enterprise zones
     *
     * @default false
     */
    has_enterprise_zones?: boolean;
    /**
     * Indicates whether user has any pro zones
     *
     * @default false
     */
    has_pro_zones?: boolean;
    /**
     * Identifier of the user.
     *
     * @example 6d7f2f5f5b1d4a0e9081fdc98d432fd1
     */
    id?: string;
    last_name?: IamLastName;
    organizations?: IamOrganization[];
    /**
     * Indicates whether user has been suspended
     *
     * @default false
     */
    suspended?: boolean;
    telephone?: IamTelephone;
    two_factor_authentication_enabled?: IamTwoFactorAuthenticationEnabled;
    two_factor_authentication_locked?: IamTwoFactorAuthenticationLocked;
    zipcode?: IamZipcode;
  };
};

/**
 * User's telephone number
 *
 * @example +1 123-123-1234
 * @maxLength 20
 */
export type IamTelephone = string | null;

export type IamTokenBase = {
  condition?: IamCondition;
  expires_on?: IamExpiresOn;
  id?: IamTokenIdentifier;
  issued_on?: IamIssuedOn;
  last_used_on?: IamLastUsedOn;
  modified_on?: IamModifiedOn;
  name?: IamName;
  not_before?: IamNotBefore;
  policies?: IamTokenPolicies;
  status?: IamTokenStatus;
};

export type IamTokenBody = {
  condition?: IamCondition;
  expires_on?: IamExpiresOn;
  id?: IamTokenIdentifier;
  issued_on?: IamIssuedOn;
  last_used_on?: IamLastUsedOn;
  modified_on?: IamModifiedOn;
  name: IamName;
  not_before?: IamNotBefore;
  policies: IamTokenPolicies;
  status?: IamTokenStatus;
};

/**
 * Token identifier tag.
 *
 * @example ed17574386854bf78a67040be0a770b0
 * @maxLength 32
 * @x-auditable true
 */
export type IamTokenIdentifier = string;

/**
 * List of access policies assigned to the token.
 */
export type IamTokenPolicies = IamPolicyWithPermissionGroupsAndResources[];

/**
 * Status of the token.
 *
 * @example active
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type IamTokenStatus = "active" | "disabled" | "expired";

export type IamTokenVerifyResponseSingleSegment = IamApiResponseSingle & {
  result?: {
    expires_on?: IamExpiresOn;
    id: IamTokenIdentifier;
    not_before?: IamNotBefore;
    status: IamTokenStatus;
  };
};

export type IamTokenWithValue = IamTokenBase & {
  value?: IamValue;
};

/**
 * Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
 *
 * @default false
 */
export type IamTwoFactorAuthenticationEnabled = boolean;

/**
 * Indicates whether two-factor authentication is required by one of the accounts that the user is a member of.
 *
 * @default false
 */
export type IamTwoFactorAuthenticationLocked = boolean;

/**
 * Tenant unit identifier.
 *
 * @example f267e341f3dd4697bd3b9f71dd96247f
 * @x-auditable true
 */
export type IamUnitIdentifier = string;

export type IamUpdateMemberWithPolicies = {
  /**
   * Array of policies associated with this member.
   */
  policies: IamCreateMemberPolicy[];
};

export type IamUpdateMemberWithRoles = {
  id?: IamMembershipComponentsSchemasIdentifier;
  /**
   * Roles assigned to this member.
   */
  roles?: IamRole[];
  /**
   * A member's status in the account.
   *
   * @example accepted
   * @x-auditable true
   */
  status?: "accepted" | "pending";
  /**
   * Details of the user associated to the membership.
   */
  user?: {
    email: IamEmail;
    first_name?: IamFirstName;
    id?: IamCommonComponentsSchemasIdentifier;
    last_name?: IamLastName;
    two_factor_authentication_enabled?: IamTwoFactorAuthenticationEnabled;
  };
};

export type IamUpdateUserGroupBody = {
  /**
   * Name of the User group.
   *
   * @example My New User Group
   */
  name?: string;
  /**
   * Policies attached to the User group
   */
  policies?: ({
    /**
     * Policy identifier.
     *
     * @example f267e341f3dd4697bd3b9f71dd96247f
     */
    id: string;
  } & IamUserGroupPolicyWriteBody)[];
};

/**
 * A group of policies resources.
 */
export type IamUserGroup = {
  /**
   * Timestamp for the creation of the user group
   *
   * @example 2024-03-01T12:21:02.0000Z
   * @format date-time
   * @x-auditable true
   */
  created_on: string;
  id: IamUserGroupIdentifier;
  /**
   * Last time the user group was modified.
   *
   * @example 2024-03-01T12:21:02.0000Z
   * @format date-time
   * @x-auditable true
   */
  modified_on: string;
  /**
   * Name of the user group.
   *
   * @example My New User Group
   * @x-auditable true
   */
  name: string;
  /**
   * Policies attached to the User group
   */
  policies?: {
    access?: IamAccess;
    id?: IamIdentifier;
    permission_groups?: IamPermissionGroups;
    resource_groups?: IamResourceGroups;
  }[];
};

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @minLength 32
 * @x-auditable true
 */
export type IamUserGroupIdentifier = IamCommonComponentsSchemasIdentifier;

/**
 * Member attached to a User Group.
 */
export type IamUserGroupMember = {
  email?: IamEmail;
  /**
   * Account member identifier.
   *
   * @example 4f5f0c14a2a41d5063dd301b2f829f04
   */
  id: string;
  /**
   * The member's status in the account.
   *
   * @example accepted
   */
  status?: "accepted" | "pending";
};

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @minLength 32
 * @x-auditable true
 */
export type IamUserGroupMemberIdentifier = IamCommonComponentsSchemasIdentifier;

export type IamUserGroupPolicyWriteBody = {
  access: IamAccess;
  permission_groups: IamPermissionGroupIds;
  resource_groups: IamResourceGroupIds;
};

/**
 * A list of user groups for the account.
 */
export type IamUserGroups = IamUserGroup[];

export type IamUserInvite = {
  expires_on?: IamSchemasExpiresOn;
  id?: IamInviteComponentsSchemasIdentifier;
  invited_by?: IamInvitedBy;
  invited_member_email?: IamInvitedMemberEmail;
  /**
   * ID of the user to add to the organization.
   *
   * @example 5a7805061c76ada191ed06f989cc3dac
   * @maxLength 32
   * @x-auditable true
   */
  invited_member_id: string | null;
  invited_on?: IamInvitedOn;
  /**
   * ID of the organization the user will be added to.
   *
   * @example 5a7805061c76ada191ed06f989cc3dac
   * @maxLength 32
   * @x-auditable true
   */
  organization_id: string;
  /**
   * @example true
   * @x-auditable true
   */
  organization_is_enforcing_twofactor?: boolean;
  /**
   * Organization name.
   *
   * @example Cloudflare, Inc.
   * @maxLength 100
   * @x-auditable true
   */
  organization_name?: string;
  roles?: IamRoleNames;
  /**
   * Current status of the invitation.
   *
   * @example accepted
   * @x-auditable true
   */
  status?: "pending" | "accepted" | "rejected" | "expired";
};

/**
 * The token value.
 *
 * @example 8M7wS6hCpXVc-DoRnPPY_UCWPgy8aea4Wy6kCe5T
 * @maxLength 80
 * @minLength 40
 * @x-sensitive true
 */
export type IamValue = string;

/**
 * The zipcode or postal code where the user lives.
 *
 * @example 12345
 * @maxLength 20
 */
export type IamZipcode = string | null;

/**
 * Account identifier tag.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type ImagesAccountIdentifier = string;

export type ImagesApiResponseCollectionV2 = {
  errors: ImagesMessages;
  messages: ImagesMessages;
  result:
    | {
        continuation_token?: ImagesImagesListContinuationToken;
      }
    | any[]
    | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   * @x-auditable true
   */
  success: true;
};

export type ImagesApiResponseCommon = {
  errors: ImagesMessages;
  messages: ImagesMessages;
  result: Record<string, any> | any[] | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   * @x-auditable true
   */
  success: true;
};

export type ImagesApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: ImagesMessages;
  messages: ImagesMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   * @x-auditable true
   */
  success: false;
};

export type ImagesApiResponseSingle = {
  errors: ImagesMessages;
  messages: ImagesMessages;
  result: Record<string, any> | string | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   * @x-auditable true
   */
  success: true;
};

export type ImagesDeletedResponse = ImagesApiResponseSingle & {
  /**
   * @example {}
   */
  result?: Record<string, any>;
};

export type ImagesImage = {
  filename?: ImagesImageFilename;
  id?: ImagesImageIdentifier;
  meta?: ImagesImageMetadata;
  requireSignedURLs?: ImagesImageRequireSignedURLs;
  uploaded?: ImagesImageUploaded;
  variants?: ImagesImageVariants;
};

export type ImagesImageBasicUpload = {
  /**
   * An image binary data. Only needed when type is uploading a file.
   *
   * @format binary
   * @x-auditable true
   */
  file?: Blob;
  /**
   * An optional custom unique identifier for your image.
   *
   * @x-auditable true
   */
  id?: string;
  /**
   * User modifiable key-value store. Can use used for keeping references to another system of record for managing images.
   */
  metadata?: Record<string, any>;
  /**
   * Indicates whether the image requires a signature token for the access.
   *
   * @default false
   * @example true
   * @x-auditable true
   */
  requireSignedURLs?: boolean;
  /**
   * A URL to fetch an image from origin. Only needed when type is uploading from a URL.
   *
   * @example https://example.com/path/to/logo.png
   * @x-auditable true
   */
  url?: string;
};

export type ImagesImageDirectUploadRequestV2 = {
  /**
   * The date after which the upload will not be accepted. Minimum: Now + 2 minutes. Maximum: Now + 6 hours.
   *
   * @default Now + 30 minutes
   * @example 2021-01-02T02:20:00Z
   * @format date-time
   * @x-auditable true
   */
  expiry?: string;
  /**
   * Optional Image Custom ID. Up to 1024 chars. Can include any number of subpaths, and utf8 characters. Cannot start nor end with a / (forward slash). Cannot be a UUID.
   *
   * @example this/is/my-customid
   * @maxLength 1024
   * @x-auditable true
   */
  id?: string;
  /**
   * User modifiable key-value store. Can be used for keeping references to another system of record, for managing images.
   */
  metadata?: Record<string, any>;
  /**
   * Indicates whether the image requires a signature token to be accessed.
   *
   * @default false
   * @example true
   * @x-auditable true
   */
  requireSignedURLs?: boolean;
};

export type ImagesImageDirectUploadResponseV2 = ImagesApiResponseSingle & {
  result?: {
    /**
     * Image unique identifier.
     *
     * @example e22e9e6b-c02b-42fd-c405-6c32af5fe600
     * @maxLength 32
     * @x-auditable true
     */
    id?: string;
    /**
     * The URL the unauthenticated upload can be performed to using a single HTTP POST (multipart/form-data) request.
     *
     * @example https://upload.imagedelivery.net/FxUufywByo0m2v3xhKSiU8/e22e9e6b-c02b-42fd-c405-6c32af5fe600
     * @x-auditable true
     */
    uploadURL?: string;
  };
};

/**
 * Image file name.
 *
 * @example logo.png
 * @maxLength 255
 * @x-auditable true
 */
export type ImagesImageFilename = string;

/**
 * URI to hero variant for an image.
 *
 * @example https://imagedelivery.net/MTt4OTd0b0w5aj/107b9558-dd06-4bbd-5fef-9c2c16bb7900/hero
 * @format uri
 * @x-auditable true
 */
export type ImagesImageHeroUrl = string;

/**
 * Image unique identifier.
 *
 * @example 107b9558-dd06-4bbd-5fef-9c2c16bb7900
 * @maxLength 32
 * @x-auditable true
 */
export type ImagesImageIdentifier = string;

/**
 * Key name.
 *
 * @example default
 * @x-auditable true
 */
export type ImagesImageKeyName = string;

export type ImagesImageKeyResponseCollection = {
  errors: ImagesMessages;
  messages: ImagesMessages;
  result: ImagesImageKeysResponse;
  /**
   * Whether the API call was successful
   *
   * @example true
   * @x-auditable true
   */
  success: true;
};

/**
 * Key value.
 *
 * @example Oix0bbNaT8Rge9PuyxUBrjI6zrgnsyJ5=
 * @x-auditable true
 */
export type ImagesImageKeyValue = string;

export type ImagesImageKeys = {
  name?: ImagesImageKeyName;
  value?: ImagesImageKeyValue;
};

export type ImagesImageKeysResponse = {
  keys?: ImagesImageKeys[];
};

/**
 * User modifiable key-value store. Can be used for keeping references to another system of record for managing images. Metadata must not exceed 1024 bytes.
 *
 * @example {"key":"value"}
 */
export type ImagesImageMetadata = Record<string, any>;

/**
 * URI to original variant for an image.
 *
 * @example https://imagedelivery.net/MTt4OTd0b0w5aj/107b9558-dd06-4bbd-5fef-9c2c16bb7900/original
 * @format uri
 * @x-auditable true
 */
export type ImagesImageOriginalUrl = string;

export type ImagesImagePatchRequest = {
  /**
   * User modifiable key-value store. Can be used for keeping references to another system of record for managing images. No change if not specified.
   */
  metadata?: Record<string, any>;
  /**
   * Indicates whether the image can be accessed using only its UID. If set to `true`, a signed token needs to be generated with a signing key to view the image. Returns a new UID on a change. No change if not specified.
   *
   * @example true
   * @x-auditable true
   */
  requireSignedURLs?: boolean;
};

/**
 * Indicates whether the image can be a accessed only using it's UID. If set to true, a signed token needs to be generated with a signing key to view the image.
 *
 * @default false
 * @example true
 * @x-auditable true
 */
export type ImagesImageRequireSignedURLs = boolean;

/**
 * @example <image blob data>
 */
export type ImagesImageResponseBlob = string | Record<string, any>;

export type ImagesImageResponseSingle = ImagesApiResponseSingle & {
  result?: ImagesImage;
};

/**
 * URI to thumbnail variant for an image.
 *
 * @example https://imagedelivery.net/MTt4OTd0b0w5aj/107b9558-dd06-4bbd-5fef-9c2c16bb7900/thumbnail
 * @format uri
 * @x-auditable true
 */
export type ImagesImageThumbnailUrl = string;

/**
 * When the media item was uploaded.
 *
 * @example 2014-01-02T02:20:00.123Z
 * @format date-time
 * @x-auditable true
 */
export type ImagesImageUploaded = string;

export type ImagesImageVariantDefinition = {
  id: ImagesImageVariantIdentifier;
  neverRequireSignedURLs?: ImagesImageVariantNeverRequireSignedURLs;
  options: ImagesImageVariantOptions;
};

/**
 * The fit property describes how the width and height dimensions should be interpreted.
 *
 * @example scale-down
 * @x-auditable true
 */
export type ImagesImageVariantFit =
  | "scale-down"
  | "contain"
  | "cover"
  | "crop"
  | "pad";

/**
 * Maximum height in image pixels.
 *
 * @example 768
 * @minimum 1
 * @x-auditable true
 */
export type ImagesImageVariantHeight = number;

/**
 * @example hero
 * @maxLength 99
 * @pattern ^[a-zA-Z0-9]$
 * @x-auditable true
 */
export type ImagesImageVariantIdentifier = string;

export type ImagesImageVariantListResponse = {
  errors: ImagesMessages;
  messages: ImagesMessages;
  result: ImagesImageVariantsResponse;
  /**
   * Whether the API call was successful
   *
   * @example true
   * @x-auditable true
   */
  success: true;
};

/**
 * Indicates whether the variant can access an image without a signature, regardless of image access control.
 *
 * @default false
 * @example true
 * @x-auditable true
 */
export type ImagesImageVariantNeverRequireSignedURLs = boolean;

/**
 * Allows you to define image resizing sizes for different use cases.
 */
export type ImagesImageVariantOptions = {
  fit: ImagesImageVariantFit;
  height: ImagesImageVariantHeight;
  metadata: ImagesImageVariantSchemasMetadata;
  width: ImagesImageVariantWidth;
};

export type ImagesImageVariantPatchRequest = {
  neverRequireSignedURLs?: ImagesImageVariantNeverRequireSignedURLs;
  options: ImagesImageVariantOptions;
};

export type ImagesImageVariantPublicRequest = {
  hero?: {
    id: ImagesImageVariantIdentifier;
    neverRequireSignedURLs?: ImagesImageVariantNeverRequireSignedURLs;
    options: ImagesImageVariantOptions;
  };
};

export type ImagesImageVariantResponse = {
  variant?: ImagesImageVariantDefinition;
};

/**
 * What EXIF data should be preserved in the output image.
 *
 * @example none
 * @x-auditable true
 */
export type ImagesImageVariantSchemasMetadata = "keep" | "copyright" | "none";

export type ImagesImageVariantSimpleResponse = ImagesApiResponseSingle & {
  result?: ImagesImageVariantResponse;
};

/**
 * Maximum width in image pixels.
 *
 * @example 1366
 * @minimum 1
 * @x-auditable true
 */
export type ImagesImageVariantWidth = number;

/**
 * Object specifying available variants for an image.
 *
 * @example https://imagedelivery.net/MTt4OTd0b0w5aj/107b9558-dd06-4bbd-5fef-9c2c16bb7900/thumbnail
 * @example https://imagedelivery.net/MTt4OTd0b0w5aj/107b9558-dd06-4bbd-5fef-9c2c16bb7900/hero
 * @example https://imagedelivery.net/MTt4OTd0b0w5aj/107b9558-dd06-4bbd-5fef-9c2c16bb7900/original
 */
export type ImagesImageVariants = (
  | ImagesImageThumbnailUrl
  | ImagesImageHeroUrl
  | ImagesImageOriginalUrl
)[];

export type ImagesImageVariantsResponse = {
  variants?: ImagesImageVariantPublicRequest;
};

/**
 * Continuation token to fetch next page. Passed as a query param when requesting List V2 api endpoint.
 *
 * @example iD0bxlWFSVUWsDHbzIqvDkgBW4otifAAuGXLz1n8BQA
 * @maxLength 32
 * @x-auditable true
 */
export type ImagesImagesListContinuationToken = string | null;

export type ImagesImagesListResponse = {
  errors: ImagesMessages;
  messages: ImagesMessages;
  result:
    | {
        images?: ImagesImage[];
      }
    | any[]
    | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   * @x-auditable true
   */
  success: true;
};

export type ImagesImagesListResponseV2 = ImagesApiResponseCollectionV2 & {
  result?: {
    images?: ImagesImage[];
  };
};

export type ImagesImagesStats = {
  count?: ImagesImagesStatsCount;
};

/**
 * Cloudflare Images allowed usage.
 *
 * @example 100000
 * @x-auditable true
 */
export type ImagesImagesStatsAllowed = number;

export type ImagesImagesStatsCount = {
  allowed?: ImagesImagesStatsAllowed;
  current?: ImagesImagesStatsCurrent;
};

/**
 * Cloudflare Images current usage.
 *
 * @example 1000
 * @x-auditable true
 */
export type ImagesImagesStatsCurrent = number;

export type ImagesImagesStatsResponse = ImagesApiResponseSingle & {
  result?: ImagesImagesStats;
};

export type ImagesMessages = {
  /**
   * @minimum 1000
   * @x-auditable true
   */
  code: number;
  /**
   * @x-auditable true
   */
  message: string;
}[];

/**
 * @example someKey
 * @maxLength 20
 * @pattern ^[a-zA-Z0-9]$
 * @x-auditable true
 */
export type ImagesSigningKeyIdentifier = string;

/**
 * Account identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type InfraAccountTag = string;

/**
 * The IPv4/IPv6 address that identifies where to reach a target
 */
export type InfraIPInfo = {
  /**
   * The target's IPv4 address
   */
  ipv4?: {
    /**
     * IP address of the target
     *
     * @example 187.26.29.249
     */
    ip_addr?: string;
    /**
     * (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
     *
     * @example c77b744e-acc8-428f-9257-6878c046ed55
     * @format uuid
     */
    virtual_network_id?: string;
  };
  /**
   * The target's IPv6 address
   */
  ipv6?: {
    /**
     * IP address of the target
     *
     * @example 64c0:64e8:f0b4:8dbf:7104:72b0:ec8f:f5e0
     */
    ip_addr?: string;
    /**
     * (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
     *
     * @example c77b744e-acc8-428f-9257-6878c046ed55
     * @format uuid
     */
    virtual_network_id?: string;
  };
};

export type InfraSortingDirection = "asc" | "desc";

export type InfraTarget = {
  /**
   * Date and time at which the target was created
   *
   * @example 2019-08-24T14:15:22Z
   * @format date-time
   */
  created_at: string;
  /**
   * A non-unique field that refers to a target
   *
   * @example infra-access-target
   */
  hostname: string;
  id: InfraTargetId;
  ip: InfraIPInfo;
  /**
   * Date and time at which the target was modified
   *
   * @example 2019-08-24T14:15:22Z
   * @format date-time
   */
  modified_at: string;
};

export type InfraTargetArray = InfraTarget[];

/**
 * Target identifier
 *
 * @example 0191dce4-9ab4-7fce-b660-8e5dec5172da
 * @format uuid
 * @maxLength 36
 */
export type InfraTargetId = string;

export type InfraApiResponseCollection = InfraApiResponseCommon & {
  result_info?: {
    /**
     * Total number of results for the requested service.
     *
     * @example 1
     */
    count?: number;
    /**
     * Current page within paginated list of results.
     *
     * @example 1
     */
    page?: number;
    /**
     * Number of results per page of results.
     *
     * @example 20
     */
    per_page?: number;
    /**
     * Total results available without any search parameters.
     *
     * @example 2000
     */
    total_count?: number;
  };
};

export type InfraApiResponseCommon = {
  errors: InfraMessages;
  messages: InfraMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type InfraApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: InfraMessages;
  messages: InfraMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type InfraApiResponseSingle = InfraApiResponseCommon;

export type InfraMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

export type IntelSinkholesApiResponseCommon = {
  errors: IntelSinkholesMessages;
  messages: IntelSinkholesMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type IntelSinkholesEmptyObjectResponse = Record<string, any>;

export type IntelSinkholesGetSinkholesResponse =
  IntelSinkholesApiResponseCommon & {
    /**
     * @example {"account_tag":"233f45e61fd1f7e21e1e154ede4q2859","created_on":"2023-05-12T12:21:56.777653Z","description":"user specified description 1","id":1,"modified_on":"2023-06-18T03:13:34.123321Z","name":"sinkhole_1","r2_bucket":"my_bucket","r2_id":"<r2_id>"}
     * @example {"account_tag":"233f45e61fd1f7e21e1e154ede4q2859","created_on":"2023-05-21T21:43:52.867525Z","description":"user specified description 2","id":2,"modified_on":"2023-06-28T18:46:18.764425Z","name":"sinkhole_1","r2_bucket":"my_bucket","r2_id":"<r2_id>"}
     */
    result?: IntelSinkholesSinkholeItem[];
  };

/**
 * The unique identifier for the sinkhole
 */
export type IntelSinkholesId = number;

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type IntelSinkholesIdentifier = string;

export type IntelSinkholesMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * The name of the sinkhole
 */
export type IntelSinkholesName = string;

/**
 * @example {"account_tag":"233f45e61fd1f7e21e1e154ede4q2859","created_on":"2023-05-12T12:21:56.777653Z","description":"user specified description 1","id":1,"modified_on":"2023-06-18T03:13:34.123321Z","name":"sinkhole_1","r2_bucket":"my_bucket","r2_id":"<r2_id>"}
 */
export type IntelSinkholesSinkholeItem = {
  /**
   * The account tag that owns this sinkhole
   */
  account_tag?: string;
  /**
   * The date and time when the sinkhole was created
   *
   * @format date-time
   */
  created_on?: string;
  id?: IntelSinkholesId;
  /**
   * The date and time when the sinkhole was last modified
   *
   * @format date-time
   */
  modified_on?: string;
  name?: IntelSinkholesName;
  /**
   * The name of the R2 bucket to store results
   */
  r2_bucket?: string;
  /**
   * The id of the R2 instance
   */
  r2_id?: string;
};

/**
 * Additional information related to the host name.
 */
export type IntelAdditionalInformation = {
  /**
   * Suspected DGA malware family.
   *
   * @example
   * @x-auditable true
   */
  suspected_malware_family?: string;
};

export type IntelApiResponseCollection = {
  errors: IntelMessages;
  messages: IntelMessages;
  result:
    | Record<string, any>
    | (string | Record<string, any>)[]
    | string
    | null;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
  result_info?: IntelResultInfo;
};

export type IntelApiResponseCommon = {
  errors: IntelMessages;
  messages: IntelMessages;
  result: Record<string, any> | (string | Record<string, any>)[] | string;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type IntelApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: IntelMessages;
  messages: IntelMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: boolean;
};

export type IntelApiResponseSingle = IntelSchemasApiResponseCommon;

/**
 * Application that the hostname belongs to.
 */
export type IntelApplication = {
  /**
   * @x-auditable true
   */
  id?: number;
  /**
   * @example CLOUDFLARE
   * @x-auditable true
   */
  name?: string;
};

/**
 * @x-auditable true
 */
export type IntelAsn = number;

export type IntelAsnComponentsSchemasResponse = IntelApiResponseSingle & {
  result?: IntelAsn;
};

/**
 * @example US
 * @x-auditable true
 */
export type IntelAsnCountry = string;

/**
 * @example CLOUDFLARENET
 * @x-auditable true
 */
export type IntelAsnDescription = string;

/**
 * Infrastructure type of this ASN.
 *
 * @example hosting_provider
 * @x-auditable true
 */
export type IntelAsnType = "hosting_provider" | "isp" | "organization";

export type IntelCategoriesWithSuperCategoryIdsExampleEmpty =
  IntelCategoryWithSuperCategoryId[];

export type IntelCategoryWithSuperCategoryId = {
  /**
   * @x-auditable true
   */
  id?: number;
  /**
   * @x-auditable true
   */
  name?: string;
  /**
   * @x-auditable true
   */
  super_category_id?: number;
};

export type IntelCollectionResponse = IntelApiResponseCollection & {
  result?: {
    additional_information?: IntelAdditionalInformation;
    application?: IntelApplication;
    content_categories?: IntelContentCategories;
    domain?: IntelDomainName;
    inherited_content_categories?: IntelInheritedContentCategories;
    inherited_from?: IntelInheritedFrom;
    inherited_risk_types?: IntelInheritedRiskTypes;
    popularity_rank?: IntelPopularityRank;
    risk_score?: IntelRiskScore;
    risk_types?: IntelRiskTypes;
  }[];
};

export type IntelComponentsSchemasResponse = IntelApiResponseCollection & {
  result?: IntelIpList[];
};

export type IntelComponentsSchemasSingleResponse =
  IntelSchemasApiResponseCollection & {
    result?: IntelPassiveDnsByIp;
  };

/**
 * @example {"id":155,"name":"Technology","super_category_id":26}
 */
export type IntelContentCategories = {
  /**
   * @x-auditable true
   */
  id?: number;
  /**
   * @x-auditable true
   */
  name?: string;
  /**
   * @x-auditable true
   */
  super_category_id?: number;
}[];

/**
 * Total results returned based on your search parameters.
 *
 * @example 1
 */
export type IntelCount = number;

export type IntelDomain = {
  additional_information?: IntelAdditionalInformation;
  application?: IntelApplication;
  content_categories?: IntelContentCategories;
  domain?: IntelDomainName;
  inherited_content_categories?: IntelInheritedContentCategories;
  inherited_from?: IntelInheritedFrom;
  inherited_risk_types?: IntelInheritedRiskTypes;
  popularity_rank?: IntelPopularityRank;
  resolves_to_refs?: IntelResolvesToRefs;
  risk_score?: IntelRiskScore;
  risk_types?: IntelRiskTypes;
};

export type IntelDomainHistory = {
  categorizations?: {
    /**
     * @example {"id":155,"name":"Technology"}
     */
    categories?: {
      /**
       * @example 155
       */
      id?: number;
      /**
       * @example Technology
       */
      name?: string;
    }[];
    /**
     * @example 2021-04-30
     * @format date
     * @x-auditable true
     */
    end?: string;
    /**
     * @example 2021-04-01
     * @format date
     * @x-auditable true
     */
    start?: string;
  }[];
  domain?: IntelDomainName;
};

/**
 * @example cloudflare.com
 * @x-auditable true
 */
export type IntelDomainName = string;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type IntelIdentifier = string;

export type IntelInheritedContentCategories =
  IntelCategoriesWithSuperCategoryIdsExampleEmpty;

/**
 * Domain from which `inherited_content_categories` and `inherited_risk_types` are inherited, if applicable.
 *
 * @x-auditable true
 */
export type IntelInheritedFrom = string;

export type IntelInheritedRiskTypes =
  IntelCategoriesWithSuperCategoryIdsExampleEmpty;

/**
 * @x-auditable true
 */
export type IntelIp = IntelIpv4 | IntelIpv6;

export type IntelIpList = {
  /**
   * @x-auditable true
   */
  description?: string;
  /**
   * @x-auditable true
   */
  id?: number;
  /**
   * @example Malware
   * @x-auditable true
   */
  name?: string;
};

/**
 * @example 192.0.2.0
 * @format ipv4
 * @x-auditable true
 */
export type IntelIpv4 = string;

/**
 * @example 2001:0DB8::
 * @format ipv6
 * @x-auditable true
 */
export type IntelIpv6 = string;

export type IntelMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

export type IntelMiscategorization = {
  /**
   * Content category IDs to add.
   *
   * @example 82
   */
  content_adds?: number[];
  /**
   * Content category IDs to remove.
   *
   * @example 155
   */
  content_removes?: number[];
  /**
   * @example domain
   * @x-auditable true
   */
  indicator_type?: "domain" | "ipv4" | "ipv6" | "url";
  /**
   * Provide only if indicator_type is `ipv4` or `ipv6`.
   *
   * @x-auditable true
   */
  ip?: string | null;
  /**
   * Security category IDs to add.
   *
   * @example 117
   * @example 131
   */
  security_adds?: number[];
  /**
   * Security category IDs to remove.
   *
   * @example 83
   */
  security_removes?: number[];
  /**
   * Provide only if indicator_type is `domain` or `url`. Example if indicator_type is `domain`: `example.com`. Example if indicator_type is `url`: `https://example.com/news/`.
   *
   * @x-auditable true
   */
  url?: string;
};

/**
 * Current page within paginated list of results.
 *
 * @example 1
 */
export type IntelPage = number;

export type IntelPassiveDnsByIp = {
  /**
   * Total results returned based on your search parameters.
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results.
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results.
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Reverse DNS look-ups observed during the time period.
   */
  reverse_records?: {
    /**
     * First seen date of the DNS record during the time period.
     *
     * @example 2021-04-01
     * @format date
     * @x-auditable true
     */
    first_seen?: string;
    /**
     * Hostname that the IP was observed resolving to.
     *
     * @x-auditable true
     */
    hostname?: string;
    /**
     * Last seen date of the DNS record during the time period.
     *
     * @example 2021-04-30
     * @format date
     * @x-auditable true
     */
    last_seen?: string;
  }[];
};

/**
 * Number of results per page of results.
 *
 * @example 20
 */
export type IntelPerPage = number;

export type IntelPhishingUrlInfo = {
  /**
   * List of categorizations applied to this submission.
   */
  categorizations?: {
    /**
     * Name of the category applied.
     *
     * @example PHISHING
     * @x-auditable true
     */
    category?: string;
    /**
     * Result of human review for this categorization.
     *
     * @example confirmed
     * @x-auditable true
     */
    verification_status?: string;
  }[];
  /**
   * List of model results for completed scans.
   */
  model_results?: {
    /**
     * Name of the model.
     *
     * @example MACHINE_LEARNING_v2
     * @x-auditable true
     */
    model_name?: string;
    /**
     * This is the score that is outputted by the model for this submission.
     *
     * @example 0.024
     */
    model_score?: number;
  }[];
  /**
   * List of signatures that matched against site content found when crawling the URL.
   */
  rule_matches?: {
    /**
     * For internal use.
     */
    banning?: boolean;
    /**
     * For internal use.
     */
    blocking?: boolean;
    /**
     * Description of the signature that matched.
     *
     * @example Match frequently used social followers phishing kit
     * @x-auditable true
     */
    description?: string;
    /**
     * Name of the signature that matched.
     *
     * @example phishkit.social_followers
     * @x-auditable true
     */
    name?: string;
  }[];
  /**
   * Status of the most recent scan found.
   */
  scan_status?: {
    /**
     * Timestamp of when the submission was processed.
     *
     * @example Wed, 26 Oct 2022 16:04:51 GMT
     * @x-auditable true
     */
    last_processed?: string;
    /**
     * For internal use.
     */
    scan_complete?: boolean;
    /**
     * Status code that the crawler received when loading the submitted URL.
     *
     * @x-auditable true
     */
    status_code?: number;
    /**
     * ID of the most recent submission.
     *
     * @x-auditable true
     */
    submission_id?: number;
  };
  /**
   * For internal use.
   */
  screenshot_download_signature?: string;
  /**
   * For internal use.
   */
  screenshot_path?: string;
  /**
   * URL that was submitted.
   *
   * @example https://www.cloudflare.com
   * @x-auditable true
   */
  url?: string;
};

export type IntelPhishingUrlInfoComponentsSchemasSingleResponse =
  IntelApiResponseSingle & {
    result?: IntelPhishingUrlInfo;
  };

export type IntelPhishingUrlSubmit = {
  /**
   * URLs that were excluded from scanning because their domain is in our no-scan list.
   */
  excluded_urls?: {
    /**
     * URL that was excluded.
     *
     * @example https://developers.cloudflare.com
     * @x-auditable true
     */
    url?: string;
  }[];
  /**
   * URLs that were skipped because the same URL is currently being scanned.
   */
  skipped_urls?: {
    /**
     * URL that was skipped.
     *
     * @example https://www.cloudflare.com/developer-week/
     * @x-auditable true
     */
    url?: string;
    /**
     * ID of the submission of that URL that is currently scanning.
     *
     * @example 2
     * @x-auditable true
     */
    url_id?: number;
  }[];
  /**
   * URLs that were successfully submitted for scanning.
   */
  submitted_urls?: {
    /**
     * URL that was submitted.
     *
     * @example https://www.cloudflare.com
     * @x-auditable true
     */
    url?: string;
    /**
     * ID assigned to this URL submission. Used to retrieve scanning results.
     *
     * @example 1
     * @x-auditable true
     */
    url_id?: number;
  }[];
};

export type IntelPhishingUrlSubmitComponentsSchemasSingleResponse =
  IntelApiResponseSingle & {
    result?: IntelPhishingUrlSubmit;
  };

/**
 * Global Cloudflare 100k ranking for the last 30 days, if available for the hostname. The top ranked domain is 1, the lowest ranked domain is 100,000.
 *
 * @x-auditable true
 */
export type IntelPopularityRank = number;

export type IntelResolvesToRef = {
  id?: IntelStixIdentifier;
  /**
   * IP address or domain name.
   *
   * @example 192.0.2.0
   * @x-auditable true
   */
  value?: string;
};

/**
 * Specifies a list of references to one or more IP addresses or domain names that the domain name currently resolves to.
 */
export type IntelResolvesToRefs = IntelResolvesToRef[];

export type IntelResponse = IntelApiResponseCollection & {
  result?: IntelDomainHistory[];
};

export type IntelResultInfo = {
  /**
   * Total number of results for the requested service.
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results.
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results.
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters.
   *
   * @example 2000
   */
  total_count?: number;
};

/**
 * Hostname risk score, which is a value between 0 (lowest risk) to 1 (highest risk).
 */
export type IntelRiskScore = number;

export type IntelRiskTypes = IntelCategoriesWithSuperCategoryIdsExampleEmpty;

export type IntelSchemasApiResponseCollection =
  IntelSchemasApiResponseCommon & {
    result_info?: IntelSchemasResultInfo;
  };

export type IntelSchemasApiResponseCommon = {
  errors: IntelSchemasMessages;
  messages: IntelSchemasMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type IntelSchemasAsn = {
  asn?: IntelAsn;
  country?: IntelAsnCountry;
  description?: IntelAsnDescription;
  /**
   * @x-auditable true
   */
  domain_count?: number;
  /**
   * @example example.com
   */
  top_domains?: string[];
  type?: IntelAsnType;
};

export type IntelSchemasIp = {
  /**
   * Specifies a reference to the autonomous systems (AS) that the IP address belongs to.
   */
  belongs_to_ref?: {
    /**
     * @example US
     * @x-auditable true
     */
    country?: string;
    /**
     * @example CLOUDFLARENET
     * @x-auditable true
     */
    description?: string;
    /**
     * @example autonomous-system--2fa28d71-3549-5a38-af05-770b79ad6ea8
     * @x-auditable true
     */
    id?: string;
    /**
     * Infrastructure type of this ASN.
     *
     * @example hosting_provider
     * @x-auditable true
     */
    type?: "hosting_provider" | "isp" | "organization";
    /**
     * @x-auditable true
     */
    value?: string;
  };
  ip?: IntelIp;
  /**
   * @example {"id":131,"name":"Phishing","super_category_id":21}
   */
  risk_types?: {
    id?: number;
    /**
     * @x-auditable true
     */
    name?: string;
    super_category_id?: number;
  }[];
};

export type IntelSchemasMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

export type IntelSchemasResponse = IntelApiResponseCollection & {
  result?: IntelSchemasIp[];
};

export type IntelSchemasResultInfo = {
  /**
   * Total number of results for the requested service.
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results.
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results.
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters.
   *
   * @example 2000
   */
  total_count?: number;
};

export type IntelSchemasSingleResponse = IntelApiResponseSingle & {
  result?: IntelWhois;
};

export type IntelSingleResponse = IntelApiResponseSingle & {
  result?: IntelDomain;
};

export type IntelStartEndParams = {
  /**
   * Defaults to the current date.
   *
   * @example 2021-04-30
   * @format date
   * @x-auditable true
   */
  end?: string;
  /**
   * Defaults to 30 days before the end parameter value.
   *
   * @example 2021-04-01
   * @format date
   * @x-auditable true
   */
  start?: string;
};

/**
 * STIX 2.1 identifier: https://docs.oasis-open.org/cti/stix/v2.1/cs02/stix-v2.1-cs02.html#_64yvzeku5a5c.
 *
 * @example ipv4-addr--baa568ec-6efe-5902-be55-0663833db537
 * @x-auditable true
 */
export type IntelStixIdentifier = string;

/**
 * URL(s) to filter submissions results by.
 *
 * @example https://www.cloudflare.com
 * @format uri
 * @x-auditable true
 */
export type IntelUrl = string;

export type IntelUrlParam = {
  url?: IntelUrl;
};

export type IntelWhois = {
  /**
   * @example 2009-02-17
   * @format date
   * @x-auditable true
   */
  created_date?: string;
  domain?: IntelDomainName;
  /**
   * @example ns3.cloudflare.com
   * @example ns4.cloudflare.com
   * @example ns5.cloudflare.com
   * @example ns6.cloudflare.com
   * @example ns7.cloudflare.com
   */
  nameservers?: string[];
  /**
   * @example DATA REDACTED
   * @x-auditable true
   */
  registrant?: string;
  /**
   * @example United States
   * @x-auditable true
   */
  registrant_country?: string;
  /**
   * @example https://domaincontact.cloudflareregistrar.com/cloudflare.com
   * @x-auditable true
   */
  registrant_email?: string;
  /**
   * @example DATA REDACTED
   * @x-auditable true
   */
  registrant_org?: string;
  /**
   * @example Cloudflare, Inc.
   * @x-auditable true
   */
  registrar?: string;
  /**
   * @example 2017-05-24
   * @format date
   * @x-auditable true
   */
  updated_date?: string;
};

/**
 * The Account ID for this resource.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @minLength 32
 * @x-auditable true
 */
export type ListsAccountId = string;

export type ListsApiResponseCollection = {
  result: Record<string, any> | Record<string, any>[] | null;
  errors: ListsMessages;
  messages: ListsMessages;
  /**
   * Defines whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type ListsApiResponseCommon = {
  errors: ListsMessages;
  messages: ListsMessages;
  result: Record<string, any> | Record<string, any>[];
  /**
   * Defines whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type ListsApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: ListsMessages;
  messages: ListsMessages;
  result: any | null;
  /**
   * Defines whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type ListsBulkOperationResponseCollection = {
  result?: ListsOperation;
} & ListsApiResponseCollection;

/**
 * The RFC 3339 timestamp of when the operation was completed.
 *
 * @example 2020-01-01T08:00:00Z
 * @x-auditable true
 */
export type ListsCompleted = string;

/**
 * The RFC 3339 timestamp of when the list was created.
 *
 * @example 2020-01-01T08:00:00Z
 * @x-auditable true
 */
export type ListsCreatedOn = string;

/**
 * An informative summary of the list.
 *
 * @example This is a note
 * @maxLength 500
 * @x-auditable true
 */
export type ListsDescription = string;

/**
 * @example {"comment":"Private IP address","created_on":"2020-01-01T08:00:00Z","id":"2c0fc9fa937b11eaa1b71c4d701ab86e","ip":"10.0.0.1","modified_on":"2020-01-10T14:00:00Z"}
 */
export type ListsItem = {
  asn?: ListsItemAsn;
  comment?: ListsItemComment;
  /**
   * The RFC 3339 timestamp of when the item was created.
   *
   * @example 2020-01-01T08:00:00Z
   * @x-auditable true
   */
  created_on?: string;
  hostname?: ListsItemHostname;
  id?: ListsListId;
  ip?: ListsItemIp;
  /**
   * The RFC 3339 timestamp of when the item was last modified.
   *
   * @example 2020-01-10T14:00:00Z
   * @x-auditable true
   */
  modified_on?: string;
  redirect?: ListsItemRedirect;
};

export type ListsItemResponseCollection = {
  result?: ListsItem;
} & ListsApiResponseCollection;

/**
 * Defines a non-negative 32 bit integer.
 *
 * @example 5567
 * @x-auditable true
 */
export type ListsItemAsn = number;

/**
 * Defines an informative summary of the list item.
 *
 * @example Private IP address
 * @x-auditable true
 */
export type ListsItemComment = string;

/**
 * Valid characters for hostnames are ASCII(7) letters from a to z, the digits from 0 to 9, wildcards (*), and the hyphen (-).
 */
export type ListsItemHostname = {
  /**
   * Only applies to wildcard hostnames (e.g., *.example.com). When true (default), only subdomains are blocked. When false, both the root domain and subdomains are blocked.
   *
   * @example true
   */
  exclude_exact_hostname?: boolean;
  /**
   * @example example.com
   * @x-auditable true
   */
  url_hostname: string;
};

/**
 * Defines the unique ID of the item in the List.
 *
 * @example 34b12448945f11eaa1b71c4d701ab86e
 * @maxLength 32
 * @minLength 32
 * @x-auditable true
 */
export type ListsItemId = string;

/**
 * An IPv4 address, an IPv4 CIDR, an IPv6 address, or an IPv6 CIDR.
 *
 * @example 10.0.0.1
 * @x-auditable true
 */
export type ListsItemIp = string;

/**
 * The definition of the redirect.
 */
export type ListsItemRedirect = {
  /**
   * @default false
   * @x-auditable true
   */
  include_subdomains?: boolean;
  /**
   * @default false
   * @x-auditable true
   */
  preserve_path_suffix?: boolean;
  /**
   * @default false
   * @x-auditable true
   */
  preserve_query_string?: boolean;
  /**
   * @example example.com/arch
   * @x-auditable true
   */
  source_url: string;
  /**
   * @default 301
   * @x-auditable true
   */
  status_code?: 301 | 302 | 307 | 308;
  /**
   * @default false
   * @x-auditable true
   */
  subpath_matching?: boolean;
  /**
   * @example https://archlinux.org/
   * @x-auditable true
   */
  target_url: string;
};

export type ListsItems = ListsItem[];

export type ListsItemsListResponseCollection = {
  result?: ListsItems;
  result_info?: {
    cursors?: {
      /**
       * @example yyy
       * @x-auditable true
       */
      after?: string;
      /**
       * @example xxx
       * @x-auditable true
       */
      before?: string;
    };
  };
} & ListsApiResponseCollection;

export type ListsItemsUpdateRequestCollection = (
  | {
      comment?: ListsItemComment;
      ip: ListsItemIp;
    }
  | {
      comment?: ListsItemComment;
      redirect: ListsItemRedirect;
    }
  | {
      comment?: ListsItemComment;
      hostname: ListsItemHostname;
    }
  | {
      asn: ListsItemAsn;
      comment?: ListsItemComment;
    }
)[];

/**
 * The type of the list. Each type supports specific list items (IP addresses, ASNs, hostnames or redirects).
 *
 * @example ip
 */
export type ListsKind = "ip" | "redirect" | "hostname" | "asn";

export type ListsList = {
  created_on: ListsCreatedOn;
  description?: ListsDescription;
  id: ListsListId;
  kind: ListsKind;
  modified_on: ListsModifiedOn;
  name: ListsName;
  num_items: ListsNumItems;
  num_referencing_filters: ListsNumReferencingFilters;
};

export type ListsListDeleteResponseCollection = {
  result:
    | {
        id: ListsListId;
      }
    | Record<string, any>[];
  errors: ListsMessages;
  messages: ListsMessages;
  /**
   * Defines whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type ListsListResponseCollection = {
  result: ListsList;
  errors: ListsMessages;
  messages: ListsMessages;
  /**
   * Defines whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

/**
 * The unique ID of the list.
 *
 * @example 2c0fc9fa937b11eaa1b71c4d701ab86e
 * @maxLength 32
 * @minLength 32
 * @x-auditable true
 */
export type ListsListId = string;

export type ListsListsAsyncResponse = {
  result?: {
    operation_id: ListsOperationId;
  };
} & ListsApiResponseCollection;

export type ListsListsResponseCollection = {
  result?: ListsList[];
} & ListsApiResponseCollection;

export type ListsMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * The RFC 3339 timestamp of when the list was last modified.
 *
 * @example 2020-01-10T14:00:00Z
 * @x-auditable true
 */
export type ListsModifiedOn = string;

/**
 * An informative name for the list. Use this name in filter and rule expressions.
 *
 * @example list1
 * @maxLength 50
 * @pattern ^[a-zA-Z0-9_]+$
 * @x-auditable true
 */
export type ListsName = string;

/**
 * The number of items in the list.
 *
 * @example 10
 * @x-auditable true
 */
export type ListsNumItems = number;

/**
 * The number of [filters](/api/resources/filters/) referencing the list.
 *
 * @example 2
 * @x-auditable true
 */
export type ListsNumReferencingFilters = number;

export type ListsOperation =
  | {
      completed: ListsCompleted;
      /**
       * A message describing the error when the status is `failed`.
       *
       * @example This list is at the maximum number of items
       * @x-auditable true
       */
      error: string;
      id: ListsOperationId;
      /**
       * The current status of the asynchronous operation.
       *
       * @example failed
       * @x-auditable true
       */
      status: "failed";
    }
  | {
      id: ListsOperationId;
      /**
       * The current status of the asynchronous operation.
       *
       * @example pending
       * @x-auditable true
       */
      status: "pending" | "running";
    }
  | {
      completed: ListsCompleted;
      id: ListsOperationId;
      /**
       * The current status of the asynchronous operation.
       *
       * @example completed
       * @x-auditable true
       */
      status: "completed";
    };

/**
 * The unique operation ID of the asynchronous action.
 *
 * @example 4da8780eeb215e6cb7f48dd981c4ea02
 * @x-auditable true
 */
export type ListsOperationId = string;

/**
 * The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
 */
export type LoadBalancingHost = string[];

/**
 * Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin.
 */
export type LoadBalancingAdaptiveRouting = {
  /**
   * Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See `session_affinity_attributes` for control over when sessions are broken or reassigned.
   *
   * @default false
   * @example true
   * @x-auditable true
   */
  failover_across_pools?: boolean;
};

/**
 * The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual_network_id must also be set.
 *
 * @example 0.0.0.0
 * @x-auditable true
 */
export type LoadBalancingAddress = string;

/**
 * Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
 *
 * @default false
 * @example true
 * @x-auditable true
 */
export type LoadBalancingAllowInsecure = boolean;

export type LoadBalancingAnalytics = {
  /**
   * @default 1
   */
  id?: number;
  /**
   * @example {"address":"198.51.100.4","changed":true,"enabled":true,"failure_reason":"No failures","healthy":true,"ip":"198.51.100.4","name":"some-origin"}
   */
  origins?: LoadBalancingOriginAnalytics[];
  /**
   * @example {"changed":true,"healthy":true,"id":"74bc6a8b9b0dda3d651707a2928bad0c","minimum_origins":1,"name":"some-pool"}
   */
  pool?: Record<string, any>;
  /**
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  timestamp?: string;
};

export type LoadBalancingApiPaginatedResponseCollection =
  LoadBalancingApiResponseCommon & {
    result_info?: LoadBalancingResultInfo;
  };

export type LoadBalancingApiResponseCommon = {
  errors: LoadBalancingMessages;
  messages: LoadBalancingMessages;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type LoadBalancingApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: LoadBalancingMessages;
  messages: LoadBalancingMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

export type LoadBalancingApiResponseSingle = LoadBalancingApiResponseCommon & {
  result?: (Record<string, any> | null) | (string | null);
};

/**
 * A list of regions from which to run health checks. Null means every Cloudflare data center.
 *
 * @example WEU
 * @example ENAM
 */
export type LoadBalancingCheckRegions =
  | (
      | "WNAM"
      | "ENAM"
      | "WEU"
      | "EEU"
      | "NSAM"
      | "SSAM"
      | "OC"
      | "ME"
      | "NAF"
      | "SAF"
      | "SAS"
      | "SEAS"
      | "NEAS"
      | "ALL_REGIONS"
    )[]
  | null;

/**
 * Object description.
 *
 * @example Load Balancer for www.example.com
 * @x-auditable true
 */
export type LoadBalancingComponentsSchemasDescription = string;

/**
 * Whether to enable (the default) this load balancer.
 *
 * @default true
 * @example true
 * @x-auditable true
 */
export type LoadBalancingComponentsSchemasEnabled = boolean;

export type LoadBalancingComponentsSchemasIdResponse =
  LoadBalancingApiResponseSingle & {
    result?: {
      id?: LoadBalancingLoadBalancerComponentsSchemasIdentifier;
    };
  };

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type LoadBalancingComponentsSchemasIdentifier = string;

/**
 * The DNS hostname to associate with your Load Balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the Load Balancer will take precedence and the DNS record will not be used.
 *
 * @example www.example.com
 * @x-auditable true
 */
export type LoadBalancingComponentsSchemasName = string;

export type LoadBalancingComponentsSchemasResponseCollection =
  LoadBalancingApiPaginatedResponseCollection & {
    result?: LoadBalancingAnalytics[];
  };

export type LoadBalancingComponentsSchemasSingleResponse =
  LoadBalancingApiResponseSingle & {
    /**
     * A list of countries and subdivisions mapped to a region.
     *
     * @example {"iso_standard":"Country and subdivision codes follow ISO 3166-1 alpha-2 and ISO 3166-2","regions":[{"countries":[{"country_code_a2":"CA","country_name":"Canada","country_subdivisions":[{"subdivision_code_a2":"AB","subdivision_name":"Alberta"},{"subdivision_code_a2":"BC","subdivision_name":"British Columbia"}]},{"country_code_a2":"HT","country_name":"Haiti"},{"country_code_a2":"MX","country_name":"Mexico"},{"country_code_a2":"US","country_name":"United States","country_subdivisions":[{"subdivision_code_a2":"AZ","subdivision_name":"Arizona"},{"subdivision_code_a2":"CA","subdivision_name":"California"},{"subdivision_code_a2":"CO","subdivision_name":"Colorado"},{"subdivision_code_a2":"HI","subdivision_name":"Hawaii"},{"subdivision_code_a2":"MN","subdivision_name":"Minnesota"},{"subdivision_code_a2":"MO","subdivision_name":"Missouri"},{"subdivision_code_a2":"NV","subdivision_name":"Nevada"},{"subdivision_code_a2":"OR","subdivision_name":"Oregon"},{"subdivision_code_a2":"TX","subdivision_name":"Texas"},{"subdivision_code_a2":"UT","subdivision_name":"Utah"},{"subdivision_code_a2":"WA","subdivision_name":"Washington"}]}],"region_code":"WNAM"}]}
     */
    result?: Record<string, any>;
  };

/**
 * @example example.com
 * @x-auditable true
 */
export type LoadBalancingComponentsSchemasZoneName = string;

/**
 * To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
 *
 * @default 0
 * @x-auditable true
 */
export type LoadBalancingConsecutiveDown = number;

/**
 * To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
 *
 * @default 0
 * @x-auditable true
 */
export type LoadBalancingConsecutiveUp = number;

/**
 * A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region_pool mapping if it exists else to default_pools.
 *
 * @example {"GB":["abd90f38ced07c2e2f4df50b1f61d4194"],"US":["de90f38ced07c2e2f4df50b1f61d4194","00920f38ce07c2e2f4df50b1f61d4194"]}
 */
export type LoadBalancingCountryPools = {
  [key: string]: string[];
};

/**
 * A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region.
 *
 * @example 17b5962d775c646f3f9725cbc7a53df4
 * @example 9290f38c5d07c2e2f4df57b1f61d4196
 * @example 00920f38ce07c2e2f4df50b1f61d4194
 */
export type LoadBalancingDefaultPools = string[];

/**
 * Object description.
 *
 * @example Login page monitor
 * @x-auditable true
 */
export type LoadBalancingDescription = string;

/**
 * This field shows up only if the origin is disabled. This field is set with the time the origin was disabled.
 *
 * @format date-time
 * @x-auditable true
 */
export type LoadBalancingDisabledAt = string;

/**
 * Whether to enable (the default) or disable this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any).
 *
 * @default true
 * @example false
 * @x-auditable true
 */
export type LoadBalancingEnabled = boolean;

/**
 * A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
 *
 * @example alive
 * @x-auditable true
 */
export type LoadBalancingExpectedBody = string;

/**
 * The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
 *
 * @example 2xx
 * @x-auditable true
 */
export type LoadBalancingExpectedCodes = string;

/**
 * The pool ID to use when all other pools are detected as unhealthy.
 *
 * @x-auditable true
 */
export type LoadBalancingFallbackPool = string;

/**
 * Filter options for a particular resource type (pool or origin). Use null to reset.
 */
export type LoadBalancingFilterOptions = {
  /**
   * If set true, disable notifications for this type of resource (pool or origin).
   *
   * @default false
   * @x-auditable true
   */
  disable?: boolean;
  /**
   * If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
   *
   * @x-auditable true
   */
  healthy?: boolean | null;
} | null;

/**
 * Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
 *
 * @default false
 * @example true
 * @x-auditable true
 */
export type LoadBalancingFollowRedirects = boolean;

/**
 * The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
 *
 * @example {"Host":["example.com"],"X-App-ID":["abc123"]}
 */
export type LoadBalancingHeader = {
  [key: string]: string[];
};

export type LoadBalancingHealthDetails = LoadBalancingApiResponseSingle & {
  /**
   * A list of regions from which to run health checks. Null means every Cloudflare data center.
   *
   * @example {"pool_id":"17b5962d775c646f3f9725cbc7a53df4","pop_health":{"Amsterdam, NL":{"healthy":true,"origins":[{"2001:DB8::5":{"failure_reason":"No failures","healthy":true,"response_code":401,"rtt":"12.1ms"}}]}}}
   */
  result?: {
    /**
     * Pool ID
     *
     * @example 17b5962d775c646f3f9725cbc7a53df4
     * @x-auditable true
     */
    pool_id?: string;
    /**
     * List of regions and associated health status.
     */
    pop_health?: {
      /**
       * Whether health check in region is healthy.
       *
       * @example true
       * @x-auditable true
       */
      healthy?: boolean;
      origins?: LoadBalancingOriginHealth[];
    };
  };
};

export type LoadBalancingIdResponse = LoadBalancingApiResponseSingle & {
  result?: {
    id?: LoadBalancingIdentifier;
  };
};

/**
 * @example f1aba936b94213e5b8dca0c0dbf1f9cc
 * @x-auditable true
 */
export type LoadBalancingIdentifier = string;

/**
 * The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
 *
 * @default 60
 * @x-auditable true
 */
export type LoadBalancingInterval = number;

/**
 * The latitude of the data center containing the origins used in this pool in decimal degrees. If this is set, longitude must also be set.
 *
 * @x-auditable true
 */
export type LoadBalancingLatitude = number;

export type LoadBalancingLoadBalancer = {
  adaptive_routing?: LoadBalancingAdaptiveRouting;
  country_pools?: LoadBalancingCountryPools;
  created_on?: LoadBalancingTimestamp;
  default_pools?: LoadBalancingDefaultPools;
  description?: LoadBalancingComponentsSchemasDescription;
  enabled?: LoadBalancingComponentsSchemasEnabled;
  fallback_pool?: LoadBalancingFallbackPool;
  id?: LoadBalancingLoadBalancerComponentsSchemasIdentifier;
  location_strategy?: LoadBalancingLocationStrategy;
  modified_on?: LoadBalancingTimestamp;
  name?: LoadBalancingComponentsSchemasName;
  networks?: LoadBalancingNetworks;
  pop_pools?: LoadBalancingPopPools;
  proxied?: LoadBalancingProxied;
  random_steering?: LoadBalancingRandomSteering;
  region_pools?: LoadBalancingRegionPools;
  rules?: LoadBalancingRules;
  session_affinity?: LoadBalancingSessionAffinity;
  session_affinity_attributes?: LoadBalancingSessionAffinityAttributes;
  session_affinity_ttl?: LoadBalancingSessionAffinityTtl;
  steering_policy?: LoadBalancingSteeringPolicy;
  ttl?: LoadBalancingTtl;
  zone_name?: LoadBalancingComponentsSchemasZoneName;
};

/**
 * @example 699d98642c564d2e855e9661899b7252
 * @x-auditable true
 */
export type LoadBalancingLoadBalancerComponentsSchemasIdentifier = string;

export type LoadBalancingLoadBalancerComponentsSchemasResponseCollection =
  LoadBalancingApiPaginatedResponseCollection & {
    result?: LoadBalancingLoadBalancer[];
  };

export type LoadBalancingLoadBalancerComponentsSchemasSingleResponse =
  LoadBalancingApiResponseSingle & {
    result?: LoadBalancingLoadBalancer;
  };

/**
 * Configures load shedding policies and percentages for the pool.
 */
export type LoadBalancingLoadShedding = {
  /**
   * The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
   *
   * @default 0
   * @maximum 100
   * @minimum 0
   * @x-auditable true
   */
  default_percent?: number;
  /**
   * The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
   *
   * @default random
   * @x-auditable true
   */
  default_policy?: "random" | "hash";
  /**
   * The percent of existing sessions to shed from the pool, according to the session policy.
   *
   * @default 0
   * @maximum 100
   * @minimum 0
   * @x-auditable true
   */
  session_percent?: number;
  /**
   * Only the hash policy is supported for existing sessions (to avoid exponential decay).
   *
   * @default hash
   * @x-auditable true
   */
  session_policy?: "hash";
};

/**
 * Controls location-based steering for non-proxied requests. See `steering_policy` to learn how steering is affected.
 */
export type LoadBalancingLocationStrategy = {
  /**
   * Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
   * - `"pop"`: Use the Cloudflare PoP location.
   * - `"resolver_ip"`: Use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, use the Cloudflare PoP location.
   *
   * @default pop
   * @example resolver_ip
   * @x-auditable true
   */
  mode?: "pop" | "resolver_ip";
  /**
   * Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
   * - `"always"`: Always prefer ECS.
   * - `"never"`: Never prefer ECS.
   * - `"proximity"`: Prefer ECS only when `steering_policy="proximity"`.
   * - `"geo"`: Prefer ECS only when `steering_policy="geo"`.
   *
   * @default proximity
   * @example always
   * @x-auditable true
   */
  prefer_ecs?: "always" | "never" | "proximity" | "geo";
};

/**
 * The longitude of the data center containing the origins used in this pool in decimal degrees. If this is set, latitude must also be set.
 *
 * @x-auditable true
 */
export type LoadBalancingLongitude = number;

export type LoadBalancingMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
 *
 * @default GET
 * @example GET
 * @x-auditable true
 */
export type LoadBalancingMethod = string;

/**
 * The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and will failover to the next available pool.
 *
 * @default 1
 * @x-auditable true
 */
export type LoadBalancingMinimumOrigins = number;

export type LoadBalancingMonitor = LoadBalancingMonitorEditable & {
  created_on?: LoadBalancingTimestamp;
  id?: LoadBalancingIdentifier;
  modified_on?: LoadBalancingTimestamp;
};

export type LoadBalancingMonitorEditable = {
  allow_insecure?: LoadBalancingAllowInsecure;
  consecutive_down?: LoadBalancingConsecutiveDown;
  consecutive_up?: LoadBalancingConsecutiveUp;
  description?: LoadBalancingDescription;
  expected_body?: LoadBalancingExpectedBody;
  expected_codes?: LoadBalancingExpectedCodes;
  follow_redirects?: LoadBalancingFollowRedirects;
  header?: LoadBalancingHeader;
  interval?: LoadBalancingInterval;
  method?: LoadBalancingMethod;
  path?: LoadBalancingPath;
  port?: LoadBalancingPort;
  probe_zone?: LoadBalancingProbeZone;
  retries?: LoadBalancingRetries;
  timeout?: LoadBalancingTimeout;
  type?: LoadBalancingType;
};

export type LoadBalancingMonitorReferencesResponse =
  LoadBalancingApiResponseCommon & {
    /**
     * List of resources that reference a given monitor.
     *
     * @example {"reference_type":"referrer","resource_id":"17b5962d775c646f3f9725cbc7a53df4","resource_name":"primary-dc-1","resource_type":"pool"}
     */
    result?: {
      /**
       * @x-auditable true
       */
      reference_type?: "*" | "referral" | "referrer";
      /**
       * @x-auditable true
       */
      resource_id?: string;
      /**
       * @x-auditable true
       */
      resource_name?: string;
      /**
       * @x-auditable true
       */
      resource_type?: string;
    }[];
  };

export type LoadBalancingMonitorResponseCollection =
  LoadBalancingApiPaginatedResponseCollection & {
    result?: LoadBalancingMonitor[];
  };

export type LoadBalancingMonitorResponseSingle =
  LoadBalancingApiResponseSingle & {
    result?: LoadBalancingMonitor;
  };

/**
 * The ID of the Monitor to use for checking the health of origins within this pool.
 *
 * @x-auditable true
 */
export type LoadBalancingMonitorId = string;

/**
 * A short name (tag) for the pool. Only alphanumeric characters, hyphens, and underscores are allowed.
 *
 * @example primary-dc-1
 * @x-auditable true
 */
export type LoadBalancingName = string;

/**
 * List of networks where Load Balancer or Pool is enabled.
 */
export type LoadBalancingNetworks = string[];

/**
 * This field is now deprecated. It has been moved to Cloudflare's Centralized Notification service https://developers.cloudflare.com/fundamentals/notifications/. The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.
 *
 * @example someone@example.com,sometwo@example.com
 * @x-auditable true
 */
export type LoadBalancingNotificationEmail = string;

/**
 * Filter pool and origin health notifications by resource type or health status. Use null to reset.
 *
 * @example {"origin":{"disable":true},"pool":{"healthy":false}}
 */
export type LoadBalancingNotificationFilter = {
  origin?: LoadBalancingFilterOptions;
  pool?: LoadBalancingFilterOptions;
} | null;

export type LoadBalancingOrigin = {
  address?: LoadBalancingAddress;
  disabled_at?: LoadBalancingDisabledAt;
  enabled?: LoadBalancingSchemasEnabled;
  header?: LoadBalancingSchemasHeader;
  name?: LoadBalancingSchemasName;
  port?: LoadBalancingOriginPort;
  virtual_network_id?: LoadBalancingVirtualNetworkId;
  weight?: LoadBalancingWeight;
};

export type LoadBalancingOriginAnalytics = {
  address?: LoadBalancingAddress;
  changed?: LoadBalancingOriginChanged;
  enabled?: LoadBalancingSchemasEnabled;
  failure_reason?: LoadBalancingOriginFailureReason;
  healthy?: LoadBalancingOriginHealthy;
  ip?: LoadBalancingOriginIp;
  name?: LoadBalancingSchemasName;
};

/**
 * Whether the origin has changed health status.
 *
 * @example true
 * @x-auditable true
 */
export type LoadBalancingOriginChanged = boolean;

/**
 * Failure reason for un-healthy origin health check.
 *
 * @example No failures
 * @x-auditable true
 */
export type LoadBalancingOriginFailureReason = string;

export type LoadBalancingOriginHealth = {
  ip?: {
    /**
     * Failure reason.
     *
     * @example No failure reasons
     * @x-auditable true
     */
    failure_reason?: string;
    /**
     * Origin health status.
     *
     * @example true
     * @x-auditable true
     */
    healthy?: boolean;
    /**
     * Response code from origin health check.
     *
     * @example 200
     * @x-auditable true
     */
    response_code?: number;
    /**
     * Origin RTT (Round Trip Time) response.
     *
     * @example 201.5ms
     * @x-auditable true
     */
    rtt?: string;
  };
};

/**
 * Whether the origin is reported as healthy.
 *
 * @example true
 * @x-auditable true
 */
export type LoadBalancingOriginHealthy = boolean;

/**
 * The IP address (IPv4 or IPv6) of the origin.
 *
 * @example 198.51.100.4
 * @x-auditable true
 */
export type LoadBalancingOriginIp = string;

/**
 * The origin ipv4/ipv6 address or domain name mapped to it's health data.
 *
 * @example {"failure_reason":"No failures","healthy":true,"response_code":200,"rtt":"66ms"}
 */
export type LoadBalancingOriginHealthData = {
  /**
   * @x-auditable true
   */
  failure_reason?: string;
  /**
   * @x-auditable true
   */
  healthy?: boolean;
  /**
   * @x-auditable true
   */
  response_code?: number;
  /**
   * @x-auditable true
   */
  rtt?: string;
};

/**
 * The port for upstream connections. A value of 0 means the default port for the protocol will be used.
 *
 * @default 0
 */
export type LoadBalancingOriginPort = number;

/**
 * Configures origin steering for the pool. Controls how origins are selected for new sessions and traffic without session affinity.
 */
export type LoadBalancingOriginSteering = {
  /**
   * The type of origin steering policy to use.
   * - `"random"`: Select an origin randomly.
   * - `"hash"`: Select an origin by computing a hash over the CF-Connecting-IP address.
   * - `"least_outstanding_requests"`: Select an origin by taking into consideration origin weights, as well as each origin's number of outstanding requests. Origins with more pending requests are weighted proportionately less relative to others.
   * - `"least_connections"`: Select an origin by taking into consideration origin weights, as well as each origin's number of open connections. Origins with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections.
   *
   * @default random
   * @x-auditable true
   */
  policy?:
    | "random"
    | "hash"
    | "least_outstanding_requests"
    | "least_connections";
};

/**
 * The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy.
 */
export type LoadBalancingOrigins = LoadBalancingOrigin[];

/**
 * The email address to send health status notifications to. This field is now deprecated in favor of Cloudflare Notifications for Load Balancing, so only resetting this field with an empty string `""` is accepted.
 *
 * @example
 */
export type LoadBalancingPatchPoolsNotificationEmail = "";

/**
 * The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
 *
 * @default /
 * @example /health
 * @x-auditable true
 */
export type LoadBalancingPath = string;

export type LoadBalancingPool = {
  check_regions?: LoadBalancingCheckRegions;
  created_on?: LoadBalancingTimestamp;
  description?: LoadBalancingSchemasDescription;
  disabled_at?: LoadBalancingSchemasDisabledAt;
  enabled?: LoadBalancingEnabled;
  id?: LoadBalancingSchemasIdentifier;
  latitude?: LoadBalancingLatitude;
  load_shedding?: LoadBalancingLoadShedding;
  longitude?: LoadBalancingLongitude;
  minimum_origins?: LoadBalancingMinimumOrigins;
  modified_on?: LoadBalancingTimestamp;
  monitor?: LoadBalancingMonitorId;
  name?: LoadBalancingName;
  networks?: LoadBalancingNetworks;
  notification_email?: LoadBalancingNotificationEmail;
  notification_filter?: LoadBalancingNotificationFilter;
  origin_steering?: LoadBalancingOriginSteering;
  origins?: LoadBalancingOrigins;
};

/**
 * The name for the pool to filter.
 *
 * @example primary-dc
 * @x-auditable true
 */
export type LoadBalancingPoolName = string;

export type LoadBalancingPoolsReferencesResponse =
  LoadBalancingApiResponseCommon & {
    /**
     * List of resources that reference a given pool.
     *
     * @example {"reference_type":"referrer","resource_id":"699d98642c564d2e855e9661899b7252","resource_name":"www.example.com","resource_type":"load_balancer"}
     * @example {"reference_type":"referral","resource_id":"f1aba936b94213e5b8dca0c0dbf1f9cc","resource_name":"Login page monitor","resource_type":"monitor"}
     */
    result?: {
      /**
       * @x-auditable true
       */
      reference_type?: "*" | "referral" | "referrer";
      /**
       * @x-auditable true
       */
      resource_id?: string;
      /**
       * @x-auditable true
       */
      resource_name?: string;
      /**
       * @x-auditable true
       */
      resource_type?: string;
    }[];
  };

/**
 * (Enterprise only): A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country_pool, then region_pool mapping if it exists else to default_pools.
 *
 * @example {"LAX":["de90f38ced07c2e2f4df50b1f61d4194","9290f38c5d07c2e2f4df57b1f61d4196"],"LHR":["abd90f38ced07c2e2f4df50b1f61d4194","f9138c5d07c2e2f4df57b1f61d4196"],"SJC":["00920f38ce07c2e2f4df50b1f61d4194"]}
 */
export type LoadBalancingPopPools = {
  [key: string]: string[];
};

/**
 * The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).
 *
 * @default 0
 * @x-auditable true
 */
export type LoadBalancingPort = number;

/**
 * @example f1aba936b94213e5b8dca0c0dbf1f9cc
 */
export type LoadBalancingPreviewId = void;

export type LoadBalancingPreviewResponse = LoadBalancingApiResponseSingle & {
  result?: {
    /**
     * Monitored pool IDs mapped to their respective names.
     *
     * @example {"abwlnp5jbqn45ecgxd03erbgtxtqai0d":"WNAM Datacenter","ve8h9lrcip5n5bbga9yqmdws28ay5d0l":"EEU Datacenter"}
     */
    pools?: {
      [key: string]: string;
    };
    preview_id?: LoadBalancingIdentifier;
  };
};

/**
 * Resulting health data from a preview operation.
 *
 * @example {"abwlnp5jbqn45ecgxd03erbgtxtqai0d":{"healthy":true,"origins":[{"originone.example.com.":{"failure_reason":"No failures","healthy":true,"response_code":200,"rtt":"66ms"}}]}}
 */
export type LoadBalancingPreviewResult = {
  [key: string]: {
    /**
     * @x-auditable true
     */
    healthy?: boolean;
    origins?: {
      [key: string]: LoadBalancingOriginHealthData;
    }[];
  };
};

export type LoadBalancingPreviewResultResponse =
  LoadBalancingApiResponseSingle & {
    result?: LoadBalancingPreviewResult;
  };

/**
 * Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
 *
 * @example example.com
 * @x-auditable true
 */
export type LoadBalancingProbeZone = string;

/**
 * Whether the hostname should be gray clouded (false) or orange clouded (true).
 *
 * @default false
 * @example true
 * @x-auditable true
 */
export type LoadBalancingProxied = boolean;

/**
 * Configures pool weights.
 * - `steering_policy="random"`: A random pool is selected with probability proportional to pool weights.
 * - `steering_policy="least_outstanding_requests"`: Use pool weights to scale each pool's outstanding requests.
 * - `steering_policy="least_connections"`: Use pool weights to scale each pool's open connections.
 */
export type LoadBalancingRandomSteering = {
  /**
   * The default weight for pools in the load balancer that are not specified in the pool_weights map.
   *
   * @default 1
   * @example 0.2
   * @maximum 1
   * @minimum 0
   * @multipleOf 0.1
   * @x-auditable true
   */
  default_weight?: number;
  /**
   * A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
   *
   * @example {"9290f38c5d07c2e2f4df57b1f61d4196":0.5,"de90f38ced07c2e2f4df50b1f61d4194":0.3}
   */
  pool_weights?: {
    [key: string]: number;
  };
};

/**
 * A list of Cloudflare regions. WNAM: Western North America, ENAM: Eastern North America, WEU: Western Europe, EEU: Eastern Europe, NSAM: Northern South America, SSAM: Southern South America, OC: Oceania, ME: Middle East, NAF: North Africa, SAF: South Africa, SAS: Southern Asia, SEAS: South East Asia, NEAS: North East Asia).
 *
 * @example WNAM
 */
export type LoadBalancingRegionCode =
  | "WNAM"
  | "ENAM"
  | "WEU"
  | "EEU"
  | "NSAM"
  | "SSAM"
  | "OC"
  | "ME"
  | "NAF"
  | "SAF"
  | "SAS"
  | "SEAS"
  | "NEAS";

export type LoadBalancingRegionComponentsSchemasResponseCollection =
  LoadBalancingApiResponseSingle & {
    result?: Record<string, any>;
  };

/**
 * A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
 *
 * @example {"ENAM":["00920f38ce07c2e2f4df50b1f61d4194"],"WNAM":["de90f38ced07c2e2f4df50b1f61d4194","9290f38c5d07c2e2f4df57b1f61d4196"]}
 */
export type LoadBalancingRegionPools = {
  [key: string]: string[];
};

/**
 * A reference to a load balancer resource.
 */
export type LoadBalancingResourceReference = {
  /**
   * When listed as a reference, the type (direction) of the reference.
   *
   * @x-auditable true
   */
  reference_type?: "referral" | "referrer";
  /**
   * A list of references to (referrer) or from (referral) this resource.
   *
   * @example {"reference_type":"referrer","resource_id":"699d98642c564d2e855e9661899b7252","resource_name":"www.example.com","resource_type":"load_balancer"}
   * @example {"reference_type":"referral","resource_id":"f1aba936b94213e5b8dca0c0dbf1f9cc","resource_name":"Login page monitor","resource_type":"monitor"}
   */
  references?: Record<string, any>[];
  /**
   * @example 17b5962d775c646f3f9725cbc7a53df4
   */
  resource_id?: void;
  /**
   * The human-identifiable name of the resource.
   *
   * @example primary-dc-1
   * @x-auditable true
   */
  resource_name?: string;
  /**
   * The type of the resource.
   *
   * @example pool
   * @x-auditable true
   */
  resource_type?: "load_balancer" | "monitor" | "pool";
};

export type LoadBalancingResultInfo = {
  /**
   * Total number of results on the current page
   *
   * @example 20
   */
  count?: number;
  /**
   * Current page within paginated list of results
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters
   *
   * @example 2000
   */
  total_count?: number;
  /**
   * Total number of pages available
   *
   * @example 100
   */
  total_pages?: number;
};

/**
 * The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
 *
 * @default 2
 * @x-auditable true
 */
export type LoadBalancingRetries = number;

/**
 * BETA Field Not General Access: A list of rules for this load balancer to execute.
 */
export type LoadBalancingRules = {
  /**
   * The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
   *
   * @example http.request.uri.path contains "/testing"
   * @x-auditable true
   */
  condition?: string;
  /**
   * Disable this specific rule. It will no longer be evaluated by this load balancer.
   *
   * @default false
   * @x-auditable true
   */
  disabled?: boolean;
  /**
   * A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed_response is supplied the rule will be marked as terminates.
   */
  fixed_response?: {
    /**
     * The http 'Content-Type' header to include in the response.
     *
     * @example application/json
     * @maxLength 32
     * @x-auditable true
     */
    content_type?: string;
    /**
     * The http 'Location' header to include in the response.
     *
     * @example www.example.com
     * @maxLength 2048
     * @x-auditable true
     */
    location?: string;
    /**
     * Text to include as the http body.
     *
     * @example Testing Hello
     * @maxLength 1024
     * @x-auditable true
     */
    message_body?: string;
    /**
     * The http status code to respond with.
     *
     * @x-auditable true
     */
    status_code?: number;
  };
  /**
   * Name of this rule. Only used for human readability.
   *
   * @example route the path /testing to testing datacenter.
   * @maxLength 200
   * @x-auditable true
   */
  name?: string;
  /**
   * A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional.
   */
  overrides?: {
    adaptive_routing?: LoadBalancingAdaptiveRouting;
    country_pools?: LoadBalancingCountryPools;
    default_pools?: LoadBalancingDefaultPools;
    fallback_pool?: LoadBalancingFallbackPool;
    location_strategy?: LoadBalancingLocationStrategy;
    pop_pools?: LoadBalancingPopPools;
    random_steering?: LoadBalancingRandomSteering;
    region_pools?: LoadBalancingRegionPools;
    session_affinity?: LoadBalancingSessionAffinity;
    session_affinity_attributes?: LoadBalancingSessionAffinityAttributes;
    session_affinity_ttl?: LoadBalancingSessionAffinityTtl;
    steering_policy?: LoadBalancingSteeringPolicy;
    ttl?: LoadBalancingTtl;
  };
  /**
   * The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
   *
   * @default 0
   * @minimum 0
   * @x-auditable true
   */
  priority?: number;
  /**
   * If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
   *
   * @x-auditable true
   */
  terminates?: boolean;
}[];

/**
 * A human-readable description of the pool.
 *
 * @example Primary data center - Provider XYZ
 * @x-auditable true
 */
export type LoadBalancingSchemasDescription = string;

/**
 * This field shows up only if the pool is disabled. This field is set with the time the pool was disabled at.
 *
 * @format date-time
 * @x-auditable true
 */
export type LoadBalancingSchemasDisabledAt = string;

/**
 * Whether to enable (the default) this origin within the pool. Disabled origins will not receive traffic and are excluded from health checks. The origin will only be disabled for the current pool.
 *
 * @default true
 * @example true
 * @x-auditable true
 */
export type LoadBalancingSchemasEnabled = boolean;

/**
 * The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'.
 */
export type LoadBalancingSchemasHeader = {
  Host?: LoadBalancingHost;
};

export type LoadBalancingSchemasIdResponse = LoadBalancingApiResponseSingle & {
  result?: {
    id?: LoadBalancingSchemasIdentifier;
  };
};

/**
 * @example 17b5962d775c646f3f9725cbc7a53df4
 * @x-auditable true
 */
export type LoadBalancingSchemasIdentifier = string;

/**
 * A human-identifiable name for the origin.
 *
 * @example app-server-1
 * @x-auditable true
 */
export type LoadBalancingSchemasName = string;

/**
 * @example p1aba936b94213e5b8dca0c0dbf1f9cc
 */
export type LoadBalancingSchemasPreviewId = string;

export type LoadBalancingSchemasResponseCollection =
  LoadBalancingApiPaginatedResponseCollection & {
    result?: LoadBalancingPool[];
  };

export type LoadBalancingSchemasSingleResponse =
  LoadBalancingApiResponseSingle & {
    result?: LoadBalancingPool;
  };

export type LoadBalancingSearch = {
  /**
   * A list of resources matching the search query.
   */
  resources?: LoadBalancingResourceReference[];
};

export type LoadBalancingSearchResult = {
  result?: LoadBalancingSearch;
};

/**
 * Specifies the type of session affinity the load balancer should use unless specified as `"none"`. The supported types are:
 * - `"cookie"`: On the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy, then a new origin server is calculated and used.
 * - `"ip_cookie"`: Behaves the same as `"cookie"` except the initial origin selection is stable and based on the client's ip address.
 * - `"header"`: On the first request to a proxied load balancer, a session key based on the configured HTTP headers (see `session_affinity_attributes.headers`) is generated, encoding the request headers used for storing in the load balancer session state which origin the request will be forwarded to. Subsequent requests to the load balancer with the same headers will be sent to the same origin server, for the duration of the session and as long as the origin server remains healthy. If the session has been idle for the duration of `session_affinity_ttl` seconds or the origin server is unhealthy, then a new origin server is calculated and used. See `headers` in `session_affinity_attributes` for additional required configuration.
 *
 * @default none
 * @example cookie
 * @x-auditable true
 */
export type LoadBalancingSessionAffinity =
  | "none"
  | "cookie"
  | "ip_cookie"
  | "header";

/**
 * Configures attributes for session affinity.
 */
export type LoadBalancingSessionAffinityAttributes = {
  /**
   * Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
   *
   * @example 100
   * @x-auditable true
   */
  drain_duration?: number;
  /**
   * Configures the names of HTTP headers to base session affinity on when header `session_affinity` is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: `"cookie:<cookie-name-1>,<cookie-name-2>"` (example) where everything after the colon is a comma-separated list of cookie names. Providing only `"cookie"` will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.
   *
   * @default none
   * @uniqueItems true
   */
  headers?: string[];
  /**
   * When header `session_affinity` is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are:
   * - `"true"`: Load balancing requests must contain *all* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created.
   * - `"false"`: Load balancing requests must contain *at least one* of the HTTP headers specified by the `headers` session affinity attribute, otherwise sessions aren't created.
   *
   * @default false
   * @x-auditable true
   */
  require_all_headers?: boolean;
  /**
   * Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
   *
   * @default Auto
   * @example Auto
   * @x-auditable true
   */
  samesite?: "Auto" | "Lax" | "None" | "Strict";
  /**
   * Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
   *
   * @default Auto
   * @example Auto
   * @x-auditable true
   */
  secure?: "Auto" | "Always" | "Never";
  /**
   * Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are:
   * - `"none"`: No failover takes place for sessions pinned to the origin (default).
   * - `"temporary"`: Traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping.
   * - `"sticky"`: The session affinity cookie is updated and subsequent requests are sent to the new origin. Note: Zero-downtime failover with sticky sessions is currently not supported for session affinity by header.
   *
   * @default none
   * @example sticky
   * @x-auditable true
   */
  zero_downtime_failover?: "none" | "temporary" | "sticky";
};

/**
 * Time, in seconds, until a client's session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per `session_affinity` policy are:
 * - `"cookie"` / `"ip_cookie"`: The current default of 23 hours will be used unless explicitly set. The accepted range of values is between [1800, 604800].
 * - `"header"`: The current default of 1800 seconds will be used unless explicitly set. The accepted range of values is between [30, 3600]. Note: With session affinity by header, sessions only expire after they haven't been used for the number of seconds specified.
 *
 * @example 1800
 * @x-auditable true
 */
export type LoadBalancingSessionAffinityTtl = number;

/**
 * Steering Policy for this load balancer.
 * - `"off"`: Use `default_pools`.
 * - `"geo"`: Use `region_pools`/`country_pools`/`pop_pools`. For non-proxied requests, the country for `country_pools` is determined by `location_strategy`.
 * - `"random"`: Select a pool randomly.
 * - `"dynamic_latency"`: Use round trip time to select the closest pool in default_pools (requires pool health checks).
 * - `"proximity"`: Use the pools' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by `location_strategy` for non-proxied requests.
 * - `"least_outstanding_requests"`: Select a pool by taking into consideration `random_steering` weights, as well as each pool's number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others.
 * - `"least_connections"`: Select a pool by taking into consideration `random_steering` weights, as well as each pool's number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections.
 * - `""`: Will map to `"geo"` if you use `region_pools`/`country_pools`/`pop_pools` otherwise `"off"`.
 *
 * @default
 * @example dynamic_latency
 * @x-auditable true
 */
export type LoadBalancingSteeringPolicy =
  | "off"
  | "geo"
  | "random"
  | "dynamic_latency"
  | "proximity"
  | "least_outstanding_requests"
  | "least_connections"
  | "";

/**
 * Two-letter subdivision code followed in ISO 3166-2.
 *
 * @example CA
 * @x-auditable true
 */
export type LoadBalancingSubdivisionCodeA2 = string;

/**
 * The timeout (in seconds) before marking the health check as failed.
 *
 * @default 5
 * @x-auditable true
 */
export type LoadBalancingTimeout = number;

/**
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type LoadBalancingTimestamp = string;

/**
 * Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
 *
 * @example 30
 * @x-auditable true
 */
export type LoadBalancingTtl = number;

/**
 * The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
 *
 * @default http
 * @example https
 * @x-auditable true
 */
export type LoadBalancingType =
  | "http"
  | "https"
  | "tcp"
  | "udp_icmp"
  | "icmp_ping"
  | "smtp";

/**
 * End date and time of requesting data period in the ISO8601 format.
 *
 * @example 2016-11-11T13:00:00Z
 * @format date-time
 * @x-auditable true
 */
export type LoadBalancingUntil = string;

/**
 * The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
 *
 * @example a5624d4e-044a-4ff0-b3e1-e2465353d4b4
 */
export type LoadBalancingVirtualNetworkId = string;

/**
 * The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
 * - `origin_steering.policy="least_outstanding_requests"`: Use weight to scale the origin's outstanding requests.
 * - `origin_steering.policy="least_connections"`: Use weight to scale the origin's open connections.
 *
 * @default 1
 * @example 0.6
 * @maximum 1
 * @minimum 0
 * @multipleOf 0.01
 * @x-auditable true
 */
export type LoadBalancingWeight = number;

export type LogcontrolAccountIdentifier = LogcontrolIdentifier;

/**
 * Allow out of region access
 *
 * @example false
 */
export type LogcontrolAllowOutOfRegionAccess = boolean;

export type LogcontrolApiResponseCommon = {
  errors: LogcontrolMessages;
  messages: LogcontrolMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type LogcontrolApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: LogcontrolMessages;
  messages: LogcontrolMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type LogcontrolApiResponseSingle = LogcontrolApiResponseCommon;

export type LogcontrolCmbConfig = {
  allow_out_of_region_access?: LogcontrolAllowOutOfRegionAccess;
  regions?: LogcontrolRegions;
} | null;

export type LogcontrolCmbConfigResponseSingle = LogcontrolApiResponseSingle & {
  result?: LogcontrolCmbConfig;
};

/**
 * The log retention flag for Logpull API.
 *
 * @example true
 */
export type LogcontrolFlag = boolean;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type LogcontrolIdentifier = string;

export type LogcontrolMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * Name of the region.
 *
 * @example eu
 * @maxLength 256
 * @pattern ^[a-z]*$
 */
export type LogcontrolRegions = string;

export type LogcontrolRetentionFlag = {
  flag?: LogcontrolFlag;
} | null;

export type LogcontrolRetentionFlagResponseSingle =
  LogcontrolApiResponseSingle & {
    result?: LogcontrolRetentionFlag;
  };

export type LogcontrolZoneIdentifier = LogcontrolIdentifier;

export type LogpushApiResponseCommon = {
  errors: LogpushMessages;
  messages: LogpushMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type LogpushApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: LogpushMessages;
  messages: LogpushMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type LogpushApiResponseSingle = LogpushApiResponseCommon;

/**
 * Name of the dataset. A list of supported datasets can be found on the [Developer Docs](https://developers.cloudflare.com/logs/reference/log-fields/).
 *
 * @default http_requests
 * @example http_requests
 * @x-auditable true
 */
export type LogpushDataset =
  | "access_requests"
  | "audit_logs"
  | "biso_user_actions"
  | "casb_findings"
  | "device_posture_results"
  | "dlp_forensic_copies"
  | "dns_firewall_logs"
  | "dns_logs"
  | "email_security_alerts"
  | "firewall_events"
  | "gateway_dns"
  | "gateway_http"
  | "gateway_network"
  | "http_requests"
  | "magic_ids_detections"
  | "nel_reports"
  | "network_analytics_logs"
  | "page_shield_events"
  | "sinkhole_http_logs"
  | "spectrum_events"
  | "ssh_logs"
  | "workers_trace_events"
  | "zaraz_events"
  | "zero_trust_network_sessions"
  | null;

/**
 * Uniquely identifies a resource (such as an s3 bucket) where data will be pushed. Additional configuration parameters supported by the destination may be included.
 *
 * @example s3://mybucket/logs?region=us-west-2
 * @format uri
 * @maxLength 4096
 */
export type LogpushDestinationConf = string;

export type LogpushDestinationExistsResponse = LogpushApiResponseCommon & {
  result?: {
    /**
     * @example false
     * @x-auditable true
     */
    exists?: boolean;
  } | null;
};

/**
 * Flag that indicates if the job is enabled.
 *
 * @example false
 * @x-auditable true
 */
export type LogpushEnabled = boolean;

/**
 * If not null, the job is currently failing. Failures are usually repetitive (example: no permissions to write to destination bucket). Only the last failure is recorded. On successful execution of a job the error_message and last_error are set to null.
 *
 * @x-auditable true
 */
export type LogpushErrorMessage = string | null;

/**
 * Comma-separated list of fields.
 *
 * @example ClientIP,ClientRequestHost,ClientRequestMethod,ClientRequestURI,EdgeEndTimestamp,EdgeResponseBytes,EdgeResponseStatus,EdgeStartTimestamp,RayID
 * @x-auditable true
 */
export type LogpushFields = string;

/**
 * The filters to select the events to include and/or remove from your logs. For more information, refer to [Filters](https://developers.cloudflare.com/logs/reference/filters/).
 *
 * @example {"where":{"and":[{"key":"ClientRequestPath","operator":"contains","value":"/static"},{"key":"ClientRequestHost","operator":"eq","value":"example.com"}]}}
 */
export type LogpushFilter = string | null;

/**
 * This field is deprecated. Please use `max_upload_*` parameters instead. The frequency at which Cloudflare sends batches of logs to your destination. Setting frequency to high sends your logs in larger quantities of smaller files. Setting frequency to low sends logs in smaller quantities of larger files.
 *
 * @default high
 * @deprecated true
 * @example high
 * @x-auditable true
 */
export type LogpushFrequency = "high" | "low" | null;

export type LogpushGetOwnershipResponse = LogpushApiResponseCommon & {
  result?: {
    /**
     * @example logs/challenge-filename.txt
     * @x-auditable true
     */
    filename?: string;
    /**
     * @example
     * @x-auditable true
     */
    message?: string;
    /**
     * @example true
     * @x-auditable true
     */
    valid?: boolean;
  } | null;
};

/**
 * Unique id of the job.
 *
 * @minimum 1
 * @x-auditable true
 */
export type LogpushId = number;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type LogpushIdentifier = string;

export type LogpushInstantLogsJob = {
  destination_conf?: LogpushSchemasDestinationConf;
  fields?: LogpushFields;
  filter?: LogpushSchemasFilter;
  sample?: LogpushSample;
  session_id?: LogpushSessionId;
} | null;

export type LogpushInstantLogsJobResponseCollection =
  LogpushApiResponseCommon & {
    result?: LogpushInstantLogsJob[];
  };

export type LogpushInstantLogsJobResponseSingle = LogpushApiResponseSingle & {
  result?: LogpushInstantLogsJob;
};

/**
 * The kind parameter (optional) is used to differentiate between Logpush and Edge Log Delivery jobs (when supported by the dataset).
 *
 * @default
 * @example
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type LogpushKind = "" | "edge";

/**
 * Records the last time for which logs have been successfully pushed. If the last successful push was for logs range 2018-07-23T10:00:00Z to 2018-07-23T10:01:00Z then the value of this field will be 2018-07-23T10:01:00Z. If the job has never run or has just been enabled and hasn't run yet then the field will be empty.
 *
 * @format date-time
 * @x-auditable true
 */
export type LogpushLastComplete = string | null;

/**
 * Records the last time the job failed. If not null, the job is currently failing. If null, the job has either never failed or has run successfully at least once since last failure. See also the error_message field.
 *
 * @format date-time
 * @x-auditable true
 */
export type LogpushLastError = string | null;

/**
 * This field is deprecated. Use `output_options` instead. Configuration string. It specifies things like requested fields and timestamp formats. If migrating from the logpull api, copy the url (full url or just the query string) of your call here, and logpush will keep on making this call for you, setting start and end times appropriately.
 *
 * @deprecated true
 * @example fields=RayID,ClientIP,EdgeStartTimestamp&timestamps=rfc3339
 * @format uri-reference
 * @maxLength 4096
 * @x-auditable true
 */
export type LogpushLogpullOptions = string | null;

export type LogpushLogpushFieldResponseCollection = LogpushApiResponseCommon & {
  result?: Record<string, any>;
};

export type LogpushLogpushJob = {
  dataset?: LogpushDataset;
  destination_conf?: LogpushDestinationConf;
  enabled?: LogpushEnabled;
  error_message?: LogpushErrorMessage;
  frequency?: LogpushFrequency;
  id?: LogpushId;
  kind?: LogpushKind;
  last_complete?: LogpushLastComplete;
  last_error?: LogpushLastError;
  logpull_options?: LogpushLogpullOptions;
  max_upload_bytes?: LogpushMaxUploadBytes;
  max_upload_interval_seconds?: LogpushMaxUploadIntervalSeconds;
  max_upload_records?: LogpushMaxUploadRecords;
  name?: LogpushName;
  output_options?: LogpushOutputOptions;
} | null;

export type LogpushLogpushJobResponseCollection = LogpushApiResponseCommon & {
  result?: LogpushLogpushJob[];
};

export type LogpushLogpushJobResponseSingle = LogpushApiResponseSingle & {
  result?: LogpushLogpushJob;
};

/**
 * The maximum uncompressed file size of a batch of logs. This setting value must be between `5 MB` and `1 GB`, or `0` to disable it. Note that you cannot set a minimum file size; this means that log files may be much smaller than this batch size.
 *
 * @example 5000000
 * @x-auditable true
 */
export type LogpushMaxUploadBytes = 0 | number | null;

/**
 * The maximum interval in seconds for log batches. This setting must be between 30 and 300 seconds (5 minutes), or `0` to disable it. Note that you cannot specify a minimum interval for log batches; this means that log files may be sent in shorter intervals than this.
 *
 * @default 30
 * @example 30
 * @x-auditable true
 */
export type LogpushMaxUploadIntervalSeconds = 0 | number | null;

/**
 * The maximum number of log lines per batch. This setting must be between 1000 and 1,000,000 lines, or `0` to disable it. Note that you cannot specify a minimum number of log lines per batch; this means that log files may contain many fewer lines than this.
 *
 * @default 100000
 * @example 1000
 * @x-auditable true
 */
export type LogpushMaxUploadRecords = 0 | number | null;

export type LogpushMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * Optional human readable job name. Not unique. Cloudflare suggests that you set this to a meaningful string, like the domain name, to make it easier to identify your job.
 *
 * @example example.com
 * @maxLength 512
 * @pattern ^[a-zA-Z0-9\-\.]*$
 * @x-auditable true
 */
export type LogpushName = string | null;

/**
 * The structured replacement for `logpull_options`. When including this field, the `logpull_option` field will be ignored.
 */
export type LogpushOutputOptions = {
  /**
   * If set to true, will cause all occurrences of `${` in the generated files to be replaced with `x{`.
   *
   * @default false
   * @x-auditable true
   */
  ["CVE-2021-44228"]?: boolean | null;
  /**
   * String to be prepended before each batch.
   *
   * @x-auditable true
   */
  batch_prefix?: string | null;
  /**
   * String to be appended after each batch.
   *
   * @x-auditable true
   */
  batch_suffix?: string | null;
  /**
   * String to join fields. This field be ignored when `record_template` is set.
   *
   * @x-auditable true
   */
  field_delimiter?: string | null;
  /**
   * List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
   *
   * @example ClientIP
   * @example EdgeStartTimestamp
   * @example RayID
   */
  field_names?: string[];
  /**
   * Specifies the output type, such as `ndjson` or `csv`. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
   *
   * @default ndjson
   * @example ndjson
   * @x-auditable true
   */
  output_type?: "ndjson" | "csv";
  /**
   * String to be inserted in-between the records as separator.
   *
   * @x-auditable true
   */
  record_delimiter?: string | null;
  /**
   * String to be prepended before each record.
   *
   * @x-auditable true
   */
  record_prefix?: string | null;
  /**
   * String to be appended after each record.
   *
   * @x-auditable true
   */
  record_suffix?: string | null;
  /**
   * String to use as template for each record instead of the default json key value mapping. All fields used in the template must be present in `field_names` as well, otherwise they will end up as null. Format as a Go `text/template` without any standard functions, like conditionals, loops, sub-templates, etc.
   *
   * @x-auditable true
   */
  record_template?: string | null;
  /**
   * Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current `sample_interval` of the data.
   *
   * @default 1
   * @format float
   * @maximum 1
   * @minimum 0
   * @x-auditable true
   */
  sample_rate?: number | null;
  /**
   * String to specify the format for timestamps, such as `unixnano`, `unix`, or `rfc3339`.
   *
   * @default unixnano
   * @x-auditable true
   */
  timestamp_format?: "unixnano" | "unix" | "rfc3339";
} | null;

/**
 * Ownership challenge token to prove destination ownership.
 *
 * @example 00000000000000000000
 * @maxLength 4096
 * @pattern ^[a-zA-Z0-9/\+\.\-_]*$
 * @x-sensitive true
 */
export type LogpushOwnershipChallenge = string;

/**
 * The sample parameter is the sample rate of the records set by the client: "sample": 1 is 100% of records "sample": 10 is 10% and so on.
 *
 * @example 1
 * @x-auditable true
 */
export type LogpushSample = number;

/**
 * Unique WebSocket address that will receive messages from Cloudflare’s edge.
 *
 * @example wss://logs.cloudflare.com/instant-logs/ws/sessions/99d471b1ca3c23cc8e30b6acec5db987
 * @format uri
 * @maxLength 4096
 * @x-auditable true
 */
export type LogpushSchemasDestinationConf = string;

/**
 * Filters to drill down into specific events.
 *
 * @example {"where":{"and":[{"key":"ClientCountry","operator":"neq","value":"ca"}]}}
 * @x-auditable true
 */
export type LogpushSchemasFilter = string;

/**
 * Unique session id of the job.
 *
 * @example 99d471b1ca3c23cc8e30b6acec5db987
 * @x-auditable true
 */
export type LogpushSessionId = string;

export type LogpushValidateOwnershipResponse = LogpushApiResponseCommon & {
  result?: {
    /**
     * @example true
     * @x-auditable true
     */
    valid?: boolean;
  } | null;
};

export type LogpushValidateResponse = LogpushApiResponseCommon & {
  result?: {
    /**
     * @example
     * @x-auditable true
     */
    message?: string;
    /**
     * @example true
     * @x-auditable true
     */
    valid?: boolean;
  } | null;
};

export type LogshareApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: LogshareMessages;
  messages: LogshareMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

/**
 * When `?count=` is provided, the response will contain up to `count` results. Since results are not sorted, you are likely to get different data for repeated requests. `count` must be an integer > 0.
 *
 * @minimum 1
 * @x-auditable true
 */
export type LogshareCount = number;

/**
 * Sets the (exclusive) end of the requested time frame. This can be a unix timestamp (in seconds or nanoseconds), or an absolute timestamp that conforms to RFC 3339. `end` must be at least five minutes earlier than now and must be later than `start`. Difference between `start` and `end` must be not greater than one hour.
 *
 * @example 2018-05-20T10:01:00Z
 * @x-auditable true
 */
export type LogshareEnd = string | number;

/**
 * The `/received` route by default returns a limited set of fields, and allows customers to override the default field set by specifying individual fields. The reasons for this are: 1. Most customers require only a small subset of fields, but that subset varies from customer to customer; 2. Flat schema is much easier to work with downstream (importing into BigTable etc); 3. Performance (time to process, file size). If `?fields=` is not specified, default field set is returned. This default field set may change at any time. When `?fields=` is provided, each record is returned with the specified fields. `fields` must be specified as a comma separated list without any whitespaces, and all fields must exist. The order in which fields are specified does not matter, and the order of fields in the response is not specified.
 *
 * @example ClientIP,RayID,EdgeStartTimestamp
 * @x-auditable true
 */
export type LogshareFields = string;

export type LogshareFieldsResponse = {
  /**
   * @example value
   * @x-auditable true
   */
  key?: string;
};

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type LogshareIdentifier = string;

/**
 * @example {"ClientIP":"192.0.2.1","RayID":"41ddf1740f67442d","EdgeStartTimestamp":1526810289280000000}
{"ClientIP":"192.0.2.1","RayID":"41ddf1740f67442d","EdgeStartTimestamp":1526810289280000000}
{"ClientIP":"192.0.2.1","RayID":"41ddf1740f67442d","EdgeStartTimestamp":1526810289280000000}
 */
export type LogshareLogsResponseJsonLines = string | Record<string, any>;

export type LogshareMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * Ray identifier.
 *
 * @example 41ddf1740f67442d
 * @maxLength 16
 * @x-auditable true
 */
export type LogshareRayIdentifier = string;

/**
 * When `?sample=` is provided, a sample of matching records is returned. If `sample=0.1` then 10% of records will be returned. Sampling is random: repeated calls will not only return different records, but likely will also vary slightly in number of returned records. When `?count=` is also specified, `count` is applied to the number of returned records, not the sampled records. So, with `sample=0.05` and `count=7`, when there is a total of 100 records available, approximately five will be returned. When there are 1000 records, seven will be returned. When there are 10,000 records, seven will be returned.
 *
 * @example 0.1
 * @maximum 1
 * @minimum 0
 * @x-auditable true
 */
export type LogshareSample = number;

/**
 * Sets the (inclusive) beginning of the requested time frame. This can be a unix timestamp (in seconds or nanoseconds), or an absolute timestamp that conforms to RFC 3339. At this point in time, it cannot exceed a time in the past greater than seven days.
 *
 * @example 2018-05-20T10:00:00Z
 * @x-auditable true
 */
export type LogshareStart = string | number;

/**
 * By default, timestamps in responses are returned as Unix nanosecond integers. The `?timestamps=` argument can be set to change the format in which response timestamps are returned. Possible values are: `unix`, `unixnano`, `rfc3339`. Note that `unix` and `unixnano` return timestamps as integers; `rfc3339` returns timestamps as strings.
 *
 * @default unixnano
 * @example unixnano
 * @x-auditable true
 */
export type LogshareTimestamps = "unix" | "unixnano" | "rfc3339";

export type LogshareZoneIdentifier = LogshareIdentifier;

export type MagicTransitApiResponseCommon = {
  errors: MagicTransitMessages;
  messages: MagicTransitMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type MagicTransitApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: MagicTransitMessages;
  messages: MagicTransitMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

/**
 * AS number associated with the node object.
 */
export type MagicTransitAsn = string;

/**
 * type of check to perform
 *
 * @default icmp
 * @example icmp
 */
export type MagicTransitCheckType = "icmp";

export type MagicTransitColo = {
  city?: MagicTransitColoCity;
  name?: MagicTransitColoName;
};

/**
 * Source colo city.
 *
 * @example Denver, CO, US
 */
export type MagicTransitColoCity = string;

/**
 * Source colo name.
 *
 * @example den01
 */
export type MagicTransitColoName = string;

export type MagicTransitColoResult = {
  colo?: MagicTransitColo;
  error?: MagicTransitError;
  hops?: MagicTransitHopResult[];
  target_summary?: MagicTransitTargetSummary;
  traceroute_time_ms?: MagicTransitTracerouteTimeMs;
};

/**
 * If no source colo names specified, all colos will be used. China colos are unavailable for traceroutes.
 *
 * @example den
 * @example sin
 */
export type MagicTransitColos = string[];

export type MagicTransitEndpointHealthCheck = {
  check_type: MagicTransitCheckType;
  /**
   * the IP address of the host to perform checks against
   *
   * @example 203.0.113.1
   */
  endpoint: string;
  /**
   * Optional name associated with this check
   *
   * @example My Endpoint
   */
  name?: string;
};

export type MagicTransitEndpointHealthCheckResponse =
  MagicTransitEndpointHealthCheck & {
    id?: MagicTransitUuid;
  };

export type MagicTransitEndpointHealthCheckResponseCollection =
  MagicTransitApiResponseCommon & {
    result?: MagicTransitEndpointHealthCheckResponse[];
  };

export type MagicTransitEndpointHealthCheckResponseSingle =
  MagicTransitApiResponseCommon & {
    result?: MagicTransitEndpointHealthCheckResponse;
  };

/**
 * Errors resulting from collecting traceroute from colo to target.
 *
 * @example
 */
export type MagicTransitError =
  | ""
  | "Could not gather traceroute data: Code 1"
  | "Could not gather traceroute data: Code 2"
  | "Could not gather traceroute data: Code 3"
  | "Could not gather traceroute data: Code 4";

export type MagicTransitHopResult = {
  /**
   * An array of node objects.
   */
  nodes?: MagicTransitNodeResult[];
  packets_lost?: MagicTransitPacketsLost;
  packets_sent?: MagicTransitPacketsSent;
  packets_ttl?: MagicTransitPacketsTtl;
};

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type MagicTransitIdentifier = string;

/**
 * IP address of the node.
 */
export type MagicTransitIp = string;

/**
 * Field appears if there is an additional annotation printed when the probe returns. Field also appears when running a GRE+ICMP traceroute to denote which traceroute a node comes from.
 */
export type MagicTransitLabels = string[];

/**
 * Maximum RTT in ms.
 */
export type MagicTransitMaxRttMs = number;

/**
 * Max TTL.
 *
 * @default 15
 * @maximum 64
 * @minimum 0
 */
export type MagicTransitMaxTtl = number;

/**
 * Mean RTT in ms.
 */
export type MagicTransitMeanRttMs = number;

export type MagicTransitMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * Minimum RTT in ms.
 */
export type MagicTransitMinRttMs = number;

/**
 * Host name of the address, this may be the same as the IP address.
 */
export type MagicTransitName = string;

/**
 * @example {"asn":"AS13335","ip":"1.1.1.1","max_latency_ms":0.034,"mean_latency_ms":0.021,"min_latency_ms":0.014,"name":"one.one.one.one","packet_count":3,"std_dev_latency_ms":0.011269427669584647}
 */
export type MagicTransitNodeResult = {
  asn?: MagicTransitAsn;
  ip?: MagicTransitIp;
  labels?: MagicTransitLabels;
  max_rtt_ms?: MagicTransitMaxRttMs;
  mean_rtt_ms?: MagicTransitMeanRttMs;
  min_rtt_ms?: MagicTransitMinRttMs;
  name?: MagicTransitName;
  packet_count?: MagicTransitPacketCount;
  std_dev_rtt_ms?: MagicTransitStdDevRttMs;
};

/**
 * @example {"max_ttl":15,"packet_type":"icmp"}
 */
export type MagicTransitOptions = {
  max_ttl?: MagicTransitMaxTtl;
  packet_type?: MagicTransitPacketType;
  packets_per_ttl?: MagicTransitPacketsPerTtl;
  port?: MagicTransitPort;
  wait_time?: MagicTransitWaitTime;
};

/**
 * Number of packets with a response from this node.
 */
export type MagicTransitPacketCount = number;

/**
 * Type of packet sent.
 *
 * @default icmp
 * @example icmp
 */
export type MagicTransitPacketType =
  | "icmp"
  | "tcp"
  | "udp"
  | "gre"
  | "gre+icmp";

/**
 * Number of packets where no response was received.
 */
export type MagicTransitPacketsLost = number;

/**
 * Number of packets sent at each TTL.
 *
 * @default 3
 * @maximum 10
 * @minimum 0
 */
export type MagicTransitPacketsPerTtl = number;

/**
 * Number of packets sent with specified TTL.
 */
export type MagicTransitPacketsSent = number;

/**
 * The time to live (TTL).
 */
export type MagicTransitPacketsTtl = number;

/**
 * For UDP and TCP, specifies the destination port. For ICMP, specifies the initial ICMP sequence value. Default value 0 will choose the best value to use for each protocol.
 *
 * @default 0
 * @maximum 65535
 * @minimum 0
 */
export type MagicTransitPort = number;

/**
 * Standard deviation of the RTTs in ms.
 */
export type MagicTransitStdDevRttMs = number;

/**
 * The target hostname, IPv6, or IPv6 address.
 *
 * @example 1.1.1.1
 */
export type MagicTransitTarget = string;

export type MagicTransitTargetResult = {
  colos?: MagicTransitColoResult[];
  target?: MagicTransitTarget;
};

/**
 * Aggregated statistics from all hops about the target.
 *
 * @example {"asn":"","ip":"1.1.1.1","max_latency_ms":0.034,"mean_latency_ms":0.021,"min_latency_ms":0.014,"name":"1.1.1.1","packet_count":3,"std_dev_latency_ms":0.011269427669584647}
 */
export type MagicTransitTargetSummary = Record<string, any>;

/**
 * @example 203.0.113.1
 * @example cloudflare.com
 * @maxLength 10
 */
export type MagicTransitTargets = string[];

export type MagicTransitTracerouteResponseCollection =
  MagicTransitApiResponseCommon & {
    result?: MagicTransitTargetResult[];
  };

/**
 * Total time of traceroute in ms.
 */
export type MagicTransitTracerouteTimeMs = number;

/**
 * UUID.
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 */
export type MagicTransitUuid = string;

/**
 * Set the time (in seconds) to wait for a response to a probe.
 *
 * @default 1
 * @maximum 5
 * @minimum 1
 */
export type MagicTransitWaitTime = number;

/**
 * @example 6f91088a406011ed95aed352566e8d4c
 * @x-auditable true
 */
export type MagicVisibilityMnmAccountIdentifier = string;

export type MagicVisibilityMnmApiResponseCollection = {
  errors: MagicVisibilityMnmMessages;
  messages: MagicVisibilityMnmMessages;
  result: Record<string, any> | any[] | string | null;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
  result_info?: MagicVisibilityMnmResultInfo;
};

export type MagicVisibilityMnmApiResponseCommon = {
  errors: MagicVisibilityMnmMessages;
  messages: MagicVisibilityMnmMessages;
  result: Record<string, any> | any[] | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type MagicVisibilityMnmApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: MagicVisibilityMnmMessages;
  messages: MagicVisibilityMnmMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

export type MagicVisibilityMnmApiResponseSingle = {
  errors: MagicVisibilityMnmMessages;
  messages: MagicVisibilityMnmMessages;
  result: (Record<string, any> | null) | (string | null) | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type MagicVisibilityMnmMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

export type MagicVisibilityMnmMnmConfig = {
  default_sampling: MagicVisibilityMnmMnmConfigDefaultSampling;
  name: MagicVisibilityMnmMnmConfigName;
  router_ips: MagicVisibilityMnmMnmConfigRouterIps;
  warp_devices: MagicVisibilityMnmMnmConfigWarpDevices;
};

/**
 * Fallback sampling rate of flow messages being sent in packets per second. This should match the packet sampling rate configured on the router.
 *
 * @default 1
 * @minimum 1
 * @x-auditable true
 */
export type MagicVisibilityMnmMnmConfigDefaultSampling = number;

/**
 * The account name.
 *
 * @example cloudflare user's account
 * @x-auditable true
 */
export type MagicVisibilityMnmMnmConfigName = string;

/**
 * IPv4 CIDR of the router sourcing flow data. Only /32 addresses are currently supported.
 *
 * @example 203.0.113.1
 * @x-auditable true
 */
export type MagicVisibilityMnmMnmConfigRouterIp = string;

export type MagicVisibilityMnmMnmConfigRouterIps =
  MagicVisibilityMnmMnmConfigRouterIp[];

export type MagicVisibilityMnmMnmConfigSingleResponse =
  MagicVisibilityMnmApiResponseSingle & {
    result?: MagicVisibilityMnmMnmConfig;
  };

/**
 * Object representing a warp device with an ID and name.
 */
export type MagicVisibilityMnmMnmConfigWarpDevice = {
  /**
   * Unique identifier for the warp device.
   *
   * @example 5360368d-b351-4791-abe1-93550dabd351
   * @x-auditable true
   */
  id: string;
  /**
   * Name of the warp device.
   *
   * @example My warp device
   * @x-auditable true
   */
  name: string;
  /**
   * IPv4 CIDR of the router sourcing flow data associated with this warp device. Only /32 addresses are currently supported.
   *
   * @example 203.0.113.1
   * @x-auditable true
   */
  router_ip: string;
};

export type MagicVisibilityMnmMnmConfigWarpDevices =
  MagicVisibilityMnmMnmConfigWarpDevice[];

export type MagicVisibilityMnmMnmRule = {
  automatic_advertisement: MagicVisibilityMnmMnmRuleAutomaticAdvertisement;
  bandwidth_threshold?: MagicVisibilityMnmMnmRuleBandwidthThreshold;
  duration?: MagicVisibilityMnmMnmRuleDuration;
  id?: MagicVisibilityMnmRuleIdentifier;
  name: MagicVisibilityMnmMnmRuleName;
  packet_threshold?: MagicVisibilityMnmMnmRulePacketThreshold;
  prefix_match?: MagicVisibilityMnmMnmRulePrefixMatch;
  prefixes: MagicVisibilityMnmMnmRuleIpPrefixes;
  type: MagicVisibilityMnmMnmRuleType;
  zscore_sensitivity?: MagicVisibilityMnmMnmRuleZscoreSensitivity;
  zscore_target?: MagicVisibilityMnmMnmRuleZscoreTarget;
} | null;

export type MagicVisibilityMnmMnmRuleAdvertisableResponse = {
  automatic_advertisement: MagicVisibilityMnmMnmRuleAutomaticAdvertisement;
} | null;

export type MagicVisibilityMnmMnmRuleAdvertisementSingleResponse =
  MagicVisibilityMnmApiResponseSingle & {
    result?: MagicVisibilityMnmMnmRuleAdvertisableResponse;
  };

/**
 * Toggle on if you would like Cloudflare to automatically advertise the IP Prefixes within the rule via Magic Transit when the rule is triggered. Only available for users of Magic Transit.
 *
 * @example false
 * @x-auditable true
 */
export type MagicVisibilityMnmMnmRuleAutomaticAdvertisement = boolean | null;

/**
 * The number of bits per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum.
 *
 * @example 1000
 * @minimum 1
 * @x-auditable true
 */
export type MagicVisibilityMnmMnmRuleBandwidthThreshold = number;

/**
 * The amount of time that the rule threshold must be exceeded to send an alert notification. The final value must be equivalent to one of the following 8 values ["1m","5m","10m","15m","20m","30m","45m","60m"].
 *
 * @default 1m
 * @example 300s
 * @x-auditable true
 */
export type MagicVisibilityMnmMnmRuleDuration =
  | "1m"
  | "5m"
  | "10m"
  | "15m"
  | "20m"
  | "30m"
  | "45m"
  | "60m";

/**
 * The IP prefixes that are monitored for this rule. Must be a CIDR range like 203.0.113.0/24. Max 5000 different CIDR ranges.
 *
 * @example 203.0.113.1/32
 * @x-auditable true
 */
export type MagicVisibilityMnmMnmRuleIpPrefix = string;

export type MagicVisibilityMnmMnmRuleIpPrefixes =
  MagicVisibilityMnmMnmRuleIpPrefix[];

/**
 * The name of the rule. Must be unique. Supports characters A-Z, a-z, 0-9, underscore (_), dash (-), period (.), and tilde (~). You can’t have a space in the rule name. Max 256 characters.
 *
 * @example my_rule_1
 * @x-auditable true
 */
export type MagicVisibilityMnmMnmRuleName = string;

/**
 * The number of packets per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum.
 *
 * @example 10000
 * @minimum 1
 * @x-auditable true
 */
export type MagicVisibilityMnmMnmRulePacketThreshold = number;

/**
 * Prefix match type to be applied for a prefix auto advertisement when using an advanced_ddos rule.
 *
 * @example exact
 * @x-auditable true
 */
export type MagicVisibilityMnmMnmRulePrefixMatch =
  | "exact"
  | "subnet"
  | "supernet"
  | null;

/**
 * MNM rule type.
 *
 * @example zscore
 * @x-auditable true
 */
export type MagicVisibilityMnmMnmRuleType =
  | "threshold"
  | "zscore"
  | "advanced_ddos";

/**
 * Level of sensitivity set for zscore rules.
 *
 * @example high
 * @x-auditable true
 */
export type MagicVisibilityMnmMnmRuleZscoreSensitivity =
  | "low"
  | "medium"
  | "high"
  | null;

/**
 * Target of the zscore rule analysis.
 *
 * @example bits
 * @x-auditable true
 */
export type MagicVisibilityMnmMnmRuleZscoreTarget = "bits" | "packets" | null;

export type MagicVisibilityMnmMnmRulesCollectionResponse =
  MagicVisibilityMnmApiResponseCollection & {
    result?: MagicVisibilityMnmMnmRule[] | null;
  };

export type MagicVisibilityMnmMnmRulesSingleResponse =
  MagicVisibilityMnmApiResponseSingle & {
    result?: MagicVisibilityMnmMnmRule;
  };

export type MagicVisibilityMnmMnmVpcFlowsSingleResponse =
  MagicVisibilityMnmApiResponseSingle & {
    result?: MagicVisibilityMnmMnmVpcFlowsToken;
  };

/**
 * Authentication token to be used for VPC Flows export authentication.
 *
 * @example JWE/JWT auth token
 * @x-sensitive true
 */
export type MagicVisibilityMnmMnmVpcFlowsToken = string;

export type MagicVisibilityMnmResultInfo = {
  /**
   * Total number of results for the requested service
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters
   *
   * @example 2000
   */
  total_count?: number;
};

/**
 * The id of the rule. Must be unique.
 *
 * @example 2890e6fa406311ed9b5a23f70f6fb8cf
 * @x-auditable true
 */
export type MagicVisibilityMnmRuleIdentifier = string;

export type MagicVisibilityPcapsApiResponseCollection = {
  errors: MagicVisibilityPcapsMessages;
  messages: MagicVisibilityPcapsMessages;
  result: Record<string, any> | any[] | string | null;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
  result_info?: MagicVisibilityPcapsResultInfo;
};

export type MagicVisibilityPcapsApiResponseCommon = {
  errors: MagicVisibilityPcapsMessages;
  messages: MagicVisibilityPcapsMessages;
  result: Record<string, any> | any[] | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type MagicVisibilityPcapsApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: MagicVisibilityPcapsMessages;
  messages: MagicVisibilityPcapsMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

export type MagicVisibilityPcapsApiResponseSingle = {
  errors: MagicVisibilityPcapsMessages;
  messages: MagicVisibilityPcapsMessages;
  result: Record<string, any> | string | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type MagicVisibilityPcapsIdentifier = string;

export type MagicVisibilityPcapsMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * The maximum number of bytes to capture. This field only applies to `full` packet captures.
 *
 * @example 500000
 * @maximum 1000000000
 * @minimum 1
 * @x-auditable true
 */
export type MagicVisibilityPcapsPcapsByteLimit = number;

export type MagicVisibilityPcapsPcapsCollectionResponse =
  MagicVisibilityPcapsApiResponseCollection & {
    result?: (
      | MagicVisibilityPcapsPcapsResponseSimple
      | MagicVisibilityPcapsPcapsResponseFull
    )[];
  };

/**
 * The name of the data center used for the packet capture. This can be a specific colo (ord02) or a multi-colo name (ORD). This field only applies to `full` packet captures.
 *
 * @example ord02
 * @x-auditable true
 */
export type MagicVisibilityPcapsPcapsColoName = string;

/**
 * The full URI for the bucket. This field only applies to `full` packet captures.
 *
 * @example s3://pcaps-bucket?region=us-east-1
 */
export type MagicVisibilityPcapsPcapsDestinationConf = string;

/**
 * An error message that describes why the packet capture failed. This field only applies to `full` packet captures.
 *
 * @example No packets matched the filter in the time limit given. Please modify the filter or try again.
 */
export type MagicVisibilityPcapsPcapsErrorMessage = string;

/**
 * The packet capture filter. When this field is empty, all packets are captured.
 */
export type MagicVisibilityPcapsPcapsFilterV1 = {
  /**
   * The destination IP address of the packet.
   *
   * @example 1.2.3.4
   * @x-auditable true
   */
  destination_address?: string;
  /**
   * The destination port of the packet.
   *
   * @example 80
   * @x-auditable true
   */
  destination_port?: number;
  /**
   * The protocol number of the packet.
   *
   * @example 6
   * @x-auditable true
   */
  protocol?: number;
  /**
   * The source IP address of the packet.
   *
   * @example 1.2.3.4
   * @x-auditable true
   */
  source_address?: string;
  /**
   * The source port of the packet.
   *
   * @example 123
   * @x-auditable true
   */
  source_port?: number;
};

/**
 * The ID for the packet capture.
 *
 * @example 66802ca5668e47a2b82c2e6746e45037
 * @maxLength 32
 * @minLength 32
 * @x-auditable true
 */
export type MagicVisibilityPcapsPcapsId = string;

/**
 * The RFC 3339 offset timestamp from which to query backwards for packets. Must be within the last 24h. When this field is empty, defaults to time of request.
 *
 * @example 2020-01-01T08:00:00Z
 * @format date-time
 * @x-auditable true
 */
export type MagicVisibilityPcapsPcapsOffsetTime = string;

/**
 * The ownership challenge filename stored in the bucket.
 *
 * @example ownership-challenge-9883874ecac311ec8475433579a6bf5f.txt
 */
export type MagicVisibilityPcapsPcapsOwnershipChallenge = string;

export type MagicVisibilityPcapsPcapsOwnershipCollection =
  MagicVisibilityPcapsApiResponseCollection & {
    result?: MagicVisibilityPcapsPcapsOwnershipResponse[] | null;
  };

export type MagicVisibilityPcapsPcapsOwnershipRequest = {
  destination_conf: MagicVisibilityPcapsPcapsDestinationConf;
};

export type MagicVisibilityPcapsPcapsOwnershipResponse = {
  destination_conf: MagicVisibilityPcapsPcapsDestinationConf;
  filename: MagicVisibilityPcapsPcapsOwnershipChallenge;
  /**
   * The bucket ID associated with the packet captures API.
   *
   * @example 9883874ecac311ec8475433579a6bf5f
   * @maxLength 32
   * @minLength 32
   */
  id: string;
  /**
   * The status of the ownership challenge. Can be pending, success or failed.
   *
   * @example success
   */
  status: "pending" | "success" | "failed";
  /**
   * The RFC 3339 timestamp when the bucket was added to packet captures API.
   *
   * @example 2020-01-01T08:00:00Z
   */
  submitted: string;
  /**
   * The RFC 3339 timestamp when the bucket was validated.
   *
   * @example 2020-01-01T08:00:00Z
   */
  validated?: string;
};

export type MagicVisibilityPcapsPcapsOwnershipSingleResponse = {
  errors: MagicVisibilityPcapsMessages;
  messages: MagicVisibilityPcapsMessages;
  result: MagicVisibilityPcapsPcapsOwnershipResponse;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type MagicVisibilityPcapsPcapsOwnershipValidateRequest = {
  destination_conf: MagicVisibilityPcapsPcapsDestinationConf;
  ownership_challenge: MagicVisibilityPcapsPcapsOwnershipChallenge;
};

/**
 * The limit of packets contained in a packet capture.
 *
 * @example 10000
 * @maximum 10000
 * @minimum 1
 * @x-auditable true
 */
export type MagicVisibilityPcapsPcapsPacketLimit = number;

/**
 * The number of packets captured.
 */
export type MagicVisibilityPcapsPcapsPacketsCaptured = number;

export type MagicVisibilityPcapsPcapsRequestFull = {
  byte_limit?: MagicVisibilityPcapsPcapsByteLimit;
  colo_name: MagicVisibilityPcapsPcapsColoName;
  destination_conf: MagicVisibilityPcapsPcapsDestinationConf;
  filter_v1?: MagicVisibilityPcapsPcapsFilterV1;
  packet_limit?: MagicVisibilityPcapsPcapsPacketLimit;
  system: MagicVisibilityPcapsPcapsSystem;
  time_limit: MagicVisibilityPcapsPcapsTimeLimitFull;
  type: MagicVisibilityPcapsPcapsType;
};

export type MagicVisibilityPcapsPcapsRequestPcap =
  | MagicVisibilityPcapsPcapsRequestSimple
  | MagicVisibilityPcapsPcapsRequestFull;

export type MagicVisibilityPcapsPcapsRequestSimple = {
  filter_v1?: MagicVisibilityPcapsPcapsFilterV1;
  offset_time?: MagicVisibilityPcapsPcapsOffsetTime;
  packet_limit: MagicVisibilityPcapsPcapsPacketLimit;
  system: MagicVisibilityPcapsPcapsSystem;
  time_limit: MagicVisibilityPcapsPcapsTimeLimitSampled;
  type: MagicVisibilityPcapsPcapsType;
};

export type MagicVisibilityPcapsPcapsResponseFull = {
  byte_limit?: MagicVisibilityPcapsPcapsByteLimit;
  colo_name?: MagicVisibilityPcapsPcapsColoName;
  destination_conf?: MagicVisibilityPcapsPcapsDestinationConf;
  error_message?: MagicVisibilityPcapsPcapsErrorMessage;
  filter_v1?: MagicVisibilityPcapsPcapsFilterV1;
  id?: MagicVisibilityPcapsPcapsId;
  packets_captured?: MagicVisibilityPcapsPcapsPacketsCaptured;
  status?: MagicVisibilityPcapsPcapsStatus;
  stop_requested?: MagicVisibilityPcapsPcapsStopRequested;
  submitted?: MagicVisibilityPcapsPcapsSubmitted;
  system?: MagicVisibilityPcapsPcapsSystem;
  time_limit?: MagicVisibilityPcapsPcapsTimeLimitFull;
  type?: MagicVisibilityPcapsPcapsType;
};

export type MagicVisibilityPcapsPcapsResponseSimple = {
  filter_v1?: MagicVisibilityPcapsPcapsFilterV1;
  id?: MagicVisibilityPcapsPcapsId;
  offset_time?: MagicVisibilityPcapsPcapsOffsetTime;
  status?: MagicVisibilityPcapsPcapsStatus;
  submitted?: MagicVisibilityPcapsPcapsSubmitted;
  system?: MagicVisibilityPcapsPcapsSystem;
  time_limit?: MagicVisibilityPcapsPcapsTimeLimitSampled;
  type?: MagicVisibilityPcapsPcapsType;
};

export type MagicVisibilityPcapsPcapsSingleResponse =
  MagicVisibilityPcapsApiResponseSingle & {
    result?:
      | MagicVisibilityPcapsPcapsResponseSimple
      | MagicVisibilityPcapsPcapsResponseFull;
  };

/**
 * The status of the packet capture request.
 *
 * @example success
 */
export type MagicVisibilityPcapsPcapsStatus =
  | "unknown"
  | "success"
  | "pending"
  | "running"
  | "conversion_pending"
  | "conversion_running"
  | "complete"
  | "failed";

/**
 * The RFC 3339 timestamp when stopping the packet capture was requested. This field only applies to `full` packet captures.
 *
 * @format date-time
 */
export type MagicVisibilityPcapsPcapsStopRequested = string;

/**
 * The RFC 3339 timestamp when the packet capture was created.
 *
 * @example 2020-01-01T08:00:00Z
 */
export type MagicVisibilityPcapsPcapsSubmitted = string;

/**
 * The system used to collect packet captures.
 *
 * @example magic-transit
 * @x-auditable true
 */
export type MagicVisibilityPcapsPcapsSystem = "magic-transit";

/**
 * The packet capture duration in seconds.
 *
 * @example 86400
 * @maximum 86400
 * @minimum 1
 * @x-auditable true
 */
export type MagicVisibilityPcapsPcapsTimeLimitFull = number;

/**
 * The packet capture duration in seconds.
 *
 * @example 300
 * @maximum 300
 * @minimum 1
 * @x-auditable true
 */
export type MagicVisibilityPcapsPcapsTimeLimitSampled = number;

/**
 * The type of packet capture. `Simple` captures sampled packets, and `full` captures entire payloads and non-sampled packets.
 *
 * @example simple
 * @x-auditable true
 */
export type MagicVisibilityPcapsPcapsType = "simple" | "full";

export type MagicVisibilityPcapsResultInfo = {
  /**
   * Total number of results for the requested service
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters
   *
   * @example 2000
   */
  total_count?: number;
};

/**
 * Custom app defined for an account.
 */
export type MagicAccountApp = {
  account_app_id: MagicAccountAppId;
  hostnames?: MagicAppHostnames;
  ip_subnets?: MagicAppSubnets;
  name?: MagicAppName;
  type?: MagicAppType;
};

/**
 * Magic account app ID.
 *
 * @example ac60d3d0435248289d446cedd870bcf4
 */
export type MagicAccountAppId = string;

/**
 * Bidirectional ACL policy for network traffic within a site.
 */
export type MagicAcl = {
  /**
   * Description for the ACL.
   *
   * @example Allows local traffic between PIN pads and cash register.
   */
  description?: string;
  forward_locally?: MagicForwardLocally;
  id?: MagicIdentifier;
  lan_1?: MagicLanAclConfiguration;
  lan_2?: MagicLanAclConfiguration;
  /**
   * The name of the ACL.
   *
   * @example PIN Pad - Cash Register
   */
  name?: string;
  protocols?: ("tcp" | "udp" | "icmp")[];
  unidirectional?: MagicUnidirectional;
};

/**
 * A valid port range value.
 *
 * @example 8080-9000
 */
export type MagicAclPortRange = string;

export type MagicAclSubnet = MagicIpAddress | MagicCidr;

export type MagicAclDeletedResponse = MagicApiResponseSingle & {
  result?: MagicAcl;
};

export type MagicAclModifiedResponse = MagicApiResponseSingle & {
  result?: MagicAcl;
};

export type MagicAclSingleResponse = MagicApiResponseSingle & {
  result?: MagicAcl;
};

export type MagicAclUpdateRequest = {
  /**
   * Description for the ACL.
   *
   * @example Allows local traffic between PIN pads and cash register.
   */
  description?: string;
  forward_locally?: MagicForwardLocally;
  lan_1?: MagicLanAclConfiguration;
  lan_2?: MagicLanAclConfiguration;
  /**
   * The name of the ACL.
   *
   * @example PIN Pad - Cash Register
   */
  name?: string;
  protocols?: ("tcp" | "udp" | "icmp")[];
  unidirectional?: MagicUnidirectional;
};

/**
 * Bidirectional ACL policy for local network traffic within a site.
 */
export type MagicAclsAddSingleRequest = {
  /**
   * Description for the ACL.
   *
   * @example Allows local traffic between PIN pads and cash register.
   */
  description?: string;
  forward_locally?: MagicForwardLocally;
  lan_1: MagicLanAclConfiguration;
  lan_2: MagicLanAclConfiguration;
  /**
   * The name of the ACL.
   *
   * @example PIN Pad - Cash Register
   */
  name: string;
  protocols?: ("tcp" | "udp" | "icmp")[];
  unidirectional?: MagicUnidirectional;
};

export type MagicAclsCollectionResponse = MagicApiResponseSingle & {
  result?: MagicAcl[];
};

/**
 * When `true`, the tunnel can use a null-cipher (`ENCR_NULL`) in the ESP tunnel (Phase 2).
 *
 * @example true
 */
export type MagicAllowNullCipher = boolean;

export type MagicApiResponseCommon = {
  errors: MagicMessages;
  messages: MagicMessages;
  result: Record<string, any> | any[] | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type MagicApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: MagicMessages;
  messages: MagicMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

export type MagicApiResponseSingle = {
  errors: MagicMessages;
  messages: MagicMessages;
  result: (Record<string, any> | null) | (string | null) | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

/**
 * Collection of Hostnames and/or IP Subnets to associate with traffic decisions.
 */
export type MagicApp = MagicAccountApp | MagicManagedApp;

export type MagicAppAddSingleRequest =
  | {
      hostnames: MagicAppHostnames;
      ip_subnets?: MagicAppSubnets;
      name?: MagicAppName;
      type?: MagicAppType;
    }
  | {
      hostnames?: MagicAppHostnames;
      ip_subnets: MagicAppSubnets;
      name?: MagicAppName;
      type?: MagicAppType;
    };

/**
 * Whether to breakout traffic to the app's endpoints directly. Null preserves default behavior.
 *
 * @example true
 */
export type MagicAppBreakout = boolean;

/**
 * Traffic decision configuration for an app.
 */
export type MagicAppConfig =
  | {
      account_app_id: MagicAccountAppId;
    }
  | {
      managed_app_id: MagicManagedAppId;
    };

export type MagicAppConfigAddSingleRequest =
  | (
      | {
          account_app_id?: MagicAccountAppId;
        }
      | {
          account_app_id?: MagicAccountAppId;
        }
    )
  | (
      | {
          managed_app_id?: MagicManagedAppId;
        }
      | {
          managed_app_id?: MagicManagedAppId;
        }
    );

export type MagicAppConfigSingleResponse = {
  errors: MagicMessages;
  messages: MagicMessages;
  result: MagicAppConfig;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type MagicAppConfigUpdateRequest = {
  account_app_id?: MagicAccountAppId;
  breakout?: MagicAppBreakout;
  managed_app_id?: MagicManagedAppId;
  priority?: MagicAppPriority;
};

export type MagicAppConfigsCollectionResponse = {
  errors: MagicMessages;
  messages: MagicMessages;
  result: never;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

/**
 * FQDNs to associate with traffic decisions.
 */
export type MagicAppHostnames = string[];

/**
 * Display name for the app.
 *
 * @example Cloudflare Dashboard
 */
export type MagicAppName = string;

/**
 * Priority of traffic. 0 is default, anything greater is prioritized. (Currently only 0 and 1 are supported)
 *
 * @maximum 1
 * @minimum 0
 */
export type MagicAppPriority = number;

export type MagicAppSingleResponse = {
  errors: MagicMessages;
  messages: MagicMessages;
  result: MagicAccountApp;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

/**
 * IPv4 CIDRs to associate with traffic decisions. (IPv6 CIDRs are currently unsupported)
 */
export type MagicAppSubnets = (MagicCidr & void)[];

/**
 * Category of the app.
 *
 * @example Development
 */
export type MagicAppType = string;

export type MagicAppUpdateRequest =
  | {
      hostnames?: MagicAppHostnames;
      ip_subnets?: MagicAppSubnets;
      name: MagicAppName;
      type?: MagicAppType;
    }
  | {
      hostnames?: MagicAppHostnames;
      ip_subnets?: MagicAppSubnets;
      name?: MagicAppName;
      type: MagicAppType;
    }
  | {
      hostnames: MagicAppHostnames;
      ip_subnets?: MagicAppSubnets;
      name?: MagicAppName;
      type?: MagicAppType;
    }
  | {
      hostnames?: MagicAppHostnames;
      ip_subnets: MagicAppSubnets;
      name?: MagicAppName;
      type?: MagicAppType;
    };

export type MagicAppsResponseArray = {
  errors: MagicMessages;
  messages: MagicMessages;
  result: any[] | null;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type MagicAppsResponseObject = {
  errors: MagicMessages;
  messages: MagicMessages;
  result: Record<string, any> | null;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type MagicAppsCollectionResponse = {
  errors: MagicMessages;
  messages: MagicMessages;
  result: MagicApp[] | null;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

/**
 * A valid CIDR notation representing an IP range.
 *
 * @example 192.0.2.0/24
 */
export type MagicCidr = string;

/**
 * The IP address assigned to the Cloudflare side of the GRE tunnel.
 *
 * @example 203.0.113.1
 * @x-auditable true
 */
export type MagicCloudflareGreEndpoint = string;

/**
 * The IP address assigned to the Cloudflare side of the IPsec tunnel.
 *
 * @example 203.0.113.1
 */
export type MagicCloudflareIpsecEndpoint = string;

/**
 * Scope colo name.
 *
 * @example den01
 * @x-auditable true
 */
export type MagicColoName = string;

/**
 * List of colo names for the ECMP scope.
 */
export type MagicColoNames = MagicColoName[];

/**
 * Scope colo region.
 *
 * @example APAC
 * @x-auditable true
 */
export type MagicColoRegion = string;

/**
 * List of colo regions for the ECMP scope.
 *
 * @x-auditable true
 */
export type MagicColoRegions = MagicColoRegion[];

/**
 * An optional description forthe IPsec tunnel.
 *
 * @example Tunnel for ISP X
 */
export type MagicComponentsSchemasDescription = string;

export type MagicComponentsSchemasModifiedTunnelsCollectionResponse =
  MagicApiResponseSingle & {
    result?: {
      /**
       * @example true
       */
      modified?: boolean;
      modified_interconnects?: MagicInterconnect[];
    };
  };

/**
 * The name of the interconnect. The name cannot share a name with other tunnels.
 *
 * @example pni_ord
 */
export type MagicComponentsSchemasName = string;

export type MagicComponentsSchemasTunnelModifiedResponse =
  MagicApiResponseSingle & {
    result?: {
      /**
       * @example true
       */
      modified?: boolean;
      modified_interconnect?: MagicInterconnect;
    };
  };

export type MagicComponentsSchemasTunnelSingleResponse =
  MagicApiResponseSingle & {
    result?: {
      interconnect?: MagicInterconnect;
    };
  };

export type MagicComponentsSchemasTunnelsCollectionResponse =
  MagicApiResponseSingle & {
    result?: {
      interconnects?: MagicInterconnect[];
    };
  };

/**
 * Magic Connector identifier tag.
 *
 * @example ac60d3d0435248289d446cedd870bcf4
 * @x-auditable true
 */
export type MagicConnectorId = string;

export type MagicCreateGreTunnelRequest = {
  cloudflare_gre_endpoint: MagicCloudflareGreEndpoint;
  customer_gre_endpoint: MagicCustomerGreEndpoint;
  description?: MagicSchemasDescription;
  health_check?: MagicTunnelHealthCheck;
  interface_address: MagicInterfaceAddress;
  mtu?: MagicMtu;
  name: MagicGreTunnelName;
  ttl?: MagicTtl;
};

export type MagicCreateGreTunnelResponse = MagicApiResponseSingle & {
  result?: MagicGreTunnel;
};

export type MagicCreateRouteRequest = {
  description?: MagicDescription;
  nexthop: MagicNexthop;
  prefix: MagicPrefix;
  priority: MagicPriority;
  scope?: MagicScope;
  weight?: MagicWeight;
};

export type MagicCreateRouteResponse = MagicApiResponseSingle & {
  result?: MagicRoute;
};

/**
 * When the route was created.
 *
 * @example 2017-06-14T00:00:00Z
 * @format date-time
 * @x-auditable true
 */
export type MagicCreatedOn = string;

/**
 * The IP address assigned to the customer side of the GRE tunnel.
 *
 * @example 203.0.113.1
 * @x-auditable true
 */
export type MagicCustomerGreEndpoint = string;

/**
 * The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
 *
 * @example 203.0.113.1
 */
export type MagicCustomerIpsecEndpoint = string;

/**
 * An optional human provided description of the static route.
 *
 * @example New route for new prefix 203.0.113.1
 * @x-auditable true
 */
export type MagicDescription = string;

/**
 * The desired forwarding action for this ACL policy. If set to "false", the policy will forward traffic to Cloudflare. If set to "true", the policy will forward traffic locally on the Magic Connector. If not included in request, will default to false.
 */
export type MagicForwardLocally = boolean;

/**
 * The configuration specific to GRE interconnects.
 */
export type MagicGre = {
  /**
   * The IP address assigned to the Cloudflare side of the GRE tunnel created as part of the Interconnect.
   *
   * @example 203.0.113.1
   */
  cloudflare_endpoint?: string;
};

export type MagicGreTunnel = {
  cloudflare_gre_endpoint: MagicCloudflareGreEndpoint;
  created_on?: MagicSchemasCreatedOn;
  customer_gre_endpoint: MagicCustomerGreEndpoint;
  description?: MagicSchemasDescription;
  health_check?: MagicTunnelHealthCheck;
  id: MagicSchemasIdentifier;
  interface_address: MagicInterfaceAddress;
  modified_on?: MagicSchemasModifiedOn;
  mtu?: MagicMtu;
  name: MagicGreTunnelName;
  ttl?: MagicTtl;
};

export type MagicGreTunnelAddSingleRequest = {
  cloudflare_gre_endpoint: MagicCloudflareGreEndpoint;
  customer_gre_endpoint: MagicCustomerGreEndpoint;
  description?: MagicSchemasDescription;
  health_check?: MagicTunnelHealthCheck;
  interface_address: MagicInterfaceAddress;
  mtu?: MagicMtu;
  name: MagicGreTunnelName;
  ttl?: MagicTtl;
};

/**
 * The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel.
 *
 * @example GRE_1
 * @x-auditable true
 */
export type MagicGreTunnelName = string;

export type MagicGreTunnelUpdateRequest = MagicGreTunnelAddSingleRequest;

export type MagicHealthCheckBase = {
  /**
   * Determines whether to run healthchecks for a tunnel.
   *
   * @default true
   * @example true
   * @x-auditable true
   */
  enabled?: boolean;
  /**
   * How frequent the health check is run. The default value is `mid`.
   *
   * @default mid
   * @example low
   * @x-auditable true
   */
  rate?: "low" | "mid" | "high";
  /**
   * The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false.
   */
  target?: MagicHealthCheckTarget | string;
  /**
   * The type of healthcheck to run, reply or request. The default value is `reply`.
   *
   * @default reply
   * @example request
   * @x-auditable true
   */
  type?: "reply" | "request";
};

/**
 * The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to `customer_gre_endpoint address`. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target.
 */
export type MagicHealthCheckTarget = {
  /**
   * The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
   *
   * @example 203.0.113.1
   * @x-auditable true
   */
  effective?: string;
  /**
   * The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
   *
   * @example 203.0.113.1
   * @x-auditable true
   */
  saved?: string;
};

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type MagicIdentifier = string;

export type MagicInterconnect = {
  colo_name?: MagicComponentsSchemasName;
  created_on?: MagicSchemasCreatedOn;
  description?: MagicInterconnectComponentsSchemasDescription;
  gre?: MagicGre;
  health_check?: MagicInterconnectHealthCheck;
  id?: MagicSchemasIdentifier;
  interface_address?: MagicInterfaceAddress;
  modified_on?: MagicSchemasModifiedOn;
  mtu?: MagicSchemasMtu;
  name?: MagicComponentsSchemasName;
};

/**
 * An optional description of the interconnect.
 *
 * @example Tunnel for Interconnect to ORD
 */
export type MagicInterconnectComponentsSchemasDescription = string;

export type MagicInterconnectHealthCheck = MagicHealthCheckBase;

export type MagicInterconnectTunnelUpdateRequest = {
  description?: MagicInterconnectComponentsSchemasDescription;
  gre?: MagicGre;
  health_check?: MagicInterconnectHealthCheck;
  interface_address?: MagicInterfaceAddress;
  mtu?: MagicSchemasMtu;
};

/**
 * A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.0–10.255.255.255, 172.16.0.0–172.31.255.255, 192.168.0.0–192.168.255.255.
 *
 * @example 192.0.2.0/31
 * @x-auditable true
 */
export type MagicInterfaceAddress = string;

/**
 * A valid IPv4 address.
 *
 * @example 192.0.2.1
 */
export type MagicIpAddress = string;

export type MagicIpsecTunnel = {
  allow_null_cipher?: MagicAllowNullCipher;
  cloudflare_endpoint: MagicCloudflareIpsecEndpoint;
  created_on?: MagicSchemasCreatedOn;
  customer_endpoint?: MagicCustomerIpsecEndpoint;
  description?: MagicComponentsSchemasDescription;
  health_check?: MagicTunnelHealthCheck;
  id: MagicSchemasIdentifier;
  interface_address: MagicInterfaceAddress;
  modified_on?: MagicSchemasModifiedOn;
  name: MagicIpsecTunnelName;
  psk_metadata?: MagicPskMetadata;
  replay_protection?: MagicReplayProtection;
};

export type MagicIpsecTunnelAddRequest = MagicIpsecTunnelAddSingleRequest;

export type MagicIpsecTunnelAddSingleRequest = {
  cloudflare_endpoint: MagicCloudflareIpsecEndpoint;
  customer_endpoint?: MagicCustomerIpsecEndpoint;
  description?: MagicComponentsSchemasDescription;
  health_check?: MagicTunnelHealthCheck;
  interface_address: MagicInterfaceAddress;
  name: MagicIpsecTunnelName;
  psk?: MagicPsk;
  replay_protection?: MagicReplayProtection;
};

/**
 * The name of the IPsec tunnel. The name cannot share a name with other tunnels.
 *
 * @example IPsec_1
 */
export type MagicIpsecTunnelName = string;

export type MagicIpsecTunnelUpdateRequest = MagicIpsecTunnelAddSingleRequest;

export type MagicLan = {
  /**
   * mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
   */
  ha_link?: boolean;
  id?: MagicIdentifier;
  name?: string;
  nat?: MagicNat;
  physport?: MagicPort;
  routed_subnets?: MagicRoutedSubnet[];
  site_id?: MagicIdentifier;
  static_addressing?: MagicLanStaticAddressing;
  vlan_tag?: MagicVlanTag;
};

export type MagicLanAclConfiguration = {
  /**
   * The identifier for the LAN you want to create an ACL policy with.
   */
  lan_id: string;
  /**
   * The name of the LAN based on the provided lan_id.
   */
  lan_name?: string;
  /**
   * Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
   */
  port_ranges?: MagicAclPortRange[];
  /**
   * Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
   */
  ports?: MagicPort[];
  /**
   * Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
   */
  subnets?: MagicAclSubnet[];
};

export type MagicLanDeletedResponse = MagicApiResponseSingle & {
  result?: MagicLan;
};

export type MagicLanDhcpRelay = {
  /**
   * List of DHCP server IPs.
   */
  server_addresses?: MagicIpAddress[];
};

export type MagicLanDhcpServer = {
  dhcp_pool_end?: MagicIpAddress;
  dhcp_pool_start?: MagicIpAddress;
  dns_server?: MagicIpAddress;
  dns_servers?: MagicIpAddress[];
  /**
   * Mapping of MAC addresses to IP addresses
   *
   * @example {"00:11:22:33:44:55":"192.0.2.100","AA:BB:CC:DD:EE:FF":"192.168.1.101"}
   */
  reservations?: {
    [key: string]: string;
  };
};

export type MagicLanModifiedResponse = MagicApiResponseSingle & {
  result?: MagicLan;
};

export type MagicLanSingleResponse = MagicApiResponseSingle & {
  result?: MagicLan;
};

/**
 * If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static_address is required along with secondary and virtual address.
 */
export type MagicLanStaticAddressing = {
  address: MagicCidr;
  dhcp_relay?: MagicLanDhcpRelay;
  dhcp_server?: MagicLanDhcpServer;
  secondary_address?: MagicCidr;
  virtual_address?: MagicCidr;
};

export type MagicLanUpdateRequest = {
  name?: string;
  nat?: MagicNat;
  physport?: MagicPort;
  routed_subnets?: MagicRoutedSubnet[];
  static_addressing?: MagicLanStaticAddressing;
  vlan_tag?: MagicVlanTag;
};

export type MagicLansAddSingleRequest = {
  /**
   * mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
   */
  ha_link?: boolean;
  name?: string;
  nat?: MagicNat;
  physport: MagicPort;
  routed_subnets?: MagicRoutedSubnet[];
  static_addressing?: MagicLanStaticAddressing;
  vlan_tag?: MagicVlanTag;
};

export type MagicLansCollectionResponse = MagicApiResponseSingle & {
  result?: MagicLan[];
};

/**
 * Managed app defined by Cloudflare.
 */
export type MagicManagedApp = {
  hostnames?: MagicAppHostnames;
  ip_subnets?: MagicAppSubnets;
  managed_app_id: MagicManagedAppId;
  name?: MagicAppName;
  type?: MagicAppType;
};

/**
 * Managed app ID.
 *
 * @example cloudflare
 */
export type MagicManagedAppId = string;

export type MagicMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * When the route was last modified.
 *
 * @example 2017-06-14T05:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type MagicModifiedOn = string;

export type MagicModifiedTunnelsCollectionResponse = MagicApiResponseSingle & {
  result?: {
    /**
     * @example true
     */
    modified?: boolean;
    modified_gre_tunnels?: MagicGreTunnel[];
  };
};

/**
 * Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576.
 *
 * @default 1476
 * @x-auditable true
 */
export type MagicMtu = number;

export type MagicMultipleRouteDeleteResponse = MagicApiResponseSingle & {
  result?: {
    /**
     * @example true
     */
    deleted?: boolean;
    deleted_routes?: MagicRoute[];
  };
};

export type MagicMultipleRouteModifiedResponse = MagicApiResponseSingle & {
  result?: {
    /**
     * @example true
     */
    modified?: boolean;
    modified_routes?: MagicRoute[];
  };
};

export type MagicNat = {
  static_prefix?: MagicCidr;
};

/**
 * The next-hop IP Address for the static route.
 *
 * @example 203.0.113.1
 * @x-auditable true
 */
export type MagicNexthop = string;

/**
 * @example 1
 */
export type MagicPort = number;

/**
 * IP Prefix in Classless Inter-Domain Routing format.
 *
 * @example 192.0.2.0/24
 * @x-auditable true
 */
export type MagicPrefix = string;

/**
 * Priority of the static route.
 *
 * @x-auditable true
 */
export type MagicPriority = number;

/**
 * A randomly generated or provided string for use in the IPsec tunnel.
 *
 * @example O3bwKSjnaoCxDoUxjcq4Rk8ZKkezQUiy
 */
export type MagicPsk = string;

export type MagicPskGenerationResponse = MagicApiResponseSingle & {
  result?: {
    ipsec_tunnel_id?: MagicIdentifier;
    psk?: MagicPsk;
    psk_metadata?: MagicPskMetadata;
  };
};

/**
 * The PSK metadata that includes when the PSK was generated.
 */
export type MagicPskMetadata = {
  last_generated_on?: MagicSchemasModifiedOn;
};

/**
 * If `true`, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
 *
 * @default false
 * @example false
 */
export type MagicReplayProtection = boolean;

export type MagicRoute = {
  created_on?: MagicCreatedOn;
  description?: MagicDescription;
  id: MagicIdentifier;
  modified_on?: MagicModifiedOn;
  nexthop: MagicNexthop;
  prefix: MagicPrefix;
  priority: MagicPriority;
  scope?: MagicScope;
  weight?: MagicWeight;
};

export type MagicRouteAddSingleRequest = {
  description?: MagicDescription;
  nexthop: MagicNexthop;
  prefix: MagicPrefix;
  priority: MagicPriority;
  scope?: MagicScope;
  weight?: MagicWeight;
};

export type MagicRouteDeleteId = {
  id: MagicIdentifier;
};

export type MagicRouteDeleteManyRequest = {
  routes: MagicRouteDeleteId[];
};

export type MagicRouteDeletedResponse = MagicApiResponseSingle & {
  result?: {
    /**
     * @example true
     */
    deleted?: boolean;
    deleted_route?: MagicRoute;
  };
};

export type MagicRouteModifiedResponse = MagicApiResponseSingle & {
  result?: {
    /**
     * @example true
     */
    modified?: boolean;
    modified_route?: MagicRoute;
  };
};

export type MagicRouteSingleResponse = MagicApiResponseSingle & {
  result?: {
    route?: MagicRoute;
  };
};

export type MagicRouteUpdateManyRequest = {
  routes: MagicRouteUpdateSingleRequest[];
};

export type MagicRouteUpdateRequest = MagicRouteAddSingleRequest;

export type MagicRouteUpdateSingleRequest = {
  id: MagicIdentifier;
} & MagicRouteAddSingleRequest;

export type MagicRoutedSubnet = {
  nat?: MagicNat;
  next_hop: MagicIpAddress;
  prefix: MagicCidr;
};

export type MagicRoutesCollectionResponse = MagicApiResponseSingle & {
  result?: {
    routes?: MagicRoute[];
  };
};

export type MagicSchemasCreateIpsecTunnelResponse = MagicApiResponseSingle & {
  result?: MagicIpsecTunnel;
};

/**
 * The date and time the tunnel was created.
 *
 * @example 2017-06-14T00:00:00Z
 * @format date-time
 * @x-auditable true
 */
export type MagicSchemasCreatedOn = string;

/**
 * An optional description of the GRE tunnel.
 *
 * @example Tunnel for ISP X
 * @x-auditable true
 */
export type MagicSchemasDescription = string;

/**
 * Identifier
 *
 * @example c4a7362d577a6c3019a474fd6f485821
 * @maxLength 32
 * @x-auditable true
 */
export type MagicSchemasIdentifier = string;

/**
 * The date and time the tunnel was last modified.
 *
 * @example 2017-06-14T05:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type MagicSchemasModifiedOn = string;

export type MagicSchemasModifiedTunnelsCollectionResponse =
  MagicApiResponseSingle & {
    result?: {
      /**
       * @example true
       */
      modified?: boolean;
      modified_ipsec_tunnels?: MagicIpsecTunnel[];
    };
  };

/**
 * The Maximum Transmission Unit (MTU) in bytes for the interconnect. The minimum value is 576.
 *
 * @default 1476
 */
export type MagicSchemasMtu = number;

export type MagicSchemasTunnelDeletedResponse = MagicApiResponseSingle & {
  result?: {
    /**
     * @example true
     */
    deleted?: boolean;
    deleted_ipsec_tunnel?: MagicIpsecTunnel;
  };
};

export type MagicSchemasTunnelModifiedResponse = MagicApiResponseSingle & {
  result?: {
    /**
     * @example true
     */
    modified?: boolean;
    modified_ipsec_tunnel?: MagicIpsecTunnel;
  };
};

export type MagicSchemasTunnelSingleResponse = MagicApiResponseSingle & {
  result?: {
    ipsec_tunnel?: MagicIpsecTunnel;
  };
};

export type MagicSchemasTunnelsCollectionResponse = MagicApiResponseSingle & {
  result?: {
    ipsec_tunnels?: MagicIpsecTunnel[];
  };
};

/**
 * Used only for ECMP routes.
 */
export type MagicScope = {
  colo_names?: MagicColoNames;
  colo_regions?: MagicColoRegions;
};

/**
 * Magic Connector identifier tag. Used when high availability mode is on.
 *
 * @example 8d67040d3835dbcf46ce29da440dc482
 * @x-auditable true
 */
export type MagicSecondaryConnectorId = string;

export type MagicSite = {
  connector_id?: MagicConnectorId;
  description?: string;
  /**
   * Site high availability mode. If set to true, the site can have two connectors and runs in high availability mode.
   *
   * @example true
   */
  ha_mode?: boolean;
  id?: MagicIdentifier;
  location?: MagicSiteLocation;
  name?: MagicSiteName;
  secondary_connector_id?: MagicSecondaryConnectorId;
};

/**
 * Location of site in latitude and longitude.
 */
export type MagicSiteLocation = {
  /**
   * Latitude
   *
   * @example 37.6192
   * @x-auditable true
   */
  lat?: string;
  /**
   * Longitude
   *
   * @example 122.3816
   * @x-auditable true
   */
  lon?: string;
};

/**
 * The name of the site.
 *
 * @example site_1
 * @x-auditable true
 */
export type MagicSiteName = string;

export type MagicSiteDeletedResponse = MagicApiResponseSingle & {
  result?: MagicSite;
};

export type MagicSiteModifiedResponse = MagicApiResponseSingle & {
  result?: MagicSite;
};

export type MagicSiteSingleResponse = MagicApiResponseSingle & {
  result?: MagicSite;
};

export type MagicSiteUpdateRequest = {
  connector_id?: MagicConnectorId;
  description?: string;
  location?: MagicSiteLocation;
  name?: MagicSiteName;
  secondary_connector_id?: MagicSecondaryConnectorId;
};

export type MagicSitesAddSingleRequest = {
  connector_id?: MagicConnectorId;
  description?: string;
  /**
   * Site high availability mode. If set to true, the site can have two connectors and runs in high availability mode.
   *
   * @example true
   */
  ha_mode?: boolean;
  location?: MagicSiteLocation;
  name: MagicSiteName;
  secondary_connector_id?: MagicSecondaryConnectorId;
};

export type MagicSitesCollectionResponse = MagicApiResponseSingle & {
  result?: MagicSite[];
};

/**
 * Time To Live (TTL) in number of hops of the GRE tunnel.
 *
 * @default 64
 * @x-auditable true
 */
export type MagicTtl = number;

export type MagicTunnelDeletedResponse = MagicApiResponseSingle & {
  result?: {
    /**
     * @example true
     */
    deleted?: boolean;
    deleted_gre_tunnel?: MagicGreTunnel;
  };
};

export type MagicTunnelHealthCheck = MagicHealthCheckBase & {
  /**
   * The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
   *
   * @default unidirectional
   * @example bidirectional
   */
  direction?: "unidirectional" | "bidirectional";
};

export type MagicTunnelModifiedResponse = MagicApiResponseSingle & {
  result?: {
    /**
     * @example true
     */
    modified?: boolean;
    modified_gre_tunnel?: MagicGreTunnel;
  };
};

export type MagicTunnelSingleResponse = MagicApiResponseSingle & {
  result?: {
    gre_tunnel?: MagicGreTunnel;
  };
};

export type MagicTunnelsCollectionResponse = MagicApiResponseSingle & {
  result?: {
    gre_tunnels?: MagicGreTunnel[];
  };
};

/**
 * The desired traffic direction for this ACL policy. If set to "false", the policy will allow bidirectional traffic. If set to "true", the policy will only allow traffic in one direction. If not included in request, will default to false.
 */
export type MagicUnidirectional = boolean;

/**
 * VLAN ID. Use zero for untagged.
 *
 * @example 42
 * @x-auditable true
 */
export type MagicVlanTag = number;

export type MagicWan = {
  /**
   * Magic WAN health check rate for tunnels created on this link. The default value is `mid`.
   *
   * @default mid
   * @example low
   */
  health_check_rate?: "low" | "mid" | "high";
  id?: MagicIdentifier;
  name?: string;
  physport?: MagicPort;
  /**
   * Priority of WAN for traffic loadbalancing.
   */
  priority?: number;
  site_id?: MagicIdentifier;
  static_addressing?: MagicWanStaticAddressing;
  vlan_tag?: MagicVlanTag;
};

export type MagicWanDeletedResponse = MagicApiResponseSingle & {
  result?: MagicWan;
};

export type MagicWanModifiedResponse = MagicApiResponseSingle & {
  result?: MagicWan;
};

export type MagicWanSingleResponse = MagicApiResponseSingle & {
  result?: MagicWan;
};

/**
 * (optional) if omitted, use DHCP. Submit secondary_address when site is in high availability mode.
 */
export type MagicWanStaticAddressing = {
  address: MagicCidr;
  gateway_address: MagicIpAddress;
  secondary_address?: MagicCidr;
};

export type MagicWanUpdateRequest = {
  name?: string;
  physport?: MagicPort;
  priority?: number;
  static_addressing?: MagicWanStaticAddressing;
  vlan_tag?: MagicVlanTag;
};

export type MagicWansAddSingleRequest = {
  name?: string;
  physport: MagicPort;
  priority?: number;
  static_addressing?: MagicWanStaticAddressing;
  vlan_tag?: MagicVlanTag;
};

export type MagicWansCollectionResponse = MagicApiResponseSingle & {
  result?: MagicWan[];
};

/**
 * Optional weight of the ECMP scope - if provided.
 *
 * @x-auditable true
 */
export type MagicWeight = number;

/**
 * @x-auditable true
 */
export type McnAccountId = string;

export type McnApplyProgress = {
  /**
   * @x-auditable true
   */
  done: number;
  /**
   * @x-auditable true
   */
  total: number;
};

export type McnAwsTrustPolicy = {
  aws_trust_policy: string;
  /**
   * @x-auditable true
   */
  item_type: string;
};

export type McnAzureSetup = {
  azure_consent_url: string;
  /**
   * @x-auditable true
   */
  integration_identity_tag: string;
  /**
   * @x-auditable true
   */
  item_type: string;
  tag_cli_command: string;
};

export type McnBadResponse = McnResponse & {
  /**
   * @minLength 1
   */
  errors?: McnError[];
  result?: any | null;
};

export type McnCatalogSync = {
  description: string;
  destination_id: McnCatalogSyncDestinationId;
  destination_type: McnCatalogSyncDestinationType;
  errors?: {
    [key: string]: McnError;
  };
  id: McnCatalogSyncId;
  includes_discoveries_until?: string;
  last_attempted_update_at?: string;
  last_successful_update_at?: string;
  last_user_update_at: string;
  name: string;
  policy: string;
  update_mode: McnCatalogSyncUpdateMode;
};

/**
 * @format uuid
 * @x-auditable true
 */
export type McnCatalogSyncDestinationId = string;

/**
 * @x-auditable true
 */
export type McnCatalogSyncDestinationType = "NONE" | "ZERO_TRUST_LIST";

/**
 * @format uuid
 */
export type McnCatalogSyncId = string;

/**
 * @x-auditable true
 */
export type McnCatalogSyncUpdateMode = "AUTO" | "MANUAL";

export type McnCatalogSyncsPrebuiltPoliciesResponse = McnGoodResponse & {
  result?: McnCatalogSyncsPrebuiltPolicy[];
};

export type McnCatalogSyncsPrebuiltPolicy = {
  applicable_destinations: McnCatalogSyncDestinationType[];
  policy_description: string;
  policy_name: string;
  policy_string: string;
};

/**
 * An IP address prefix in CIDR format.
 *
 * @example 192.168.0.0/16
 * @x-auditable true
 */
export type McnCidrPrefix = string;

export type McnCloudPlatformClient = {
  /**
   * @x-auditable true
   */
  client_type: "MAGIC_WAN_CLOUD_ONRAMP";
  id: McnPlatformClientId;
  /**
   * @x-auditable true
   */
  name: string;
};

/**
 * @x-auditable true
 */
export type McnCloudType = "AWS" | "AZURE" | "GOOGLE" | "CLOUDFLARE";

/**
 * @format uuid
 * @x-auditable true
 */
export type McnConduitRouteId = string;

/**
 * @format uuid
 * @x-auditable true
 */
export type McnConduitTunnelId = string;

export type McnCost = {
  /**
   * @x-auditable true
   */
  currency: string;
  /**
   * @format double
   */
  monthly_cost: number;
};

export type McnCostDiff = {
  /**
   * @x-auditable true
   */
  currency: string;
  /**
   * @format double
   */
  current_monthly_cost: number;
  /**
   * @format double
   */
  diff: number;
  /**
   * @format double
   */
  proposed_monthly_cost: number;
};

export type McnCreateCatalogSyncRequest = {
  description?: string;
  destination_type: McnCatalogSyncDestinationType;
  name: string;
  policy?: string;
  update_mode: McnCatalogSyncUpdateMode;
};

export type McnCreateCatalogSyncResponse = McnGoodResponse & {
  result?: McnCatalogSync;
};

export type McnCreateOnrampRequest = {
  adopted_hub_id?: McnResourceId;
  attached_hubs?: McnResourceId[];
  attached_vpcs?: McnResourceId[];
  cloud_type: McnOnrampCloudType;
  description?: string;
  hub_provider_id?: McnProviderId;
  /**
   * @x-auditable true
   */
  install_routes_in_cloud: boolean;
  /**
   * @x-auditable true
   */
  install_routes_in_magic_wan: boolean;
  /**
   * @x-auditable true
   */
  manage_hub_to_hub_attachments?: boolean;
  /**
   * @x-auditable true
   */
  manage_vpc_to_hub_attachments?: boolean;
  name: string;
  /**
   * @x-auditable true
   */
  region?: string;
  type: McnOnrampType;
  vpc?: McnResourceId;
};

export type McnCreateOnrampResponse = McnGoodResponse & {
  result?: McnOnramp;
};

export type McnCreateProviderRequest = {
  cloud_type: McnCloudType;
  /**
   * @x-auditable true
   */
  description?: string;
  /**
   * @x-auditable true
   */
  friendly_name: string;
};

export type McnCreateProviderResponse = McnGoodResponse & {
  result?: McnProvider;
};

export type McnDeleteCatalogSyncResponse = McnGoodResponse & {
  result?: McnDeletedCatalogSync;
};

export type McnDeleteOnrampResponse = McnGoodResponse & {
  result?: McnDeletedOnramp;
};

export type McnDeleteProviderResponse = McnGoodResponse & {
  result?: McnDeletedProvider;
};

export type McnDeleteResourceResponse = McnGoodResponse & {
  result?: McnDeletedResource;
};

export type McnDeletedCatalogSync = {
  id: McnCatalogSyncId;
};

export type McnDeletedOnramp = {
  id: McnOnrampId;
};

export type McnDeletedProvider = {
  id: McnProviderId;
};

export type McnDeletedResource = {
  id: McnResourceId;
};

export type McnError = {
  /**
   * @x-auditable true
   */
  code:
    | 1001
    | 1002
    | 1003
    | 1004
    | 1005
    | 1006
    | 1007
    | 1008
    | 1009
    | 1010
    | 1011
    | 1012
    | 1013
    | 1014
    | 1015
    | 1016
    | 1017
    | 2001
    | 2002
    | 2003
    | 2004
    | 2005
    | 2006
    | 2007
    | 2008
    | 2009
    | 2010
    | 2011
    | 2012
    | 2013
    | 2014
    | 2015
    | 2016
    | 2017
    | 2018
    | 2019
    | 2020
    | 2021
    | 2022
    | 3001
    | 3002
    | 3003
    | 3004
    | 3005
    | 3006
    | 3007
    | 4001
    | 4002
    | 4003
    | 4004
    | 4005
    | 4006
    | 4007
    | 4008
    | 4009
    | 4010
    | 4011
    | 4012
    | 4013
    | 4014
    | 4015
    | 4016
    | 4017
    | 4018
    | 4019
    | 4020
    | 4021
    | 4022
    | 4023
    | 5001
    | 5002
    | 5003
    | 5004
    | 102000
    | 102001
    | 102002
    | 102003
    | 102004
    | 102005
    | 102006
    | 102007
    | 102008
    | 102009
    | 102010
    | 102011
    | 102012
    | 102013
    | 102014
    | 102015
    | 102016
    | 102017
    | 102018
    | 102019
    | 102020
    | 102021
    | 102022
    | 102023
    | 102024
    | 102025
    | 102026
    | 102027
    | 102028
    | 102029
    | 102030
    | 102031
    | 102032
    | 102033
    | 102034
    | 102035
    | 102036
    | 102037
    | 102038
    | 102039
    | 102040
    | 102041
    | 102042
    | 102043
    | 102044
    | 102045
    | 102046
    | 102047
    | 102048
    | 102049
    | 102050
    | 102051
    | 102052
    | 102053
    | 102054
    | 102055
    | 102056
    | 102057
    | 102058
    | 102059
    | 102060
    | 102061
    | 102062
    | 102063
    | 102064
    | 102065
    | 102066
    | 103001
    | 103002
    | 103003
    | 103004
    | 103005
    | 103006
    | 103007
    | 103008;
  documentation_url?: string;
  message: string;
  meta?: McnErrorMeta;
  source?: McnErrorSource;
};

export type McnErrorMeta = {
  /**
   * @x-auditable true
   */
  l10n_key?: string;
  loggable_error?: string;
  template_data?: Record<string, any>;
  /**
   * @x-auditable true
   */
  trace_id?: string;
};

export type McnErrorSource = {
  /**
   * @x-auditable true
   */
  parameter?: string;
  /**
   * @x-auditable true
   */
  parameter_value_index?: number;
  /**
   * @x-auditable true
   */
  pointer?: string;
};

export type McnGcpSetup = {
  /**
   * @x-auditable true
   */
  integration_identity_tag: string;
  /**
   * @x-auditable true
   */
  item_type: string;
  tag_cli_command: string;
};

export type McnGetMagicWanAddressSpaceResponse = McnGoodResponse & {
  result?: McnMagicWanAddressSpace;
};

export type McnGetOnrampResponse = McnGoodResponse & {
  result?: McnOnramp;
};

export type McnGoodResponse = McnResponse & {
  /**
   * @maxLength 0
   */
  errors?: McnError[];
};

export type McnGoodResponseCollection = McnResponseCollection & {
  /**
   * @maxLength 0
   */
  errors?: McnError[];
};

export type McnListItem = {
  item_type: string;
  list: (McnStringItem | McnResourcePreviewItem)[];
};

export type McnListOnrampsResponse = McnGoodResponse & {
  result?: McnOnramp[];
};

export type McnMagicWanAddressSpace = {
  prefixes: McnCidrPrefix[];
};

export type McnObservation = {
  /**
   * @x-auditable true
   */
  first_observed_at: string;
  /**
   * @x-auditable true
   */
  last_observed_at: string;
  provider_id: McnProviderId;
  resource_id: McnResourceId;
};

export type McnOnramp = {
  attached_hubs?: McnResourceId[];
  attached_vpcs?: McnResourceId[];
  cloud_type: McnOnrampCloudType;
  /**
   * @x-auditable true
   */
  description?: string;
  hub?: McnResourceId;
  id: McnOnrampId;
  /**
   * @x-auditable true
   */
  install_routes_in_cloud: boolean;
  /**
   * @x-auditable true
   */
  install_routes_in_magic_wan: boolean;
  /**
   * @x-auditable true
   */
  last_applied_at?: string;
  /**
   * @x-auditable true
   */
  last_exported_at?: string;
  /**
   * @x-auditable true
   */
  last_planned_at?: string;
  /**
   * @x-auditable true
   */
  manage_hub_to_hub_attachments?: boolean;
  /**
   * @x-auditable true
   */
  manage_vpc_to_hub_attachments?: boolean;
  /**
   * @x-auditable true
   */
  name: string;
  planned_monthly_cost_estimate?: McnCostDiff;
  planned_resources?: McnResourceDiff[];
  /**
   * @x-auditable true
   */
  planned_resources_unavailable?: boolean;
  post_apply_monthly_cost_estimate?: McnCost;
  post_apply_resources?: {
    [key: string]: McnResourceDetails;
  };
  /**
   * @x-auditable true
   */
  post_apply_resources_unavailable?: boolean;
  /**
   * @x-auditable true
   */
  region?: string;
  status?: McnOnrampStatus;
  type: McnOnrampType;
  updated_at: string;
  vpc?: McnResourceId;
  vpcs_by_id?: {
    [key: string]: McnResourceDetails;
  };
  /**
   * The list of vpc IDs for which resource details failed to generate.
   */
  vpcs_by_id_unavailable?: McnResourceId[];
};

/**
 * @x-auditable true
 */
export type McnOnrampCloudType = "AWS" | "AZURE" | "GOOGLE";

/**
 * @format uuid
 * @x-auditable true
 */
export type McnOnrampId = string;

/**
 * @x-auditable true
 */
export type McnOnrampLifecycleState =
  | "OnrampNeedsApply"
  | "OnrampPendingPlan"
  | "OnrampPlanning"
  | "OnrampPlanFailed"
  | "OnrampPendingApproval"
  | "OnrampPendingApply"
  | "OnrampApplying"
  | "OnrampApplyFailed"
  | "OnrampActive"
  | "OnrampPendingDestroy"
  | "OnrampDestroying"
  | "OnrampDestroyFailed";

export type McnOnrampStatus = {
  apply_progress: McnApplyProgress;
  lifecycle_errors?: {
    [key: string]: McnError;
  };
  lifecycle_state: McnOnrampLifecycleState;
  plan_progress: McnPlanProgress;
  routes: McnConduitRouteId[];
  tunnels: McnConduitTunnelId[];
};

/**
 * @x-auditable true
 */
export type McnOnrampType = "OnrampTypeSingle" | "OnrampTypeHub";

export type McnOnrampWithAccount = McnOnramp & {
  account_id: McnAccountId;
};

export type McnPlanProgress = {
  /**
   * @x-auditable true
   */
  done: number;
  /**
   * @x-auditable true
   */
  total: number;
};

/**
 * @x-auditable true
 */
export type McnPlannedAction =
  | "no_op"
  | "create"
  | "update"
  | "replace"
  | "destroy";

/**
 * @format uuid
 * @x-auditable true
 */
export type McnPlatformClientId = string;

export type McnPolicyResult = string;

export type McnProvider = {
  /**
   * @x-auditable true
   */
  aws_arn?: string;
  /**
   * @x-auditable true
   */
  azure_subscription_id?: string;
  /**
   * @x-auditable true
   */
  azure_tenant_id?: string;
  cloud_type: McnCloudType;
  description?: string;
  friendly_name: string;
  /**
   * @x-auditable true
   */
  gcp_project_id?: string;
  /**
   * @x-auditable true
   */
  gcp_service_account_email?: string;
  id: McnProviderId;
  /**
   * @x-auditable true
   */
  last_updated: string;
  lifecycle_state: McnProviderLifecycleState;
  state: McnProviderDiscoveryStatus;
  state_v2: McnProviderDiscoveryStatus;
  status?: McnProviderStatus;
};

export type McnProviderDiscoveryProgress = {
  /**
   * @x-auditable true
   */
  done: number;
  /**
   * @x-auditable true
   */
  total: number;
  /**
   * @x-auditable true
   */
  unit: string;
};

/**
 * @x-auditable true
 */
export type McnProviderDiscoveryStatus =
  | "UNSPECIFIED"
  | "PENDING"
  | "DISCOVERING"
  | "FAILED"
  | "SUCCEEDED";

/**
 * @format uuid
 * @x-auditable true
 */
export type McnProviderId = string;

export type McnProviderInitialSetupResponse = McnGoodResponse & {
  result?: McnAwsTrustPolicy | McnAzureSetup | McnGcpSetup;
};

/**
 * @x-auditable true
 */
export type McnProviderLifecycleState = "ACTIVE" | "PENDING_SETUP" | "RETIRED";

export type McnProviderStatus = {
  /**
   * @x-auditable true
   */
  credentials_good_since?: string;
  /**
   * @x-auditable true
   */
  credentials_missing_since?: string;
  /**
   * @x-auditable true
   */
  credentials_rejected_since?: string;
  /**
   * @x-auditable true
   */
  discovery_message?: string;
  /**
   * @x-auditable true
   */
  discovery_message_v2?: string;
  discovery_progress: McnProviderDiscoveryProgress;
  discovery_progress_v2: McnProviderDiscoveryProgress;
  in_use_by?: McnCloudPlatformClient[];
  /**
   * @x-auditable true
   */
  last_discovery_completed_at?: string;
  /**
   * @x-auditable true
   */
  last_discovery_completed_at_v2?: string;
  /**
   * @x-auditable true
   */
  last_discovery_started_at?: string;
  /**
   * @x-auditable true
   */
  last_discovery_started_at_v2?: string;
  last_discovery_status: McnProviderDiscoveryStatus;
  last_discovery_status_v2: McnProviderDiscoveryStatus;
  /**
   * @x-auditable true
   */
  last_updated?: string;
  regions: string[];
};

export type McnProviderWithAccount = McnProvider & {
  account_id: McnAccountId;
};

export type McnReadAccountCatalogSyncResponse = McnGoodResponse & {
  result?: McnCatalogSync;
};

export type McnReadAccountCatalogSyncsResponse = McnGoodResponse & {
  result?: McnCatalogSync[];
};

export type McnReadAccountProviderResponse = McnGoodResponse & {
  result?: McnProvider;
};

export type McnReadAccountProvidersResponse = McnGoodResponse & {
  result?: McnProvider[];
};

export type McnReadAccountResourceResponse = McnGoodResponse & {
  result?: McnResourceDetails;
};

export type McnReadAccountResourcesResponse = McnGoodResponseCollection & {
  result?: McnResourceDetails[];
  result_info?: McnResultInfo;
};

export type McnRefreshCatalogSyncResponse = McnGoodResponse & {
  result?: McnPolicyResult;
};

export type McnResourceDetails = {
  account_id: McnAccountId;
  cloud_type: McnCloudType;
  config: {
    [key: string]: any;
  };
  deployment_provider: McnProviderId;
  id: McnResourceId;
  /**
   * @x-auditable true
   */
  managed: boolean;
  managed_by?: McnCloudPlatformClient[];
  monthly_cost_estimate: McnCost;
  name: string;
  native_id: string;
  observations: {
    [key: string]: McnObservation;
  };
  provider_ids: McnProviderId[];
  provider_names_by_id: {
    [key: string]: string;
  };
  /**
   * @x-auditable true
   */
  region: string;
  /**
   * @x-auditable true
   */
  resource_group: string;
  resource_type: McnResourceType;
  sections: McnResourceDetailsSection[];
  state: {
    [key: string]: any;
  };
  tags: {
    [key: string]: string;
  };
  updated_at: string;
  url: string;
};

export type McnResourceDetailsSection = {
  help_text?: string;
  hidden_items: McnResourceDetailsSectionItem[];
  name: string;
  visible_items: McnResourceDetailsSectionItem[];
};

export type McnResourceDetailsSectionItem = {
  helpText?: string;
  name?: string;
  value?:
    | McnStringItem
    | McnYamlItem
    | McnYamlDiffItem
    | McnResourcePreviewItem
    | McnListItem;
};

export type McnResourceDiff = {
  diff: McnYamlDiff;
  keys_require_replace: string[];
  monthly_cost_estimate_diff: McnCostDiff;
  planned_action: McnPlannedAction;
  resource: McnResourcePreview;
};

/**
 * @format uuid
 * @x-auditable true
 */
export type McnResourceId = string;

export type McnResourcePreview = {
  cloud_type: McnCloudType;
  detail: string;
  id: McnResourceId;
  name: string;
  resource_type: McnResourceType;
  title: string;
};

export type McnResourcePreviewItem = {
  /**
   * @x-auditable true
   */
  item_type: string;
  resource_preview: McnResourcePreview;
};

/**
 * @x-auditable true
 */
export type McnResourceType =
  | "aws_customer_gateway"
  | "aws_egress_only_internet_gateway"
  | "aws_internet_gateway"
  | "aws_instance"
  | "aws_network_interface"
  | "aws_route"
  | "aws_route_table"
  | "aws_route_table_association"
  | "aws_subnet"
  | "aws_vpc"
  | "aws_vpc_ipv4_cidr_block_association"
  | "aws_vpn_connection"
  | "aws_vpn_connection_route"
  | "aws_vpn_gateway"
  | "aws_security_group"
  | "aws_vpc_security_group_ingress_rule"
  | "aws_vpc_security_group_egress_rule"
  | "aws_ec2_managed_prefix_list"
  | "aws_ec2_transit_gateway"
  | "aws_ec2_transit_gateway_prefix_list_reference"
  | "aws_ec2_transit_gateway_vpc_attachment"
  | "azurerm_application_security_group"
  | "azurerm_lb"
  | "azurerm_lb_backend_address_pool"
  | "azurerm_lb_nat_pool"
  | "azurerm_lb_nat_rule"
  | "azurerm_lb_rule"
  | "azurerm_local_network_gateway"
  | "azurerm_network_interface"
  | "azurerm_network_interface_application_security_group_association"
  | "azurerm_network_interface_backend_address_pool_association"
  | "azurerm_network_interface_security_group_association"
  | "azurerm_network_security_group"
  | "azurerm_public_ip"
  | "azurerm_route"
  | "azurerm_route_table"
  | "azurerm_subnet"
  | "azurerm_subnet_route_table_association"
  | "azurerm_virtual_machine"
  | "azurerm_virtual_network_gateway_connection"
  | "azurerm_virtual_network"
  | "azurerm_virtual_network_gateway"
  | "google_compute_network"
  | "google_compute_subnetwork"
  | "google_compute_vpn_gateway"
  | "google_compute_vpn_tunnel"
  | "google_compute_route"
  | "google_compute_address"
  | "google_compute_global_address"
  | "google_compute_router"
  | "google_compute_interconnect_attachment"
  | "google_compute_ha_vpn_gateway"
  | "google_compute_forwarding_rule"
  | "google_compute_network_firewall_policy"
  | "google_compute_network_firewall_policy_rule"
  | "cloudflare_static_route"
  | "cloudflare_ipsec_tunnel";

export type McnResourcesCatalogPolicyPreview = string;

export type McnResourcesCatalogPolicyPreviewRequest = {
  policy: string;
};

export type McnResourcesCatalogPolicyPreviewResponse = McnGoodResponse & {
  result?: McnResourcesCatalogPolicyPreview;
};

export type McnResponse = {
  messages: McnError[];
  /**
   * @x-auditable true
   */
  success: boolean;
};

export type McnResponseCollection = {
  messages: McnError[];
  result_info?: McnResultInfo;
  success: boolean;
};

export type McnResultInfo = {
  /**
   * The number of items in the current result set.
   *
   * @example 1
   */
  count: number;
  /**
   * The current page (starts from zero).
   *
   * @example 1
   */
  page: number;
  /**
   * The maximum numnber of items per page.
   *
   * @example 20
   */
  per_page: number;
  /**
   * The total number of items in the entire result set.
   *
   * @example 2000
   */
  total_count: number;
  /**
   * The number of total pages in the entire result set.
   *
   * @example 200
   */
  total_pages?: number;
};

export type McnStringItem = {
  item_type: string;
  string: string;
};

export type McnUpdateCatalogSyncRequest = {
  description?: string;
  name?: string;
  policy?: string;
  update_mode?: McnCatalogSyncUpdateMode;
};

export type McnUpdateCatalogSyncResponse = McnGoodResponse & {
  result?: McnCatalogSync;
};

export type McnUpdateMagicWanAddressSpaceRequest = {
  prefixes: McnCidrPrefix[];
};

export type McnUpdateMagicWanAddressSpaceResponse = McnGoodResponse & {
  result?: McnMagicWanAddressSpace;
};

export type McnUpdateOnrampRequest = {
  attached_hubs?: McnResourceId[];
  attached_vpcs?: McnResourceId[];
  description?: string;
  /**
   * @x-auditable true
   */
  install_routes_in_cloud?: boolean;
  install_routes_in_magic_wan?: boolean;
  manage_hub_to_hub_attachments?: boolean;
  manage_vpc_to_hub_attachments?: boolean;
  name?: string;
  vpc?: McnResourceId;
};

export type McnUpdateOnrampResponse = McnGoodResponse & {
  result?: McnOnramp;
};

export type McnUpdateProviderRequest = {
  /**
   * @x-auditable true
   */
  aws_arn?: string;
  /**
   * @x-auditable true
   */
  azure_subscription_id?: string;
  /**
   * @x-auditable true
   */
  azure_tenant_id?: string;
  /**
   * @x-auditable true
   */
  description?: string;
  /**
   * @x-auditable true
   */
  friendly_name?: string;
  /**
   * @x-auditable true
   */
  gcp_project_id?: string;
  /**
   * @x-auditable true
   */
  gcp_service_account_email?: string;
};

export type McnUpdateProviderResponse = McnGoodResponse & {
  result?: McnProvider;
};

export type McnYamlDiff = {
  diff: string;
  left_description: string;
  left_yaml: string;
  right_description: string;
  right_yaml: string;
};

export type McnYamlDiffItem = {
  item_type: string;
  yaml_diff: McnYamlDiff;
};

export type McnYamlItem = {
  item_type: string;
  yaml: string;
};

/**
 * Account identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type MconnAccountId = string;

export type MconnAdminConnector = {
  account_id: MconnAccountId;
  activated: boolean;
  cohort?: string;
  desired_version?: string;
  device_id?: MconnUuid;
  id: MconnUuid;
  interrupt_window_duration_hours: number;
  interrupt_window_hour_of_day: number;
  last_heartbeat?: string;
  last_seen_version?: string;
  last_updated: string;
  notes: string;
  pinned_version?: string;
  timezone: string;
  upgrade_asap: boolean;
};

export type MconnAdminConnectorCreateRequest = MconnAdminConnectorFields;

export type MconnAdminConnectorCreateResponse = MconnGoodResponse & {
  result?: MconnAdminConnector;
};

export type MconnAdminConnectorDeleteResponse = MconnGoodResponse & {
  result?: MconnAdminConnector;
};

export type MconnAdminConnectorFetchResponse = MconnGoodResponse & {
  result?: MconnAdminConnector;
};

export type MconnAdminConnectorFields = {
  account_id?: number;
  activated?: boolean;
  cohort?: string;
  desired_version?: string;
  device_id?: string;
  interrupt_window_duration_hours?: number;
  interrupt_window_hour_of_day?: number;
  last_heartbeat?: string;
  last_seen_version?: string;
  last_updated?: string;
  notes?: string;
  pinned_version?: string;
  timezone?: string;
  upgrade_asap?: boolean;
};

export type MconnAdminConnectorListResponse = MconnGoodResponse & {
  result?: MconnAdminConnector[];
};

export type MconnAdminConnectorReplaceRequest = MconnAdminConnectorFields;

export type MconnAdminConnectorReplaceResponse = MconnGoodResponse & {
  result?: MconnAdminConnector;
};

export type MconnAdminConnectorUpdateRequest = MconnAdminConnectorFields;

export type MconnAdminConnectorUpdateResponse = MconnGoodResponse & {
  result?: MconnAdminConnector;
};

export type MconnAdminDevice = {
  /**
   * @x-sensitive true
   */
  crypt_key: string;
  crypt_key_rotation_finished_at?: string;
  crypt_key_rotation_output?: string;
  crypt_key_rotation_started_at?: string;
  crypt_key_rotation_status_code?: number;
  ek_cert?: string;
  id: MconnUuid;
  imaged_at?: string;
  /**
   * @x-sensitive true
   */
  last_crypt_key?: string;
  last_updated: string;
  license_key_sha256?: string;
  metadata: string;
  pki_rotation_finished_at?: string;
  pki_rotation_output?: string;
  pki_rotation_started_at?: string;
  pki_rotation_status_code?: number;
  serial_number?: string;
};

export type MconnAdminDeviceCreateRequest = MconnAdminDeviceFields;

export type MconnAdminDeviceCreateResponse = MconnGoodResponse & {
  result?: MconnAdminDevice;
};

export type MconnAdminDeviceDeleteResponse = MconnGoodResponse & {
  result?: MconnAdminDevice;
};

export type MconnAdminDeviceFetchResponse = MconnGoodResponse & {
  result?: MconnAdminDevice;
};

export type MconnAdminDeviceFields = {
  /**
   * @x-sensitive true
   */
  crypt_key?: string;
  crypt_key_rotation_finished_at?: string;
  crypt_key_rotation_output?: string;
  crypt_key_rotation_started_at?: string;
  crypt_key_rotation_status_code?: number;
  ek_cert?: string;
  imaged_at?: string;
  /**
   * @x-sensitive true
   */
  last_crypt_key?: string;
  last_updated?: string;
  license_key_sha256?: string;
  metadata?: string;
  pki_rotation_finished_at?: string;
  pki_rotation_output?: string;
  pki_rotation_started_at?: string;
  pki_rotation_status_code?: number;
  serial_number?: string;
};

export type MconnAdminDeviceListResponse = MconnGoodResponse & {
  result?: MconnAdminDevice[];
};

export type MconnAdminDeviceReplaceRequest = MconnAdminDeviceFields;

export type MconnAdminDeviceReplaceResponse = MconnGoodResponse & {
  result?: MconnAdminDevice;
};

export type MconnAdminDeviceUpdateRequest = MconnAdminDeviceFields;

export type MconnAdminDeviceUpdateResponse = MconnGoodResponse & {
  result?: MconnAdminDevice;
};

export type MconnAdminEventGetSuccess = MconnEnvelope & {
  result: MconnRecordedEvent;
};

export type MconnAdminEventsGetLatestResult = {
  count: number;
  items: MconnRecordedEvent[];
};

export type MconnAdminEventsGetLatestSuccess = MconnEnvelope & {
  result: MconnAdminEventsGetLatestResult;
};

export type MconnAdminEventsGetResult = {
  count: number;
  cursor?: string;
  items: MconnEventMetadata[];
};

export type MconnAdminEventsGetSuccess = MconnEnvelope & {
  result: MconnAdminEventsGetResult;
};

export type MconnAdminFlare = {
  id: MconnUuid;
  triggered_at: string;
};

export type MconnAdminFlareReplaceResponse = MconnGoodResponse & {
  result?: MconnAdminFlare;
};

export type MconnAdminMacrosDiagnoseConnectorResponse = MconnGoodResponse & {
  result?: MconnAdminMacrosDiagnoseConnectorResult;
};

export type MconnAdminMacrosDiagnoseConnectorResult = {
  connector?: MconnAdminConnector;
  device?: MconnAdminDevice;
  site?: MconnAdminSite;
};

export type MconnAdminMacrosProvisionLicensedConnectorResponse =
  MconnGoodResponse & {
    result?: MconnAdminMacrosProvisionLicensedConnectorResult;
  };

export type MconnAdminMacrosProvisionLicensedConnectorResult = {
  connector: MconnAdminConnector;
  device: MconnAdminDevice;
  license_key: string;
};

export type MconnAdminMacrosProvisionPhysicalConnectorResponse =
  MconnGoodResponse & {
    result?: MconnAdminMacrosProvisionPhysicalConnectorResult;
  };

export type MconnAdminMacrosProvisionPhysicalConnectorResult = {
  connector: MconnAdminConnector;
};

export type MconnAdminMacrosReportExceptionResult = {
  message: string;
};

export type MconnAdminMacrosReportExceptionSuccess = MconnEnvelope & {
  result: MconnAdminMacrosReportExceptionResult;
};

export type MconnAdminSite = {
  id: MconnUuid;
};

export type MconnAdminSnapshotGetSuccess = MconnEnvelope & {
  result: MconnSnapshot;
};

export type MconnAdminSnapshotsGetLatestResult = {
  count: number;
  items: MconnSnapshot[];
};

export type MconnAdminSnapshotsGetLatestSuccess = MconnEnvelope & {
  result: MconnAdminSnapshotsGetLatestResult;
};

export type MconnAdminSnapshotsGetResult = {
  count: number;
  cursor?: string;
  items: MconnSnapshotMetadata[];
};

export type MconnAdminSnapshotsGetSuccess = MconnEnvelope & {
  result: MconnAdminSnapshotsGetResult;
};

export type MconnAdminUpgradeSlot = {
  connector_id?: MconnUuid;
  id: number;
  started_at?: string;
};

export type MconnAdminUpgradeSlotsFetchResponse = MconnGoodResponse & {
  result?: MconnAdminUpgradeSlot[];
};

export type MconnAdminUpgradeSlotsReplaceResponse = MconnGoodResponse & {
  result?: MconnAdminUpgradeSlot[];
};

export type MconnBadResponse = MconnResponse & {
  /**
   * @minLength 1
   */
  errors?: MconnCodedMessage[];
  result?: MconnNone;
};

export type MconnCodedMessage = {
  code: number;
  message: string;
};

export type MconnConduitConnector = {
  account_id: MconnAccountId;
};

export type MconnConduitFetchConnectorResponse = MconnGoodResponse & {
  result?: MconnConduitFetchConnectorResult;
};

export type MconnConduitFetchConnectorResult = MconnConduitConnector;

export type MconnConnectorEventsPostResult = {
  count: number;
};

export type MconnConnectorEventsPostSuccess = MconnEnvelope & {
  result: MconnConnectorEventsPostResult;
};

export type MconnConnectorSnapshotsPostResult = {
  count: number;
};

export type MconnConnectorSnapshotsPostSuccess = MconnEnvelope & {
  result: MconnConnectorSnapshotsPostResult;
};

export type MconnControllerAttestationSession = {
  ak_public: string;
  connector?: MconnControllerConnectorIdentity;
  device: MconnControllerDeviceIdentity;
  nonce: string;
};

export type MconnControllerBeginAttestationSessionResponse =
  MconnGoodResponse & {
    result?: MconnControllerBeginAttestationSessionResult;
  };

export type MconnControllerBeginAttestationSessionResult =
  MconnControllerAttestationSession;

export type MconnControllerConnector = {
  account_id: MconnAccountId;
  activated: boolean;
  desired_version?: string;
  id: MconnUuid;
  interrupt_window_duration_hours: number;
  interrupt_window_hour_of_day: number;
  last_heartbeat?: string;
  last_seen_version?: string;
  pinned_version?: string;
  timezone: string;
  upgrade_asap: boolean;
};

export type MconnControllerConnectorIdentity = {
  account_id: MconnAccountId;
  activated: boolean;
  id: MconnUuid;
};

export type MconnControllerDevice = {
  /**
   * @x-sensitive true
   */
  crypt_key: string;
  crypt_key_rotation_finished_at?: string;
  id: MconnUuid;
  imaged_at?: string;
  /**
   * @x-sensitive true
   */
  last_crypt_key?: string;
  license_key_sha256?: string;
  serial_number?: string;
};

export type MconnControllerDeviceIdentity = {
  id: MconnUuid;
  imaged_at?: string;
  serial_number?: string;
};

export type MconnControllerEndAttestationSessionResponse = MconnGoodResponse & {
  result?: MconnControllerEndAttestationSessionResult;
};

export type MconnControllerEndAttestationSessionResult =
  MconnControllerAttestationSession;

export type MconnControllerFetchCloudflaredTokenResponse = MconnGoodResponse & {
  result?: MconnControllerFetchCloudflaredTokenResult;
};

/**
 * @x-sensitive true
 */
export type MconnControllerFetchCloudflaredTokenResult = string;

export type MconnControllerFetchConnectorResponse = MconnGoodResponse & {
  result?: MconnControllerFetchConnectorResult;
};

export type MconnControllerFetchConnectorResult = MconnControllerConnector;

export type MconnControllerFetchDeviceResponse = MconnGoodResponse & {
  result?: MconnControllerFetchDeviceResult;
};

export type MconnControllerFetchDeviceResult = MconnControllerDevice;

export type MconnControllerFetchFlareResponse = MconnGoodResponse & {
  result?: MconnControllerFetchFlareResult;
};

export type MconnControllerFetchFlareResult = MconnControllerFlare;

export type MconnControllerFetchUpgradeSlotsResponse = MconnGoodResponse & {
  result?: MconnControllerUpgradeSlot[];
};

export type MconnControllerFlare = {
  triggered_at: string;
};

export type MconnControllerIdentifyEkCertResponse = MconnGoodResponse & {
  result?: MconnControllerIdentifyEkCertResult;
};

export type MconnControllerIdentifyEkCertResult = {
  connector?: MconnControllerConnectorIdentity;
  device?: MconnControllerDeviceIdentity;
};

export type MconnControllerIdentifyLicenseKeyResponse = MconnGoodResponse & {
  result?: MconnControllerIdentifyLicenseKeyResult;
};

export type MconnControllerIdentifyLicenseKeyResult = {
  connector?: MconnControllerConnectorIdentity;
  device?: MconnControllerDeviceIdentity;
};

export type MconnControllerUpdateConnectorResponse = MconnGoodResponse & {
  result?: MconnControllerUpdateConnectorResult;
};

export type MconnControllerUpdateConnectorResult = Record<string, any>;

export type MconnControllerUpdateDeviceResponse = MconnGoodResponse & {
  result?: MconnControllerUpdateDeviceResult;
};

export type MconnControllerUpdateDeviceResult = Record<string, any>;

export type MconnControllerUpgradeSlot = {
  connector_id?: MconnUuid;
  id: number;
  started_at?: string;
};

export type MconnCreateAttestationSessionResponse = MconnGoodResponse & {
  result?: MconnControllerAttestationSession;
};

export type MconnCreateConnectorResponse = MconnGoodResponse & {
  result?: MconnAdminConnector;
};

export type MconnCustomerConnector = {
  /**
   * @x-auditable true
   */
  activated: boolean;
  device?: MconnCustomerDevice;
  id: MconnUuid;
  /**
   * @x-auditable true
   */
  interrupt_window_duration_hours: number;
  /**
   * @x-auditable true
   */
  interrupt_window_hour_of_day: number;
  /**
   * @x-auditable true
   */
  last_heartbeat?: string;
  /**
   * @x-auditable true
   */
  last_seen_version?: string;
  /**
   * @x-auditable true
   */
  last_updated: string;
  /**
   * @x-auditable true
   */
  notes: string;
  /**
   * @x-auditable true
   */
  timezone: string;
};

export type MconnCustomerConnectorCreateRequest = {
  device: MconnCustomerDeviceIdentifier;
} & MconnCustomerConnectorFields;

export type MconnCustomerConnectorCreateResponse = MconnGoodResponse & {
  result?: MconnCustomerConnector;
};

export type MconnCustomerConnectorDeleteResponse = MconnGoodResponse & {
  result?: MconnCustomerConnector;
};

export type MconnCustomerConnectorFetchResponse = MconnGoodResponse & {
  result?: MconnCustomerConnector;
};

export type MconnCustomerConnectorFields = {
  /**
   * @x-auditable true
   */
  activated?: boolean;
  /**
   * @x-auditable true
   */
  interrupt_window_duration_hours?: number;
  /**
   * @x-auditable true
   */
  interrupt_window_hour_of_day?: number;
  /**
   * @x-auditable true
   */
  notes?: string;
  /**
   * @x-auditable true
   */
  timezone?: string;
};

export type MconnCustomerConnectorListResponse = MconnGoodResponse & {
  result?: MconnCustomerConnector[];
};

export type MconnCustomerConnectorUpdateRequest = MconnCustomerConnectorFields;

export type MconnCustomerConnectorUpdateResponse = MconnGoodResponse & {
  result?: MconnCustomerConnector;
};

export type MconnCustomerDevice = {
  id: MconnUuid;
  /**
   * @x-auditable true
   */
  serial_number?: string;
};

/**
 * @maxProperties 1
 * @minProperties 1
 */
export type MconnCustomerDeviceIdentifier = {
  /**
   * @x-auditable true
   */
  id?: string;
  /**
   * @x-auditable true
   */
  serial_number?: string;
};

export type MconnCustomerEventGetSuccess = MconnEnvelope & {
  result: MconnRecordedEvent;
};

export type MconnCustomerEventsGetLatestResult = {
  count: number;
  items: MconnRecordedEvent[];
};

export type MconnCustomerEventsGetLatestSuccess = MconnEnvelope & {
  result: MconnCustomerEventsGetLatestResult;
};

export type MconnCustomerEventsGetResult = {
  count: number;
  cursor?: string;
  items: MconnEventMetadata[];
};

export type MconnCustomerEventsGetSuccess = MconnEnvelope & {
  result: MconnCustomerEventsGetResult;
};

export type MconnCustomerSnapshotGetSuccess = MconnEnvelope & {
  result: MconnSnapshot;
};

export type MconnCustomerSnapshotsGetLatestResult = {
  count: number;
  items: MconnSnapshot[];
};

export type MconnCustomerSnapshotsGetLatestSuccess = MconnEnvelope & {
  result: MconnCustomerSnapshotsGetLatestResult;
};

export type MconnCustomerSnapshotsGetResult = {
  count: number;
  cursor?: string;
  items: MconnSnapshotMetadata[];
};

export type MconnCustomerSnapshotsGetSuccess = MconnEnvelope & {
  result: MconnCustomerSnapshotsGetResult;
};

export type MconnDeleteAttestationSessionResponse = MconnGoodResponse & {
  result?: MconnControllerAttestationSession;
};

export type MconnDeleteControllerFlareResponse = MconnGoodResponse & {
  result?: MconnControllerFlare;
};

export type MconnEnvelope = {
  errors?: MconnCodedMessage[];
  messages?: MconnCodedMessage[];
  success: boolean;
};

export type MconnEvent =
  | {
      /**
       * Initialized process
       */
      k: "Init";
    }
  | {
      /**
       * Stopped process
       */
      k: "Leave";
    }
  | {
      /**
       * Started attestation
       */
      k: "StartAttestation";
    }
  | {
      /**
       * Finished attestation
       */
      k: "FinishAttestationSuccess";
    }
  | {
      /**
       * Failed attestation
       */
      k: "FinishAttestationFailure";
    }
  | {
      /**
       * Started crypt key rotation
       */
      k: "StartRotateCryptKey";
    }
  | {
      /**
       * Finished crypt key rotation
       */
      k: "FinishRotateCryptKeySuccess";
    }
  | {
      /**
       * Failed crypt key rotation
       */
      k: "FinishRotateCryptKeyFailure";
    }
  | {
      /**
       * Started PKI rotation
       */
      k: "StartRotatePki";
    }
  | {
      /**
       * Finished PKI rotation
       */
      k: "FinishRotatePkiSuccess";
    }
  | {
      /**
       * Failed PKI rotation
       */
      k: "FinishRotatePkiFailure";
    }
  | {
      /**
       * Started upgrade
       */
      k: "StartUpgrade";
      /**
       * Location of upgrade bundle
       */
      url: string;
    }
  | {
      /**
       * Finished upgrade
       */
      k: "FinishUpgradeSuccess";
    }
  | {
      /**
       * Failed upgrade
       */
      k: "FinishUpgradeFailure";
    }
  | {
      /**
       * Reconciled
       */
      k: "Reconcile";
    }
  | {
      /**
       * Configured Cloudflared tunnel
       */
      k: "ConfigureCloudflaredTunnel";
    };

export type MconnEventMetadata = {
  /**
   * Time the Event was collected (seconds since the Unix epoch)
   */
  a: number;
  /**
   * Kind
   */
  k: string;
  /**
   * Sequence number, used to order events with the same timestamp
   */
  n: number;
  /**
   * Time the Event was recorded (seconds since the Unix epoch)
   */
  t: number;
};

export type MconnGoodResponse = MconnResponse & {
  /**
   * @maxLength 0
   */
  errors?: MconnCodedMessage[];
};

export type MconnNone = Record<string, any> | null;

export type MconnPartnerDevice = {
  id: MconnUuid;
};

export type MconnPartnerDeviceRegisterResponse = MconnGoodResponse & {
  result?: MconnPartnerDevice;
};

export type MconnReadControllerConnectorTokenResponse = MconnGoodResponse & {
  /**
   * @x-sensitive true
   */
  result?: string;
};

/**
 * Recorded Event
 */
export type MconnRecordedEvent = {
  e: MconnEvent;
  /**
   * Sequence number, used to order events with the same timestamp
   */
  n: number;
  /**
   * Time the Event was recorded (seconds since the Unix epoch)
   */
  t: number;
};

export type MconnResponse = {
  messages: MconnCodedMessage[];
  success: boolean;
};

/**
 * Snapshot
 */
export type MconnSnapshot = {
  /**
   * Count of failures to reclaim space
   */
  count_reclaim_failures: number;
  /**
   * Count of reclaimed paths
   */
  count_reclaimed_paths: number;
  /**
   * Count of failed snapshot recordings
   */
  count_record_failed: number;
  /**
   * Count of failed snapshot transmissions
   */
  count_transmit_failures: number;
  /**
   * Count of processors/cores
   */
  cpu_count?: number;
  /**
   * Percentage of time over a 10 second window that tasks were stalled
   */
  cpu_pressure_10s?: number;
  /**
   * Percentage of time over a 5 minute window that tasks were stalled
   */
  cpu_pressure_300s?: number;
  /**
   * Percentage of time over a 1 minute window that tasks were stalled
   */
  cpu_pressure_60s?: number;
  /**
   * Total stall time (microseconds)
   */
  cpu_pressure_total_us?: number;
  /**
   * Time spent running a virtual CPU or guest OS (milliseconds)
   */
  cpu_time_guest_ms?: number;
  /**
   * Time spent running a niced guest (milliseconds)
   */
  cpu_time_guest_nice_ms?: number;
  /**
   * Time spent in idle state (milliseconds)
   */
  cpu_time_idle_ms?: number;
  /**
   * Time spent wait for I/O to complete (milliseconds)
   */
  cpu_time_iowait_ms?: number;
  /**
   * Time spent servicing interrupts (milliseconds)
   */
  cpu_time_irq_ms?: number;
  /**
   * Time spent in low-priority user mode (milliseconds)
   */
  cpu_time_nice_ms?: number;
  /**
   * Time spent servicing softirqs (milliseconds)
   */
  cpu_time_softirq_ms?: number;
  /**
   * Time stolen (milliseconds)
   */
  cpu_time_steal_ms?: number;
  /**
   * Time spent in system mode (milliseconds)
   */
  cpu_time_system_ms?: number;
  /**
   * Time spent in user mode (milliseconds)
   */
  cpu_time_user_ms?: number;
  dhcp_leases?: MconnSnapshotDhcpLease[];
  disks?: MconnSnapshotDisk[];
  /**
   * Name of high availability state
   */
  ha_state?: string;
  /**
   * Numeric value associated with high availability state (0 = disabled, 1 = active, 2 = standby, 3 = stopped, 4 = fault)
   */
  ha_value?: number;
  interfaces?: MconnSnapshotInterface[];
  /**
   * Percentage of time over a 10 second window that all tasks were stalled
   */
  io_pressure_full_10s?: number;
  /**
   * Percentage of time over a 5 minute window that all tasks were stalled
   */
  io_pressure_full_300s?: number;
  /**
   * Percentage of time over a 1 minute window that all tasks were stalled
   */
  io_pressure_full_60s?: number;
  /**
   * Total stall time (microseconds)
   */
  io_pressure_full_total_us?: number;
  /**
   * Percentage of time over a 10 second window that some tasks were stalled
   */
  io_pressure_some_10s?: number;
  /**
   * Percentage of time over a 3 minute window that some tasks were stalled
   */
  io_pressure_some_300s?: number;
  /**
   * Percentage of time over a 1 minute window that some tasks were stalled
   */
  io_pressure_some_60s?: number;
  /**
   * Total stall time (microseconds)
   */
  io_pressure_some_total_us?: number;
  /**
   * Boot time (seconds since Unix epoch)
   */
  kernel_btime?: number;
  /**
   * Number of context switches that the system underwent
   */
  kernel_ctxt?: number;
  /**
   * Number of forks since boot
   */
  kernel_processes?: number;
  /**
   * Number of processes blocked waiting for I/O
   */
  kernel_processes_blocked?: number;
  /**
   * Number of processes in runnable state
   */
  kernel_processes_running?: number;
  /**
   * The fifteen-minute load average
   */
  load_average_15m?: number;
  /**
   * The one-minute load average
   */
  load_average_1m?: number;
  /**
   * The five-minute load average
   */
  load_average_5m?: number;
  /**
   * Number of currently runnable kernel scheduling entities
   */
  load_average_cur?: number;
  /**
   * Number of kernel scheduling entities that currently exist on the system
   */
  load_average_max?: number;
  /**
   * Memory that has been used more recently
   */
  memory_active_bytes?: number;
  /**
   * Non-file backed huge pages mapped into user-space page tables
   */
  memory_anon_hugepages_bytes?: number;
  /**
   * Non-file backed pages mapped into user-space page tables
   */
  memory_anon_pages_bytes?: number;
  /**
   * Estimate of how much memory is available for starting new applications
   */
  memory_available_bytes?: number;
  /**
   * Memory used for block device bounce buffers
   */
  memory_bounce_bytes?: number;
  /**
   * Relatively temporary storage for raw disk blocks
   */
  memory_buffers_bytes?: number;
  /**
   * In-memory cache for files read from the disk
   */
  memory_cached_bytes?: number;
  /**
   * Free CMA (Contiguous Memory Allocator) pages
   */
  memory_cma_free_bytes?: number;
  /**
   * Total CMA (Contiguous Memory Allocator) pages
   */
  memory_cma_total_bytes?: number;
  /**
   * Total amount of memory currently available to be allocated on the system
   */
  memory_commit_limit_bytes?: number;
  /**
   * Amount of memory presently allocated on the system
   */
  memory_committed_as_bytes?: number;
  /**
   * Memory which is waiting to get written back to the disk
   */
  memory_dirty_bytes?: number;
  /**
   * The sum of LowFree and HighFree
   */
  memory_free_bytes?: number;
  /**
   * Amount of free highmem
   */
  memory_high_free_bytes?: number;
  /**
   * Total amount of highmem
   */
  memory_high_total_bytes?: number;
  /**
   * The number of huge pages in the pool that are not yet allocated
   */
  memory_hugepages_free?: number;
  /**
   * Number of huge pages for which a commitment has been made, but no allocation has yet been made
   */
  memory_hugepages_rsvd?: number;
  /**
   * Number of huge pages in the pool above the threshold
   */
  memory_hugepages_surp?: number;
  /**
   * The size of the pool of huge pages
   */
  memory_hugepages_total?: number;
  /**
   * The size of huge pages
   */
  memory_hugepagesize_bytes?: number;
  /**
   * Memory which has been less recently used
   */
  memory_inactive_bytes?: number;
  /**
   * Kernel allocations that the kernel will attempt to reclaim under memory pressure
   */
  memory_k_reclaimable_bytes?: number;
  /**
   * Amount of memory allocated to kernel stacks
   */
  memory_kernel_stack_bytes?: number;
  /**
   * Amount of free lowmem
   */
  memory_low_free_bytes?: number;
  /**
   * Total amount of lowmem
   */
  memory_low_total_bytes?: number;
  /**
   * Files which have been mapped into memory
   */
  memory_mapped_bytes?: number;
  /**
   * Amount of memory dedicated to the lowest level of page tables
   */
  memory_page_tables_bytes?: number;
  /**
   * Memory allocated to the per-cpu alloctor used to back per-cpu allocations
   */
  memory_per_cpu_bytes?: number;
  /**
   * Percentage of time over a 10 second window that all tasks were stalled
   */
  memory_pressure_full_10s?: number;
  /**
   * Percentage of time over a 5 minute window that all tasks were stalled
   */
  memory_pressure_full_300s?: number;
  /**
   * Percentage of time over a 1 minute window that all tasks were stalled
   */
  memory_pressure_full_60s?: number;
  /**
   * Total stall time (microseconds)
   */
  memory_pressure_full_total_us?: number;
  /**
   * Percentage of time over a 10 second window that some tasks were stalled
   */
  memory_pressure_some_10s?: number;
  /**
   * Percentage of time over a 5 minute window that some tasks were stalled
   */
  memory_pressure_some_300s?: number;
  /**
   * Percentage of time over a 1 minute window that some tasks were stalled
   */
  memory_pressure_some_60s?: number;
  /**
   * Total stall time (microseconds)
   */
  memory_pressure_some_total_us?: number;
  /**
   * Part of slab that can be reclaimed on memory pressure
   */
  memory_s_reclaimable_bytes?: number;
  /**
   * Part of slab that cannot be reclaimed on memory pressure
   */
  memory_s_unreclaim_bytes?: number;
  /**
   * Amount of memory dedicated to the lowest level of page tables
   */
  memory_secondary_page_tables_bytes?: number;
  /**
   * Amount of memory consumed by tmpfs
   */
  memory_shmem_bytes?: number;
  /**
   * Memory used by shmem and tmpfs, allocated with huge pages
   */
  memory_shmem_hugepages_bytes?: number;
  /**
   * Shared memory mapped into user space with huge pages
   */
  memory_shmem_pmd_mapped_bytes?: number;
  /**
   * In-kernel data structures cache
   */
  memory_slab_bytes?: number;
  /**
   * Memory swapped out and back in while still in swap file
   */
  memory_swap_cached_bytes?: number;
  /**
   * Amount of swap space that is currently unused
   */
  memory_swap_free_bytes?: number;
  /**
   * Total amount of swap space available
   */
  memory_swap_total_bytes?: number;
  /**
   * Total usable RAM
   */
  memory_total_bytes?: number;
  /**
   * Largest contiguous block of vmalloc area which is free
   */
  memory_vmalloc_chunk_bytes?: number;
  /**
   * Total size of vmalloc memory area
   */
  memory_vmalloc_total_bytes?: number;
  /**
   * Amount of vmalloc area which is used
   */
  memory_vmalloc_used_bytes?: number;
  /**
   * Memory which is actively being written back to the disk
   */
  memory_writeback_bytes?: number;
  /**
   * Memory used by FUSE for temporary writeback buffers
   */
  memory_writeback_tmp_bytes?: number;
  /**
   * Memory consumed by the zswap backend, compressed
   */
  memory_z_swap_bytes?: number;
  /**
   * Amount of anonymous memory stored in zswap, uncompressed
   */
  memory_z_swapped_bytes?: number;
  mounts?: MconnSnapshotMount[];
  netdevs?: MconnSnapshotNetdev[];
  /**
   * Number of ICMP Address Mask Reply messages received
   */
  snmp_icmp_in_addr_mask_reps?: number;
  /**
   * Number of ICMP Address Mask Request messages received
   */
  snmp_icmp_in_addr_masks?: number;
  /**
   * Number of ICMP messages received with bad checksums
   */
  snmp_icmp_in_csum_errors?: number;
  /**
   * Number of ICMP Destination Unreachable messages received
   */
  snmp_icmp_in_dest_unreachs?: number;
  /**
   * Number of ICMP Echo Reply messages received
   */
  snmp_icmp_in_echo_reps?: number;
  /**
   * Number of ICMP Echo (request) messages received
   */
  snmp_icmp_in_echos?: number;
  /**
   * Number of ICMP messages received with ICMP-specific errors
   */
  snmp_icmp_in_errors?: number;
  /**
   * Number of ICMP messages received
   */
  snmp_icmp_in_msgs?: number;
  /**
   * Number of ICMP Parameter Problem messages received
   */
  snmp_icmp_in_parm_probs?: number;
  /**
   * Number of ICMP Redirect messages received
   */
  snmp_icmp_in_redirects?: number;
  /**
   * Number of ICMP Source Quench messages received
   */
  snmp_icmp_in_src_quenchs?: number;
  /**
   * Number of ICMP Time Exceeded messages received
   */
  snmp_icmp_in_time_excds?: number;
  /**
   * Number of ICMP Address Mask Request messages received
   */
  snmp_icmp_in_timestamp_reps?: number;
  /**
   * Number of ICMP Timestamp (request) messages received
   */
  snmp_icmp_in_timestamps?: number;
  /**
   * Number of ICMP Address Mask Reply messages sent
   */
  snmp_icmp_out_addr_mask_reps?: number;
  /**
   * Number of ICMP Address Mask Request messages sent
   */
  snmp_icmp_out_addr_masks?: number;
  /**
   * Number of ICMP Destination Unreachable messages sent
   */
  snmp_icmp_out_dest_unreachs?: number;
  /**
   * Number of ICMP Echo Reply messages sent
   */
  snmp_icmp_out_echo_reps?: number;
  /**
   * Number of ICMP Echo (request) messages sent
   */
  snmp_icmp_out_echos?: number;
  /**
   * Number of ICMP messages which this entity did not send due to ICMP-specific errors
   */
  snmp_icmp_out_errors?: number;
  /**
   * Number of ICMP messages attempted to send
   */
  snmp_icmp_out_msgs?: number;
  /**
   * Number of ICMP Parameter Problem messages sent
   */
  snmp_icmp_out_parm_probs?: number;
  /**
   * Number of ICMP Redirect messages sent
   */
  snmp_icmp_out_redirects?: number;
  /**
   * Number of ICMP Source Quench messages sent
   */
  snmp_icmp_out_src_quenchs?: number;
  /**
   * Number of ICMP Time Exceeded messages sent
   */
  snmp_icmp_out_time_excds?: number;
  /**
   * Number of ICMP Timestamp Reply messages sent
   */
  snmp_icmp_out_timestamp_reps?: number;
  /**
   * Number of ICMP Timestamp (request) messages sent
   */
  snmp_icmp_out_timestamps?: number;
  /**
   * Default value of the Time-To-Live field of the IP header
   */
  snmp_ip_default_ttl?: number;
  /**
   * Number of datagrams forwarded to their final destination
   */
  snmp_ip_forw_datagrams?: number;
  /**
   * Set when acting as an IP gateway
   */
  snmp_ip_forwarding_enabled?: boolean;
  /**
   * Number of datagrams generated by fragmentation
   */
  snmp_ip_frag_creates?: number;
  /**
   * Number of datagrams discarded because fragmentation failed
   */
  snmp_ip_frag_fails?: number;
  /**
   * Number of datagrams successfully fragmented
   */
  snmp_ip_frag_oks?: number;
  /**
   * Number of input datagrams discarded due to errors in the IP address
   */
  snmp_ip_in_addr_errors?: number;
  /**
   * Number of input datagrams successfully delivered to IP user-protocols
   */
  snmp_ip_in_delivers?: number;
  /**
   * Number of input datagrams otherwise discarded
   */
  snmp_ip_in_discards?: number;
  /**
   * Number of input datagrams discarded due to errors in the IP header
   */
  snmp_ip_in_hdr_errors?: number;
  /**
   * Number of input datagrams received from interfaces
   */
  snmp_ip_in_receives?: number;
  /**
   * Number of input datagrams discarded due unknown or unsupported protocol
   */
  snmp_ip_in_unknown_protos?: number;
  /**
   * Number of output datagrams otherwise discarded
   */
  snmp_ip_out_discards?: number;
  /**
   * Number of output datagrams discarded because no route matched
   */
  snmp_ip_out_no_routes?: number;
  /**
   * Number of datagrams supplied for transmission
   */
  snmp_ip_out_requests?: number;
  /**
   * Number of failures detected by the reassembly algorithm
   */
  snmp_ip_reasm_fails?: number;
  /**
   * Number of datagrams successfully reassembled
   */
  snmp_ip_reasm_oks?: number;
  /**
   * Number of fragments received which needed to be reassembled
   */
  snmp_ip_reasm_reqds?: number;
  /**
   * Number of seconds fragments are held while awaiting reassembly
   */
  snmp_ip_reasm_timeout?: number;
  /**
   * Number of times TCP transitions to SYN-SENT from CLOSED
   */
  snmp_tcp_active_opens?: number;
  /**
   * Number of times TCP transitions to CLOSED from SYN-SENT or SYN-RCVD, plus transitions to LISTEN from SYN-RCVD
   */
  snmp_tcp_attempt_fails?: number;
  /**
   * Number of TCP connections in ESTABLISHED or CLOSE-WAIT
   */
  snmp_tcp_curr_estab?: number;
  /**
   * Number of times TCP transitions to CLOSED from ESTABLISHED or CLOSE-WAIT
   */
  snmp_tcp_estab_resets?: number;
  /**
   * Number of TCP segments received with checksum errors
   */
  snmp_tcp_in_csum_errors?: number;
  /**
   * Number of TCP segments received in error
   */
  snmp_tcp_in_errs?: number;
  /**
   * Number of TCP segments received
   */
  snmp_tcp_in_segs?: number;
  /**
   * Limit on the total number of TCP connections
   */
  snmp_tcp_max_conn?: number;
  /**
   * Number of TCP segments sent with RST flag
   */
  snmp_tcp_out_rsts?: number;
  /**
   * Number of TCP segments sent
   */
  snmp_tcp_out_segs?: number;
  /**
   * Number of times TCP transitions to SYN-RCVD from LISTEN
   */
  snmp_tcp_passive_opens?: number;
  /**
   * Number of TCP segments retransmitted
   */
  snmp_tcp_retrans_segs?: number;
  /**
   * Maximum value permitted by a TCP implementation for the retransmission timeout (milliseconds)
   */
  snmp_tcp_rto_max?: number;
  /**
   * Minimum value permitted by a TCP implementation for the retransmission timeout (milliseconds)
   */
  snmp_tcp_rto_min?: number;
  /**
   * Number of UDP datagrams delivered to UDP applications
   */
  snmp_udp_in_datagrams?: number;
  /**
   * Number of UDP datagrams failed to be delivered for reasons other than lack of application at the destination port
   */
  snmp_udp_in_errors?: number;
  /**
   * Number of UDP datagrams received for which there was not application at the destination port
   */
  snmp_udp_no_ports?: number;
  /**
   * Number of UDP datagrams sent
   */
  snmp_udp_out_datagrams?: number;
  /**
   * Boottime of the system (seconds since the Unix epoch)
   */
  system_boot_time_s?: number;
  /**
   * Time the Snapshot was recorded (seconds since the Unix epoch)
   */
  t: number;
  thermals?: MconnSnapshotThermal[];
  tunnels?: MconnSnapshotTunnel[];
  /**
   * Sum of how much time each core has spent idle
   */
  uptime_idle_ms?: number;
  /**
   * Uptime of the system, including time spent in suspend
   */
  uptime_total_ms?: number;
  /**
   * Version
   */
  v: string;
};

/**
 * Snapshot DHCP lease
 */
export type MconnSnapshotDhcpLease = {
  /**
   * Client ID of the device the IP Address was leased to
   */
  client_id: string;
  /**
   * Connector identifier
   */
  connector_id?: string;
  /**
   * Expiry time of the DHCP lease (seconds since the Unix epoch)
   */
  expiry_time: number;
  /**
   * Hostname of the device the IP Address was leased to
   */
  hostname: string;
  /**
   * Name of the network interface
   */
  interface_name: string;
  /**
   * IP Address that was leased
   */
  ip_address: string;
  /**
   * MAC Address of the device the IP Address was leased to
   */
  mac_address: string;
};

/**
 * Snapshot Disk
 */
export type MconnSnapshotDisk = {
  /**
   * Connector identifier
   */
  connector_id?: string;
  /**
   * Discards completed successfully
   */
  discards?: number;
  /**
   * Discards merged
   */
  discards_merged?: number;
  /**
   * Flushes completed successfully
   */
  flushes?: number;
  /**
   * I/Os currently in progress
   */
  in_progress: number;
  /**
   * Device major number
   */
  major: number;
  /**
   * Reads merged
   */
  merged: number;
  /**
   * Device minor number
   */
  minor: number;
  /**
   * Device name
   */
  name: string;
  /**
   * Reads completed successfully
   */
  reads: number;
  /**
   * Sectors discarded
   */
  sectors_discarded?: number;
  /**
   * Sectors read successfully
   */
  sectors_read: number;
  /**
   * Sectors written successfully
   */
  sectors_written: number;
  /**
   * Time spent discarding (milliseconds)
   */
  time_discarding_ms?: number;
  /**
   * Time spent flushing (milliseconds)
   */
  time_flushing_ms?: number;
  /**
   * Time spent doing I/Os (milliseconds)
   */
  time_in_progress_ms: number;
  /**
   * Time spent reading (milliseconds)
   */
  time_reading_ms: number;
  /**
   * Time spent writing (milliseconds)
   */
  time_writing_ms: number;
  /**
   * Weighted time spent doing I/Os (milliseconds)
   */
  weighted_time_in_progress_ms: number;
  /**
   * Writes completed
   */
  writes: number;
  /**
   * Writes merged
   */
  writes_merged: number;
};

/**
 * Snapshot Interface
 */
export type MconnSnapshotInterface = {
  /**
   * Connector identifier
   */
  connector_id?: string;
  ip_addresses?: MconnSnapshotInterfaceAddress[];
  /**
   * Name of the network interface
   */
  name: string;
  /**
   * UP/DOWN state of the network interface
   */
  operstate: string;
  /**
   * Speed of the network interface (bits per second)
   */
  speed?: number;
};

/**
 * Snapshot Interface Address
 */
export type MconnSnapshotInterfaceAddress = {
  /**
   * Connector identifier
   */
  connector_id?: string;
  /**
   * Name of the network interface
   */
  interface_name: string;
  /**
   * IP address of the network interface
   */
  ip_address: string;
};

export type MconnSnapshotMetadata = {
  /**
   * Time the Snapshot was collected (seconds since the Unix epoch)
   */
  a: number;
  /**
   * Time the Snapshot was recorded (seconds since the Unix epoch)
   */
  t: number;
};

/**
 * Snapshot Mount
 */
export type MconnSnapshotMount = {
  /**
   * Available disk size (bytes)
   */
  available_bytes?: number;
  /**
   * Connector identifier
   */
  connector_id?: string;
  /**
   * File system on disk (EXT4, NTFS, etc.)
   */
  file_system: string;
  /**
   * Determines whether the disk is read-only
   */
  is_read_only?: boolean;
  /**
   * Determines whether the disk is removable
   */
  is_removable?: boolean;
  /**
   * Kind of disk (HDD, SSD, etc.)
   */
  kind: string;
  /**
   * Path where disk is mounted
   */
  mount_point: string;
  /**
   * Name of the disk mount
   */
  name: string;
  /**
   * Total disk size (bytes)
   */
  total_bytes?: number;
};

/**
 * Snapshot Netdev
 */
export type MconnSnapshotNetdev = {
  /**
   * Connector identifier
   */
  connector_id?: string;
  /**
   * Name of the network device
   */
  name: string;
  /**
   * Total bytes received
   */
  recv_bytes: number;
  /**
   * Compressed packets received
   */
  recv_compressed: number;
  /**
   * Packets dropped
   */
  recv_drop: number;
  /**
   * Bad packets received
   */
  recv_errs: number;
  /**
   * FIFO overruns
   */
  recv_fifo: number;
  /**
   * Frame alignment errors
   */
  recv_frame: number;
  /**
   * Multicast packets received
   */
  recv_multicast: number;
  /**
   * Total packets received
   */
  recv_packets: number;
  /**
   * Total bytes transmitted
   */
  sent_bytes: number;
  /**
   * Number of packets not sent due to carrier errors
   */
  sent_carrier: number;
  /**
   * Number of collisions
   */
  sent_colls: number;
  /**
   * Number of compressed packets transmitted
   */
  sent_compressed: number;
  /**
   * Number of packets dropped during transmission
   */
  sent_drop: number;
  /**
   * Number of transmission errors
   */
  sent_errs: number;
  /**
   * FIFO overruns
   */
  sent_fifo: number;
  /**
   * Total packets transmitted
   */
  sent_packets: number;
};

/**
 * Snapshot Thermal
 */
export type MconnSnapshotThermal = {
  /**
   * Connector identifier
   */
  connector_id?: string;
  /**
   * Critical failure temperature of the component (degrees Celsius)
   */
  critical_celcius?: number;
  /**
   * Current temperature of the component (degrees Celsius)
   */
  current_celcius?: number;
  /**
   * Sensor identifier for the component
   */
  label: string;
  /**
   * Maximum temperature of the component (degrees Celsius)
   */
  max_celcius?: number;
};

/**
 * Snapshot Tunnels
 */
export type MconnSnapshotTunnel = {
  /**
   * Connector identifier
   */
  connector_id?: string;
  /**
   * Name of tunnel health state (unknown, healthy, degraded, down)
   */
  health_state: string;
  /**
   * Numeric value associated with tunnel state (0 = unknown, 1 = healthy, 2 = degraded, 3 = down)
   */
  health_value: number;
  /**
   * The tunnel interface name (i.e. xfrm1, xfrm3.99, etc.)
   */
  interface_name: string;
  /**
   * Tunnel identifier
   */
  tunnel_id: string;
};

/**
 * @x-auditable true
 */
export type MconnUuid = string;

/**
 * @example {"code":7003,"message":"No route for the URI"}
 * @minLength 1
 */
export type MqApiV4Error = {
  /**
   * @minimum 1000
   * @x-auditable true
   */
  code: number;
  /**
   * @x-auditable true
   */
  message: string;
}[];

export type MqApiV4Failure = {
  errors?: MqApiV4Error;
  messages?: MqApiV4Message;
  /**
   * Indicates if the API call was successful or not.
   *
   * @example false
   * @x-auditable true
   */
  success?: false;
};

export type MqApiV4Message = string[];

export type MqApiV4Success = {
  errors?: MqApiV4Error;
  messages?: MqApiV4Message;
  /**
   * Indicates if the API call was successful or not.
   *
   * @x-auditable true
   */
  success?: true;
};

/**
 * The maximum number of messages to include in a batch.
 *
 * @example 50
 * @x-auditable true
 */
export type MqBatchSize = number;

export type MqConsumer = MqWorkerConsumer | MqHttpConsumer;

export type MqHttpConsumer = {
  consumer_id?: MqIdentifier;
  /**
   * @x-auditable true
   */
  created_on?: string;
  queue_id?: MqIdentifier;
  settings?: {
    batch_size?: MqBatchSize;
    max_retries?: MqMaxRetries;
    retry_delay?: MqRetryDelay;
    visibility_timeout_ms?: MqVisibilityTimeout;
  };
  /**
   * @x-auditable true
   */
  type?: "http_pull";
};

/**
 * A Resource identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type MqIdentifier = string;

/**
 * An ID that represents an "in-flight" message that has been pulled from a Queue. You must hold on to this ID and use it to acknowledge this message.
 *
 * @example eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2Q0JDLUhTNTEyIn0..Q8p21d7dceR6vUfwftONdQ.JVqZgAS-Zk7MqmqccYtTHeeMElNHaOMigeWdb8LyMOg.T2_HV99CYzGaQuhTyW8RsgbnpTRZHRM6N7UoSaAKeK0
 * @x-auditable true
 */
export type MqLeaseId = string;

/**
 * Maximum number of concurrent consumers that may consume from this Queue. Set to `null` to automatically opt in to the platform's maximum (recommended).
 *
 * @example 10
 * @x-auditable true
 */
export type MqMaxConcurrency = number;

/**
 * The maximum number of retries
 *
 * @example 3
 * @x-auditable true
 */
export type MqMaxRetries = number;

/**
 * The number of milliseconds to wait for a batch to fill up before attempting to deliver it
 *
 * @example 5000
 * @x-auditable true
 */
export type MqMaxWaitTime = number;

export type MqProducer = MqWorkerProducer | MqR2Producer;

export type MqQueue = {
  consumers?: MqConsumer[];
  consumers_total_count?: number;
  /**
   * @x-auditable true
   */
  created_on?: string;
  /**
   * @x-auditable true
   */
  modified_on?: string;
  producers?: MqProducer[];
  /**
   * @x-auditable true
   */
  producers_total_count?: number;
  /**
   * @x-auditable true
   */
  queue_id?: string;
  queue_name?: MqQueueName;
  settings?: MqQueueSettings;
};

export type MqQueueBatch = {
  /**
   * The number of seconds to wait for attempting to deliver this batch to consumers
   *
   * @example text
   * @x-auditable true
   */
  delay_seconds?: number;
  messages?: MqQueueMessage[];
};

export type MqQueueMessage = MqQueueMessageText | MqQueueMessageJson;

export type MqQueueMessageJson = {
  body?: Record<string, any>;
  /**
   * @x-auditable true
   */
  content_type?: "json";
};

export type MqQueueMessageText = {
  body?: string;
  /**
   * @x-auditable true
   */
  content_type?: "text";
};

/**
 * @example example-queue
 * @x-auditable true
 */
export type MqQueueName = string;

export type MqQueuePullBatch = {
  /**
   * @example 1
   * @x-auditable true
   */
  attempts?: number;
  /**
   * @example hello world
   */
  body?: string;
  /**
   * @example b01b5594f784d0165c2985833f5660dd
   * @x-auditable true
   */
  id?: string;
  lease_id?: MqLeaseId;
  /**
   * @example {"CF-Content-Type":"text","CF-sourceMessageSource":"dash"}
   */
  metadata?: Record<string, any>;
  /**
   * @example 1710950954154
   * @x-auditable true
   */
  timestamp_ms?: number;
}[];

export type MqQueueSettings = {
  /**
   * Number of seconds to delay delivery of all messages to consumers.
   *
   * @example 5
   * @x-auditable true
   */
  delivery_delay?: number;
  /**
   * Indicates if message delivery to consumers is currently paused.
   *
   * @example true
   * @x-auditable true
   */
  delivery_paused?: boolean;
  /**
   * Number of seconds after which an unconsumed message will be delayed.
   *
   * @example 345600
   * @x-auditable true
   */
  message_retention_period?: number;
};

export type MqR2Producer = {
  /**
   * @x-auditable true
   */
  bucket_name?: string;
  /**
   * @x-auditable true
   */
  type?: "r2_bucket";
};

/**
 * The number of seconds to delay before making the message available for another attempt.
 *
 * @example 10
 * @x-auditable true
 */
export type MqRetryDelay = number;

/**
 * Name of a Worker
 *
 * @example my-consumer-worker
 * @x-auditable true
 */
export type MqScriptName = string;

/**
 * The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
 *
 * @example 6000
 * @x-auditable true
 */
export type MqVisibilityTimeout = number;

export type MqWorkerConsumer = {
  consumer_id?: MqIdentifier;
  /**
   * @x-auditable true
   */
  created_on?: string;
  queue_id?: MqIdentifier;
  /**
   * Name of a Worker
   *
   * @example my-consumer-worker
   * @x-auditable true
   */
  script?: MqScriptName & string;
  /**
   * Name of a Worker
   *
   * @x-auditable true
   * @example my-consumer-worker
   */
  script_name?: MqScriptName & string;
  settings?: {
    batch_size?: MqBatchSize;
    max_concurrency?: MqMaxConcurrency;
    max_retries?: MqMaxRetries;
    max_wait_time_ms?: MqMaxWaitTime;
    retry_delay?: MqRetryDelay;
  };
  /**
   * @x-auditable true
   */
  type?: "worker";
};

export type MqWorkerProducer = {
  /**
   * @x-auditable true
   */
  script?: string;
  /**
   * @x-auditable true
   */
  type?: "worker";
};

/**
 * Customer account tag
 */
export type NscAccountTag = string;

/**
 * Bandwidth structure as visible through the customer-facing API.
 */
export type NscApiBandwidth =
  | "50M"
  | "100M"
  | "200M"
  | "300M"
  | "400M"
  | "500M"
  | "1G"
  | "2G"
  | "5G"
  | "10G"
  | "20G"
  | "50G";

export type NscBgpControl = {
  /**
   * ASN used on the customer end of the BGP session
   *
   * @format int32
   * @minimum 0
   */
  customer_asn: number;
  /**
   * Extra set of static prefixes to advertise to the customer's end of the session
   *
   * @example 192.168.3.4/31
   */
  extra_prefixes: string[];
  /**
   * MD5 key to use for session authentication.
   *
   * Note that *this is not a security measure*. MD5 is not a valid security mechanism, and the
   * key is not treated as a secret value. This is *only* supported for preventing
   * misconfiguration, not for defending against malicious attacks.
   *
   * The MD5 key, if set, must be of non-zero length and consist only of the following types of
   * character:
   *
   * * ASCII alphanumerics: `[a-zA-Z0-9]`
   * * Special characters in the set `'!@#$%^&*()+[]{}<>/.,;:_-~`= \|`
   *
   * In other words, MD5 keys may contain any printable ASCII character aside from newline (0x0A),
   * quotation mark (`"`), vertical tab (0x0B), carriage return (0x0D), tab (0x09), form feed
   * (0x0C), and the question mark (`?`). Requests specifying an MD5 key with one or more of
   * these disallowed characters will be rejected.
   */
  md5_key?: string | null;
};

/**
 * A Cloudflare site name.
 */
export type NscCloudflareSite = string;

export type NscCni = {
  account: NscAccountTag;
  bgp?: NscBgpControl;
  /**
   * Customer end of the point-to-point link
   *
   * This should always be inside the same prefix as `p2p_ip`.
   *
   * @example 192.168.3.4/31
   * @format A.B.C.D/N
   */
  cust_ip: string;
  /**
   * @format uuid
   */
  id: string;
  /**
   * Interconnect identifier hosting this CNI
   */
  interconnect: string;
  magic: NscMagicSettings;
  /**
   * Cloudflare end of the point-to-point link
   *
   * @example 192.168.3.4/31
   * @format A.B.C.D/N
   */
  p2p_ip: string;
};

export type NscCniCreate = {
  account: NscAccountTag;
  bgp?: NscBgpControl;
  interconnect: string;
  magic: NscMagicSettings;
};

export type NscCniList = {
  items: NscCni[];
  /**
   * @format int32
   */
  next?: number | null;
};

export type NscFacilityInfo = {
  address: string[];
  name: string;
};

export type NscInterconnect =
  | (Omit<NscInterconnectPhysicalBody, "type"> & {
      type: "direct";
    })
  | (Omit<NscInterconnectGcpPartnerBody, "type"> & {
      type: "gcp_partner";
    });

export type NscInterconnectCreate =
  | (Omit<NscInterconnectCreatePhysicalBody, "type"> & {
      type: "direct";
    })
  | (Omit<NscInterconnectCreateGcpPartnerBody, "type"> & {
      type: "gcp_partner";
    });

export type NscInterconnectCreateGcpPartnerBody = {
  account?: string;
  type?: string;
  bandwidth: NscApiBandwidth;
  /**
   * Pairing key provided by GCP
   */
  pairing_key: string;
};

export type NscInterconnectCreatePhysicalBody = {
  account: string;
  type?: string;
  /**
   * @format uuid
   */
  slot_id: string;
  speed?: string | null;
};

export type NscInterconnectList = {
  items: NscInterconnect[];
  /**
   * @format int32
   */
  next?: number | null;
};

export type NscInterconnectGcpPartnerBody = {
  account: string;
  name: string;
  owner?: string;
  type?: string;
  region: string;
};

export type NscInterconnectPhysicalBody = {
  account?: string;
  name?: string;
  owner?: string;
  type?: string;
  facility: NscFacilityInfo;
  site: NscCloudflareSite;
  /**
   * @format uuid
   */
  slot_id: string;
  speed: string;
};

export type NscMagicSettings = {
  conduit_name: string;
  description: string;
  /**
   * @format int32
   * @minimum 0
   */
  mtu: number;
};

export type NscSettings = {
  /**
   * @format int32
   * @minimum 0
   */
  default_asn: number;
};

export type NscSettingsRequest = {
  /**
   * @format int32
   * @minimum 0
   */
  default_asn?: number | null;
};

export type NscSlotInfo = {
  account?: NscAccountTag;
  facility: NscFacilityInfo;
  /**
   * Slot ID
   *
   * @format uuid
   */
  id: string;
  /**
   * Whether the slot is occupied or not
   */
  occupied: boolean;
  site: string;
  speed: string;
};

export type NscSlotList = {
  items: NscSlotInfo[];
  /**
   * @format int32
   */
  next?: number | null;
};

export type NscStatusInfo =
  | {
      state: "Pending";
    }
  | {
      /**
       * Diagnostic information, if available
       */
      reason?: string | null;
      state: "Down";
    }
  | {
      /**
       * Diagnostic information, if available
       */
      reason?: string | null;
      state: "Unhealthy";
    }
  | {
      state: "Healthy";
    };

export type ObservatoryApiResponseCollection = ObservatoryApiResponseCommon;

export type ObservatoryApiResponseCommon = {
  errors: ObservatoryMessages;
  messages: ObservatoryMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   * @x-auditable true
   */
  success: boolean;
};

export type ObservatoryApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: ObservatorySchemasMessages;
  messages: ObservatorySchemasMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type ObservatoryApiResponseSingle = ObservatoryApiResponseCommon;

export type ObservatoryAvailabilities = {
  quota?: {
    /**
     * Cloudflare plan.
     *
     * @example free
     * @x-auditable true
     */
    plan?: string;
    /**
     * The number of tests available per plan.
     */
    quotasPerPlan?: {
      value?: ObservatoryPlanPropertiesInfo;
    };
    /**
     * The number of remaining schedules available.
     *
     * @example 1
     * @x-auditable true
     */
    remainingSchedules?: number;
    /**
     * The number of remaining tests available.
     *
     * @example 30
     * @x-auditable true
     */
    remainingTests?: number;
    /**
     * The number of schedules available per plan.
     */
    scheduleQuotasPerPlan?: {
      value?: ObservatoryPlanPropertiesInfo;
    };
  };
  regions?: ObservatoryLabeledRegion[];
  /**
   * Available regions.
   */
  regionsPerPlan?: {
    business?: ObservatoryLabeledRegion[];
    enterprise?: ObservatoryLabeledRegion[];
    free?: ObservatoryLabeledRegion[];
    pro?: ObservatoryLabeledRegion[];
  };
};

export type ObservatoryAvailabilitiesResponse = ObservatoryApiResponseSingle & {
  result?: ObservatoryAvailabilities;
};

export type ObservatoryCountResponse = ObservatoryApiResponseSingle & {
  result?: {
    /**
     * Number of items affected.
     *
     * @example 1
     * @x-auditable true
     */
    count?: number;
  };
};

export type ObservatoryCreateScheduleResponse = ObservatoryApiResponseSingle & {
  result?: {
    schedule?: ObservatorySchedule;
    test?: ObservatoryPageTest;
  };
};

/**
 * The type of device.
 *
 * @example DESKTOP
 * @x-auditable true
 */
export type ObservatoryDeviceType = "DESKTOP" | "MOBILE";

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type ObservatoryIdentifier = string;

/**
 * A test region with a label.
 */
export type ObservatoryLabeledRegion = {
  /**
   * @example Iowa, USA
   * @x-auditable true
   */
  label?: string;
  value?: ObservatoryRegion;
};

/**
 * The error code of the Lighthouse result.
 *
 * @example NOT_REACHABLE
 * @x-auditable true
 */
export type ObservatoryLighthouseErrorCode =
  | "NOT_REACHABLE"
  | "DNS_FAILURE"
  | "NOT_HTML"
  | "LIGHTHOUSE_TIMEOUT"
  | "UNKNOWN";

/**
 * The Lighthouse report.
 */
export type ObservatoryLighthouseReport = {
  /**
   * Cumulative Layout Shift.
   *
   * @example 100
   * @x-auditable true
   */
  cls?: number;
  deviceType?: ObservatoryDeviceType;
  error?: {
    code?: ObservatoryLighthouseErrorCode;
    /**
     * Detailed error message.
     *
     * @example Details: net::ERR_CONNECTION_CLOSED
     * @x-auditable true
     */
    detail?: string;
    /**
     * The final URL displayed to the user.
     *
     * @example example.com
     * @x-auditable true
     */
    finalDisplayedUrl?: string;
  };
  /**
   * First Contentful Paint.
   *
   * @example 100
   * @x-auditable true
   */
  fcp?: number;
  /**
   * The URL to the full Lighthouse JSON report.
   *
   * @x-auditable true
   */
  jsonReportUrl?: string;
  /**
   * Largest Contentful Paint.
   *
   * @example 100
   * @x-auditable true
   */
  lcp?: number;
  /**
   * The Lighthouse performance score.
   *
   * @example 90
   * @x-auditable true
   */
  performanceScore?: number;
  /**
   * Speed Index.
   *
   * @example 100
   * @x-auditable true
   */
  si?: number;
  state?: ObservatoryLighthouseState;
  /**
   * Total Blocking Time.
   *
   * @example 100
   * @x-auditable true
   */
  tbt?: number;
  /**
   * Time To First Byte.
   *
   * @example 100
   * @x-auditable true
   */
  ttfb?: number;
  /**
   * Time To Interactive.
   *
   * @example 100
   * @x-auditable true
   */
  tti?: number;
};

/**
 * The state of the Lighthouse report.
 *
 * @example COMPLETE
 * @x-auditable true
 */
export type ObservatoryLighthouseState = "RUNNING" | "COMPLETE" | "FAILED";

export type ObservatoryMessages = {
  /**
   * @minimum 1000
   * @x-auditable true
   */
  code: number;
  /**
   * @x-auditable true
   */
  message: string;
}[];

export type ObservatoryPageTestResponseCollection =
  ObservatoryApiResponseCollection & {
    result?: ObservatoryPageTest[];
  } & {
    result_info?: ObservatoryResultInfo;
  };

export type ObservatoryPageTestResponseSingle = ObservatoryApiResponseSingle & {
  result?: ObservatoryPageTest;
};

export type ObservatoryPageTest = {
  date?: ObservatoryTimestamp;
  desktopReport?: ObservatoryLighthouseReport;
  id?: ObservatoryUuid;
  mobileReport?: ObservatoryLighthouseReport;
  region?: ObservatoryLabeledRegion;
  scheduleFrequency?: ObservatoryScheduleFrequency;
  url?: ObservatoryUrl;
};

export type ObservatoryPagesResponseCollection =
  ObservatoryApiResponseCollection & {
    result?: {
      region?: ObservatoryLabeledRegion;
      scheduleFrequency?: ObservatoryScheduleFrequency;
      tests?: ObservatoryPageTest[];
      url?: ObservatoryUrl;
    }[];
  };

/**
 * Counts per account plan.
 */
export type ObservatoryPlanPropertiesInfo = {
  /**
   * @example 1
   * @x-auditable true
   */
  business?: number;
  /**
   * @example 1
   * @x-auditable true
   */
  enterprise?: number;
  /**
   * @example 1
   * @x-auditable true
   */
  free?: number;
  /**
   * @example 1
   * @x-auditable true
   */
  pro?: number;
};

/**
 * A test region.
 *
 * @example us-central1
 * @x-auditable true
 */
export type ObservatoryRegion =
  | "asia-east1"
  | "asia-northeast1"
  | "asia-northeast2"
  | "asia-south1"
  | "asia-southeast1"
  | "australia-southeast1"
  | "europe-north1"
  | "europe-southwest1"
  | "europe-west1"
  | "europe-west2"
  | "europe-west3"
  | "europe-west4"
  | "europe-west8"
  | "europe-west9"
  | "me-west1"
  | "southamerica-east1"
  | "us-central1"
  | "us-east1"
  | "us-east4"
  | "us-south1"
  | "us-west1";

export type ObservatoryResultInfo = {
  /**
   * @example 5
   * @x-auditable true
   */
  count?: number;
  /**
   * @example 1
   * @x-auditable true
   */
  page?: number;
  /**
   * @example 5
   * @x-auditable true
   */
  per_page?: number;
  /**
   * @example 3
   * @x-auditable true
   */
  total_count?: number;
};

/**
 * The test schedule.
 */
export type ObservatorySchedule = {
  frequency?: ObservatoryScheduleFrequency;
  region?: ObservatoryRegion;
  url?: ObservatoryUrl;
};

export type ObservatoryScheduleResponseSingle = ObservatoryApiResponseSingle & {
  result?: ObservatorySchedule;
};

/**
 * The frequency of the test.
 *
 * @example DAILY
 * @x-auditable true
 */
export type ObservatoryScheduleFrequency = "DAILY" | "WEEKLY";

export type ObservatorySchemasMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type ObservatoryTimestamp = string;

export type ObservatoryTrend = {
  /**
   * Cumulative Layout Shift trend.
   */
  cls?: (number | null)[];
  /**
   * First Contentful Paint trend.
   */
  fcp?: (number | null)[];
  /**
   * Largest Contentful Paint trend.
   */
  lcp?: (number | null)[];
  /**
   * The Lighthouse score trend.
   */
  performanceScore?: (number | null)[];
  /**
   * Speed Index trend.
   */
  si?: (number | null)[];
  /**
   * Total Blocking Time trend.
   */
  tbt?: (number | null)[];
  /**
   * Time To First Byte trend.
   */
  ttfb?: (number | null)[];
  /**
   * Time To Interactive trend.
   */
  tti?: (number | null)[];
};

export type ObservatoryTrendResponse = ObservatoryApiResponseSingle & {
  result?: ObservatoryTrend;
};

/**
 * A URL.
 *
 * @example example.com
 * @x-auditable true
 */
export type ObservatoryUrl = string;

/**
 * UUID.
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 * @x-auditable true
 */
export type ObservatoryUuid = string;

export type PageShieldApiGetResponseCollection = PageShieldApiResponseCommon & {
  result?: Record<string, any> | null;
};

export type PageShieldApiListResponseCollection =
  PageShieldApiResponseCommon & {
    result_info: PageShieldResultInfo;
  };

export type PageShieldApiResponseCommon = {
  errors?: PageShieldMessages;
  messages?: PageShieldMessages;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type PageShieldApiResponseCommonFailure = {
  errors: PageShieldMessages;
  messages?: PageShieldMessages;
  result?: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

export type PageShieldApiResponseSingle = PageShieldApiResponseCommon & {
  result?: Record<string, any> | any[] | string;
};

export type PageShieldConnection = {
  /**
   * @example 2021-08-18T10:51:10.09615Z
   * @format date-time
   */
  added_at: string;
  /**
   * @example false
   */
  domain_reported_malicious?: boolean;
  /**
   * @example blog.cloudflare.com/page
   */
  first_page_url?: string;
  /**
   * @example 2021-08-18T10:51:08Z
   * @format date-time
   */
  first_seen_at: string;
  /**
   * @example blog.cloudflare.com
   */
  host: string;
  id: PageShieldId;
  /**
   * @example 2021-09-02T09:57:54Z
   * @format date-time
   */
  last_seen_at: string;
  /**
   * @example Malware
   */
  malicious_domain_categories?: string[];
  /**
   * @example Malware
   */
  malicious_url_categories?: string[];
  /**
   * @example blog.cloudflare.com/page1
   * @example blog.cloudflare.com/page2
   */
  page_urls?: string[];
  /**
   * @example https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.6.0/js/bootstrap.min.js
   */
  url: string;
  /**
   * @example false
   */
  url_contains_cdn_cgi_path: boolean;
  /**
   * @example false
   */
  url_reported_malicious?: boolean;
};

export type PageShieldCookie = {
  /**
   * @example cloudflare.com
   */
  domain_attribute?: string;
  /**
   * @example 2021-10-02T09:57:54Z
   * @format date-time
   */
  expires_attribute?: string;
  /**
   * @example 2021-08-18T10:51:08Z
   * @format date-time
   */
  first_seen_at: string;
  /**
   * @example blog.cloudflare.com
   */
  host: string;
  /**
   * @example true
   */
  http_only_attribute?: boolean;
  id: PageShieldId;
  /**
   * @example 2021-09-02T09:57:54Z
   * @format date-time
   */
  last_seen_at: string;
  /**
   * @example 3600
   */
  max_age_attribute?: number;
  /**
   * @example session_id
   */
  name: string;
  /**
   * @example blog.cloudflare.com/page1
   * @example blog.cloudflare.com/page2
   */
  page_urls?: string[];
  /**
   * @example /
   */
  path_attribute?: string;
  /**
   * @example strict
   */
  same_site_attribute?: "lax" | "strict" | "none";
  /**
   * @example true
   */
  secure_attribute?: boolean;
  /**
   * @example first_party
   */
  type: "first_party" | "unknown";
};

/**
 * The cryptomining score of the JavaScript content.
 *
 * @maximum 99
 * @minimum 1
 */
export type PageShieldCryptominingScore = number | null;

/**
 * The dataflow score of the JavaScript content.
 *
 * @maximum 99
 * @minimum 1
 */
export type PageShieldDataflowScore = number | null;

/**
 * When true, indicates that Page Shield is enabled.
 *
 * @example true
 * @x-auditable true
 */
export type PageShieldEnabled = boolean;

/**
 * The timestamp of when the script was last fetched.
 */
export type PageShieldFetchedAt = string | null;

export type PageShieldGetZoneConnectionResponse =
  PageShieldApiGetResponseCollection & {
    result: PageShieldConnection;
  };

export type PageShieldGetZoneCookieResponse =
  PageShieldApiGetResponseCollection & {
    result: PageShieldCookie;
  };

export type PageShieldGetZonePolicyResponse =
  PageShieldApiGetResponseCollection & {
    result: PageShieldPolicyWithId;
  };

export type PageShieldGetZoneScriptResponse =
  PageShieldApiGetResponseCollection & {
    result: PageShieldScript & {
      /**
       * @example {"cryptomining_score":20,"dataflow_score":2,"fetched_at":"2021-08-18T10:51:08Z","hash":"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b423","js_integrity_score":2,"magecart_score":10,"malware_score":5,"obfuscation_score":10}
       */
      versions?: PageShieldVersion[] | null;
    };
  };

export type PageShieldGetZoneSettingsResponse = {
  enabled: PageShieldEnabled;
  updated_at: PageShieldUpdatedAt;
  use_cloudflare_reporting_endpoint: PageShieldUseCloudflareReportingEndpoint;
  use_connection_url_path: PageShieldUseConnectionUrlPath;
};

/**
 * The computed hash of the analyzed script.
 *
 * @maxLength 64
 * @minLength 64
 */
export type PageShieldHash = string | null;

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type PageShieldId = string;

/**
 * The integrity score of the JavaScript content.
 *
 * @maximum 99
 * @minimum 1
 */
export type PageShieldJsIntegrityScore = number | null;

export type PageShieldListZoneConnectionsResponse =
  PageShieldApiListResponseCollection & {
    result?: PageShieldConnection[];
  };

export type PageShieldListZoneCookiesResponse =
  PageShieldApiListResponseCollection & {
    result: PageShieldCookie[];
  };

export type PageShieldListZonePoliciesResponse =
  PageShieldApiListResponseCollection & {
    result: PageShieldPolicyWithId[];
  };

export type PageShieldListZoneScriptsResponse =
  PageShieldApiListResponseCollection & {
    result: PageShieldScript[];
  };

/**
 * The magecart score of the JavaScript content.
 *
 * @maximum 99
 * @minimum 1
 */
export type PageShieldMagecartScore = number | null;

/**
 * The malware score of the JavaScript content.
 *
 * @maximum 99
 * @minimum 1
 */
export type PageShieldMalwareScore = number | null;

export type PageShieldMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * The obfuscation score of the JavaScript content.
 *
 * @maximum 99
 * @minimum 1
 */
export type PageShieldObfuscationScore = number | null;

export type PageShieldPolicy = {
  action: PageShieldPolicyAction;
  description: PageShieldPolicyDescription;
  enabled: PageShieldPolicyEnabled;
  expression: PageShieldPolicyExpression;
  value: PageShieldPolicyValue;
};

/**
 * The action to take if the expression matches
 *
 * @example allow
 * @x-auditable true
 */
export type PageShieldPolicyAction = "allow" | "log";

/**
 * A description for the policy
 *
 * @example Checkout page CSP policy
 * @x-auditable true
 */
export type PageShieldPolicyDescription = string;

/**
 * Whether the policy is enabled
 *
 * @example true
 * @x-auditable true
 */
export type PageShieldPolicyEnabled = boolean;

/**
 * The expression which must match for the policy to be applied, using the Cloudflare Firewall rule expression syntax
 *
 * @example ends_with(http.request.uri.path, "/checkout")
 * @x-auditable true
 */
export type PageShieldPolicyExpression = string;

/**
 * The policy which will be applied
 *
 * @example script-src 'none';
 * @x-auditable true
 */
export type PageShieldPolicyValue = string;

export type PageShieldPolicyWithId = PageShieldPolicy & {
  id: PageShieldId;
};

export type PageShieldResultInfo = {
  /**
   * Total number of results for the requested service
   *
   * @example 1
   */
  count: number;
  /**
   * Current page within paginated list of results
   *
   * @example 1
   */
  page: number;
  /**
   * Number of results per page of results
   *
   * @example 20
   */
  per_page: number;
  /**
   * Total results available without any search parameters
   *
   * @example 2000
   */
  total_count: number;
  /**
   * Total number of pages
   *
   * @example 100
   */
  total_pages: number;
};

export type PageShieldScript = {
  /**
   * @example 2021-08-18T10:51:10.09615Z
   * @format date-time
   */
  added_at: string;
  cryptomining_score?: PageShieldCryptominingScore;
  dataflow_score?: PageShieldDataflowScore;
  /**
   * @example false
   */
  domain_reported_malicious?: boolean;
  fetched_at?: PageShieldFetchedAt;
  /**
   * @example blog.cloudflare.com/page
   */
  first_page_url?: string;
  /**
   * @example 2021-08-18T10:51:08Z
   * @format date-time
   */
  first_seen_at: string;
  hash?: PageShieldHash;
  /**
   * @example blog.cloudflare.com
   */
  host: string;
  id: PageShieldId;
  js_integrity_score?: PageShieldJsIntegrityScore;
  /**
   * @example 2021-09-02T09:57:54Z
   * @format date-time
   */
  last_seen_at: string;
  magecart_score?: PageShieldMagecartScore;
  /**
   * @example Malware
   */
  malicious_domain_categories?: string[];
  /**
   * @example Malware
   */
  malicious_url_categories?: string[];
  malware_score?: PageShieldMalwareScore;
  obfuscation_score?: PageShieldObfuscationScore;
  /**
   * @example blog.cloudflare.com/page1
   * @example blog.cloudflare.com/page2
   */
  page_urls?: string[];
  /**
   * @example https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.6.0/js/bootstrap.min.js
   */
  url: string;
  /**
   * @example false
   */
  url_contains_cdn_cgi_path: boolean;
  /**
   * @example false
   */
  url_reported_malicious?: boolean;
};

export type PageShieldUpdateZoneSettingsResponse = {
  enabled: PageShieldEnabled;
  updated_at: PageShieldUpdatedAt;
  use_cloudflare_reporting_endpoint: PageShieldUseCloudflareReportingEndpoint;
  use_connection_url_path: PageShieldUseConnectionUrlPath;
};

/**
 * The timestamp of when Page Shield was last updated.
 *
 * @example 2022-10-12T17:56:52.083582+01:00
 * @x-auditable true
 */
export type PageShieldUpdatedAt = string;

/**
 * When true, CSP reports will be sent to https://csp-reporting.cloudflare.com/cdn-cgi/script_monitor/report
 *
 * @example true
 * @x-auditable true
 */
export type PageShieldUseCloudflareReportingEndpoint = boolean;

/**
 * When true, the paths associated with connections URLs will also be analyzed.
 *
 * @example true
 * @x-auditable true
 */
export type PageShieldUseConnectionUrlPath = boolean;

/**
 * The version of the analyzed script.
 */
export type PageShieldVersion = {
  cryptomining_score?: PageShieldCryptominingScore;
  dataflow_score?: PageShieldDataflowScore;
  fetched_at?: PageShieldFetchedAt;
  hash?: PageShieldHash;
  js_integrity_score?: PageShieldJsIntegrityScore;
  magecart_score?: PageShieldMagecartScore;
  malware_score?: PageShieldMalwareScore;
  obfuscation_score?: PageShieldObfuscationScore;
};

export type PageShieldZoneSettingsResponseSingle =
  PageShieldApiResponseSingle & {
    result?: Record<string, any>;
  };

export type PagesApiResponseCommon = {
  errors: PagesMessages;
  messages: PagesMessages;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: false | true;
};

export type PagesApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI."}
   * @minLength 1
   */
  errors: PagesMessages;
  messages: PagesMessages;
  result: Record<string, any> | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type PagesApiResponsePagination = {
  result_info?: {
    /**
     * The number of items on the current page.
     *
     * @example 1
     */
    count: number;
    /**
     * The page currently being requested.
     *
     * @example 1
     */
    page: number;
    /**
     * The number of items per page being returned.
     *
     * @example 100
     */
    per_page: number;
    /**
     * The total count of items.
     *
     * @example 1
     */
    total_count: number;
    /**
     * The total count of pages.
     *
     * @example 1
     */
    total_pages?: number;
  };
};

export type PagesApiResponseSingle = PagesApiResponseCommon & {
  result?: Record<string, any> | null;
};

/**
 * Configs for the project build process.
 */
export type PagesBuildConfig = {
  /**
   * Enable build caching for the project.
   *
   * @example true
   * @x-auditable true
   */
  build_caching?: boolean | null;
  /**
   * Command used to build project.
   *
   * @example npm run build
   * @x-auditable true
   */
  build_command?: string | null;
  /**
   * Output directory of the build.
   *
   * @example build
   * @x-auditable true
   */
  destination_dir?: string | null;
  /**
   * Directory to run the command.
   *
   * @example /
   * @x-auditable true
   */
  root_dir?: string | null;
  /**
   * The classifying tag for analytics.
   *
   * @example cee1c73f6e4743d0b5e6bb1a0bcaabcc
   * @x-auditable true
   */
  web_analytics_tag?: string | null;
  /**
   * The auth token for analytics.
   *
   * @example 021e1057c18547eca7b79f2516f06o7x
   * @x-sensitive true
   */
  web_analytics_token?: string | null;
};

export type PagesDeploymentListResponse = PagesApiResponseCommon &
  PagesApiResponsePagination & {
    result?: PagesDeployments[];
  };

export type PagesDeploymentNewDeployment = PagesApiResponseCommon & {
  result?: PagesDeployments;
};

export type PagesDeploymentResponseDetails = PagesApiResponseCommon & {
  result?: PagesDeployments;
};

export type PagesDeploymentResponseLogs = PagesApiResponseCommon & {
  /**
   * @example {"data":[{"line":"Cloning repository...","ts":"2021-04-20T19:35:29.0749819Z"},{"line":"From https://github.com/cloudflare/example","ts":"2021-04-20T19:35:30.0749819Z"},{"line":" * branch            209c5bb11d89533f426b2f8469bcae12fdccf71b -> FETCH_HEAD","ts":"2021-04-20T19:35:30.0749819Z"},{"line":"","ts":"2021-04-20T19:35:30.0749819Z"},{"line":"HEAD is now at 209c5bb Update index.html","ts":"2021-04-20T19:35:30.0749819Z"},{"line":"","ts":"2021-04-20T19:35:30.0749819Z"},{"line":"","ts":"2021-04-20T19:35:30.0749819Z"},{"line":"Success: Finished cloning repository files","ts":"2021-04-20T19:35:30.0749819Z"},{"line":"Installing dependencies","ts":"2021-04-20T19:35:59.0749819Z"},{"line":"Python version set to 2.7","ts":"2021-04-20T19:35:59.0931208Z"},{"line":"v12.18.0 is already installed.","ts":"2021-04-20T19:36:02.2369501Z"},{"line":"Now using node v12.18.0 (npm v6.14.4)","ts":"2021-04-20T19:36:02.6028886Z"},{"line":"Started restoring cached build plugins","ts":"2021-04-20T19:36:02.624555Z"},{"line":"Finished restoring cached build plugins","ts":"2021-04-20T19:36:02.6340688Z"},{"line":"Attempting ruby version 2.7.1, read from environment","ts":"2021-04-20T19:36:02.963095Z"},{"line":"Using ruby version 2.7.1","ts":"2021-04-20T19:36:04.2236084Z"},{"line":"Using PHP version 5.6","ts":"2021-04-20T19:36:04.5450152Z"},{"line":"5.2 is already installed.","ts":"2021-04-20T19:36:04.5740509Z"},{"line":"Using Swift version 5.2","ts":"2021-04-20T19:36:04.577035Z"},{"line":"Installing Hugo 0.54.0","ts":"2021-04-20T19:36:04.5771615Z"},{"line":"Hugo Static Site Generator v0.54.0-B1A82C61A/extended linux/amd64 BuildDate: 2019-02-01T10:04:38Z","ts":"2021-04-20T19:36:05.4786868Z"},{"line":"Started restoring cached go cache","ts":"2021-04-20T19:36:05.4794366Z"},{"line":"Finished restoring cached go cache","ts":"2021-04-20T19:36:05.481977Z"},{"line":"go version go1.14.4 linux/amd64","ts":"2021-04-20T19:36:05.9049776Z"},{"line":"go version go1.14.4 linux/amd64","ts":"2021-04-20T19:36:05.9086053Z"},{"line":"Installing missing commands","ts":"2021-04-20T19:36:05.9163568Z"},{"line":"Verify run directory","ts":"2021-04-20T19:36:05.9163934Z"},{"line":"Executing user command: echo \"skipping build step: no build command specified\"","ts":"2021-04-20T19:36:05.9164636Z"},{"line":"skipping build step: no build command specified","ts":"2021-04-20T19:36:05.9165087Z"},{"line":"Finished","ts":"2021-04-20T19:36:05.917412Z"}],"includes_container_logs":true,"total":30}
   */
  result?: {
    data?: {
      line?: string;
      ts?: string;
    }[];
    includes_container_logs?: boolean;
    total?: number;
  };
};

export type PagesDeploymentResponseStageLogs = PagesApiResponseCommon & {
  /**
   * @example {"data":[{"id":15,"message":"Installing dependencies","timestamp":"2021-04-20T19:35:59.0749819Z"},{"id":16,"message":"Python version set to 2.7","timestamp":"2021-04-20T19:35:59.0931208Z"},{"id":17,"message":"v12.18.0 is already installed.","timestamp":"2021-04-20T19:36:02.2369501Z"},{"id":18,"message":"Now using node v12.18.0 (npm v6.14.4)","timestamp":"2021-04-20T19:36:02.6028886Z"},{"id":19,"message":"Started restoring cached build plugins","timestamp":"2021-04-20T19:36:02.624555Z"},{"id":20,"message":"Finished restoring cached build plugins","timestamp":"2021-04-20T19:36:02.6340688Z"},{"id":21,"message":"Attempting ruby version 2.7.1, read from environment","timestamp":"2021-04-20T19:36:02.963095Z"},{"id":22,"message":"Using ruby version 2.7.1","timestamp":"2021-04-20T19:36:04.2236084Z"},{"id":23,"message":"Using PHP version 5.6","timestamp":"2021-04-20T19:36:04.5450152Z"},{"id":24,"message":"5.2 is already installed.","timestamp":"2021-04-20T19:36:04.5740509Z"},{"id":25,"message":"Using Swift version 5.2","timestamp":"2021-04-20T19:36:04.577035Z"},{"id":26,"message":"Installing Hugo 0.54.0","timestamp":"2021-04-20T19:36:04.5771615Z"},{"id":27,"message":"Hugo Static Site Generator v0.54.0-B1A82C61A/extended linux/amd64 BuildDate: 2019-02-01T10:04:38Z","timestamp":"2021-04-20T19:36:05.4786868Z"},{"id":28,"message":"Started restoring cached go cache","timestamp":"2021-04-20T19:36:05.4794366Z"},{"id":29,"message":"Finished restoring cached go cache","timestamp":"2021-04-20T19:36:05.481977Z"},{"id":30,"message":"go version go1.14.4 linux/amd64","timestamp":"2021-04-20T19:36:05.9049776Z"},{"id":31,"message":"go version go1.14.4 linux/amd64","timestamp":"2021-04-20T19:36:05.9086053Z"},{"id":32,"message":"Installing missing commands","timestamp":"2021-04-20T19:36:05.9163568Z"},{"id":33,"message":"Verify run directory","timestamp":"2021-04-20T19:36:05.9163934Z"},{"id":34,"message":"Executing user command: echo \"skipping build step: no build command specified\"","timestamp":"2021-04-20T19:36:05.9164636Z"},{"id":35,"message":"skipping build step: no build command specified","timestamp":"2021-04-20T19:36:05.9165087Z"},{"id":36,"message":"Finished","timestamp":"2021-04-20T19:36:05.917412Z"}],"end":37,"ended_on":"2021-04-20T19:36:06.38889Z","name":"build","start":0,"started_on":"2021-04-20T19:35:58.238757Z","status":"success","total":37}
   */
  result?: Record<string, any>;
};

/**
 * Configs for deployments in a project.
 */
export type PagesDeploymentConfigs = {
  /**
   * Configs for preview deploys.
   */
  preview?: PagesDeploymentConfigsValues;
  /**
   * Configs for production deploys.
   */
  production?: PagesDeploymentConfigsValues;
};

export type PagesDeploymentConfigsValues = {
  /**
   * Constellation bindings used for Pages Functions.
   *
   * @example {"AI_BINDING":{"project_id":"some-project-id"}}
   */
  ai_bindings?: {
    [key: string]: {
      /**
       * @x-auditable true
       */
      project_id?: string;
    } | null;
  } | null;
  /**
   * Analytics Engine bindings used for Pages Functions.
   *
   * @example {"ANALYTICS_ENGINE_BINDING":{"dataset":"api_analytics"}}
   */
  analytics_engine_datasets?: {
    [key: string]: {
      /**
       * Name of the dataset.
       *
       * @example api_analytics
       * @x-auditable true
       */
      dataset?: string;
    } | null;
  } | null;
  /**
   * Browser bindings used for Pages Functions.
   *
   * @example {"BROWSER":{}}
   */
  browsers?: {
    [key: string]: Record<string, any> | null;
  } | null;
  /**
   * Compatibility date used for Pages Functions.
   *
   * @example 2022-01-01
   * @x-auditable true
   */
  compatibility_date?: string;
  /**
   * Compatibility flags used for Pages Functions.
   *
   * @example url_standard
   */
  compatibility_flags?: string[];
  /**
   * D1 databases used for Pages Functions.
   *
   * @example {"D1_BINDING":{"id":"445e2955-951a-43f8-a35b-a4d0c8138f63"}}
   */
  d1_databases?: {
    [key: string]: {
      /**
       * UUID of the D1 database.
       *
       * @example 445e2955-951a-43f8-a35b-a4d0c8138f63
       * @x-auditable true
       */
      id?: string;
    } | null;
  } | null;
  /**
   * Durable Object namespaces used for Pages Functions.
   *
   * @example {"DO_BINDING":{"namespace_id":"5eb63bbbe01eeed093cb22bb8f5acdc3"}}
   */
  durable_object_namespaces?: {
    [key: string]: {
      /**
       * ID of the Durable Object namespace.
       *
       * @example 5eb63bbbe01eeed093cb22bb8f5acdc3
       * @x-auditable true
       */
      namespace_id?: string;
    } | null;
  } | null;
  env_vars?: PagesEnvVars;
  /**
   * Hyperdrive bindings used for Pages Functions.
   *
   * @example {"HYPERDRIVE":{"id":"a76a99bc342644deb02c38d66082262a"}}
   */
  hyperdrive_bindings?: {
    [key: string]: {
      /**
       * @example a76a99bc342644deb02c38d66082262a
       * @x-auditable true
       */
      id?: string;
    } | null;
  } | null;
  /**
   * KV namespaces used for Pages Functions.
   *
   * @example {"KV_BINDING":{"namespace_id":"5eb63bbbe01eeed093cb22bb8f5acdc3"}}
   */
  kv_namespaces?: {
    [key: string]: {
      /**
       * ID of the KV namespace.
       *
       * @example 5eb63bbbe01eeed093cb22bb8f5acdc3
       * @x-auditable true
       */
      namespace_id?: string;
    } | null;
  } | null;
  /**
   * mTLS bindings used for Pages Functions.
   *
   * @example {"MTLS":{"certificate_id":"d7cdd17c-916f-4cb7-aabe-585eb382ec4e"}}
   */
  mtls_certificates?: {
    [key: string]: {
      /**
       * @example d7cdd17c-916f-4cb7-aabe-585eb382ec4e
       * @x-auditable true
       */
      certificate_id?: string;
    } | null;
  } | null;
  /**
   * Placement setting used for Pages Functions.
   *
   * @example {"mode":"smart"}
   */
  placement?: {
    /**
     * Placement mode.
     *
     * @example smart
     * @x-auditable true
     */
    mode?: string;
  } | null;
  /**
   * Queue Producer bindings used for Pages Functions.
   *
   * @example {"QUEUE_PRODUCER_BINDING":{"name":"some-queue"}}
   */
  queue_producers?: {
    [key: string]: {
      /**
       * Name of the Queue.
       *
       * @example some-queue
       * @x-auditable true
       */
      name?: string;
    } | null;
  } | null;
  /**
   * R2 buckets used for Pages Functions.
   *
   * @example {"R2_BINDING":{"name":"some-bucket"}}
   */
  r2_buckets?: {
    [key: string]: {
      /**
       * Jurisdiction of the R2 bucket.
       *
       * @example eu
       * @x-auditable true
       */
      jurisdiction?: string | null;
      /**
       * Name of the R2 bucket.
       *
       * @example some-bucket
       * @x-auditable true
       */
      name?: string;
    } | null;
  } | null;
  /**
   * Services used for Pages Functions.
   *
   * @example {"SERVICE_BINDING":{"entrypoint":"MyHandler","environment":"production","service":"example-worker"}}
   */
  services?: {
    [key: string]: {
      /**
       * The entrypoint to bind to.
       *
       * @x-auditable true
       */
      entrypoint?: string | null;
      /**
       * The Service environment.
       *
       * @x-auditable true
       */
      environment?: string;
      /**
       * The Service name.
       *
       * @x-auditable true
       */
      service?: string;
    } | null;
  } | null;
  /**
   * Vectorize bindings used for Pages Functions.
   *
   * @example {"VECTORIZE":{"index_name":"my_index"}}
   */
  vectorize_bindings?: {
    [key: string]: {
      /**
       * @example my_index
       * @x-auditable true
       */
      index_name?: string;
    } | null;
  } | null;
};

/**
 * Deployment stage name.
 *
 * @example deploy
 * @x-auditable true
 */
export type PagesDeploymentStageName =
  | "queued"
  | "initialize"
  | "clone_repo"
  | "build"
  | "deploy";

export type PagesDeployments = {
  /**
   * A list of alias URLs pointing to this deployment.
   *
   * @example https://branchname.projectname.pages.dev
   */
  aliases?: string[] | null;
  build_config?: PagesBuildConfig;
  /**
   * When the deployment was created.
   *
   * @example 2021-03-09T00:55:03.923456Z
   * @format date-time
   * @x-auditable true
   */
  created_on?: string;
  /**
   * Info about what caused the deployment.
   */
  deployment_trigger?: {
    /**
     * Additional info about the trigger.
     */
    metadata?: {
      /**
       * Where the trigger happened.
       *
       * @example main
       * @x-auditable true
       */
      branch?: string;
      /**
       * Hash of the deployment trigger commit.
       *
       * @example ad9ccd918a81025731e10e40267e11273a263421
       * @x-auditable true
       */
      commit_hash?: string;
      /**
       * Message of the deployment trigger commit.
       *
       * @example Update index.html
       * @x-auditable true
       */
      commit_message?: string;
    };
    /**
     * What caused the deployment.
     *
     * @example ad_hoc
     * @x-auditable true
     */
    type?: "push" | "ad_hoc";
  };
  env_vars?: PagesEnvVars;
  /**
   * Type of deploy.
   *
   * @example preview
   * @x-auditable true
   */
  environment?: "preview" | "production";
  /**
   * Id of the deployment.
   *
   * @example f64788e9-fccd-4d4a-a28a-cb84f88f6
   * @x-auditable true
   */
  id?: string;
  /**
   * If the deployment has been skipped.
   *
   * @example true
   * @x-auditable true
   */
  is_skipped?: boolean;
  latest_stage?: PagesStage;
  /**
   * When the deployment was last modified.
   *
   * @example 2021-03-09T00:58:59.045655
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string;
  /**
   * Id of the project.
   *
   * @example 7b162ea7-7367-4d67-bcde-1160995d5
   * @x-auditable true
   */
  project_id?: string;
  /**
   * Name of the project.
   *
   * @example ninjakittens
   * @x-auditable true
   */
  project_name?: string;
  /**
   * Short Id (8 character) of the deployment.
   *
   * @example f64788e9
   * @x-auditable true
   */
  short_id?: string;
  source?: PagesSource;
  /**
   * List of past stages.
   *
   * @example {"ended_on":"2021-06-03T15:39:03.134378Z","name":"queued","started_on":"2021-06-03T15:38:15.608194Z","status":"active"}
   * @example {"ended_on":null,"name":"initialize","started_on":null,"status":"idle"}
   * @example {"ended_on":null,"name":"clone_repo","started_on":null,"status":"idle"}
   * @example {"ended_on":null,"name":"build","started_on":null,"status":"idle"}
   * @example {"ended_on":null,"name":"deploy","started_on":null,"status":"idle"}
   */
  stages?: PagesStage[];
  /**
   * The live URL to view this deployment.
   *
   * @example https://f64788e9.ninjakittens.pages.dev
   * @x-auditable true
   */
  url?: string;
};

export type PagesDomainObject = {
  /**
   * @example lets_encrypt
   * @x-auditable true
   */
  certificate_authority?: "google" | "lets_encrypt";
  /**
   * @x-auditable true
   */
  created_on?: string;
  /**
   * @x-auditable true
   */
  domain_id?: string;
  /**
   * @x-auditable true
   */
  id?: string;
  /**
   * @example example.com
   * @x-auditable true
   */
  name?: string;
  /**
   * @x-auditable true
   */
  status?:
    | "initializing"
    | "pending"
    | "active"
    | "deactivated"
    | "blocked"
    | "error";
  validation_data?: {
    /**
     * @x-auditable true
     */
    error_message?: string;
    /**
     * @x-auditable true
     */
    method?: "http" | "txt";
    /**
     * @x-auditable true
     */
    status?: "initializing" | "pending" | "active" | "deactivated" | "error";
    /**
     * @x-auditable true
     */
    txt_name?: string;
    /**
     * @x-auditable true
     */
    txt_value?: string;
  };
  verification_data?: {
    /**
     * @x-auditable true
     */
    error_message?: string;
    status?: "pending" | "active" | "deactivated" | "blocked" | "error";
  };
  /**
   * @x-auditable true
   */
  zone_tag?: string;
};

export type PagesDomainResponseCollection = PagesApiResponseCommon &
  PagesApiResponsePagination & {
    result?: PagesDomainObject[];
  };

export type PagesDomainResponseSingle = PagesApiResponseSingle & {
  result?: PagesDomainObject;
};

/**
 * Name of the domain.
 *
 * @example this-is-my-domain-01.com
 * @pattern ^[a-z0-9][a-z0-9-]*$
 * @x-auditable true
 */
export type PagesDomainName = string;

export type PagesDomainsPost = {
  /**
   * @example example.com
   * @x-auditable true
   */
  name?: string;
};

/**
 * Environment variables used for builds and Pages Functions.
 */
export type PagesEnvVars = {
  [key: string]: PagesPlainTextEnvVar | PagesSecretTextEnvVar;
};

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type PagesIdentifier = string;

export type PagesMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * A plaintext environment variable.
 *
 * @example {"type":"plain_text","value":"hello world"}
 */
export type PagesPlainTextEnvVar = {
  /**
   * @x-auditable true
   */
  type: "plain_text";
  /**
   * Environment variable value.
   */
  value: string;
} | null;

export type PagesProjectObject = {
  build_config?: PagesBuildConfig;
  /**
   * Most recent deployment to the repo.
   */
  canonical_deployment?: PagesDeployments & (Record<string, any> | null);
  /**
   * When the project was created.
   *
   * @example 2017-01-01T00:00:00Z
   * @format date-time
   * @x-auditable true
   */
  created_on?: string;
  deployment_configs?: PagesDeploymentConfigs;
  /**
   * A list of associated custom domains for the project.
   *
   * @example customdomain.com
   * @example customdomain.org
   */
  domains?: string[];
  /**
   * Id of the project.
   *
   * @example 7b162ea7-7367-4d67-bcde-1160995d5
   * @x-auditable true
   */
  id?: string;
  /**
   * Most recent deployment to the repo.
   */
  latest_deployment?: PagesDeployments & (Record<string, any> | null);
  /**
   * Name of the project.
   *
   * @example NextJS Blog
   * @x-auditable true
   */
  name?: string;
  /**
   * Production branch of the project. Used to identify production deployments.
   *
   * @example main
   * @x-auditable true
   */
  production_branch?: string;
  source?: PagesSource;
  /**
   * The Cloudflare subdomain associated with the project.
   *
   * @example helloworld.pages.dev
   * @x-auditable true
   */
  subdomain?: string;
};

/**
 * @example {"deployment_configs":{"production":{"compatibility_date":"2022-01-01","compatibility_flags":["url_standard"],"env_vars":{"BUILD_VERSION":{"value":"3.3"},"delete_this_env_var":null,"secret_var":{"type":"secret_text","value":"A_CMS_API_TOKEN"}}}}}
 */
export type PagesProjectPatch = PagesProjectObject & Record<string, any>;

export type PagesProjectResponse = PagesApiResponseCommon & {
  result?: PagesProjectObject;
};

/**
 * Name of the project.
 *
 * @example this-is-my-project-01
 * @pattern ^[a-z0-9][a-z0-9-]*$
 * @x-auditable true
 */
export type PagesProjectName = string;

export type PagesProjectsResponse = PagesApiResponseCommon &
  PagesApiResponsePagination & {
    result?: PagesDeployments[];
  };

/**
 * An encrypted environment variable.
 *
 * @example {"type":"secret_text","value":""}
 */
export type PagesSecretTextEnvVar = {
  /**
   * @x-auditable true
   */
  type: "secret_text";
  /**
   * Secret value.
   *
   * @x-sensitive true
   */
  value: string;
} | null;

export type PagesSource = {
  config?: {
    /**
     * @x-auditable true
     */
    deployments_enabled?: boolean;
    /**
     * @x-auditable true
     */
    owner?: string;
    path_excludes?: string[];
    path_includes?: string[];
    /**
     * @x-auditable true
     */
    pr_comments_enabled?: boolean;
    preview_branch_excludes?: string[];
    preview_branch_includes?: string[];
    /**
     * @x-auditable true
     */
    preview_deployment_setting?: "all" | "none" | "custom";
    /**
     * @x-auditable true
     */
    production_branch?: string;
    /**
     * @x-auditable true
     */
    production_deployments_enabled?: boolean;
    /**
     * @x-auditable true
     */
    repo_name?: string;
  };
  /**
   * @x-auditable true
   */
  type?: string;
};

/**
 * The status of the deployment.
 */
export type PagesStage = {
  /**
   * When the stage ended.
   *
   * @example 2021-03-09T00:58:59.045655
   * @format date-time
   * @x-auditable true
   */
  ended_on?: string | null;
  /**
   * The current build stage.
   *
   * @example deploy
   * @x-auditable true
   */
  name?: "queued" | "initialize" | "clone_repo" | "build" | "deploy";
  /**
   * When the stage started.
   *
   * @example 2021-03-09T00:55:03.923456Z
   * @format date-time
   * @x-auditable true
   */
  started_on?: string | null;
  /**
   * State of the current stage.
   *
   * @example success
   * @x-auditable true
   */
  status?: "success" | "idle" | "active" | "failure" | "canceled";
};

export type PublicIpApiResponseCommon = {
  errors: PublicIpMessages;
  messages: PublicIpMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type PublicIpApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: PublicIpMessages;
  messages: PublicIpMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type PublicIpApiResponseSingle = PublicIpApiResponseCommon;

/**
 * A digest of the IP data. Useful for determining if the data has changed.
 *
 * @example a8e453d9d129a3769407127936edfdb0
 */
export type PublicIpEtag = string;

export type PublicIpIps = {
  etag?: PublicIpEtag;
  ipv4_cidrs?: PublicIpIpv4Cidrs;
  ipv6_cidrs?: PublicIpIpv6Cidrs;
};

export type PublicIpIpsJdcloud = {
  etag?: PublicIpEtag;
  ipv4_cidrs?: PublicIpIpv4Cidrs;
  ipv6_cidrs?: PublicIpIpv6Cidrs;
  jdcloud_cidrs?: PublicIpJdcloudCidrs;
};

/**
 * List of Cloudflare IPv4 CIDR addresses.
 */
export type PublicIpIpv4Cidrs = string[];

/**
 * List of Cloudflare IPv6 CIDR addresses.
 */
export type PublicIpIpv6Cidrs = string[];

/**
 * List IPv4 and IPv6 CIDRs, only populated if `?networks=jdcloud` is used.
 */
export type PublicIpJdcloudCidrs = string[];

export type PublicIpMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

export type R2SlurperConnectivityResponse = {
  connectivityStatus?: "success" | "error";
};

export type R2SlurperCreateJobRequest = {
  /**
   * @default true
   */
  overwrite?: boolean;
  source?: R2SlurperSourceJobSchema;
  target?: R2SlurperR2TargetSchema;
};

export type R2SlurperGCSLikeCredsSchema = {
  clientEmail?: string;
  /**
   * @x-sensitive true
   */
  privateKey?: string;
};

export type R2SlurperGCSSourceSchema = {
  bucket?: string;
  secret?: R2SlurperGCSLikeCredsSchema;
  vendor?: "gcs";
};

export type R2SlurperJobLogResponse = {
  createdAt?: string;
  job?: string;
  logType?:
    | "migrationStart"
    | "migrationComplete"
    | "migrationAbort"
    | "migrationError"
    | "migrationPause"
    | "migrationResume"
    | "migrationErrorFailedContinuation"
    | "importErrorRetryExhaustion"
    | "importSkippedStorageClass"
    | "importSkippedOversized"
    | "importSkippedEmptyObject"
    | "importSkippedUnsupportedContentType"
    | "importSkippedExcludedContentType"
    | "importSkippedInvalidMedia"
    | "importSkippedRequiresRetrieval";
  message?: string | null;
  objectKey?: string | null;
};

export type R2SlurperJobProgressResponse = {
  createdAt?: string;
  failedObjects?: number;
  id?: string;
  objects?: number;
  skippedObjects?: number;
  status?: R2SlurperJobStatus;
  transferredObjects?: number;
};

export type R2SlurperJobResponse = {
  createdAt?: string;
  finishedAt?: string | null;
  id?: string;
  overwrite?: boolean;
  source?:
    | {
        bucket?: string;
        endpoint?: string | null;
        pathPrefix?: string | null;
        vendor?: "s3";
      }
    | {
        bucket?: string;
        pathPrefix?: string | null;
        vendor?: "gcs";
      }
    | {
        bucket?: string;
        jurisdiction?: R2SlurperJurisdiction;
        pathPrefix?: string | null;
        vendor?: "r2";
      };
  status?: R2SlurperJobStatus;
  target?: {
    bucket?: string;
    jurisdiction?: R2SlurperJurisdiction;
    vendor?: "r2";
  };
};

export type R2SlurperJobStatus = "running" | "paused" | "aborted" | "completed";

export type R2SlurperJurisdiction = "default" | "eu" | "fedramp";

export type R2SlurperR2SourceSchema = {
  bucket?: string;
  jurisdiction?: R2SlurperJurisdiction;
  secret?: R2SlurperS3LikeCredsSchema;
  vendor?: "r2";
};

export type R2SlurperR2TargetSchema = R2SlurperR2SourceSchema;

export type R2SlurperS3LikeCredsSchema = {
  accessKeyId?: string;
  /**
   * @x-sensitive true
   */
  secretAccessKey?: string;
};

export type R2SlurperS3SourceSchema = {
  bucket?: string;
  endpoint?: string | null;
  secret?: R2SlurperS3LikeCredsSchema;
  vendor?: "s3";
};

export type R2SlurperSourceJobSchema =
  | R2SlurperS3SourceSchema
  | R2SlurperGCSSourceSchema
  | R2SlurperR2SourceSchema;

/**
 * @example {"code":7003,"message":"No route for the URI"}
 * @minLength 1
 */
export type R2SlurperApiV4Error = {
  /**
   * @minimum 1000
   * @x-auditable true
   */
  code: number;
  /**
   * @x-auditable true
   */
  message: string;
}[];

export type R2SlurperApiV4Failure = {
  errors?: R2SlurperApiV4Error;
  messages?: R2SlurperApiV4Message;
  /**
   * Indicates if the API call was successful or not.
   *
   * @example false
   * @x-auditable true
   */
  success?: false;
};

export type R2SlurperApiV4Message = string[];

export type R2SlurperApiV4Success = {
  errors?: R2SlurperApiV4Error;
  messages?: R2SlurperApiV4Message;
  /**
   * Indicates if the API call was successful or not.
   *
   * @x-auditable true
   */
  success?: true;
};

/**
 * Account ID.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type R2AccountIdentifier = string;

/**
 * Metrics based on the class they belong to.
 */
export type R2AccountLevelMetrics = {
  infrequentAccess?: R2ClassBasedMetrics;
  standard?: R2ClassBasedMetrics;
};

/**
 * @example {"domain":"prefix.example-domain.com","enabled":true,"zoneId":"36ca64a6d92827b8a6b90be344bb1bfd"}
 */
export type R2AddCustomDomainRequest = {
  /**
   * Name of the custom domain to be added.
   *
   * @x-auditable true
   */
  domain: string;
  /**
   * Whether to enable public bucket access at the custom domain. If undefined, the domain will be enabled.
   *
   * @x-auditable true
   */
  enabled: boolean;
  /**
   * Minimum TLS Version the custom domain will accept for incoming connections. If not set, defaults to 1.0.
   *
   * @x-auditable true
   */
  minTLS?: "1.0" | "1.1" | "1.2" | "1.3";
  /**
   * Zone ID of the custom domain.
   *
   * @x-auditable true
   */
  zoneId: string;
};

/**
 * @example {"domain":"example-domain.com","enabled":true}
 */
export type R2AddCustomDomainResponse = {
  /**
   * Domain name of the affected custom domain.
   *
   * @x-auditable true
   */
  domain: string;
  /**
   * Whether this bucket is publicly accessible at the specified custom domain.
   */
  enabled: boolean;
  /**
   * Minimum TLS Version the custom domain will accept for incoming connections. If not set, defaults to 1.0.
   *
   * @x-auditable true
   */
  minTLS?: "1.0" | "1.1" | "1.2" | "1.3";
};

/**
 * A single R2 bucket.
 */
export type R2Bucket = {
  /**
   * Creation timestamp.
   */
  creation_date?: string;
  jurisdiction?: R2Jurisdiction;
  location?: R2BucketLocation;
  name?: R2BucketName;
  storage_class?: R2StorageClass;
};

export type R2BucketConfig = {
  /**
   * Name of the bucket.
   *
   * @x-auditable true
   */
  bucketName?: string;
  /**
   * List of queues associated with the bucket.
   */
  queues?: R2QueuesConfig[];
};

export type R2BucketLockRule = {
  condition:
    | R2LockRuleAgeCondition
    | R2LockRuleDateCondition
    | R2LockRuleIndefiniteCondition;
  /**
   * Whether or not this rule is in effect.
   *
   * @x-auditable true
   */
  enabled: boolean;
  /**
   * Unique identifier for this rule.
   *
   * @example Lock all objects for 24 hours
   * @x-auditable true
   */
  id: string;
  /**
   * Rule will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads.
   *
   * @x-auditable true
   */
  prefix?: string;
};

export type R2BucketLockRuleConfig = {
  rules?: R2BucketLockRule[];
};

/**
 * Location of the bucket.
 *
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type R2BucketLocation =
  | "apac"
  | "eeur"
  | "enam"
  | "weur"
  | "wnam"
  | "oc";

/**
 * Name of the bucket.
 *
 * @example example-bucket
 * @maxLength 64
 * @minLength 3
 * @pattern ^[a-z0-9][a-z0-9-]*[a-z0-9]
 * @x-auditable true
 */
export type R2BucketName = string;

/**
 * Metrics based on what state they are in(uploaded or published).
 */
export type R2ClassBasedMetrics = {
  published?: R2ObjectSizeMetrics;
  uploaded?: R2ObjectSizeMetrics;
};

export type R2CorsRule = {
  /**
   * Object specifying allowed origins, methods and headers for this CORS rule.
   */
  allowed: {
    /**
     * Specifies the value for the Access-Control-Allow-Headers header R2 sets when requesting objects in this bucket from a browser. Cross-origin requests that include custom headers (e.g. x-user-id) should specify these headers as AllowedHeaders.
     */
    headers?: string[];
    /**
     * Specifies the value for the Access-Control-Allow-Methods header R2 sets when requesting objects in a bucket from a browser.
     */
    methods: ("GET" | "PUT" | "POST" | "DELETE" | "HEAD")[];
    /**
     * Specifies the value for the Access-Control-Allow-Origin header R2 sets when requesting objects in a bucket from a browser.
     */
    origins: string[];
  };
  /**
   * Specifies the headers that can be exposed back, and accessed by, the JavaScript making the cross-origin request. If you need to access headers beyond the safelisted response headers, such as Content-Encoding or cf-cache-status, you must specify it here.
   */
  exposeHeaders?: string[];
  /**
   * Identifier for this rule.
   *
   * @example Allow Local Development
   * @x-auditable true
   */
  id?: string;
  /**
   * Specifies the amount of time (in seconds) browsers are allowed to cache CORS preflight responses. Browsers may limit this to 2 hours or less, even if the maximum value (86400) is specified.
   *
   * @example 3600
   * @x-auditable true
   */
  maxAgeSeconds?: number;
};

/**
 * Name of the custom domain.
 *
 * @example example-domain/custom-domain.com
 * @x-auditable true
 */
export type R2DomainName = string;

/**
 * @example {"enabled":true,"minTLS":"1.2"}
 */
export type R2EditCustomDomainRequest = {
  /**
   * Whether to enable public bucket access at the specified custom domain.
   *
   * @x-auditable true
   */
  enabled?: boolean;
  /**
   * Minimum TLS Version the custom domain will accept for incoming connections. If not set, defaults to previous value.
   *
   * @x-auditable true
   */
  minTLS?: "1.0" | "1.1" | "1.2" | "1.3";
};

/**
 * @example {"domain":"example-domain.com","enabled":true}
 */
export type R2EditCustomDomainResponse = {
  /**
   * Domain name of the affected custom domain.
   *
   * @x-auditable true
   */
  domain: string;
  /**
   * Whether this bucket is publicly accessible at the specified custom domain.
   *
   * @x-auditable true
   */
  enabled?: boolean;
  /**
   * Minimum TLS Version the custom domain will accept for incoming connections. If not set, defaults to 1.0.
   *
   * @x-auditable true
   */
  minTLS?: "1.0" | "1.1" | "1.2" | "1.3";
};

/**
 * @example {"enabled":true}
 */
export type R2EditManagedDomainRequest = {
  /**
   * Whether to enable public bucket access at the r2.dev domain.
   *
   * @x-auditable true
   */
  enabled: boolean;
};

export type R2EnableSippyAws = {
  /**
   * R2 bucket to copy objects to.
   */
  destination?: {
    /**
     * ID of a Cloudflare API token.
     * This is the value labelled "Access Key ID" when creating an API.
     * token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
     *
     * Sippy will use this token when writing objects to R2, so it is
     * best to scope this token to the bucket you're enabling Sippy for.
     */
    accessKeyId?: string;
    /**
     * @x-auditable true
     */
    provider?: "r2";
    /**
     * Value of a Cloudflare API token.
     * This is the value labelled "Secret Access Key" when creating an API.
     * token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
     *
     * Sippy will use this token when writing objects to R2, so it is
     * best to scope this token to the bucket you're enabling Sippy for.
     *
     * @x-sensitive true
     */
    secretAccessKey?: string;
  };
  /**
   * AWS S3 bucket to copy objects from.
   */
  source?: {
    /**
     * Access Key ID of an IAM credential (ideally scoped to a single S3 bucket).
     */
    accessKeyId?: string;
    /**
     * Name of the AWS S3 bucket.
     *
     * @x-auditable true
     */
    bucket?: string;
    /**
     * @x-auditable true
     */
    provider?: "aws";
    /**
     * Name of the AWS availability zone.
     *
     * @x-auditable true
     */
    region?: string;
    /**
     * Secret Access Key of an IAM credential (ideally scoped to a single S3 bucket).
     *
     * @x-sensitive true
     */
    secretAccessKey?: string;
  };
};

export type R2EnableSippyGcs = {
  /**
   * R2 bucket to copy objects to.
   */
  destination?: {
    /**
     * ID of a Cloudflare API token.
     * This is the value labelled "Access Key ID" when creating an API.
     * token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
     *
     * Sippy will use this token when writing objects to R2, so it is
     * best to scope this token to the bucket you're enabling Sippy for.
     */
    accessKeyId?: string;
    provider?: "r2";
    /**
     * Value of a Cloudflare API token.
     * This is the value labelled "Secret Access Key" when creating an API.
     * token from the [R2 dashboard](https://dash.cloudflare.com/?to=/:account/r2/api-tokens).
     *
     * Sippy will use this token when writing objects to R2, so it is
     * best to scope this token to the bucket you're enabling Sippy for.
     *
     * @x-sensitive true
     */
    secretAccessKey?: string;
  };
  /**
   * GCS bucket to copy objects from.
   */
  source?: {
    /**
     * Name of the GCS bucket.
     *
     * @x-auditable true
     */
    bucket?: string;
    /**
     * Client email of an IAM credential (ideally scoped to a single GCS bucket).
     */
    clientEmail?: string;
    /**
     * Private Key of an IAM credential (ideally scoped to a single GCS bucket).
     *
     * @x-sensitive true
     */
    privateKey?: string;
    provider?: "gcs";
  };
};

export type R2Errors = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * @example {"domain":"prefix.example-domain.one.com","enabled":false,"status":{"ownership":"deactivated","ssl":"pending"},"zoneId":"36ca64a6d92827b8a6b90be344bb1bfd","zoneName":"example-domain.one.com"}
 */
export type R2GetCustomDomainResponse = {
  /**
   * Domain name of the custom domain to be added.
   *
   * @x-auditable true
   */
  domain: string;
  /**
   * Whether this bucket is publicly accessible at the specified custom domain.
   *
   * @x-auditable true
   */
  enabled: boolean;
  /**
   * Minimum TLS Version the custom domain will accept for incoming connections. If not set, defaults to 1.0.
   *
   * @x-auditable true
   */
  minTLS?: "1.0" | "1.1" | "1.2" | "1.3";
  status: {
    /**
     * Ownership status of the domain.
     *
     * @x-auditable true
     */
    ownership:
      | "pending"
      | "active"
      | "deactivated"
      | "blocked"
      | "error"
      | "unknown";
    /**
     * SSL certificate status.
     *
     * @x-auditable true
     */
    ssl:
      | "initializing"
      | "pending"
      | "active"
      | "deactivated"
      | "error"
      | "unknown";
  };
  /**
   * Zone ID of the custom domain resides in.
   *
   * @x-auditable true
   */
  zoneId?: string;
  /**
   * Zone that the custom domain resides in.
   *
   * @x-auditable true
   */
  zoneName?: string;
};

/**
 * Jurisdiction where objects in this bucket are guaranteed to be stored.
 *
 * @default default
 * @x-auditable true
 * @x-stainless-param jurisdiction
 */
export type R2Jurisdiction = "default" | "eu" | "fedramp";

/**
 * Condition for lifecycle transitions to apply after an object reaches an age in seconds.
 */
export type R2LifecycleAgeCondition = {
  /**
   * @x-auditable true
   */
  maxAge: number;
  /**
   * @x-auditable true
   */
  type: "Age";
};

export type R2LifecycleConfig = {
  rules?: R2LifecycleRule[];
};

/**
 * Condition for lifecycle transitions to apply on a specific date.
 */
export type R2LifecycleDateCondition = {
  /**
   * @format date
   * @x-auditable true
   */
  date: string;
  /**
   * @x-auditable true
   */
  type: "Date";
};

export type R2LifecycleRule = {
  /**
   * Transition to abort ongoing multipart uploads.
   */
  abortMultipartUploadsTransition?: {
    /**
     * Condition for lifecycle transitions to apply after an object reaches an age in seconds.
     */
    condition?: R2LifecycleAgeCondition;
  };
  /**
   * Conditions that apply to all transitions of this rule.
   */
  conditions: {
    /**
     * Transitions will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads.
     *
     * @x-auditable true
     */
    prefix: string;
  };
  /**
   * Transition to delete objects.
   */
  deleteObjectsTransition?: {
    condition?: R2LifecycleAgeCondition | R2LifecycleDateCondition;
  };
  /**
   * Whether or not this rule is in effect.
   *
   * @x-auditable true
   */
  enabled: boolean;
  /**
   * Unique identifier for this rule.
   *
   * @example Expire all objects older than 24 hours
   * @x-auditable true
   */
  id: string;
  /**
   * Transitions to change the storage class of objects.
   */
  storageClassTransitions?: R2LifecycleStorageTransition[];
};

export type R2LifecycleStorageTransition = {
  condition: R2LifecycleAgeCondition | R2LifecycleDateCondition;
  /**
   * @x-auditable true
   */
  storageClass: "InfrequentAccess";
};

/**
 * @example {"domains":[{"domain":"prefix.example-domain.one.com","enabled":false,"status":{"ownership":"deactivated","ssl":"pending"},"zoneId":"36ca64a6d92827b8a6b90be344bb1bfd","zoneName":"example-domain.one.com"},{"domain":"prefix.example-domain.two.com","enabled":true,"status":{"ownership":"active","ssl":"active"},"zoneId":"d9d28585d5f8f5b0f857b055bf574f19"}]}
 */
export type R2ListCustomDomainsResponse = {
  domains: {
    /**
     * Domain name of the custom domain to be added.
     *
     * @x-auditable true
     */
    domain: string;
    /**
     * Whether this bucket is publicly accessible at the specified custom domain.
     *
     * @x-auditable true
     */
    enabled: boolean;
    /**
     * Minimum TLS Version the custom domain will accept for incoming connections. If not set, defaults to 1.0.
     *
     * @x-auditable true
     */
    minTLS?: "1.0" | "1.1" | "1.2" | "1.3";
    status: {
      /**
       * Ownership status of the domain.
       *
       * @x-auditable true
       */
      ownership:
        | "pending"
        | "active"
        | "deactivated"
        | "blocked"
        | "error"
        | "unknown";
      /**
       * SSL certificate status.
       *
       * @x-auditable true
       */
      ssl:
        | "initializing"
        | "pending"
        | "active"
        | "deactivated"
        | "error"
        | "unknown";
    };
    /**
     * Zone ID of the custom domain resides in.
     *
     * @x-auditable true
     */
    zoneId?: string;
    /**
     * Zone that the custom domain resides in.
     *
     * @x-auditable true
     */
    zoneName?: string;
  }[];
};

/**
 * Condition to apply a lock rule to an object for how long in seconds.
 */
export type R2LockRuleAgeCondition = {
  /**
   * @example 100
   * @x-auditable true
   */
  maxAgeSeconds: number;
  /**
   * @x-auditable true
   */
  type: "Age";
};

/**
 * Condition to apply a lock rule to an object until a specific date.
 */
export type R2LockRuleDateCondition = {
  /**
   * @format date
   * @x-auditable true
   */
  date: string;
  /**
   * @x-auditable true
   */
  type: "Date";
};

/**
 * Condition to apply a lock rule indefinitely.
 */
export type R2LockRuleIndefiniteCondition = {
  /**
   * @x-auditable true
   */
  type: "Indefinite";
};

/**
 * @example {"bucketId":"0113a9e4549cf9b1ff1bf56e04da0cef","domain":"pub-0113a9e4549cf9b1ff1bf56e04da0cef.r2.dev","enabled":true}
 */
export type R2ManagedDomainResponse = {
  /**
   * Bucket ID.
   *
   * @maxLength 32
   * @x-auditable true
   */
  bucketId: string;
  /**
   * Domain name of the bucket's r2.dev domain.
   *
   * @x-auditable true
   */
  domain: string;
  /**
   * Whether this bucket is publicly accessible at the r2.dev domain.
   *
   * @x-auditable true
   */
  enabled: boolean;
};

export type R2Messages = string[];

/**
 * Metrics on number of objects/amount of storage used.
 */
export type R2ObjectSizeMetrics = {
  /**
   * Amount of.
   */
  metadataSize?: number;
  /**
   * Number of objects stored.
   */
  objects?: number;
  /**
   * Amount of storage used by object data.
   */
  payloadSize?: number;
};

/**
 * Queue ID.
 *
 * @example 11111aa1-11aa-111a-a1a1-a1a111a11a11
 * @maxLength 32
 * @x-auditable true
 */
export type R2QueueIdentifier = string;

export type R2QueuesConfig = {
  /**
   * Queue ID.
   *
   * @example 11111aa1-11aa-111a-a1a1-a1a111a11a11
   * @x-auditable true
   */
  queueId?: string;
  /**
   * Name of the queue.
   *
   * @example first-queue
   * @x-auditable true
   */
  queueName?: string;
  rules?: {
    /**
     * Array of R2 object actions that will trigger notifications.
     *
     * @example PutObject
     * @example CopyObject
     * @uniqueItems true
     */
    actions: R2R2Action[];
    /**
     * A description that can be used to identify the event notification rule after creation.
     *
     * @example Notifications from source bucket to queue
     * @x-auditable true
     */
    description?: string;
    /**
     * Notifications will be sent only for objects with this prefix.
     *
     * @example img/
     * @x-auditable true
     */
    prefix?: string;
    /**
     * Notifications will be sent only for objects with this suffix.
     *
     * @example .jpeg
     * @x-auditable true
     */
    suffix?: string;
    /**
     * Timestamp when the rule was created.
     *
     * @example 2024-09-19T21:54:48.405Z
     * @x-auditable true
     */
    createdAt?: string;
    /**
     * Rule ID.
     *
     * @example 11111aa1-11aa-111a-a1a1-a1a111a11a11
     * @x-auditable true
     */
    ruleId?: string;
  }[];
};

/**
 * @x-auditable true
 */
export type R2R2Action =
  | "PutObject"
  | "CopyObject"
  | "DeleteObject"
  | "CompleteMultipartUpload"
  | "LifecycleDeletion";

/**
 * @example {"domain":"example-domain/custom-domain.com"}
 */
export type R2RemoveCustomDomainResponse = {
  /**
   * Name of the removed custom domain.
   *
   * @x-auditable true
   */
  domain: string;
};

export type R2ResultInfo = {
  /**
   * A continuation token that should be used to fetch the next page of results.
   *
   * @example 1-JTdCJTIydiUyMiUzQTElMkMlMjJzdGFydEFmdGVyJTIyJTNBJTIyZGF2aWRwdWJsaWMlMjIlN0Q=
   */
  cursor?: string;
  /**
   * Maximum number of results on this page.
   *
   * @example 20
   */
  per_page?: number;
};

export type R2Rule = {
  /**
   * Array of R2 object actions that will trigger notifications.
   *
   * @example PutObject
   * @example CopyObject
   * @uniqueItems true
   */
  actions: R2R2Action[];
  /**
   * A description that can be used to identify the event notification rule after creation.
   *
   * @example Notifications from source bucket to queue
   * @x-auditable true
   */
  description?: string;
  /**
   * Notifications will be sent only for objects with this prefix.
   *
   * @example img/
   * @x-auditable true
   */
  prefix?: string;
  /**
   * Notifications will be sent only for objects with this suffix.
   *
   * @example .jpeg
   * @x-auditable true
   */
  suffix?: string;
};

export type R2Sippy = {
  /**
   * Details about the configured destination bucket.
   */
  destination?: {
    /**
     * ID of the Cloudflare API token used when writing objects to this
     * bucket.
     */
    accessKeyId?: string;
    /**
     * @x-auditable true
     */
    account?: string;
    /**
     * Name of the bucket on the provider.
     *
     * @x-auditable true
     */
    bucket?: string;
    /**
     * @x-auditable true
     */
    provider?: "r2";
  };
  /**
   * State of Sippy for this bucket.
   *
   * @x-auditable true
   */
  enabled?: boolean;
  /**
   * Details about the configured source bucket.
   */
  source?: {
    /**
     * Name of the bucket on the provider.
     *
     * @x-auditable true
     */
    bucket?: string;
    /**
     * @x-auditable true
     */
    provider?: "aws" | "gcs";
    /**
     * Region where the bucket resides (AWS only).
     *
     * @x-auditable true
     */
    region?: string | null;
  };
};

/**
 * Storage class for newly uploaded objects, unless specified otherwise.
 *
 * @default Standard
 * @x-auditable true
 */
export type R2StorageClass = "Standard" | "InfrequentAccess";

/**
 * @example {"bucket":"example-bucket","objects":["example-object"],"parentAccessKeyId":"example-access-key-id","permission":"object-read-write","prefixes":["example-prefix/"],"ttlSeconds":3600}
 */
export type R2TempAccessCredsRequest = {
  /**
   * Name of the R2 bucket.
   *
   * @x-auditable true
   */
  bucket: string;
  /**
   * Optional object paths to scope the credentials to.
   */
  objects?: string[];
  /**
   * The parent access key id to use for signing.
   */
  parentAccessKeyId: string;
  /**
   * Permissions allowed on the credentials.
   *
   * @x-auditable true
   */
  permission:
    | "admin-read-write"
    | "admin-read-only"
    | "object-read-write"
    | "object-read-only";
  /**
   * Optional prefix paths to scope the credentials to.
   */
  prefixes?: string[];
  /**
   * How long the credentials will live for in seconds.
   *
   * @default 900
   * @maximum 604800
   * @x-auditable true
   */
  ttlSeconds: number;
};

/**
 * @example {"accessKeyId":"example-access-key-id","secretAccessKey":"example-secret-key","sessionToken":"example-session-token"}
 */
export type R2TempAccessCredsResponse = {
  /**
   * ID for new access key.
   */
  accessKeyId?: string;
  /**
   * Secret access key.
   *
   * @x-sensitive true
   */
  secretAccessKey?: string;
  /**
   * Security token.
   *
   * @x-sensitive true
   */
  sessionToken?: string;
};

export type R2V4Response = {
  errors: R2Errors;
  messages: R2Messages;
  result: Record<string, any>;
  /**
   * Whether the API call was successful.
   */
  success: true;
};

export type R2V4ResponseFailure = {
  errors: R2Errors;
  messages: R2Messages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type R2V4ResponseList = R2V4Response & {
  result_info?: R2ResultInfo;
};

/**
 * Address.
 *
 * @example 123 Sesame St.
 */
export type RegistrarApiAddress = string;

/**
 * Optional address line for unit, floor, suite, etc.
 *
 * @example Suite 430
 */
export type RegistrarApiAddress2 = string;

export type RegistrarApiApiResponseCollection = {
  errors: RegistrarApiMessages;
  messages: RegistrarApiMessages;
  result: Record<string, any> | Record<string, any>[] | string | null;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
  result_info?: RegistrarApiResultInfo;
};

export type RegistrarApiApiResponseCommon = {
  errors: RegistrarApiMessages;
  messages: RegistrarApiMessages;
  result: Record<string, any> | Record<string, any>[] | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type RegistrarApiApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: RegistrarApiMessages;
  messages: RegistrarApiMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

export type RegistrarApiApiResponseSingle = {
  errors: RegistrarApiMessages;
  messages: RegistrarApiMessages;
  result: Record<string, any> | Record<string, any>[] | string | null;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

/**
 * Auto-renew controls whether subscription is automatically renewed upon domain expiration.
 *
 * @example true
 * @x-auditable true
 */
export type RegistrarApiAutoRenew = boolean;

/**
 * Shows if a domain is available for transferring into Cloudflare Registrar.
 *
 * @example false
 */
export type RegistrarApiAvailable = boolean;

/**
 * Indicates if the domain can be registered as a new domain.
 *
 * @example false
 */
export type RegistrarApiCanRegister = boolean;

/**
 * City.
 *
 * @example Austin
 */
export type RegistrarApiCity = string;

/**
 * Contact Identifier.
 *
 * @example ea95132c15732412d22c1476fa83f27a
 * @maxLength 32
 */
export type RegistrarApiContactIdentifier = string;

export type RegistrarApiContactProperties = {
  address: RegistrarApiAddress;
  address2?: RegistrarApiAddress2;
  city: RegistrarApiCity;
  country: RegistrarApiCountry;
  email?: RegistrarApiEmail;
  fax?: RegistrarApiFax;
  first_name: RegistrarApiFirstName;
  id?: RegistrarApiContactIdentifier;
  last_name: RegistrarApiLastName;
  organization: RegistrarApiOrganization;
  phone: RegistrarApiTelephone;
  state: RegistrarApiState;
  zip: RegistrarApiZipcode;
};

export type RegistrarApiContacts = RegistrarApiContactProperties;

/**
 * The country in which the user lives.
 *
 * @example US
 * @maxLength 30
 */
export type RegistrarApiCountry = string | null;

/**
 * Shows time of creation.
 *
 * @example 2018-08-28T17:26:26Z
 * @format date-time
 */
export type RegistrarApiCreatedAt = string;

/**
 * Shows name of current registrar.
 *
 * @example Cloudflare
 */
export type RegistrarApiCurrentRegistrar = string;

/**
 * Domain identifier.
 *
 * @example ea95132c15732412d22c1476fa83f27a
 * @maxLength 32
 */
export type RegistrarApiDomainIdentifier = string;

/**
 * Domain name.
 *
 * @example cloudflare.com
 */
export type RegistrarApiDomainName = string;

export type RegistrarApiDomainProperties = {
  available?: RegistrarApiAvailable;
  can_register?: RegistrarApiCanRegister;
  created_at?: RegistrarApiCreatedAt;
  current_registrar?: RegistrarApiCurrentRegistrar;
  expires_at?: RegistrarApiExpiresAt;
  id?: RegistrarApiDomainIdentifier;
  locked?: RegistrarApiLocked;
  registrant_contact?: RegistrarApiRegistrantContact;
  registry_statuses?: RegistrarApiRegistryStatuses;
  supported_tld?: RegistrarApiSupportedTld;
  transfer_in?: RegistrarApiTransferIn;
  updated_at?: RegistrarApiUpdatedAt;
};

export type RegistrarApiDomainResponseCollection =
  RegistrarApiApiResponseCollection & {
    result?: RegistrarApiDomains[];
  };

export type RegistrarApiDomainResponseSingle = RegistrarApiApiResponseSingle & {
  result?: Record<string, any>;
};

export type RegistrarApiDomainUpdateProperties = {
  auto_renew?: RegistrarApiAutoRenew;
  locked?: RegistrarApiLocked;
  privacy?: RegistrarApiPrivacy;
};

export type RegistrarApiDomains = RegistrarApiDomainProperties;

/**
 * The contact email address of the user.
 *
 * @example user@example.com
 * @maxLength 90
 */
export type RegistrarApiEmail = string;

/**
 * Shows when domain name registration expires.
 *
 * @example 2019-08-28T23:59:59Z
 * @format date-time
 */
export type RegistrarApiExpiresAt = string;

/**
 * Contact fax number.
 *
 * @example 123-867-5309
 */
export type RegistrarApiFax = string;

/**
 * User's first name
 *
 * @example John
 * @maxLength 60
 */
export type RegistrarApiFirstName = string | null;

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type RegistrarApiIdentifier = string;

/**
 * User's last name
 *
 * @example Appleseed
 * @maxLength 60
 */
export type RegistrarApiLastName = string | null;

/**
 * Shows whether a registrar lock is in place for a domain.
 *
 * @example false
 * @x-auditable true
 */
export type RegistrarApiLocked = boolean;

export type RegistrarApiMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * Name of organization.
 *
 * @example Cloudflare, Inc.
 */
export type RegistrarApiOrganization = string;

/**
 * Privacy option controls redacting WHOIS information.
 *
 * @example true
 * @x-auditable true
 */
export type RegistrarApiPrivacy = boolean;

/**
 * Shows contact information for domain registrant.
 */
export type RegistrarApiRegistrantContact = RegistrarApiContacts;

/**
 * A comma-separated list of registry status codes. A full list of status codes can be found at [EPP Status Codes](https://www.icann.org/resources/pages/epp-status-codes-2014-06-16-en).
 *
 * @example ok,serverTransferProhibited
 */
export type RegistrarApiRegistryStatuses = string;

export type RegistrarApiResultInfo = {
  /**
   * Total number of results for the requested service
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters
   *
   * @example 2000
   */
  total_count?: number;
};

/**
 * State.
 *
 * @example TX
 */
export type RegistrarApiState = string;

/**
 * Whether a particular TLD is currently supported by Cloudflare Registrar. Refer to [TLD Policies](https://www.cloudflare.com/tld-policies/) for a list of supported TLDs.
 *
 * @example true
 */
export type RegistrarApiSupportedTld = boolean;

/**
 * User's telephone number
 *
 * @example +1 123-123-1234
 * @maxLength 20
 */
export type RegistrarApiTelephone = string | null;

/**
 * Statuses for domain transfers into Cloudflare Registrar.
 */
export type RegistrarApiTransferIn = {
  /**
   * Form of authorization has been accepted by the registrant.
   *
   * @example needed
   */
  accept_foa?: "needed" | "ok";
  /**
   * Shows transfer status with the registry.
   *
   * @example unknown
   */
  approve_transfer?:
    | "needed"
    | "ok"
    | "pending"
    | "trying"
    | "rejected"
    | "unknown";
  /**
   * Indicates if cancellation is still possible.
   *
   * @example true
   */
  can_cancel_transfer?: boolean;
  /**
   * Privacy guards are disabled at the foreign registrar.
   *
   * @example ok
   */
  disable_privacy?: "needed" | "ok" | "unknown";
  /**
   * Auth code has been entered and verified.
   *
   * @example needed
   */
  enter_auth_code?: "needed" | "ok" | "pending" | "trying" | "rejected";
  /**
   * Domain is unlocked at the foreign registrar.
   *
   * @example ok
   */
  unlock_domain?: "needed" | "ok" | "pending" | "trying" | "unknown";
};

/**
 * Last updated.
 *
 * @example 2018-08-28T17:26:26Z
 * @format date-time
 */
export type RegistrarApiUpdatedAt = string;

/**
 * The zipcode or postal code where the user lives.
 *
 * @example 12345
 * @maxLength 20
 */
export type RegistrarApiZipcode = string | null;

export type RequestTracerAccountIdentifier = RequestTracerIdentifier;

export type RequestTracerApiResponseCommon = {
  errors: RequestTracerMessages;
  messages: RequestTracerMessages;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type RequestTracerApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: RequestTracerMessages;
  messages: RequestTracerMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type RequestTracerIdentifier = string;

export type RequestTracerMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

export type RequestTracerTrace = {
  /**
   * If step type is rule, then action performed by this rule
   *
   * @example execute
   * @pattern ^[a-z_]+$
   */
  action?: string;
  /**
   * If step type is rule, then action parameters of this rule as JSON
   *
   * @example {"id":"4814384a9e5d4991b9815dcfc25d2f1f"}
   */
  action_parameters?: Record<string, any>;
  /**
   * If step type is rule or ruleset, the description of this entity
   *
   * @example some rule
   */
  description?: string;
  /**
   * If step type is rule, then expression used to match for this rule
   *
   * @example ip.src ne 1.1.1.1
   */
  expression?: string;
  /**
   * If step type is ruleset, then kind of this ruleset
   *
   * @example zone
   */
  kind?: string;
  /**
   * Whether tracing step affected tracing request/response
   *
   * @example true
   */
  matched?: boolean;
  /**
   * If step type is ruleset, then name of this ruleset
   *
   * @example some ruleset name
   */
  name?: string;
  /**
   * Tracing step identifying name
   *
   * @example rule_id01
   */
  step_name?: string;
  trace?: RequestTracerTrace;
  /**
   * Tracing step type
   *
   * @example rule
   */
  type?: string;
}[];

/**
 * Account identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type ResourceSharingAccountId = string;

/**
 * The display name of an account.
 *
 * @example Account A
 */
export type ResourceSharingAccountName = string;

export type ResourceSharingApiResponseCollection = {
  errors: ResourceSharingV4errors;
  result?: Record<string, any> | any[] | string | null;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: boolean;
  result_info?: ResourceSharingResultInfo;
};

export type ResourceSharingApiResponseCommon = {
  errors: ResourceSharingV4errors;
  result?: Record<string, any> | any[] | string;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: boolean;
};

export type ResourceSharingApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: ResourceSharingV4errors;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: boolean;
};

/**
 * Account or organization ID must be provided.
 */
export type ResourceSharingCreateShareRecipientRequest = {
  account_id?: ResourceSharingAccountId;
  organization_id?: ResourceSharingOrganizationId;
};

export type ResourceSharingCreateShareRequest = {
  name: ResourceSharingShareName;
  recipients: ResourceSharingCreateShareRecipientRequest[];
  resources: ResourceSharingCreateShareResourceRequest[];
};

export type ResourceSharingCreateShareResourceRequest = {
  meta: ResourceSharingResourceMeta;
  resource_account_id: ResourceSharingAccountId;
  resource_id: ResourceSharingResourceResourceId;
  resource_type: ResourceSharingResourceType;
};

/**
 * When the share was created.
 *
 * @example 2023-09-21T18:56:32.624632Z
 * @format date-time
 */
export type ResourceSharingCreated = string;

/**
 * When the share was modified.
 *
 * @example 2023-09-21T18:56:32.624632Z
 * @format date-time
 */
export type ResourceSharingModified = string;

/**
 * Organization identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type ResourceSharingOrganizationId = string;

/**
 * Share Recipient association status.
 */
export type ResourceSharingRecipientAssociationStatus =
  | "associating"
  | "associated"
  | "disassociating"
  | "disassociated";

/**
 * Share Recipient identifier tag.
 *
 * @example 3fd85f74b32742f1bff64a85009dda07
 * @maxLength 32
 */
export type ResourceSharingRecipientId = string;

/**
 * Share Recipient status message.
 *
 * @example Cannot share to account that owns the resource
 */
export type ResourceSharingRecipientStatusMessage = string;

/**
 * Share Resource identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type ResourceSharingResourceId = string;

/**
 * Resource Metadata.
 */
export type ResourceSharingResourceMeta = Record<string, any>;

/**
 * Share Resource identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type ResourceSharingResourceResourceId = string;

/**
 * Resource Status.
 */
export type ResourceSharingResourceStatus = "active" | "deleting" | "deleted";

/**
 * Resource Type.
 */
export type ResourceSharingResourceType = "custom-ruleset" | "widget";

/**
 * Resource Version.
 */
export type ResourceSharingResourceVersion = number;

export type ResourceSharingResultInfo = {
  /**
   * Total number of results for the requested service.
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results.
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results.
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters.
   *
   * @example 2000
   */
  total_count?: number;
  /**
   * Total number of pages using the given per page.
   *
   * @example 50
   */
  total_pages?: number;
};

/**
 * Share identifier tag.
 *
 * @example 3fd85f74b32742f1bff64a85009dda07
 * @maxLength 32
 */
export type ResourceSharingShareId = string;

export type ResourceSharingShareKind = "sent" | "received";

/**
 * The name of the share.
 *
 * @example My Shared WAF Managed Rule
 */
export type ResourceSharingShareName = string;

export type ResourceSharingShareObject = {
  account_id: ResourceSharingAccountId;
  account_name: ResourceSharingAccountName;
  created: ResourceSharingCreated;
  id: ResourceSharingShareId;
  kind?: ResourceSharingShareKind;
  modified: ResourceSharingModified;
  name: ResourceSharingShareName;
  organization_id: ResourceSharingOrganizationId;
  status: ResourceSharingShareStatus;
  target_type: ResourceSharingShareTargetType;
};

export type ResourceSharingShareRecipientObject = {
  account_id: ResourceSharingAccountId;
  association_status: ResourceSharingRecipientAssociationStatus;
  created: ResourceSharingCreated;
  id: ResourceSharingRecipientId;
  modified: ResourceSharingModified;
  status_message: ResourceSharingRecipientStatusMessage;
};

export type ResourceSharingShareRecipientResponseCollection =
  ResourceSharingApiResponseCollection & {
    result?: ResourceSharingShareRecipientObject[];
  };

export type ResourceSharingShareRecipientResponseSingle = {
  errors: ResourceSharingV4errors;
  result?: ResourceSharingShareRecipientObject;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: boolean;
};

export type ResourceSharingShareResourceObject = {
  created: ResourceSharingCreated;
  id: ResourceSharingResourceId;
  meta: ResourceSharingResourceMeta;
  modified: ResourceSharingModified;
  resource_account_id: ResourceSharingAccountId;
  resource_id: ResourceSharingResourceResourceId;
  resource_type: ResourceSharingResourceType;
  resource_version: ResourceSharingResourceVersion;
  status: ResourceSharingResourceStatus;
};

export type ResourceSharingShareResourceResponseCollection =
  ResourceSharingApiResponseCollection & {
    result?: ResourceSharingShareResourceObject[];
  };

export type ResourceSharingShareResourceResponseSingle = {
  errors: ResourceSharingV4errors;
  result?: ResourceSharingShareResourceObject;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: boolean;
};

export type ResourceSharingShareResponseCollection =
  ResourceSharingApiResponseCollection & {
    result?: ResourceSharingShareObject[];
  };

export type ResourceSharingShareResponseSingle = {
  errors: ResourceSharingV4errors;
  result?: ResourceSharingShareObject;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: boolean;
};

export type ResourceSharingShareStatus = "active" | "deleting" | "deleted";

export type ResourceSharingShareTargetType = "account" | "organization";

export type ResourceSharingUpdateShareRequest = {
  name: ResourceSharingShareName;
};

export type ResourceSharingUpdateShareResourceRequest = {
  meta: ResourceSharingResourceMeta;
};

export type ResourceSharingV4error = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
};

export type ResourceSharingV4errors = ResourceSharingV4error[];

/**
 * The unique ID of the account.
 *
 * @example abf9b32d38c5f572afde3336ec0ce302
 * @pattern ^[0-9a-f]{32}$
 */
export type RulesetsAccountId = string;

export type RulesetsBlockRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   */
  action_parameters?: {
    /**
     * The response to show when the block is applied.
     */
    response?: {
      /**
             * The content to return.
             *
             * @example {
              "success": false,
              "error": "you have been blocked"
            }
             * @minLength 1
             */
      content: string;
      /**
       * The type of the content to return.
       *
       * @example application/json
       * @minLength 1
       */
      content_type: string;
      /**
       * The status code to return.
       *
       * @maximum 499
       * @minimum 400
       */
      status_code: number;
    };
  };
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   * @example Block when the IP address is not 1.1.1.1
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

export type RulesetsChallengeRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   */
  action_parameters?: Record<string, any>;
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   * @example Issue an Interactive Challenge if the visitor had not solved an Interactive Challenge prior to the request when the address is not 1.1.1.1
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

export type RulesetsCompressResponseRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   */
  action_parameters?: {
    /**
     * Custom order for compression algorithms.
     *
     * @example {"name":"none"}
     */
    algorithms?: {
      /**
       * Name of compression algorithm to enable.
       */
      name?: "none" | "auto" | "default" | "gzip" | "brotli" | "zstd";
    }[];
  };
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   * @example Disable compression when address is not 1.1.1.1
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

/**
 * Cursor to use for the next page.
 *
 * @example dGhpc2lzYW5leGFtcGxlCg
 * @minLength 1
 */
export type RulesetsCursor = string;

export type RulesetsDDoSDynamicRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   */
  action_parameters?: Record<string, any>;
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   * @example Performs a specific action according to a set of internal guidelines defined by Cloudflare.
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

/**
 * A list of error messages.
 */
export type RulesetsErrors = RulesetsMessage[];

export type RulesetsExecuteRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   */
  action_parameters?: {
    /**
     * The ID of the ruleset to execute.
     *
     * @example 4814384a9e5d4991b9815dcfc25d2f1f
     * @pattern ^[0-9a-f]{32}$
     */
    id: RulesetsRulesetId & void;
    /**
     * The configuration to use for matched data logging.
     */
    matched_data?: {
      /**
       * The public key to encrypt matched data logs with.
       *
       * @example iGqBmyIUxuWt1rvxoAharN9FUXneUBxA/Y19PyyrEG0=
       * @minLength 1
       */
      public_key: string;
    };
    /**
     * A set of overrides to apply to the target ruleset.
     *
     * @minProperties 1
     */
    overrides?: {
      /**
       * An action to override all rules with. This option has lower precedence than rule and category overrides.
       *
       * @pattern ^[a-z]+$
       * @example log
       */
      action?: RulesetsRuleAction & void;
      /**
       * A list of category-level overrides. This option has the second-highest precedence after rule-level overrides.
       *
       * @minItems 1
       * @uniqueItems true
       */
      categories?: {
        /**
         * The action to override rules in the category with.
         *
         * @pattern ^[a-z]+$
         * @example log
         */
        action?: RulesetsRuleAction & void;
        /**
         * The name of the category to override.
         *
         * @example directory-traversal
         * @minLength 1
         */
        category: RulesetsRuleCategory & void;
        /**
         * Whether to enable execution of rules in the category.
         *
         * @example true
         */
        enabled?: RulesetsRuleEnabled & void;
        /**
         * The sensitivity level to use for rules in the category.
         */
        sensitivity_level?: RulesetsExecuteSensitivityLevel & void;
      }[];
      /**
       * Whether to enable execution of all rules. This option has lower precedence than rule and category overrides.
       *
       * @example true
       */
      enabled?: RulesetsRuleEnabled & void;
      /**
       * A list of rule-level overrides. This option has the highest precedence.
       *
       * @minItems 1
       * @uniqueItems true
       */
      rules?: {
        /**
         * The action to override the rule with.
         *
         * @pattern ^[a-z]+$
         * @example log
         */
        action?: RulesetsRuleAction & void;
        /**
         * Whether to enable execution of the rule.
         *
         * @example true
         */
        enabled?: RulesetsRuleEnabled & void;
        /**
         * The ID of the rule to override.
         *
         * @example 8ac8bc2a661e475d940980f9317f28e1
         * @pattern ^[0-9a-f]{32}$
         */
        id: RulesetsRuleId & void;
        /**
         * The score threshold to use for the rule.
         */
        score_threshold?: number;
        /**
         * The sensitivity level to use for the rule.
         */
        sensitivity_level?: RulesetsExecuteSensitivityLevel & void;
      }[];
      /**
       * A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
       */
      sensitivity_level?: RulesetsExecuteSensitivityLevel & void;
    };
  };
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   * @example Execute the OWASP ruleset when the IP address is not 1.1.1.1
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

export type RulesetsExecuteSensitivityLevel =
  | "default"
  | "medium"
  | "low"
  | "eoff";

export type RulesetsForceConnectionCloseRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   */
  action_parameters?: Record<string, any>;
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   * @example Closes ongoing HTTP connections. This action does not block a request, but it forces the client to reconnect. For HTTP/2 and HTTP/3 connections, the connection will be closed even if it breaks other requests running on the same connection.
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

export type RulesetsJsChallengeRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   */
  action_parameters?: Record<string, any>;
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   * @example Issue a non-interactive Javascript Challenge if the visitor had not solved a Interactive Challenge, Managed Challenge, or Javascript Challenge prior to the request when the address is not 1.1.1.1
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

export type RulesetsLogCustomFieldRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   *
   * @minProperties 1
   */
  action_parameters?: {
    /**
     * The cookie fields to log.
     *
     * @minItems 1
     */
    cookie_fields?: {
      /**
       * The name of the field.
       *
       * @example cookie_name_1
       * @minLength 1
       */
      name: string;
    }[];
    /**
     * The raw response fields to log.
     *
     * @minItems 1
     */
    raw_response_fields?: {
      /**
       * The name of the field.
       *
       * @example http_response_header_name_1_in_lower_case
       * @minLength 1
       */
      name: string;
      /**
       * Whether to log duplicate values of the same header.
       *
       * @example true
       */
      preserve_duplicates?: boolean;
    }[];
    /**
     * The raw request fields to log.
     *
     * @minItems 1
     */
    request_fields?: {
      /**
       * The name of the field.
       *
       * @example http_request_header_name_1_in_lower_case
       * @minLength 1
       */
      name: string;
    }[];
    /**
     * The transformed response fields to log.
     *
     * @minItems 1
     */
    response_fields?: {
      /**
       * The name of the field.
       *
       * @example http_response_header_name_1_in_lower_case
       * @minLength 1
       */
      name: string;
      /**
       * Whether to log duplicate values of the same header.
       *
       * @example true
       */
      preserve_duplicates?: boolean;
    }[];
    /**
     * The transformed request fields to log.
     *
     * @minItems 1
     */
    transformed_request_fields?: {
      /**
       * The name of the field.
       *
       * @example http_request_header_name_1_in_lower_case
       * @minLength 1
       */
      name: string;
    }[];
  };
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   * @example Log custom field when the IP address is not 1.1.1.1
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

export type RulesetsLogRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   */
  action_parameters?: Record<string, any>;
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   * @example Log when the IP address is not 1.1.1.1
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

export type RulesetsManagedChallengeRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   */
  action_parameters?: Record<string, any>;
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   * @example Issue a Managed Challenge if the visitor had not solved a Managed Challenge or Interactive Challenge prior to the request when the address is not 1.1.1.1
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

/**
 * A Managed Transform object.
 */
export type RulesetsManagedTransform = {
  /**
   * The Managed Transforms that this Managed Transform conflicts with.
   */
  conflicts_with?: (RulesetsManagedTransformId & void)[];
  /**
   * Whether the Managed Transform is enabled.
   *
   * @example true
   */
  enabled: boolean;
  /**
   * Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
   *
   * @example false
   */
  has_conflict: boolean;
  id: RulesetsManagedTransformId;
};

/**
 * The human-readable identifier of the Managed Transform.
 *
 * @minLength 1
 */
export type RulesetsManagedTransformId = string;

/**
 * A Managed Transforms object.
 */
export type RulesetsManagedTransforms = {
  /**
   * The list of Managed Request Transforms.
   */
  managed_request_headers: {
    /**
     * The Managed Transforms that this Managed Transform conflicts with.
     */
    conflicts_with?: (RulesetsManagedTransformId & void)[];
    /**
     * Whether the Managed Transform is enabled.
     *
     * @example true
     */
    enabled: boolean;
    /**
     * Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
     *
     * @example false
     */
    has_conflict: boolean;
    /**
     * @example add_bot_protection_headers
     */
    id: RulesetsManagedTransformId;
  }[];
  /**
   * The list of Managed Response Transforms.
   */
  managed_response_headers: {
    /**
     * The Managed Transforms that this Managed Transform conflicts with.
     */
    conflicts_with?: (RulesetsManagedTransformId & void)[];
    /**
     * Whether the Managed Transform is enabled.
     *
     * @example true
     */
    enabled: boolean;
    /**
     * Whether the Managed Transform conflicts with the currently-enabled Managed Transforms.
     *
     * @example false
     */
    has_conflict: boolean;
    /**
     * @example add_security_headers
     */
    id: RulesetsManagedTransformId;
  }[];
};

/**
 * A message.
 */
export type RulesetsMessage = {
  /**
   * A unique code for this message.
   *
   * @example 10000
   */
  code?: number;
  /**
   * A text description of this message.
   *
   * @example something bad happened
   * @minLength 1
   */
  message: string;
  /**
   * The source of this message.
   */
  source?: {
    /**
     * A JSON pointer to the field that is the source of the message.
     *
     * @example /rules/0/action
     * @minLength 1
     */
    pointer: string;
  };
};

/**
 * A list of warning messages.
 */
export type RulesetsMessages = RulesetsMessage[];

/**
 * Number of rulesets to return per page.
 *
 * @example 3
 * @maximum 50
 * @minimum 1
 */
export type RulesetsPerPage = number;

export type RulesetsRedirectRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   */
  action_parameters?: {
    /**
     * Serve a redirect based on a bulk list lookup.
     */
    from_list?: {
      /**
       * Expression that evaluates to the list lookup key.
       *
       * @example http.request.full_uri
       * @minLength 1
       */
      key?: string;
      /**
       * The name of the list to match against.
       *
       * @example list1
       * @maxLength 50
       * @pattern ^[a-zA-Z0-9_]+$
       */
      name?: string;
    };
    /**
     * Serve a redirect based on the request properties.
     */
    from_value?: {
      /**
       * Keep the query string of the original request.
       */
      preserve_query_string?: boolean;
      /**
       * The status code to be used for the redirect.
       */
      status_code?: 301 | 302 | 303 | 307 | 308;
      /**
       * The URL to redirect the request to.
       *
       * @example {"expression":"concat(\"https://m.example.com\", http.request.uri.path)"}
       */
      target_url?:
        | {
            /**
             * The URL to redirect the request to.
             *
             * @minLength 1
             */
            value?: string;
          }
        | {
            /**
             * An expression to evaluate to get the URL to redirect the request to.
             *
             * @minLength 1
             */
            expression?: string;
          };
    };
  };
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   * @example Redirect when IP address is not 1.1.1.1
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

export type RulesetsRequestRule =
  | (Omit<RulesetsBlockRule, "action"> & {
      action: "block";
    })
  | (Omit<RulesetsChallengeRule, "action"> & {
      action: "challenge";
    })
  | (Omit<RulesetsCompressResponseRule, "action"> & {
      action: "compress_response";
    })
  | (Omit<RulesetsExecuteRule, "action"> & {
      action: "execute";
    })
  | (Omit<RulesetsJsChallengeRule, "action"> & {
      action: "js_challenge";
    })
  | (Omit<RulesetsLogRule, "action"> & {
      action: "log";
    })
  | (Omit<RulesetsManagedChallengeRule, "action"> & {
      action: "managed_challenge";
    })
  | (Omit<RulesetsRedirectRule, "action"> & {
      action: "redirect";
    })
  | (Omit<RulesetsRewriteRule, "action"> & {
      action: "rewrite";
    })
  | (Omit<RulesetsRouteRule, "action"> & {
      action: "route";
    })
  | (Omit<RulesetsScoreRule, "action"> & {
      action: "score";
    })
  | (Omit<RulesetsServeErrorRule, "action"> & {
      action: "serve_error";
    })
  | (Omit<RulesetsSetConfigRule, "action"> & {
      action: "set_config";
    })
  | (Omit<RulesetsSkipRule, "action"> & {
      action: "skip";
    })
  | (Omit<RulesetsSetCacheSettingsRule, "action"> & {
      action: "set_cache_settings";
    })
  | (Omit<RulesetsLogCustomFieldRule, "action"> & {
      action: "log_custom_field";
    })
  | (Omit<RulesetsDDoSDynamicRule, "action"> & {
      action: "ddos_dynamic";
    })
  | (Omit<RulesetsForceConnectionCloseRule, "action"> & {
      action: "force_connection_close";
    });

/**
 * The list of rules in the ruleset.
 */
export type RulesetsRequestRules = RulesetsRequestRule[];

/**
 * A response object.
 */
export type RulesetsResponse = {
  errors: RulesetsErrors;
  messages: RulesetsMessages;
  /**
   * A result.
   */
  result: void;
  /**
   * Whether the API call was successful.
   */
  success: boolean;
};

export type RulesetsResponseRule = RulesetsRequestRule & void;

/**
 * The list of rules in the ruleset.
 */
export type RulesetsResponseRules = RulesetsResponseRule[];

/**
 * Cursors information to navigate the results.
 */
export type RulesetsResultInfo = {
  /**
   * Set of cursors.
   */
  cursors?: {
    after?: RulesetsCursor;
  };
};

export type RulesetsRewriteRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   */
  action_parameters?: {
    /**
     * Map of request headers to modify.
     *
     * @example {"client-http-version":{"expression":"http.request.version","operation":"set"}}
     */
    headers?: {
      [key: string]:
        | {
            operation: "remove";
          }
        | {
            operation: "add";
            /**
             * Static value for the header.
             *
             * @example static-header-value
             * @minLength 1
             */
            value: string;
          }
        | {
            operation: "set";
            /**
             * Static value for the header.
             *
             * @example static-header-value
             * @minLength 1
             */
            value: string;
          }
        | {
            /**
             * Expression for the header value.
             *
             * @example ip.src
             * @minLength 1
             */
            expression: string;
            operation: "add";
          }
        | {
            /**
             * Expression for the header value.
             *
             * @example ip.src
             * @minLength 1
             */
            expression: string;
            operation: "set";
          };
    };
    /**
     * URI to rewrite the request to.
     */
    uri?: {
      /**
       * Path portion rewrite.
       *
       * @example {"expression":"regex_replace(http.request.uri.path, \"/bar$\", \"/baz\")"}
       */
      path?: void & RulesetsRewriteUriPart;
      /**
       * Query portion rewrite.
       *
       * @example {"expression":"regex_replace(http.request.uri.query, \"foo=bar\", \"\")"}
       */
      query?: void & RulesetsRewriteUriPart;
    };
  };
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   * @example Add a header when the IP address is not 1.1.1.1
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

export type RulesetsRewriteUriPart =
  | {
      /**
       * Predefined replacement value.
       *
       * @example /images
       * @minLength 1
       */
      value: string;
    }
  | {
      /**
       * Expression to evaluate for the replacement value.
       *
       * @example regex_replace(http.request.uri.path, "/bar$", "/baz")
       * @minLength 1
       */
      expression: string;
    };

export type RulesetsRouteRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   */
  action_parameters?: {
    /**
     * Rewrite the HTTP Host header.
     *
     * @example static.example.com
     * @minLength 1
     */
    host_header?: string;
    /**
     * Override the IP/TCP destination.
     */
    origin?: {
      /**
       * Override the resolved hostname.
       *
       * @example static.example.com
       * @minLength 1
       */
      host?: string;
      /**
       * Override the destination port.
       *
       * @maximum 65535
       * @minimum 1
       */
      port?: number;
    };
    /**
     * Override the Server Name Indication (SNI).
     */
    sni?: {
      /**
       * The SNI override.
       *
       * @example static.example.com
       * @minLength 1
       */
      value: string;
    };
  };
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   * @example Select origin server when IP address is not 1.1.1.1
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

export type RulesetsRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   */
  action_parameters?: Record<string, any>;
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

/**
 * The action to perform when the rule matches.
 *
 * @pattern ^[a-z]+$
 */
export type RulesetsRuleAction = string;

/**
 * A category of the rule.
 *
 * @example directory-traversal
 * @minLength 1
 */
export type RulesetsRuleCategory = string;

/**
 * Whether the rule should be executed.
 *
 * @example true
 */
export type RulesetsRuleEnabled = boolean;

/**
 * The unique ID of the rule.
 *
 * @example 3a03d665bac047339bb530ecb439a90d
 * @pattern ^[0-9a-f]{32}$
 */
export type RulesetsRuleId = string;

/**
 * An object configuring where the rule will be placed.
 */
export type RulesetsRulePosition = Record<string, any>;

/**
 * A ruleset object.
 */
export type RulesetsRuleset = {
  /**
   * An informative description of the ruleset.
   *
   * @default
   * @example My ruleset to execute managed rulesets
   */
  description?: string;
  /**
   * The unique ID of the ruleset.
   *
   * @example 2f2feab2026849078ba485f918791bdc
   * @pattern ^[0-9a-f]{32}$
   */
  id: RulesetsRulesetId & void;
  /**
   * The timestamp of when the ruleset was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * The human-readable name of the ruleset.
   *
   * @example My ruleset
   * @minLength 1
   */
  name?: string;
  /**
   * The version of the ruleset.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: RulesetsRulesetVersion & void;
};

/**
 * The unique ID of the ruleset.
 *
 * @example 2f2feab2026849078ba485f918791bdc
 * @pattern ^[0-9a-f]{32}$
 */
export type RulesetsRulesetId = string;

/**
 * The kind of the ruleset.
 *
 * @example root
 */
export type RulesetsRulesetKind = "managed" | "custom" | "root" | "zone";

/**
 * The phase of the ruleset.
 *
 * @example http_request_firewall_custom
 */
export type RulesetsRulesetPhase =
  | "ddos_l4"
  | "ddos_l7"
  | "http_config_settings"
  | "http_custom_errors"
  | "http_log_custom_fields"
  | "http_ratelimit"
  | "http_request_cache_settings"
  | "http_request_dynamic_redirect"
  | "http_request_firewall_custom"
  | "http_request_firewall_managed"
  | "http_request_late_transform"
  | "http_request_origin"
  | "http_request_redirect"
  | "http_request_sanitize"
  | "http_request_sbfm"
  | "http_request_transform"
  | "http_response_compression"
  | "http_response_firewall_managed"
  | "http_response_headers_transform"
  | "magic_transit"
  | "magic_transit_ids_managed"
  | "magic_transit_managed"
  | "magic_transit_ratelimit";

/**
 * The version of the ruleset.
 *
 * @example 1
 * @pattern ^[0-9]+$
 */
export type RulesetsRulesetVersion = string;

export type RulesetsScoreRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   *
   * @example {"increment":3}
   * @minProperties 1
   */
  action_parameters?: {
    /**
     * Increment contains the delta to change the score and can be either positive or negative.
     *
     * @example 3
     */
    increment?: number;
  };
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   * @example Increment score when the IP address is not 1.1.1.1
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

export type RulesetsServeErrorRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   */
  action_parameters?: {
    /**
     * Error response content.
     *
     * @example {"error": "1xxx error occurred"}
     * @maxLength 10240
     * @minLength 1
     */
    content?: string;
    /**
     * Content-type header to set with the response.
     *
     * @example application/json
     */
    content_type?: "application/json" | "text/xml" | "text/plain" | "text/html";
    /**
     * The status code to use for the error.
     *
     * @example 500
     * @maximum 999
     * @minimum 400
     */
    status_code?: number;
  };
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   * @example Serve a JSON response to api users on error
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

export type RulesetsSetCacheSettingsRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   */
  action_parameters?: {
    /**
     * List of additional ports that caching can be enabled on.
     */
    additional_cacheable_ports?: number[];
    /**
         * Specify how long client browsers should cache the response. Cloudflare cache purge will not purge content cached on client browsers, so high browser TTLs may lead to stale content.
         *
         * @example {
            "mode": "override_origin",
            "default": 1000
        }
         */
    browser_ttl?: {
      /**
       * The TTL (in seconds) if you choose override_origin mode.
       */
      ["default"]?: number;
      /**
       * Determines which browser ttl mode to use.
       */
      mode: "respect_origin" | "bypass_by_default" | "override_origin";
    };
    /**
     * Mark whether the request’s response from origin is eligible for caching. Caching itself will still depend on the cache-control header and your other caching configurations.
     */
    cache?: boolean;
    /**
     * Define which components of the request are included or excluded from the cache key Cloudflare uses to store the response in cache.
     */
    cache_key?: {
      /**
       * Separate cached content based on the visitor’s device type.
       */
      cache_by_device_type?: boolean;
      /**
       * Protect from web cache deception attacks while allowing static assets to be cached.
       */
      cache_deception_armor?: boolean;
      /**
       * Customize which components of the request are included or excluded from the cache key.
       */
      custom_key?: {
        /**
         * The cookies to include in building the cache key.
         */
        cookie?: {
          /**
           * Checks for the presence of these cookie names. The presence of these cookies is used in building the cache key.
           */
          check_presence?: string[];
          /**
           * Include these cookies' names and their values.
           */
          include?: string[];
        };
        /**
         * The header names and values to include in building the cache key.
         */
        header?: {
          /**
           * Checks for the presence of these header names. The presence of these headers is used in building the cache key.
           */
          check_presence?: string[];
          /**
           * For each header name and list of values combination, check if the request header contains any of the values provided. The presence of the request header and whether any of the values provided are contained in the request header value is used in building the cache key.
           */
          contains?: {
            [key: string]: string[];
          };
          /**
           * Whether or not to include the origin header. A value of true will exclude the origin header in the cache key.
           */
          exclude_origin?: boolean;
          /**
           * Include these headers' names and their values.
           */
          include?: string[];
        };
        /**
         * Whether to use the original host or the resolved host in the cache key.
         */
        host?: {
          /**
           * Use the resolved host in the cache key. A value of true will use the resolved host, while a value or false will use the original host.
           *
           * @example true
           */
          resolved?: boolean;
        };
        query_string?:
          | {
              include?:
                | {
                    /**
                     * @example foo
                     * @example bar
                     */
                    list?: string[];
                  }
                | {
                    /**
                     * Determines whether to include all query string parameters in the cache key.
                     *
                     * @example true
                     */
                    all?: boolean;
                  };
            }
          | {
              exclude?:
                | {
                    /**
                     * @example foo
                     * @example bar
                     */
                    list?: string[];
                  }
                | {
                    /**
                     * Determines whether to exclude all query string parameters from the cache key.
                     *
                     * @example true
                     */
                    all?: boolean;
                  };
            };
        /**
         * Characteristics of the request user agent used in building the cache key.
         */
        user?: {
          /**
           * Use the user agent's device type in the cache key.
           */
          device_type?: boolean;
          /**
           * Use the user agents's country in the cache key.
           */
          geo?: boolean;
          /**
           * Use the user agent's language in the cache key.
           */
          lang?: boolean;
        };
      };
      /**
       * Treat requests with the same query parameters the same, regardless of the order those query parameters are in. A value of true ignores the query strings' order.
       */
      ignore_query_strings_order?: boolean;
    };
    /**
     * Mark whether the request's response from origin is eligible for Cache Reserve (requires a Cache Reserve add-on plan).
     */
    cache_reserve?: {
      /**
             * Determines whether cache reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to cache reserve.
             *
             * @example {
                "eligible": true,
                "minimum_file_size": 100000
            }
             */
      eligible: boolean;
      /**
       * The minimum file size eligible for store in cache reserve.
       */
      minimum_file_size: number;
    };
    /**
         * TTL (Time to Live) specifies the maximum time to cache a resource in the Cloudflare edge network.
         *
         * @example {
            "status_code_ttl": [
                {
                    "status_code_range": {
                        "to": 299
                    },
                    "value": 86400
                },
                {
                    "status_code_range": {
                        "from": 300,
                        "to": 499
                    },
                    "value": 0
                },
                {
                    "status_code_range": {
                        "from": 500
                    },
                    "value": -1
                }
            ],
            "mode": "respect_origin"
        }
         */
    edge_ttl?: {
      /**
       * The TTL (in seconds) if you choose override_origin mode.
       *
       * @maximum 9223372036854776000
       * @minimum 0
       */
      ["default"]: number;
      /**
       * Edge TTL options.
       */
      mode: "respect_origin" | "bypass_by_default" | "override_origin";
      /**
       * List of single status codes, or status code ranges to apply the selected mode.
       */
      status_code_ttl: {
        /**
         * The range of status codes used to apply the selected mode.
         */
        status_code_range?: {
          /**
           * Response status code lower bound.
           */
          from: number;
          /**
           * Response status code upper bound.
           */
          to: number;
        };
        /**
         * Set the TTL for responses with this specific status code.
         */
        status_code_value?: number;
        /**
         * Time to cache a response (in seconds). A value of 0 is equivalent to setting the Cache-Control header with the value "no-cache". A value of -1 is equivalent to setting Cache-Control header with the value of "no-store".
         */
        value: number;
      }[];
    };
    /**
     * When enabled, Cloudflare will aim to strictly adhere to RFC 7234.
     */
    origin_cache_control?: boolean;
    /**
     * Generate Cloudflare error pages from issues sent from the origin server. When on, error pages will trigger for issues from the origin.
     */
    origin_error_page_passthru?: boolean;
    /**
     * Define a timeout value between two successive read operations to your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
     *
     * @example 900
     */
    read_timeout?: number;
    /**
     * Specify whether or not Cloudflare should respect strong ETag (entity tag) headers. When off, Cloudflare converts strong ETag headers to weak ETag headers.
     */
    respect_strong_etags?: boolean;
    /**
     * Define if Cloudflare should serve stale content while getting the latest content from the origin. If on, Cloudflare will not serve stale content while getting the latest content from the origin.
     */
    serve_stale?: {
      /**
       * Defines whether Cloudflare should serve stale content while updating. If true, Cloudflare will not serve stale content while getting the latest content from the origin.
       */
      disable_stale_while_updating: boolean;
    };
  };
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   * @example Set cache settings when the hostname address is not example.com
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

export type RulesetsSetConfigRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   */
  action_parameters?: {
    /**
     * Turn on or off Automatic HTTPS Rewrites.
     */
    automatic_https_rewrites?: boolean;
    /**
     * Select which file extensions to minify automatically.
     */
    autominify?: {
      /**
       * Minify CSS files.
       */
      css?: boolean;
      /**
       * Minify HTML files.
       */
      html?: boolean;
      /**
       * Minify JS files.
       */
      js?: boolean;
    };
    /**
     * Turn on or off Browser Integrity Check.
     */
    bic?: boolean;
    /**
     * Turn off all active Cloudflare Apps.
     */
    disable_apps?: true;
    /**
     * Turn off Real User Monitoring (RUM).
     */
    disable_rum?: true;
    /**
     * Turn off Zaraz.
     */
    disable_zaraz?: true;
    /**
     * Turn on or off Email Obfuscation.
     */
    email_obfuscation?: boolean;
    /**
     * Turn on or off Cloudflare Fonts.
     */
    fonts?: boolean;
    /**
     * Turn on or off the Hotlink Protection.
     */
    hotlink_protection?: boolean;
    /**
     * Turn on or off Mirage.
     */
    mirage?: boolean;
    /**
     * Turn on or off Opportunistic Encryption.
     */
    opportunistic_encryption?: boolean;
    /**
     * Configure the Polish level.
     */
    polish?: "off" | "lossless" | "lossy" | "webp";
    /**
     * Turn on or off Rocket Loader.
     */
    rocket_loader?: boolean;
    /**
     * Configure the Security Level.
     */
    security_level?:
      | "off"
      | "essentially_off"
      | "low"
      | "medium"
      | "high"
      | "under_attack";
    /**
     * Turn on or off Server Side Excludes.
     */
    server_side_excludes?: boolean;
    /**
     * Configure the SSL level.
     */
    ssl?: "off" | "flexible" | "full" | "strict" | "origin_pull";
    /**
     * Turn on or off Signed Exchanges (SXG).
     */
    sxg?: boolean;
  };
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   * @example Disable Zaraz when IP address is not 1.1.1.1
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

export type RulesetsSkipRule = {
  action?: RulesetsRuleAction;
  /**
   * The parameters configuring the rule's action.
   *
   * @example {"ruleset":"current"}
   * @minProperties 1
   */
  action_parameters?: {
    /**
     * A list of phases to skip the execution of. This option is incompatible with the rulesets option.
     *
     * @minItems 1
     * @uniqueItems true
     */
    phases?: (RulesetsRulesetPhase & void)[];
    /**
     * A list of legacy security products to skip the execution of.
     *
     * @minItems 1
     * @uniqueItems true
     */
    products?: (
      | "bic"
      | "hot"
      | "rateLimit"
      | "securityLevel"
      | "uaBlock"
      | "waf"
      | "zoneLockdown"
    )[];
    /**
     * A mapping of ruleset IDs to a list of rule IDs in that ruleset to skip the execution of. This option is incompatible with the ruleset option.
     *
     * @example {"4814384a9e5d4991b9815dcfc25d2f1f":["8ac8bc2a661e475d940980f9317f28e1"]}
     * @minProperties 1
     */
    rules?: {
      [key: string]: (RulesetsRuleId & void)[];
    };
    /**
     * A ruleset to skip the execution of. This option is incompatible with the rulesets option.
     */
    ruleset?: "current";
    /**
     * A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
     *
     * @minItems 1
     * @uniqueItems true
     */
    rulesets?: (RulesetsRulesetId & void)[];
  };
  /**
   * The categories of the rule.
   *
   * @example directory-traversal
   * @example header
   * @minItems 1
   * @uniqueItems true
   */
  categories?: RulesetsRuleCategory[];
  /**
   * An informative description of the rule.
   *
   * @default
   * @example Skip the current ruleset when the IP address is not 1.1.1.1
   */
  description?: string;
  /**
   * Whether the rule should be executed.
   *
   * @example true
   * @default true
   */
  enabled?: RulesetsRuleEnabled & void;
  /**
   * Configure checks for exposed credentials.
   */
  exposed_credential_check?: {
    /**
     * Expression that selects the password used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"password\"][0])
     */
    password_expression: string;
    /**
     * Expression that selects the user ID used in the credentials check.
     *
     * @example url_decode(http.request.body.form[\"username\"][0])
     */
    username_expression: string;
  };
  /**
   * The expression defining which traffic will match the rule.
   *
   * @example ip.src ne 1.1.1.1
   * @minLength 1
   */
  expression?: string;
  id?: RulesetsRuleId;
  /**
   * The timestamp of when the rule was last modified.
   *
   * @example 2000-01-01T00:00:00.000000Z
   * @format date-time
   */
  last_updated: string;
  /**
   * An object configuring the rule's logging behavior.
   */
  logging?: {
    /**
     * Whether to generate a log when the rule matches.
     *
     * @example true
     */
    enabled: boolean;
  };
  /**
   * An object configuring the rule's ratelimit behavior.
   */
  ratelimit?: {
    /**
     * Characteristics of the request on which the ratelimiter counter will be incremented.
     *
     * @example ip.src
     * @minLength 1
     */
    characteristics: string[];
    /**
     * Defines when the ratelimit counter should be incremented. It is optional and defaults to the same as the rule's expression.
     *
     * @example http.request.body.raw eq "abcd"
     */
    counting_expression?: string;
    /**
     * Period of time in seconds after which the action will be disabled following its first execution.
     *
     * @example 600
     */
    mitigation_timeout?: number;
    /**
     * Period in seconds over which the counter is being incremented.
     *
     * @example 60
     */
    period: number;
    /**
     * The threshold of requests per period after which the action will be executed for the first time.
     *
     * @example 1000
     * @minimum 1
     */
    requests_per_period?: number;
    /**
     * Defines if ratelimit counting is only done when an origin is reached.
     *
     * @example true
     */
    requests_to_origin?: boolean;
    /**
     * The score threshold per period for which the action will be executed the first time.
     *
     * @example 400
     */
    score_per_period?: number;
    /**
     * The response header name provided by the origin which should contain the score to increment ratelimit counter on.
     *
     * @example my-score
     */
    score_response_header_name?: string;
  };
  /**
   * The reference of the rule (the rule ID by default).
   *
   * @example my_ref
   * @minLength 1
   */
  ref?: string;
  /**
   * The version of the rule.
   *
   * @example 1
   * @pattern ^[0-9]+$
   */
  version: string;
};

/**
 * A URL Normalization object.
 */
export type RulesetsUrlNormalization = {
  /**
   * The scope of the URL normalization.
   *
   * @example incoming
   */
  scope: "incoming" | "both";
  /**
   * The type of URL normalization performed by Cloudflare.
   *
   * @example cloudflare
   */
  type: "cloudflare" | "rfc3986";
};

/**
 * The unique ID of the zone.
 *
 * @example 9f1839b6152d298aca64c4e906b6d074
 * @pattern ^[0-9a-f]{32}$
 */
export type RulesetsZoneId = string;

export type RumApiResponseCommon = {
  errors: RumMessages;
  messages: RumMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: boolean;
};

export type RumApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: RumSchemasMessages;
  messages: RumSchemasMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

/**
 * If enabled, the JavaScript snippet is automatically injected for orange-clouded sites.
 *
 * @example true
 * @x-auditable true
 */
export type RumAutoInstall = boolean;

export type RumCreateRuleRequest = {
  /**
   * @example example.com
   */
  host?: string;
  /**
   * Whether the rule includes or excludes traffic from being measured.
   *
   * @example true
   */
  inclusive?: boolean;
  /**
   * Whether the rule is paused or not.
   *
   * @example false
   */
  is_paused?: boolean;
  /**
   * @example *
   */
  paths?: string[];
};

export type RumCreateSiteRequest = {
  auto_install?: RumAutoInstall;
  host?: RumHost;
  zone_tag?: RumZoneTag;
};

export type RumCreated = RumTimestamp;

/**
 * @example true
 */
export type RumEditable = boolean;

/**
 * Enables or disables RUM. This option can be used only when auto_install is set to true.
 *
 * @example true
 * @x-auditable true
 */
export type RumEnabled = boolean;

/**
 * The hostname to use for gray-clouded sites.
 *
 * @example example.com
 * @x-auditable true
 */
export type RumHost = string;

/**
 * @example rum
 * @x-auditable true
 */
export type RumId = string;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type RumIdentifier = string;

/**
 * Whether to match the hostname using a regular expression.
 *
 * @example false
 * @x-auditable true
 */
export type RumIsHostRegex = boolean;

/**
 * If enabled, the JavaScript snippet will not be injected for visitors from the EU.
 *
 * @x-auditable true
 */
export type RumLite = boolean;

export type RumMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

export type RumModifyRulesRequest = {
  /**
   * A list of rule identifiers to delete.
   */
  delete_rules?: RumRuleIdentifier[];
  /**
   * A list of rules to create or update.
   */
  rules?: {
    /**
     * @example example.com
     */
    host?: string;
    id?: RumRuleIdentifier;
    /**
     * @example true
     */
    inclusive?: boolean;
    /**
     * @example false
     */
    is_paused?: boolean;
    /**
     * @example *
     */
    paths?: string[];
  }[];
};

/**
 * The property used to sort the list of results.
 *
 * @example host
 */
export type RumOrderBy = "host" | "created";

/**
 * Current page within the paginated list of results.
 *
 * @example 1
 */
export type RumPage = number;

/**
 * Number of items to return per page of results.
 *
 * @example 10
 */
export type RumPerPage = number;

export type RumResultInfo = {
  /**
   * The total number of items on the current page.
   *
   * @example 10
   */
  count?: number;
  /**
   * Current page within the paginated list of results.
   *
   * @example 1
   */
  page?: number;
  /**
   * The maximum number of items to return per page of results.
   *
   * @example 10
   */
  per_page?: number;
  /**
   * The total number of items.
   *
   * @example 25
   */
  total_count?: number;
  /**
   * The total number of pages.
   *
   * @example 3
   */
  total_pages?: number | null;
};

export type RumRule = {
  created?: RumTimestamp;
  /**
   * The hostname the rule will be applied to.
   *
   * @example example.com
   * @x-auditable true
   */
  host?: string;
  id?: RumRuleIdentifier;
  /**
   * Whether the rule includes or excludes traffic from being measured.
   *
   * @example true
   * @x-auditable true
   */
  inclusive?: boolean;
  /**
   * Whether the rule is paused or not.
   *
   * @example false
   * @x-auditable true
   */
  is_paused?: boolean;
  /**
   * The paths the rule will be applied to.
   *
   * @example *
   */
  paths?: string[];
  /**
   * @example 1000
   * @x-auditable true
   */
  priority?: number;
};

export type RumRuleIdResponseSingle = RumApiResponseCommon & {
  result?: {
    id?: RumRuleIdentifier;
  };
};

export type RumRuleResponseSingle = RumApiResponseCommon & {
  result?: RumRule;
};

/**
 * The Web Analytics rule identifier.
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @x-auditable true
 */
export type RumRuleIdentifier = string;

/**
 * A list of rules.
 */
export type RumRules = RumRule[];

export type RumRulesResponseCollection = RumApiResponseCommon & {
  result?: {
    rules?: RumRules;
    ruleset?: RumRuleset;
  };
};

export type RumRuleset = {
  /**
   * Whether the ruleset is enabled.
   *
   * @example true
   */
  enabled?: boolean;
  id?: RumRulesetIdentifier;
  /**
   * @example example.com
   */
  zone_name?: string;
  zone_tag?: RumZoneTag;
};

/**
 * The Web Analytics ruleset identifier.
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @x-auditable true
 */
export type RumRulesetIdentifier = string;

export type RumRumSiteResponseSingle = RumApiResponseCommon & {
  result?: RumRumSite;
};

export type RumRumSite = {
  editable?: RumEditable;
  id?: RumId;
  value?: RumValue;
};

export type RumSchemasMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

export type RumSite = {
  auto_install?: RumAutoInstall;
  created?: RumTimestamp;
  rules?: RumRules;
  ruleset?: RumRuleset;
  site_tag?: RumSiteTag;
  site_token?: RumSiteToken;
  snippet?: RumSnippet;
};

export type RumSiteResponseSingle = RumApiResponseCommon & {
  result?: RumSite;
};

export type RumSiteTagResponseSingle = RumApiResponseCommon & {
  result?: {
    site_tag?: RumSiteTag;
  };
};

/**
 * The Web Analytics site identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @x-auditable true
 */
export type RumSiteTag = string;

/**
 * The Web Analytics site token.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @x-auditable true
 */
export type RumSiteToken = string;

export type RumSitesResponseCollection = RumApiResponseCommon & {
  result?: RumSite[];
  result_info?: RumResultInfo;
};

/**
 * Encoded JavaScript snippet.
 *
 * @example <!-- Cloudflare Web Analytics --><script defer src='https://static.cloudflareinsights.com/beacon.min.js' data-cf-beacon='{"token": "bc40a2d1b5834453aba85c1b9a3054da"}'></script><!-- End Cloudflare Web Analytics -->
 * @x-auditable true
 */
export type RumSnippet = string;

/**
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type RumTimestamp = string;

export type RumToggleRumRequest = {
  /**
   * Value can either be On or Off.
   *
   * @example on
   */
  value?: string;
};

export type RumUpdateSiteRequest = {
  auto_install?: RumAutoInstall;
  enabled?: RumEnabled;
  host?: RumHost;
  lite?: RumLite;
  zone_tag?: RumZoneTag;
};

/**
 * Current state of RUM. Returns On, Off, or Manual.
 *
 * @example on
 * @x-auditable true
 */
export type RumValue = string;

/**
 * The zone identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @x-auditable true
 */
export type RumZoneTag = string;

/**
 * @example 01a7362d577a6c3019a474fd6f485823
 * @x-auditable true
 */
export type SecondaryDnsAccountIdentifier = string;

export type SecondaryDnsAcl = {
  id: SecondaryDnsComponentsSchemasIdentifier;
  ip_range: SecondaryDnsIpRange;
  name: SecondaryDnsAclComponentsSchemasName;
};

/**
 * The name of the acl.
 *
 * @example my-acl-1
 * @x-auditable true
 */
export type SecondaryDnsAclComponentsSchemasName = string;

/**
 * TSIG algorithm.
 *
 * @example hmac-sha512.
 * @x-auditable true
 */
export type SecondaryDnsAlgo = string;

export type SecondaryDnsApiResponseCollection =
  SecondaryDnsApiResponseCommon & {
    result_info?: {
      /**
       * Total number of results for the requested service.
       *
       * @example 1
       */
      count?: number;
      /**
       * Current page within paginated list of results.
       *
       * @example 1
       */
      page?: number;
      /**
       * Number of results per page of results.
       *
       * @example 20
       */
      per_page?: number;
      /**
       * Total results available without any search parameters.
       *
       * @example 2000
       */
      total_count?: number;
    };
  };

export type SecondaryDnsApiResponseCommon = {
  errors: SecondaryDnsMessages;
  messages: SecondaryDnsMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type SecondaryDnsApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: SecondaryDnsMessages;
  messages: SecondaryDnsMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type SecondaryDnsApiResponseSingle = SecondaryDnsApiResponseCommon;

/**
 * How often should a secondary zone auto refresh regardless of DNS NOTIFY.
 * Not applicable for primary zones.
 *
 * @example 86400
 * @x-auditable true
 */
export type SecondaryDnsAutoRefreshSeconds = number;

export type SecondaryDnsComponentsSchemasIdResponse =
  SecondaryDnsApiResponseSingle & {
    result?: {
      id?: SecondaryDnsComponentsSchemasIdentifier;
    };
  };

/**
 * @example 23ff594956f20c2a721606e94745a8aa
 * @x-auditable true
 */
export type SecondaryDnsComponentsSchemasIdentifier = string;

/**
 * The name of the peer.
 *
 * @example my-peer-1
 * @x-auditable true
 */
export type SecondaryDnsComponentsSchemasName = string;

export type SecondaryDnsComponentsSchemasResponseCollection =
  SecondaryDnsApiResponseCollection & {
    result?: SecondaryDnsAcl[];
  };

export type SecondaryDnsComponentsSchemasSingleResponse =
  SecondaryDnsApiResponseSingle & {
    result?: SecondaryDnsAcl;
  };

export type SecondaryDnsDisableTransferResponse =
  SecondaryDnsApiResponseSingle & {
    result?: SecondaryDnsDisableTransferResult;
  };

/**
 * The zone transfer status of a primary zone
 *
 * @example Disabled
 * @x-auditable true
 */
export type SecondaryDnsDisableTransferResult = string;

export type SecondaryDnsDnsSecondarySecondaryZone = {
  auto_refresh_seconds: SecondaryDnsAutoRefreshSeconds;
  id: SecondaryDnsIdentifier;
  name: SecondaryDnsName;
  peers: SecondaryDnsPeers;
};

export type SecondaryDnsEnableTransferResponse =
  SecondaryDnsApiResponseSingle & {
    result?: SecondaryDnsEnableTransferResult;
  };

/**
 * The zone transfer status of a primary zone
 *
 * @example Enabled
 * @x-auditable true
 */
export type SecondaryDnsEnableTransferResult = string;

export type SecondaryDnsForceResponse = SecondaryDnsApiResponseSingle & {
  result?: SecondaryDnsForceResult;
};

/**
 * When force_axfr query parameter is set to true, the response is a simple string
 *
 * @example OK
 * @x-auditable true
 */
export type SecondaryDnsForceResult = string;

export type SecondaryDnsIdResponse = SecondaryDnsApiResponseSingle & {
  result?: {
    id?: SecondaryDnsIdentifier;
  };
};

/**
 * @example 269d8f4853475ca241c4e730be286b20
 * @x-auditable true
 */
export type SecondaryDnsIdentifier = string;

/**
 * IPv4/IPv6 address of primary or secondary nameserver, depending on what zone this peer is linked to. For primary zones this IP defines the IP of the secondary nameserver Cloudflare will NOTIFY upon zone changes. For secondary zones this IP defines the IP of the primary nameserver Cloudflare will send AXFR/IXFR requests to.
 *
 * @example 192.0.2.53
 * @x-auditable true
 */
export type SecondaryDnsIp = string;

/**
 * Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively.
 *
 * @example 192.0.2.53/28
 * @x-auditable true
 */
export type SecondaryDnsIpRange = string;

/**
 * Enable IXFR transfer protocol, default is AXFR. Only applicable to secondary zones.
 *
 * @example false
 * @x-auditable true
 */
export type SecondaryDnsIxfrEnable = boolean;

export type SecondaryDnsMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * Zone name.
 *
 * @example www.example.com.
 * @x-auditable true
 */
export type SecondaryDnsName = string;

export type SecondaryDnsPeer = {
  id: SecondaryDnsComponentsSchemasIdentifier;
  ip?: SecondaryDnsIp;
  ixfr_enable?: SecondaryDnsIxfrEnable;
  name: SecondaryDnsComponentsSchemasName;
  port?: SecondaryDnsPort;
  tsig_id?: SecondaryDnsTsigId;
};

/**
 * A list of peer tags.
 *
 * @example 23ff594956f20c2a721606e94745a8aa
 * @example 00920f38ce07c2e2f4df50b1f61d4194
 */
export type SecondaryDnsPeers = SecondaryDnsIdentifier[];

/**
 * DNS port of primary or secondary nameserver, depending on what zone this peer is linked to.
 *
 * @example 53
 * @x-auditable true
 */
export type SecondaryDnsPort = number;

export type SecondaryDnsResponseCollection =
  SecondaryDnsApiResponseCollection & {
    result?: SecondaryDnsTsig[];
  };

export type SecondaryDnsSchemasForceResponse = SecondaryDnsApiResponseSingle & {
  result?: SecondaryDnsSchemasForceResult;
};

/**
 * When force_notify query parameter is set to true, the response is a simple string
 *
 * @example OK
 * @x-auditable true
 */
export type SecondaryDnsSchemasForceResult = string;

export type SecondaryDnsSchemasIdResponse = SecondaryDnsApiResponseSingle & {
  result?: {
    id?: SecondaryDnsSchemasIdentifier;
  };
};

/**
 * @example 69cd1e104af3e6ed3cb344f263fd0d5a
 * @x-auditable true
 */
export type SecondaryDnsSchemasIdentifier = string;

/**
 * TSIG key name.
 *
 * @example tsig.customer.cf.
 * @x-auditable true
 */
export type SecondaryDnsSchemasName = string;

export type SecondaryDnsSchemasResponseCollection =
  SecondaryDnsApiResponseCollection & {
    result?: SecondaryDnsPeer[];
  };

export type SecondaryDnsSchemasSingleResponse =
  SecondaryDnsApiResponseSingle & {
    result?: SecondaryDnsPeer;
  };

/**
 * TSIG secret.
 *
 * @example caf79a7804b04337c9c66ccd7bef9190a1e1679b5dd03d8aa10f7ad45e1a9dab92b417896c15d4d007c7c14194538d2a5d0feffdecc5a7f0e1c570cfa700837c
 * @x-sensitive true
 */
export type SecondaryDnsSecret = string;

export type SecondaryDnsSingleRequestOutgoing = {
  id: SecondaryDnsIdentifier;
  name: SecondaryDnsName;
  peers: SecondaryDnsPeers;
};

export type SecondaryDnsSingleResponse = SecondaryDnsApiResponseSingle & {
  result?: SecondaryDnsTsig;
};

export type SecondaryDnsSingleResponseIncoming =
  SecondaryDnsApiResponseSingle & {
    result?: {
      auto_refresh_seconds?: SecondaryDnsAutoRefreshSeconds;
      checked_time?: SecondaryDnsTime;
      created_time?: SecondaryDnsTime;
      id?: SecondaryDnsIdentifier;
      modified_time?: SecondaryDnsTime;
      name?: SecondaryDnsName;
      peers?: SecondaryDnsPeers;
      soa_serial?: SecondaryDnsSoaSerial;
    };
  };

export type SecondaryDnsSingleResponseOutgoing =
  SecondaryDnsApiResponseSingle & {
    result?: {
      checked_time?: SecondaryDnsTime;
      created_time?: SecondaryDnsTime;
      id?: SecondaryDnsIdentifier;
      last_transferred_time?: SecondaryDnsTime;
      name?: SecondaryDnsName;
      peers?: SecondaryDnsPeers;
      soa_serial?: SecondaryDnsSoaSerial;
    };
  };

/**
 * The serial number of the SOA for the given zone.
 *
 * @example 2019102400
 * @x-auditable true
 */
export type SecondaryDnsSoaSerial = number;

/**
 * The time for a specific event.
 *
 * @example 2019-10-24T17:09:42.883908+01:00
 * @x-auditable true
 */
export type SecondaryDnsTime = string;

export type SecondaryDnsTsig = {
  algo: SecondaryDnsAlgo;
  id: SecondaryDnsSchemasIdentifier;
  name: SecondaryDnsSchemasName;
  secret: SecondaryDnsSecret;
};

/**
 * TSIG authentication will be used for zone transfer if configured.
 *
 * @example 69cd1e104af3e6ed3cb344f263fd0d5a
 * @x-auditable true
 */
export type SecondaryDnsTsigId = string;

/**
 * @x-auditable true
 */
export type SecretsStoreSecretStatus = "pending" | "active" | "deleted";

/**
 * Account Identifier
 *
 * @example 985e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type SecretsStoreAccountIdentifier = string;

export type SecretsStoreApiResponseCollection =
  SecretsStoreApiResponseCommon & {
    result_info?: {
      /**
       * Total number of results for the requested service.
       *
       * @example 1
       */
      count?: number;
      /**
       * Current page within paginated list of results.
       *
       * @example 1
       */
      page?: number;
      /**
       * Number of results per page of results.
       *
       * @example 20
       */
      per_page?: number;
      /**
       * Total results available without any search parameters.
       *
       * @example 2000
       */
      total_count?: number;
    };
  };

export type SecretsStoreApiResponseCommon = {
  errors: SecretsStoreMessages;
  messages: SecretsStoreMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type SecretsStoreApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: SecretsStoreMessages;
  messages: SecretsStoreMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

/**
 * Freeform text describing the secret
 *
 * @example info about my secret
 * @x-auditable true
 */
export type SecretsStoreComment = string;

export type SecretsStoreCreateSecretObject = {
  comment?: SecretsStoreComment;
  name: SecretsStoreSecretName;
  scopes: SecretsStoreScopes;
  value: SecretsStoreValue;
};

export type SecretsStoreCreateStoreObject = {
  name: SecretsStoreStoreName;
};

/**
 * Whenthe secret was created.
 *
 * @example 2023-09-21T18:56:32.624632Z
 * @format date-time
 * @x-auditable true
 */
export type SecretsStoreCreated = string;

export type SecretsStoreDeleteSecretObject = {
  id: SecretsStoreIdentifier;
};

export type SecretsStoreDuplicateSecretObject = {
  comment?: SecretsStoreComment;
  name: SecretsStoreSecretName;
};

/**
 * Secret identifier tag.
 *
 * @example 3fd85f74b32742f1bff64a85009dda07
 * @maxLength 32
 * @x-auditable true
 */
export type SecretsStoreIdentifier = string;

export type SecretsStoreMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * When the secret was modified.
 *
 * @example 2023-09-21T18:56:32.624632Z
 * @format date-time
 * @x-auditable true
 */
export type SecretsStoreModified = string;

export type SecretsStorePatchSecretObject = {
  comment?: SecretsStoreComment;
  name: SecretsStoreSecretName;
  scopes?: SecretsStoreScopes;
  value?: SecretsStoreValue;
};

/**
 * The number of secrets the account is entitlted to use
 *
 * @example 10
 * @x-auditable true
 */
export type SecretsStoreQuota = number;

export type SecretsStoreQuotaResponse = SecretsStoreApiResponseCollection & {
  result?: SecretsStoreSecretsUsageObject;
};

/**
 * The list of services that can use this secret.
 *
 * @example workers
 */
export type SecretsStoreScopes = string[];

export type SecretsStoreSecretObject = {
  comment?: SecretsStoreComment;
  created: SecretsStoreCreated;
  id: SecretsStoreIdentifier;
  modified: SecretsStoreModified;
  name: SecretsStoreSecretName;
  status: SecretsStoreSecretStatus;
  store_id: SecretsStoreStoreIdentifier;
};

/**
 * The name of the secret
 *
 * @example MY_API_KEY
 */
export type SecretsStoreSecretName = string;

export type SecretsStoreSecretResponse = SecretsStoreApiResponseCollection & {
  result?: SecretsStoreSecretObject;
};

export type SecretsStoreSecretsUsageObject = {
  secrets: SecretsStoreUsageQuotaObject;
};

export type SecretsStoreSecretsResponseCollection =
  SecretsStoreApiResponseCollection & {
    result?: SecretsStoreSecretObject[];
  };

export type SecretsStoreStoreObject = {
  created: SecretsStoreCreated;
  id: SecretsStoreStoreIdentifier;
  modified: SecretsStoreModified;
  name: SecretsStoreStoreName;
};

/**
 * Store Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type SecretsStoreStoreIdentifier = string;

/**
 * The name of the store
 *
 * @example service_x_keys
 */
export type SecretsStoreStoreName = string;

export type SecretsStoreStoreResponse = SecretsStoreApiResponseCollection & {
  result?: SecretsStoreStoreObject;
};

export type SecretsStoreStoresResponseCollection =
  SecretsStoreApiResponseCollection & {
    result?: SecretsStoreStoreObject[];
  };

/**
 * The number of secrets the account is currently using
 *
 * @example 10
 * @x-auditable true
 */
export type SecretsStoreUsage = number;

export type SecretsStoreUsageQuotaObject = {
  quota: SecretsStoreQuota;
  usage: SecretsStoreUsage;
};

/**
 * The value of the secret. Note that this is 'write only' - no API reponse will provide this value, it is only used to create/modify secrets.
 *
 * @example api-token-secret-123
 * @x-sensitive true
 */
export type SecretsStoreValue = string;

export type SecurityCenterAccountId = SecurityCenterIdentifier;

export type SecurityCenterApiResponseCommon = {
  errors: SecurityCenterMessages;
  messages: SecurityCenterMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type SecurityCenterApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: SecurityCenterMessages;
  messages: SecurityCenterMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type SecurityCenterApiResponseSingle = SecurityCenterApiResponseCommon;

/**
 * Total number of results
 *
 * @example 1
 * @x-auditable true
 */
export type SecurityCenterCount = number;

/**
 * @example false
 * @x-auditable true
 */
export type SecurityCenterDismissed = boolean;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type SecurityCenterIdentifier = string;

export type SecurityCenterIssue = {
  /**
   * @example false
   * @x-auditable true
   */
  dismissed?: boolean;
  /**
   * @x-auditable true
   */
  id?: string;
  issue_class?: SecurityCenterIssueClass;
  issue_type?: SecurityCenterIssueType;
  payload?: Record<string, any>;
  /**
   * @x-auditable true
   */
  resolve_link?: string;
  /**
   * @x-auditable true
   */
  resolve_text?: string;
  /**
   * @x-auditable true
   */
  severity?: "Low" | "Moderate" | "Critical";
  /**
   * @format date-time
   * @x-auditable true
   */
  since?: string;
  subject?: SecurityCenterSubject;
  /**
   * @format date-time
   * @x-auditable true
   */
  timestamp?: string;
};

/**
 * @example always_use_https_not_enabled
 * @x-auditable true
 */
export type SecurityCenterIssueClass = string;

/**
 * @example a_record_dangling
 * @example always_use_https_not_enabled
 */
export type SecurityCenterIssueClasses = SecurityCenterIssueClass[];

/**
 * @x-auditable true
 */
export type SecurityCenterIssueType =
  | "compliance_violation"
  | "email_security"
  | "exposed_infrastructure"
  | "insecure_configuration"
  | "weak_authentication";

/**
 * @example compliance_violation
 * @example email_security
 */
export type SecurityCenterIssueTypes = SecurityCenterIssueType[];

export type SecurityCenterMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * Current page within paginated list of results
 *
 * @example 1
 */
export type SecurityCenterPage = number;

/**
 * Number of results per page of results
 *
 * @example 25
 * @maximum 1000
 * @minimum 1
 */
export type SecurityCenterPerPage = number;

/**
 * @example access
 * @example dns
 */
export type SecurityCenterProducts = string[];

export type SecurityCenterSecurityTxt = {
  /**
   * @example https://example.com/hall-of-fame.html
   */
  acknowledgments?: string[];
  /**
   * @example https://www.example.com/.well-known/security.txt
   */
  canonical?: string[];
  /**
   * @example mailto:security@example.com
   * @example tel:+1-201-555-0123
   * @example https://example.com/security-contact.html
   */
  contact?: string[];
  /**
   * @example true
   * @x-auditable true
   */
  enabled?: boolean;
  /**
   * @example https://example.com/pgp-key.txt
   * @example dns:5d2d37ab76d47d36._openpgpkey.example.com?type=OPENPGPKEY
   * @example openpgp4fpr:5f2de5521c63a801ab59ccb603d49de44b29100f
   */
  encryption?: string[];
  /**
   * @format date-time
   * @x-auditable true
   */
  expires?: string;
  /**
   * @example https://example.com/jobs.html
   */
  hiring?: string[];
  /**
   * @example https://example.com/disclosure-policy.html
   */
  policy?: string[];
  /**
   * @example en, es, fr
   * @x-auditable true
   */
  preferredLanguages?: string;
};

/**
 * @example low
 * @example moderate
 */
export type SecurityCenterSeverityQueryParam = (
  | "low"
  | "moderate"
  | "critical"
)[];

/**
 * @example example.com
 * @x-auditable true
 */
export type SecurityCenterSubject = string;

export type SecurityCenterSubjects = SecurityCenterSubject[];

export type SecurityCenterValueCountsResponse =
  SecurityCenterApiResponseCommon & {
    result?: {
      /**
       * @example 1
       * @x-auditable true
       */
      count?: number;
      /**
       * @x-auditable true
       */
      value?: string;
    }[];
  };

export type SecurityCenterZoneId = SecurityCenterIdentifier;

export type SnippetsApiResponseCommon = {
  errors: SnippetsMessages;
  messages: SnippetsMessages;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type SnippetsApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: SnippetsMessages;
  messages: SnippetsMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type SnippetsIdentifier = string;

export type SnippetsMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * List of snippet rules
 */
export type SnippetsRules = {
  /**
   * @example Rule description
   */
  description?: string;
  /**
   * @example true
   */
  enabled?: boolean;
  /**
   * @example http.cookie eq "a=b"
   */
  expression?: string;
  snippet_name?: SnippetsSnippetName;
}[];

/**
 * Snippet Information
 */
export type SnippetsSnippet = {
  /**
   * Creation time of the snippet
   *
   * @example 2023-07-24-00:00:00
   */
  created_on?: string;
  /**
   * Modification time of the snippet
   *
   * @example 2023-07-24-00:00:00
   */
  modified_on?: string;
  snippet_name?: SnippetsSnippetName;
};

/**
 * Snippet identifying name
 *
 * @example snippet_name_01
 * @pattern ^[A-Za-z0-9_]+$
 */
export type SnippetsSnippetName = string;

export type SnippetsZoneIdentifier = SnippetsIdentifier;

export type SpectrumAnalyticsApiResponseCommon = {
  errors: SpectrumAnalyticsMessages;
  messages: SpectrumAnalyticsMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type SpectrumAnalyticsApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: SpectrumAnalyticsMessages;
  messages: SpectrumAnalyticsMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type SpectrumAnalyticsApiResponseSingle =
  SpectrumAnalyticsApiResponseCommon;

/**
 * Comma-delimited list of Spectrum Application Id(s). If provided, the response will be limited to Spectrum Application Id(s) that match.
 *
 * @example ea95132c15732412d22c1476fa83f27a,d122c5f4bb71e25cc9e86ab43b142e2f
 */
export type SpectrumAnalyticsAppIdParam = string;

export type SpectrumAnalyticsColumn = {
  dimensions?: string[];
  metrics?: number[] | number[][];
};

/**
 * Can be used to break down the data by given attributes. Options are:
 *
 * Dimension                 | Name                            | Example
 * --------------------------|---------------------------------|--------------------------
 * event                     | Connection Event                | connect, progress, disconnect, originError, clientFiltered
 * appID                     | Application ID                  | 40d67c87c6cd4b889a4fd57805225e85
 * coloName                  | Colo Name                       | SFO
 * ipVersion                 | IP version used by the client   | 4, 6.
 *
 * @example event
 * @example appID
 */
export type SpectrumAnalyticsDimensions = (
  | "event"
  | "appID"
  | "coloName"
  | "ipVersion"
)[];

/**
 * Used to filter rows by one or more dimensions. Filters can be combined using OR and AND boolean logic. AND takes precedence over OR in all the expressions. The OR operator is defined using a comma (,) or OR keyword surrounded by whitespace. The AND operator is defined using a semicolon (;) or AND keyword surrounded by whitespace. Note that the semicolon is a reserved character in URLs (rfc1738) and needs to be percent-encoded as %3B. Comparison options are:
 *
 * Operator                  | Name                            | URL Encoded
 * --------------------------|---------------------------------|--------------------------
 * ==                        | Equals                          | %3D%3D
 * !=                        | Does not equals                 | !%3D
 * \>                        | Greater Than                    | %3E
 * \<                        | Less Than                       | %3C
 * \>=                       | Greater than or equal to        | %3E%3D
 * \<=                       | Less than or equal to           | %3C%3D
 *
 * @example event==disconnect%20AND%20coloName!=SFO
 */
export type SpectrumAnalyticsFilters = string;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type SpectrumAnalyticsIdentifier = string;

export type SpectrumAnalyticsMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * One or more metrics to compute. Options are:
 *
 * Metric                    | Name                                | Example                  | Unit
 * --------------------------|-------------------------------------|--------------------------|--------------------------
 * count                     | Count of total events               | 1000                     | Count
 * bytesIngress              | Sum of ingress bytes                | 1000                     | Sum
 * bytesEgress               | Sum of egress bytes                 | 1000                     | Sum
 * durationAvg               | Average connection duration         | 1.0                      | Time in milliseconds
 * durationMedian            | Median connection duration          | 1.0                      | Time in milliseconds
 * duration90th              | 90th percentile connection duration | 1.0                      | Time in milliseconds
 * duration99th              | 99th percentile connection duration | 1.0                      | Time in milliseconds.
 *
 * @example count
 * @example bytesIngress
 */
export type SpectrumAnalyticsMetrics = (
  | "count"
  | "bytesIngress"
  | "bytesEgress"
  | "durationAvg"
  | "durationMedian"
  | "duration90th"
  | "duration99th"
)[];

export type SpectrumAnalyticsQuery = {
  dimensions?: SpectrumAnalyticsDimensions;
  filters?: SpectrumAnalyticsFilters;
  /**
   * Limit number of returned metrics.
   */
  limit?: number;
  metrics?: SpectrumAnalyticsMetrics;
  since?: SpectrumAnalyticsSince;
  sort?: SpectrumAnalyticsSort;
  until?: SpectrumAnalyticsUntil;
};

export type SpectrumAnalyticsQueryResponseAggregate =
  SpectrumAnalyticsApiResponseSingle & {
    result?: {
      /**
       * Identifier.
       *
       * @example 023e105f4ecef8ad9ca31a8372d0c353
       * @maxLength 32
       * @x-auditable true
       */
      appID: void & SpectrumAnalyticsIdentifier;
      /**
       * Number of bytes sent
       */
      bytesEgress: number;
      /**
       * Number of bytes received
       */
      bytesIngress: number;
      /**
       * Number of connections
       */
      connections: number;
      /**
       * Average duration of connections
       */
      durationAvg: number;
    }[];
  };

export type SpectrumAnalyticsQueryResponseSingle =
  SpectrumAnalyticsApiResponseSingle & {
    result?: {
      /**
       * List of columns returned by the analytics query.
       */
      data: SpectrumAnalyticsColumn[];
      /**
       * Number of seconds between current time and last processed event, i.e. how many seconds of data could be missing.
       *
       * @example 3
       * @minimum 0
       */
      data_lag: number;
      /**
       * Maximum result for each selected metrics across all data.
       *
       * @example {"bytesEgress":100,"bytesIngress":50}
       */
      max: void & SpectrumAnalyticsStat;
      /**
       * Minimum result for each selected metrics across all data.
       *
       * @example {"bytesEgress":100,"bytesIngress":50}
       */
      min: void & SpectrumAnalyticsStat;
      query: SpectrumAnalyticsQuery;
      /**
       * Total number of rows in the result.
       *
       * @example 5
       * @minimum 0
       */
      rows: number;
      /**
       * List of time interval buckets: [start, end]
       */
      time_intervals?: SpectrumAnalyticsTimestamp[][];
      /**
       * Total result for each selected metrics across all data.
       *
       * @example {"bytesEgress":100,"bytesIngress":50}
       */
      totals: void & SpectrumAnalyticsStat;
    };
  };

/**
 * Start of time interval to query, defaults to `until` - 6 hours. Timestamp must be in RFC3339 format and uses UTC unless otherwise specified.
 *
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type SpectrumAnalyticsSince = void & SpectrumAnalyticsTimestamp;

/**
 * The sort order for the result set; sort fields must be included in `metrics` or `dimensions`.
 *
 * @example +count
 * @example -bytesIngress
 */
export type SpectrumAnalyticsSort = string[];

/**
 * @example {"bytesEgress":100,"bytesIngress":50}
 */
export type SpectrumAnalyticsStat = {
  [key: string]: number;
};

/**
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type SpectrumAnalyticsTimestamp = string;

/**
 * End of time interval to query, defaults to current time. Timestamp must be in RFC3339 format and uses UTC unless otherwise specified.
 *
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type SpectrumAnalyticsUntil = void & SpectrumAnalyticsTimestamp;

export type SpectrumConfigApiResponseCollection =
  SpectrumConfigApiResponseCommon & {
    result_info?: {
      /**
       * Total number of results for the requested service.
       *
       * @example 1
       */
      count?: number;
      /**
       * Current page within paginated list of results.
       *
       * @example 1
       */
      page?: number;
      /**
       * Number of results per page of results.
       *
       * @example 20
       */
      per_page?: number;
      /**
       * Total results available without any search parameters.
       *
       * @example 2000
       */
      total_count?: number;
    };
  };

export type SpectrumConfigApiResponseCommon = {
  errors: SpectrumConfigMessages;
  messages: SpectrumConfigMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type SpectrumConfigApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: SpectrumConfigMessages;
  messages: SpectrumConfigMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type SpectrumConfigApiResponseSingle = SpectrumConfigApiResponseCommon;

export type SpectrumConfigApiResponseSingleId =
  SpectrumConfigApiResponseCommon & {
    result?: {
      id: SpectrumConfigIdentifier;
    } | null;
  };

export type SpectrumConfigAppConfig = SpectrumConfigBaseAppConfig & {
  argo_smart_routing?: SpectrumConfigArgoSmartRouting;
  dns: SpectrumConfigDns;
  edge_ips?: SpectrumConfigEdgeIps;
  ip_firewall: SpectrumConfigIpFirewall;
  origin_direct?: SpectrumConfigOriginDirect;
  origin_dns?: SpectrumConfigOriginDns;
  origin_port?: SpectrumConfigOriginPort;
  protocol: SpectrumConfigProtocol;
  proxy_protocol: SpectrumConfigProxyProtocol;
  tls: SpectrumConfigTls;
  traffic_type: SpectrumConfigTrafficType;
};

export type SpectrumConfigAppConfigCollection =
  SpectrumConfigApiResponseCollection & {
    result?: SpectrumConfigAppConfig[] | SpectrumConfigPaygoAppConfig[];
  };

export type SpectrumConfigAppConfigSingle = SpectrumConfigApiResponseSingle & {
  result?: SpectrumConfigAppConfig | SpectrumConfigPaygoAppConfig;
};

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type SpectrumConfigAppIdentifier = void &
  void &
  SpectrumConfigIdentifier;

/**
 * Enables Argo Smart Routing for this application.
 * Notes: Only available for TCP applications with traffic_type set to "direct".
 *
 * @default false
 * @example true
 */
export type SpectrumConfigArgoSmartRouting = boolean;

export type SpectrumConfigBaseAppConfig = {
  created_on: SpectrumConfigCreated;
  id: SpectrumConfigAppIdentifier;
  modified_on: SpectrumConfigModified;
};

/**
 * When the Application was created.
 *
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type SpectrumConfigCreated = void & void & SpectrumConfigTimestamp;

/**
 * The name and type of DNS record for the Spectrum application.
 */
export type SpectrumConfigDns = {
  name?: SpectrumConfigDnsName;
  type?: SpectrumConfigDnsType;
};

/**
 * The name of the DNS record associated with the application.
 *
 * @example ssh.example.com
 * @format hostname
 */
export type SpectrumConfigDnsName = string;

/**
 * The TTL of our resolution of your DNS record in seconds.
 *
 * @minimum 600
 */
export type SpectrumConfigDnsTtl = number;

/**
 * The type of DNS record associated with the application.
 *
 * @example CNAME
 */
export type SpectrumConfigDnsType = "CNAME" | "ADDRESS";

/**
 * The anycast edge IP configuration for the hostname of this application.
 *
 * @default {"connectivity":"all","type":"dynamic"}
 */
export type SpectrumConfigEdgeIps =
  | {
      /**
       * The IP versions supported for inbound connections on Spectrum anycast IPs.
       *
       * @example all
       */
      connectivity?: "all" | "ipv4" | "ipv6";
      /**
       * The type of edge IP configuration specified. Dynamically allocated edge IPs use Spectrum anycast IPs in accordance with the connectivity you specify. Only valid with CNAME DNS names.
       *
       * @example dynamic
       */
      type?: "dynamic";
    }
  | {
      /**
       * The array of customer owned IPs we broadcast via anycast for this hostname and application.
       *
       * @example 192.0.2.1
       */
      ips?: string[];
      /**
       * The type of edge IP configuration specified. Statically allocated edge IPs use customer IPs in accordance with the ips array you specify. Only valid with ADDRESS DNS names.
       *
       * @example static
       */
      type?: "static";
    };

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type SpectrumConfigIdentifier = string;

/**
 * Enables IP Access Rules for this application.
 * Notes: Only available for TCP applications.
 *
 * @example true
 */
export type SpectrumConfigIpFirewall = boolean;

export type SpectrumConfigMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * When the Application was last modified.
 *
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type SpectrumConfigModified = void & void & SpectrumConfigTimestamp;

/**
 * List of origin IP addresses. Array may contain multiple IP addresses for load balancing.
 */
export type SpectrumConfigOriginDirect = string[];

/**
 * The name and type of DNS record for the Spectrum application.
 */
export type SpectrumConfigOriginDns = {
  name?: SpectrumConfigOriginDnsName;
  ttl?: SpectrumConfigDnsTtl;
  type?: SpectrumConfigOriginDnsType;
};

/**
 * The name of the DNS record associated with the origin.
 *
 * @example origin.example.com
 * @format hostname
 */
export type SpectrumConfigOriginDnsName = string;

/**
 * The type of DNS record associated with the origin. "" is used to specify a combination of A/AAAA records.
 *
 * @example
 */
export type SpectrumConfigOriginDnsType = "" | "A" | "AAAA" | "SRV";

/**
 * The destination port at the origin. Only specified in conjunction with origin_dns. May use an integer to specify a single origin port, for example `1000`, or a string to specify a range of origin ports, for example `"1000-2000"`.
 * Notes: If specifying a port range, the number of ports in the range must match the number of ports specified in the "protocol" field.
 *
 * @example 22
 * @maximum 65535
 * @minimum 1
 */
export type SpectrumConfigOriginPort = number | string;

export type SpectrumConfigPaygoAppConfig = SpectrumConfigBaseAppConfig & {
  dns: SpectrumConfigDns;
  origin_direct?: SpectrumConfigOriginDirect;
  protocol: SpectrumConfigProtocol;
};

/**
 * The port configuration at Cloudflare's edge. May specify a single port, for example `"tcp/1000"`, or a range of ports, for example `"tcp/1000-2000"`.
 *
 * @example tcp/22
 */
export type SpectrumConfigProtocol = string;

/**
 * Enables Proxy Protocol to the origin. Refer to [Enable Proxy protocol](https://developers.cloudflare.com/spectrum/getting-started/proxy-protocol/) for implementation details on PROXY Protocol V1, PROXY Protocol V2, and Simple Proxy Protocol.
 *
 * @default off
 * @example off
 */
export type SpectrumConfigProxyProtocol = "off" | "v1" | "v2" | "simple";

/**
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type SpectrumConfigTimestamp = string;

/**
 * The type of TLS termination associated with the application.
 *
 * @example full
 */
export type SpectrumConfigTls = "off" | "flexible" | "full" | "strict";

/**
 * Determines how data travels from the edge to your origin. When set to "direct", Spectrum will send traffic directly to your origin, and the application's type is derived from the `protocol`. When set to "http" or "https", Spectrum will apply Cloudflare's HTTP/HTTPS features as it sends traffic to your origin, and the application type matches this property exactly.
 *
 * @default direct
 * @example direct
 */
export type SpectrumConfigTrafficType = "direct" | "http" | "https";

export type SpectrumConfigUpdateAppConfig =
  | SpectrumConfigAppConfig
  | SpectrumConfigPaygoAppConfig;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type SpectrumConfigZoneIdentifier = void &
  void &
  SpectrumConfigIdentifier;

export type SpeedApiResponseCommon = {
  errors: SpeedMessages;
  messages: SpeedMessages;
  /**
   * Whether the API call was successful
   *
   * @example true
   * @x-auditable true
   */
  success: boolean;
};

export type SpeedApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: SpeedMessages;
  messages: SpeedMessages;
  result: Record<string, any> | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   * @x-auditable true
   */
  success: boolean;
};

export type SpeedApiResponseSingleId = SpeedApiResponseCommon & {
  result?: {
    id: SpeedIdentifier;
  } | null;
};

export type SpeedBase = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   * @x-auditable true
   */
  editable?: true | false;
  /**
   * Identifier of the zone setting.
   *
   * @example development_mode
   * @x-auditable true
   */
  id?: string;
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   * @x-auditable true
   */
  value?: "on" | "off";
};

/**
 * Enhance your website's font delivery with Cloudflare Fonts. Deliver Google Hosted fonts from your own domain,
 * boost performance, and enhance user privacy. Refer to the Cloudflare Fonts documentation for more information.
 */
export type SpeedCloudflareFonts = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   * @x-auditable true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example fonts
   * @x-auditable true
   */
  id?: "fonts";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   * @x-auditable true
   */
  value?: SpeedCloudflareFontsValue;
};

/**
 * Whether the feature is enabled or disabled.
 *
 * @default off
 * @x-auditable true
 */
export type SpeedCloudflareFontsValue = "on" | "off";

export type SpeedCloudflareSpeedBrainResponse = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   * @x-auditable true
   */
  editable?: true | false;
  /**
   * Identifier of the zone setting.
   *
   * @example development_mode
   * @x-auditable true
   */
  id?: string;
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string | null;
  /**
   * Whether the feature is enabled or disabled.
   * Defaults to "on" for Free plans, otherwise defaults to "off".
   *
   * @example on
   * @x-auditable true
   */
  value?: "on" | "off";
};

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type SpeedIdentifier = string;

export type SpeedMessages = {
  /**
   * @minimum 1000
   * @x-auditable true
   */
  code: number;
  /**
   * @x-auditable true
   */
  message: string;
}[];

/**
 * Defines rules for fine-grained control over content than signed URL tokens alone. Access rules primarily make tokens conditionally valid based on user information. Access Rules are specified on token payloads as the `accessRules` property containing an array of Rule objects.
 */
export type StreamAccessRules = {
  /**
   * The action to take when a request matches a rule. If the action is `block`, the signed token blocks views for viewers matching the rule.
   *
   * @example allow
   * @x-auditable true
   */
  action?: "allow" | "block";
  /**
   * An array of 2-letter country codes in ISO 3166-1 Alpha-2 format used to match requests.
   */
  country?: string[];
  /**
   * An array of IPv4 or IPV6 addresses or CIDRs used to match requests.
   */
  ip?: string[];
  /**
   * Lists available rule types to match for requests. An `any` type matches all requests and can be used as a wildcard to apply default actions after other rules.
   *
   * @example ip.src
   * @x-auditable true
   */
  type?: "any" | "ip.src" | "ip.geoip.country";
};

/**
 * The account identifier tag.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type StreamAccountIdentifier = string;

export type StreamAddAudioTrackResponse = StreamApiResponseCommon & {
  result?: StreamAdditionalAudio;
};

export type StreamAdditionalAudio = {
  ["default"]?: StreamAudioDefault;
  label?: StreamAudioLabel;
  status?: StreamAudioState;
  uid?: StreamIdentifier;
};

/**
 * Lists the origins allowed to display the video. Enter allowed origin domains in an array and use `*` for wildcard subdomains. Empty arrays allow the video to be viewed on any origin.
 *
 * @example example.com
 */
export type StreamAllowedOrigins = string[];

export type StreamApiResponseCommon = {
  errors: StreamMessages;
  messages: StreamMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type StreamApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: StreamMessages;
  messages: StreamMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type StreamApiResponseSingle = StreamApiResponseCommon;

/**
 * Lists videos in ascending order of creation.
 *
 * @default false
 * @example true
 */
export type StreamAsc = boolean;

/**
 * Denotes whether the audio track will be played by default in a player.
 *
 * @default false
 * @x-auditable true
 */
export type StreamAudioDefault = boolean;

/**
 * The unique identifier for an additional audio track.
 *
 * @example ea95132c15732412d22c1476fa83f27a
 * @maxLength 32
 * @x-auditable true
 */
export type StreamAudioIdentifier = string;

/**
 * A string to uniquely identify the track amongst other audio track labels for the specified video.
 *
 * @example director commentary
 * @x-auditable true
 */
export type StreamAudioLabel = string;

/**
 * Specifies the processing status of the video.
 *
 * @x-auditable true
 */
export type StreamAudioState = "queued" | "ready" | "error";

export type StreamCaptionBasicUpload = {
  /**
   * The WebVTT file containing the caption or subtitle content.
   *
   * @example @/Users/kyle/Desktop/tr.vtt
   * @x-auditable true
   */
  file: string;
};

/**
 * The status of a generated caption.
 *
 * @x-auditable true
 */
export type StreamCaptionStatus = "ready" | "inprogress" | "error";

export type StreamCaptions = {
  generated?: StreamGeneratedCaption;
  label?: StreamLabel;
  language?: StreamLanguage;
  status?: StreamCaptionStatus;
};

export type StreamClipResponseSingle = StreamApiResponseCommon & {
  result?: StreamClipping;
};

/**
 * The unique video identifier (UID).
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type StreamClippedFromVideoUid = string;

export type StreamClipping = {
  allowedOrigins?: StreamAllowedOrigins;
  clippedFromVideoUID?: StreamClippedFromVideoUid;
  created?: StreamClippingCreated;
  creator?: StreamCreator;
  endTimeSeconds?: StreamEndTimeSeconds;
  maxDurationSeconds?: StreamMaxDurationSeconds;
  meta?: StreamMediaMetadata;
  modified?: StreamLiveInputModified;
  playback?: StreamPlayback;
  preview?: StreamPreview;
  requireSignedURLs?: StreamRequireSignedURLs;
  startTimeSeconds?: StreamStartTimeSeconds;
  status?: StreamMediaState;
  thumbnailTimestampPct?: StreamThumbnailTimestampPct;
  watermark?: StreamWatermarkAtUpload;
};

/**
 * The date and time the clip was created.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 */
export type StreamClippingCreated = string;

export type StreamCopyAudioTrack = {
  label: StreamAudioLabel;
  /**
   * An audio track URL. The server must be publicly routable and support `HTTP HEAD` requests and `HTTP GET` range requests. The server should respond to `HTTP HEAD` requests with a `content-range` header that includes the size of the file.
   *
   * @example https://www.examplestorage.com/audio_file.mp3
   * @format uri
   * @x-auditable true
   */
  url?: string;
};

export type StreamCreateInputRequest = {
  defaultCreator?: StreamLiveInputDefaultCreator;
  deleteRecordingAfterDays?: StreamLiveInputRecordingDeletion;
  meta?: StreamLiveInputMetadata;
  recording?: StreamLiveInputRecordingSettings;
};

export type StreamCreateOutputRequest = {
  enabled?: StreamOutputEnabled;
  streamKey: StreamOutputStreamKey;
  url: StreamOutputUrl;
};

/**
 * The date and time the media item was created.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type StreamCreated = string;

/**
 * A user-defined identifier for the media creator.
 *
 * @example creator-id_abcde12345
 * @maxLength 64
 * @x-auditable true
 */
export type StreamCreator = string;

export type StreamDeletedResponse = StreamApiResponseSingle & {
  /**
   * @example ok
   */
  result?: string;
};

export type StreamDirectUploadRequest = {
  allowedOrigins?: StreamAllowedOrigins;
  creator?: StreamCreator;
  /**
   * The date and time after upload when videos will not be accepted.
   *
   * @default Now + 30 minutes
   * @example 2021-01-02T02:20:00Z
   * @format date-time
   * @x-auditable true
   */
  expiry?: string;
  maxDurationSeconds: StreamMaxDurationSeconds;
  meta?: StreamMediaMetadata;
  requireSignedURLs?: StreamRequireSignedURLs;
  scheduledDeletion?: StreamScheduledDeletion;
  thumbnailTimestampPct?: StreamThumbnailTimestampPct;
  watermark?: StreamWatermarkAtUpload2;
};

export type StreamDirectUploadResponse = StreamApiResponseSingle & {
  result?: {
    scheduledDeletion?: StreamScheduledDeletion;
    uid?: StreamIdentifier;
    /**
     * The URL an unauthenticated upload can use for a single `HTTP POST multipart/form-data` request.
     *
     * @example www.example.com/samplepath
     */
    uploadURL?: string;
    watermark?: StreamWatermarks;
  };
};

/**
 * Provisions a URL to let your end users upload videos directly to Cloudflare Stream without exposing your API token to clients.
 *
 * @default false
 * @example true
 * @x-auditable true
 */
export type StreamDirectUser = boolean;

/**
 * The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
 *
 * @example https://company.com/logo.png
 * @x-auditable true
 */
export type StreamDownloadedFrom = string;

export type StreamDownloadsResponse = StreamApiResponseSingle & {
  result?: Record<string, any>;
};

/**
 * The duration of the video in seconds. A value of `-1` means the duration is unknown. The duration becomes available after the upload and before the video is ready.
 *
 * @x-auditable true
 */
export type StreamDuration = number;

export type StreamEditAudioTrack = {
  ["default"]?: StreamAudioDefault;
  label?: StreamAudioLabel;
};

/**
 * Lists videos created before the specified date.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 */
export type StreamEnd = string;

/**
 * Specifies the end time for the video clip in seconds.
 *
 * @x-auditable true
 */
export type StreamEndTimeSeconds = number;

/**
 * Specifies why the video failed to encode. This field is empty if the video is not in an `error` state. Preferred for programmatic use.
 *
 * @example ERR_NON_VIDEO
 * @x-auditable true
 */
export type StreamErrorReasonCode = string;

/**
 * Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an `error` state.
 *
 * @example The file was not recognized as a valid video file.
 * @x-auditable true
 */
export type StreamErrorReasonText = string;

/**
 * Whether the caption was generated via AI.
 *
 * @example true
 * @x-auditable true
 */
export type StreamGeneratedCaption = boolean;

/**
 * The height of the image in pixels.
 *
 * @x-auditable true
 */
export type StreamHeight = number;

/**
 * A Cloudflare-generated unique identifier for a media item.
 *
 * @example ea95132c15732412d22c1476fa83f27a
 * @maxLength 32
 * @x-auditable true
 */
export type StreamIdentifier = string;

/**
 * Includes the total number of videos associated with the submitted query parameters.
 *
 * @default false
 * @example true
 */
export type StreamIncludeCounts = boolean;

export type StreamInput = {
  /**
   * The video height in pixels. A value of `-1` means the height is unknown. The value becomes available after the upload and before the video is ready.
   *
   * @x-auditable true
   */
  height?: number;
  /**
   * The video width in pixels. A value of `-1` means the width is unknown. The value becomes available after the upload and before the video is ready.
   *
   * @x-auditable true
   */
  width?: number;
};

/**
 * Details for streaming to an live input using RTMPS.
 */
export type StreamInputRtmps = {
  streamKey?: StreamInputRtmpsStreamKey;
  url?: StreamInputRtmpsUrl;
};

/**
 * The secret key to use when streaming via RTMPS to a live input.
 *
 * @example 2fb3cb9f17e68a2568d6ebed8d5505eak3ceaf8c9b1f395e1b76b79332497cada
 * @x-sensitive true
 */
export type StreamInputRtmpsStreamKey = string;

/**
 * The RTMPS URL you provide to the broadcaster, which they stream live video to.
 *
 * @example rtmps://live.cloudflare.com:443/live/
 * @x-sensitive true
 */
export type StreamInputRtmpsUrl = string;

/**
 * Details for streaming to a live input using SRT.
 */
export type StreamInputSrt = {
  passphrase?: StreamInputSrtStreamPassphrase;
  streamId?: StreamInputSrtStreamId;
  url?: StreamInputSrtUrl;
};

/**
 * The identifier of the live input to use when streaming via SRT.
 *
 * @example f256e6ea9341d51eea64c9454659e576
 * @x-auditable true
 */
export type StreamInputSrtStreamId = string;

/**
 * The secret key to use when streaming via SRT to a live input.
 *
 * @example 2fb3cb9f17e68a2568d6ebed8d5505eak3ceaf8c9b1f395e1b76b79332497cada
 * @x-sensitive true
 */
export type StreamInputSrtStreamPassphrase = string;

/**
 * The SRT URL you provide to the broadcaster, which they stream live video to.
 *
 * @example srt://live.cloudflare.com:778
 * @x-sensitive true
 */
export type StreamInputSrtUrl = string;

/**
 * Details for streaming to a live input using WebRTC.
 */
export type StreamInputWebrtc = {
  url?: StreamInputWebrtcUrl;
};

/**
 * The WebRTC URL you provide to the broadcaster, which they stream live video to.
 *
 * @example https://customer-m033z5x00ks6nunl.cloudflarestream.com/b236bde30eb07b9d01318940e5fc3edake34a3efb3896e18f2dc277ce6cc993ad/webRTC/publish
 * @x-sensitive true
 */
export type StreamInputWebrtcUrl = string;

/**
 * The signing key in JWK format.
 *
 * @example eyJ1c2UiOiJzaWciLCJrdHkiOiJSU0EiLCJraWQiOiI1MjEzY2ZhMTIxZjcwYjhjMTM4MDY4NmZmYzM3MWJhMyIsImFsZyI6IlJTMjU2IiwibiI6IjBUandqT2laV21KNDN2ZjNUbzREb1htWFd0SkdOR3lYZmh5dHRMYUJnRjEtRVFXUURLaG9LYm9hS21xakNBc21za3V0YkxVN1BVOGRrUU5ER1p3S3VWczA4elNaNGt4aTR0RWdQUFp5dDdkWEMtbFlSWW95ckFHRjRBWGh5MzI5YkhDUDFJbHJCQl9Ba0dnbmRMQWd1bnhZMHJSZ2N2T3ppYXc2S0p4Rm5jMlVLMFdVOGIwcDRLS0hHcDFLTDlkazBXVDhkVllxYmVSaUpqQ2xVRW1oOHl2OUNsT1ZhUzRLeGlYNnhUUTREWnc2RGFKZklWM1F0Tmd2cG1ieWxOSmFQSG5zc3JodDJHS1A5NjJlS2poUVJsaWd2SFhKTE9uSm9KZkxlSUVIWi1peFdmY1RETUg5MnNHdm93MURPanhMaUNOMXpISy1oN2JMb1hUaUxnYzRrdyIsImUiOiJBUUFCIiwiZCI6IndpQWEwaU5mWnNYSGNOcVMxSWhnUmdzVHJHay1TcFlYV2lReDZHTU9kWlJKekhGazN0bkRERFJvNHNKZTBxX0dEOWkzNlEyZkVadS15elpEcEJkc3U5OHNtaHhNU19Ta0s5X3VFYUo1Zm96V2IyN3JRRnFoLVliUU9MUThkUnNPRHZmQl9Hb2txWWJzblJDR3kzWkFaOGZJZ25ocXBUNEpiOHdsaWxpMUgxeFpzM3RnTWtkTEluTm1yMFAtcTYxZEtNd3JYZVRoSWNEc0kyb2Z1LTFtRm1MWndQb2ZGbmxaTW9QN1pfRU5pUGNfWGtWNzFhaHBOZE9pcW5ablZtMHBCNE5QS1UweDRWTjQyYlAzWEhMUmpkV2hJOGt3SC1BdXhqb3BLaHJ0R2tvcG1jZFRkM1ZRdElaOGRpZHByMXpBaEpvQi16ZVlIaTFUel9ZSFFld0FRUSIsInAiOiIyVTZFVUJka3U3TndDYXoyNzZuWGMxRXgwVHpNZjU4U0UtU2M2eUNaYWk2TkwzVURpWi1mNHlIdkRLYnFGUXdLWDNwZ0l2aVE3Y05QYUpkbE9NeS1mU21GTXU3V3hlbVZYamFlTjJCMkRDazhQY0NEOVgxU2hhR3E1ZUdSSHNObVUtSDNxTG1FRGpjLWliazRHZ0RNb2lVYjQ2OGxFZHAwU2pIOXdsOUdsYTgiLCJxIjoiOW5ucXg5ZnNNY2dIZ29DemhfVjJmaDhoRUxUSUM5aFlIOVBCTG9aQjZIaE1TWG1ja1BSazVnUlpPWlFEN002TzlMaWZjNmFDVXdEbjBlQzU2YkFDNUNrcWxjODJsVDhzTWlMeWJyTjh3bWotcjNjSTBGQTlfSGQySEY1ZkgycnJmenVqd0NWM3czb09Ud3p4d1g3c2xKbklRanphel91SzEyWEtucVZZcUYwIiwiZHAiOiJxQklTUTlfVUNWaV9Ucng0UU9VYnZoVU9jc2FUWkNHajJiNzNudU9YeElnOHFuZldSSnN4RG5zd2FKaXdjNWJjYnZ3M1h0VGhRd1BNWnhpeE1UMHFGNlFGWVY5WXZibnJ6UEp4YkdNdTZqajZYc2lIUjFlbWU3U09lVDM4Xzg0aFZyOXV6UkN2RWstb0R0MHlodW9YVzFGWVFNRTE2cGtMV0ZkUjdRUERsQUUiLCJkcSI6Im5zQUp3eXZFbW8tdW5wU01qYjVBMHB6MExCRjBZNFMxeGRJYXNfLVBSYzd0dThsVFdWMl8teExEOFR6dmhqX0lmY0RJR3JJZGNKNjlzVVZnR1M3ZnZkcng3Y21uNjFyai1XcmU0UVJFRC1lV1dxZDlpc2FVRmg5UGVKZ2tCbFZVVnYtdnladVlWdFF2a1NUU05ZR3RtVXl2V2xKZDBPWEFHRm9jdGlfak9aVSIsInFpIjoib0dYaWxLQ2NKRXNFdEE1eG54WUdGQW5UUjNwdkZLUXR5S0F0UGhHaHkybm5ya2VzN1RRaEFxMGhLRWZtU1RzaE1hNFhfd05aMEstX1F0dkdoNDhpeHdTTDVLTEwxZnFsY0k2TF9XUnF0cFQxS21LRERlUHR2bDVCUzFGbjgwSGFwR215cmZRWUU4S09QR2UwUl82S1BOZE1vc3dYQ3Nfd0RYMF92ZzNoNUxRIn0=
 * @x-sensitive true
 */
export type StreamJwk = string;

export type StreamKeyGenerationResponse = StreamApiResponseCommon & {
  result?: StreamKeys;
};

export type StreamKeyResponseCollection = StreamApiResponseCommon & {
  result?: {
    created?: StreamSigningKeyCreated;
    id?: StreamSchemasIdentifier;
  }[];
};

export type StreamKeys = {
  created?: StreamSigningKeyCreated;
  id?: StreamSchemasIdentifier;
  jwk?: StreamJwk;
  pem?: StreamPem;
};

/**
 * The language label displayed in the native language to users.
 *
 * @example Türkçe
 * @x-auditable true
 */
export type StreamLabel = string;

/**
 * The language tag in BCP 47 format.
 *
 * @example tr
 * @x-auditable true
 */
export type StreamLanguage = string;

export type StreamLanguageResponseCollection = StreamApiResponseCommon & {
  result?: StreamCaptions[];
};

export type StreamLanguageResponseSingle = StreamApiResponseSingle & {
  result?: StreamCaptions;
};

export type StreamListAudioTrackResponse = StreamApiResponseCommon & {
  result?: StreamAdditionalAudio[];
};

/**
 * The live input ID used to upload a video with Stream Live.
 *
 * @example fc0a8dc887b16759bfd9ad922230a014
 * @maxLength 32
 * @x-auditable true
 */
export type StreamLiveInput = string;

/**
 * The date and time the live input was created.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type StreamLiveInputCreated = string;

/**
 * Sets the creator ID asssociated with this live input.
 *
 * @x-auditable true
 */
export type StreamLiveInputDefaultCreator = string;

/**
 * A unique identifier for a live input.
 *
 * @example 66be4bf738797e01e1fca35a7bdecdcd
 * @maxLength 32
 * @x-auditable true
 */
export type StreamLiveInputIdentifier = string;

/**
 * A user modifiable key-value store used to reference other systems of record for managing live inputs.
 *
 * @example {"name":"test stream 1"}
 */
export type StreamLiveInputMetadata = Record<string, any>;

/**
 * The date and time the live input was last modified.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type StreamLiveInputModified = string;

export type StreamLiveInputObjectWithoutUrl = {
  created?: StreamLiveInputCreated;
  deleteRecordingAfterDays?: StreamLiveInputRecordingDeletion;
  meta?: StreamLiveInputMetadata;
  modified?: StreamLiveInputModified;
  uid?: StreamLiveInputIdentifier;
};

/**
 * Lists the origins allowed to display videos created with this input. Enter allowed origin domains in an array and use `*` for wildcard subdomains. An empty array allows videos to be viewed on any origin.
 *
 * @example example.com
 */
export type StreamLiveInputRecordingAllowedOrigins = string[];

/**
 * Indicates the number of days after which the live inputs recordings will be deleted. When a stream completes and the recording is ready, the value is used to calculate a scheduled deletion date for that recording. Omit the field to indicate no change, or include with a `null` value to remove an existing scheduled deletion.
 *
 * @example 45
 * @minimum 30
 * @x-auditable true
 */
export type StreamLiveInputRecordingDeletion = number;

/**
 * Disables reporting the number of live viewers when this property is set to `true`.
 *
 * @default false
 * @example true
 * @x-auditable true
 */
export type StreamLiveInputRecordingHideLiveViewerCount = boolean;

/**
 * Specifies the recording behavior for the live input. Set this value to `off` to prevent a recording. Set the value to `automatic` to begin a recording and transition to on-demand after Stream Live stops receiving input.
 *
 * @default off
 * @example automatic
 * @x-auditable true
 */
export type StreamLiveInputRecordingMode = "off" | "automatic";

/**
 * Indicates if a video using the live input has the `requireSignedURLs` property set. Also enforces access controls on any video recording of the livestream with the live input.
 *
 * @default false
 * @example true
 * @x-auditable true
 */
export type StreamLiveInputRecordingRequireSignedURLs = boolean;

/**
 * Records the input to a Cloudflare Stream video. Behavior depends on the mode. In most cases, the video will initially be viewable as a live video and transition to on-demand after a condition is satisfied.
 *
 * @example {"hideLiveViewerCount":false,"mode":"off","requireSignedURLs":false,"timeoutSeconds":0}
 */
export type StreamLiveInputRecordingSettings = {
  allowedOrigins?: StreamLiveInputRecordingAllowedOrigins;
  hideLiveViewerCount?: StreamLiveInputRecordingHideLiveViewerCount;
  mode?: StreamLiveInputRecordingMode;
  requireSignedURLs?: StreamLiveInputRecordingRequireSignedURLs;
  timeoutSeconds?: StreamLiveInputRecordingTimeoutSeconds;
};

/**
 * Determines the amount of time a live input configured in `automatic` mode should wait before a recording transitions from live to on-demand. `0` is recommended for most use cases and indicates the platform default should be used.
 *
 * @default 0
 * @x-auditable true
 */
export type StreamLiveInputRecordingTimeoutSeconds = number;

export type StreamLiveInputResponseCollection = StreamApiResponseCommon & {
  result?: {
    liveInputs?: StreamLiveInputObjectWithoutUrl[];
    /**
     * The total number of remaining live inputs based on cursor position.
     *
     * @example 1000
     */
    range?: number;
    /**
     * The total number of live inputs that match the provided filters.
     *
     * @example 35586
     */
    total?: number;
  };
};

export type StreamLiveInputResponseSingle = StreamApiResponseSingle & {
  result?: StreamLiveInput2;
};

/**
 * The connection status of a live input.
 *
 * @x-auditable true
 */
export type StreamLiveInputStatus =
  | any
  | "connected"
  | "reconnected"
  | "reconnecting"
  | "client_disconnect"
  | "ttl_exceeded"
  | "failed_to_connect"
  | "failed_to_reconnect"
  | "new_configuration_accepted"
  | null;

/**
 * The maximum duration in seconds for a video upload. Can be set for a video that is not yet uploaded to limit its duration. Uploads that exceed the specified duration will fail during processing. A value of `-1` means the value is unknown.
 *
 * @maximum 36000
 * @minimum 1
 * @x-auditable true
 */
export type StreamMaxDurationSeconds = number;

/**
 * A user modifiable key-value store used to reference other systems of record for managing videos.
 *
 * @example {"name":"video12345.mp4"}
 */
export type StreamMediaMetadata = Record<string, any>;

/**
 * Specifies the processing status for all quality levels for a video.
 *
 * @example inprogress
 * @x-auditable true
 */
export type StreamMediaState =
  | "pendingupload"
  | "downloading"
  | "queued"
  | "inprogress"
  | "ready"
  | "error"
  | "live-inprogress";

/**
 * Specifies a detailed status for a video. If the `state` is `inprogress` or `error`, the `step` field returns `encoding` or `manifest`. If the `state` is `inprogress`, `pctComplete` returns a number between 0 and 100 to indicate the approximate percent of completion. If the `state` is `error`, `errorReasonCode` and `errorReasonText` provide additional details.
 */
export type StreamMediaStatus = {
  errorReasonCode?: StreamErrorReasonCode;
  errorReasonText?: StreamErrorReasonText;
  pctComplete?: StreamPctComplete;
  state?: StreamMediaState;
};

export type StreamMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * The date and time the media item was last modified.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type StreamModified = string;

/**
 * A short description of the watermark profile.
 *
 * @default
 * @example Marketing Videos
 * @x-auditable true
 */
export type StreamName = string;

/**
 * The URL where webhooks will be sent.
 *
 * @example https://example.com
 * @format uri
 * @x-auditable true
 */
export type StreamNotificationUrl = string;

/**
 * The date and time when the video upload URL is no longer valid for direct user uploads.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type StreamOneTimeUploadExpiry = string;

/**
 * The translucency of the image. A value of `0.0` makes the image completely transparent, and `1.0` makes the image completely opaque. Note that if the image is already semi-transparent, setting this to `1.0` will not make the image completely opaque.
 *
 * @default 1
 * @example 0.75
 * @maximum 1
 * @minimum 0
 * @x-auditable true
 */
export type StreamOpacity = number;

export type StreamOutput = {
  enabled?: StreamOutputEnabled;
  streamKey?: StreamOutputStreamKey;
  uid?: StreamOutputIdentifier;
  url?: StreamOutputUrl;
};

/**
 * When enabled, live video streamed to the associated live input will be sent to the output URL. When disabled, live video will not be sent to the output URL, even when streaming to the associated live input. Use this to control precisely when you start and stop simulcasting to specific destinations like YouTube and Twitch.
 *
 * @default true
 * @example true
 * @x-auditable true
 */
export type StreamOutputEnabled = boolean;

/**
 * A unique identifier for the output.
 *
 * @example baea4d9c515887b80289d5c33cf01145
 * @maxLength 32
 * @x-auditable true
 */
export type StreamOutputIdentifier = string;

export type StreamOutputResponseCollection = StreamApiResponseCommon & {
  result?: StreamOutput[];
};

export type StreamOutputResponseSingle = StreamApiResponseSingle & {
  result?: StreamOutput;
};

/**
 * The streamKey used to authenticate against an output's target.
 *
 * @example uzya-f19y-g2g9-a2ee-51j2
 * @x-sensitive true
 */
export type StreamOutputStreamKey = string;

/**
 * The URL an output uses to restream.
 *
 * @example rtmp://a.rtmp.youtube.com/live2
 * @x-sensitive true
 */
export type StreamOutputUrl = string;

/**
 * The whitespace between the adjacent edges (determined by position) of the video and the image. `0.0` indicates no padding, and `1.0` indicates a fully padded video width or length, as determined by the algorithm.
 *
 * @default 0.05
 * @example 0.1
 * @maximum 1
 * @minimum 0
 * @x-auditable true
 */
export type StreamPadding = number;

/**
 * Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
 *
 * @maximum 100
 * @minimum 0
 * @x-auditable true
 */
export type StreamPctComplete = string;

/**
 * The signing key in PEM format.
 *
 * @example LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcGdJQkFBS0NBUUVBMFRqd2pPaVpXbUo0M3ZmM1RvNERvWG1YV3RKR05HeVhmaHl0dExhQmdGMStFUVdRCkRLaG9LYm9hS21xakNBc21za3V0YkxVN1BVOGRrUU5ER1p3S3VWczA4elNaNGt4aTR0RWdQUFp5dDdkWEMrbFkKUllveXJBR0Y0QVhoeTMyOWJIQ1AxSWxyQkIvQWtHZ25kTEFndW54WTByUmdjdk96aWF3NktKeEZuYzJVSzBXVQo4YjBwNEtLSEdwMUtMOWRrMFdUOGRWWXFiZVJpSmpDbFVFbWg4eXY5Q2xPVmFTNEt4aVg2eFRRNERadzZEYUpmCklWM1F0Tmd2cG1ieWxOSmFQSG5zc3JodDJHS1A5NjJlS2poUVJsaWd2SFhKTE9uSm9KZkxlSUVIWitpeFdmY1QKRE1IOTJzR3ZvdzFET2p4TGlDTjF6SEsraDdiTG9YVGlMZ2M0a3dJREFRQUJBb0lCQVFEQ0lCclNJMTlteGNkdwoycExVaUdCR0N4T3NhVDVLbGhkYUpESG9ZdzUxbEVuTWNXVGUyY01NTkdqaXdsN1NyOFlQMkxmcERaOFJtNzdMCk5rT2tGMnk3M3l5YUhFeEw5S1FyMys0Um9ubCtqTlp2YnV0QVdxSDVodEE0dER4MUd3NE85OEg4YWlTcGh1eWQKRUliTGRrQm54OGlDZUdxbFBnbHZ6Q1dLV0xVZlhGbXplMkF5UjBzaWMyYXZRLzZyclYwb3pDdGQ1T0Vod093agphaCs3N1dZV1l0bkEraDhXZVZreWcvdG44UTJJOXo5ZVJYdlZxR2sxMDZLcWRtZFdiU2tIZzA4cFRUSGhVM2paCnMvZGNjdEdOMWFFanlUQWY0QzdHT2lrcUd1MGFTaW1aeDFOM2RWQzBobngySjJtdlhNQ0VtZ0g3TjVnZUxWUFAKOWdkQjdBQkJBb0dCQU5sT2hGQVhaTHV6Y0Ftczl1K3AxM05STWRFOHpIK2ZFaFBrbk9zZ21Xb3VqUzkxQTRtZgpuK01oN3d5bTZoVU1DbDk2WUNMNGtPM0RUMmlYWlRqTXZuMHBoVEx1MXNYcGxWNDJuamRnZGd3cFBEM0FnL1Y5ClVvV2hxdVhoa1I3RFpsUGg5Nmk1aEE0M1BvbTVPQm9BektJbEcrT3ZKUkhhZEVveC9jSmZScFd2QW9HQkFQWjUKNnNmWDdESElCNEtBczRmMWRuNGZJUkMweUF2WVdCL1R3UzZHUWVoNFRFbDVuSkQwWk9ZRVdUbVVBK3pPanZTNApuM09tZ2xNQTU5SGd1ZW13QXVRcEtwWFBOcFUvTERJaThtNnpmTUpvL3E5M0NOQlFQZngzZGh4ZVh4OXE2Mzg3Cm84QWxkOE42RGs4TThjRis3SlNaeUVJODJzLzdpdGRseXA2bFdLaGRBb0dCQUtnU0VrUGYxQWxZdjA2OGVFRGwKRzc0VkRuTEdrMlFobzltKzk1N2psOFNJUEtwMzFrU2JNUTU3TUdpWXNIT1czRzc4TjE3VTRVTUR6R2NZc1RFOQpLaGVrQldGZldMMjU2OHp5Y1d4akx1bzQrbDdJaDBkWHBudTBqbms5L1AvT0lWYS9iczBRcnhKUHFBN2RNb2JxCkYxdFJXRURCTmVxWkMxaFhVZTBEdzVRQkFvR0JBSjdBQ2NNcnhKcVBycDZVakkyK1FOS2M5Q3dSZEdPRXRjWFMKR3JQL2owWE83YnZKVTFsZHYvc1N3L0U4NzRZL3lIM0F5QnF5SFhDZXZiRkZZQmt1MzczYThlM0pwK3RhNC9scQozdUVFUkEvbmxscW5mWXJHbEJZZlQzaVlKQVpWVkZiL3I4bWJtRmJVTDVFazBqV0JyWmxNcjFwU1hkRGx3QmhhCkhMWXY0em1WQW9HQkFLQmw0cFNnbkNSTEJMUU9jWjhXQmhRSjAwZDZieFNrTGNpZ0xUNFJvY3RwNTY1SHJPMDAKSVFLdElTaEg1a2s3SVRHdUYvOERXZEN2djBMYnhvZVBJc2NFaStTaXk5WDZwWENPaS8xa2FyYVU5U3BpZ3czago3YjVlUVV0UlovTkIycVJwc3EzMEdCUENqanhudEVmK2lqelhUS0xNRndyUDhBMTlQNzRONGVTMAotLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQo=
 * @x-sensitive true
 */
export type StreamPem = string;

export type StreamPlayback = {
  /**
   * DASH Media Presentation Description for the video.
   *
   * @example https://customer-m033z5x00ks6nunl.cloudflarestream.com/ea95132c15732412d22c1476fa83f27a/manifest/video.mpd
   * @x-auditable true
   */
  dash?: string;
  /**
   * The HLS manifest for the video.
   *
   * @example https://customer-m033z5x00ks6nunl.cloudflarestream.com/ea95132c15732412d22c1476fa83f27a/manifest/video.m3u8
   * @x-auditable true
   */
  hls?: string;
};

/**
 * Details for playback from an live input using RTMPS.
 */
export type StreamPlaybackRtmps = {
  streamKey?: StreamPlaybackRtmpsStreamKey;
  url?: StreamPlaybackRtmpsUrl;
};

/**
 * The secret key to use for playback via RTMPS.
 *
 * @example 2fb3cb9f17e68a2568d6ebed8d5505eak3ceaf8c9b1f395e1b76b79332497cada
 * @x-sensitive true
 */
export type StreamPlaybackRtmpsStreamKey = string;

/**
 * The URL used to play live video over RTMPS.
 *
 * @example rtmps://live.cloudflare.com:443/live/
 * @x-sensitive true
 */
export type StreamPlaybackRtmpsUrl = string;

/**
 * Details for playback from an live input using SRT.
 */
export type StreamPlaybackSrt = {
  passphrase?: StreamPlaybackSrtStreamPassphrase;
  streamId?: StreamPlaybackSrtStreamId;
  url?: StreamPlaybackSrtUrl;
};

/**
 * The identifier of the live input to use for playback via SRT.
 *
 * @example f256e6ea9341d51eea64c9454659e576
 * @x-auditable true
 */
export type StreamPlaybackSrtStreamId = string;

/**
 * The secret key to use for playback via SRT.
 *
 * @example 2fb3cb9f17e68a2568d6ebed8d5505eak3ceaf8c9b1f395e1b76b79332497cada
 * @x-sensitive true
 */
export type StreamPlaybackSrtStreamPassphrase = string;

/**
 * The URL used to play live video over SRT.
 *
 * @example rtmps://live.cloudflare.com:443/live/
 * @x-sensitive true
 */
export type StreamPlaybackSrtUrl = string;

/**
 * Details for playback from a live input using WebRTC.
 */
export type StreamPlaybackWebrtc = {
  url?: StreamPlaybackWebrtcUrl;
};

/**
 * The URL used to play live video over WebRTC.
 *
 * @example https://customer-m033z5x00ks6nunl.cloudflarestream.com/b236bde30eb07b9d01318940e5fc3edake34a3efb3896e18f2dc277ce6cc993ad/webRTC/play
 * @x-sensitive true
 */
export type StreamPlaybackWebrtcUrl = string;

/**
 * The location of the image. Valid positions are: `upperRight`, `upperLeft`, `lowerLeft`, `lowerRight`, and `center`. Note that `center` ignores the `padding` parameter.
 *
 * @default upperRight
 * @example center
 * @x-auditable true
 */
export type StreamPosition = string;

/**
 * The video's preview page URI. This field is omitted until encoding is complete.
 *
 * @example https://customer-m033z5x00ks6nunl.cloudflarestream.com/ea95132c15732412d22c1476fa83f27a/watch
 * @format uri
 * @x-auditable true
 */
export type StreamPreview = string;

/**
 * Indicates whether the video is playable. The field is empty if the video is not ready for viewing or the live stream is still in progress.
 *
 * @example true
 * @x-auditable true
 */
export type StreamReadyToStream = boolean;

/**
 * Indicates the time at which the video became playable. The field is empty if the video is not ready for viewing or the live stream is still in progress.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type StreamReadyToStreamAt = string;

/**
 * Indicates whether the video can be a accessed using the UID. When set to `true`, a signed token must be generated with a signing key to view the video.
 *
 * @default false
 * @example true
 * @x-auditable true
 */
export type StreamRequireSignedURLs = boolean;

/**
 * The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. `0.0` indicates no scaling (use the size of the image as-is), and `1.0 `fills the entire video.
 *
 * @default 0.15
 * @example 0.1
 * @maximum 1
 * @minimum 0
 * @x-auditable true
 */
export type StreamScale = number;

/**
 * Indicates the date and time at which the video will be deleted. Omit the field to indicate no change, or include with a `null` value to remove an existing scheduled deletion. If specified, must be at least 30 days from upload time.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type StreamScheduledDeletion = string;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type StreamSchemasIdentifier = string;

/**
 * Searches over the `name` key in the `meta` field. This field can be set with or after the upload request.
 *
 * @example puppy.mp4
 * @x-auditable true
 */
export type StreamSearch = string;

export type StreamSignedTokenRequest = {
  /**
   * The optional list of access rule constraints on the token. Access can be blocked or allowed based on an IP, IP range, or by country. Access rules are evaluated from first to last. If a rule matches, the associated action is applied and no further rules are evaluated.
   *
   * @example {"action":"block","country":["US","MX"],"type":"ip.geoip.country"}
   * @example {"action":"allow","ip":["93.184.216.0/24","2400:cb00::/32"],"type":"ip.src"}
   * @example {"action":"block","type":"any"}
   */
  accessRules?: StreamAccessRules[];
  /**
   * The optional boolean value that enables using signed tokens to access MP4 download links for a video.
   *
   * @default false
   * @x-auditable true
   */
  downloadable?: boolean;
  /**
   * The optional unix epoch timestamp that specficies the time after a token is not accepted. The maximum time specification is 24 hours from issuing time. If this field is not set, the default is one hour after issuing.
   */
  exp?: number;
  /**
   * The optional ID of a Stream signing key. If present, the `pem` field is also required.
   *
   * @example ab0d4ef71g4425f8dcba9041231813000
   * @x-auditable true
   */
  id?: string;
  /**
   * The optional unix epoch timestamp that specifies the time before a the token is not accepted. If this field is not set, the default is one hour before issuing.
   *
   * @x-auditable true
   */
  nbf?: number;
  /**
   * The optional base64 encoded private key in PEM format associated with a Stream signing key. If present, the `id` field is also required.
   *
   * @example LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFcEFJQkFBS0NBUUVBc284dnBvOFpEWXRkOUgzbWlPaW1qYXAzVXlVM0oyZ3kwTUYvN1R4blJuRnkwRHpDCkxqUk9naFZsQ0hPQmxsd3NVaE9GU0lyYnN4K05tUTdBeS90TFpXSGxuVGF3UWJ5WGZGOStJeDhVSnNlSHBGV1oKNVF5Z1JYd2liSjh1MVVsZ2xlcmZHMkpueldjVXpZTzEySktZN3doSkw1ajROMWgxZFJNUXQ5Q1pkZFlCQWRzOQpCdk02cjRFMDcxQkhQekhWeDMrUTI1VWtubGdUNXIwS3FiM1E1Y0dlTlBXY1JreW1ybkJEWWR0OXR4eFFMb1dPCllzNXdsMnVYWFVYL0VGcDMwajU0Nmp6czllWExLYlNDbjJjTDZFVE96Y2x3aG9DRGx2a2VQT05rUE9LMDVKNUMKTm1TdFdhMG9hV1VGRzM0MFl3cVVrWGt4OU9tNndXd1JldU1uU1FJREFRQUJBb0lCQUFJOHo1ck5kOEdtOGJBMgo1S3pxQjI1R2lOVENwbUNJeW53NXRJWHZTQmNHcEdydUcvdlN2WG9kVlFVSVY0TWdHQkVXUEFrVzdsNWVBcHI4CnA1ZFd5SkRXYTNkdklFSE9vSEpYU3dBYksxZzZEMTNVa2NkZ1EyRGpoNVhuWDhHZCtBY2c2SmRTQWgxOWtYSHEKMk54RUtBVDB6Ri83a1g2MkRkREFBcWxmQkpGSXJodVIvZUdEVWh4L2piTTRhQ2JCcFdiM0pnRE9OYm5tS1ZoMwpxS2ZwZmRZZENZU1lzWUxrNTlxRDF2VFNwUVFUQ0VadW9VKzNzRVNhdkJzaUs1bU0vTzY5ZkRMRXNURG1MeTVQCmhEK3BMQXI0SlhNNjFwRGVBS0l3cUVqWWJybXlDRHRXTUdJNnZzZ0E1eXQzUUJaME9vV2w5QUkwdWxoZ3p4dXQKZ2ZFNTRRRUNnWUVBN0F3a0lhVEEzYmQ4Nk9jSVZnNFlrWGk1cm5aNDdsM1k4V24zcjIzUmVISXhLdkllRUtSbgp5bUlFNDFtRVBBSmlGWFpLK1VPTXdkeS9EcnFJUithT1JiT2NiV01jWUg2QzgvbG1wdVJFaXE3SW1Ub3VWcnA4CnlnUkprMWprVDA4cTIvNmg4eTBEdjJqMitsaHFXNzRNOUt0cmwxcTRlWmZRUFREL01tR1NnTWtDZ1lFQXdhY04KaSttN1p6dnJtL3NuekF2VlZ5SEtwZHVUUjNERk1naC9maC9tZ0ZHZ1RwZWtUOVV5b3FleGNYQXdwMVlhL01iQQoyNTVJVDZRbXZZTm5yNXp6Wmxic2tMV0hsYllvbWhmWnVXTHhXR3hRaEFORWdaMFVVdUVTRGMvbWx2UXZHbEtSCkZoaGhBUWlVSmdDamhPaHk1SlBiNGFldGRKd0UxK09lVWRFaE1vRUNnWUVBNG8yZ25CM1o4ck5xa3NzemlBek4KYmNuMlJVbDJOaW9pejBwS3JMaDFaT29NNE5BekpQdjJsaHRQMzdtS0htS1hLMHczRjFqTEgwSTBxZmxFVmVZbQpSU1huakdHazJjUnpBYUVzOGgrQzNheDE0Z01pZUtGU3BqNUpNOEFNbVVZOXQ1cUVhN2FYc3o0V1ZoOUlMYmVTCkRiNzlhKzVwd21LQVBrcnBsTHhyZFdrQ2dZQlNNSHVBWVdBbmJYZ1BDS2FZWklGVWJNUWNacmY0ZnpWQ2lmYksKYWZHampvRlNPZXdEOGdGK3BWdWJRTGwxbkFieU44ek1xVDRaaHhybUhpcFlqMjJDaHV2NmN3RXJtbGRiSnpwQwpBMnRaVXdkTk1ESFlMUG5lUHlZeGRJWnlsUXFVeW14SGkydElUQUxNcWtLOGV3ZWdXZHpkeGhQSlJScU5JazhrCmZIVHhnUUtCZ1FEUFc2UXIxY3F3QjNUdnVWdWR4WGRqUTdIcDFodXhrNEVWaEFJZllKNFhSTW1NUE5YS28wdHUKdUt6LzE0QW14R0dvSWJxYVc1bDMzeFNteUxhem84clNUN0tSTjVKME9JSHcrZkR5SFgxdHpVSjZCTldDcEFTcwpjbWdNK0htSzVON0w2bkNaZFJQY2IwU1hGaVRQUGhCUG1PVWFDUnpER0ZMK2JYM1VwajJKbWc9PQotLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQo=
   * @x-sensitive true
   */
  pem?: string;
};

export type StreamSignedTokenResponse = StreamApiResponseSingle & {
  result?: {
    /**
     * The signed token used with the signed URLs feature.
     *
     * @example eyJhbGciOiJSUzI1NiIsImtpZCI6ImU5ZGI5OTBhODI2NjZkZDU3MWM3N2Y5NDRhNWM1YzhkIn0.eyJzdWIiOiJlYTk1MTMyYzE1NzMyNDEyZDIyYzE0NzZmYTgzZjI3YSIsImtpZCI6ImU5ZGI5OTBhODI2NjZkZDU3MWM3N2Y5NDRhNWM1YzhkIiwiZXhwIjoiMTUzNzQ2MDM2NSIsIm5iZiI6IjE1Mzc0NTMxNjUifQ.OZhqOARADn1iubK6GKcn25hN3nU-hCFF5q9w2C4yup0C4diG7aMIowiRpP-eDod8dbAJubsiFuTKrqPcmyCKWYsiv0TQueukqbQlF7HCO1TV-oF6El5-7ldJ46eD-ZQ0XgcIYEKrQOYFF8iDQbqPm3REWd6BnjKZdeVrLzuRaiSnZ9qqFpGu5dfxIY9-nZKDubJHqCr3Imtb211VIG_b9MdtO92JjvkDS-rxT_pkEfTZSafl1OU-98A7KBGtPSJHz2dHORIrUiTA6on4eIXTj9aFhGiir4rSn-rn0OjPRTtJMWIDMoQyE_fwrSYzB7MPuzL2t82BWaEbHZTfixBm5A
     * @x-sensitive true
     */
    token?: string;
  };
};

/**
 * The date and time a signing key was created.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type StreamSigningKeyCreated = string;

/**
 * The size of the media item in bytes.
 *
 * @example 4190963
 * @x-auditable true
 */
export type StreamSize = number;

/**
 * Lists videos created after the specified date.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 */
export type StreamStart = string;

/**
 * Specifies the start time for the video clip in seconds.
 *
 * @x-auditable true
 */
export type StreamStartTimeSeconds = number;

export type StreamStorageUseResponse = StreamApiResponseSingle & {
  result?: {
    creator?: StreamCreator;
    /**
     * The total minutes of video content stored in the account.
     */
    totalStorageMinutes?: number;
    /**
     * The storage capacity alloted for the account.
     */
    totalStorageMinutesLimit?: number;
    /**
     * The total count of videos associated with the account.
     */
    videoCount?: number;
  };
};

/**
 * The timestamp for a thumbnail image calculated as a percentage value of the video's duration. To convert from a second-wise timestamp to a percentage, divide the desired timestamp by the total duration of the video.  If this value is not set, the default thumbnail image is taken from 0s of the video.
 *
 * @default 0
 * @example 0.529241
 * @maximum 1
 * @minimum 0
 * @x-auditable true
 */
export type StreamThumbnailTimestampPct = number;

/**
 * The media item's thumbnail URI. This field is omitted until encoding is complete.
 *
 * @example https://customer-m033z5x00ks6nunl.cloudflarestream.com/ea95132c15732412d22c1476fa83f27a/thumbnails/thumbnail.jpg
 * @format uri
 * @x-auditable true
 */
export type StreamThumbnailUrl = string;

/**
 * Specifies the TUS protocol version. This value must be included in every upload request.
 * Notes: The only supported version of TUS protocol is 1.0.0.
 *
 * @example 1.0.0
 * @x-auditable true
 */
export type StreamTusResumable = "1.0.0";

/**
 * Specifies whether the video is `vod` or `live`.
 *
 * @example live
 * @x-auditable true
 */
export type StreamType = string;

export type StreamUpdateInputRequest = {
  defaultCreator?: StreamLiveInputDefaultCreator;
  deleteRecordingAfterDays?: StreamLiveInputRecordingDeletion;
  meta?: StreamLiveInputMetadata;
  recording?: StreamLiveInputRecordingSettings;
};

export type StreamUpdateOutputRequest = {
  enabled: StreamOutputEnabled;
};

/**
 * Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
 *
 * @minimum 0
 * @x-auditable true
 */
export type StreamUploadLength = number;

/**
 * Comma-separated key-value pairs following the TUS protocol specification. Values are Base-64 encoded.
 * Supported keys: `name`, `requiresignedurls`, `allowedorigins`, `thumbnailtimestamppct`, `watermark`, `scheduleddeletion`, `maxdurationseconds`.
 *
 * @example name aGVsbG8gd29ybGQ=, requiresignedurls, allowedorigins ZXhhbXBsZS5jb20sdGVzdC5jb20=
 * @x-auditable true
 */
export type StreamUploadMetadata = string;

/**
 * The date and time the media item was uploaded.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type StreamUploaded = string;

export type StreamVideoClipStandard = {
  allowedOrigins?: StreamAllowedOrigins;
  clippedFromVideoUID: StreamClippedFromVideoUid;
  creator?: StreamCreator;
  endTimeSeconds: StreamEndTimeSeconds;
  maxDurationSeconds?: StreamMaxDurationSeconds;
  requireSignedURLs?: StreamRequireSignedURLs;
  startTimeSeconds: StreamStartTimeSeconds;
  thumbnailTimestampPct?: StreamThumbnailTimestampPct;
  watermark?: StreamWatermarkAtUpload;
};

export type StreamVideoCopyRequest = {
  allowedOrigins?: StreamAllowedOrigins;
  creator?: StreamCreator;
  meta?: StreamMediaMetadata;
  requireSignedURLs?: StreamRequireSignedURLs;
  scheduledDeletion?: StreamScheduledDeletion;
  thumbnailTimestampPct?: StreamThumbnailTimestampPct;
  /**
   * A video's URL. The server must be publicly routable and support `HTTP HEAD` requests and `HTTP GET` range requests. The server should respond to `HTTP HEAD` requests with a `content-range` header that includes the size of the file.
   *
   * @example https://example.com/myvideo.mp4
   * @format uri
   */
  url: string;
  watermark?: StreamWatermarkAtUpload2;
};

export type StreamVideoResponseCollection = StreamApiResponseCommon & {
  result?: StreamVideos[];
} & {
  /**
   * The total number of remaining videos based on cursor position.
   *
   * @example 1000
   */
  range?: number;
  /**
   * The total number of videos that match the provided filters.
   *
   * @example 35586
   */
  total?: number;
};

export type StreamVideoResponseSingle = StreamApiResponseSingle & {
  result?: StreamVideos;
};

export type StreamVideoUpdate = {
  allowedOrigins?: StreamAllowedOrigins;
  creator?: StreamCreator;
  maxDurationSeconds?: StreamMaxDurationSeconds;
  meta?: StreamMediaMetadata;
  requireSignedURLs?: StreamRequireSignedURLs;
  scheduledDeletion?: StreamScheduledDeletion;
  thumbnailTimestampPct?: StreamThumbnailTimestampPct;
  uploadExpiry?: StreamOneTimeUploadExpiry;
};

export type StreamVideos = {
  allowedOrigins?: StreamAllowedOrigins;
  created?: StreamCreated;
  creator?: StreamCreator;
  duration?: StreamDuration;
  input?: StreamInput;
  liveInput?: StreamLiveInput;
  maxDurationSeconds?: StreamMaxDurationSeconds;
  meta?: StreamMediaMetadata;
  modified?: StreamModified;
  playback?: StreamPlayback;
  preview?: StreamPreview;
  readyToStream?: StreamReadyToStream;
  readyToStreamAt?: StreamReadyToStreamAt;
  requireSignedURLs?: StreamRequireSignedURLs;
  scheduledDeletion?: StreamScheduledDeletion;
  size?: StreamSize;
  status?: StreamMediaStatus;
  thumbnail?: StreamThumbnailUrl;
  thumbnailTimestampPct?: StreamThumbnailTimestampPct;
  uid?: StreamIdentifier;
  uploadExpiry?: StreamOneTimeUploadExpiry;
  uploaded?: StreamUploaded;
  watermark?: StreamWatermarks;
};

export type StreamWatermarkAtUpload = {
  /**
   * The unique identifier for the watermark profile.
   *
   * @example ea95132c15732412d22c1476fa83f27a
   * @maxLength 32
   * @x-auditable true
   */
  uid?: string;
};

export type StreamWatermarkBasicUpload = {
  /**
   * The image file to upload.
   *
   * @example @/Users/rchen/Downloads/watermark.png
   * @x-auditable true
   */
  file: string;
  name?: StreamName;
  opacity?: StreamOpacity;
  padding?: StreamPadding;
  position?: StreamPosition;
  scale?: StreamScale;
};

/**
 * The date and a time a watermark profile was created.
 *
 * @example 2014-01-02T02:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type StreamWatermarkCreated = string;

/**
 * The unique identifier for a watermark profile.
 *
 * @example ea95132c15732412d22c1476fa83f27a
 * @maxLength 32
 * @x-auditable true
 */
export type StreamWatermarkIdentifier = string;

export type StreamWatermarkResponseCollection = StreamApiResponseCommon & {
  result?: StreamWatermarks[];
};

export type StreamWatermarkResponseSingle = StreamApiResponseSingle & {
  result?: StreamWatermarks;
};

/**
 * The size of the image in bytes.
 *
 * @example 29472
 * @x-auditable true
 */
export type StreamWatermarkSize = number;

export type StreamWatermarks = {
  created?: StreamWatermarkCreated;
  downloadedFrom?: StreamDownloadedFrom;
  height?: StreamHeight;
  name?: StreamName;
  opacity?: StreamOpacity;
  padding?: StreamPadding;
  position?: StreamPosition;
  scale?: StreamScale;
  size?: StreamWatermarkSize;
  uid?: StreamWatermarkIdentifier;
  width?: StreamWidth;
};

export type StreamWebhookRequest = {
  notificationUrl: StreamNotificationUrl;
};

export type StreamWebhookResponseSingle = StreamApiResponseSingle & {
  result?: Record<string, any>;
};

/**
 * The width of the image in pixels.
 *
 * @x-auditable true
 */
export type StreamWidth = number;

export type TeamsDevicesAccessSerialNumberListInputRequest = {
  /**
   * UUID of Access List.
   *
   * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
   * @maxLength 36
   * @x-auditable true
   */
  id: string;
};

export type TeamsDevicesAccount = {
  /**
   * @deprecated true
   */
  account_type?: string;
  /**
   * @deprecated true
   */
  id?: string;
  /**
   * The name of the enrolled account.
   *
   * @example Company
   * @x-auditable true
   */
  name?: string;
};

/**
 * Whether to allow the user to switch WARP between modes.
 *
 * @default false
 * @example true
 */
export type TeamsDevicesAllowModeSwitch = boolean;

/**
 * Whether to receive update notifications when a new version of the client is available.
 *
 * @default false
 * @example true
 */
export type TeamsDevicesAllowUpdates = boolean;

/**
 * Whether to allow devices to leave the organization.
 *
 * @default true
 * @example true
 */
export type TeamsDevicesAllowedToLeave = boolean;

export type TeamsDevicesApiResponseCollection = {
  errors: TeamsDevicesMessages;
  messages: TeamsDevicesMessages;
  result: Record<string, any> | Record<string, any>[] | string | null;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
  result_info?: TeamsDevicesResultInfo;
};

export type TeamsDevicesApiResponseCollectionCommon = {
  errors: TeamsDevicesMessages;
  messages: TeamsDevicesMessages;
  result: Record<string, any> | Record<string, any>[] | string | null;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type TeamsDevicesApiResponseCommon = {
  errors: TeamsDevicesMessages;
  messages: TeamsDevicesMessages;
  result: Record<string, any> | Record<string, any>[] | string;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type TeamsDevicesApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: TeamsDevicesMessages;
  messages: TeamsDevicesMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type TeamsDevicesApiResponseSingle = {
  errors: TeamsDevicesMessages;
  messages: TeamsDevicesMessages;
  result: Record<string, any> | string | string | null;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type TeamsDevicesApplicationInputRequest = {
  /**
   * Operating system.
   *
   * @example mac
   * @x-auditable true
   */
  operating_system: "windows" | "linux" | "mac";
  /**
   * Path for the application.
   *
   * @example /bin/cat
   * @x-auditable true
   */
  path: string;
  /**
   * SHA-256.
   *
   * @example b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c
   * @x-auditable true
   */
  sha256?: string;
  /**
   * Signing certificate thumbprint.
   *
   * @example 0aabab210bdb998e9cf45da2c9ce352977ab531c681b74cf1e487be1bbe9fe6e
   * @x-auditable true
   */
  thumbprint?: string;
};

/**
 * The amount of time in seconds to reconnect after having been disabled.
 *
 * @default 0
 * @example 0
 */
export type TeamsDevicesAutoConnect = number;

/**
 * Turn on the captive portal after the specified amount of time.
 *
 * @default 180
 * @example 180
 */
export type TeamsDevicesCaptivePortal = number;

export type TeamsDevicesCarbonblackInputRequest = {
  /**
   * Operating system.
   *
   * @example mac
   * @x-auditable true
   */
  operating_system: "windows" | "linux" | "mac";
  /**
   * File path.
   *
   * @example /bin/cat
   * @x-auditable true
   */
  path: string;
  /**
   * SHA-256.
   *
   * @example b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c
   * @x-auditable true
   */
  sha256?: string;
  /**
   * Signing certificate thumbprint.
   *
   * @example 0aabab210bdb998e9cf45da2c9ce352977ab531c681b74cf1e487be1bbe9fe6e
   * @x-auditable true
   */
  thumbprint?: string;
};

/**
 * List of volume names to be checked for encryption.
 *
 * @example C
 * @example D
 * @example G
 */
export type TeamsDevicesCheckDisks = string[];

export type TeamsDevicesClientCertificateInputRequest = {
  /**
   * UUID of Cloudflare managed certificate.
   *
   * @example b14ddcc4-bcd2-4df4-bd4f-eb27d5a50c30
   * @maxLength 36
   */
  certificate_id: string;
  /**
   * Common Name that is protected by the certificate.
   *
   * @example example.com
   */
  cn: string;
};

export type TeamsDevicesClientCertificateV2InputRequest = {
  /**
   * UUID of Cloudflare managed certificate.
   *
   * @example b14ddcc4-bcd2-4df4-bd4f-eb27d5a50c30
   * @maxLength 36
   */
  certificate_id: string;
  /**
   * Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
   *
   * @example true
   */
  check_private_key: boolean;
  /**
   * Certificate Common Name. This may include one or more variables in the ${ } notation. Only ${serial_number} and ${hostname} are valid variables.
   *
   * @example ${hostname}.com.${serial_number}
   */
  cn?: string;
  /**
   * List of values indicating purposes for which the certificate public key can be used.
   *
   * @example clientAuth
   * @example emailProtection
   */
  extended_key_usage?: TeamsDevicesExtendedKeyUsageEnum[];
  locations?: {
    paths?: TeamsDevicesPaths;
    trust_stores?: TeamsDevicesTrustStores;
  };
  /**
   * Operating System.
   *
   * @example windows
   */
  operating_system: "windows" | "mac" | "linux";
  /**
   * List of certificate Subject Alternative Names.
   *
   * @example example.com
   * @example sample.com
   */
  subject_alternative_names?: string[];
};

/**
 * The name of the device posture integration.
 *
 * @example My Workspace One Integration
 * @x-auditable true
 */
export type TeamsDevicesComponentsSchemasName = string;

export type TeamsDevicesComponentsSchemasResponseCollection =
  TeamsDevicesApiResponseCollection & {
    result?: TeamsDevicesDeviceManagedNetworks[];
  };

export type TeamsDevicesComponentsSchemasSingleResponse =
  TeamsDevicesApiResponseSingle & {
    result?: TeamsDevicesDeviceManagedNetworks;
  };

/**
 * The type of device managed network.
 *
 * @example tls
 * @x-auditable true
 */
export type TeamsDevicesComponentsSchemasType = "tls";

/**
 * UUID.
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 * @x-auditable true
 */
export type TeamsDevicesComponentsSchemasUuid = string;

/**
 * The configuration object containing third-party integration information.
 *
 * @example {"api_url":"https://as123.awmdm.com/API","auth_url":"https://na.uemauth.vmwservices.com/connect/token","client_id":"example client id","client_secret":"example client secret"}
 */
export type TeamsDevicesConfigRequest =
  | TeamsDevicesWorkspaceOneConfigRequest
  | TeamsDevicesCrowdstrikeConfigRequest
  | TeamsDevicesUptycsConfigRequest
  | TeamsDevicesIntuneConfigRequest
  | TeamsDevicesKolideConfigRequest
  | TeamsDevicesTaniumConfigRequest
  | TeamsDevicesSentineloneS2sConfigRequest
  | TeamsDevicesCustomS2sConfigRequest;

/**
 * The configuration object containing third-party integration information.
 *
 * @example {"api_url":"https://as123.awmdm.com/API","auth_url":"https://na.uemauth.vmwservices.com/connect/token","client_id":"example client id"}
 */
export type TeamsDevicesConfigResponse = TeamsDevicesWorkspaceOneConfigResponse;

/**
 * When the device was created.
 *
 * @example 2017-06-14T00:00:00Z
 * @format date-time
 * @x-auditable true
 */
export type TeamsDevicesCreated = string;

export type TeamsDevicesCrowdstrikeConfigRequest = {
  /**
   * The Crowdstrike API URL.
   *
   * @example https://api.us-2.crowdstrike.com
   * @x-auditable true
   */
  api_url: string;
  /**
   * The Crowdstrike client ID.
   *
   * @example example client id
   */
  client_id: string;
  /**
   * The Crowdstrike client secret.
   *
   * @example example client secret
   * @x-sensitive true
   */
  client_secret: string;
  /**
   * The Crowdstrike customer ID.
   *
   * @example example customer id
   * @x-auditable true
   */
  customer_id: string;
};

export type TeamsDevicesCrowdstrikeInputRequest = {
  /**
   * Posture Integration ID.
   *
   * @example bc7cbfbb-600a-42e4-8a23-45b5e85f804f
   * @x-auditable true
   */
  connection_id: string;
  /**
   * For more details on last seen, please refer to the Crowdstrike documentation.
   *
   * @example 15d3h20m4s
   * @x-auditable true
   */
  last_seen?: string;
  /**
   * Operator.
   *
   * @example >
   * @x-auditable true
   */
  operator?: "<" | "<=" | ">" | ">=" | "==";
  /**
   * Os Version.
   *
   * @example 13.3.0
   * @x-auditable true
   */
  os?: string;
  /**
   * Overall.
   *
   * @example 90
   * @x-auditable true
   */
  overall?: string;
  /**
   * SensorConfig.
   *
   * @example 90
   * @x-auditable true
   */
  sensor_config?: string;
  /**
   * For more details on state, please refer to the Crowdstrike documentation.
   *
   * @example online
   * @x-auditable true
   */
  state?: "online" | "offline" | "unknown";
  /**
   * Version.
   *
   * @example 13.3.0
   * @x-auditable true
   */
  version?: string;
  /**
   * Version Operator.
   *
   * @example >
   * @x-auditable true
   */
  versionOperator?: "<" | "<=" | ">" | ">=" | "==";
};

/**
 * V4 public API Pagination/Cursor info.
 *
 * @example {"count":1,"cursor":"ais86dftf.asdf7ba8","page":null,"per_page":10,"total_count":null}
 */
export type TeamsDevicesCursorResultInfo = {
  /**
   * Number of records in the response.
   */
  count: number;
  /**
   * Opaque token to request the next set of records.
   */
  cursor: string;
  /**
   * The limit for the number of records in the response.
   */
  per_page: number;
  /**
   * Total number of records available.
   */
  total_count?: number | null;
};

export type TeamsDevicesCustomS2sConfigRequest = {
  /**
   * This id will be passed in the `CF-Access-Client-ID` header when hitting the `api_url`.
   *
   * @example 88bf3b6d86161464f6509f7219099e57.access
   */
  access_client_id: string;
  /**
   * This secret will be passed in the `CF-Access-Client-Secret` header when hitting the `api_url`.
   *
   * @example bdd31cbc4dec990953e39163fbbb194c93313ca9f0a6e420346af9d326b1d2a5
   * @x-sensitive true
   */
  access_client_secret: string;
  /**
   * The Custom Device Posture Integration  API URL.
   *
   * @example https://example.custom-s2s.com
   * @x-auditable true
   */
  api_url: string;
};

export type TeamsDevicesCustomS2sInputRequest = {
  /**
   * Posture Integration ID.
   *
   * @example bc7cbfbb-600a-42e4-8a23-45b5e85f804f
   */
  connection_id: string;
  /**
   * Operator.
   *
   * @example >
   */
  operator: "<" | "<=" | ">" | ">=" | "==";
  /**
   * A value between 0-100 assigned to devices set by the 3rd party posture provider.
   *
   * @example 100
   */
  score: number;
};

/**
 * Whether the policy is the default policy for an account.
 *
 * @example false
 */
export type TeamsDevicesDefault = boolean;

export type TeamsDevicesDefaultDeviceSettingsPolicy = {
  allow_mode_switch?: TeamsDevicesAllowModeSwitch;
  allow_updates?: TeamsDevicesAllowUpdates;
  allowed_to_leave?: TeamsDevicesAllowedToLeave;
  auto_connect?: TeamsDevicesAutoConnect;
  captive_portal?: TeamsDevicesCaptivePortal;
  /**
   * Whether the policy will be applied to matching devices.
   *
   * @example true
   */
  ["default"]?: boolean;
  disable_auto_fallback?: TeamsDevicesDisableAutoFallback;
  /**
   * Whether the policy will be applied to matching devices.
   *
   * @example true
   */
  enabled?: boolean;
  exclude?: TeamsDevicesExclude;
  exclude_office_ips?: TeamsDevicesExcludeOfficeIps;
  fallback_domains?: TeamsDevicesFallbackDomains;
  gateway_unique_id?: TeamsDevicesGatewayUniqueId;
  include?: TeamsDevicesInclude;
  register_interface_ip_with_dns?: TeamsDevicesRegisterInterfaceIpWithDns;
  sccm_vpn_boundary_support?: TeamsDevicesSccmVpnBoundarySupport;
  service_mode_v2?: TeamsDevicesServiceModeV2;
  support_url?: TeamsDevicesSupportUrl;
  switch_locked?: TeamsDevicesSwitchLocked;
  tunnel_protocol?: TeamsDevicesTunnelProtocol;
};

export type TeamsDevicesDefaultDeviceSettingsResponse =
  TeamsDevicesApiResponseSingle & {
    result?: TeamsDevicesDefaultDeviceSettingsPolicy;
  };

/**
 * True if the device was deleted.
 *
 * @example true
 */
export type TeamsDevicesDeleted = boolean;

/**
 * The description of the device posture rule.
 *
 * @default
 * @example The rule for admin serial numbers
 * @x-auditable true
 */
export type TeamsDevicesDescription = string;

export type TeamsDevicesDevice = {
  account?: TeamsDevicesAccount;
  created?: TeamsDevicesCreated;
  deleted?: TeamsDevicesDeleted;
  device_type?: TeamsDevicesDeviceType;
  gateway_device_id?: TeamsDevicesGatewayDeviceId;
  id?: TeamsDevicesRegistrationId;
  ip?: TeamsDevicesIp;
  key?: TeamsDevicesKey;
  key_type?: TeamsDevicesKeyType;
  last_seen?: TeamsDevicesLastSeen;
  mac_address?: TeamsDevicesMacAddress;
  model?: TeamsDevicesModel;
  name?: TeamsDevicesSchemasName;
  os_version?: TeamsDevicesOsVersion;
  serial_number?: TeamsDevicesSerialNumber;
  tunnel_type?: TeamsDevicesTunnelType;
  updated?: TeamsDevicesUpdated;
  user?: TeamsDevicesUser;
  version?: TeamsDevicesVersion;
};

/**
 * The configuration object which contains the details for the WARP client to conduct the test.
 *
 * @example {"host":"https://dash.cloudflare.com","kind":"http","method":"GET"}
 */
export type TeamsDevicesDeviceDexTestSchemasData = {
  /**
   * The desired endpoint to test.
   *
   * @example https://dash.cloudflare.com
   */
  host?: string;
  /**
   * The type of test.
   *
   * @example http
   */
  kind?: string;
  /**
   * The HTTP request method type.
   *
   * @example GET
   */
  method?: string;
};

/**
 * Additional details about the test.
 *
 * @example Checks the dash endpoint every 30 minutes
 */
export type TeamsDevicesDeviceDexTestSchemasDescription = string;

/**
 * Determines whether or not the test is active.
 *
 * @example true
 */
export type TeamsDevicesDeviceDexTestSchemasEnabled = boolean;

export type TeamsDevicesDeviceDexTestSchemasHttp = {
  data: TeamsDevicesDeviceDexTestSchemasData;
  description?: TeamsDevicesDeviceDexTestSchemasDescription;
  enabled: TeamsDevicesDeviceDexTestSchemasEnabled;
  interval: TeamsDevicesDeviceDexTestSchemasInterval;
  name: TeamsDevicesDeviceDexTestSchemasName;
  target_policies?: TeamsDevicesDeviceDexTestTargetPolicies;
  targeted?: boolean;
  test_id?: TeamsDevicesSchemasTestId;
};

/**
 * How often the test will run.
 *
 * @example 30m
 */
export type TeamsDevicesDeviceDexTestSchemasInterval = string;

/**
 * The name of the DEX test. Must be unique.
 *
 * @example HTTP dash health check
 */
export type TeamsDevicesDeviceDexTestSchemasName = string;

/**
 * Device settings profiles targeted by this test.
 */
export type TeamsDevicesDeviceDexTestTargetPolicies =
  TeamsDevicesDexTargetPolicy[];

export type TeamsDevicesDeviceManagedNetworks = {
  config?: TeamsDevicesSchemasConfigResponse;
  name?: TeamsDevicesDeviceManagedNetworksComponentsSchemasName;
  network_id?: TeamsDevicesUuid;
  type?: TeamsDevicesComponentsSchemasType;
};

/**
 * The name of the device managed network. This name must be unique.
 *
 * @example managed-network-1
 * @x-auditable true
 */
export type TeamsDevicesDeviceManagedNetworksComponentsSchemasName = string;

export type TeamsDevicesDevicePostureIntegrations = {
  config?: TeamsDevicesConfigResponse;
  id?: TeamsDevicesUuid;
  interval?: TeamsDevicesInterval;
  name?: TeamsDevicesComponentsSchemasName;
  type?: TeamsDevicesSchemasType;
};

export type TeamsDevicesDevicePostureRules = {
  description?: TeamsDevicesDescription;
  expiration?: TeamsDevicesExpiration;
  id?: TeamsDevicesUuid;
  input?: TeamsDevicesInput;
  match?: TeamsDevicesMatch;
  name?: TeamsDevicesName;
  schedule?: TeamsDevicesSchedule;
  type?: TeamsDevicesType;
};

export type TeamsDevicesDeviceResponse = TeamsDevicesApiResponseSingle & {
  result?: TeamsDevicesDevice;
};

export type TeamsDevicesDeviceSettingsPolicy = {
  allow_mode_switch?: TeamsDevicesAllowModeSwitch;
  allow_updates?: TeamsDevicesAllowUpdates;
  allowed_to_leave?: TeamsDevicesAllowedToLeave;
  auto_connect?: TeamsDevicesAutoConnect;
  captive_portal?: TeamsDevicesCaptivePortal;
  ["default"]?: TeamsDevicesDefault;
  description?: TeamsDevicesSchemasDescription;
  disable_auto_fallback?: TeamsDevicesDisableAutoFallback;
  /**
   * Whether the policy will be applied to matching devices.
   *
   * @example true
   */
  enabled?: boolean;
  exclude?: TeamsDevicesExclude;
  exclude_office_ips?: TeamsDevicesExcludeOfficeIps;
  fallback_domains?: TeamsDevicesFallbackDomains;
  gateway_unique_id?: TeamsDevicesGatewayUniqueId;
  include?: TeamsDevicesInclude;
  lan_allow_minutes?: TeamsDevicesLanAllowMinutes;
  lan_allow_subnet_size?: TeamsDevicesLanAllowSubnetSize;
  match?: TeamsDevicesSchemasMatch;
  /**
   * The name of the device settings profile.
   *
   * @example Allow Developers
   * @maxLength 100
   */
  name?: string;
  policy_id?: TeamsDevicesSchemasUuid;
  precedence?: TeamsDevicesPrecedence;
  register_interface_ip_with_dns?: TeamsDevicesRegisterInterfaceIpWithDns;
  sccm_vpn_boundary_support?: TeamsDevicesSccmVpnBoundarySupport;
  service_mode_v2?: TeamsDevicesServiceModeV2;
  support_url?: TeamsDevicesSupportUrl;
  switch_locked?: TeamsDevicesSwitchLocked;
  target_tests?: TeamsDevicesTargetDexTest[];
  tunnel_protocol?: TeamsDevicesTunnelProtocol;
};

export type TeamsDevicesDeviceSettingsResponse =
  TeamsDevicesApiResponseSingle & {
    result?: TeamsDevicesDeviceSettingsPolicy;
  };

export type TeamsDevicesDeviceSettingsResponseCollection =
  TeamsDevicesApiResponseCollection & {
    result?: TeamsDevicesDeviceSettingsPolicy[];
  };

/**
 * @example windows
 * @x-auditable true
 */
export type TeamsDevicesDeviceType = string;

export type TeamsDevicesDevices = {
  created?: TeamsDevicesCreated;
  deleted?: TeamsDevicesDeleted;
  device_type?: TeamsDevicesPlatform;
  id?: TeamsDevicesRegistrationId;
  ip?: TeamsDevicesIp;
  key?: TeamsDevicesKey;
  last_seen?: TeamsDevicesLastSeen;
  mac_address?: TeamsDevicesMacAddress;
  manufacturer?: TeamsDevicesManufacturer;
  model?: TeamsDevicesModel;
  name?: TeamsDevicesSchemasName;
  os_distro_name?: TeamsDevicesOsDistroName;
  os_distro_revision?: TeamsDevicesOsDistroRevision;
  os_version?: TeamsDevicesOsVersion;
  os_version_extra?: TeamsDevicesOsVersionExtra;
  revoked_at?: TeamsDevicesRevokedAt;
  serial_number?: TeamsDevicesSerialNumber;
  updated?: TeamsDevicesUpdated;
  user?: TeamsDevicesUser;
  version?: TeamsDevicesVersion;
};

export type TeamsDevicesDevicesPolicyCertificates = {
  /**
   * The current status of the device policy certificate provisioning feature for WARP clients.
   *
   * @example true
   */
  enabled: boolean;
};

export type TeamsDevicesDevicesPolicyCertificatesSingle =
  TeamsDevicesApiResponseSingle & {
    result?: TeamsDevicesDevicesPolicyCertificates;
  };

export type TeamsDevicesDevicesResponse = TeamsDevicesApiResponseCollection & {
  result?: TeamsDevicesDevices[];
};

export type TeamsDevicesDexDeleteResponseCollection = {
  errors: TeamsDevicesMessages;
  messages: TeamsDevicesMessages;
  result:
    | {
        dex_tests?: TeamsDevicesDeviceDexTestSchemasHttp[];
      }
    | Record<string, any>[]
    | string;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type TeamsDevicesDexResponseCollection =
  TeamsDevicesApiResponseCollectionCommon & {
    result?: TeamsDevicesDeviceDexTestSchemasHttp[];
  };

export type TeamsDevicesDexSingleResponse = TeamsDevicesApiResponseSingle & {
  result?: TeamsDevicesDeviceDexTestSchemasHttp;
};

export type TeamsDevicesDexTargetPolicy = {
  /**
   * Whether the profile is the account default.
   */
  ["default"]?: boolean;
  /**
   * The id of the device settings profile.
   */
  id?: string;
  /**
   * The name of the device settings profile.
   */
  name?: string;
};

/**
 * If the `dns_server` field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers unless this policy option is set to `true`.
 *
 * @default false
 * @example true
 * @x-auditable true
 */
export type TeamsDevicesDisableAutoFallback = boolean;

export type TeamsDevicesDisableForTime = {
  /**
   * Override code that is valid for 1 hour.
   *
   * @example 9106681
   */
  ["1"]?: string;
  /**
   * Override code that is valid for 3 hours.
   *
   * @example 5356247
   */
  ["3"]?: string;
  /**
   * Override code that is valid for 6 hours.
   *
   * @example 9478972
   */
  ["6"]?: string;
  /**
   * Override code that is valid for 12 hour2.
   *
   * @example 3424359
   */
  ["12"]?: string;
  /**
   * Override code that is valid for 24 hour.2.
   *
   * @example 2887634
   */
  ["24"]?: string;
};

/**
 * Disconnects all devices on the account using Global WARP override.
 *
 * @example false
 * @x-auditable true
 */
export type TeamsDevicesDisconnect = boolean;

export type TeamsDevicesDiskEncryptionInputRequest = {
  checkDisks?: TeamsDevicesCheckDisks;
  requireAll?: TeamsDevicesRequireAll;
};

export type TeamsDevicesDomainJoinedInputRequest = {
  /**
   * Domain.
   *
   * @example example.com
   * @x-auditable true
   */
  domain?: string;
  /**
   * Operating System.
   *
   * @example windows
   * @x-auditable true
   */
  operating_system: "windows";
};

/**
 * The contact email address of the user.
 *
 * @example user@example.com
 * @maxLength 90
 * @x-auditable true
 */
export type TeamsDevicesEmail = string;

export type TeamsDevicesEmptyBody = Record<string, any> | null;

/**
 * List of routes excluded in the WARP client's tunnel.
 *
 * @default {"address":"10.0.0.0/8"}
 * @default {"address":"100.64.0.0/10"}
 * @default {"address":"169.254.0.0/16","description":"DHCP Unspecified"}
 * @default {"address":"172.16.0.0/12"}
 * @default {"address":"192.0.0.0/24"}
 * @default {"address":"192.168.0.0/16"}
 * @default {"address":"224.0.0.0/24"}
 * @default {"address":"240.0.0.0/4"}
 * @default {"address":"255.255.255.255/32","description":"DHCP Broadcast"}
 * @default {"address":"fe80::/10","description":"IPv6 Link Local"}
 * @default {"address":"fd00::/8"}
 * @default {"address":"ff01::/16"}
 * @default {"address":"ff02::/16"}
 * @default {"address":"ff03::/16"}
 * @default {"address":"ff04::/16"}
 * @default {"address":"ff05::/16"}
 */
export type TeamsDevicesExclude = TeamsDevicesSplitTunnel[];

/**
 * Whether to add Microsoft IPs to Split Tunnel exclusions.
 *
 * @default false
 * @example true
 */
export type TeamsDevicesExcludeOfficeIps = boolean;

/**
 * List of routes excluded in the WARP client's tunnel. Both 'exclude' and 'include' cannot be set in the same request.
 */
export type TeamsDevicesExcludeRequest = TeamsDevicesSplitTunnel[];

export type TeamsDevicesExcludeSplitTunnelWithAddress = {
  address: TeamsDevicesSplitTunnelAddress;
  description?: TeamsDevicesSplitTunnelDescription;
};

export type TeamsDevicesExcludeSplitTunnelWithHost = {
  description?: TeamsDevicesSplitTunnelDescription;
  host: TeamsDevicesSplitTunnelHost;
};

/**
 * Sets the expiration time for a posture check result. If empty, the result remains valid until it is overwritten by new data from the WARP client.
 *
 * @example 1h
 */
export type TeamsDevicesExpiration = string;

/**
 * @x-auditable true
 */
export type TeamsDevicesExtendedKeyUsageEnum = "clientAuth" | "emailProtection";

export type TeamsDevicesFallbackDomain = {
  /**
   * A description of the fallback domain, displayed in the client UI.
   *
   * @example Domain bypass for local development
   * @maxLength 100
   * @x-auditable true
   */
  description?: string;
  /**
   * A list of IP addresses to handle domain resolution.
   */
  dns_server?: TeamsDevicesIp[];
  /**
   * The domain suffix to match when resolving locally.
   *
   * @example example.com
   * @x-auditable true
   */
  suffix: string;
};

export type TeamsDevicesFallbackDomainResponseCollection =
  TeamsDevicesApiResponseCollection & {
    result?: TeamsDevicesFallbackDomain[];
  };

/**
 * @default {"suffix":"intranet"}
 * @default {"suffix":"internal"}
 * @default {"suffix":"private"}
 * @default {"suffix":"localdomain"}
 * @default {"suffix":"domain"}
 * @default {"suffix":"lan"}
 * @default {"suffix":"home"}
 * @default {"suffix":"host"}
 * @default {"suffix":"corp"}
 * @default {"suffix":"local"}
 * @default {"suffix":"localhost"}
 * @default {"suffix":"home.arpa"}
 * @default {"suffix":"invalid"}
 * @default {"suffix":"test"}
 */
export type TeamsDevicesFallbackDomains = TeamsDevicesFallbackDomain[];

export type TeamsDevicesFileInputRequest = {
  /**
   * Whether or not file exists.
   *
   * @example true
   * @x-auditable true
   */
  exists?: boolean;
  /**
   * Operating system.
   *
   * @example mac
   * @x-auditable true
   */
  operating_system: "windows" | "linux" | "mac";
  /**
   * File path.
   *
   * @example /bin/cat
   * @x-auditable true
   */
  path: string;
  /**
   * SHA-256.
   *
   * @example https://api.us-2.crowdstrike.com
   */
  sha256?: string;
  /**
   * Signing certificate thumbprint.
   *
   * @example 0aabab210bdb998e9cf45da2c9ce352977ab531c681b74cf1e487be1bbe9fe6e
   */
  thumbprint?: string;
};

export type TeamsDevicesFirewallInputRequest = {
  /**
   * Enabled.
   *
   * @example true
   * @x-auditable true
   */
  enabled: boolean;
  /**
   * Operating System.
   *
   * @example windows
   * @x-auditable true
   */
  operating_system: "windows" | "mac";
};

/**
 * @deprecated true
 * @example PD33E90AXfafe14643cbbbc-4a0ed4fc8415Q
 */
export type TeamsDevicesGatewayDeviceId = string;

/**
 * @example 699d98642c564d2e855e9661899b7252
 */
export type TeamsDevicesGatewayUniqueId = string;

export type TeamsDevicesGlobalWarpOverride = {
  disconnect?: TeamsDevicesDisconnect;
  timestamp?: TeamsDevicesTimestamp;
};

export type TeamsDevicesGlobalWarpOverrideRequest = {
  disconnect: TeamsDevicesDisconnect;
  justification?: TeamsDevicesJustification;
};

export type TeamsDevicesGlobalWarpOverrideResponse =
  TeamsDevicesApiResponseSingle & {
    result?: TeamsDevicesGlobalWarpOverride;
  };

export type TeamsDevicesIdResponse = TeamsDevicesApiResponseSingle & {
  result?: {
    id?: TeamsDevicesUuid;
  };
};

/**
 * @example 699d98642c564d2e855e9661899b7252
 */
export type TeamsDevicesIdentifier = void;

/**
 * List of routes included in the WARP client's tunnel.
 */
export type TeamsDevicesInclude = TeamsDevicesSplitTunnelInclude[];

/**
 * List of routes included in the WARP client's tunnel. Both 'exclude' and 'include' cannot be set in the same request.
 */
export type TeamsDevicesIncludeRequest = TeamsDevicesSplitTunnelInclude[];

/**
 * The address in CIDR format to include in the tunnel. If `address` is present, `host` must not be present.
 *
 * @example 192.0.2.0/24
 */
export type TeamsDevicesIncludeSplitTunnelAddress = string;

/**
 * A description of the Split Tunnel item, displayed in the client UI.
 *
 * @example Include testing domains in the tunnel
 * @maxLength 100
 */
export type TeamsDevicesIncludeSplitTunnelDescription = string;

/**
 * The domain name to include in the tunnel. If `host` is present, `address` must not be present.
 *
 * @example *.example.com
 */
export type TeamsDevicesIncludeSplitTunnelHost = string;

export type TeamsDevicesIncludeSplitTunnelWithAddress = {
  address: TeamsDevicesIncludeSplitTunnelAddress;
  description?: TeamsDevicesIncludeSplitTunnelDescription;
};

export type TeamsDevicesIncludeSplitTunnelWithHost = {
  description?: TeamsDevicesIncludeSplitTunnelDescription;
  host: TeamsDevicesIncludeSplitTunnelHost;
};

/**
 * The value to be checked against.
 *
 * @example {"operating_system":"linux","path":"/bin/cat","thumbprint":"0aabab210bdb998e9cf45da2c9ce352977ab531c681b74cf1e487be1bbe9fe6e"}
 */
export type TeamsDevicesInput =
  | TeamsDevicesFileInputRequest
  | TeamsDevicesUniqueClientIdInputRequest
  | TeamsDevicesDomainJoinedInputRequest
  | TeamsDevicesOsVersionInputRequest
  | TeamsDevicesFirewallInputRequest
  | TeamsDevicesSentineloneInputRequest
  | TeamsDevicesCarbonblackInputRequest
  | TeamsDevicesAccessSerialNumberListInputRequest
  | TeamsDevicesDiskEncryptionInputRequest
  | TeamsDevicesApplicationInputRequest
  | TeamsDevicesClientCertificateInputRequest
  | TeamsDevicesClientCertificateV2InputRequest
  | TeamsDevicesWorkspaceOneInputRequest
  | TeamsDevicesCrowdstrikeInputRequest
  | TeamsDevicesIntuneInputRequest
  | TeamsDevicesKolideInputRequest
  | TeamsDevicesTaniumInputRequest
  | TeamsDevicesSentineloneS2sInputRequest
  | TeamsDevicesCustomS2sInputRequest;

/**
 * The interval between each posture check with the third-party API. Use `m` for minutes (e.g. `5m`) and `h` for hours (e.g. `12h`).
 *
 * @example 10m
 * @x-auditable true
 */
export type TeamsDevicesInterval = string;

export type TeamsDevicesIntuneConfigRequest = {
  /**
   * The Intune client ID.
   *
   * @example example client id
   */
  client_id: string;
  /**
   * The Intune client secret.
   *
   * @example example client secret
   * @x-sensitive true
   */
  client_secret: string;
  /**
   * The Intune customer ID.
   *
   * @example example customer id
   */
  customer_id: string;
};

export type TeamsDevicesIntuneInputRequest = {
  /**
   * Compliance Status.
   *
   * @example compliant
   * @x-auditable true
   */
  compliance_status:
    | "compliant"
    | "noncompliant"
    | "unknown"
    | "notapplicable"
    | "ingraceperiod"
    | "error";
  /**
   * Posture Integration ID.
   *
   * @example bc7cbfbb-600a-42e4-8a23-45b5e85f804f
   * @x-auditable true
   */
  connection_id: string;
};

/**
 * IPv4 or IPv6 address.
 *
 * @example 1.1.1.1
 * @x-auditable true
 */
export type TeamsDevicesIp = string;

/**
 * Reasoning for setting the Global WARP override state. This will be surfaced in the audit log.
 *
 * @example Turning off WARP for testing purposes.
 * @x-auditable true
 */
export type TeamsDevicesJustification = string;

/**
 * The device's public key.
 *
 * @example yek0SUYoOQ10vMGsIYAevozXUQpQtNFJFfFGqER/BGc=
 */
export type TeamsDevicesKey = string;

/**
 * Type of the key.
 *
 * @example curve25519
 * @x-auditable true
 */
export type TeamsDevicesKeyType = string;

export type TeamsDevicesKolideConfigRequest = {
  /**
   * The Kolide client ID.
   *
   * @example example client id
   */
  client_id: string;
  /**
   * The Kolide client secret.
   *
   * @example example client secret
   * @x-sensitive true
   */
  client_secret: string;
};

export type TeamsDevicesKolideInputRequest = {
  /**
   * Posture Integration ID.
   *
   * @example bc7cbfbb-600a-42e4-8a23-45b5e85f804f
   * @x-auditable true
   */
  connection_id: string;
  /**
   * Count Operator.
   *
   * @example >
   * @x-auditable true
   */
  countOperator: "<" | "<=" | ">" | ">=" | "==";
  /**
   * The Number of Issues.
   *
   * @example 1
   * @x-auditable true
   */
  issue_count: string;
};

/**
 * The amount of time in minutes a user is allowed access to their LAN. A value of 0 will allow LAN access until the next WARP reconnection, such as a reboot or a laptop waking from sleep. Note that this field is omitted from the response if null or unset.
 *
 * @example 30
 */
export type TeamsDevicesLanAllowMinutes = number;

/**
 * The size of the subnet for the local access network. Note that this field is omitted from the response if null or unset.
 *
 * @example 24
 */
export type TeamsDevicesLanAllowSubnetSize = number;

/**
 * When the device last connected to Cloudflare services.
 *
 * @example 2017-06-14T00:00:00Z
 * @format date-time
 * @x-auditable true
 */
export type TeamsDevicesLastSeen = string;

/**
 * The device mac address.
 *
 * @example 00-00-5E-00-53-00
 * @x-auditable true
 */
export type TeamsDevicesMacAddress = string;

/**
 * The device manufacturer name.
 *
 * @example My phone corp
 */
export type TeamsDevicesManufacturer = string;

/**
 * The conditions that the client must match to run the rule.
 */
export type TeamsDevicesMatch = TeamsDevicesMatchItem[];

export type TeamsDevicesMatchItem = {
  platform?: TeamsDevicesPlatform;
};

export type TeamsDevicesMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * The device model name.
 *
 * @example MyPhone(pro-X)
 */
export type TeamsDevicesModel = string;

/**
 * The name of the device posture rule.
 *
 * @example Admin Serial Numbers
 * @x-auditable true
 */
export type TeamsDevicesName = string;

/**
 * The Linux distro name.
 *
 * @example ubuntu
 * @x-auditable true
 */
export type TeamsDevicesOsDistroName = string;

/**
 * The Linux distro revision.
 *
 * @example 1.0.0
 * @x-auditable true
 */
export type TeamsDevicesOsDistroRevision = string;

/**
 * The operating system version.
 *
 * @example 10.0.0
 */
export type TeamsDevicesOsVersion = string;

/**
 * The operating system version extra parameter.
 *
 * @example (a)
 */
export type TeamsDevicesOsVersionExtra = string;

export type TeamsDevicesOsVersionInputRequest = {
  /**
   * Operating System.
   *
   * @example windows
   * @x-auditable true
   */
  operating_system: "windows";
  /**
   * Operator.
   *
   * @example 13.3.0
   * @x-auditable true
   */
  operator: "<" | "<=" | ">" | ">=" | "==";
  /**
   * Operating System Distribution Name (linux only).
   *
   * @example ubuntu
   * @x-auditable true
   */
  os_distro_name?: string;
  /**
   * Version of OS Distribution (linux only).
   *
   * @example 11.3.1
   * @x-auditable true
   */
  os_distro_revision?: string;
  /**
   * Additional version data. For Mac or iOS, the Product Version Extra. For Linux, the kernel release version. (Mac, iOS, and Linux only).
   *
   * @example (a) or -1007
   * @x-auditable true
   */
  os_version_extra?: string;
  /**
   * Version of OS.
   *
   * @example 13.3.0
   * @x-auditable true
   */
  version: string;
};

export type TeamsDevicesOverrideCodes = {
  disable_for_time?: {
    [key: string]: string;
  };
};

export type TeamsDevicesOverrideCodesResponse =
  TeamsDevicesApiResponseCollection & {
    result?: {
      disable_for_time?: TeamsDevicesDisableForTime;
    };
  };

/**
 * List of paths to check for client certificate on linux.
 *
 * @example /path1
 * @example /path2
 */
export type TeamsDevicesPaths = string[];

/**
 * A WARP Device.
 */
export type TeamsDevicesPhysicalDevice = {
  /**
   * The number of active registrations for the device. Active registrations are those which haven't been revoked or deleted.
   *
   * @example 1
   * @x-auditable true
   */
  active_registrations: number;
  /**
   * Version of the WARP client.
   *
   * @example 1.0.0
   * @x-auditable true
   */
  client_version?: string | null;
  /**
   * The RFC3339 timestamp when the device was created.
   *
   * @example 2025-02-14T13:17:00Z
   * @x-auditable true
   */
  created_at: string;
  /**
   * The RFC3339 timestamp when the device was deleted.
   *
   * @example 2025-02-14T13:17:00Z
   * @x-auditable true
   */
  deleted_at?: string | null;
  /**
   * The device operating system.
   *
   * @example linux
   * @x-auditable true
   */
  device_type?: string | null;
  /**
   * A string that uniquely identifies the hardware or virtual machine (VM).
   *
   * @x-auditable true
   */
  hardware_id?: string | null;
  /**
   * The unique ID of the device.
   *
   * @example fc9ab6ab-3b94-4319-9941-459462b3d73e
   * @x-auditable true
   */
  id: string;
  /**
   * The RFC3339 timestamp when the device was last seen.
   *
   * @example 2025-02-14T13:17:00Z
   * @x-auditable true
   */
  last_seen_at: string | null;
  /**
   * The last user to use the WARP device.
   */
  last_seen_user?: TeamsDevicesUser | null;
  /**
   * The device MAC address.
   *
   * @example f5:01:73:cf:12:23
   * @x-auditable true
   */
  mac_address?: string | null;
  /**
   * The device manufacturer.
   *
   * @example ACME
   * @x-auditable true
   */
  manufacturer?: string | null;
  /**
   * The model name of the device.
   *
   * @example Mark VII
   * @x-auditable true
   */
  model?: string | null;
  /**
   * The name of the device.
   *
   * @example My Device
   * @x-auditable true
   */
  name: string;
  /**
   * The device operating system version number.
   *
   * @x-auditable true
   */
  os_version?: string | null;
  /**
   * Additional operating system version data. For macOS or iOS, the Product Version Extra. For Linux, the kernel release version.
   *
   * @x-auditable true
   */
  os_version_extra?: string | null;
  /**
   * The public IP address of the WARP client.
   *
   * @example 1.1.1.1
   * @x-auditable true
   */
  public_ip?: string | null;
  /**
   * The device serial number.
   *
   * @example ABS765ASD8A
   * @x-auditable true
   */
  serial_number?: string | null;
  /**
   * The RFC3339 timestamp when the device was last updated.
   *
   * @example 2025-02-14T13:17:00Z
   * @x-auditable true
   */
  updated_at: string;
};

/**
 * @example windows
 * @x-auditable true
 */
export type TeamsDevicesPlatform =
  | "windows"
  | "mac"
  | "linux"
  | "android"
  | "ios"
  | "chromeos";

/**
 * The precedence of the policy. Lower values indicate higher precedence. Policies will be evaluated in ascending order of this field.
 *
 * @example 100
 */
export type TeamsDevicesPrecedence = number;

/**
 * Determines if the operating system will register WARP's local interface IP with your on-premises DNS server.
 *
 * @default true
 * @example true
 */
export type TeamsDevicesRegisterInterfaceIpWithDns = boolean;

/**
 * A WARP configuration tied to a single user. Multiple registrations can be created from a single WARP device.
 */
export type TeamsDevicesRegistration = {
  /**
   * The RFC3339 timestamp when the registration was created.
   *
   * @example 2025-02-14T13:17:00Z
   * @x-auditable true
   */
  created_at: string;
  /**
   * The RFC3339 timestamp when the registration was deleted.
   *
   * @example 2025-02-14T13:17:00Z
   * @x-auditable true
   */
  deleted_at?: string | null;
  device: TeamsDevicesRegistrationDeviceDetails;
  /**
   * The ID of the registration.
   *
   * @example 11ffb86f-3f0c-4306-b4a2-e62f872b166a
   * @x-auditable true
   */
  id: string;
  /**
   * The public key used to connect to the Cloudflare network.
   *
   * @example U+QTP50RsWfeLGHF4tlGDnmGeuwtsz46KCHr5OyhWq00Rsdfl45mgnQAuEJ6CO0YrkyTl9FUf5iB0bwYR3g4EEFEHhtu6jFaqfMrBMBSz6itv9HQXkaR9OieKQ==
   * @x-auditable true
   */
  key: string;
  /**
   * The type of encryption key used by the WARP client for the active key. Currently 'curve25519' for WireGuard and 'secp256r1' for MASQUE.
   *
   * @example secp256r1
   * @x-auditable true
   */
  key_type?: string | null;
  /**
   * The RFC3339 timestamp when the registration was last seen.
   *
   * @example 2025-02-14T13:17:00Z
   * @x-auditable true
   */
  last_seen_at: string;
  /**
   * The RFC3339 timestamp when the registration was revoked.
   *
   * @example 2025-02-14T13:17:00Z
   * @x-auditable true
   */
  revoked_at?: string | null;
  /**
   * Type of the tunnel - wireguard or masque.
   *
   * @example masque
   * @x-auditable true
   */
  tunnel_type?: string | null;
  /**
   * The RFC3339 timestamp when the registration was last updated.
   *
   * @example 2025-02-14T13:17:00Z
   * @x-auditable true
   */
  updated_at: string;
  user?: TeamsDevicesUser;
};

/**
 * Device details embedded inside of a registration.
 */
export type TeamsDevicesRegistrationDeviceDetails = {
  /**
   * Version of the WARP client.
   *
   * @example 1.0.0
   * @x-auditable true
   */
  client_version?: string;
  /**
   * The ID of the device.
   *
   * @example 32aa0404-78f1-49a4-99e0-97f575081356
   * @x-auditable true
   */
  id: string;
  /**
   * The name of the device.
   *
   * @example My Device
   * @x-auditable true
   */
  name: string;
};

/**
 * Registration ID. Equal to Device ID except for accounts which enabled [multi-user mode](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/warp/deployment/mdm-deployment/windows-multiuser/).
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 * @x-auditable true
 */
export type TeamsDevicesRegistrationId = string;

/**
 * Whether to check all disks for encryption.
 *
 * @example true
 * @x-auditable true
 */
export type TeamsDevicesRequireAll = boolean;

export type TeamsDevicesResponseCollection =
  TeamsDevicesApiResponseCollection & {
    result?: TeamsDevicesDevicePostureRules[];
  };

export type TeamsDevicesResultInfo = {
  /**
   * Total number of results for the requested service.
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results.
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results.
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters.
   *
   * @example 2000
   */
  total_count?: number;
};

/**
 * A list of Registration IDs to revoke.
 *
 * @maxLength 200
 */
export type TeamsDevicesRevokeDevicesRequest = TeamsDevicesRegistrationId[];

/**
 * When the device was revoked.
 *
 * @example 2017-06-14T00:00:00Z
 * @format date-time
 * @x-auditable true
 */
export type TeamsDevicesRevokedAt = string;

/**
 * Determines whether the WARP client indicates to SCCM that it is inside a VPN boundary. (Windows only).
 *
 * @default false
 * @example false
 */
export type TeamsDevicesSccmVpnBoundarySupport = boolean;

/**
 * Polling frequency for the WARP client posture check. Default: `5m` (poll every five minutes). Minimum: `1m`.
 *
 * @example 1h
 * @x-auditable true
 */
export type TeamsDevicesSchedule = string;

/**
 * The configuration object containing information for the WARP client to detect the managed network.
 *
 * @example {"sha256":"b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c","tls_sockaddr":"foo.bar:1234"}
 */
export type TeamsDevicesSchemasConfigRequest = TeamsDevicesTlsConfigRequest;

/**
 * The configuration object containing information for the WARP client to detect the managed network.
 *
 * @example {"sha256":"b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c","tls_sockaddr":"foo.bar:1234"}
 */
export type TeamsDevicesSchemasConfigResponse = TeamsDevicesTlsConfigResponse;

/**
 * A description of the policy.
 *
 * @example Policy for test teams.
 * @maxLength 500
 */
export type TeamsDevicesSchemasDescription = string;

export type TeamsDevicesSchemasIdResponse = TeamsDevicesApiResponseSingle & {
  result?: Record<string, any> | null;
};

/**
 * The wirefilter expression to match devices. Available values: "identity.email", "identity.groups.id", "identity.groups.name", "identity.groups.email", "identity.service_token_uuid", "identity.saml_attributes", "network", "os.name", "os.version".
 *
 * @example identity.email == "test@cloudflare.com"
 * @maxLength 500
 */
export type TeamsDevicesSchemasMatch = string;

/**
 * The device name.
 *
 * @example My mobile device
 */
export type TeamsDevicesSchemasName = string;

export type TeamsDevicesSchemasResponseCollection =
  TeamsDevicesApiResponseCollection & {
    result?: TeamsDevicesDevicePostureIntegrations[];
  };

export type TeamsDevicesSchemasSingleResponse =
  TeamsDevicesApiResponseSingle & {
    result?: TeamsDevicesDevicePostureIntegrations;
  };

/**
 * The unique identifier for the test.
 *
 * @example 372e67954025e0ba6aaa6d586b9e0b59
 * @maxLength 32
 */
export type TeamsDevicesSchemasTestId = string;

/**
 * The type of device posture integration.
 *
 * @example workspace_one
 * @x-auditable true
 */
export type TeamsDevicesSchemasType =
  | "workspace_one"
  | "crowdstrike_s2s"
  | "uptycs"
  | "intune"
  | "kolide"
  | "tanium_s2s"
  | "sentinelone_s2s"
  | "custom_s2s";

/**
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 * @x-auditable true
 */
export type TeamsDevicesSchemasUuid = string;

export type TeamsDevicesSentineloneInputRequest = {
  /**
   * Operating system.
   *
   * @example mac
   * @x-auditable true
   */
  operating_system: "windows" | "linux" | "mac";
  /**
   * File path.
   *
   * @example /bin/cat
   * @x-auditable true
   */
  path: string;
  /**
   * SHA-256.
   *
   * @example b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c
   * @x-auditable true
   */
  sha256?: string;
  /**
   * Signing certificate thumbprint.
   *
   * @example 0aabab210bdb998e9cf45da2c9ce352977ab531c681b74cf1e487be1bbe9fe6e
   * @x-auditable true
   */
  thumbprint?: string;
};

export type TeamsDevicesSentineloneS2sConfigRequest = {
  /**
   * The SentinelOne S2S API URL.
   *
   * @example https://example.sentinelone.net
   */
  api_url: string;
  /**
   * The SentinelOne S2S client secret.
   *
   * @example example client secret
   * @x-sensitive true
   */
  client_secret: string;
};

export type TeamsDevicesSentineloneS2sInputRequest = {
  /**
   * The Number of active threats.
   *
   * @example 1
   */
  active_threats?: number;
  /**
   * Posture Integration ID.
   *
   * @example bc7cbfbb-600a-42e4-8a23-45b5e85f804f
   */
  connection_id: string;
  /**
   * Whether device is infected.
   *
   * @example true
   */
  infected?: boolean;
  /**
   * Whether device is active.
   *
   * @example true
   */
  is_active?: boolean;
  /**
   * Network status of device.
   *
   * @example connected
   */
  network_status?:
    | "connected"
    | "disconnected"
    | "disconnecting"
    | "connecting";
  /**
   * Agent operational state.
   */
  operational_state?:
    | "na"
    | "partially_disabled"
    | "auto_fully_disabled"
    | "fully_disabled"
    | "auto_partially_disabled"
    | "disabled_error"
    | "db_corruption";
  /**
   * Operator.
   *
   * @example >
   */
  operator?: "<" | "<=" | ">" | ">=" | "==";
};

/**
 * The device serial number.
 *
 * @example EXAMPLEHMD6R
 */
export type TeamsDevicesSerialNumber = string;

export type TeamsDevicesServiceModeV2 = {
  /**
   * The mode to run the WARP client under.
   *
   * @example proxy
   * @x-auditable true
   */
  mode?: string;
  /**
   * The port number when used with proxy mode.
   *
   * @example 3000
   * @x-auditable true
   */
  port?: number;
};

export type TeamsDevicesSingleResponse = TeamsDevicesApiResponseSingle & {
  result?: TeamsDevicesDevicePostureRules;
};

export type TeamsDevicesSplitTunnel =
  | TeamsDevicesExcludeSplitTunnelWithAddress
  | TeamsDevicesExcludeSplitTunnelWithHost;

/**
 * The address in CIDR format to exclude from the tunnel. If `address` is present, `host` must not be present.
 *
 * @example 192.0.2.0/24
 */
export type TeamsDevicesSplitTunnelAddress = string;

/**
 * A description of the Split Tunnel item, displayed in the client UI.
 *
 * @example Exclude testing domains from the tunnel
 * @maxLength 100
 */
export type TeamsDevicesSplitTunnelDescription = string;

/**
 * The domain name to exclude from the tunnel. If `host` is present, `address` must not be present.
 *
 * @example *.example.com
 */
export type TeamsDevicesSplitTunnelHost = string;

export type TeamsDevicesSplitTunnelInclude =
  | TeamsDevicesIncludeSplitTunnelWithAddress
  | TeamsDevicesIncludeSplitTunnelWithHost;

export type TeamsDevicesSplitTunnelIncludeResponseCollection =
  TeamsDevicesApiResponseCollection & {
    result?: TeamsDevicesSplitTunnelInclude[];
  };

export type TeamsDevicesSplitTunnelResponseCollection =
  TeamsDevicesApiResponseCollection & {
    result?: TeamsDevicesSplitTunnel[];
  };

/**
 * The URL to launch when the Send Feedback button is clicked.
 *
 * @default
 * @example https://1.1.1.1/help
 */
export type TeamsDevicesSupportUrl = string;

/**
 * Whether to allow the user to turn off the WARP switch and disconnect the client.
 *
 * @default false
 * @example true
 */
export type TeamsDevicesSwitchLocked = boolean;

export type TeamsDevicesTaniumConfigRequest = {
  /**
   * If present, this id will be passed in the `CF-Access-Client-ID` header when hitting the `api_url`.
   *
   * @example 88bf3b6d86161464f6509f7219099e57.access
   */
  access_client_id?: string;
  /**
   * If present, this secret will be passed in the `CF-Access-Client-Secret` header when hitting the `api_url`.
   *
   * @example bdd31cbc4dec990953e39163fbbb194c93313ca9f0a6e420346af9d326b1d2a5
   * @x-sensitive true
   */
  access_client_secret?: string;
  /**
   * The Tanium API URL.
   *
   * @example https://dummy-tanium-api.cloudflare.com/plugin/products/gateway/graphql
   * @x-auditable true
   */
  api_url: string;
  /**
   * The Tanium client secret.
   *
   * @example example client secret
   * @x-sensitive true
   */
  client_secret: string;
};

export type TeamsDevicesTaniumInputRequest = {
  /**
   * Posture Integration ID.
   *
   * @example bc7cbfbb-600a-42e4-8a23-45b5e85f804f
   * @x-auditable true
   */
  connection_id: string;
  /**
   * For more details on eid last seen, refer to the Tanium documentation.
   *
   * @example 2023-07-20T23:16:32Z
   * @x-auditable true
   */
  eid_last_seen?: string;
  /**
   * Operator to evaluate risk_level or eid_last_seen.
   *
   * @example >
   * @x-auditable true
   */
  operator?: "<" | "<=" | ">" | ">=" | "==";
  /**
   * For more details on risk level, refer to the Tanium documentation.
   *
   * @example low
   * @x-auditable true
   */
  risk_level?: "low" | "medium" | "high" | "critical";
  /**
   * Score Operator.
   *
   * @example >
   * @x-auditable true
   */
  scoreOperator?: "<" | "<=" | ">" | ">=" | "==";
  /**
   * For more details on total score, refer to the Tanium documentation.
   *
   * @example 1
   * @x-auditable true
   */
  total_score?: number;
};

export type TeamsDevicesTargetDexTest = {
  /**
   * The id of the DEX test targeting this policy.
   */
  id?: string;
  /**
   * The name of the DEX test targeting this policy.
   */
  name?: string;
};

/**
 * When the Global WARP override state was updated.
 *
 * @example 1970-01-01T00:00:00.000Z
 * @format date-time
 * @x-auditable true
 */
export type TeamsDevicesTimestamp = string;

export type TeamsDevicesTlsConfigRequest = {
  /**
   * The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
   *
   * @example b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c
   */
  sha256?: string;
  /**
   * A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
   *
   * @example foobar:1234
   */
  tls_sockaddr: string;
};

/**
 * The Managed Network TLS Config Response.
 */
export type TeamsDevicesTlsConfigResponse = {
  /**
   * The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
   *
   * @example b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c
   */
  sha256?: string;
  /**
   * A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
   *
   * @example foobar:1234
   * @x-auditable true
   */
  tls_sockaddr: string;
};

/**
 * List of trust stores to check for client certificate.
 *
 * @example system
 * @example user
 */
export type TeamsDevicesTrustStores = TeamsDevicesTrustStoresEnum[];

/**
 * @x-auditable true
 */
export type TeamsDevicesTrustStoresEnum = "system" | "user";

/**
 * Determines which tunnel protocol to use.
 *
 * @default
 * @example wireguard
 */
export type TeamsDevicesTunnelProtocol = string;

/**
 * Type of the tunnel connection used.
 *
 * @example masque
 * @x-auditable true
 */
export type TeamsDevicesTunnelType = string;

/**
 * The type of device posture rule.
 *
 * @example file
 * @x-auditable true
 */
export type TeamsDevicesType =
  | "file"
  | "application"
  | "tanium"
  | "gateway"
  | "warp"
  | "disk_encryption"
  | "serial_number"
  | "sentinelone"
  | "carbonblack"
  | "firewall"
  | "os_version"
  | "domain_joined"
  | "client_certificate"
  | "client_certificate_v2"
  | "unique_client_id"
  | "kolide"
  | "tanium_s2s"
  | "crowdstrike_s2s"
  | "intune"
  | "workspace_one"
  | "sentinelone_s2s"
  | "custom_s2s";

export type TeamsDevicesUniqueClientIdInputRequest = {
  /**
   * List ID.
   *
   * @example da3de859-8f6e-47ea-a2b5-b2433858471f
   * @x-auditable true
   */
  id: string;
  /**
   * Operating System.
   *
   * @example android
   * @x-auditable true
   */
  operating_system: "android" | "ios" | "chromeos";
};

/**
 * A list of Registration IDs to unrevoke.
 *
 * @maxLength 200
 */
export type TeamsDevicesUnrevokeDevicesRequest = TeamsDevicesRegistrationId[];

/**
 * When the device was updated.
 *
 * @example 2017-06-14T00:00:00Z
 * @format date-time
 * @x-auditable true
 */
export type TeamsDevicesUpdated = string;

export type TeamsDevicesUptycsConfigRequest = {
  /**
   * The Uptycs API URL.
   *
   * @example rnd.uptycs.io
   * @x-auditable true
   */
  api_url: string;
  /**
   * The Uptycs client secret.
   *
   * @example example client key
   */
  client_key: string;
  /**
   * The Uptycs client secret.
   *
   * @example example client secret
   * @x-sensitive true
   */
  client_secret: string;
  /**
   * The Uptycs customer ID.
   *
   * @example example customer id
   */
  customer_id: string;
};

export type TeamsDevicesUser = {
  email?: TeamsDevicesEmail;
  id?: TeamsDevicesComponentsSchemasUuid;
  /**
   * The enrolled device user's name.
   *
   * @example John Appleseed
   */
  name?: string;
};

/**
 * API UUID.
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 * @x-auditable true
 */
export type TeamsDevicesUuid = string;

/**
 * A message which can be returned in either the 'errors' or 'messages' fields in a v4 API response.
 */
export type TeamsDevicesV4ResponseMessage = {
  code: number;
  message: string;
};

/**
 * The WARP client version.
 *
 * @example 1.0.0
 */
export type TeamsDevicesVersion = string;

export type TeamsDevicesWorkspaceOneConfigRequest = {
  /**
   * The Workspace One API URL provided in the Workspace One Admin Dashboard.
   *
   * @example https://as123.awmdm.com/API
   */
  api_url: string;
  /**
   * The Workspace One Authorization URL depending on your region.
   *
   * @example https://na.uemauth.vmwservices.com/connect/token
   */
  auth_url: string;
  /**
   * The Workspace One client ID provided in the Workspace One Admin Dashboard.
   *
   * @example example client id
   */
  client_id: string;
  /**
   * The Workspace One client secret provided in the Workspace One Admin Dashboard.
   *
   * @example example client secret
   * @x-sensitive true
   */
  client_secret: string;
};

/**
 * The Workspace One Config Response.
 */
export type TeamsDevicesWorkspaceOneConfigResponse = {
  /**
   * The Workspace One API URL provided in the Workspace One Admin Dashboard.
   *
   * @example https://as123.awmdm.com/API
   */
  api_url: string;
  /**
   * The Workspace One Authorization URL depending on your region.
   *
   * @example https://na.uemauth.vmwservices.com/connect/token
   */
  auth_url: string;
  /**
   * The Workspace One client ID provided in the Workspace One Admin Dashboard.
   *
   * @example example client id
   */
  client_id: string;
};

export type TeamsDevicesWorkspaceOneInputRequest = {
  /**
   * Compliance Status.
   *
   * @example compliant
   * @x-auditable true
   */
  compliance_status: "compliant" | "noncompliant" | "unknown";
  /**
   * Posture Integration ID.
   *
   * @example bc7cbfbb-600a-42e4-8a23-45b5e85f804f
   * @x-auditable true
   */
  connection_id: string;
};

export type TeamsDevicesZeroTrustAccountDeviceSettings = {
  /**
   * Sets the time limit, in seconds, that a user can use an override code to bypass WARP.
   */
  disable_for_time?: number;
  /**
   * Enable gateway proxy filtering on TCP.
   *
   * @example true
   */
  gateway_proxy_enabled?: boolean;
  /**
   * Enable gateway proxy filtering on UDP.
   *
   * @example true
   */
  gateway_udp_proxy_enabled?: boolean;
  /**
   * Enable installation of cloudflare managed root certificate.
   *
   * @example true
   */
  root_certificate_installation_enabled?: boolean;
  /**
   * Enable using CGNAT virtual IPv4.
   *
   * @example true
   */
  use_zt_virtual_ip?: boolean;
};

export type TeamsDevicesZeroTrustAccountDeviceSettingsResponse =
  TeamsDevicesApiResponseSingle & {
    result?: TeamsDevicesZeroTrustAccountDeviceSettings;
  };

export type TlsCertificatesAndHostnamesAdvancedCertificatePackResponseSingle =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: {
      certificate_authority?: TlsCertificatesAndHostnamesSchemasCertificateAuthority;
      cloudflare_branding?: TlsCertificatesAndHostnamesCloudflareBranding;
      hosts?: TlsCertificatesAndHostnamesSchemasHosts;
      id?: TlsCertificatesAndHostnamesIdentifier;
      status?: TlsCertificatesAndHostnamesCertificatePacksComponentsSchemasStatus;
      type?: TlsCertificatesAndHostnamesAdvancedType;
      validation_method?: TlsCertificatesAndHostnamesValidationMethod;
      validity_days?: TlsCertificatesAndHostnamesValidityDays;
    };
  };

/**
 * Type of certificate pack.
 *
 * @example advanced
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesAdvancedType = "advanced";

export type TlsCertificatesAndHostnamesApiResponseCollection =
  TlsCertificatesAndHostnamesApiResponseCommon & {
    result_info?: TlsCertificatesAndHostnamesResultInfo;
  };

export type TlsCertificatesAndHostnamesApiResponseCommon = {
  errors: TlsCertificatesAndHostnamesMessages;
  messages: TlsCertificatesAndHostnamesMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type TlsCertificatesAndHostnamesApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: TlsCertificatesAndHostnamesMessages;
  messages: TlsCertificatesAndHostnamesMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type TlsCertificatesAndHostnamesApiResponseSingle =
  TlsCertificatesAndHostnamesApiResponseCommon;

export type TlsCertificatesAndHostnamesAssociationObject = {
  service?: TlsCertificatesAndHostnamesService;
  status?: TlsCertificatesAndHostnamesMtlsManagementComponentsSchemasStatus;
};

export type TlsCertificatesAndHostnamesAssociationResponseCollection =
  TlsCertificatesAndHostnamesApiResponseCollection & {
    result?: TlsCertificatesAndHostnamesAssociationObject[];
  };

export type TlsCertificatesAndHostnamesBase = {
  /**
   * When the Keyless SSL was created.
   *
   * @example 2014-01-01T05:20:00Z
   * @format date-time
   * @x-auditable true
   */
  created_on: string;
  enabled: TlsCertificatesAndHostnamesEnabled;
  host: TlsCertificatesAndHostnamesHost;
  id: TlsCertificatesAndHostnamesSchemasIdentifier;
  /**
   * When the Keyless SSL was last modified.
   *
   * @example 2014-01-01T05:20:00Z
   * @format date-time
   * @x-auditable true
   */
  modified_on: string;
  name: TlsCertificatesAndHostnamesName;
  /**
   * Available permissions for the Keyless SSL for the current user requesting the item.
   *
   * @example #ssl:read
   * @example #ssl:edit
   */
  permissions: string[];
  port: TlsCertificatesAndHostnamesPort;
  status: TlsCertificatesAndHostnamesSchemasStatus;
  tunnel?: TlsCertificatesAndHostnamesKeylessTunnel;
};

/**
 * Certificate Authority is manually reviewing the order.
 *
 * @example false
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesBrandCheck = boolean;

/**
 * A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
 *
 * @default ubiquitous
 * @example ubiquitous
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesBundleMethod =
  | "ubiquitous"
  | "optimal"
  | "force";

/**
 * Indicates whether the certificate is a CA or leaf certificate.
 *
 * @example true
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesCa = boolean;

/**
 * Certificate identifier tag.
 *
 * @example 2458ce5a-0c35-4c7f-82c7-8e9487d3ff60
 * @maxLength 36
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesCertId = string;

/**
 * Certificate Pack UUID.
 *
 * @example a77f8bd7-3b47-46b4-a6f1-75cf98109948
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesCertPackUuid = string;

/**
 * The zone's SSL certificate or certificate and the intermediate(s).
 * 
 * @example -----BEGIN CERTIFICATE-----
MIIDtTCCAp2gAwIBAgIJAMHAwfXZ5/PWMA0GCSqGSIb3DQEBCwUAMEUxCzAJBgNV
BAYTAkFVMRMwEQYDVQQIEwpTb21lLVN0YXRlMSEwHwYDVQQKExhJbnRlcm5ldCBX
aWRnaXRzIFB0eSBMdGQwHhcNMTYwODI0MTY0MzAxWhcNMTYxMTIyMTY0MzAxWjBF
MQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50
ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
CgKCAQEAwQHoetcl9+5ikGzV6cMzWtWPJHqXT3wpbEkRU9Yz7lgvddmGdtcGbg/1
CGZu0jJGkMoppoUo4c3dts3iwqRYmBikUP77wwY2QGmDZw2FvkJCJlKnabIRuGvB
KwzESIXgKk2016aTP6/dAjEHyo6SeoK8lkIySUvK0fyOVlsiEsCmOpidtnKX/a+5
0GjB79CJH4ER2lLVZnhePFR/zUOyPxZQQ4naHf7yu/b5jhO0f8fwt+pyFxIXjbEI
dZliWRkRMtzrHOJIhrmJ2A1J7iOrirbbwillwjjNVUWPf3IJ3M12S9pEewooaeO2
izNTERcG9HzAacbVRn2Y2SWIyT/18QIDAQABo4GnMIGkMB0GA1UdDgQWBBT/LbE4
9rWf288N6sJA5BRb6FJIGDB1BgNVHSMEbjBsgBT/LbE49rWf288N6sJA5BRb6FJI
GKFJpEcwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgTClNvbWUtU3RhdGUxITAfBgNV
BAoTGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZIIJAMHAwfXZ5/PWMAwGA1UdEwQF
MAMBAf8wDQYJKoZIhvcNAQELBQADggEBAHHFwl0tH0quUYZYO0dZYt4R7SJ0pCm2
2satiyzHl4OnXcHDpekAo7/a09c6Lz6AU83cKy/+x3/djYHXWba7HpEu0dR3ugQP
Mlr4zrhd9xKZ0KZKiYmtJH+ak4OM4L3FbT0owUZPyjLSlhMtJVcoRp5CJsjAMBUG
SvD8RX+T01wzox/Qb+lnnNnOlaWpqu8eoOenybxKp1a9ULzIVvN/LAcc+14vioFq
2swRWtmocBAs8QR9n4uvbpiYvS8eYueDCWMM4fvFfBhaDZ3N9IbtySh3SpFdQDhw
YbjM2rxXiyLGxB4Bol7QTv4zHif7Zt89FReT/NBy4rzaskDJY5L6xmY=
-----END CERTIFICATE-----
 */
export type TlsCertificatesAndHostnamesCertificate = string;

/**
 * Status of certificate pack.
 *
 * @example initializing
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesCertificatePacksComponentsSchemasStatus =

    | "initializing"
    | "pending_validation"
    | "deleted"
    | "pending_issuance"
    | "pending_deployment"
    | "pending_deletion"
    | "pending_expiration"
    | "expired"
    | "active"
    | "initializing_timed_out"
    | "validation_timed_out"
    | "issuance_timed_out"
    | "deployment_timed_out"
    | "deletion_timed_out"
    | "pending_cleanup"
    | "staging_deployment"
    | "staging_active"
    | "deactivating"
    | "inactive"
    | "backup_issued"
    | "holding_deployment";

export type TlsCertificatesAndHostnamesCertificateObject = {
  certificate?: TlsCertificatesAndHostnamesZoneAuthenticatedOriginPullComponentsSchemasCertificate;
  expires_on?: TlsCertificatesAndHostnamesComponentsSchemasExpiresOn;
  id?: TlsCertificatesAndHostnamesIdentifier;
  issuer?: TlsCertificatesAndHostnamesIssuer;
  signature?: TlsCertificatesAndHostnamesSignature;
  status?: TlsCertificatesAndHostnamesZoneAuthenticatedOriginPullComponentsSchemasStatus;
  uploaded_on?: TlsCertificatesAndHostnamesSchemasUploadedOn;
};

export type TlsCertificatesAndHostnamesCertificateObjectPost = {
  ca?: TlsCertificatesAndHostnamesCa;
  certificates?: TlsCertificatesAndHostnamesSchemasCertificates;
  expires_on?: TlsCertificatesAndHostnamesMtlsManagementComponentsSchemasExpiresOn;
  id?: TlsCertificatesAndHostnamesIdentifier;
  issuer?: TlsCertificatesAndHostnamesSchemasIssuer;
  name?: TlsCertificatesAndHostnamesSchemasName;
  serial_number?: TlsCertificatesAndHostnamesSchemasSerialNumber;
  signature?: TlsCertificatesAndHostnamesSignature;
  updated_at?: TlsCertificatesAndHostnamesComponentsSchemasUpdatedAt;
  uploaded_on?: TlsCertificatesAndHostnamesMtlsManagementComponentsSchemasUploadedOn;
};

export type TlsCertificatesAndHostnamesCertificateAnalyzeResponse =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: Record<string, any>;
  };

/**
 * The Certificate Authority that will issue the certificate
 *
 * @example google
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesCertificateAuthority =
  | "digicert"
  | "google"
  | "lets_encrypt"
  | "ssl_com";

export type TlsCertificatesAndHostnamesCertificatePackQuotaResponse =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: {
      advanced?: TlsCertificatesAndHostnamesQuota;
    };
  };

export type TlsCertificatesAndHostnamesCertificatePackResponseCollection =
  TlsCertificatesAndHostnamesApiResponseCollection & {
    result?: Record<string, any>[];
  };

export type TlsCertificatesAndHostnamesCertificatePackResponseSingle =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: Record<string, any>;
  };

export type TlsCertificatesAndHostnamesCertificateResponseCollection =
  TlsCertificatesAndHostnamesApiResponseCollection & {
    result?: TlsCertificatesAndHostnamesCustomCertificate[];
  };

export type TlsCertificatesAndHostnamesCertificateResponseIdOnly =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: {
      id?: TlsCertificatesAndHostnamesIdentifier;
    };
  };

export type TlsCertificatesAndHostnamesCertificateResponseSingle =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: TlsCertificatesAndHostnamesCustomCertificate;
  };

export type TlsCertificatesAndHostnamesCertificateResponseSinglePost =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: TlsCertificatesAndHostnamesCertificateObjectPost;
  };

export type TlsCertificatesAndHostnamesCertificateRevokeResponse = {
  result?: {
    id?: TlsCertificatesAndHostnamesIdentifier;
    revoked_at?: TlsCertificatesAndHostnamesRevokedAt;
  };
};

/**
 * Current status of certificate.
 *
 * @example active
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesCertificateStatus =
  | "initializing"
  | "authorizing"
  | "active"
  | "expired"
  | "issuing"
  | "timing_out"
  | "pending_deployment";

export type TlsCertificatesAndHostnamesCertificates = {
  certificate?: TlsCertificatesAndHostnamesComponentsSchemasCertificate;
  csr: TlsCertificatesAndHostnamesCsr;
  expires_on?: TlsCertificatesAndHostnamesSchemasExpiresOn;
  hostnames: TlsCertificatesAndHostnamesHostnames;
  id?: TlsCertificatesAndHostnamesIdentifier;
  request_type: TlsCertificatesAndHostnamesRequestType;
  requested_validity: TlsCertificatesAndHostnamesRequestedValidity;
};

/**
 * The Client Certificate PEM
 *
 * @example -----BEGIN CERTIFICATE-----\nMIIDmDCCAoC...dhDDE\n-----END CERTIFICATE-----
 */
export type TlsCertificatesAndHostnamesClientCertificatesComponentsSchemasCertificate =
  string;

/**
 * Certificate Authority used to issue the Client Certificate
 */
export type TlsCertificatesAndHostnamesClientCertificatesComponentsSchemasCertificateAuthority =
  {
    /**
     * @example 568b6b74-7b0c-4755-8840-4e3b8c24adeb
     * @x-auditable true
     */
    id?: string;
    /**
     * @example Cloudflare Managed CA for account
     * @x-auditable true
     */
    name?: string;
  };

/**
 * Client Certificates may be active or revoked, and the pending_reactivation or pending_revocation represent in-progress asynchronous transitions
 *
 * @example active
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesClientCertificatesComponentsSchemasStatus =
  "active" | "pending_reactivation" | "pending_revocation" | "revoked";

export type TlsCertificatesAndHostnamesClientCertificate = {
  certificate?: TlsCertificatesAndHostnamesClientCertificatesComponentsSchemasCertificate;
  certificate_authority?: TlsCertificatesAndHostnamesClientCertificatesComponentsSchemasCertificateAuthority;
  common_name?: TlsCertificatesAndHostnamesCommonName;
  country?: TlsCertificatesAndHostnamesCountry;
  csr?: TlsCertificatesAndHostnamesSchemasCsr;
  expires_on?: TlsCertificatesAndHostnamesExpiredOn;
  fingerprint_sha256?: TlsCertificatesAndHostnamesFingerprintSha256;
  id?: TlsCertificatesAndHostnamesIdentifier;
  issued_on?: TlsCertificatesAndHostnamesIssuedOn;
  location?: TlsCertificatesAndHostnamesLocation;
  organization?: TlsCertificatesAndHostnamesOrganization;
  organizational_unit?: TlsCertificatesAndHostnamesOrganizationalUnit;
  serial_number?: TlsCertificatesAndHostnamesComponentsSchemasSerialNumber;
  signature?: TlsCertificatesAndHostnamesComponentsSchemasSignature;
  ski?: TlsCertificatesAndHostnamesSki;
  state?: TlsCertificatesAndHostnamesState;
  status?: TlsCertificatesAndHostnamesClientCertificatesComponentsSchemasStatus;
  validity_days?: TlsCertificatesAndHostnamesSchemasValidityDays;
};

export type TlsCertificatesAndHostnamesClientCertificateResponseCollection =
  TlsCertificatesAndHostnamesApiResponseCollection & {
    result?: TlsCertificatesAndHostnamesClientCertificate[];
  };

export type TlsCertificatesAndHostnamesClientCertificateResponseSingle =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: TlsCertificatesAndHostnamesClientCertificate;
  };

/**
 * Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true.
 *
 * @example false
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesCloudflareBranding = boolean;

/**
 * Common Name of the Client Certificate
 *
 * @example Cloudflare
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesCommonName = string;

/**
 * The Origin CA certificate. Will be newline-encoded.
 * 
 * @example -----BEGIN CERTIFICATE-----
MIICvDCCAaQCAQAwdzELMAkGA1UEBhMCVVMxDTALBgNVBAgMBFV0YWgxDzANBgNV
BAcMBkxpbmRvbjEWMBQGA1UECgwNRGlnaUNlcnQgSW5jLjERMA8GA1UECwwIRGln
aUNlcnQxHTAbBgNVBAMMFGV4YW1wbGUuZGlnaWNlcnQuY29tMIIBIjANBgkqhkiG
9w0BAQEFAAOCAQ8AMIIBCgKCAQEA8+To7d+2kPWeBv/orU3LVbJwDrSQbeKamCmo
wp5bqDxIwV20zqRb7APUOKYoVEFFOEQs6T6gImnIolhbiH6m4zgZ/CPvWBOkZc+c
1Po2EmvBz+AD5sBdT5kzGQA6NbWyZGldxRthNLOs1efOhdnWFuhI162qmcflgpiI
WDuwq4C9f+YkeJhNn9dF5+owm8cOQmDrV8NNdiTqin8q3qYAHHJRW28glJUCZkTZ
wIaSR6crBQ8TbYNE0dc+Caa3DOIkz1EOsHWzTx+n0zKfqcbgXi4DJx+C1bjptYPR
BPZL8DAeWuA8ebudVT44yEp82G96/Ggcf7F33xMxe0yc+Xa6owIDAQABoAAwDQYJ
KoZIhvcNAQEFBQADggEBAB0kcrFccSmFDmxox0Ne01UIqSsDqHgL+XmHTXJwre6D
hJSZwbvEtOK0G3+dr4Fs11WuUNt5qcLsx5a8uk4G6AKHMzuhLsJ7XZjgmQXGECpY
Q4mC3yT3ZoCGpIXbw+iP3lmEEXgaQL0Tx5LFl/okKbKYwIqNiyKWOMj7ZR/wxWg/
ZDGRs55xuoeLDJ/ZRFf9bI+IaCUd1YrfYcHIl3G87Av+r49YVwqRDT0VDV7uLgqn
29XI1PpVUNCPQGn9p/eX6Qo7vpDaPybRtA2R7XLKjQaF9oXWeCUqy1hvJac9QFO2
97Ob1alpHPoZ7mWiEuJwjBPii6a9M9G30nUo39lBi1w=
-----END CERTIFICATE-----
 */
export type TlsCertificatesAndHostnamesComponentsSchemasCertificate = string;

export type TlsCertificatesAndHostnamesComponentsSchemasCertificateObject = {
  ca?: TlsCertificatesAndHostnamesCa;
  certificates?: TlsCertificatesAndHostnamesSchemasCertificates;
  expires_on?: TlsCertificatesAndHostnamesMtlsManagementComponentsSchemasExpiresOn;
  id?: TlsCertificatesAndHostnamesIdentifier;
  issuer?: TlsCertificatesAndHostnamesSchemasIssuer;
  name?: TlsCertificatesAndHostnamesSchemasName;
  serial_number?: TlsCertificatesAndHostnamesSchemasSerialNumber;
  signature?: TlsCertificatesAndHostnamesSignature;
  uploaded_on?: TlsCertificatesAndHostnamesMtlsManagementComponentsSchemasUploadedOn;
};

/**
 * The Certificate Authority that Total TLS certificates will be issued through.
 *
 * @example google
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesComponentsSchemasCertificateAuthority =
  | "google"
  | "lets_encrypt"
  | "ssl_com";

export type TlsCertificatesAndHostnamesComponentsSchemasCertificateResponseCollection =
  TlsCertificatesAndHostnamesApiResponseCollection & {
    result?: TlsCertificatesAndHostnamesZoneAuthenticatedOriginPull[];
  };

export type TlsCertificatesAndHostnamesComponentsSchemasCertificateResponseSingle =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: TlsCertificatesAndHostnamesZoneAuthenticatedOriginPull;
  };

/**
 * The time when the certificate was created.
 *
 * @example 2100-01-01T05:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesComponentsSchemasCreatedAt = string;

/**
 * If enabled, Total TLS will order a hostname specific TLS certificate for any proxied A, AAAA, or CNAME record in your zone.
 *
 * @example true
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesComponentsSchemasEnabled = boolean;

/**
 * When the certificate from the authority expires.
 *
 * @example 2100-01-01T05:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesComponentsSchemasExpiresOn = string;

/**
 * The hostname for which the tls settings are set.
 *
 * @example app.example.com
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesComponentsSchemasHostname = string;

/**
 * The private key for the certificate. This field is only needed for specific use cases such as using a custom certificate with Zero Trust's block page.
 * 
 * @example -----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDEXDkcICRU3XBv9hiiPnBWIjgTQyowmVFxDr11mONgZB/cMYjE/OvQjvnpwNcOaSK16MOpAjNbELKRx2lZiVJaLRDCccqCxXwP/CrdRChcqGzo7mbNksMlcidrErb0LlEBKLFC2QjRmRKqB+YOs4TD8WsZu2S667A2fZmjRlaqOxFi1h62ee0P+TLU628UC/nl41JifSt5Evt7hMDHakemdwZblNYr2p6T3NQjdhjYXTtP4UmOGJBhJ7i7Kicg3d3CIgdTMbggSeGWqjndr4ldVnD96FN3cVT5uDFsn2CJXTFgdeBWoUnMS4VnUZzPWGf4vSBXC8qV7Ls+w46yT7T1AgMBAAECggEAQZnp/oqCeNPOR6l5S2L+1tfx0gWjZ78hJVteUpZ0iHSK7F6kKeOxyOird7vUXV0kmo+cJq+0hp0Ke4eam640FCpwKfYoSQ4/R3vgujGWJnaihCN5tv5sMet0XeJPuz5qE7ALoKCvwI6aXLHs20aAeZIDTQJ9QbGSGnJVzOWn+JDTidIgZpN57RpXfSAwnJPTQK/PN8i5z108hsaDOdEgGmxYZ7kYqMqzX20KXmth58LDfPixs5JGtS60iiKC/wOcGzkB2/AdTSojR76oEU77cANP/3zO25NG//whUdYlW0t0d7PgXxIeJe+xgYnamDQJx3qonVyt4H77ha0ObRAj9QKBgQDicZr+VTwFMnELP3a+FXGnjehRiuS1i7MXGKxNweCD+dFlML0FplSQS8Ro2n+d8lu8BBXGx0qm6VXu8Rhn7TAUL6q+PCgfarzxfIhacb/TZCqfieIHsMlVBfhV5HCXnk+kis0tuC/PRArcWTwDHJUJXkBhvkUsNswvQzavDPI7KwKBgQDd/WgLkj7A3X5fgIHZH/GbDSBiXwzKb+rF4ZCT2XFgG/OAW7vapfcX/w+v+5lBLyrocmOAS3PGGAhM5T3HLnUCQfnK4qgps1Lqibkc9Tmnsn60LanUjuUMsYv/zSw70tozbzhJ0pioEpWfRxRZBztO2Rr8Ntm7h6Fk701EXGNAXwKBgQCD1xsjy2J3sCerIdcz0u5qXLAPkeuZW+34m4/ucdwTWwc0gEz9lhsULFj9p4G351zLuiEnq+7mAWLcDJlmIO3mQt6JhiLiL9Y0T4pgBmxmWqKKYtAsJB0EmMY+1BNN44mBRqMxZFTJu1cLdhT/xstrOeoIPqytknYNanfTMZlzIwKBgHrLXe5oq0XMP8dcMneEcAUwsaU4pr6kQd3L9EmUkl5zl7J9C+DaxWAEuwzBw/iGutlxzRB+rD/7szu14wJ29EqXbDGKRzMp+se5/yfBjm7xEZ1hVPw7PwBShfqt57X/4Ktq7lwHnmH6RcGhc+P7WBc5iO/S94YAdIp8xOT3pf9JAoGAE0QkqJUY+5Mgr+fBO0VNV72ZoPveGpW+De59uhKAOnu1zljQCUtk59m6+DXfm0tNYKtawa5n8iN71Zh+s62xXSt3pYi1Y5CCCmv8Y4BhwIcPwXKk3zEvLgSHVTpC0bayA9aSO4bbZgVXa5w+Z0w/vvfp9DWo1IS3EnQRrz6WMYA=
-----END PRIVATE KEY-----
 * @x-sensitive true
 */
export type TlsCertificatesAndHostnamesComponentsSchemasPrivateKey = string;

/**
 * The serial number on the created Client Certificate.
 *
 * @example 3bb94ff144ac567b9f75ad664b6c55f8d5e48182
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesComponentsSchemasSerialNumber = string;

/**
 * The type of hash used for the Client Certificate..
 *
 * @example SHA256WithRSA
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesComponentsSchemasSignature = string;

/**
 * Status of the hostname's activation.
 *
 * @example pending
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesComponentsSchemasStatus =
  | "active"
  | "pending"
  | "active_redeploying"
  | "moved"
  | "pending_deletion"
  | "deleted"
  | "pending_blocked"
  | "pending_migration"
  | "pending_provisioned"
  | "test_pending"
  | "test_active"
  | "test_active_apex"
  | "test_blocked"
  | "test_failed"
  | "provisioned"
  | "blocked";

/**
 * This is the time the certificate was updated.
 *
 * @example 2022-11-22T17:32:30.467938Z
 * @format date-time
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesComponentsSchemasUpdatedAt = string;

/**
 * The time when the certificate was uploaded.
 *
 * @example 2019-10-28T18:11:23.37411Z
 * @format date-time
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesComponentsSchemasUploadedOn = string;

export type TlsCertificatesAndHostnamesComponentsSchemasValidationMethod = {
  validation_method: TlsCertificatesAndHostnamesValidationMethodDefinition;
};

export type TlsCertificatesAndHostnamesConfig =
  TlsCertificatesAndHostnamesHostnameCertidInput[];

/**
 * Country, provided by the CSR
 *
 * @example US
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesCountry = string;

/**
 * This is the time the hostname was created.
 *
 * @example 2020-02-06T18:11:23.531995Z
 * @format date-time
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesCreatedAt = string;

/**
 * The Certificate Signing Request (CSR). Must be newline-encoded.
 * 
 * @example -----BEGIN CERTIFICATE REQUEST-----
MIICxzCCAa8CAQAwSDELMAkGA1UEBhMCVVMxFjAUBgNVBAgTDVNhbiBGcmFuY2lz
Y28xCzAJBgNVBAcTAkNBMRQwEgYDVQQDEwtleGFtcGxlLm5ldDCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBALxejtu4b+jPdFeFi6OUsye8TYJQBm3WfCvL
Hu5EvijMO/4Z2TImwASbwUF7Ir8OLgH+mGlQZeqyNvGoSOMEaZVXcYfpR1hlVak8
4GGVr+04IGfOCqaBokaBFIwzclGZbzKmLGwIQioNxGfqFm6RGYGA3be2Je2iseBc
N8GV1wYmvYE0RR+yWweJCTJ157exyRzu7sVxaEW9F87zBQLyOnwXc64rflXslRqi
g7F7w5IaQYOl8yvmk/jEPCAha7fkiUfEpj4N12+oPRiMvleJF98chxjD4MH39c5I
uOslULhrWunfh7GB1jwWNA9y44H0snrf+xvoy2TcHmxvma9Eln8CAwEAAaA6MDgG
CSqGSIb3DQEJDjErMCkwJwYDVR0RBCAwHoILZXhhbXBsZS5uZXSCD3d3dy5leGFt
cGxlLm5ldDANBgkqhkiG9w0BAQsFAAOCAQEAcBaX6dOnI8ncARrI9ZSF2AJX+8mx
pTHY2+Y2C0VvrVDGMtbBRH8R9yMbqWtlxeeNGf//LeMkSKSFa4kbpdx226lfui8/
auRDBTJGx2R1ccUxmLZXx4my0W5iIMxunu+kez+BDlu7bTT2io0uXMRHue4i6quH
yc5ibxvbJMjR7dqbcanVE10/34oprzXQsJ/VmSuZNXtjbtSKDlmcpw6To/eeAJ+J
hXykcUihvHyG4A1m2R6qpANBjnA0pHexfwM/SgfzvpbvUg0T1ubmer8BgTwCKIWs
dcWYTthM51JIqRBfNqy4QcBnX+GY05yltEEswQI55wdiS3CjTTA67sdbcQ==
-----END CERTIFICATE REQUEST-----
 */
export type TlsCertificatesAndHostnamesCsr = string;

export type TlsCertificatesAndHostnamesCustomCertificate = {
  bundle_method: TlsCertificatesAndHostnamesBundleMethod;
  expires_on: TlsCertificatesAndHostnamesExpiresOn;
  geo_restrictions?: TlsCertificatesAndHostnamesGeoRestrictions;
  hosts: TlsCertificatesAndHostnamesHosts;
  id: TlsCertificatesAndHostnamesIdentifier;
  issuer: TlsCertificatesAndHostnamesIssuer;
  keyless_server?: TlsCertificatesAndHostnamesKeylessCertificate;
  modified_on: TlsCertificatesAndHostnamesModifiedOn;
  policy?: TlsCertificatesAndHostnamesPolicy;
  priority: TlsCertificatesAndHostnamesPriority;
  signature: TlsCertificatesAndHostnamesSignature;
  status: TlsCertificatesAndHostnamesStatus;
  uploaded_on: TlsCertificatesAndHostnamesUploadedOn;
  zone_id: TlsCertificatesAndHostnamesIdentifier;
};

export type TlsCertificatesAndHostnamesCustomHostname = {
  created_at?: TlsCertificatesAndHostnamesCreatedAt;
  custom_metadata?: TlsCertificatesAndHostnamesCustomMetadata;
  custom_origin_server?: TlsCertificatesAndHostnamesCustomOriginServer;
  custom_origin_sni?: TlsCertificatesAndHostnamesCustomOriginSni;
  hostname: TlsCertificatesAndHostnamesHostname;
  id: TlsCertificatesAndHostnamesIdentifier;
  ownership_verification?: TlsCertificatesAndHostnamesOwnershipVerification;
  ownership_verification_http?: TlsCertificatesAndHostnamesOwnershipVerificationHttp;
  ssl: TlsCertificatesAndHostnamesSsl;
  status?: TlsCertificatesAndHostnamesComponentsSchemasStatus;
  verification_errors?: TlsCertificatesAndHostnamesVerificationErrors;
};

/**
 * Status of the fallback origin's activation.
 *
 * @example pending_deployment
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesCustomHostnameFallbackOriginComponentsSchemasStatus =

    | "initializing"
    | "pending_deployment"
    | "pending_deletion"
    | "active"
    | "deployment_timed_out"
    | "deletion_timed_out";

export type TlsCertificatesAndHostnamesCustomCertAndKey = {
  /**
     * If a custom uploaded certificate is used.
     *
     * @example -----BEGIN CERTIFICATE-----
    MIIDdjCCAl6gAwIBAgIJAPnMg0Fs+/B0MA0GCSqGSIb3DQEBCwUAMFsx...
    -----END CERTIFICATE-----
     */
  custom_certificate: string;
  /**
     * The key for a custom uploaded certificate.
     *
     * @example -----BEGIN PRIVATE KEY-----
    MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC/SCB5...
    -----END PRIVATE KEY-----
     * @x-sensitive true
     */
  custom_key: string;
};

/**
 * Array of custom certificate and key pairs (1 or 2 pairs allowed)
 *
 * @maxItems 2
 * @minItems 1
 */
export type TlsCertificatesAndHostnamesCustomCertBundle =
  TlsCertificatesAndHostnamesCustomCertAndKey[];

export type TlsCertificatesAndHostnamesCustomHostnameResponseCollection =
  TlsCertificatesAndHostnamesApiResponseCollection & {
    result?: TlsCertificatesAndHostnamesCustomHostname[];
  };

export type TlsCertificatesAndHostnamesCustomHostnameResponseSingle =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: TlsCertificatesAndHostnamesCustomHostname;
  };

/**
 * Unique key/value metadata for this hostname. These are per-hostname (customer) settings.
 */
export type TlsCertificatesAndHostnamesCustomMetadata = {
  [key: string]: string;
};

/**
 * a valid hostname that’s been added to your DNS zone as an A, AAAA, or CNAME record.
 *
 * @example origin2.example.com
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesCustomOriginServer = string;

/**
 * A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request_host_header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server.
 *
 * @example sni.example.com
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesCustomOriginSni = string;

export type TlsCertificatesAndHostnamesCustomhostname = {
  created_at?: TlsCertificatesAndHostnamesCreatedAt;
  custom_metadata?: TlsCertificatesAndHostnamesCustomMetadata;
  custom_origin_server?: TlsCertificatesAndHostnamesCustomOriginServer;
  custom_origin_sni?: TlsCertificatesAndHostnamesCustomOriginSni;
  hostname?: TlsCertificatesAndHostnamesHostname;
  id?: TlsCertificatesAndHostnamesIdentifier;
  ownership_verification?: TlsCertificatesAndHostnamesOwnershipVerification;
  ownership_verification_http?: TlsCertificatesAndHostnamesOwnershipVerificationHttp;
  ssl?: TlsCertificatesAndHostnamesSsl;
  status?: TlsCertificatesAndHostnamesComponentsSchemasStatus;
  verification_errors?: TlsCertificatesAndHostnamesVerificationErrors;
};

export type TlsCertificatesAndHostnamesDcvDelegationResponse =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: TlsCertificatesAndHostnamesUuidObject;
  };

export type TlsCertificatesAndHostnamesDeleteAdvancedCertificatePackResponseSingle =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: {
      id?: TlsCertificatesAndHostnamesIdentifier;
    };
  };

/**
 * Whether or not the Keyless SSL is on or off.
 *
 * @example false
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesEnabled = boolean;

export type TlsCertificatesAndHostnamesEnabledResponse =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: {
      enabled?: TlsCertificatesAndHostnamesZoneAuthenticatedOriginPullComponentsSchemasEnabled;
    };
  };

/**
 * Whether or not the Keyless SSL is on or off.
 *
 * @deprecated true
 * @example false
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesEnabledWrite = boolean;

/**
 * These are errors that were encountered while trying to activate a fallback origin.
 *
 * @example DNS records are not setup correctly. Origin should be a proxied A/AAAA/CNAME dns record
 */
export type TlsCertificatesAndHostnamesErrors = string[];

/**
 * Date that the Client Certificate expires
 *
 * @example 2033-02-20T23:18:00Z
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesExpiredOn = string;

/**
 * When the certificate from the authority expires.
 *
 * @example 2016-01-01T05:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesExpiresOn = string;

export type TlsCertificatesAndHostnamesFallbackOriginResponse =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: TlsCertificatesAndHostnamesFallbackorigin;
  };

export type TlsCertificatesAndHostnamesFallbackorigin = {
  created_at?: TlsCertificatesAndHostnamesSchemasCreatedAt;
  errors?: TlsCertificatesAndHostnamesErrors;
  origin?: TlsCertificatesAndHostnamesOrigin;
  status?: TlsCertificatesAndHostnamesCustomHostnameFallbackOriginComponentsSchemasStatus;
  updated_at?: TlsCertificatesAndHostnamesUpdatedAt;
};

/**
 * Unique identifier of the Client Certificate
 *
 * @example 256c24690243359fb8cf139a125bd05ebf1d968b71e4caf330718e9f5c8a89ea
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesFingerprintSha256 = string;

/**
 * Specify the region where your private key can be held locally for optimal TLS performance. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Options allow distribution to only to U.S. data centers, only to E.U. data centers, or only to highest security data centers. Default distribution is to all Cloudflare datacenters, for optimal performance.
 */
export type TlsCertificatesAndHostnamesGeoRestrictions = {
  /**
   * @example us
   * @x-auditable true
   */
  label?: "us" | "eu" | "highest_security";
};

/**
 * The keyless SSL name.
 *
 * @example example.com
 * @format hostname
 * @maxLength 253
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesHost = string;

/**
 * The custom hostname that will point to your hostname via CNAME.
 *
 * @example app.example.com
 * @maxLength 255
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesHostname = string;

export type TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPull = {
  cert_id?: TlsCertificatesAndHostnamesIdentifier;
  cert_status?: TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasStatus;
  cert_updated_at?: TlsCertificatesAndHostnamesSchemasUpdatedAt;
  cert_uploaded_on?: TlsCertificatesAndHostnamesComponentsSchemasUploadedOn;
  certificate?: TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasCertificate;
  created_at?: TlsCertificatesAndHostnamesComponentsSchemasCreatedAt;
  enabled?: TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasEnabled;
  expires_on?: TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasExpiresOn;
  hostname?: TlsCertificatesAndHostnamesSchemasHostname;
  issuer?: TlsCertificatesAndHostnamesIssuer;
  serial_number?: TlsCertificatesAndHostnamesSerialNumber;
  signature?: TlsCertificatesAndHostnamesSignature;
  status?: TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasStatus;
  updated_at?: TlsCertificatesAndHostnamesSchemasUpdatedAt;
  id?: TlsCertificatesAndHostnamesIdentifier;
  private_key?: TlsCertificatesAndHostnamesSchemasPrivateKey;
};

/**
 * The hostname certificate.
 * 
 * @example -----BEGIN CERTIFICATE-----
MIIDtTCCAp2gAwIBAgIJAMHAwfXZ5/PWMA0GCSqGSIb3DQEBCwUAMEUxCzAJBgNV
BAYTAkFVMRMwEQYDVQQIEwpTb21lLVN0YXRlMSEwHwYDVQQKExhJbnRlcm5ldCBX
aWRnaXRzIFB0eSBMdGQwHhcNMTYwODI0MTY0MzAxWhcNMTYxMTIyMTY0MzAxWjBF
MQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50
ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
CgKCAQEAwQHoetcl9+5ikGzV6cMzWtWPJHqXT3wpbEkRU9Yz7lgvddmGdtcGbg/1
CGZu0jJGkMoppoUo4c3dts3iwqRYmBikUP77wwY2QGmDZw2FvkJCJlKnabIRuGvB
KwzESIXgKk2016aTP6/dAjEHyo6SeoK8lkIySUvK0fyOVlsiEsCmOpidtnKX/a+5
0GjB79CJH4ER2lLVZnhePFR/zUOyPxZQQ4naHf7yu/b5jhO0f8fwt+pyFxIXjbEI
dZliWRkRMtzrHOJIhrmJ2A1J7iOrirbbwillwjjNVUWPf3IJ3M12S9pEewooaeO2
izNTERcG9HzAacbVRn2Y2SWIyT/18QIDAQABo4GnMIGkMB0GA1UdDgQWBBT/LbE4
9rWf288N6sJA5BRb6FJIGDB1BgNVHSMEbjBsgBT/LbE49rWf288N6sJA5BRb6FJI
GKFJpEcwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgTClNvbWUtU3RhdGUxITAfBgNV
BAoTGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZIIJAMHAwfXZ5/PWMAwGA1UdEwQF
MAMBAf8wDQYJKoZIhvcNAQELBQADggEBAHHFwl0tH0quUYZYO0dZYt4R7SJ0pCm2
2satiyzHl4OnXcHDpekAo7/a09c6Lz6AU83cKy/+x3/djYHXWba7HpEu0dR3ugQP
Mlr4zrhd9xKZ0KZKiYmtJH+ak4OM4L3FbT0owUZPyjLSlhMtJVcoRp5CJsjAMBUG
SvD8RX+T01wzox/Qb+lnnNnOlaWpqu8eoOenybxKp1a9ULzIVvN/LAcc+14vioFq
2swRWtmocBAs8QR9n4uvbpiYvS8eYueDCWMM4fvFfBhaDZ3N9IbtySh3SpFdQDhw
YbjM2rxXiyLGxB4Bol7QTv4zHif7Zt89FReT/NBy4rzaskDJY5L6xmY=
-----END CERTIFICATE-----
 */
export type TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasCertificate =
  string;

export type TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasCertificateResponseCollection =
  TlsCertificatesAndHostnamesApiResponseCollection & {
    result?: TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPull[];
  };

export type TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasCertificateResponseSingle =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: TlsCertificatesAndHostnamesSchemasCertificateObject;
  };

/**
 * Indicates whether hostname-level authenticated origin pulls is enabled. A null value voids the association.
 *
 * @example true
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasEnabled =
  boolean | null;

/**
 * The date when the certificate expires.
 *
 * @example 2100-01-01T05:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasExpiresOn =
  string;

/**
 * Status of the certificate or the association.
 *
 * @example active
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasStatus =

    | "initializing"
    | "pending_deployment"
    | "pending_deletion"
    | "active"
    | "deleted"
    | "deployment_timed_out"
    | "deletion_timed_out";

/**
 * This is the time the tls setting was originally created for this hostname.
 *
 * @example 2023-07-10T20:01:50.219171Z
 * @format date-time
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesHostnameTlsSettingsComponentsSchemasCreatedAt =
  string;

/**
 * Deployment status for the given tls setting.
 *
 * @example pending_deployment
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesHostnameTlsSettingsComponentsSchemasStatus =
  string;

/**
 * This is the time the tls setting was updated.
 *
 * @example 2023-07-10T20:01:50.219171Z
 * @format date-time
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesHostnameTlsSettingsComponentsSchemasUpdatedAt =
  string;

export type TlsCertificatesAndHostnamesHostnameAopResponseCollection =
  TlsCertificatesAndHostnamesApiResponseCollection & {
    result?: TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPull[];
  };

export type TlsCertificatesAndHostnamesHostnameAopSingleResponse =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: TlsCertificatesAndHostnamesHostnameCertidObject;
  };

export type TlsCertificatesAndHostnamesHostnameAssociation = {
  hostnames?: TlsCertificatesAndHostnamesSchemasHostnames;
  /**
   * The UUID for a certificate that was uploaded to the mTLS Certificate Management endpoint. If no mtls_certificate_id is given, the hostnames will be associated to your active Cloudflare Managed CA.
   *
   * @maxLength 36
   * @minLength 36
   * @x-auditable true
   */
  mtls_certificate_id?: string;
};

export type TlsCertificatesAndHostnamesHostnameAssociationsResponse =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: {
      hostnames?: TlsCertificatesAndHostnamesSchemasHostnames;
    };
  };

export type TlsCertificatesAndHostnamesHostnameCertidInput = {
  cert_id?: TlsCertificatesAndHostnamesCertId;
  enabled?: TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasEnabled;
  hostname?: TlsCertificatesAndHostnamesSchemasHostname;
};

export type TlsCertificatesAndHostnamesHostnameCertidObject = {
  cert_id?: TlsCertificatesAndHostnamesIdentifier;
  cert_status?: TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasStatus;
  cert_updated_at?: TlsCertificatesAndHostnamesSchemasUpdatedAt;
  cert_uploaded_on?: TlsCertificatesAndHostnamesComponentsSchemasUploadedOn;
  certificate?: TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasCertificate;
  created_at?: TlsCertificatesAndHostnamesComponentsSchemasCreatedAt;
  enabled?: TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasEnabled;
  expires_on?: TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasExpiresOn;
  hostname?: TlsCertificatesAndHostnamesSchemasHostname;
  issuer?: TlsCertificatesAndHostnamesIssuer;
  serial_number?: TlsCertificatesAndHostnamesSerialNumber;
  signature?: TlsCertificatesAndHostnamesSignature;
  status?: TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasStatus;
  updated_at?: TlsCertificatesAndHostnamesSchemasUpdatedAt;
};

/**
 * The custom hostname that will point to your hostname via CNAME.
 *
 * @example app.example.com
 * @maxLength 255
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesHostnamePost = string;

/**
 * Array of hostnames or wildcard names (e.g., *.example.com) bound to the certificate.
 *
 * @example example.com
 * @example *.example.com
 */
export type TlsCertificatesAndHostnamesHostnames = string[];

export type TlsCertificatesAndHostnamesHosts = string[];

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type TlsCertificatesAndHostnamesIdentifier = string;

/**
 * Date that the Client Certificate was issued by the Certificate Authority
 *
 * @example 2023-02-23T23:18:00Z
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesIssuedOn = string;

/**
 * The certificate authority that issued the certificate.
 *
 * @example GlobalSign
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesIssuer = string;

export type TlsCertificatesAndHostnamesKeylessCertificate =
  TlsCertificatesAndHostnamesBase;

/**
 * Private IP of the Key Server Host
 *
 * @example 10.0.0.1
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesKeylessPrivateIp = string;

export type TlsCertificatesAndHostnamesKeylessResponseCollection =
  TlsCertificatesAndHostnamesApiResponseCollection & {
    result?: TlsCertificatesAndHostnamesKeylessCertificate[];
  };

export type TlsCertificatesAndHostnamesKeylessResponseSingle =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: TlsCertificatesAndHostnamesBase;
  };

export type TlsCertificatesAndHostnamesKeylessResponseSingleId =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: {
      id?: TlsCertificatesAndHostnamesIdentifier;
    };
  };

/**
 * Configuration for using Keyless SSL through a Cloudflare Tunnel
 */
export type TlsCertificatesAndHostnamesKeylessTunnel = {
  private_ip: TlsCertificatesAndHostnamesKeylessPrivateIp;
  vnet_id: TlsCertificatesAndHostnamesKeylessVnetId;
};

/**
 * Cloudflare Tunnel Virtual Network ID
 *
 * @example 7365377a-85a4-4390-9480-531ef7dc7a3c
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesKeylessVnetId = string;

/**
 * Location, provided by the CSR
 *
 * @example Somewhere
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesLocation = string;

export type TlsCertificatesAndHostnamesMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * When the certificate was last modified.
 *
 * @example 2014-01-01T05:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesModifiedOn = string;

export type TlsCertificatesAndHostnamesMtlsManagementComponentsSchemasCertificateResponseCollection =
  TlsCertificatesAndHostnamesApiResponseCollection & {
    result?: TlsCertificatesAndHostnamesComponentsSchemasCertificateObject[];
  } & {
    result_info?: {
      /**
       * @example 1
       */
      count?: void;
      /**
       * @example 1
       */
      page?: void;
      /**
       * @example 50
       */
      per_page?: void;
      /**
       * @example 1
       */
      total_count?: void;
      /**
       * Total pages available of results
       *
       * @example 1
       */
      total_pages?: number;
    };
  };

export type TlsCertificatesAndHostnamesMtlsManagementComponentsSchemasCertificateResponseSingle =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: TlsCertificatesAndHostnamesComponentsSchemasCertificateObject;
  };

/**
 * When the certificate expires.
 *
 * @example 2122-10-29T16:59:47Z
 * @format date-time
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesMtlsManagementComponentsSchemasExpiresOn =
  string;

/**
 * Certificate deployment status for the given service.
 *
 * @example pending_deployment
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesMtlsManagementComponentsSchemasStatus =
  string;

/**
 * This is the time the certificate was uploaded.
 *
 * @example 2022-11-22T17:32:30.467938Z
 * @format date-time
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesMtlsManagementComponentsSchemasUploadedOn =
  string;

/**
 * The keyless SSL name.
 *
 * @example example.com Keyless SSL
 * @maxLength 180
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesName = string;

/**
 * The keyless SSL name.
 *
 * @example example.com Keyless SSL
 * @maxLength 180
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesNameWrite = string;

/**
 * Organization, provided by the CSR
 *
 * @example Organization
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesOrganization = string;

/**
 * Organizational Unit, provided by the CSR
 *
 * @example Organizational Unit
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesOrganizationalUnit = string;

/**
 * Your origin hostname that requests to your custom hostnames will be sent to.
 *
 * @example fallback.example.com
 * @maxLength 255
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesOrigin = string;

/**
 * This is a record which can be placed to activate a hostname.
 */
export type TlsCertificatesAndHostnamesOwnershipVerification = {
  /**
   * DNS Name for record.
   *
   * @example _cf-custom-hostname.app.example.com
   * @x-auditable true
   */
  name?: string;
  /**
   * DNS Record type.
   *
   * @example txt
   * @x-auditable true
   */
  type?: "txt";
  /**
   * Content for the record.
   *
   * @example 5cc07c04-ea62-4a5a-95f0-419334a875a4
   */
  value?: string;
};

/**
 * This presents the token to be served by the given http url to activate a hostname.
 */
export type TlsCertificatesAndHostnamesOwnershipVerificationHttp = {
  /**
   * Token to be served.
   *
   * @example 5cc07c04-ea62-4a5a-95f0-419334a875a4
   */
  http_body?: string;
  /**
   * The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
   *
   * @example http://custom.test.com/.well-known/cf-custom-hostname-challenge/0d89c70d-ad9f-4843-b99f-6cc0252067e9
   */
  http_url?: string;
};

export type TlsCertificatesAndHostnamesPerHostnameSettingsResponse =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: TlsCertificatesAndHostnamesSettingObject;
  };

export type TlsCertificatesAndHostnamesPerHostnameSettingsResponseCollection =
  TlsCertificatesAndHostnamesApiResponseCollection & {
    result?: {
      created_at?: TlsCertificatesAndHostnamesHostnameTlsSettingsComponentsSchemasCreatedAt;
      hostname?: TlsCertificatesAndHostnamesComponentsSchemasHostname;
      status?: TlsCertificatesAndHostnamesHostnameTlsSettingsComponentsSchemasStatus;
      updated_at?: TlsCertificatesAndHostnamesHostnameTlsSettingsComponentsSchemasUpdatedAt;
      value?: TlsCertificatesAndHostnamesValue;
    }[];
  } & {
    result_info?: {
      /**
       * @example 1
       */
      count?: void;
      /**
       * @example 1
       */
      page?: void;
      /**
       * @example 50
       */
      per_page?: void;
      /**
       * @example 1
       */
      total_count?: void;
      /**
       * Total pages available of results
       *
       * @example 1
       */
      total_pages?: number;
    };
  };

export type TlsCertificatesAndHostnamesPerHostnameSettingsResponseDelete =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: TlsCertificatesAndHostnamesSettingObjectDelete;
  };

/**
 * Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) can be chosen, such as 'country: IN', as well as 'region: EU' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.
 *
 * @example (country: US) or (region: EU)
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesPolicy = string;

/**
 * The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
 *
 * @default 24008
 * @example 24008
 * @maxLength 65535
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesPort = number;

/**
 * The order/priority in which the certificate will be used in a request. The higher priority will break ties across overlapping 'legacy_custom' certificates, but 'legacy_custom' certificates will always supercede 'sni_custom' certificates.
 *
 * @default 0
 * @example 1
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesPriority = number;

/**
 * The zone's private key.
 * 
 * @example -----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEAwQHoetcl9+5ikGzV6cMzWtWPJHqXT3wpbEkRU9Yz7lgvddmG
dtcGbg/1CGZu0jJGkMoppoUo4c3dts3iwqRYmBikUP77wwY2QGmDZw2FvkJCJlKn
abIRuGvBKwzESIXgKk2016aTP6/dAjEHyo6SeoK8lkIySUvK0fyOVlsiEsCmOpid
tnKX/a+50GjB79CJH4ER2lLVZnhePFR/zUOyPxZQQ4naHf7yu/b5jhO0f8fwt+py
FxIXjbEIdZliWRkRMtzrHOJIhrmJ2A1J7iOrirbbwillwjjNVUWPf3IJ3M12S9pE
ewooaeO2izNTERcG9HzAacbVRn2Y2SWIyT/18QIDAQABAoIBACbhTYXBZYKmYPCb
HBR1IBlCQA2nLGf0qRuJNJZg5iEzXows/6tc8YymZkQE7nolapWsQ+upk2y5Xdp/
axiuprIs9JzkYK8Ox0r+dlwCG1kSW+UAbX0bQ/qUqlsTvU6muVuMP8vZYHxJ3wmb
+ufRBKztPTQ/rYWaYQcgC0RWI20HTFBMxlTAyNxYNWzX7RKFkGVVyB9RsAtmcc8g
+j4OdosbfNoJPS0HeIfNpAznDfHKdxDk2Yc1tV6RHBrC1ynyLE9+TaflIAdo2MVv
KLMLq51GqYKtgJFIlBRPQqKoyXdz3fGvXrTkf/WY9QNq0J1Vk5ERePZ54mN8iZB7
9lwy/AkCgYEA6FXzosxswaJ2wQLeoYc7ceaweX/SwTvxHgXzRyJIIT0eJWgx13Wo
/WA3Iziimsjf6qE+SI/8laxPp2A86VMaIt3Z3mJN/CqSVGw8LK2AQst+OwdPyDMu
iacE8lj/IFGC8mwNUAb9CzGU3JpU4PxxGFjS/eMtGeRXCWkK4NE+G08CgYEA1Kp9
N2JrVlqUz+gAX+LPmE9OEMAS9WQSQsfCHGogIFDGGcNf7+uwBM7GAaSJIP01zcoe
VAgWdzXCv3FLhsaZoJ6RyLOLay5phbu1iaTr4UNYm5WtYTzMzqh8l1+MFFDl9xDB
vULuCIIrglM5MeS/qnSg1uMoH2oVPj9TVst/ir8CgYEAxrI7Ws9Zc4Bt70N1As+U
lySjaEVZCMkqvHJ6TCuVZFfQoE0r0whdLdRLU2PsLFP+q7qaeZQqgBaNSKeVcDYR
9B+nY/jOmQoPewPVsp/vQTCnE/R81spu0mp0YI6cIheT1Z9zAy322svcc43JaWB7
mEbeqyLOP4Z4qSOcmghZBSECgYACvR9Xs0DGn+wCsW4vze/2ei77MD4OQvepPIFX
dFZtlBy5ADcgE9z0cuVB6CiL8DbdK5kwY9pGNr8HUCI03iHkW6Zs+0L0YmihfEVe
PG19PSzK9CaDdhD9KFZSbLyVFmWfxOt50H7YRTTiPMgjyFpfi5j2q348yVT0tEQS
fhRqaQKBgAcWPokmJ7EbYQGeMbS7HC8eWO/RyamlnSffdCdSc7ue3zdVJxpAkQ8W
qu80pEIF6raIQfAf8MXiiZ7auFOSnHQTXUbhCpvDLKi0Mwq3G8Pl07l+2s6dQG6T
lv6XTQaMyf6n1yjzL+fzDrH3qXMxHMO/b13EePXpDMpY7HQpoLDi
-----END RSA PRIVATE KEY-----
 * @x-sensitive true
 */
export type TlsCertificatesAndHostnamesPrivateKey = string;

export type TlsCertificatesAndHostnamesQuota = {
  /**
   * Quantity Allocated.
   *
   * @x-auditable true
   */
  allocated?: number;
  /**
   * Quantity Used.
   *
   * @x-auditable true
   */
  used?: number;
};

/**
 * Signature type desired on certificate ("origin-rsa" (rsa), "origin-ecc" (ecdsa), or "keyless-certificate" (for Keyless SSL servers).
 *
 * @example origin-rsa
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesRequestType =
  | "origin-rsa"
  | "origin-ecc"
  | "keyless-certificate";

/**
 * The number of days for which the certificate should be valid.
 *
 * @default 5475
 * @example 5475
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesRequestedValidity =
  | 7
  | 30
  | 90
  | 365
  | 730
  | 1095
  | 5475;

export type TlsCertificatesAndHostnamesResultInfo = {
  /**
   * Total number of results for the requested service.
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results.
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results.
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters.
   *
   * @example 2000
   */
  total_count?: number;
};

/**
 * When the certificate was revoked.
 *
 * @example 2024-09-06T18:43:47.928893Z
 * @format date-time
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesRevokedAt = string;

/**
 * The zone's SSL certificate or SSL certificate and intermediate(s).
 *
 * @example -----BEGIN CERTIFICATE----- MIIDtTCCAp2gAwIBAgIJAM15n7fdxhRtMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNV BAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMSEwHwYDVQQKExhJbnRlcm5ldCBX aWRnaXRzIFB0eSBMdGQwHhcNMTQwMzExMTkyMTU5WhcNMTQwNDEwMTkyMTU5WjBF MQswCQYDVQQGEwJVUzETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50 ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB CgKCAQEAvq3sKsHpeduJHimOK+fvQdKsI8z8A05MZyyLp2/R/GE8FjNv+hkVY1WQ LIyTNNQH7CJecE1nbTfo8Y56S7x/rhxC6/DJ8MIulapFPnorq46KU6yRxiM0MQ3N nTJHlHA2ozZta6YBBfVfhHWl1F0IfNbXCLKvGwWWMbCx43OfW6KTkbRnE6gFWKuO fSO5h2u5TaWVuSIzBvYs7Vza6m+gtYAvKAJV2nSZ+eSEFPDo29corOy8+huEOUL8 5FAw4BFPsr1TlrlGPFitduQUHGrSL7skk1ESGza0to3bOtrodKei2s9bk5MXm7lZ qI+WZJX4Zu9+mzZhc9pCVi8r/qlXuQIDAQABo4GnMIGkMB0GA1UdDgQWBBRvavf+ sWM4IwKiH9X9w1vl6nUVRDB1BgNVHSMEbjBsgBRvavf+sWM4IwKiH9X9w1vl6nUV RKFJpEcwRTELMAkGA1UEBhMCVVMxEzARBgNVBAgTClNvbWUtU3RhdGUxITAfBgNV BAoTGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZIIJAM15n7fdxhRtMAwGA1UdEwQF MAMBAf8wDQYJKoZIhvcNAQEFBQADggEBABY2ZzBaW0dMsAAT7tPJzrVWVzQx6KU4 UEBLudIlWPlkAwTnINCWR/8eNjCCmGA4heUdHmazdpPa8RzwOmc0NT1NQqzSyktt vTqb4iHD7+8f9MqJ9/FssCfTtqr/Qst/hGH4Wmdf1EJ/6FqYAAb5iRlPgshFZxU8 uXtA8hWn6fK6eISD9HBdcAFToUvKNZ1BIDPvh9f95Ine8ar6yGd56TUNrHR8eHBs ESxz5ddVR/oWRysNJ+aGAyYqHS8S/ttmC7r4XCAHqXptkHPCGRqkAhsterYhd4I8 /cBzejUobNCjjHFbtkAL/SjxZOLW+pNkZwfeYdM8iPkD54Uua1v2tdw= -----END CERTIFICATE-----
 */
export type TlsCertificatesAndHostnamesSchemasCertificate = string;

export type TlsCertificatesAndHostnamesSchemasCertificateObject = {
  certificate?: TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasCertificate;
  expires_on?: TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasExpiresOn;
  id?: TlsCertificatesAndHostnamesIdentifier;
  issuer?: TlsCertificatesAndHostnamesIssuer;
  serial_number?: TlsCertificatesAndHostnamesSerialNumber;
  signature?: TlsCertificatesAndHostnamesSignature;
  status?: TlsCertificatesAndHostnamesHostnameAuthenticatedOriginPullComponentsSchemasStatus;
  uploaded_on?: TlsCertificatesAndHostnamesComponentsSchemasUploadedOn;
};

/**
 * Certificate Authority selected for the order.  For information on any certificate authority specific details or restrictions [see this page for more details.](https://developers.cloudflare.com/ssl/reference/certificate-authorities)
 *
 * @example lets_encrypt
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSchemasCertificateAuthority =
  | "google"
  | "lets_encrypt"
  | "ssl_com";

export type TlsCertificatesAndHostnamesSchemasCertificateResponseCollection =
  TlsCertificatesAndHostnamesApiResponseCollection & {
    result?: TlsCertificatesAndHostnamesCertificates[];
  };

export type TlsCertificatesAndHostnamesSchemasCertificateResponseSingle =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: TlsCertificatesAndHostnamesCertificates;
  };

/**
 * The uploaded root CA certificate.
 * 
 * @example -----BEGIN CERTIFICATE-----
MIIDmDCCAoCgAwIBAgIUKTOAZNjcXVZRj4oQt0SHsl1c1vMwDQYJKoZIhvcNAQELBQAwUTELMAkGA1UEBhMCVVMxFjAUBgNVBAgMDVNhbiBGcmFuY2lzY28xEzARBgNVBAcMCkNhbGlmb3JuaWExFTATBgNVBAoMDEV4YW1wbGUgSW5jLjAgFw0yMjExMjIxNjU5NDdaGA8yMTIyMTAyOTE2NTk0N1owUTELMAkGA1UEBhMCVVMxFjAUBgNVBAgMDVNhbiBGcmFuY2lzY28xEzARBgNVBAcMCkNhbGlmb3JuaWExFTATBgNVBAoMDEV4YW1wbGUgSW5jLjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMRcORwgJFTdcG/2GKI+cFYiOBNDKjCZUXEOvXWY42BkH9wxiMT869CO+enA1w5pIrXow6kCM1sQspHHaVmJUlotEMJxyoLFfA/8Kt1EKFyobOjuZs2SwyVyJ2sStvQuUQEosULZCNGZEqoH5g6zhMPxaxm7ZLrrsDZ9maNGVqo7EWLWHrZ57Q/5MtTrbxQL+eXjUmJ9K3kS+3uEwMdqR6Z3BluU1ivanpPc1CN2GNhdO0/hSY4YkGEnuLsqJyDd3cIiB1MxuCBJ4ZaqOd2viV1WcP3oU3dxVPm4MWyfYIldMWB14FahScxLhWdRnM9YZ/i9IFcLypXsuz7DjrJPtPUCAwEAAaNmMGQwHQYDVR0OBBYEFP5JzLUawNF+c3AXsYTEWHh7z2czMB8GA1UdIwQYMBaAFP5JzLUawNF+c3AXsYTEWHh7z2czMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEBMA0GCSqGSIb3DQEBCwUAA4IBAQBc+Be7NDhpE09y7hLPZGRPl1cSKBw4RI0XIv6rlbSTFs5EebpTGjhx/whNxwEZhB9HZ7111Oa1YlT8xkI9DshB78mjAHCKBAJ76moK8tkG0aqdYpJ4ZcJTVBB7l98Rvgc7zfTii7WemTy72deBbSeiEtXavm4EF0mWjHhQ5Nxpnp00Bqn5g1x8CyTDypgmugnep+xG+iFzNmTdsz7WI9T/7kDMXqB7M/FPWBORyS98OJqNDswCLF8bIZYwUBEe+bRHFomoShMzaC3tvim7WCb16noDkSTMlfKO4pnvKhpcVdSgwcruATV7y+W+Lvmz2OT/Gui4JhqeoTewsxndhDDE
-----END CERTIFICATE-----
 */
export type TlsCertificatesAndHostnamesSchemasCertificates = string;

/**
 * This is the time the fallback origin was created.
 *
 * @example 2019-10-28T18:11:23.37411Z
 * @format date-time
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSchemasCreatedAt = string;

/**
 * The Certificate Signing Request (CSR). Must be newline-encoded.
 *
 * @example -----BEGIN CERTIFICATE REQUEST-----\nMIICY....\n-----END CERTIFICATE REQUEST-----\n
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSchemasCsr = string;

/**
 * Disabling Universal SSL removes any currently active Universal SSL certificates for your zone from the edge and prevents any future Universal SSL certificates from being ordered. If there are no advanced certificates or custom certificates uploaded for the domain, visitors will be unable to access the domain over HTTPS.
 *
 * By disabling Universal SSL, you understand that the following Cloudflare settings and preferences will result in visitors being unable to visit your domain unless you have uploaded a custom certificate or purchased an advanced certificate.
 *
 * * HSTS
 * * Always Use HTTPS
 * * Opportunistic Encryption
 * * Onion Routing
 * * Any Page Rules redirecting traffic to HTTPS
 *
 * Similarly, any HTTP redirect to HTTPS at the origin while the Cloudflare proxy is enabled will result in users being unable to visit your site without a valid certificate at Cloudflare's edge.
 *
 * If you do not have a valid custom or advanced certificate at Cloudflare's edge and are unsure if any of the above Cloudflare settings are enabled, or if any HTTP redirects exist at your origin, we advise leaving Universal SSL enabled for your domain.
 *
 * @example true
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSchemasEnabled = boolean;

/**
 * When the certificate will expire.
 *
 * @example 2014-01-01 05:20:00 +0000 UTC
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSchemasExpiresOn = string;

/**
 * The hostname on the origin for which the client certificate uploaded will be used.
 *
 * @example app.example.com
 * @maxLength 255
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSchemasHostname = string;

export type TlsCertificatesAndHostnamesSchemasHostnames = string[];

/**
 * Comma separated list of valid host names for the certificate packs. Must contain the zone apex, may not contain more than 50 hosts, and may not be empty.
 *
 * @example example.com
 * @example *.example.com
 * @example www.example.com
 */
export type TlsCertificatesAndHostnamesSchemasHosts = string[];

/**
 * Keyless certificate identifier tag.
 *
 * @example 4d2844d2ce78891c34d0b6c0535a291e
 * @maxLength 32
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSchemasIdentifier = string;

/**
 * The certificate authority that issued the certificate.
 *
 * @example O=Example Inc.,L=California,ST=San Francisco,C=US
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSchemasIssuer = string;

/**
 * Optional unique name for the certificate. Only used for human readability.
 *
 * @example example_ca_cert
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSchemasName = string;

/**
 * The hostname certificate's private key.
 * 
 * @example -----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEAwQHoetcl9+5ikGzV6cMzWtWPJHqXT3wpbEkRU9Yz7lgvddmG
dtcGbg/1CGZu0jJGkMoppoUo4c3dts3iwqRYmBikUP77wwY2QGmDZw2FvkJCJlKn
abIRuGvBKwzESIXgKk2016aTP6/dAjEHyo6SeoK8lkIySUvK0fyOVlsiEsCmOpid
tnKX/a+50GjB79CJH4ER2lLVZnhePFR/zUOyPxZQQ4naHf7yu/b5jhO0f8fwt+py
FxIXjbEIdZliWRkRMtzrHOJIhrmJ2A1J7iOrirbbwillwjjNVUWPf3IJ3M12S9pE
ewooaeO2izNTERcG9HzAacbVRn2Y2SWIyT/18QIDAQABAoIBACbhTYXBZYKmYPCb
HBR1IBlCQA2nLGf0qRuJNJZg5iEzXows/6tc8YymZkQE7nolapWsQ+upk2y5Xdp/
axiuprIs9JzkYK8Ox0r+dlwCG1kSW+UAbX0bQ/qUqlsTvU6muVuMP8vZYHxJ3wmb
+ufRBKztPTQ/rYWaYQcgC0RWI20HTFBMxlTAyNxYNWzX7RKFkGVVyB9RsAtmcc8g
+j4OdosbfNoJPS0HeIfNpAznDfHKdxDk2Yc1tV6RHBrC1ynyLE9+TaflIAdo2MVv
KLMLq51GqYKtgJFIlBRPQqKoyXdz3fGvXrTkf/WY9QNq0J1Vk5ERePZ54mN8iZB7
9lwy/AkCgYEA6FXzosxswaJ2wQLeoYc7ceaweX/SwTvxHgXzRyJIIT0eJWgx13Wo
/WA3Iziimsjf6qE+SI/8laxPp2A86VMaIt3Z3mJN/CqSVGw8LK2AQst+OwdPyDMu
iacE8lj/IFGC8mwNUAb9CzGU3JpU4PxxGFjS/eMtGeRXCWkK4NE+G08CgYEA1Kp9
N2JrVlqUz+gAX+LPmE9OEMAS9WQSQsfCHGogIFDGGcNf7+uwBM7GAaSJIP01zcoe
VAgWdzXCv3FLhsaZoJ6RyLOLay5phbu1iaTr4UNYm5WtYTzMzqh8l1+MFFDl9xDB
vULuCIIrglM5MeS/qnSg1uMoH2oVPj9TVst/ir8CgYEAxrI7Ws9Zc4Bt70N1As+U
lySjaEVZCMkqvHJ6TCuVZFfQoE0r0whdLdRLU2PsLFP+q7qaeZQqgBaNSKeVcDYR
9B+nY/jOmQoPewPVsp/vQTCnE/R81spu0mp0YI6cIheT1Z9zAy322svcc43JaWB7
mEbeqyLOP4Z4qSOcmghZBSECgYACvR9Xs0DGn+wCsW4vze/2ei77MD4OQvepPIFX
dFZtlBy5ADcgE9z0cuVB6CiL8DbdK5kwY9pGNr8HUCI03iHkW6Zs+0L0YmihfEVe
PG19PSzK9CaDdhD9KFZSbLyVFmWfxOt50H7YRTTiPMgjyFpfi5j2q348yVT0tEQS
fhRqaQKBgAcWPokmJ7EbYQGeMbS7HC8eWO/RyamlnSffdCdSc7ue3zdVJxpAkQ8W
qu80pEIF6raIQfAf8MXiiZ7auFOSnHQTXUbhCpvDLKi0Mwq3G8Pl07l+2s6dQG6T
lv6XTQaMyf6n1yjzL+fzDrH3qXMxHMO/b13EePXpDMpY7HQpoLDi
-----END RSA PRIVATE KEY-----
 * @x-sensitive true
 */
export type TlsCertificatesAndHostnamesSchemasPrivateKey = string;

/**
 * The certificate serial number.
 *
 * @example 235217144297995885180570755458463043449861756659
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSchemasSerialNumber = string;

/**
 * Certificate's signature algorithm.
 *
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSchemasSignature =
  | "ECDSAWithSHA256"
  | "SHA1WithRSA"
  | "SHA256WithRSA";

/**
 * Status of the Keyless SSL.
 *
 * @example active
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSchemasStatus = "active" | "deleted";

/**
 * The time when the certificate was updated.
 *
 * @example 2100-01-01T05:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSchemasUpdatedAt = string;

/**
 * This is the time the certificate was uploaded.
 *
 * @example 2019-10-28T18:11:23.37411Z
 * @format date-time
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSchemasUploadedOn = string;

/**
 * Validation method in use for a certificate pack order.
 *
 * @example txt
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSchemasValidationMethod =
  | "http"
  | "cname"
  | "txt";

/**
 * The number of days the Client Certificate will be valid after the issued_on date
 *
 * @example 3650
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSchemasValidityDays = number;

/**
 * The serial number on the uploaded certificate.
 *
 * @example 6743787633689793699141714808227354901
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSerialNumber = string;

/**
 * The service using the certificate.
 *
 * @example gateway
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesService = string;

export type TlsCertificatesAndHostnamesSettingObject = {
  created_at?: TlsCertificatesAndHostnamesHostnameTlsSettingsComponentsSchemasCreatedAt;
  hostname?: TlsCertificatesAndHostnamesComponentsSchemasHostname;
  status?: TlsCertificatesAndHostnamesHostnameTlsSettingsComponentsSchemasStatus;
  updated_at?: TlsCertificatesAndHostnamesHostnameTlsSettingsComponentsSchemasUpdatedAt;
  value?: TlsCertificatesAndHostnamesValue;
};

export type TlsCertificatesAndHostnamesSettingObjectDelete = {
  created_at?: TlsCertificatesAndHostnamesHostnameTlsSettingsComponentsSchemasCreatedAt;
  hostname?: TlsCertificatesAndHostnamesComponentsSchemasHostname;
  status?: TlsCertificatesAndHostnamesHostnameTlsSettingsComponentsSchemasStatus;
  updated_at?: TlsCertificatesAndHostnamesHostnameTlsSettingsComponentsSchemasUpdatedAt;
  value?: TlsCertificatesAndHostnamesValue;
};

/**
 * The TLS Setting name.
 *
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSettingId =
  | "ciphers"
  | "min_tls_version"
  | "http2";

/**
 * The type of hash used for the certificate.
 *
 * @example SHA256WithRSA
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSignature = string;

/**
 * Subject Key Identifier
 *
 * @example 8e375af1389a069a0f921f8cc8e1eb12d784b949
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesSki = string;

/**
 * SSL properties for the custom hostname.
 */
export type TlsCertificatesAndHostnamesSsl = {
  /**
   * A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
   *
   * @default ubiquitous
   * @example ubiquitous
   * @x-auditable true
   */
  bundle_method?: "ubiquitous" | "optimal" | "force";
  certificate_authority?: TlsCertificatesAndHostnamesCertificateAuthority;
  /**
   * If a custom uploaded certificate is used.
   *
   * @example -----BEGIN CERTIFICATE-----\nMIIFJDCCBAygAwIBAgIQD0ifmj/Yi5NP/2gdUySbfzANBgkqhkiG9w0BAQsFADBN\nMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMScwJQYDVQQDEx5E...SzSHfXp5lnu/3V08I72q1QNzOCgY1XeL4GKVcj4or6cT6tX6oJH7ePPmfrBfqI/O\nOeH8gMJ+FuwtXYEPa4hBf38M5eU5xWG7\n-----END CERTIFICATE-----\n
   */
  custom_certificate?: string;
  /**
   * The identifier for the Custom CSR that was used.
   *
   * @example 7b163417-1d2b-4c84-a38a-2fb7a0cd7752
   * @x-auditable true
   */
  custom_csr_id?: string;
  /**
     * The key for a custom uploaded certificate.
     *
     * @example -----BEGIN RSA PRIVATE KEY-----
    MIIEowIBAAKCAQEAwQHoetcl9+5ikGzV6cMzWtWPJHqXT3wpbEkRU9Yz7lgvddmG
    dtcGbg/1CGZu0jJGkMoppoUo4c3dts3iwqRYmBikUP77wwY2QGmDZw2FvkJCJlKn
    abIRuGvBKwzESIXgKk2016aTP6/dAjEHyo6SeoK8lkIySUvK0fyOVlsiEsCmOpid
    tnKX/a+50GjB79CJH4ER2lLVZnhePFR/zUOyPxZQQ4naHf7yu/b5jhO0f8fwt+py
    FxIXjbEIdZliWRkRMtzrHOJIhrmJ2A1J7iOrirbbwillwjjNVUWPf3IJ3M12S9pE
    ewooaeO2izNTERcG9HzAacbVRn2Y2SWIyT/18QIDAQABAoIBACbhTYXBZYKmYPCb
    HBR1IBlCQA2nLGf0qRuJNJZg5iEzXows/6tc8YymZkQE7nolapWsQ+upk2y5Xdp/
    axiuprIs9JzkYK8Ox0r+dlwCG1kSW+UAbX0bQ/qUqlsTvU6muVuMP8vZYHxJ3wmb
    +ufRBKztPTQ/rYWaYQcgC0RWI20HTFBMxlTAyNxYNWzX7RKFkGVVyB9RsAtmcc8g
    +j4OdosbfNoJPS0HeIfNpAznDfHKdxDk2Yc1tV6RHBrC1ynyLE9+TaflIAdo2MVv
    KLMLq51GqYKtgJFIlBRPQqKoyXdz3fGvXrTkf/WY9QNq0J1Vk5ERePZ54mN8iZB7
    9lwy/AkCgYEA6FXzosxswaJ2wQLeoYc7ceaweX/SwTvxHgXzRyJIIT0eJWgx13Wo
    /WA3Iziimsjf6qE+SI/8laxPp2A86VMaIt3Z3mJN/CqSVGw8LK2AQst+OwdPyDMu
    iacE8lj/IFGC8mwNUAb9CzGU3JpU4PxxGFjS/eMtGeRXCWkK4NE+G08CgYEA1Kp9
    N2JrVlqUz+gAX+LPmE9OEMAS9WQSQsfCHGogIFDGGcNf7+uwBM7GAaSJIP01zcoe
    VAgWdzXCv3FLhsaZoJ6RyLOLay5phbu1iaTr4UNYm5WtYTzMzqh8l1+MFFDl9xDB
    vULuCIIrglM5MeS/qnSg1uMoH2oVPj9TVst/ir8CgYEAxrI7Ws9Zc4Bt70N1As+U
    lySjaEVZCMkqvHJ6TCuVZFfQoE0r0whdLdRLU2PsLFP+q7qaeZQqgBaNSKeVcDYR
    9B+nY/jOmQoPewPVsp/vQTCnE/R81spu0mp0YI6cIheT1Z9zAy322svcc43JaWB7
    mEbeqyLOP4Z4qSOcmghZBSECgYACvR9Xs0DGn+wCsW4vze/2ei77MD4OQvepPIFX
    dFZtlBy5ADcgE9z0cuVB6CiL8DbdK5kwY9pGNr8HUCI03iHkW6Zs+0L0YmihfEVe
    PG19PSzK9CaDdhD9KFZSbLyVFmWfxOt50H7YRTTiPMgjyFpfi5j2q348yVT0tEQS
    fhRqaQKBgAcWPokmJ7EbYQGeMbS7HC8eWO/RyamlnSffdCdSc7ue3zdVJxpAkQ8W
    qu80pEIF6raIQfAf8MXiiZ7auFOSnHQTXUbhCpvDLKi0Mwq3G8Pl07l+2s6dQG6T
    lv6XTQaMyf6n1yjzL+fzDrH3qXMxHMO/b13EePXpDMpY7HQpoLDi
    -----END RSA PRIVATE KEY-----
     * @x-sensitive true
     */
  custom_key?: string;
  /**
   * The time the custom certificate expires on.
   *
   * @example 2021-02-06T18:11:23.531995Z
   * @format date-time
   * @x-auditable true
   */
  expires_on?: string;
  /**
   * A list of Hostnames on a custom uploaded certificate.
   *
   * @example app.example.com
   * @example *.app.example.com
   */
  hosts?: string[];
  /**
   * Custom hostname SSL identifier tag.
   *
   * @example 0d89c70d-ad9f-4843-b99f-6cc0252067e9
   * @maxLength 36
   * @minLength 36
   * @x-auditable true
   */
  id?: string;
  /**
   * The issuer on a custom uploaded certificate.
   *
   * @example DigiCertInc
   * @x-auditable true
   */
  issuer?: string;
  /**
   * Domain control validation (DCV) method used for this hostname.
   *
   * @example txt
   * @x-auditable true
   */
  method?: "http" | "txt" | "email";
  /**
   * The serial number on a custom uploaded certificate.
   *
   * @example 6743787633689793699141714808227354901
   * @x-auditable true
   */
  serial_number?: string;
  settings?: TlsCertificatesAndHostnamesSslsettings;
  /**
   * The signature on a custom uploaded certificate.
   *
   * @example SHA256WithRSA
   * @x-auditable true
   */
  signature?: string;
  /**
   * Status of the hostname's SSL certificates.
   *
   * @example pending_validation
   * @x-auditable true
   */
  status?:
    | "initializing"
    | "pending_validation"
    | "deleted"
    | "pending_issuance"
    | "pending_deployment"
    | "pending_deletion"
    | "pending_expiration"
    | "expired"
    | "active"
    | "initializing_timed_out"
    | "validation_timed_out"
    | "issuance_timed_out"
    | "deployment_timed_out"
    | "deletion_timed_out"
    | "pending_cleanup"
    | "staging_deployment"
    | "staging_active"
    | "deactivating"
    | "inactive"
    | "backup_issued"
    | "holding_deployment";
  /**
   * Level of validation to be used for this hostname. Domain validation (dv) must be used.
   *
   * @example dv
   * @x-auditable true
   */
  type?: "dv";
  /**
   * The time the custom certificate was uploaded.
   *
   * @example 2020-02-06T18:11:23.531995Z
   * @format date-time
   * @x-auditable true
   */
  uploaded_on?: string;
  /**
   * Domain validation errors that have been received by the certificate authority (CA).
   */
  validation_errors?: {
    /**
     * A domain validation error.
     *
     * @example SERVFAIL looking up CAA for app.example.com
     * @x-auditable true
     */
    message?: string;
  }[];
  validation_records?: TlsCertificatesAndHostnamesValidationRecord[];
  /**
   * Indicates whether the certificate covers a wildcard.
   *
   * @example false
   * @x-auditable true
   */
  wildcard?: boolean;
};

export type TlsCertificatesAndHostnamesSslUniversalSettingsResponse =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: TlsCertificatesAndHostnamesUniversal;
  };

export type TlsCertificatesAndHostnamesSslValidationMethodResponseCollection =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: {
      status?: TlsCertificatesAndHostnamesValidationMethodComponentsSchemasStatus;
      validation_method?: TlsCertificatesAndHostnamesValidationMethodDefinition;
    };
  };

export type TlsCertificatesAndHostnamesSslVerificationResponseCollection = {
  result?: TlsCertificatesAndHostnamesVerification[];
};

/**
 * SSL properties used when creating the custom hostname.
 */
export type TlsCertificatesAndHostnamesSslpost = {
  /**
   * A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
   *
   * @default ubiquitous
   * @example ubiquitous
   * @x-auditable true
   */
  bundle_method?: "ubiquitous" | "optimal" | "force";
  certificate_authority?: TlsCertificatesAndHostnamesCertificateAuthority;
  /**
   * Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
   *
   * @example false
   * @x-auditable true
   */
  cloudflare_branding?: boolean;
  custom_cert_bundle?: TlsCertificatesAndHostnamesCustomCertBundle;
  /**
   * If a custom uploaded certificate is used.
   *
   * @example -----BEGIN CERTIFICATE-----\nMIIFJDCCBAygAwIBAgIQD0ifmj/Yi5NP/2gdUySbfzANBgkqhkiG9w0BAQsFADBN\nMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMScwJQYDVQQDEx5E...SzSHfXp5lnu/3V08I72q1QNzOCgY1XeL4GKVcj4or6cT6tX6oJH7ePPmfrBfqI/O\nOeH8gMJ+FuwtXYEPa4hBf38M5eU5xWG7\n-----END CERTIFICATE-----\n
   * @x-auditable true
   */
  custom_certificate?: string;
  /**
     * The key for a custom uploaded certificate.
     *
     * @example -----BEGIN RSA PRIVATE KEY-----
    MIIEowIBAAKCAQEAwQHoetcl9+5ikGzV6cMzWtWPJHqXT3wpbEkRU9Yz7lgvddmG
    dtcGbg/1CGZu0jJGkMoppoUo4c3dts3iwqRYmBikUP77wwY2QGmDZw2FvkJCJlKn
    abIRuGvBKwzESIXgKk2016aTP6/dAjEHyo6SeoK8lkIySUvK0fyOVlsiEsCmOpid
    tnKX/a+50GjB79CJH4ER2lLVZnhePFR/zUOyPxZQQ4naHf7yu/b5jhO0f8fwt+py
    FxIXjbEIdZliWRkRMtzrHOJIhrmJ2A1J7iOrirbbwillwjjNVUWPf3IJ3M12S9pE
    ewooaeO2izNTERcG9HzAacbVRn2Y2SWIyT/18QIDAQABAoIBACbhTYXBZYKmYPCb
    HBR1IBlCQA2nLGf0qRuJNJZg5iEzXows/6tc8YymZkQE7nolapWsQ+upk2y5Xdp/
    axiuprIs9JzkYK8Ox0r+dlwCG1kSW+UAbX0bQ/qUqlsTvU6muVuMP8vZYHxJ3wmb
    +ufRBKztPTQ/rYWaYQcgC0RWI20HTFBMxlTAyNxYNWzX7RKFkGVVyB9RsAtmcc8g
    +j4OdosbfNoJPS0HeIfNpAznDfHKdxDk2Yc1tV6RHBrC1ynyLE9+TaflIAdo2MVv
    KLMLq51GqYKtgJFIlBRPQqKoyXdz3fGvXrTkf/WY9QNq0J1Vk5ERePZ54mN8iZB7
    9lwy/AkCgYEA6FXzosxswaJ2wQLeoYc7ceaweX/SwTvxHgXzRyJIIT0eJWgx13Wo
    /WA3Iziimsjf6qE+SI/8laxPp2A86VMaIt3Z3mJN/CqSVGw8LK2AQst+OwdPyDMu
    iacE8lj/IFGC8mwNUAb9CzGU3JpU4PxxGFjS/eMtGeRXCWkK4NE+G08CgYEA1Kp9
    N2JrVlqUz+gAX+LPmE9OEMAS9WQSQsfCHGogIFDGGcNf7+uwBM7GAaSJIP01zcoe
    VAgWdzXCv3FLhsaZoJ6RyLOLay5phbu1iaTr4UNYm5WtYTzMzqh8l1+MFFDl9xDB
    vULuCIIrglM5MeS/qnSg1uMoH2oVPj9TVst/ir8CgYEAxrI7Ws9Zc4Bt70N1As+U
    lySjaEVZCMkqvHJ6TCuVZFfQoE0r0whdLdRLU2PsLFP+q7qaeZQqgBaNSKeVcDYR
    9B+nY/jOmQoPewPVsp/vQTCnE/R81spu0mp0YI6cIheT1Z9zAy322svcc43JaWB7
    mEbeqyLOP4Z4qSOcmghZBSECgYACvR9Xs0DGn+wCsW4vze/2ei77MD4OQvepPIFX
    dFZtlBy5ADcgE9z0cuVB6CiL8DbdK5kwY9pGNr8HUCI03iHkW6Zs+0L0YmihfEVe
    PG19PSzK9CaDdhD9KFZSbLyVFmWfxOt50H7YRTTiPMgjyFpfi5j2q348yVT0tEQS
    fhRqaQKBgAcWPokmJ7EbYQGeMbS7HC8eWO/RyamlnSffdCdSc7ue3zdVJxpAkQ8W
    qu80pEIF6raIQfAf8MXiiZ7auFOSnHQTXUbhCpvDLKi0Mwq3G8Pl07l+2s6dQG6T
    lv6XTQaMyf6n1yjzL+fzDrH3qXMxHMO/b13EePXpDMpY7HQpoLDi
    -----END RSA PRIVATE KEY-----
     * @x-sensitive true
     */
  custom_key?: string;
  /**
   * Domain control validation (DCV) method used for this hostname.
   *
   * @example http
   * @x-auditable true
   */
  method?: "http" | "txt" | "email";
  settings?: TlsCertificatesAndHostnamesSslsettings;
  /**
   * Level of validation to be used for this hostname. Domain validation (dv) must be used.
   *
   * @example dv
   * @x-auditable true
   */
  type?: "dv";
  /**
   * Indicates whether the certificate covers a wildcard.
   *
   * @example false
   * @x-auditable true
   */
  wildcard?: boolean;
};

/**
 * SSL specific settings.
 */
export type TlsCertificatesAndHostnamesSslsettings = {
  /**
   * An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
   *
   * @example ECDHE-RSA-AES128-GCM-SHA256
   * @example AES128-SHA
   * @uniqueItems true
   */
  ciphers?: string[];
  /**
   * Whether or not Early Hints is enabled.
   *
   * @example on
   * @x-auditable true
   */
  early_hints?: "on" | "off";
  /**
   * Whether or not HTTP2 is enabled.
   *
   * @example on
   * @x-auditable true
   */
  http2?: "on" | "off";
  /**
   * The minimum TLS version supported.
   *
   * @example 1.2
   * @x-auditable true
   */
  min_tls_version?: "1.0" | "1.1" | "1.2" | "1.3";
  /**
   * Whether or not TLS 1.3 is enabled.
   *
   * @example on
   * @x-auditable true
   */
  tls_1_3?: "on" | "off";
};

/**
 * State, provided by the CSR
 *
 * @example CA
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesState = string;

/**
 * Status of the zone's custom SSL.
 *
 * @example active
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesStatus =
  | "active"
  | "expired"
  | "deleted"
  | "pending"
  | "initializing";

export type TlsCertificatesAndHostnamesTotalTlsSettingsResponse =
  TlsCertificatesAndHostnamesApiResponseSingle & {
    result?: {
      certificate_authority?: TlsCertificatesAndHostnamesComponentsSchemasCertificateAuthority;
      enabled?: TlsCertificatesAndHostnamesComponentsSchemasEnabled;
      validity_period?: TlsCertificatesAndHostnamesValidityPeriod;
    };
  };

/**
 * The type 'legacy_custom' enables support for legacy clients which do not include SNI in the TLS handshake.
 *
 * @default legacy_custom
 * @example sni_custom
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesType = "legacy_custom" | "sni_custom";

export type TlsCertificatesAndHostnamesUniversal = {
  enabled?: TlsCertificatesAndHostnamesSchemasEnabled;
};

/**
 * This is the time the fallback origin was updated.
 *
 * @example 2020-03-16T18:11:23.531995Z
 * @format date-time
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesUpdatedAt = string;

/**
 * When the certificate was uploaded to Cloudflare.
 *
 * @example 2014-01-01T05:20:00Z
 * @format date-time
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesUploadedOn = string;

/**
 * The DCV Delegation unique identifier.
 *
 * @example abc123def456ghi7
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesUuid = string;

export type TlsCertificatesAndHostnamesUuidObject = {
  uuid?: TlsCertificatesAndHostnamesUuid;
};

/**
 * Validation Method selected for the order.
 *
 * @example txt
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesValidationMethod =
  | "txt"
  | "http"
  | "email";

/**
 * Result status.
 *
 * @example pending_validation
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesValidationMethodComponentsSchemasStatus =
  string;

/**
 * Desired validation method.
 *
 * @example txt
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesValidationMethodDefinition =
  | "http"
  | "cname"
  | "txt"
  | "email";

/**
 * Certificate's required validation record.
 */
export type TlsCertificatesAndHostnamesValidationRecord = {
  /**
   * The set of email addresses that the certificate authority (CA) will use to complete domain validation.
   *
   * @example administrator@example.com
   * @example webmaster@example.com
   */
  emails?: string[];
  /**
   * The content that the certificate authority (CA) will expect to find at the http_url during the domain validation.
   *
   * @example ca3-574923932a82475cb8592200f1a2a23d
   */
  http_body?: string;
  /**
   * The url that will be checked during domain validation.
   *
   * @example http://app.example.com/.well-known/pki-validation/ca3-da12a1c25e7b48cf80408c6c1763b8a2.txt
   */
  http_url?: string;
  /**
   * The hostname that the certificate authority (CA) will check for a TXT record during domain validation .
   *
   * @example _acme-challenge.app.example.com
   * @x-auditable true
   */
  txt_name?: string;
  /**
   * The TXT record that the certificate authority (CA) will check during domain validation.
   *
   * @example 810b7d5f01154524b961ba0cd578acc2
   */
  txt_value?: string;
};

/**
 * Validity Days selected for the order.
 *
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesValidityDays = 14 | 30 | 90 | 365;

/**
 * The validity period in days for the certificates ordered via Total TLS.
 *
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesValidityPeriod = 90;

/**
 * The tls setting value.
 *
 * @example ECDHE-RSA-AES128-GCM-SHA256
 * @example AES128-GCM-SHA256
 */
export type TlsCertificatesAndHostnamesValue = number | string | string[];

export type TlsCertificatesAndHostnamesVerification = {
  brand_check?: TlsCertificatesAndHostnamesBrandCheck;
  cert_pack_uuid?: TlsCertificatesAndHostnamesCertPackUuid;
  certificate_status: TlsCertificatesAndHostnamesCertificateStatus;
  signature?: TlsCertificatesAndHostnamesSchemasSignature;
  validation_method?: TlsCertificatesAndHostnamesSchemasValidationMethod;
  verification_info?: TlsCertificatesAndHostnamesVerificationInfo;
  verification_status?: TlsCertificatesAndHostnamesVerificationStatus;
  verification_type?: TlsCertificatesAndHostnamesVerificationType;
};

/**
 * These are errors that were encountered while trying to activate a hostname.
 *
 * @example None of the A or AAAA records are owned by this account and the pre-generated ownership verification token was not found.
 */
export type TlsCertificatesAndHostnamesVerificationErrors = string[];

/**
 * Certificate's required verification information.
 */
export type TlsCertificatesAndHostnamesVerificationInfo = {
  /**
   * Name of CNAME record.
   *
   * @example b3b90cfedd89a3e487d3e383c56c4267.example.com
   * @format hostname
   * @x-auditable true
   */
  record_name?: "record_name" | "http_url" | "cname" | "txt_name";
  /**
   * Target of CNAME record.
   *
   * @example 6979be7e4cfc9e5c603e31df7efac9cc60fee82d.comodoca.com
   * @format hostname
   * @x-auditable true
   */
  record_target?: "record_value" | "http_body" | "cname_target" | "txt_value";
};

/**
 * Status of the required verification information, omitted if verification status is unknown.
 *
 * @example true
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesVerificationStatus = boolean;

/**
 * Method of verification.
 *
 * @example cname
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesVerificationType = "cname" | "meta tag";

export type TlsCertificatesAndHostnamesZoneAuthenticatedOriginPull = {
  certificate?: TlsCertificatesAndHostnamesZoneAuthenticatedOriginPullComponentsSchemasCertificate;
  expires_on?: TlsCertificatesAndHostnamesComponentsSchemasExpiresOn;
  id?: TlsCertificatesAndHostnamesIdentifier;
  issuer?: TlsCertificatesAndHostnamesIssuer;
  signature?: TlsCertificatesAndHostnamesSignature;
  status?: TlsCertificatesAndHostnamesZoneAuthenticatedOriginPullComponentsSchemasStatus;
  uploaded_on?: TlsCertificatesAndHostnamesSchemasUploadedOn;
  enabled?: TlsCertificatesAndHostnamesZoneAuthenticatedOriginPullComponentsSchemasEnabled;
  private_key?: TlsCertificatesAndHostnamesPrivateKey;
};

/**
 * The zone's leaf certificate.
 * 
 * @example -----BEGIN CERTIFICATE-----
MIIDtTCCAp2gAwIBAgIJAMHAwfXZ5/PWMA0GCSqGSIb3DQEBCwUAMEUxCzAJBgNV
BAYTAkFVMRMwEQYDVQQIEwpTb21lLVN0YXRlMSEwHwYDVQQKExhJbnRlcm5ldCBX
aWRnaXRzIFB0eSBMdGQwHhcNMTYwODI0MTY0MzAxWhcNMTYxMTIyMTY0MzAxWjBF
MQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50
ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB
CgKCAQEAwQHoetcl9+5ikGzV6cMzWtWPJHqXT3wpbEkRU9Yz7lgvddmGdtcGbg/1
CGZu0jJGkMoppoUo4c3dts3iwqRYmBikUP77wwY2QGmDZw2FvkJCJlKnabIRuGvB
KwzESIXgKk2016aTP6/dAjEHyo6SeoK8lkIySUvK0fyOVlsiEsCmOpidtnKX/a+5
0GjB79CJH4ER2lLVZnhePFR/zUOyPxZQQ4naHf7yu/b5jhO0f8fwt+pyFxIXjbEI
dZliWRkRMtzrHOJIhrmJ2A1J7iOrirbbwillwjjNVUWPf3IJ3M12S9pEewooaeO2
izNTERcG9HzAacbVRn2Y2SWIyT/18QIDAQABo4GnMIGkMB0GA1UdDgQWBBT/LbE4
9rWf288N6sJA5BRb6FJIGDB1BgNVHSMEbjBsgBT/LbE49rWf288N6sJA5BRb6FJI
GKFJpEcwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgTClNvbWUtU3RhdGUxITAfBgNV
BAoTGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZIIJAMHAwfXZ5/PWMAwGA1UdEwQF
MAMBAf8wDQYJKoZIhvcNAQELBQADggEBAHHFwl0tH0quUYZYO0dZYt4R7SJ0pCm2
2satiyzHl4OnXcHDpekAo7/a09c6Lz6AU83cKy/+x3/djYHXWba7HpEu0dR3ugQP
Mlr4zrhd9xKZ0KZKiYmtJH+ak4OM4L3FbT0owUZPyjLSlhMtJVcoRp5CJsjAMBUG
SvD8RX+T01wzox/Qb+lnnNnOlaWpqu8eoOenybxKp1a9ULzIVvN/LAcc+14vioFq
2swRWtmocBAs8QR9n4uvbpiYvS8eYueDCWMM4fvFfBhaDZ3N9IbtySh3SpFdQDhw
YbjM2rxXiyLGxB4Bol7QTv4zHif7Zt89FReT/NBy4rzaskDJY5L6xmY=
-----END CERTIFICATE-----
 */
export type TlsCertificatesAndHostnamesZoneAuthenticatedOriginPullComponentsSchemasCertificate =
  string;

/**
 * Indicates whether zone-level authenticated origin pulls is enabled.
 *
 * @example true
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesZoneAuthenticatedOriginPullComponentsSchemasEnabled =
  boolean;

/**
 * Status of the certificate activation.
 *
 * @example active
 * @x-auditable true
 */
export type TlsCertificatesAndHostnamesZoneAuthenticatedOriginPullComponentsSchemasStatus =

    | "initializing"
    | "pending_deployment"
    | "pending_deletion"
    | "active"
    | "deleted"
    | "deployment_timed_out"
    | "deletion_timed_out";

/**
 * Cloudflare account ID
 *
 * @example 699d98642c564d2e855e9661899b7252
 * @maxLength 32
 * @x-auditable true
 */
export type TunnelAccountId = string;

/**
 * IP address family, either `v4` (IPv4) or `v6` (IPv6)
 *
 * @example v4
 */
export type TunnelAddressFamily = "v4" | "v6";

export type TunnelApiResponseCollection = {
  errors: TunnelMessages;
  messages: TunnelMessages;
  result: Record<string, any> | any[] | string | null;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
  result_info?: TunnelResultInfo;
};

export type TunnelApiResponseCommon = {
  errors: TunnelMessages;
  messages: TunnelMessages;
  result: Record<string, any> | any[] | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type TunnelApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: TunnelMessages;
  messages: TunnelMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

export type TunnelApiResponseSingle = TunnelApiResponseCommon;

/**
 * The cloudflared OS architecture used to establish this connection.
 *
 * @example linux_amd64
 */
export type TunnelArch = string;

export type TunnelArgoTunnel = {
  /**
   * The tunnel connections between your origin and Cloudflare's edge.
   */
  connections: TunnelConnection[];
  created_at: TunnelCreatedAt;
  deleted_at?: TunnelDeletedAt;
  id: TunnelTunnelId;
  name: TunnelTunnelName;
};

/**
 * A Cloudflare Tunnel that connects your origin to Cloudflare's edge.
 */
export type TunnelCfdTunnel = {
  account_tag?: TunnelAccountId;
  connections?: TunnelConnectionsDeprecated;
  conns_active_at?: TunnelConnsActiveAt;
  conns_inactive_at?: TunnelConnsInactiveAt;
  created_at?: TunnelCreatedAt;
  deleted_at?: TunnelDeletedAt;
  id?: TunnelTunnelId;
  metadata?: TunnelMetadata;
  name?: TunnelTunnelName;
  remote_config?: TunnelRemoteConfig;
  status?: TunnelStatus;
  tun_type?: TunnelTunnelType;
};

/**
 * UUID of the Cloudflare Tunnel connector.
 *
 * @example 1bedc50d-42b3-473c-b108-ff3d10c0d925
 * @format uuid
 * @maxLength 36
 * @x-auditable true
 */
export type TunnelClientId = string;

/**
 * The Cloudflare data center used for this connection.
 *
 * @example DFW
 */
export type TunnelColoName = string;

/**
 * The tunnel configuration and ingress rules.
 */
export type TunnelConfig = {
  /**
   * List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel.
   *
   * @minItems 1
   */
  ingress?: TunnelIngressRule[];
  originRequest?: TunnelOriginRequest;
  /**
   * Enable private network access from WARP users to private network routes. This is enabled if the tunnel has an assigned route.
   */
  ["warp-routing"]?: {
    enabled?: boolean;
  };
};

/**
 * Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel on the Zero Trust dashboard.
 *
 * @default local
 * @example cloudflare
 */
export type TunnelConfigSrc = "local" | "cloudflare";

/**
 * The version of the remote tunnel configuration. Used internally to sync cloudflared with the Zero Trust dashboard.
 */
export type TunnelConfigVersion = number;

/**
 * Cloudflare Tunnel configuration
 */
export type TunnelConfiguration = {
  account_id?: TunnelIdentifier;
  config?: TunnelConfig;
  created_at?: TunnelTimestamp;
  source?: TunnelSchemasConfigSrc;
  tunnel_id?: TunnelSchemasTunnelId;
  version?: TunnelSchemasConfigVersion;
};

export type TunnelConfigurationResponse = TunnelSchemasApiResponseSingle & {
  result?: TunnelConfiguration;
};

export type TunnelConnection = {
  colo_name?: TunnelColoName;
  is_pending_reconnect?: TunnelIsPendingReconnect;
  uuid?: TunnelConnectionId;
};

/**
 * UUID of the Cloudflare Tunnel connection.
 *
 * @example 1bedc50d-42b3-473c-b108-ff3d10c0d925
 * @format uuid
 * @maxLength 36
 * @x-auditable true
 */
export type TunnelConnectionId = string;

/**
 * The Cloudflare Tunnel connections between your origin and Cloudflare's edge.
 */
export type TunnelConnections = TunnelSchemasConnection[];

/**
 * The Cloudflare Tunnel connections between your origin and Cloudflare's edge.
 *
 * @deprecated true
 * @x-stainless-deprecation-message This field will start returning an empty array. To fetch the connections of a given tunnel, please use the dedicated endpoint `/accounts/{account_id}/{tunnel_type}/{tunnel_id}/connections`
 */
export type TunnelConnectionsDeprecated = TunnelSchemasConnection[];

/**
 * Timestamp of when the tunnel established at least one connection to Cloudflare's edge. If `null`, the tunnel is inactive.
 *
 * @example 2009-11-10T23:00:00Z
 * @format date-time
 */
export type TunnelConnsActiveAt = string;

/**
 * Timestamp of when the tunnel became inactive (no connections to Cloudflare's edge). If `null`, the tunnel is active.
 *
 * @example 2009-11-10T23:00:00Z
 * @format date-time
 */
export type TunnelConnsInactiveAt = string;

/**
 * Timestamp of when the resource was created.
 *
 * @example 2021-01-25T18:22:34.317854Z
 * @format date-time
 */
export type TunnelCreatedAt = string;

/**
 * Timestamp of when the resource was deleted. If `null`, the resource has not been deleted.
 *
 * @example 2009-11-10T23:00:00.000000Z
 * @format date-time
 */
export type TunnelDeletedAt = string;

export type TunnelEmptyResponse = {
  errors: TunnelMessages;
  messages: TunnelMessages;
  result: any | any | any | null;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

/**
 * If provided, include only resources that were created (and not deleted) before this time. URL encoded.
 *
 * @example 2019-10-12T07%3A20%3A50.52Z
 * @format url-encoded-date-time
 */
export type TunnelExistedAt = string;

/**
 * Features enabled for the Cloudflare Tunnel.
 */
export type TunnelFeatures = string[];

/**
 * A flag to enable the ICMP proxy for the account network.
 *
 * @example true
 * @x-auditable true
 */
export type TunnelIcmpProxyEnabled = boolean;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type TunnelIdentifier = string;

/**
 * Public hostname
 */
export type TunnelIngressRule = {
  /**
   * Public hostname for this service.
   *
   * @example tunnel.example.com
   */
  hostname: string;
  originRequest?: TunnelOriginRequest;
  /**
   * Requests with this path route to this public hostname.
   *
   * @example subpath
   */
  path?: string;
  /**
   * Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http_status:[code] e.g. 'http_status:404'.
   *
   * @example https://localhost:8001
   */
  service: string;
};

/**
 * @example 10.1.0.137
 */
export type TunnelIp = string;

/**
 * The private IPv4 or IPv6 range connected by the route, in CIDR notation.
 *
 * @example 172.16.0.0/16
 * @x-auditable true
 */
export type TunnelIpNetwork = string;

/**
 * IP/CIDR range in URL-encoded format
 *
 * @example 172.16.0.0%2F16
 */
export type TunnelIpNetworkEncoded = string;

/**
 * If `true`, this virtual network is the default for the account.
 *
 * @example true
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type TunnelIsDefaultNetwork = boolean;

/**
 * If `true`, this virtual network is the default for the account.
 *
 * @default false
 * @example false
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type TunnelIsDefaultNetworkOptional = boolean;

/**
 * Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If `true`, the connection has disconnected but is still being tracked. If `false`, the connection is actively serving traffic.
 *
 * @example false
 */
export type TunnelIsPendingReconnect = boolean;

export type TunnelLegacyTunnelResponseCollection =
  TunnelApiResponseCollection & {
    result?: TunnelArgoTunnel[];
  };

export type TunnelLegacyTunnelResponseSingle = {
  errors: TunnelMessages;
  messages: TunnelMessages;
  result: TunnelArgoTunnel;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

/**
 * Management resources the token will have access to.
 *
 * @example logs
 */
export type TunnelManagementResources = "logs";

export type TunnelMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * Metadata associated with the tunnel.
 *
 * @example {}
 */
export type TunnelMetadata = Record<string, any>;

/**
 * A flag to enable WARP to WARP traffic.
 *
 * @example true
 * @x-auditable true
 */
export type TunnelOfframpWarpEnabled = boolean;

/**
 * Configuration parameters for the public hostname specific connection settings between cloudflared and origin server.
 */
export type TunnelOriginRequest = {
  /**
   * For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header.
   */
  access?: {
    /**
     * Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
     */
    audTag: string[];
    /**
     * Deny traffic that has not fulfilled Access authorization.
     *
     * @example false
     */
    required?: boolean;
    /**
     * @example zero-trust-organization-name
     */
    teamName: string;
  };
  /**
   * Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
   */
  caPool?: string;
  /**
   * Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
   *
   * @example 10
   */
  connectTimeout?: number;
  /**
   * Disables chunked transfer encoding. Useful if you are running a WSGI server.
   */
  disableChunkedEncoding?: boolean;
  /**
   * Attempt to connect to origin using HTTP2. Origin must be configured as https.
   */
  http2Origin?: boolean;
  /**
   * Sets the HTTP Host header on requests sent to the local service.
   */
  httpHostHeader?: string;
  /**
   * Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
   *
   * @example 100
   */
  keepAliveConnections?: number;
  /**
   * Timeout after which an idle keepalive connection can be discarded.
   *
   * @example 90
   */
  keepAliveTimeout?: number;
  /**
   * Disable the “happy eyeballs” algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
   *
   * @example false
   */
  noHappyEyeballs?: boolean;
  /**
   * Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
   *
   * @example false
   */
  noTLSVerify?: boolean;
  /**
   * Hostname that cloudflared should expect from your origin server certificate.
   */
  originServerName?: string;
  /**
   * cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.
   */
  proxyType?: string;
  /**
   * The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
   *
   * @example 30
   */
  tcpKeepAlive?: number;
  /**
   * Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
   *
   * @example 10
   */
  tlsTimeout?: number;
};

/**
 * Page number of paginated results.
 *
 * @default 1
 * @minimum 1
 */
export type TunnelPageNumber = number;

/**
 * Number of results to display.
 *
 * @maximum 1000
 * @minimum 1
 */
export type TunnelPerPage = number;

/**
 * If `true`, the tunnel can be configured remotely from the Zero Trust dashboard. If `false`, the tunnel must be configured locally on the origin machine.
 *
 * @example true
 * @x-auditable true
 */
export type TunnelRemoteConfig = boolean;

export type TunnelResultInfo = {
  /**
   * Total number of results for the requested service
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters
   *
   * @example 2000
   */
  total_count?: number;
};

export type TunnelRoute = {
  comment?: TunnelRouteComment;
  created_at?: TunnelCreatedAt;
  deleted_at?: TunnelDeletedAt;
  id?: TunnelRouteId;
  network?: TunnelIpNetwork;
  tunnel_id?: TunnelTunnelId;
  virtual_network_id?: TunnelVirtualNetworkId;
};

/**
 * Optional remark describing the route.
 *
 * @example Example comment for this route.
 * @maxLength 100
 * @x-auditable true
 */
export type TunnelRouteComment = string;

/**
 * UUID of the route.
 *
 * @example f70ff985-a4ef-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 */
export type TunnelRouteId = string;

export type TunnelRouteResponseSingle = {
  errors: TunnelMessages;
  messages: TunnelMessages;
  result: TunnelRoute;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

/**
 * Timestamp of when the tunnel connection was started.
 *
 * @example 2009-11-10T23:00:00Z
 * @format date-time
 */
export type TunnelRunAt = string;

export type TunnelSchemasApiResponseCommon = {
  errors: TunnelSchemasMessages;
  messages: TunnelSchemasMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type TunnelSchemasApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: TunnelSchemasMessages;
  messages: TunnelSchemasMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type TunnelSchemasApiResponseSingle = TunnelSchemasApiResponseCommon;

/**
 * Indicates if this is a locally or remotely configured tunnel. If `local`, manage the tunnel using a YAML file on the origin machine. If `cloudflare`, manage the tunnel's configuration on the Zero Trust dashboard.
 *
 * @example cloudflare
 * @x-stainless-terraform-configurability computed_optional
 */
export type TunnelSchemasConfigSrc = "local" | "cloudflare";

/**
 * The version of the Tunnel Configuration.
 */
export type TunnelSchemasConfigVersion = number;

export type TunnelSchemasConnection = {
  client_id?: TunnelClientId;
  client_version?: TunnelVersion;
  colo_name?: TunnelColoName;
  id?: TunnelConnectionId;
  is_pending_reconnect?: TunnelIsPendingReconnect;
  /**
   * Timestamp of when the connection was established.
   *
   * @example 2021-01-25T18:22:34.317854Z
   * @format date-time
   */
  opened_at?: string;
  /**
   * The public IP address of the host running cloudflared.
   *
   * @example 10.1.0.137
   */
  origin_ip?: TunnelIp;
  uuid?: TunnelConnectionId;
};

export type TunnelSchemasMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * UUID of the tunnel.
 *
 * @example f70ff985-a4ef-4643-bbbc-4a0ed4fc8415
 * @format uuid
 * @maxLength 36
 */
export type TunnelSchemasTunnelId = string;

/**
 * The status of the tunnel. Valid values are `inactive` (tunnel has never been run), `degraded` (tunnel is active and able to serve traffic but in an unhealthy state), `healthy` (tunnel is active and able to serve traffic), or `down` (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
 *
 * @example healthy
 */
export type TunnelStatus = "inactive" | "degraded" | "healthy" | "down";

export type TunnelSubnet = {
  comment?: TunnelSubnetComment;
  created_at?: TunnelCreatedAt;
  deleted_at?: TunnelDeletedAt;
  id?: TunnelSubnetId;
  is_default_network?: TunnelSubnetIsDefaultNetwork;
  name?: TunnelSubnetName;
  network?: TunnelSubnetIpNetwork;
  subnet_type?: TunnelSubnetType;
};

/**
 * An optional description of the subnet.
 *
 * @example example comment
 * @x-auditable true
 */
export type TunnelSubnetComment = string;

/**
 * The UUID of the subnet.
 *
 * @example f70ff985-a4ef-4643-bbbc-4a0ed4fc8415
 * @format uuid
 * @x-auditable true
 */
export type TunnelSubnetId = string;

/**
 * The private IPv4 or IPv6 range defining the subnet, in CIDR notation.
 *
 * @example 100.64.0.0/12
 * @x-auditable true
 */
export type TunnelSubnetIpNetwork = string;

/**
 * If `true`, this is the default subnet for the account. There can only be one default subnet per account.
 *
 * @x-auditable true
 */
export type TunnelSubnetIsDefaultNetwork = boolean;

/**
 * A user-friendly name for the subnet.
 *
 * @example IPv4 Cloudflare Source IPs
 * @x-auditable true
 */
export type TunnelSubnetName = string;

/**
 * If set, only list subnets with the given comment.
 *
 * @example example%20comment
 */
export type TunnelSubnetQueryComment = string;

/**
 * If set, only list subnets with the given name
 *
 * @example IPv4%20Cloudflare%20Source%20IPs
 */
export type TunnelSubnetQueryName = string;

export type TunnelSubnetResponseCollection = TunnelApiResponseCollection & {
  result?: TunnelSubnet[];
};

export type TunnelSubnetResponseSingle = {
  errors: TunnelMessages;
  messages: TunnelMessages;
  result: TunnelSubnet;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

/**
 * The type of subnet.
 *
 * @example cloudflare_source
 * @x-auditable true
 */
export type TunnelSubnetType = "cloudflare_source";

export type TunnelTeamnet = {
  comment?: TunnelRouteComment;
  created_at?: TunnelCreatedAt;
  deleted_at?: TunnelDeletedAt;
  id?: TunnelRouteId;
  network?: TunnelIpNetwork;
  tun_type?: TunnelTunnelType;
  tunnel_id?: TunnelTunnelId;
  tunnel_name?: TunnelTunnelName;
  virtual_network_id?: TunnelVirtualNetworkIdComputedOptional;
  virtual_network_name?: TunnelVirtualNetworkName;
};

export type TunnelTeamnetResponseCollection = TunnelApiResponseCollection & {
  result?: TunnelTeamnet[];
};

export type TunnelTeamnetResponseSingle = {
  errors: TunnelMessages;
  messages: TunnelMessages;
  result: TunnelTeamnet;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

/**
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type TunnelTimestamp = string;

export type TunnelTunnelResponseCollection = TunnelApiResponseCollection & {
  result?: (TunnelCfdTunnel | TunnelWarpConnectorTunnel)[];
};

export type TunnelTunnelResponseSingle = {
  errors: TunnelMessages;
  messages: TunnelMessages;
  result: TunnelCfdTunnel | TunnelWarpConnectorTunnel | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

/**
 * A client (typically cloudflared) that maintains connections to a Cloudflare data center.
 */
export type TunnelTunnelClient = {
  arch?: TunnelArch;
  config_version?: TunnelConfigVersion;
  conns?: TunnelConnections;
  features?: TunnelFeatures;
  id?: TunnelConnectionId;
  run_at?: TunnelRunAt;
  version?: TunnelVersion;
};

export type TunnelTunnelClientResponse = {
  errors: TunnelMessages;
  messages: TunnelMessages;
  result: TunnelTunnelClient;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type TunnelTunnelConnectionsResponse = TunnelApiResponseCollection & {
  result?: TunnelTunnelClient[];
};

/**
 * UUID of the tunnel.
 *
 * @example f70ff985-a4ef-4643-bbbc-4a0ed4fc8415
 * @format uuid
 * @maxLength 36
 * @x-auditable true
 */
export type TunnelTunnelId = string;

/**
 * The id of the tunnel linked and the date that link was created.
 */
export type TunnelTunnelLink = {
  created_at?: TunnelCreatedAt;
  linked_tunnel_id?: TunnelTunnelId;
};

export type TunnelTunnelLinksResponse = TunnelApiResponseCollection & {
  result?: TunnelTunnelLink[];
};

/**
 * A user-friendly name for a tunnel.
 *
 * @example blog
 */
export type TunnelTunnelName = string;

export type TunnelTunnelResponseToken = {
  errors: TunnelMessages;
  messages: TunnelMessages;
  result: TunnelTunnelToken;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

/**
 * Sets the password required to run a locally-managed tunnel. Must be at least 32 bytes and encoded as a base64 string.
 *
 * @example AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg=
 * @x-sensitive true
 */
export type TunnelTunnelSecret = string;

/**
 * The Tunnel Token is used as a mechanism to authenticate the operation of a tunnel.
 *
 * @example eyJhIjoiNWFiNGU5Z...
 * @x-sensitive true
 */
export type TunnelTunnelToken = string;

/**
 * The type of tunnel.
 *
 * @example cfd_tunnel
 * @x-auditable true
 */
export type TunnelTunnelType =
  | "cfd_tunnel"
  | "warp_connector"
  | "warp"
  | "magic"
  | "ip_sec"
  | "gre"
  | "cni";

/**
 * The types of tunnels to filter by, separated by commas.
 *
 * @example cfd_tunnel,warp_connector
 */
export type TunnelTunnelTypes = TunnelTunnelType[];

/**
 * The cloudflared version used to establish this connection.
 *
 * @example 2022.7.1
 */
export type TunnelVersion = string;

export type TunnelVirtualNetwork = {
  comment: TunnelVirtualNetworkComment;
  created_at: TunnelCreatedAt;
  deleted_at?: TunnelDeletedAt;
  id: TunnelVirtualNetworkId;
  is_default_network: TunnelIsDefaultNetwork;
  name: TunnelVirtualNetworkName;
};

/**
 * Optional remark describing the virtual network.
 *
 * @example Staging VPC for data science
 * @maxLength 256
 * @x-auditable true
 */
export type TunnelVirtualNetworkComment = string;

/**
 * UUID of the virtual network.
 *
 * @example f70ff985-a4ef-4643-bbbc-4a0ed4fc8415
 * @format uuid
 * @x-auditable true
 */
export type TunnelVirtualNetworkId = string;

/**
 * UUID of the virtual network.
 *
 * @example f70ff985-a4ef-4643-bbbc-4a0ed4fc8415
 * @format uuid
 * @x-auditable true
 * @x-stainless-terraform-configurability computed_optional
 */
export type TunnelVirtualNetworkIdComputedOptional = string;

/**
 * A user-friendly name for the virtual network.
 *
 * @example us-east-1-vpc
 * @maxLength 256
 * @x-auditable true
 */
export type TunnelVirtualNetworkName = string;

export type TunnelVnetResponseCollection = TunnelApiResponseCollection & {
  result?: TunnelVirtualNetwork[];
};

export type TunnelVnetResponseSingle = {
  errors: TunnelMessages;
  messages: TunnelMessages;
  result: TunnelVirtualNetwork;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

/**
 * A Warp Connector Tunnel that connects your origin to Cloudflare's edge.
 */
export type TunnelWarpConnectorTunnel = {
  account_tag?: TunnelAccountId;
  connections?: TunnelConnectionsDeprecated;
  conns_active_at?: TunnelConnsActiveAt;
  conns_inactive_at?: TunnelConnsInactiveAt;
  created_at?: TunnelCreatedAt;
  deleted_at?: TunnelDeletedAt;
  id?: TunnelTunnelId;
  metadata?: TunnelMetadata;
  name?: TunnelTunnelName;
  status?: TunnelStatus;
  tun_type?: TunnelTunnelType;
};

export type TunnelZeroTrustConnectivitySettingsResponse = {
  errors: TunnelMessages;
  messages: TunnelMessages;
  result:
    | {
        icmp_proxy_enabled?: TunnelIcmpProxyEnabled;
        offramp_warp_enabled?: TunnelOfframpWarpEnabled;
      }
    | any[]
    | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type TurnstileApiResponseCommon = {
  errors: TurnstileMessages;
  messages: TurnstileMessages;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: boolean;
};

export type TurnstileApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: TurnstileMessages;
  messages: TurnstileMessages;
  result: Record<string, any> | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: boolean;
};

/**
 * If bot_fight_mode is set to `true`, Cloudflare issues computationally
 * expensive challenges in response to malicious bots (ENT only).
 *
 * @example false
 * @x-auditable true
 */
export type TurnstileBotFightMode = boolean;

/**
 * If Turnstile is embedded on a Cloudflare site and the widget should grant challenge clearance,
 * this setting can determine the clearance level to be set
 *
 * @example interactive
 * @x-auditable true
 */
export type TurnstileClearanceLevel =
  | "no_clearance"
  | "jschallenge"
  | "managed"
  | "interactive";

/**
 * When the widget was created.
 *
 * @example 2014-01-01T05:20:00.123123Z
 * @format date-time
 */
export type TurnstileCreatedOn = string;

/**
 * @example 203.0.113.1
 * @example cloudflare.com
 * @example blog.example.com
 * @maxLength 10
 */
export type TurnstileDomains = string[];

/**
 * Return the Ephemeral ID in /siteverify (ENT only).
 *
 * @example false
 * @x-auditable true
 */
export type TurnstileEphemeralId = boolean;

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type TurnstileIdentifier = string;

/**
 * If `invalidate_immediately` is set to `false`, the previous secret will
 * remain valid for two hours. Otherwise, the secret is immediately
 * invalidated, and requests using it will be rejected.
 *
 * @default false
 * @x-auditable true
 */
export type TurnstileInvalidateImmediately = boolean;

export type TurnstileMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * When the widget was modified.
 *
 * @example 2014-01-01T05:20:00.123123Z
 * @format date-time
 */
export type TurnstileModifiedOn = string;

/**
 * Human readable widget name. Not unique. Cloudflare suggests that you
 * set this to a meaningful string to make it easier to identify your
 * widget, and where it is used.
 *
 * @example blog.cloudflare.com login form
 * @maxLength 254
 * @minLength 1
 * @x-auditable true
 */
export type TurnstileName = string;

/**
 * Do not show any Cloudflare branding on the widget (ENT only).
 *
 * @example false
 * @x-auditable true
 */
export type TurnstileOfflabel = boolean;

/**
 * Region where this widget can be used. This cannot be changed after creation.
 *
 * @default world
 * @x-auditable true
 */
export type TurnstileRegion = "world" | "china";

export type TurnstileResultInfo = {
  /**
   * Total number of results for the requested service
   *
   * @example 1
   */
  count: number;
  /**
   * Current page within paginated list of results
   *
   * @example 1
   */
  page: number;
  /**
   * Number of results per page of results
   *
   * @example 20
   */
  per_page: number;
  /**
   * Total results available without any search parameters
   *
   * @example 2000
   */
  total_count: number;
};

/**
 * Secret key for this widget.
 *
 * @example 0x4AAF00AAAABn0R22HWm098HVBjhdsYUc
 * @x-sensitive true
 */
export type TurnstileSecret = string;

/**
 * Widget item identifier tag.
 *
 * @example 0x4AAF00AAAABn0R22HWm-YUc
 * @maxLength 32
 * @x-auditable true
 */
export type TurnstileSitekey = string;

/**
 * A Turnstile widget's detailed configuration
 */
export type TurnstileWidgetDetail = {
  bot_fight_mode: TurnstileBotFightMode;
  clearance_level: TurnstileClearanceLevel;
  created_on: TurnstileCreatedOn;
  domains: TurnstileDomains;
  ephemeral_id: TurnstileEphemeralId;
  mode: TurnstileWidgetMode;
  modified_on: TurnstileModifiedOn;
  name: TurnstileName;
  offlabel: TurnstileOfflabel;
  region: TurnstileRegion;
  secret: TurnstileSecret;
  sitekey: TurnstileSitekey;
};

/**
 * A Turnstile Widgets configuration as it appears in listings
 */
export type TurnstileWidgetList = {
  bot_fight_mode: TurnstileBotFightMode;
  clearance_level: TurnstileClearanceLevel;
  created_on: TurnstileCreatedOn;
  domains: TurnstileDomains;
  ephemeral_id: TurnstileEphemeralId;
  mode: TurnstileWidgetMode;
  modified_on: TurnstileModifiedOn;
  name: TurnstileName;
  offlabel: TurnstileOfflabel;
  region: TurnstileRegion;
  sitekey: TurnstileSitekey;
};

/**
 * Widget Mode
 *
 * @example invisible
 * @x-auditable true
 */
export type TurnstileWidgetMode = "non-interactive" | "invisible" | "managed";

export type VectorizeApiResponseCollection = {
  errors: VectorizeMessages;
  messages: VectorizeMessages;
  result: Record<string, any> | any[] | string | null;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
  result_info?: VectorizeResultInfo;
};

export type VectorizeApiResponseCommon = {
  errors: VectorizeMessages;
  messages: VectorizeMessages;
  result: Record<string, any> | any[] | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type VectorizeApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: VectorizeMessages;
  messages: VectorizeMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

export type VectorizeApiResponseSingle = {
  errors: VectorizeMessages;
  messages: VectorizeMessages;
  result: Record<string, any> | string | string | null;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type VectorizeCreateIndexRequest = {
  /**
   * Specifies the type of configuration to use for the index.
   */
  config: VectorizeIndexConfiguration;
  description?: VectorizeIndexDescription;
  name: VectorizeIndexName;
};

export type VectorizeCreateIndexResponse = {
  config?: VectorizeIndexDimensionConfiguration;
  /**
   * Specifies the timestamp the resource was created as an ISO8601 string.
   *
   * @example 2022-11-15T18:25:44.442097Z
   * @format date-time
   * @x-auditable true
   */
  created_on?: string;
  description?: VectorizeIndexDescription;
  /**
   * Specifies the timestamp the resource was modified as an ISO8601 string.
   *
   * @example 2022-11-15T18:25:44.442097Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string;
  name?: VectorizeIndexName;
};

export type VectorizeCreateMetadataIndexRequest = {
  /**
   * Specifies the type of metadata property to index.
   *
   * @x-auditable true
   */
  indexType: "string" | "number" | "boolean";
  /**
   * Specifies the metadata property to index.
   *
   * @example random_metadata_property
   * @x-auditable true
   */
  propertyName: string;
};

export type VectorizeCreateMetadataIndexResponse = {
  mutationId?: VectorizeMutationUuid;
};

export type VectorizeDeleteMetadataIndexRequest = {
  /**
   * Specifies the metadata property for which the index must be deleted.
   *
   * @example random_metadata_property
   * @x-auditable true
   */
  propertyName: string;
};

export type VectorizeDeleteMetadataIndexResponse = {
  mutationId?: VectorizeMutationUuid;
};

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type VectorizeIdentifier = string;

/**
 * Specifies the type of configuration to use for the index.
 */
export type VectorizeIndexConfiguration =
  | VectorizeIndexDimensionConfiguration
  | VectorizeIndexPresetConfiguration;

export type VectorizeIndexDeleteVectorsByIdRequest = {
  /**
   * A list of vector identifiers to delete from the index indicated by the path.
   *
   * @example 5121db81354a40c6aedc3fe1ace51c59
   * @example f90eb49c2107486abdfd78c67e853430
   */
  ids?: VectorizeVectorIdentifier[];
};

export type VectorizeIndexDeleteVectorsByIdResponse = {
  /**
   * The count of the vectors successfully deleted.
   *
   * @example 42
   */
  count?: number;
  /**
   * Array of vector identifiers of the vectors that were successfully processed for deletion.
   */
  ids?: VectorizeVectorIdentifier[];
};

export type VectorizeIndexDeleteVectorsByIdV2Response = {
  mutationId?: VectorizeMutationUuid;
};

/**
 * Specifies the description of the index.
 *
 * @example This is my example index.
 * @x-auditable true
 */
export type VectorizeIndexDescription = string;

export type VectorizeIndexDimensionConfiguration = {
  dimensions: VectorizeIndexDimensions;
  metric: VectorizeIndexMetric;
};

/**
 * Specifies the number of dimensions for the index
 *
 * @example 768
 * @maximum 1536
 * @minimum 1
 * @x-auditable true
 */
export type VectorizeIndexDimensions = number;

export type VectorizeIndexGetVectorsByIdRequest = {
  /**
   * A list of vector identifiers to retrieve from the index indicated by the path.
   *
   * @example 5121db81354a40c6aedc3fe1ace51c59
   * @example f90eb49c2107486abdfd78c67e853430
   */
  ids?: VectorizeVectorIdentifier[];
};

/**
 * Array of vectors with matching ids.
 *
 * @example {"id":"some-vector-id","metadata":{"another-key":"another-value","customer-id":442},"values":[0.812,0.621,0.261]}
 * @example {"id":"other-vector-id","metadata":{"another-key":"with-a-value","customer-id":2151},"namespace":"namespaced","values":[0.961,0.751,0.661]}
 */
export type VectorizeIndexGetVectorsByIdResponse = {
  id?: VectorizeVectorIdentifier;
  metadata?: Record<string, any>;
  namespace?: string | null;
  values?: number[];
}[];

export type VectorizeIndexInfoResponse = {
  dimensions?: VectorizeIndexDimensions;
  /**
   * Specifies the timestamp the last mutation batch was processed as an ISO8601 string.
   *
   * @example 2024-07-22T18:25:44.442097Z
   * @format date-time
   * @x-auditable true
   */
  processedUpToDatetime?: string | null;
  processedUpToMutation?: VectorizeMutationUuid;
  /**
   * Specifies the number of vectors present in the index
   *
   * @example 300000
   * @x-auditable true
   */
  vectorCount?: number;
};

export type VectorizeIndexInsertResponse = {
  /**
   * Specifies the count of the vectors successfully inserted.
   *
   * @example 768
   * @x-auditable true
   */
  count?: number;
  /**
   * Array of vector identifiers of the vectors successfully inserted.
   */
  ids?: VectorizeVectorIdentifier[];
};

export type VectorizeIndexInsertV2Response = {
  mutationId?: VectorizeMutationUuid;
};

/**
 * Specifies the type of metric to use calculating distance.
 *
 * @x-auditable true
 */
export type VectorizeIndexMetric = "cosine" | "euclidean" | "dot-product";

/**
 * @example example-index
 * @pattern ^([a-z]+[a-z0-9_-]*[a-z0-9]+)$
 * @x-auditable true
 */
export type VectorizeIndexName = string;

/**
 * Specifies the preset to use for the index.
 *
 * @example @cf/baai/bge-small-en-v1.5
 * @x-auditable true
 */
export type VectorizeIndexPreset =
  | "@cf/baai/bge-small-en-v1.5"
  | "@cf/baai/bge-base-en-v1.5"
  | "@cf/baai/bge-large-en-v1.5"
  | "openai/text-embedding-ada-002"
  | "cohere/embed-multilingual-v2.0";

export type VectorizeIndexPresetConfiguration = {
  preset: VectorizeIndexPreset;
};

export type VectorizeIndexQueryRequest = {
  /**
   * A metadata filter expression used to limit nearest neighbor results.
   *
   * @example {"has_viewed":{"$ne":true},"streaming_platform":"netflix"}
   */
  filter?: Record<string, any>;
  /**
   * Whether to return the metadata associated with the closest vectors.
   *
   * @default false
   */
  returnMetadata?: boolean;
  /**
   * Whether to return the values associated with the closest vectors.
   *
   * @default false
   */
  returnValues?: boolean;
  /**
   * The number of nearest neighbors to find.
   *
   * @default 5
   * @example 5
   */
  topK?: number;
  /**
   * The search vector that will be used to find the nearest neighbors.
   *
   * @example 0.5
   * @example 0.5
   * @example 0.5
   */
  vector: number[];
};

export type VectorizeIndexQueryResponse = {
  /**
   * Specifies the count of vectors returned by the search
   */
  count?: number;
  /**
   * Array of vectors matched by the search
   */
  matches?: {
    id?: VectorizeVectorIdentifier;
    metadata?: Record<string, any> | null;
    /**
     * The score of the vector according to the index's distance metric
     */
    score?: number;
    values?: number[] | null;
  }[];
};

export type VectorizeIndexQueryV2Request = {
  /**
   * A metadata filter expression used to limit nearest neighbor results.
   *
   * @example {"has_viewed":{"$ne":true},"streaming_platform":"netflix"}
   */
  filter?: Record<string, any>;
  /**
   * Whether to return no metadata, indexed metadata or all metadata associated with the closest vectors.
   *
   * @default none
   */
  returnMetadata?: "none" | "indexed" | "all";
  /**
   * Whether to return the values associated with the closest vectors.
   *
   * @default false
   */
  returnValues?: boolean;
  /**
   * The number of nearest neighbors to find.
   *
   * @default 5
   * @example 5
   */
  topK?: number;
  /**
   * The search vector that will be used to find the nearest neighbors.
   *
   * @example 0.5
   * @example 0.5
   * @example 0.5
   */
  vector: number[];
};

export type VectorizeIndexQueryV2Response = {
  /**
   * Specifies the count of vectors returned by the search
   */
  count?: number;
  /**
   * Array of vectors matched by the search
   */
  matches?: {
    id?: VectorizeVectorIdentifier;
    metadata?: Record<string, any> | null;
    namespace?: string | null;
    /**
     * The score of the vector according to the index's distance metric
     */
    score?: number;
    values?: number[] | null;
  }[];
};

export type VectorizeIndexUpsertResponse = {
  /**
   * Specifies the count of the vectors successfully inserted.
   *
   * @example 768
   * @x-auditable true
   */
  count?: number;
  /**
   * Array of vector identifiers of the vectors successfully inserted.
   */
  ids?: VectorizeVectorIdentifier[];
};

export type VectorizeIndexUpsertV2Response = {
  mutationId?: VectorizeMutationUuid;
};

/**
 * @example {"metadataIndexes":[{"indexType":"number","propertyName":"some-num-prop"},{"indexType":"string","propertyName":"some-str-prop"},{"indexType":"boolean","propertyName":"some-bool-prop"}]}
 */
export type VectorizeListMetadataIndexResponse = {
  /**
   * Array of indexed metadata properties.
   */
  metadataIndexes?: {
    /**
     * Specifies the type of indexed metadata property.
     *
     * @x-auditable true
     */
    indexType?: "string" | "number" | "boolean";
    /**
     * Specifies the indexed metadata property.
     *
     * @example random_metadata_property
     * @x-auditable true
     */
    propertyName?: string;
  }[];
};

export type VectorizeMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * The unique identifier for the async mutation operation containing the changeset.
 *
 * @example 0000aaaa-11bb-22cc-33dd-444444eeeeee
 * @maxLength 36
 * @x-auditable true
 */
export type VectorizeMutationUuid = void;

export type VectorizeResultInfo = {
  /**
   * Total number of results for the requested service
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters
   *
   * @example 2000
   */
  total_count?: number;
};

export type VectorizeUpdateIndexRequest = {
  description: VectorizeIndexDescription;
};

/**
 * Identifier for a Vector
 *
 * @example some-vector-id-023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 64
 */
export type VectorizeVectorIdentifier = string;

/**
 * Defines the available states for the rule group.
 *
 * @example on
 * @example off
 */
export type WafManagedRulesAllowedModes = WafManagedRulesMode[];

/**
 * Defines the available modes for the current WAF rule.
 *
 * @example on
 * @example off
 */
export type WafManagedRulesAllowedModesAllowTraditional =
  WafManagedRulesModeAllowTraditional[];

/**
 * Defines the available modes for the current WAF rule. Applies to anomaly detection WAF rules.
 *
 * @example on
 * @example off
 */
export type WafManagedRulesAllowedModesAnomaly = WafManagedRulesModeAnomaly[];

/**
 * Defines the list of possible actions of the WAF rule when it is triggered.
 *
 * @example default
 * @example disable
 * @example simulate
 * @example block
 * @example challenge
 */
export type WafManagedRulesAllowedModesDenyTraditional =
  WafManagedRulesModeDenyTraditional[];

/**
 * When triggered, anomaly detection WAF rules contribute to an overall threat score that will determine if a request is considered malicious. You can configure the total scoring threshold through the 'sensitivity' property of the WAF package.
 */
export type WafManagedRulesAnomalyRule = WafManagedRulesSchemasBase & {
  allowed_modes?: WafManagedRulesAllowedModesAnomaly;
  mode?: WafManagedRulesModeAnomaly;
};

export type WafManagedRulesApiResponseCollection =
  WafManagedRulesApiResponseCommon & {
    result_info?: WafManagedRulesResultInfo;
  };

export type WafManagedRulesApiResponseCommon = {
  errors: WafManagedRulesMessages;
  messages: WafManagedRulesMessages;
  /**
   * Defines whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type WafManagedRulesApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: WafManagedRulesMessages;
  messages: WafManagedRulesMessages;
  result: any | null;
  /**
   * Defines whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type WafManagedRulesApiResponseSingle =
  WafManagedRulesApiResponseCommon & {
    result?: (Record<string, any> | null) | (string | null);
  };

export type WafManagedRulesBase = {
  description?: WafManagedRulesSchemasDescription;
  /**
   * Defines the rule group to which the current WAF rule belongs.
   */
  group?: {
    id?: WafManagedRulesComponentsSchemasIdentifier;
    name?: WafManagedRulesName;
  };
  id?: WafManagedRulesRuleComponentsSchemasIdentifier;
  package_id?: WafManagedRulesIdentifier;
  priority?: WafManagedRulesPriority;
};

/**
 * Defines the unique identifier of the rule group.
 *
 * @example de677e5818985db1285d0e80225f06e5
 * @maxLength 32
 * @x-auditable true
 */
export type WafManagedRulesComponentsSchemasIdentifier = string;

/**
 * Defines the default action/mode of a rule.
 *
 * @example block
 */
export type WafManagedRulesDefaultMode =
  | "disable"
  | "simulate"
  | "block"
  | "challenge";

/**
 * Defines an informative summary of what the rule group does.
 *
 * @example Group designed to protect against IP addresses that are a threat and typically used to launch DDoS attacks
 * @x-auditable true
 */
export type WafManagedRulesDescription = string | null;

export type WafManagedRulesGroup = {
  description?: WafManagedRulesDescription;
  id?: WafManagedRulesComponentsSchemasIdentifier;
  modified_rules_count?: WafManagedRulesModifiedRulesCount;
  name?: WafManagedRulesName;
  package_id?: WafManagedRulesIdentifier;
  rules_count?: WafManagedRulesRulesCount;
};

/**
 * Defines the unique identifier of a WAF package.
 *
 * @example a25a9a7e9c00afc1fb2e0245519d725b
 * @maxLength 32
 * @x-auditable true
 */
export type WafManagedRulesIdentifier = string;

export type WafManagedRulesMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * Defines the state of the rules contained in the rule group. When `on`, the rules in the group are configurable/usable.
 *
 * @default on
 * @x-auditable true
 */
export type WafManagedRulesMode = "on" | "off";

/**
 * When set to `on`, the current rule will be used when evaluating the request. Applies to traditional (allow) WAF rules.
 *
 * @example on
 * @x-auditable true
 */
export type WafManagedRulesModeAllowTraditional = "on" | "off";

/**
 * Defines the mode anomaly. When set to `on`, the current WAF rule will be used when evaluating the request. Applies to anomaly detection WAF rules.
 *
 * @example on
 * @x-auditable true
 */
export type WafManagedRulesModeAnomaly = "on" | "off";

/**
 * Defines the action that the current WAF rule will perform when triggered. Applies to traditional (deny) WAF rules.
 *
 * @example block
 * @x-auditable true
 */
export type WafManagedRulesModeDenyTraditional =
  | "default"
  | "disable"
  | "simulate"
  | "block"
  | "challenge";

/**
 * Defines the number of rules within the group that have been modified from their default configuration.
 *
 * @default 0
 * @example 2
 * @x-auditable true
 */
export type WafManagedRulesModifiedRulesCount = number;

/**
 * Defines the name of the rule group.
 *
 * @example Project Honey Pot
 * @x-auditable true
 */
export type WafManagedRulesName = string;

/**
 * Defines the order in which the individual WAF rule is executed within its rule group.
 *
 * @x-auditable true
 */
export type WafManagedRulesPriority = string;

export type WafManagedRulesResultInfo = {
  /**
   * Defines the total number of results for the requested service.
   *
   * @example 1
   */
  count?: number;
  /**
   * Defines the current page within paginated list of results.
   *
   * @example 1
   */
  page?: number;
  /**
   * Defines the number of results per page of results.
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Defines the total results available without any search parameters.
   *
   * @example 2000
   */
  total_count?: number;
};

export type WafManagedRulesRule =
  | WafManagedRulesAnomalyRule
  | WafManagedRulesTraditionalDenyRule
  | WafManagedRulesTraditionalAllowRule;

/**
 * Defines the unique identifier of the WAF rule.
 *
 * @example f939de3be84e66e757adcdcb87908023
 * @maxLength 32
 * @x-auditable true
 */
export type WafManagedRulesRuleComponentsSchemasIdentifier = string;

export type WafManagedRulesRuleGroupResponseCollection =
  WafManagedRulesApiResponseCollection & {
    result?: WafManagedRulesSchemasGroup[];
  };

export type WafManagedRulesRuleGroupResponseSingle =
  WafManagedRulesApiResponseSingle & {
    result?: Record<string, any>;
  };

export type WafManagedRulesRuleResponseCollection =
  WafManagedRulesApiResponseCollection & {
    result?: WafManagedRulesRule[];
  };

export type WafManagedRulesRuleResponseSingle =
  WafManagedRulesApiResponseSingle & {
    result?: Record<string, any>;
  };

/**
 * Defines the number of rules in the current rule group.
 *
 * @default 0
 * @example 10
 * @x-auditable true
 */
export type WafManagedRulesRulesCount = number;

export type WafManagedRulesSchemasBase = WafManagedRulesBase;

/**
 * Defines the public description of the WAF rule.
 *
 * @example SQL injection prevention for SELECT statements
 * @x-auditable true
 */
export type WafManagedRulesSchemasDescription = string;

export type WafManagedRulesSchemasGroup = WafManagedRulesGroup & {
  allowed_modes?: WafManagedRulesAllowedModes;
  mode?: WafManagedRulesMode;
};

/**
 * Defines an identifier of a schema.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type WafManagedRulesSchemasIdentifier = string;

/**
 * When triggered, traditional WAF rules cause the firewall to immediately act on the request based on the rule configuration. An 'allow' rule will immediately allow the request and no other rules will be processed.
 */
export type WafManagedRulesTraditionalAllowRule = WafManagedRulesBase & {
  allowed_modes?: WafManagedRulesAllowedModesAllowTraditional;
  mode?: WafManagedRulesModeAllowTraditional;
};

/**
 * When triggered, traditional WAF rules cause the firewall to immediately act upon the request based on the configuration of the rule. A 'deny' rule will immediately respond to the request based on the configured rule action/mode (for example, 'block') and no other rules will be processed.
 */
export type WafManagedRulesTraditionalDenyRule = WafManagedRulesBase & {
  allowed_modes?: WafManagedRulesAllowedModesDenyTraditional;
  default_mode?: WafManagedRulesDefaultMode;
  mode?: WafManagedRulesModeDenyTraditional;
};

export type WafProductApiBundleApiResponseCollection = {
  errors: WafProductApiBundleMessages;
  messages: WafProductApiBundleMessages;
  result: Record<string, any> | Record<string, any>[] | string | null;
  /**
   * Defines whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type WafProductApiBundleApiResponseCommon = {
  errors: WafProductApiBundleMessages;
  messages: WafProductApiBundleMessages;
  result: Record<string, any> | Record<string, any>[] | string;
  /**
   * Defines whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type WafProductApiBundleApiResponseCommonFailure = {
  /**
   * @example {"code":10100,"message":"Unknown error occured, please try again"}
   * @minLength 1
   */
  errors: WafProductApiBundleMessages;
  messages: WafProductApiBundleMessages;
  result: any | null;
  /**
   * Defines whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type WafProductApiBundleApiResponseSingle = {
  errors: WafProductApiBundleMessages;
  messages: WafProductApiBundleMessages;
  result: (Record<string, any> | null) | (string | null) | string;
  /**
   * Defines whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

/**
 * Defines a custom set of username/password expressions to match Leaked Credential Checks on.
 */
export type WafProductApiBundleCustomDetection = {
  id?: WafProductApiBundleDetectionId;
  /**
   * Defines ehe ruleset expression to use in matching the password in a request.
   *
   * @example lookup_json_string(http.request.body.raw, "secret")
   * @x-auditable true
   */
  password?: string;
  /**
   * Defines the ruleset expression to use in matching the username in a request.
   *
   * @example lookup_json_string(http.request.body.raw, "user")
   * @x-auditable true
   */
  username?: string;
};

/**
 * Defines a custom scan expression to match Content Scanning on.
 */
export type WafProductApiBundleCustomScan = {
  id?: WafProductApiBundleCustomScanId;
  payload?: WafProductApiBundleCustomScanPayload;
};

/**
 * Defines an identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type WafProductApiBundleCustomScanId = WafProductApiBundleIdentifier;

/**
 * Defines the ruleset expression to use in matching content objects.
 *
 * @example lookup_json_string(http.request.body.raw, "file")
 * @x-auditable true
 */
export type WafProductApiBundleCustomScanPayload = string;

/**
 * Defines an identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @x-auditable true
 * @maxLength 32
 */
export type WafProductApiBundleDetectionId = WafProductApiBundleIdentifier;

/**
 * Defines an identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type WafProductApiBundleIdentifier = string;

export type WafProductApiBundleMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

export type WafProductApiBundleResponseCustomDetection =
  WafProductApiBundleApiResponseSingle & {
    result?: WafProductApiBundleCustomDetection;
  };

export type WafProductApiBundleResponseCustomDetectionCollection =
  WafProductApiBundleApiResponseCollection & {
    result?: WafProductApiBundleCustomDetection[];
  };

export type WafProductApiBundleResponseCustomScanCollection =
  WafProductApiBundleSchemasApiResponseCollection & {
    result?: WafProductApiBundleCustomScan[];
  };

export type WafProductApiBundleResponseStatus =
  WafProductApiBundleApiResponseSingle & {
    result?: WafProductApiBundleStatus;
  };

export type WafProductApiBundleSchemasApiResponseCollection = {
  errors: WafProductApiBundleMessages;
  messages: WafProductApiBundleMessages;
  result: Record<string, any> | Record<string, any>[] | (string | null) | null;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type WafProductApiBundleSchemasApiResponseCommon = {
  errors: WafProductApiBundleMessages;
  messages: WafProductApiBundleMessages;
  result: Record<string, any> | Record<string, any>[] | (string | null);
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type WafProductApiBundleSchemasApiResponseCommonFailure = {
  /**
   * @example {"code":10000,"message":"Authentication error"}
   * @minLength 1
   */
  errors: WafProductApiBundleMessages;
  messages: WafProductApiBundleMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type WafProductApiBundleSchemasApiResponseSingle = {
  errors: WafProductApiBundleMessages;
  messages: WafProductApiBundleMessages;
  result: (Record<string, any> | null) | (string | null) | (string | null);
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type WafProductApiBundleSchemasResponseStatus =
  WafProductApiBundleSchemasApiResponseSingle & {
    result?: WafProductApiBundleSchemasStatus;
  };

/**
 * Defines the status for Content Scanning.
 */
export type WafProductApiBundleSchemasStatus = {
  /**
   * Defines the last modification date (ISO 8601) of the Content Scanning status.
   *
   * @example 2024-12-02T09:57:23.150259Z
   * @x-auditable true
   */
  modified?: string;
  /**
   * Defines the status of Content Scanning.
   *
   * @example enabled
   * @x-auditable true
   */
  value?: string;
};

/**
 * Defines the overall status for Leaked Credential Checks.
 */
export type WafProductApiBundleStatus = {
  /**
   * Determines whether or not Leaked Credential Checks are enabled.
   *
   * @example true
   * @x-auditable true
   */
  enabled?: boolean;
};

/**
 * Only available for the Waiting Room Advanced subscription. Additional hostname and path combinations to which this waiting room will be applied. There is an implied wildcard at the end of the path. The hostname and path combination must be unique to this and all other waiting rooms.
 */
export type WaitingroomAdditionalRoutes = {
  /**
   * The hostname to which this waiting room will be applied (no wildcards). The hostname must be the primary domain, subdomain, or custom hostname (if using SSL for SaaS) of this zone. Please do not include the scheme (http:// or https://).
   *
   * @example shop2.example.com
   * @x-auditable true
   */
  host?: string;
  /**
   * Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
   *
   * @default /
   * @example /shop2/checkout
   * @x-auditable true
   */
  path?: string;
}[];

export type WaitingroomApiResponseCollection =
  WaitingroomSchemasApiResponseCommon & {
    result_info?: {
      /**
       * Total number of results for the requested service.
       *
       * @example 1
       */
      count?: number;
      /**
       * Current page within paginated list of results.
       *
       * @example 1
       */
      page?: number;
      /**
       * Number of results per page of results.
       *
       * @example 20
       */
      per_page?: number;
      /**
       * Total results available without any search parameters.
       *
       * @example 2000
       */
      total_count?: number;
    };
  };

export type WaitingroomApiResponseCommon = Record<string, any>;

export type WaitingroomApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: WaitingroomMessages;
  messages: WaitingroomMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type WaitingroomApiResponseSingle = {
  result: Record<string, any> | string;
};

/**
 * Configures cookie attributes for the waiting room cookie. This encrypted cookie stores a user's status in the waiting room, such as queue position.
 */
export type WaitingroomCookieAttributes = {
  /**
   * Configures the SameSite attribute on the waiting room cookie. Value `auto` will be translated to `lax` or `none` depending if **Always Use HTTPS** is enabled. Note that when using value `none`, the secure attribute cannot be set to `never`.
   *
   * @default auto
   * @example auto
   * @x-auditable true
   */
  samesite?: "auto" | "lax" | "none" | "strict";
  /**
   * Configures the Secure attribute on the waiting room cookie. Value `always` indicates that the Secure attribute will be set in the Set-Cookie header, `never` indicates that the Secure attribute will not be set, and `auto` will set the Secure attribute depending if **Always Use HTTPS** is enabled.
   *
   * @default auto
   * @example auto
   * @x-auditable true
   */
  secure?: "auto" | "always" | "never";
};

/**
 * Appends a '_' + a custom suffix to the end of Cloudflare Waiting Room's cookie name(__cf_waitingroom). If `cookie_suffix` is "abcd", the cookie name will be `__cf_waitingroom_abcd`. This field is required if using `additional_routes`.
 *
 * @example abcd
 * @x-auditable true
 */
export type WaitingroomCookieSuffix = string;

export type WaitingroomCreateRule = {
  action: WaitingroomRuleAction;
  description?: WaitingroomRuleDescription;
  enabled?: WaitingroomRuleEnabled;
  expression: WaitingroomRuleExpression;
};

/**
 * Only available for the Waiting Room Advanced subscription. This is a template html file that will be rendered at the edge. If no custom_page_html is provided, the default waiting room will be used. The template is based on mustache ( https://mustache.github.io/ ). There are several variables that are evaluated by the Cloudflare edge:
 * 1. {{`waitTimeKnown`}} Acts like a boolean value that indicates the behavior to take when wait time is not available, for instance when queue_all is **true**.
 * 2. {{`waitTimeFormatted`}} Estimated wait time for the user. For example, five minutes. Alternatively, you can use:
 * 3. {{`waitTime`}} Number of minutes of estimated wait for a user.
 * 4. {{`waitTimeHours`}} Number of hours of estimated wait for a user (`Math.floor(waitTime/60)`).
 * 5. {{`waitTimeHourMinutes`}} Number of minutes above the `waitTimeHours` value (`waitTime%60`).
 * 6. {{`queueIsFull`}} Changes to **true** when no more people can be added to the queue.
 *
 * To view the full list of variables, look at the `cfWaitingRoom` object described under the `json_response_enabled` property in other Waiting Room API calls.
 *
 * @default
 * @example {{#waitTimeKnown}} {{waitTime}} mins {{/waitTimeKnown}} {{^waitTimeKnown}} Queue all enabled {{/waitTimeKnown}}
 * @x-auditable true
 */
export type WaitingroomCustomPageHtml = string;

/**
 * The language of the default page template. If no default_template_language is provided, then `en-US` (English) will be used.
 *
 * @default en-US
 * @example es-ES
 * @x-auditable true
 */
export type WaitingroomDefaultTemplateLanguage =
  | "en-US"
  | "es-ES"
  | "de-DE"
  | "fr-FR"
  | "it-IT"
  | "ja-JP"
  | "ko-KR"
  | "pt-BR"
  | "zh-CN"
  | "zh-TW"
  | "nl-NL"
  | "pl-PL"
  | "id-ID"
  | "tr-TR"
  | "ar-EG"
  | "ru-RU"
  | "fa-IR"
  | "bg-BG"
  | "hr-HR"
  | "cs-CZ"
  | "da-DK"
  | "fi-FI"
  | "lt-LT"
  | "ms-MY"
  | "nb-NO"
  | "ro-RO"
  | "el-GR"
  | "he-IL"
  | "hi-IN"
  | "hu-HU"
  | "sr-BA"
  | "sk-SK"
  | "sl-SI"
  | "sv-SE"
  | "tl-PH"
  | "th-TH"
  | "uk-UA"
  | "vi-VN";

/**
 * A note that you can use to add more details about the waiting room.
 *
 * @default
 * @example Production - DO NOT MODIFY
 * @x-auditable true
 */
export type WaitingroomDescription = string;

/**
 * Only available for the Waiting Room Advanced subscription. Disables automatic renewal of session cookies. If `true`, an accepted user will have session_duration minutes to browse the site. After that, they will have to go through the waiting room again. If `false`, a user's session cookie will be automatically renewed on every request.
 *
 * @default false
 * @example false
 * @x-auditable true
 */
export type WaitingroomDisableSessionRenewal = boolean;

/**
 * A list of enabled origin commands.
 */
export type WaitingroomEnabledOriginCommands = "revoke"[];

/**
 * @x-auditable true
 */
export type WaitingroomEstimatedQueuedUsers = number;

/**
 * @x-auditable true
 */
export type WaitingroomEstimatedTotalActiveUsers = number;

/**
 * If set, the event will override the waiting room's `custom_page_html` property while it is active. If null, the event will inherit it.
 *
 * @example {{#waitTimeKnown}} {{waitTime}} mins {{/waitTimeKnown}} {{^waitTimeKnown}} Event is prequeueing / Queue all enabled {{/waitTimeKnown}}
 * @x-auditable true
 */
export type WaitingroomEventCustomPageHtml = string | null;

/**
 * A note that you can use to add more details about the event.
 *
 * @default
 * @example Production event - DO NOT MODIFY
 * @x-auditable true
 */
export type WaitingroomEventDescription = string;

/**
 * @example {{#waitTimeKnown}} {{waitTime}} mins {{/waitTimeKnown}} {{^waitTimeKnown}} Event is prequeueing / Queue all enabled {{/waitTimeKnown}}
 * @x-auditable true
 */
export type WaitingroomEventDetailsCustomPageHtml = string;

/**
 * @example false
 * @x-auditable true
 */
export type WaitingroomEventDetailsDisableSessionRenewal = boolean;

/**
 * @x-auditable true
 */
export type WaitingroomEventDetailsNewUsersPerMinute = number;

/**
 * @example random
 * @x-auditable true
 */
export type WaitingroomEventDetailsQueueingMethod = string;

export type WaitingroomEventDetailsResponse = WaitingroomApiResponseSingle & {
  result?: WaitingroomEventDetailsResult;
};

export type WaitingroomEventDetailsResult = {
  created_on?: WaitingroomTimestamp;
  custom_page_html?: WaitingroomEventDetailsCustomPageHtml;
  description?: WaitingroomEventDescription;
  disable_session_renewal?: WaitingroomEventDetailsDisableSessionRenewal;
  event_end_time?: WaitingroomEventEndTime;
  event_start_time?: WaitingroomEventStartTime;
  id?: WaitingroomEventId;
  modified_on?: WaitingroomTimestamp;
  name?: WaitingroomEventName;
  new_users_per_minute?: WaitingroomEventDetailsNewUsersPerMinute;
  prequeue_start_time?: WaitingroomEventPrequeueStartTime;
  queueing_method?: WaitingroomEventDetailsQueueingMethod;
  session_duration?: WaitingroomEventDetailsSessionDuration;
  shuffle_at_event_start?: WaitingroomEventShuffleAtEventStart;
  suspended?: WaitingroomEventSuspended;
  total_active_users?: WaitingroomEventDetailsTotalActiveUsers;
};

/**
 * @x-auditable true
 */
export type WaitingroomEventDetailsSessionDuration = number;

/**
 * @x-auditable true
 */
export type WaitingroomEventDetailsTotalActiveUsers = number;

/**
 * If set, the event will override the waiting room's `disable_session_renewal` property while it is active. If null, the event will inherit it.
 *
 * @x-auditable true
 */
export type WaitingroomEventDisableSessionRenewal = boolean | null;

/**
 * An ISO 8601 timestamp that marks the end of the event.
 *
 * @example 2021-09-28T17:00:00.000Z
 * @x-auditable true
 */
export type WaitingroomEventEndTime = string;

/**
 * @example 25756b2dfe6e378a06b033b670413757
 * @x-auditable true
 */
export type WaitingroomEventId = string;

export type WaitingroomEventIdResponse = WaitingroomApiResponseSingle & {
  result?: {
    id?: WaitingroomEventId;
  };
};

/**
 * A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
 *
 * @example production_webinar_event
 * @x-auditable true
 */
export type WaitingroomEventName = string;

/**
 * If set, the event will override the waiting room's `new_users_per_minute` property while it is active. If null, the event will inherit it. This can only be set if the event's `total_active_users` property is also set.
 *
 * @maximum 2147483647
 * @minimum 200
 * @x-auditable true
 */
export type WaitingroomEventNewUsersPerMinute = number | null;

/**
 * An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before `event_start_time`.
 *
 * @example 2021-09-28T15:00:00.000Z
 * @x-auditable true
 */
export type WaitingroomEventPrequeueStartTime = string | null;

/**
 * If set, the event will override the waiting room's `queueing_method` property while it is active. If null, the event will inherit it.
 *
 * @example random
 * @x-auditable true
 */
export type WaitingroomEventQueueingMethod = string | null;

export type WaitingroomEventResponse = WaitingroomApiResponseSingle & {
  result?: WaitingroomEventResult;
};

export type WaitingroomEventResponseCollection =
  WaitingroomApiResponseCollection & {
    result?: WaitingroomEventResult[];
  };

export type WaitingroomEventResult = {
  created_on?: WaitingroomTimestamp;
  custom_page_html?: WaitingroomEventCustomPageHtml;
  description?: WaitingroomEventDescription;
  disable_session_renewal?: WaitingroomEventDisableSessionRenewal;
  event_end_time?: WaitingroomEventEndTime;
  event_start_time?: WaitingroomEventStartTime;
  id?: WaitingroomEventId;
  modified_on?: WaitingroomTimestamp;
  name?: WaitingroomEventName;
  new_users_per_minute?: WaitingroomEventNewUsersPerMinute;
  prequeue_start_time?: WaitingroomEventPrequeueStartTime;
  queueing_method?: WaitingroomEventQueueingMethod;
  session_duration?: WaitingroomEventSessionDuration;
  shuffle_at_event_start?: WaitingroomEventShuffleAtEventStart;
  suspended?: WaitingroomEventSuspended;
  total_active_users?: WaitingroomEventTotalActiveUsers;
  turnstile_action?: WaitingroomEventTurnstileAction;
  turnstile_mode?: WaitingroomEventTurnstileMode;
};

/**
 * If set, the event will override the waiting room's `session_duration` property while it is active. If null, the event will inherit it.
 *
 * @maximum 30
 * @minimum 1
 * @x-auditable true
 */
export type WaitingroomEventSessionDuration = number | null;

/**
 * If enabled, users in the prequeue will be shuffled randomly at the `event_start_time`. Requires that `prequeue_start_time` is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the `queueing_method` during the event respects ordering such as **fifo**, or else the shuffling may be unnecessary.
 *
 * @default false
 * @x-auditable true
 */
export type WaitingroomEventShuffleAtEventStart = boolean;

/**
 * An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before `event_end_time`.
 *
 * @example 2021-09-28T15:30:00.000Z
 * @x-auditable true
 */
export type WaitingroomEventStartTime = string;

/**
 * Suspends or allows an event. If set to `true`, the event is ignored and traffic will be handled based on the waiting room configuration.
 *
 * @default false
 * @x-auditable true
 */
export type WaitingroomEventSuspended = boolean;

/**
 * If set, the event will override the waiting room's `total_active_users` property while it is active. If null, the event will inherit it. This can only be set if the event's `new_users_per_minute` property is also set.
 *
 * @maximum 2147483647
 * @minimum 200
 * @x-auditable true
 */
export type WaitingroomEventTotalActiveUsers = number | null;

/**
 * If set, the event will override the waiting room's `turnstile_action` property while it is active. If null, the event will inherit it.
 *
 * @x-auditable true
 */
export type WaitingroomEventTurnstileAction = "log" | "infinite_queue" | null;

/**
 * If set, the event will override the waiting room's `turnstile_mode` property while it is active. If null, the event will inherit it.
 *
 * @x-auditable true
 */
export type WaitingroomEventTurnstileMode =
  | "off"
  | "invisible"
  | "visible_non_interactive"
  | "visible_managed"
  | null;

/**
 * The host name to which the waiting room will be applied (no wildcards). Please do not include the scheme (http:// or https://). The host and path combination must be unique.
 *
 * @example shop.example.com
 * @x-auditable true
 */
export type WaitingroomHost = string;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type WaitingroomIdentifier = string;

/**
 * Only available for the Waiting Room Advanced subscription. If `true`, requests to the waiting room with the header `Accept: application/json` will receive a JSON response object with information on the user's status in the waiting room as opposed to the configured static HTML page. This JSON response object has one property `cfWaitingRoom` which is an object containing the following fields:
 * 1. `inWaitingRoom`: Boolean indicating if the user is in the waiting room (always **true**).
 * 2. `waitTimeKnown`: Boolean indicating if the current estimated wait times are accurate. If **false**, they are not available.
 * 3. `waitTime`: Valid only when `waitTimeKnown` is **true**. Integer indicating the current estimated time in minutes the user will wait in the waiting room. When `queueingMethod` is **random**, this is set to `waitTime50Percentile`.
 * 4. `waitTime25Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 25% of users that gain entry the fastest (25th percentile).
 * 5. `waitTime50Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 50% of users that gain entry the fastest (50th percentile). In other words, half of the queued users are expected to let into the origin website before `waitTime50Percentile` and half are expected to be let in after it.
 * 6. `waitTime75Percentile`: Valid only when `queueingMethod` is **random** and `waitTimeKnown` is **true**. Integer indicating the current estimated maximum wait time for the 75% of users that gain entry the fastest (75th percentile).
 * 7. `waitTimeFormatted`: String displaying the `waitTime` formatted in English for users. If `waitTimeKnown` is **false**, `waitTimeFormatted` will display **unavailable**.
 * 8. `queueIsFull`: Boolean indicating if the waiting room's queue is currently full and not accepting new users at the moment.
 * 9. `queueAll`: Boolean indicating if all users will be queued in the waiting room and no one will be let into the origin website.
 * 10. `lastUpdated`: String displaying the timestamp as an ISO 8601 string of the user's last attempt to leave the waiting room and be let into the origin website. The user is able to make another attempt after `refreshIntervalSeconds` past this time. If the user makes a request too soon, it will be ignored and `lastUpdated` will not change.
 * 11. `refreshIntervalSeconds`: Integer indicating the number of seconds after `lastUpdated` until the user is able to make another attempt to leave the waiting room and be let into the origin website. When the `queueingMethod` is `reject`, there is no specified refresh time —\_it will always be **zero**.
 * 12. `queueingMethod`: The queueing method currently used by the waiting room. It is either **fifo**, **random**, **passthrough**, or **reject**.
 * 13. `isFIFOQueue`: Boolean indicating if the waiting room uses a FIFO (First-In-First-Out) queue.
 * 14. `isRandomQueue`: Boolean indicating if the waiting room uses a Random queue where users gain access randomly.
 * 15. `isPassthroughQueue`: Boolean indicating if the waiting room uses a passthrough queue. Keep in mind that when passthrough is enabled, this JSON response will only exist when `queueAll` is **true** or `isEventPrequeueing` is **true** because in all other cases requests will go directly to the origin.
 * 16. `isRejectQueue`: Boolean indicating if the waiting room uses a reject queue.
 * 17. `isEventActive`: Boolean indicating if an event is currently occurring. Events are able to change a waiting room's behavior during a specified period of time. For additional information, look at the event properties `prequeue_start_time`, `event_start_time`, and `event_end_time` in the documentation for creating waiting room events. Events are considered active between these start and end times, as well as during the prequeueing period if it exists.
 * 18. `isEventPrequeueing`: Valid only when `isEventActive` is **true**. Boolean indicating if an event is currently prequeueing users before it starts.
 * 19. `timeUntilEventStart`: Valid only when `isEventPrequeueing` is **true**. Integer indicating the number of minutes until the event starts.
 * 20. `timeUntilEventStartFormatted`: String displaying the `timeUntilEventStart` formatted in English for users. If `isEventPrequeueing` is **false**, `timeUntilEventStartFormatted` will display **unavailable**.
 * 21. `timeUntilEventEnd`: Valid only when `isEventActive` is **true**. Integer indicating the number of minutes until the event ends.
 * 22. `timeUntilEventEndFormatted`: String displaying the `timeUntilEventEnd` formatted in English for users. If `isEventActive` is **false**, `timeUntilEventEndFormatted` will display **unavailable**.
 * 23. `shuffleAtEventStart`: Valid only when `isEventActive` is **true**. Boolean indicating if the users in the prequeue are shuffled randomly when the event starts.
 * 24. `turnstile`: Empty when turnstile isn't enabled. String displaying an html tag to display the Turnstile widget. Please add the `{{{turnstile}}}` tag to the `custom_html` template to ensure the Turnstile widget appears.
 * 25. `infiniteQueue`: Boolean indicating whether the response is for a user in the infinite queue.
 *
 * An example cURL to a waiting room could be:
 *
 * 	curl -X GET "https://example.com/waitingroom" \
 * 		-H "Accept: application/json"
 *
 * If `json_response_enabled` is **true** and the request hits the waiting room, an example JSON response when `queueingMethod` is **fifo** and no event is active could be:
 *
 * 	{
 * 		"cfWaitingRoom": {
 * 			"inWaitingRoom": true,
 * 			"waitTimeKnown": true,
 * 			"waitTime": 10,
 * 			"waitTime25Percentile": 0,
 * 			"waitTime50Percentile": 0,
 * 			"waitTime75Percentile": 0,
 * 			"waitTimeFormatted": "10 minutes",
 * 			"queueIsFull": false,
 * 			"queueAll": false,
 * 			"lastUpdated": "2020-08-03T23:46:00.000Z",
 * 			"refreshIntervalSeconds": 20,
 * 			"queueingMethod": "fifo",
 * 			"isFIFOQueue": true,
 * 			"isRandomQueue": false,
 * 			"isPassthroughQueue": false,
 * 			"isRejectQueue": false,
 * 			"isEventActive": false,
 * 			"isEventPrequeueing": false,
 * 			"timeUntilEventStart": 0,
 * 			"timeUntilEventStartFormatted": "unavailable",
 * 			"timeUntilEventEnd": 0,
 * 			"timeUntilEventEndFormatted": "unavailable",
 * 			"shuffleAtEventStart": false
 * 		}
 * 	}
 *
 * If `json_response_enabled` is **true** and the request hits the waiting room, an example JSON response when `queueingMethod` is **random** and an event is active could be:
 *
 * 	{
 * 		"cfWaitingRoom": {
 * 			"inWaitingRoom": true,
 * 			"waitTimeKnown": true,
 * 			"waitTime": 10,
 * 			"waitTime25Percentile": 5,
 * 			"waitTime50Percentile": 10,
 * 			"waitTime75Percentile": 15,
 * 			"waitTimeFormatted": "5 minutes to 15 minutes",
 * 			"queueIsFull": false,
 * 			"queueAll": false,
 * 			"lastUpdated": "2020-08-03T23:46:00.000Z",
 * 			"refreshIntervalSeconds": 20,
 * 			"queueingMethod": "random",
 * 			"isFIFOQueue": false,
 * 			"isRandomQueue": true,
 * 			"isPassthroughQueue": false,
 * 			"isRejectQueue": false,
 * 			"isEventActive": true,
 * 			"isEventPrequeueing": false,
 * 			"timeUntilEventStart": 0,
 * 			"timeUntilEventStartFormatted": "unavailable",
 * 			"timeUntilEventEnd": 15,
 * 			"timeUntilEventEndFormatted": "15 minutes",
 * 			"shuffleAtEventStart": true
 * 		}
 * 	}
 *
 * @default false
 * @example false
 * @x-auditable true
 */
export type WaitingroomJsonResponseEnabled = boolean;

/**
 * @x-auditable true
 */
export type WaitingroomMaxEstimatedTimeMinutes = number;

export type WaitingroomMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * A unique name to identify the waiting room. Only alphanumeric characters, hyphens and underscores are allowed.
 *
 * @example production_webinar
 * @x-auditable true
 */
export type WaitingroomName = string;

/**
 * Sets the number of new users that will be let into the route every minute. This value is used as baseline for the number of users that are let in per minute. So it is possible that there is a little more or little less traffic coming to the route based on the traffic patterns at that time around the world.
 *
 * @maximum 2147483647
 * @minimum 200
 * @x-auditable true
 */
export type WaitingroomNewUsersPerMinute = number;

/**
 * An ISO 8601 timestamp that marks when the next event will begin queueing.
 *
 * @example 2021-09-28T15:00:00.000Z
 * @x-auditable true
 */
export type WaitingroomNextEventPrequeueStartTime = string | null;

/**
 * An ISO 8601 timestamp that marks when the next event will start.
 *
 * @example 2021-09-28T15:00:00.000Z
 * @x-auditable true
 */
export type WaitingroomNextEventStartTime = string | null;

export type WaitingroomPatchRule = {
  action: WaitingroomRuleAction;
  description?: WaitingroomRuleDescription;
  enabled?: WaitingroomRuleEnabled;
  expression: WaitingroomRuleExpression;
  position?: WaitingroomRulePosition;
};

/**
 * Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
 *
 * @default /
 * @example /shop/checkout
 * @x-auditable true
 */
export type WaitingroomPath = string;

export type WaitingroomPreviewResponse = WaitingroomApiResponseSingle & {
  result?: {
    preview_url?: WaitingroomPreviewUrl;
  };
};

/**
 * URL where the custom waiting room page can temporarily be previewed.
 *
 * @example http://waitingrooms.dev/preview/35af8c12-6d68-4608-babb-b53435a5ddfb
 * @x-auditable true
 */
export type WaitingroomPreviewUrl = string;

export type WaitingroomQueryEvent = {
  custom_page_html?: WaitingroomEventCustomPageHtml;
  description?: WaitingroomEventDescription;
  disable_session_renewal?: WaitingroomEventDisableSessionRenewal;
  event_end_time: WaitingroomEventEndTime;
  event_start_time: WaitingroomEventStartTime;
  name: WaitingroomEventName;
  new_users_per_minute?: WaitingroomEventNewUsersPerMinute;
  prequeue_start_time?: WaitingroomEventPrequeueStartTime;
  queueing_method?: WaitingroomEventQueueingMethod;
  session_duration?: WaitingroomEventSessionDuration;
  shuffle_at_event_start?: WaitingroomEventShuffleAtEventStart;
  suspended?: WaitingroomEventSuspended;
  total_active_users?: WaitingroomEventTotalActiveUsers;
  turnstile_action?: WaitingroomEventTurnstileAction;
  turnstile_mode?: WaitingroomEventTurnstileMode;
};

export type WaitingroomQueryPreview = {
  custom_html: WaitingroomCustomPageHtml;
};

export type WaitingroomQueryWaitingroom = {
  additional_routes?: WaitingroomAdditionalRoutes;
  cookie_attributes?: WaitingroomCookieAttributes;
  cookie_suffix?: WaitingroomCookieSuffix;
  custom_page_html?: WaitingroomCustomPageHtml;
  default_template_language?: WaitingroomDefaultTemplateLanguage;
  description?: WaitingroomDescription;
  disable_session_renewal?: WaitingroomDisableSessionRenewal;
  enabled_origin_commands?: WaitingroomEnabledOriginCommands;
  host: WaitingroomHost;
  json_response_enabled?: WaitingroomJsonResponseEnabled;
  name: WaitingroomName;
  new_users_per_minute: WaitingroomNewUsersPerMinute;
  path?: WaitingroomPath;
  queue_all?: WaitingroomQueueAll;
  queueing_method?: WaitingroomQueueingMethod;
  queueing_status_code?: WaitingroomQueueingStatusCode;
  session_duration?: WaitingroomSessionDuration;
  suspended?: WaitingroomSuspended;
  total_active_users: WaitingroomTotalActiveUsers;
  turnstile_action?: WaitingroomTurnstileAction;
  turnstile_mode?: WaitingroomTurnstileMode;
};

/**
 * If queue_all is `true`, all the traffic that is coming to a route will be sent to the waiting room. No new traffic can get to the route once this field is set and estimated time will become unavailable.
 *
 * @default false
 * @example true
 * @x-auditable true
 */
export type WaitingroomQueueAll = boolean;

/**
 * Sets the queueing method used by the waiting room. Changing this parameter from the **default** queueing method is only available for the Waiting Room Advanced subscription. Regardless of the queueing method, if `queue_all` is enabled or an event is prequeueing, users in the waiting room will not be accepted to the origin. These users will always see a waiting room page that refreshes automatically. The valid queueing methods are:
 * 1. `fifo` **(default)**: First-In-First-Out queue where customers gain access in the order they arrived.
 * 2. `random`: Random queue where customers gain access randomly, regardless of arrival time.
 * 3. `passthrough`: Users will pass directly through the waiting room and into the origin website. As a result, any configured limits will not be respected while this is enabled. This method can be used as an alternative to disabling a waiting room (with `suspended`) so that analytics are still reported. This can be used if you wish to allow all traffic normally, but want to restrict traffic during a waiting room event, or vice versa.
 * 4. `reject`: Users will be immediately rejected from the waiting room. As a result, no users will reach the origin website while this is enabled. This can be used if you wish to reject all traffic while performing maintenance, block traffic during a specified period of time (an event), or block traffic while events are not occurring. Consider a waiting room used for vaccine distribution that only allows traffic during sign-up events, and otherwise blocks all traffic. For this case, the waiting room uses `reject`, and its events override this with `fifo`, `random`, or `passthrough`. When this queueing method is enabled and neither `queueAll` is enabled nor an event is prequeueing, the waiting room page **will not refresh automatically**.
 *
 * @default fifo
 * @example fifo
 * @x-auditable true
 */
export type WaitingroomQueueingMethod =
  | "fifo"
  | "random"
  | "passthrough"
  | "reject";

/**
 * HTTP status code returned to a user while in the queue.
 *
 * @default 200
 * @example 202
 * @x-auditable true
 */
export type WaitingroomQueueingStatusCode = 200 | 202 | 429;

export type WaitingroomResponseCollection = WaitingroomApiResponseCollection & {
  result?: WaitingroomWaitingroom[];
};

/**
 * The action to take when the expression matches.
 *
 * @example bypass_waiting_room
 * @x-auditable true
 */
export type WaitingroomRuleAction = "bypass_waiting_room";

/**
 * The description of the rule.
 *
 * @default
 * @example allow all traffic from 10.20.30.40
 * @x-auditable true
 */
export type WaitingroomRuleDescription = string;

/**
 * When set to true, the rule is enabled.
 *
 * @default true
 * @example true
 * @x-auditable true
 */
export type WaitingroomRuleEnabled = boolean;

/**
 * Criteria defining when there is a match for the current rule.
 *
 * @example ip.src in {10.20.30.40}
 * @x-auditable true
 */
export type WaitingroomRuleExpression = string;

/**
 * The ID of the rule.
 *
 * @example 25756b2dfe6e378a06b033b670413757
 * @x-auditable true
 */
export type WaitingroomRuleId = string;

/**
 * Reorder the position of a rule
 */
export type WaitingroomRulePosition =
  | {
      /**
       * Places the rule in the exact position specified by the integer number <POSITION_NUMBER>. Position numbers start with 1. Existing rules in the ruleset from the specified position number onward are shifted one position (no rule is overwritten).
       *
       * @x-auditable true
       */
      index?: number;
    }
  | {
      /**
       * Places the rule before rule <RULE_ID>. Use this argument with an empty rule ID value ("") to set the rule as the first rule in the ruleset.
       *
       * @example <RULE_ID>
       * @x-auditable true
       */
      before?: string;
    }
  | {
      /**
       * Places the rule after rule <RULE_ID>. Use this argument with an empty rule ID value ("") to set the rule as the last rule in the ruleset.
       *
       * @example <RULE_ID>
       * @x-auditable true
       */
      after?: string;
    };

export type WaitingroomRuleResult = {
  action?: WaitingroomRuleAction;
  description?: WaitingroomRuleDescription;
  enabled?: WaitingroomRuleEnabled;
  expression?: WaitingroomRuleExpression;
  id?: WaitingroomRuleId;
  last_updated?: WaitingroomTimestamp;
  version?: WaitingroomRuleVersion;
};

/**
 * The version of the rule.
 *
 * @example 1
 * @x-auditable true
 */
export type WaitingroomRuleVersion = string;

export type WaitingroomRulesResponseCollection =
  WaitingroomApiResponseCollection & {
    result?: WaitingroomRuleResult[];
  };

export type WaitingroomSchemasApiResponseCommon = {
  errors: WaitingroomMessages;
  messages: WaitingroomMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

/**
 * Whether to allow verified search engine crawlers to bypass all waiting rooms on this zone.
 * Verified search engine crawlers will not be tracked or counted by the waiting room system,
 * and will not appear in waiting room analytics.
 *
 * @default false
 * @example true
 * @x-auditable true
 */
export type WaitingroomSearchEngineCrawlerBypass = boolean;

/**
 * Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the route. If a user is not seen by Cloudflare again in that time period, they will be treated as a new user that visits the route.
 *
 * @default 5
 * @maximum 30
 * @minimum 1
 * @x-auditable true
 */
export type WaitingroomSessionDuration = number;

export type WaitingroomSingleResponse = WaitingroomApiResponseSingle & {
  result?: WaitingroomWaitingroom;
};

/**
 * @example queueing
 * @x-auditable true
 */
export type WaitingroomStatus =
  | "event_prequeueing"
  | "not_queueing"
  | "queueing"
  | "suspended";

/**
 * @example 25756b2dfe6e378a06b033b670413757
 * @x-auditable true
 */
export type WaitingroomStatusEventId = string;

export type WaitingroomStatusResponse = WaitingroomApiResponseSingle & {
  result?: {
    estimated_queued_users?: WaitingroomEstimatedQueuedUsers;
    estimated_total_active_users?: WaitingroomEstimatedTotalActiveUsers;
    event_id?: WaitingroomStatusEventId;
    max_estimated_time_minutes?: WaitingroomMaxEstimatedTimeMinutes;
    status?: WaitingroomStatus;
  };
};

/**
 * Suspends or allows traffic going to the waiting room. If set to `true`, the traffic will not go to the waiting room.
 *
 * @default false
 * @x-auditable true
 */
export type WaitingroomSuspended = boolean;

/**
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type WaitingroomTimestamp = string;

/**
 * Sets the total number of active user sessions on the route at a point in time. A route is a combination of host and path on which a waiting room is available. This value is used as a baseline for the total number of active user sessions on the route. It is possible to have a situation where there are more or less active users sessions on the route based on the traffic patterns at that time around the world.
 *
 * @maximum 2147483647
 * @minimum 200
 * @x-auditable true
 */
export type WaitingroomTotalActiveUsers = number;

/**
 * Which action to take when a bot is detected using Turnstile. `log` will
 * have no impact on queueing behavior, simply keeping track of how many
 * bots are detected in Waiting Room Analytics. `infinite_queue` will send
 * bots to a false queueing state, where they will never reach your
 * origin. `infinite_queue` requires Advanced Waiting Room.
 *
 * @default log
 * @x-auditable true
 */
export type WaitingroomTurnstileAction = "log" | "infinite_queue";

/**
 * Which Turnstile widget type to use for detecting bot traffic. See
 * [the Turnstile documentation](https://developers.cloudflare.com/turnstile/concepts/widget/#widget-types)
 * for the definitions of these widget types. Set to `off` to disable the
 * Turnstile integration entirely. Setting this to anything other than
 * `off` or `invisible` requires Advanced Waiting Room.
 *
 * @default invisible
 * @x-auditable true
 */
export type WaitingroomTurnstileMode =
  | "off"
  | "invisible"
  | "visible_non_interactive"
  | "visible_managed";

export type WaitingroomUpdateRules = WaitingroomCreateRule[];

/**
 * @example 699d98642c564d2e855e9661899b7252
 * @x-auditable true
 */
export type WaitingroomWaitingRoomId = string;

export type WaitingroomWaitingRoomIdResponse = WaitingroomApiResponseSingle & {
  result?: {
    id?: WaitingroomWaitingRoomId;
  };
};

export type WaitingroomWaitingroom = {
  additional_routes?: WaitingroomAdditionalRoutes;
  cookie_attributes?: WaitingroomCookieAttributes;
  cookie_suffix?: WaitingroomCookieSuffix;
  created_on?: WaitingroomTimestamp;
  custom_page_html?: WaitingroomCustomPageHtml;
  default_template_language?: WaitingroomDefaultTemplateLanguage;
  description?: WaitingroomDescription;
  disable_session_renewal?: WaitingroomDisableSessionRenewal;
  enabled_origin_commands?: WaitingroomEnabledOriginCommands;
  host?: WaitingroomHost;
  id?: WaitingroomWaitingRoomId;
  json_response_enabled?: WaitingroomJsonResponseEnabled;
  modified_on?: WaitingroomTimestamp;
  name?: WaitingroomName;
  new_users_per_minute?: WaitingroomNewUsersPerMinute;
  next_event_prequeue_start_time?: WaitingroomNextEventPrequeueStartTime;
  next_event_start_time?: WaitingroomNextEventStartTime;
  path?: WaitingroomPath;
  queue_all?: WaitingroomQueueAll;
  queueing_method?: WaitingroomQueueingMethod;
  queueing_status_code?: WaitingroomQueueingStatusCode;
  session_duration?: WaitingroomSessionDuration;
  suspended?: WaitingroomSuspended;
  total_active_users?: WaitingroomTotalActiveUsers;
  turnstile_action?: WaitingroomTurnstileAction;
  turnstile_mode?: WaitingroomTurnstileMode;
};

export type WaitingroomZoneSettings = {
  search_engine_crawler_bypass?: WaitingroomSearchEngineCrawlerBypass;
};

export type WaitingroomZoneSettingsResponse = WaitingroomApiResponseSingle & {
  result: {
    search_engine_crawler_bypass: WaitingroomSearchEngineCrawlerBypass;
  };
};

export type Web3ApiResponseCollection = {
  errors: Web3Messages;
  messages: Web3Messages;
  /**
   * Provides the API response.
   */
  result: never;
  /**
   * Specifies whether the API call was successful.
   *
   * @example true
   */
  success: true;
  result_info?: Web3ResultInfo;
};

export type Web3ApiResponseCommon = {
  errors: Web3Messages;
  messages: Web3Messages;
  /**
   * Provides the API response.
   */
  result: Record<string, any> | any[] | string;
  /**
   * Specifies whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type Web3ApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: Web3Messages;
  messages: Web3Messages;
  result: any | null;
  /**
   * Specifies whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type Web3ApiResponseSingle = Web3ApiResponseCommon & {
  /**
   * Provides the API response.
   */
  result_info?: (Record<string, any> | null) | (string | null);
};

export type Web3ApiResponseSingleId = {
  errors: Web3Messages;
  messages: Web3Messages;
  /**
   * Provides the API response.
   */
  result:
    | {
        id: Web3Identifier;
      }
    | any[]
    | string
    | null;
  /**
   * Specifies whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type Web3CollectionResponse = Web3ApiResponseCollection & {
  result?: Web3Web3Hostname[];
};

/**
 * Behavior of the content list.
 *
 * @example block
 */
export type Web3ContentListAction = "block";

export type Web3ContentListDetails = {
  action?: Web3ContentListAction;
};

export type Web3ContentListDetailsResponse = Web3ApiResponseSingle & {
  result?: Web3ContentListDetails;
};

/**
 * Provides content list entries.
 */
export type Web3ContentListEntries = Web3ContentListEntry[];

/**
 * Specify a content list entry to block.
 */
export type Web3ContentListEntry = {
  content?: Web3ContentListEntryContent;
  created_on?: Web3Timestamp;
  description?: Web3ContentListEntryDescription;
  id?: Web3Identifier;
  modified_on?: Web3Timestamp;
  type?: Web3ContentListEntryType;
};

export type Web3ContentListEntryCollectionResponse =
  Web3ApiResponseCollection & {
    result?: {
      entries?: Web3ContentListEntries;
    };
  };

/**
 * Specify the CID or content path of content to block.
 *
 * @example QmPZ9gcCEpqKTo6aq61g2nXGUhM4iCL3ewB6LDXZCtioEB
 * @maxLength 500
 */
export type Web3ContentListEntryContent = string;

export type Web3ContentListEntryCreateRequest = {
  content: Web3ContentListEntryContent;
  description?: Web3ContentListEntryDescription;
  type: Web3ContentListEntryType;
};

/**
 * Specify an optional description of the content list entry.
 *
 * @example this is my content list entry
 * @maxLength 500
 */
export type Web3ContentListEntryDescription = string;

export type Web3ContentListEntrySingleResponse = Web3ApiResponseSingle & {
  result?: Web3ContentListEntry;
};

/**
 * Specify the type of content list entry to block.
 *
 * @example cid
 */
export type Web3ContentListEntryType = "cid" | "content_path";

export type Web3ContentListUpdateRequest = {
  action: Web3ContentListAction;
  entries: Web3ContentListEntries;
};

export type Web3CreateRequest = {
  description?: Web3Description;
  dnslink?: Web3Dnslink;
  name: Web3Name;
  target: Web3Target;
};

/**
 * Specify an optional description of the hostname.
 *
 * @example This is my IPFS gateway.
 * @maxLength 500
 */
export type Web3Description = string;

/**
 * Specify the DNSLink value used if the target is ipfs.
 *
 * @example /ipns/onboarding.ipfs.cloudflare.com
 */
export type Web3Dnslink = string;

/**
 * Specify the identifier of the hostname.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type Web3Identifier = string;

export type Web3Messages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

export type Web3ModifyRequest = {
  description?: Web3Description;
  dnslink?: Web3Dnslink;
};

/**
 * Specify the hostname that points to the target gateway via CNAME.
 *
 * @example gateway.example.com
 * @maxLength 255
 */
export type Web3Name = string;

export type Web3ResultInfo = {
  /**
   * Specifies the total number of results for the requested service.
   *
   * @example 1
   */
  count?: number;
  /**
   * Specifies the current page within paginated list of results.
   *
   * @example 1
   */
  page?: number;
  /**
   * Specifies the number of results per page of results.
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Specifies the total results available without any search parameters.
   *
   * @example 2000
   */
  total_count?: number;
};

export type Web3SingleResponse = Web3ApiResponseSingle & {
  result?: Web3Web3Hostname;
};

/**
 * Specifies the status of the hostname's activation.
 *
 * @example active
 */
export type Web3Status = "active" | "pending" | "deleting" | "error";

/**
 * Specify the target gateway of the hostname.
 *
 * @example ipfs
 */
export type Web3Target = "ethereum" | "ipfs" | "ipfs_universal_path";

/**
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 */
export type Web3Timestamp = string;

export type Web3Web3Hostname = {
  created_on?: Web3Timestamp;
  description?: Web3Description;
  dnslink?: Web3Dnslink;
  id?: Web3Identifier;
  modified_on?: Web3Timestamp;
  name?: Web3Name;
  status?: Web3Status;
  target?: Web3Target;
};

export type WorkersKvAny =
  | string
  | number
  | number
  | boolean
  | ({
      [key: string]: any;
    } | null)
  | WorkersKvAny[];

export type WorkersKvApiResponseCollection = WorkersKvApiResponseCommon & {
  result_info?: WorkersKvResultInfo;
};

export type WorkersKvApiResponseCommon = {
  errors: WorkersKvMessages;
  messages: WorkersKvMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type WorkersKvApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   * @uniqueItems true
   */
  errors: WorkersKvMessages;
  /**
   * @uniqueItems true
   */
  messages: WorkersKvMessages;
  /**
   * @x-stainless-empty-object true
   */
  result: Record<string, any> | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type WorkersKvApiResponseCommonNoResult = WorkersKvApiResponseCommon & {
  /**
   * @x-stainless-empty-object true
   */
  result?: Record<string, any> | null;
};

export type WorkersKvBulkGetResult = {
  /**
   * Requested keys are paired with their values in an object.
   *
   * @example {"key1":"value1","key2":"value2"}
   */
  values?: {
    [key: string]:
      | string
      | number
      | boolean
      | {
          [key: string]: any;
        };
  };
};

export type WorkersKvBulkGetResultWithMetadata = {
  /**
   * Requested keys are paired with their values and metadata in an object.
   *
   * @example {"key1":{"expiration":1577836800,"metadata":{"someMetadataKey":"someMetadataValue"},"value":"value1"},"key2":{"metadata":{"anotherKey":"anotherValue"},"value":"value2"}}
   */
  values?: {
    [key: string]: {
      expiration?: WorkersKvExpiration;
      /**
       * The metadata associated with the key.
       */
      metadata: WorkersKvAny & void;
      /**
       * The value associated with the key.
       */
      value: WorkersKvAny & void;
    } | null;
  };
};

export type WorkersKvBulkResult = {
  /**
   * Number of keys successfully updated.
   *
   * @example 100
   */
  successful_key_count?: number;
  /**
   * Name of the keys that failed to be fully updated. They should be retried.
   */
  unsuccessful_keys?: string[];
};

export type WorkersKvBulkDelete = WorkersKvKeyNameBulk[];

export type WorkersKvBulkWrite = {
  /**
   * Indicates whether or not the server should base64 decode the value before storing it. Useful for writing values that wouldn't otherwise be valid JSON strings, such as images.
   *
   * @default false
   */
  base64?: boolean;
  expiration?: WorkersKvExpiration;
  expiration_ttl?: WorkersKvExpirationTtl;
  key: WorkersKvKeyNameBulk;
  metadata?: WorkersKvListMetadata;
  /**
   * A UTF-8 encoded string to be stored, up to 25 MiB in length.
   *
   * @example Some string
   * @maxLength 26214400
   */
  value: string;
}[];

export type WorkersKvCreateRenameNamespaceBody = {
  title: WorkersKvNamespaceTitle;
};

/**
 * Opaque token indicating the position from which to continue when requesting the next set of records if the amount of list results was limited by the limit parameter. A valid value for the cursor can be obtained from the cursors object in the result_info structure.
 *
 * @example 6Ck1la0VxJ0djhidm1MdX2FyDGxLKVeeHZZmORS_8XeSuhz9SjIJRaSa2lnsF01tQOHrfTGAP3R5X1Kv5iVUuMbNKhWNAXHOl6ePB0TUL8nw
 */
export type WorkersKvCursor = string;

/**
 * Expires the key at a certain time, measured in number of seconds since the UNIX epoch.
 *
 * @example 1578435000
 */
export type WorkersKvExpiration = number;

/**
 * Expires the key after a number of seconds. Must be at least 60.
 *
 * @example 300
 * @minimum 60
 */
export type WorkersKvExpirationTtl = number;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type WorkersKvIdentifier = string;

/**
 * A name for a value. A value stored under a given key may be retrieved via the same key.
 */
export type WorkersKvKey = {
  /**
   * The time, measured in number of seconds since the UNIX epoch, at which the key will expire. This property is omitted for keys that will not expire.
   *
   * @example 1577836800
   */
  expiration?: number;
  metadata?: WorkersKvListMetadata;
  name: WorkersKvKeyName;
};

/**
 * A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid. Use percent-encoding to define key names as part of a URL.
 *
 * @example My-Key
 * @maxLength 512
 */
export type WorkersKvKeyName = string;

/**
 * A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid.
 *
 * @example My-Key
 * @maxLength 512
 */
export type WorkersKvKeyNameBulk = string;

/**
 * Arbitrary JSON that is associated with a key.
 *
 * @example {"someMetadataKey":"someMetadataValue"}
 */
export type WorkersKvListMetadata = WorkersKvAny & void;

/**
 * @uniqueItems true
 */
export type WorkersKvMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * Associates arbitrary JSON data with a key/value pair.
 *
 * @example {"someMetadataKey":"someMetadataValue"}
 */
export type WorkersKvMetadata = WorkersKvAny & void;

export type WorkersKvNamespace = {
  /**
   * True if new beta namespace, with additional preview features.
   *
   * @example true
   * @x-auditable true
   */
  beta?: boolean;
  id: WorkersKvNamespaceIdentifier;
  /**
   * True if keys written on the URL will be URL-decoded before storing. For example, if set to "true", a key written on the URL as "%3F" will be stored as "?".
   *
   * @example true
   * @x-auditable true
   */
  supports_url_encoding?: boolean;
  title: WorkersKvNamespaceTitle;
};

/**
 * Namespace identifier tag.
 *
 * @example 0f2ac74b498b48028cb68387c421e279
 * @maxLength 32
 * @x-auditable true
 */
export type WorkersKvNamespaceIdentifier = string;

/**
 * A human-readable string name for a Namespace.
 *
 * @example My Own Namespace
 * @maxLength 512
 * @x-auditable true
 */
export type WorkersKvNamespaceTitle = string;

export type WorkersKvResultInfo = {
  /**
   * Total number of results for the requested service.
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results.
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results.
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters.
   *
   * @example 2000
   */
  total_count?: number;
};

/**
 * A byte sequence to be stored, up to 25 MiB in length.
 *
 * @example Some Value
 */
export type WorkersKvValue = string | Blob;

/**
 * The statistics object contains information about query performance from the database, it does not include any network latency
 */
export type WorkersObservabilityPerformanceInformation = {
  /**
   * Number of uncompressed bytes read from the table.
   */
  bytes_read: number;
  /**
   * Time in seconds for the query to run.
   */
  elapsed: number;
  /**
   * Number of rows scanned from the table.
   */
  rows_read: number;
};

export type WorkersObservabilityQuery = {
  created: string;
  /**
   * @example Query description
   * @maxLength 1000
   */
  description: string | null;
  /**
   * ID of your environment
   *
   * @example my-environment
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  environmentId: string;
  /**
   * Flag for alerts automatically created
   */
  generated: boolean | null;
  /**
   * ID of the query
   *
   * @example query-1
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  id: string;
  /**
   * Query name
   */
  name: string | null;
  parameters: {
    /**
     * Create Calculations to compute as part of the query.
     */
    calculations?: {
      alias?: string;
      key?: string;
      keyType?: "string" | "number" | "boolean";
      operator:
        | "uniq"
        | "count"
        | "max"
        | "min"
        | "sum"
        | "avg"
        | "median"
        | "p001"
        | "p01"
        | "p05"
        | "p10"
        | "p25"
        | "p75"
        | "p90"
        | "p95"
        | "p99"
        | "p999"
        | "stddev"
        | "variance"
        | "COUNT_DISTINCT"
        | "COUNT"
        | "MAX"
        | "MIN"
        | "SUM"
        | "AVG"
        | "MEDIAN"
        | "P001"
        | "P01"
        | "P05"
        | "P10"
        | "P25"
        | "P75"
        | "P90"
        | "P95"
        | "P99"
        | "P999"
        | "STDDEV"
        | "VARIANCE";
    }[];
    /**
     * Set the Datasets to query. Leave it empty to query all the datasets.
     */
    datasets?: string[];
    /**
     * Set a Flag to describe how to combine the filters on the query.
     */
    filterCombination?: "and" | "or" | "AND" | "OR";
    /**
     * Configure the Filters to apply to the query.
     */
    filters?: {
      key: string;
      operation:
        | "includes"
        | "not_includes"
        | "starts_with"
        | "regex"
        | "exists"
        | "is_null"
        | "in"
        | "not_in"
        | "eq"
        | "neq"
        | "gt"
        | "gte"
        | "lt"
        | "lte"
        | "="
        | "!="
        | ">"
        | ">="
        | "<"
        | "<="
        | "INCLUDES"
        | "DOES_NOT_INCLUDE"
        | "MATCH_REGEX"
        | "EXISTS"
        | "DOES_NOT_EXIST"
        | "IN"
        | "NOT_IN"
        | "STARTS_WITH";
      type: "string" | "number" | "boolean";
      value?: string | number | boolean;
    }[];
    /**
     * Define how to group the results of the query.
     */
    groupBys?: {
      type: "string" | "number" | "boolean";
      value: string;
    }[];
    /**
     * Configure the Having clauses that filter on calculations in the query result.
     */
    havings?: {
      key: string;
      operation: "eq" | "neq" | "gt" | "gte" | "lt" | "lte";
      value: number;
    }[];
    /**
     * Set a limit on the number of results / records returned by the query
     *
     * @maximum 100
     * @minimum 0
     */
    limit?: number;
    /**
     * Define an expression to search using full-text search.
     */
    needle?: {
      isRegex?: boolean;
      matchCase?: boolean;
      value: string | number | boolean;
    };
    /**
     * Configure the order of the results returned by the query.
     */
    orderBy?: {
      /**
       * Set the order of the results
       */
      order?: "asc" | "desc";
      /**
       * Configure which Calculation to order the results by.
       */
      value: string;
    };
  };
  updated: string;
  /**
   * @example JY2UKXLO60AEV94R
   */
  userId: string;
  /**
   * ID of your workspace
   *
   * @example my-workspace
   * @maxLength 64
   * @minLength 1
   * @pattern ^[a-z0-9_]+(?:-[a-z0-9_]+)*$
   */
  workspaceId: string;
};

export type WorkersObservabilityQueryResults = {
  calculations?: {
    aggregates: {
      count: number;
      groups?: {
        key: string;
        value: string | number | boolean;
      }[];
      interval: number;
      sampleInterval: number;
      value: number;
    }[];
    alias?: string;
    calculation: string;
    series: {
      data: {
        count: number;
        firstSeen: string;
        groups?: {
          key: string;
          value: string | number | boolean;
        }[];
        interval: number;
        lastSeen: string;
        sampleInterval: number;
        value: number;
      }[];
      time: string;
    }[];
  }[];
  compare?: {
    aggregates: {
      count: number;
      groups?: {
        key: string;
        value: string | number | boolean;
      }[];
      interval: number;
      sampleInterval: number;
      value: number;
    }[];
    alias?: string;
    calculation: string;
    series: {
      data: {
        count: number;
        firstSeen: string;
        groups?: {
          key: string;
          value: string | number | boolean;
        }[];
        interval: number;
        lastSeen: string;
        sampleInterval: number;
        value: number;
      }[];
      time: string;
    }[];
  }[];
  events?: {
    count?: number;
    events?: WorkersObservabilityTelemetryEvent[];
    fields?: {
      key: string;
      type: string;
    }[];
    series?: {
      data: {
        aggregates: {
          /**
           * @deprecated true
           * @exclusiveMinimum true
           * @minimum 0
           */
          _count: number;
          /**
           * @deprecated true
           */
          _firstSeen: string;
          /**
           * @deprecated true
           * @exclusiveMinimum true
           * @minimum 0
           */
          _interval: number;
          /**
           * @deprecated true
           */
          _lastSeen: string;
          /**
           * @deprecated true
           */
          bin?: Record<string, any>;
        };
        count: number;
        errors?: number;
        /**
         * Groups in the query results.
         */
        groups?: {
          [key: string]: string | number | boolean;
        };
        interval: number;
        sampleInterval: number;
      }[];
      time: string;
    }[];
  };
  invocations?: {
    [key: string]: WorkersObservabilityTelemetryEvent[];
  };
  patterns?: {
    count: number;
    pattern: string;
    series: {
      data: {
        count: number;
        groups?: {
          key: string;
          value: string | number | boolean;
        }[];
        interval: number;
        sampleInterval: number;
        value: number;
      };
      time: string;
    }[];
    service: string;
  }[];
  run: WorkersObservabilityQueryRun;
  statistics: WorkersObservabilityPerformanceInformation;
};

/**
 * A Workers Observability Query Object
 */
export type WorkersObservabilityQueryRun = {
  accountId: string;
  created?: string;
  dry: boolean;
  /**
   * @deprecated true
   */
  environmentId: string;
  granularity: number;
  id: string;
  query: WorkersObservabilityQuery;
  statistics?: {
    /**
     * Number of uncompressed bytes read from the table.
     */
    bytes_read: number;
    /**
     * Time in seconds for the query to run.
     */
    elapsed: number;
    /**
     * Number of rows scanned from the table.
     */
    rows_read: number;
  };
  status: "STARTED" | "COMPLETED";
  timeframe: {
    /**
     * Set the start time for your query using UNIX time in milliseconds.
     *
     * @exclusiveMinimum true
     * @minimum 0
     */
    from: number;
    /**
     * Set the end time for your query using UNIX time in milliseconds.
     *
     * @exclusiveMinimum true
     * @minimum 0
     */
    to: number;
  };
  updated?: string;
  userId: string;
  /**
   * @deprecated true
   */
  workspaceId: string;
};

/**
 * The data structure of a telemetry event
 */
export type WorkersObservabilityTelemetryEvent = {
  $metadata: {
    account?: string;
    cloudService?: string;
    /**
     * @exclusiveMinimum true
     * @minimum 0
     */
    coldStart?: number;
    /**
     * @exclusiveMinimum true
     * @minimum 0
     */
    cost?: number;
    /**
     * @exclusiveMinimum true
     * @minimum 0
     */
    duration?: number;
    /**
     * @minimum 0
     */
    endTime?: number;
    error?: string;
    errorTemplate?: string;
    fingerprint?: string;
    id: string;
    level?: string;
    message?: string;
    messageTemplate?: string;
    metricName?: string;
    origin?: string;
    parentSpanId?: string;
    provider?: string;
    region?: string;
    requestId?: string;
    service?: string;
    spanId?: string;
    spanName?: string;
    stackId?: string;
    /**
     * @minimum 0
     */
    startTime?: number;
    /**
     * @exclusiveMinimum true
     * @minimum 0
     */
    statusCode?: number;
    /**
     * @exclusiveMinimum true
     * @minimum 0
     */
    traceDuration?: number;
    traceId?: string;
    trigger?: string;
    type?: string;
    url?: string;
  };
  /**
   * Cloudflare Workers event information enriches your logs so you can easily identify and debug issues.
   */
  $workers?:
    | {
        entrypoint?: string;
        event?: {
          [key: string]:
            | string
            | number
            | boolean
            | {
                [key: string]:
                  | string
                  | number
                  | boolean
                  | {
                      [key: string]:
                        | (string | number | boolean)[]
                        | string
                        | number
                        | boolean;
                    };
              };
        };
        eventType:
          | "fetch"
          | "scheduled"
          | "alarm"
          | "cron"
          | "queue"
          | "email"
          | "tail"
          | "rpc"
          | "websocket"
          | "unknown";
        executionModel?: "durableObject" | "stateless";
        outcome: string;
        requestId: string;
        scriptName: string;
        scriptVersion?: {
          id?: string;
          message?: string;
          tag?: string;
        };
        truncated?: boolean;
      }
    | {
        cpuTimeMs: number;
        diagnosticsChannelEvents?: {
          channel: string;
          message: string;
          timestamp: number;
        }[];
        dispatchNamespace?: string;
        entrypoint?: string;
        event?: {
          [key: string]: string | number | boolean;
        };
        eventType:
          | "fetch"
          | "scheduled"
          | "alarm"
          | "cron"
          | "queue"
          | "email"
          | "tail"
          | "rpc"
          | "websocket"
          | "unknown";
        executionModel?: "durableObject" | "stateless";
        outcome: string;
        requestId: string;
        scriptName: string;
        scriptVersion?: {
          id?: string;
          message?: string;
          tag?: string;
        };
        truncated?: boolean;
        wallTimeMs: number;
      };
  dataset: string;
  source: string | Record<string, any>;
  /**
   * @minimum 0
   */
  timestamp: number;
};

export type WorkersAccountSettings = {
  /**
   * @x-auditable true
   */
  default_usage_model?: string;
  /**
   * @x-auditable true
   */
  green_compute?: boolean;
};

/**
 * Identifer of the account.
 *
 * @example 9a7806061c88ada191ed06f989cc3dac
 * @x-auditable true
 */
export type WorkersAccountIdentifier = string;

export type WorkersApiResponseCollection = WorkersApiResponseCommon & {
  result_info?: {
    /**
     * Total number of results for the requested service.
     *
     * @example 1
     */
    count?: number;
    /**
     * Current page within paginated list of results.
     *
     * @example 1
     */
    page?: number;
    /**
     * Number of results per page of results.
     *
     * @example 20
     */
    per_page?: number;
    /**
     * Total results available without any search parameters.
     *
     * @example 2000
     */
    total_count?: number;
  };
};

export type WorkersApiResponseCommon = {
  errors: WorkersMessages;
  messages: WorkersMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type WorkersApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: WorkersMessages;
  messages: WorkersMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type WorkersApiResponseNullResult = WorkersApiResponseCommon & {
  result?: any | null;
};

export type WorkersApiResponseSingle = WorkersApiResponseCommon;

/**
 * A binding to allow the Worker to communicate with resources.
 */
export type WorkersBindingItem =
  | WorkersBindingKindAi
  | WorkersBindingKindAnalyticsEngine
  | WorkersBindingKindAssets
  | WorkersBindingKindBrowser
  | WorkersBindingKindD1
  | WorkersBindingKindDispatchNamespace
  | WorkersBindingKindDurableObjectNamespace
  | WorkersBindingKindHyperdrive
  | WorkersBindingKindJson
  | WorkersBindingKindKvNamespace
  | WorkersBindingKindMtlsCertificate
  | WorkersBindingKindPlainText
  | WorkersBindingKindPipelines
  | WorkersBindingKindQueue
  | WorkersBindingKindR2Bucket
  | WorkersBindingKindSecretText
  | WorkersBindingKindService
  | WorkersBindingKindTailConsumer
  | WorkersBindingKindVectorize
  | WorkersBindingKindVersionMetadata
  | WorkersBindingKindSecretsStoreSecret
  | WorkersBindingKindSecretKey
  | WorkersBindingKindWorkflow;

export type WorkersBindingKindAi = {
  name: WorkersBindingName;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "ai";
};

export type WorkersBindingKindAnalyticsEngine = {
  /**
   * The name of the dataset to bind to.
   *
   * @example some_dataset
   * @x-auditable true
   */
  dataset: string;
  name: WorkersBindingName;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "analytics_engine";
};

export type WorkersBindingKindAssets = {
  name: WorkersBindingName;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "assets";
};

export type WorkersBindingKindBrowser = {
  name: WorkersBindingName;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "browser";
};

export type WorkersBindingKindD1 = {
  /**
   * Identifier of the D1 database to bind to.
   *
   * @example xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
   * @x-auditable true
   */
  id: string;
  name: WorkersBindingName;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "d1";
};

export type WorkersBindingKindDispatchNamespace = {
  name: WorkersBindingName;
  /**
   * Namespace to bind to.
   *
   * @example xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
   * @x-auditable true
   */
  namespace: string;
  /**
   * Outbound worker.
   */
  outbound?: {
    /**
     * Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
     */
    params?: string[];
    /**
     * Outbound worker.
     */
    worker?: {
      /**
       * Environment of the outbound worker.
       *
       * @x-auditable true
       */
      environment?: string;
      /**
       * Name of the outbound worker.
       *
       * @x-auditable true
       */
      service?: string;
    };
  };
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "dispatch_namespace";
};

export type WorkersBindingKindDurableObjectNamespace = {
  /**
   * The exported class name of the Durable Object.
   *
   * @example MyDurableObject
   * @x-auditable true
   * @x-stainless-terraform-configurability computed_optional
   */
  class_name?: string;
  /**
   * The environment of the script_name to bind to.
   *
   * @example production
   * @x-auditable true
   */
  environment?: string;
  name: WorkersBindingName;
  /**
   * Namespace identifier tag.
   *
   * @example 0f2ac74b498b48028cb68387c421e279
   * @maxLength 32
   * @x-auditable true
   * @x-stainless-terraform-configurability computed_optional
   */
  namespace_id?: WorkersNamespaceIdentifier & string;
  /**
   * The script where the Durable Object is defined, if it is external to this Worker.
   *
   * @example my-other-worker
   * @x-auditable true
   * @x-stainless-terraform-configurability computed_optional
   */
  script_name?: string;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "durable_object_namespace";
};

export type WorkersBindingKindHyperdrive = {
  /**
   * Identifier of the Hyperdrive connection to bind to.
   *
   * @example 57b7076f58be42419276f058a8968187
   * @x-auditable true
   */
  id: string;
  name: WorkersBindingName;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "hyperdrive";
};

export type WorkersBindingKindJson = {
  /**
   * JSON data to use.
   *
   * @example { "message": "Hello, world!" }
   */
  json: string;
  name: WorkersBindingName;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "json";
};

export type WorkersBindingKindKvNamespace = {
  name: WorkersBindingName;
  namespace_id: WorkersNamespaceIdentifier;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "kv_namespace";
};

export type WorkersBindingKindMtlsCertificate = {
  /**
   * Identifier of the certificate to bind to.
   *
   * @example efwu2n6s-q69d-2kr9-184j-4913e8h391k6
   * @x-auditable true
   */
  certificate_id: string;
  name: WorkersBindingName;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "mtls_certificate";
};

export type WorkersBindingKindPipelines = {
  name: WorkersBindingName;
  /**
   * Name of the Pipeline to bind to.
   *
   * @example my-pipeline
   * @x-auditable true
   */
  pipeline: string;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "pipelines";
};

export type WorkersBindingKindPlainText = {
  name: WorkersBindingName;
  /**
   * The text value to use.
   *
   * @example Hello, world!
   * @x-auditable true
   */
  text: string;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "plain_text";
};

export type WorkersBindingKindQueue = {
  name: WorkersBindingName;
  /**
   * Name of the Queue to bind to.
   *
   * @example my-queue
   */
  queue_name: string;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "queue";
};

export type WorkersBindingKindR2Bucket = {
  /**
   * R2 bucket to bind to.
   *
   * @example my-r2-bucket
   * @x-auditable true
   */
  bucket_name: string;
  name: WorkersBindingName;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "r2_bucket";
};

export type WorkersBindingKindSecretKey = {
  /**
   * Algorithm-specific key parameters. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#algorithm).
   *
   * @x-auditable true
   */
  algorithm: Record<string, any>;
  /**
   * Data format of the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#format).
   *
   * @example raw
   * @x-auditable true
   */
  format: "raw" | "pkcs8" | "spki" | "jwk";
  /**
   * Base64-encoded key data. Required if `format` is "raw", "pkcs8", or "spki".
   *
   * @x-sensitive true
   */
  key_base64?: string;
  /**
   * Key data in [JSON Web Key](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#json_web_key) format. Required if `format` is "jwk".
   *
   * @x-sensitive true
   */
  key_jwk?: Record<string, any>;
  name: WorkersBindingName;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "secret_key";
  /**
   * Allowed operations with the key. [Learn more](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey#keyUsages).
   *
   * @example encrypt
   * @example decrypt
   * @x-auditable true
   * @x-stainless-collection-type set
   */
  usages: (
    | "encrypt"
    | "decrypt"
    | "sign"
    | "verify"
    | "deriveKey"
    | "deriveBits"
    | "wrapKey"
    | "unwrapKey"
  )[];
};

export type WorkersBindingKindSecretText = {
  name: WorkersBindingName;
  /**
   * The secret value to use.
   *
   * @example My secret.
   * @x-sensitive true
   */
  text: string;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "secret_text";
};

export type WorkersBindingKindSecretsStoreSecret = {
  name: WorkersBindingName;
  /**
   * Name of the secret in the store.
   *
   * @example my_secret
   * @x-auditable true
   */
  secret_name: string;
  /**
   * ID of the store containing the secret.
   *
   * @example 8c8b1387108e49be85669169793e7bd2
   * @x-auditable true
   */
  store_id: string;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "secrets_store_secret";
};

export type WorkersBindingKindService = {
  /**
   * Optional environment if the Worker utilizes one.
   *
   * @example production
   * @x-auditable true
   */
  environment: string;
  name: WorkersBindingName;
  /**
   * Name of Worker to bind to.
   *
   * @example my-worker
   * @x-auditable true
   */
  service: string;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "service";
};

export type WorkersBindingKindTailConsumer = {
  name: WorkersBindingName;
  /**
   * Name of Tail Worker to bind to.
   *
   * @example my-worker
   * @x-auditable true
   */
  service: string;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "tail_consumer";
};

export type WorkersBindingKindVectorize = {
  /**
   * Name of the Vectorize index to bind to.
   *
   * @example my-index-name
   * @x-auditable true
   */
  index_name: string;
  name: WorkersBindingName;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "vectorize";
};

export type WorkersBindingKindVersionMetadata = {
  name: WorkersBindingName;
  /**
   * The kind of resource that the binding provides.
   *
   * @x-auditable true
   */
  type: "version_metadata";
};

export type WorkersBindingKindWorkflow = {
  /**
   * Class name of the Workflow. Should only be provided if the Workflow belongs to this script.
   *
   * @example my-workflow
   */
  class_name?: string;
  name: WorkersBindingName;
  /**
   * Script name that contains the Workflow. If not provided, defaults to this script name.
   *
   * @example my-workflow
   * @x-auditable true
   */
  script_name?: string;
  /**
   * The kind of resource that the binding provides.
   */
  type: "workflow";
  /**
   * Name of the Workflow to bind to.
   *
   * @example my-workflow
   */
  workflow_name: string;
};

/**
 * A JavaScript variable name for the binding.
 *
 * @example myBinding
 * @x-auditable true
 */
export type WorkersBindingName = string;

/**
 * List of bindings attached to a Worker. You can find more about bindings on our docs: https://developers.cloudflare.com/workers/configuration/multipart-upload-metadata/#bindings.
 *
 * @example {"name":"MY_ENV_VAR","text":"my_data","type":"plain_text"}
 * @x-stainless-collection-type set
 */
export type WorkersBindings = WorkersBindingItem[];

/**
 * Date indicating targeted support in the Workers runtime. Backwards incompatible fixes to the runtime following this date will not affect this Worker.
 *
 * @example 2021-01-01
 * @x-auditable true
 */
export type WorkersCompatibilityDate = string;

/**
 * Flag that enables or disables a specific feature in the Workers runtime.
 *
 * @example nodejs_compat
 * @x-auditable true
 */
export type WorkersCompatibilityFlag = string;

/**
 * Flags that enable or disable certain features in the Workers runtime. Used to enable upcoming features or opt in or out of specific changes not included in a `compatibility_date`.
 *
 * @example nodejs_compat
 * @x-stainless-collection-type set
 */
export type WorkersCompatibilityFlags = WorkersCompatibilityFlag[];

export type WorkersCompletedUploadAssetsResponse = WorkersApiResponseCommon & {
  result?: {
    /**
     * A "completion" JWT which can be redeemed when creating a Worker version.
     *
     * @x-sensitive true
     */
    jwt?: string;
  };
};

export type WorkersCreateAssetsUploadSessionObject = {
  /**
   * A manifest ([path]: {hash, size}) map of files to upload. As an example, `/blog/hello-world.html` would be a valid path key.
   */
  manifest: {
    [key: string]: WorkersManifestValue;
  };
};

export type WorkersCreateAssetsUploadSessionResponse =
  WorkersApiResponseCommon & {
    result?: {
      /**
       * The requests to make to upload assets.
       *
       * @x-stainless-collection-type set
       */
      buckets?: string[][];
      /**
       * A JWT to use as authentication for uploading assets.
       *
       * @x-sensitive true
       */
      jwt?: string;
    };
  };

/**
 * When the script was created.
 *
 * @example 2017-01-01T00:00:00Z
 * @format date-time
 * @x-auditable true
 */
export type WorkersCreatedOn = string;

/**
 * Opaque token indicating the position from which to continue when requesting the next set of records. A valid value for the cursor can be obtained from the cursors object in the result_info structure.
 *
 * @example AAAAANuhDN7SjacTnSVsDu3WW1Lvst6dxJGTjRY5BhxPXdf6L6uTcpd_NVtjhn11OUYRsVEykxoUwF-JQU4dn6QylZSKTOJuG0indrdn_MlHpMRtsxgXjs-RPdHYIVm3odE_uvEQ_dTQGFm8oikZMohns34DLBgrQpc
 */
export type WorkersCursor = string;

export type WorkersDeployment = {
  annotations?: {
    /**
     * Human-readable message about the deployment. Truncated to 100 bytes.
     *
     * @example Deploy bug fix.
     * @maxLength 100
     * @x-auditable true
     */
    ["workers/message"]?: string;
  };
  /**
   * @format email
   * @x-auditable true
   */
  author_email?: string;
  /**
   * @format date-time
   * @x-auditable true
   */
  created_on: string;
  /**
   * @format uuid
   * @x-auditable true
   */
  id: string;
  /**
   * @example api
   * @x-auditable true
   */
  source: string;
  /**
   * @x-auditable true
   */
  strategy: "percentage";
  /**
   * @x-auditable true
   */
  versions: {
    /**
     * @example 100
     * @maximum 100
     * @minimum 0.01
     * @x-auditable true
     */
    percentage: number;
    /**
     * @format uuid
     * @x-auditable true
     */
    version_id: string;
  }[];
};

/**
 * Name of the Workers for Platforms dispatch namespace.
 *
 * @example my-dispatch-namespace
 * @pattern ^.+$
 * @x-auditable true
 */
export type WorkersDispatchNamespaceName = string;

export type WorkersDomain = {
  environment?: WorkersSchemasEnvironment;
  hostname?: WorkersHostname;
  id?: WorkersDomainIdentifier;
  service?: WorkersSchemasService;
  zone_id?: WorkersZoneIdentifier;
  zone_name?: WorkersZoneName;
};

export type WorkersDomainResponseCollection = WorkersApiResponseCommon & {
  result?: WorkersDomain[];
};

export type WorkersDomainResponseSingle = WorkersApiResponseCommon & {
  result?: WorkersDomain;
};

/**
 * Identifer of the Worker Domain.
 *
 * @example dbe10b4bc17c295377eabd600e1787fd
 * @x-auditable true
 */
export type WorkersDomainIdentifier = string;

/**
 * Optional environment if the Worker utilizes one.
 *
 * @example production
 * @x-auditable true
 */
export type WorkersEnvironment = string;

/**
 * Hashed script content, can be used in a If-None-Match header when updating.
 *
 * @example ea95132c15732412d22c1476fa83f27a
 */
export type WorkersEtag = string;

/**
 * Whether a Worker contains assets.
 *
 * @example false
 * @x-auditable true
 */
export type WorkersHasAssets = boolean;

/**
 * Whether a Worker contains modules.
 *
 * @example false
 * @x-auditable true
 */
export type WorkersHasModules = boolean;

/**
 * Hostname of the Worker Domain.
 *
 * @example foo.example.com
 * @x-auditable true
 */
export type WorkersHostname = string;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type WorkersIdentifier = string;

/**
 * Limits to apply for this Worker.
 */
export type WorkersLimits = {
  /**
   * The amount of CPU time this Worker can use in milliseconds.
   *
   * @example 50
   * @x-auditable true
   */
  cpu_ms?: number;
};

/**
 * Whether Logpush is turned on for the Worker.
 *
 * @default false
 * @example false
 * @x-auditable true
 */
export type WorkersLogpush = boolean;

export type WorkersManifestValue = {
  /**
   * The hash of the file.
   */
  hash: string;
  /**
   * The size of the file in bytes.
   */
  size: number;
};

export type WorkersMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

export type WorkersMigrationStep = {
  /**
   * A list of classes to delete Durable Object namespaces from.
   */
  deleted_classes?: string[];
  /**
   * A list of classes to create Durable Object namespaces from.
   */
  new_classes?: string[];
  /**
   * A list of classes to create Durable Object namespaces with SQLite from.
   */
  new_sqlite_classes?: string[];
  /**
   * A list of classes with Durable Object namespaces that were renamed.
   */
  renamed_classes?: {
    /**
     * @x-auditable true
     */
    from?: string;
    /**
     * @x-auditable true
     */
    to?: string;
  }[];
  /**
   * A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker.
   */
  transferred_classes?: {
    /**
     * @x-auditable true
     */
    from?: string;
    /**
     * @x-auditable true
     */
    from_script?: string;
    /**
     * @x-auditable true
     */
    to?: string;
  }[];
};

export type WorkersMigrationTagConditions = {
  /**
   * Tag to set as the latest migration tag.
   *
   * @example v2
   * @x-auditable true
   */
  new_tag?: string;
  /**
   * Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
   *
   * @example v1
   * @x-auditable true
   */
  old_tag?: string;
};

/**
 * When the script was last modified.
 *
 * @example 2017-01-01T00:00:00Z
 * @format date-time
 * @x-auditable true
 */
export type WorkersModifiedOn = string;

/**
 * @example {"files":["export default {\n  async fetch(request, env, ctx) {\n    return new Response(\"Hello, world!\");\n  }\n};"],"metadata":{"compatibility_date":{},"compatibility_flags":["nodejs_compat"],"main_module":"worker.js"}}
 */
export type WorkersMultipartScript = {
  /**
   * An array of modules (often JavaScript files) comprising a Worker script. At least one module must be present and referenced in the metadata as `main_module` or `body_part` by filename.<br/>Possible Content-Type(s) are: `application/javascript+module`, `text/javascript+module`, `application/javascript`, `text/javascript`, `application/wasm`, `text/plain`, `application/octet-stream`, `application/source-map`.
   *
   * @x-stainless-collection-type set
   */
  files?: Blob[];
  /**
   * JSON encoded metadata about the uploaded parts and Worker configuration.
   */
  metadata: {
    /**
     * Configuration for assets within a Worker.
     */
    assets?: {
      /**
       * Configuration for assets within a Worker.
       */
      config?: {
        /**
                 * The contents of a _headers file (used to attach custom headers on asset responses).
                 *
                 * @example /dashboard/*
                X-Frame-Options: DENY
                
                /static/*
                Access-Control-Allow-Origin: *
                 */
        _headers?: string;
        /**
                 * The contents of a _redirects file (used to apply redirects or proxy paths ahead of asset serving).
                 *
                 * @example /foo /bar 301
                /news/* /blog/:splat
                 */
        _redirects?: string;
        /**
         * Determines the redirects and rewrites of requests for HTML content.
         *
         * @example auto-trailing-slash
         */
        html_handling?:
          | "auto-trailing-slash"
          | "force-trailing-slash"
          | "drop-trailing-slash"
          | "none";
        /**
         * Determines the response when a request does not match a static asset, and there is no Worker script.
         *
         * @example 404-page
         */
        not_found_handling?: "none" | "404-page" | "single-page-application";
        run_worker_first?: string[] | boolean;
        /**
         * When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
         *
         * @deprecated true
         * @example true
         */
        serve_directly?: boolean;
      };
      /**
       * Token provided upon successful upload of all files from a registered manifest.
       *
       * @x-sensitive true
       */
      jwt?: string;
    };
    bindings?: WorkersBindings;
    /**
     * Name of the part in the multipart request that contains the script (e.g. the file adding a listener to the `fetch` event). Indicates a `service worker syntax` Worker.
     *
     * @example worker.js
     */
    body_part?: string;
    compatibility_date?: WorkersCompatibilityDate;
    compatibility_flags?: WorkersCompatibilityFlags;
    /**
     * Retain assets which exist for a previously uploaded Worker version; used in lieu of providing a completion token.
     *
     * @example false
     */
    keep_assets?: boolean;
    /**
     * List of binding types to keep from previous_upload.
     *
     * @x-stainless-collection-type set
     */
    keep_bindings?: string[];
    logpush?: WorkersLogpush;
    /**
     * Name of the part in the multipart request that contains the main module (e.g. the file exporting a `fetch` handler). Indicates a `module syntax` Worker.
     *
     * @example worker.js
     */
    main_module?: string;
    /**
     * Migrations to apply for Durable Objects associated with this Worker.
     */
    migrations?: WorkersSingleStepMigrations | WorkersMultipleStepMigrations;
    observability?: WorkersObservability;
    placement?: WorkersPlacementInfo;
    /**
     * List of strings to use as tags for this Worker.
     *
     * @x-stainless-collection-type set
     */
    tags?: string[];
    tail_consumers?: WorkersTailConsumers;
    usage_model?: WorkersUsageModel;
  };
};

export type WorkersMultipleStepMigrations = WorkersMigrationTagConditions & {
  /**
   * Migrations to apply in order.
   */
  steps?: WorkersMigrationStep[];
};

export type WorkersNamespace = {
  ["class"]?: string;
  id?: string;
  name?: string;
  script?: string;
  use_sqlite?: boolean;
};

export type WorkersNamespaceListResponse = WorkersApiResponseCommon & {
  result?: WorkersNamespaceResponse[];
};

export type WorkersNamespaceResponse = {
  created_by?: WorkersIdentifier;
  created_on?: WorkersCreatedOn;
  modified_by?: WorkersIdentifier;
  modified_on?: WorkersModifiedOn;
  namespace_id?: WorkersUuid;
  namespace_name?: WorkersDispatchNamespaceName;
  script_count?: WorkersScriptCount;
};

/**
 * Details about a worker uploaded to a Workers for Platforms namespace.
 */
export type WorkersNamespaceScriptResponse = {
  created_on?: WorkersCreatedOn;
  dispatch_namespace?: WorkersDispatchNamespaceName;
  modified_on?: WorkersModifiedOn;
  script?: WorkersScriptResponse;
};

export type WorkersNamespaceScriptResponseSingle = WorkersApiResponseCommon & {
  result: WorkersNamespaceScriptResponse;
};

export type WorkersNamespaceSingleResponse = WorkersApiResponseCommon & {
  result?: WorkersNamespaceResponse;
};

/**
 * Namespace identifier tag.
 *
 * @example 0f2ac74b498b48028cb68387c421e279
 * @maxLength 32
 * @x-auditable true
 */
export type WorkersNamespaceIdentifier = string;

export type WorkersObject = {
  /**
   * Whether the Durable Object has stored data.
   *
   * @example true
   */
  hasStoredData?: boolean;
  /**
   * ID of the Durable Object.
   *
   * @example fe7803fc55b964e09d94666545aab688d360c6bda69ba349ced1e5f28d2fc2c8
   */
  id?: string;
};

/**
 * Observability settings for the Worker.
 */
export type WorkersObservability = {
  /**
   * Whether observability is enabled for the Worker.
   *
   * @example true
   * @x-auditable true
   */
  enabled: boolean;
  /**
   * The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
   *
   * @example 0.1
   * @x-auditable true
   */
  head_sampling_rate?: number | null;
  /**
   * Log settings for the Worker.
   */
  logs?: {
    /**
     * Whether logs are enabled for the Worker.
     *
     * @example true
     * @x-auditable true
     */
    enabled: boolean;
    /**
     * The sampling rate for logs. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
     *
     * @example 0.1
     * @x-auditable true
     */
    head_sampling_rate?: number | null;
    /**
     * Whether [invocation logs](https://developers.cloudflare.com/workers/observability/logs/workers-logs/#invocation-logs) are enabled for the Worker.
     *
     * @example true
     * @x-auditable true
     */
    invocation_logs: boolean;
  } | null;
};

/**
 * Configuration for [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
 */
export type WorkersPlacementInfo = {
  /**
   * The last time the script was analyzed for [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
   *
   * @example 2025-01-01T00:00:00Z
   * @format date-time
   */
  last_analyzed_at?: string;
  mode?: WorkersPlacementMode;
  status?: WorkersPlacementStatus;
};

/**
 * Configuration for [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
 */
export type WorkersPlacementInfoNoStatus = {
  mode?: WorkersPlacementMode;
};

/**
 * Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
 *
 * @x-auditable true
 */
export type WorkersPlacementMode = "smart";

/**
 * Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
 *
 * @x-auditable true
 */
export type WorkersPlacementStatus =
  | "SUCCESS"
  | "UNSUPPORTED_APPLICATION"
  | "INSUFFICIENT_INVOCATIONS";

export type WorkersRoute = {
  /**
   * Identifier.
   *
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   * @maxLength 32
   * @x-auditable true
   */
  id: WorkersIdentifier;
  /**
   * Pattern to match incoming requests against. [Learn more](https://developers.cloudflare.com/workers/configuration/routing/routes/#matching-behavior).
   *
   * @example example.com/*
   * @x-auditable true
   */
  pattern: string;
  /**
   * Name of the script to run if the route matches.
   *
   * @example my-workers-script
   * @x-auditable true
   */
  script?: string;
};

export type WorkersSchedule = {
  /**
   * @x-auditable true
   */
  created_on?: string;
  /**
   * @example [see original specs]
   * @x-auditable true
   */
  cron: string;
  modified_on?: string;
};

/**
 * Worker environment associated with the zone and hostname.
 *
 * @example production
 * @x-auditable true
 */
export type WorkersSchemasEnvironment = string;

/**
 * ID of the namespace.
 *
 * @example 5fd1cafff895419c8bcc647fc64ab8f0
 */
export type WorkersSchemasId = string;

/**
 * Name of the script.
 *
 * @example this-is_my_script-01
 * @pattern ^[a-z0-9_][a-z0-9-_]*$
 */
export type WorkersSchemasScriptName = string;

/**
 * Worker service associated with the zone and hostname.
 *
 * @example foo
 * @x-auditable true
 */
export type WorkersSchemasService = string;

export type WorkersSchemasSubdomain = {
  /**
   * @example my-subdomain
   */
  subdomain: string;
};

export type WorkersScriptAndVersionSettingsItem = {
  /**
   * List of bindings attached to a Worker. You can find more about bindings on our docs: https://developers.cloudflare.com/workers/configuration/multipart-upload-metadata/#bindings.
   *
   * @example {"name":"MY_ENV_VAR","text":"my_data","type":"plain_text"}
   * @x-stainless-collection-type set
   */
  bindings?: WorkersBindings & WorkersBindingItem[];
  /**
   * Date indicating targeted support in the Workers runtime. Backwards incompatible fixes to the runtime following this date will not affect this Worker.
   *
   * @example 2021-01-01
   * @x-auditable true
   * @default
   */
  compatibility_date?: WorkersCompatibilityDate & string;
  /**
   * Flags that enable or disable certain features in the Workers runtime. Used to enable upcoming features or opt in or out of specific changes not included in a `compatibility_date`.
   *
   * @example nodejs_compat
   * @x-stainless-collection-type set
   */
  compatibility_flags?: WorkersCompatibilityFlags & string[];
  limits?: WorkersLimits;
  logpush?: WorkersLogpush;
  /**
   * Migrations to apply for Durable Objects associated with this Worker.
   */
  migrations?: WorkersSingleStepMigrations | WorkersMultipleStepMigrations;
  observability?: WorkersObservability;
  /**
   * Configuration for [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
   *
   * @default {}
   */
  placement?: WorkersPlacementInfoNoStatus & Record<string, any>;
  /**
   * Tags to help you manage your Workers.
   *
   * @x-stainless-collection-type set
   */
  tags?: WorkersTags & string[];
  /**
   * List of Workers that will consume logs from the attached Worker.
   *
   * @x-stainless-collection-type set
   */
  tail_consumers?: WorkersTailConsumers & WorkersTailConsumersScript[];
  usage_model?: WorkersUsageModel;
};

export type WorkersScriptAndVersionSettingsResponse =
  WorkersApiResponseCommon & {
    result: WorkersScriptAndVersionSettingsItem;
  };

export type WorkersScriptResponse = {
  created_on?: WorkersCreatedOn;
  etag?: WorkersEtag;
  has_assets?: WorkersHasAssets;
  has_modules?: WorkersHasModules;
  /**
   * The id of the script in the Workers system. Usually the script name.
   *
   * @example my-workers-script
   * @x-auditable true
   */
  id?: string;
  logpush?: WorkersLogpush;
  modified_on?: WorkersModifiedOn;
  placement?: WorkersPlacementInfo;
  /**
   * Enables [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
   *
   * @x-auditable true
   * @deprecated true
   */
  placement_mode?: WorkersPlacementMode & string;
  /**
   * Status of [Smart Placement](https://developers.cloudflare.com/workers/configuration/smart-placement).
   *
   * @x-auditable true
   * @deprecated true
   */
  placement_status?: WorkersPlacementStatus & string;
  tail_consumers?: WorkersTailConsumers;
  usage_model?: WorkersUsageModel;
};

export type WorkersScriptResponseCollection = WorkersApiResponseCommon & {
  result: WorkersScriptResponse[];
};

export type WorkersScriptResponseSingle = WorkersApiResponseSingle & {
  result: WorkersScriptResponse;
};

export type WorkersScriptResponseUpload = WorkersScriptResponse & {
  /**
   * @example 10
   * @x-auditable true
   */
  startup_time_ms: number;
};

export type WorkersScriptResponseUploadSingle = WorkersApiResponseCommon & {
  result: WorkersScriptResponseUpload;
};

export type WorkersScriptSettingsItem = {
  logpush?: WorkersLogpush;
  /**
   * Observability settings for the Worker.
   *
   * @x-auditable true
   */
  observability?: WorkersObservability & (Record<string, any> | null);
  /**
   * List of Workers that will consume logs from the attached Worker.
   *
   * @x-stainless-collection-type set
   */
  tail_consumers?: WorkersTailConsumersScript[] | null;
};

export type WorkersScriptSettingsResponse = WorkersApiResponseCommon & {
  result: WorkersScriptSettingsItem;
};

/**
 * The current number of scripts in this Dispatch Namespace.
 *
 * @example 800
 */
export type WorkersScriptCount = number;

/**
 * Name of the script, used in URLs and route configuration.
 *
 * @example this-is_my_script-01
 * @pattern ^[a-z0-9_][a-z0-9-_]*$
 * @x-auditable true
 */
export type WorkersScriptName = string;

/**
 * A secret value accessible through a binding.
 */
export type WorkersSecret =
  | WorkersBindingKindSecretText
  | WorkersBindingKindSecretKey;

/**
 * A JavaScript variable name for the secret binding.
 *
 * @example mySecret
 * @x-auditable true
 */
export type WorkersSecretName = string;

/**
 * Name of Worker to bind to.
 *
 * @example my-worker
 * @x-auditable true
 */
export type WorkersService = string;

/**
 * A single set of migrations to apply.
 */
export type WorkersSingleStepMigrations = WorkersMigrationTagConditions &
  WorkersMigrationStep;

export type WorkersSubdomain = {
  /**
   * Whether the Worker is available on the workers.dev subdomain.
   *
   * @example true
   * @x-auditable true
   */
  enabled: boolean;
  /**
   * Whether the Worker's Preview URLs are available on the workers.dev subdomain.
   *
   * @example true
   * @x-auditable true
   */
  previews_enabled: boolean;
};

/**
 * Tag to help you manage your Worker.
 *
 * @example my-tag
 * @x-auditable true
 */
export type WorkersTag = string;

/**
 * Tags to help you manage your Workers.
 *
 * @x-stainless-collection-type set
 */
export type WorkersTags = WorkersTag[];

export type WorkersTail = {
  expires_at: string;
  /**
   * Identifier.
   *
   * @example 023e105f4ecef8ad9ca31a8372d0c353
   * @maxLength 32
   * @x-auditable true
   */
  id: WorkersIdentifier;
  url: string;
};

/**
 * List of Workers that will consume logs from the attached Worker.
 *
 * @x-stainless-collection-type set
 */
export type WorkersTailConsumers = WorkersTailConsumersScript[];

/**
 * A reference to a script that will consume logs from the attached Worker.
 */
export type WorkersTailConsumersScript = {
  /**
   * Optional environment if the Worker utilizes one.
   *
   * @example production
   * @x-auditable true
   */
  environment?: string;
  /**
   * Optional dispatch namespace the script belongs to.
   *
   * @example my-namespace
   * @x-auditable true
   */
  namespace?: string;
  /**
   * Name of Worker that is to be the consumer.
   *
   * @example my-log-consumer
   * @x-auditable true
   */
  service: string;
};

export type WorkersUploadAssetsResponse = WorkersApiResponseCommon & {
  /**
   * @maxProperties 0
   */
  result?: {};
};

export type WorkersUsageModelResponse = WorkersApiResponseCommon & {
  result: {
    usage_model?: WorkersUsageModel;
  };
};

/**
 * Usage model for the Worker invocations.
 *
 * @default standard
 * @example standard
 * @x-auditable true
 */
export type WorkersUsageModel = "standard";

/**
 * API Resource UUID tag.
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 * @x-auditable true
 */
export type WorkersUuid = string;

export type WorkersVersionItemFull = WorkersVersionItemShort & {
  /**
   * @example {"bindings":[{"json":"example_binding","name":"JSON_VAR","type":"json"}],"script":{"etag":"13a3240e8fb414561b0366813b0b8f42b3e6cfa0d9e70e99835dae83d0d8a794","handlers":["fetch"],"last_deployed_from":"api"},"script_runtime":{"usage_model":"standard"}}
   */
  resources: {
    /**
     * List of bindings attached to a Worker. You can find more about bindings on our docs: https://developers.cloudflare.com/workers/configuration/multipart-upload-metadata/#bindings.
     *
     * @example {"name":"MY_ENV_VAR","text":"my_data","type":"plain_text"}
     * @x-stainless-collection-type set
     */
    bindings?: WorkersBindings & void;
    /**
     * @example {"etag":"13a3240e8fb414561b0366813b0b8f42b3e6cfa0d9e70e99835dae83d0d8a794","handlers":["fetch"],"last_deployed_from":"api","named_handlers":[{"handlers":["fetch"],"name":"MyClass"}]}
     */
    script?: {
      /**
       * @example 13a3240e8fb414561b0366813b0b8f42b3e6cfa0d9e70e99835dae83d0d8a794
       */
      etag?: string;
      /**
       * @example fetch
       * @x-stainless-collection-type set
       */
      handlers?: string[];
      /**
       * @example api
       */
      last_deployed_from?: string;
      /**
       * @example {"handlers":["fetch"],"name":"MyClass"}
       * @x-stainless-collection-type set
       */
      named_handlers?: {
        /**
         * @example fetch
         * @x-stainless-collection-type set
         */
        handlers?: string[];
        /**
         * @example MyClass
         */
        name?: string;
      }[];
    };
    script_runtime?: {
      /**
       * @example 2022-11-08
       */
      compatibility_date?: string;
      /**
       * @x-stainless-collection-type set
       */
      compatibility_flags?: string[];
      /**
       * @example {"cpu_ms":50}
       */
      limits?: {
        /**
         * @example 50
         */
        cpu_ms?: number;
      };
      /**
       * @example v1
       */
      migration_tag?: string;
      /**
       * @example standard
       */
      usage_model?: "bundled" | "unbound" | "standard";
    };
  };
};

export type WorkersVersionItemShort = {
  /**
   * @example 18f97339-c287-4872-9bdd-e2135c07ec12
   */
  id?: string;
  /**
   * @example {"author_email":"user@example.com","author_id":"408cbcdfd4dda4617efef40b04d168a1","created_on":"2022-11-08T17:19:29.176266Z","modified_on":"2022-11-08T17:19:29.176266Z","source":"api"}
   */
  metadata?: {
    /**
     * @example user@example.com
     */
    author_email?: string;
    /**
     * @example 408cbcdfd4dda4617efef40b04d168a1
     */
    author_id?: string;
    /**
     * @example 2022-11-08T17:19:29.176266Z
     */
    created_on?: string;
    hasPreview?: boolean;
    /**
     * @example 2022-11-08T17:19:29.176266Z
     */
    modified_on?: string;
    /**
     * @example api
     */
    source?:
      | "unknown"
      | "api"
      | "wrangler"
      | "terraform"
      | "dash"
      | "dash_template"
      | "integration"
      | "quick_editor"
      | "playground"
      | "workersci";
  };
  /**
   * @example 1
   */
  number?: number;
};

export type WorkersVersionItemUploaded = WorkersVersionItemFull & {
  /**
   * @example 10
   */
  startup_time_ms?: number;
};

/**
 * @example bcf48806-b317-4351-9ee7-36e7d557d4de
 * @maxLength 36
 */
export type WorkersVersionIdentifier = string;

export type WorkersVersionsListResponse = WorkersApiResponseCommon & {
  result: {
    items?: WorkersVersionItemShort[];
  };
};

export type WorkersVersionsSingleResponse = WorkersApiResponseCommon & {
  result: WorkersVersionItemFull;
};

export type WorkersVersionsUploadResponse = WorkersApiResponseCommon & {
  result: WorkersVersionItemUploaded;
};

/**
 * Identifier of the zone.
 *
 * @example 593c9c94de529bbbfaac7c53ced0447d
 * @x-auditable true
 */
export type WorkersZoneIdentifier = string;

/**
 * Name of the zone.
 *
 * @example example.com
 * @x-auditable true
 */
export type WorkersZoneName = string;

export type ZarazApiResponseCommon = {
  errors: ZarazMessages;
  messages: ZarazMessages;
  /**
   * Whether the API call was successful
   *
   * @example true
   * @x-auditable true
   */
  success: boolean;
};

export type ZarazApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: ZarazMessages;
  messages: ZarazMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type ZarazBaseMc = ZarazBaseTool & {
  /**
   * Actions configured on a tool. Either this or neoEvents field is required.
   */
  actions?: {
    [key: string]: {
      /**
       * Tool event type
       *
       * @x-auditable true
       */
      actionType: string;
      /**
       * List of blocking triggers IDs
       */
      blockingTriggers: string[];
      /**
       * Event payload
       */
      data: Record<string, any>;
      /**
       * List of firing triggers IDs
       *
       * @minItems 1
       */
      firingTriggers: string[];
    };
  };
  /**
   * Tool's internal name
   *
   * @x-auditable true
   */
  component: string;
  /**
   * DEPRECATED - List of actions configured on a tool. Either this or actions field is required. If both are present, actions field will take precedence.
   */
  neoEvents?: {
    /**
     * Tool event type
     *
     * @x-auditable true
     */
    actionType: string;
    /**
     * List of blocking triggers IDs
     */
    blockingTriggers: string[];
    /**
     * Event payload
     */
    data: Record<string, any>;
    /**
     * List of firing triggers IDs
     *
     * @minItems 1
     */
    firingTriggers: string[];
  }[];
  /**
   * List of permissions granted to the component
   */
  permissions: string[];
  /**
   * Tool's settings
   */
  settings: {
    [key: string]: string | boolean;
  };
};

export type ZarazBaseTool = {
  /**
   * List of blocking trigger IDs
   */
  blockingTriggers: string[];
  /**
   * Default fields for tool's actions
   */
  defaultFields: {
    [key: string]: string | boolean;
  };
  /**
   * Default consent purpose ID
   *
   * @x-auditable true
   */
  defaultPurpose?: string;
  /**
   * Whether tool is enabled
   *
   * @x-auditable true
   */
  enabled: boolean;
  /**
   * Tool's name defined by the user
   *
   * @x-auditable true
   */
  name: string;
  /**
   * Vendor name for TCF compliant consent modal, required for Custom Managed Components and Custom HTML tool with a defaultPurpose assigned
   *
   * @x-auditable true
   */
  vendorName?: string;
  /**
   * Vendor's Privacy Policy URL for TCF compliant consent modal, required for Custom Managed Components and Custom HTML tool with a defaultPurpose assigned
   *
   * @x-auditable true
   */
  vendorPolicyUrl?: string;
};

export type ZarazClickListenerRule = {
  /**
   * @x-auditable true
   */
  action: "clickListener";
  /**
   * @x-auditable true
   */
  id: string;
  settings: {
    /**
     * @x-auditable true
     */
    selector: string;
    /**
     * @x-auditable true
     */
    type: "xpath" | "css";
    /**
     * @minimum 0
     * @x-auditable true
     */
    waitForTags: number;
  };
};

export type ZarazCustomManagedComponent = ZarazBaseMc & {
  type: "custom-mc";
  /**
   * Cloudflare worker that acts as a managed component
   */
  worker: {
    /**
     * @x-auditable true
     */
    escapedWorkerName: string;
    /**
     * @x-auditable true
     */
    workerTag: string;
  };
};

export type ZarazElementVisibilityRule = {
  /**
   * @x-auditable true
   */
  action: "elementVisibility";
  /**
   * @x-auditable true
   */
  id: string;
  settings: {
    /**
     * @x-auditable true
     */
    selector: string;
  };
};

export type ZarazFormSubmissionRule = {
  /**
   * @x-auditable true
   */
  action: "formSubmission";
  /**
   * @x-auditable true
   */
  id: string;
  settings: {
    /**
     * @x-auditable true
     */
    selector: string;
    /**
     * @x-auditable true
     */
    validate: boolean;
  };
};

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type ZarazIdentifier = string;

export type ZarazLoadRule = {
  /**
   * @x-auditable true
   */
  id: string;
  /**
   * @x-auditable true
   */
  match: string;
  /**
   * @x-auditable true
   */
  op:
    | "CONTAINS"
    | "EQUALS"
    | "STARTS_WITH"
    | "ENDS_WITH"
    | "MATCH_REGEX"
    | "NOT_MATCH_REGEX"
    | "GREATER_THAN"
    | "GREATER_THAN_OR_EQUAL"
    | "LESS_THAN"
    | "LESS_THAN_OR_EQUAL";
  /**
   * @x-auditable true
   */
  value: string;
};

export type ZarazManagedComponent = ZarazBaseMc & {
  type: "component";
};

export type ZarazMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

export type ZarazScrollDepthRule = {
  /**
   * @x-auditable true
   */
  action: "scrollDepth";
  /**
   * @x-auditable true
   */
  id: string;
  settings: {
    /**
     * @x-auditable true
     */
    positions: string;
  };
};

export type ZarazSecretVariable = {
  /**
   * @x-auditable true
   */
  name: string;
  /**
   * @x-auditable true
   */
  type: "secret";
  /**
   * @x-auditable true
   * @x-sensitive true
   */
  value: string;
};

export type ZarazStringVariable = {
  /**
   * @x-auditable true
   */
  name: string;
  /**
   * @x-auditable true
   */
  type: "string";
  /**
   * @x-auditable true
   */
  value: string;
};

export type ZarazTimerRule = {
  /**
   * @x-auditable true
   */
  action: "timer";
  /**
   * @x-auditable true
   */
  id: string;
  settings: {
    /**
     * @minimum 50
     * @x-auditable true
     */
    interval: number;
    /**
     * @minimum 0
     * @x-auditable true
     */
    limit: number;
  };
};

export type ZarazVariableMatchRule = {
  /**
   * @x-auditable true
   */
  action: "variableMatch";
  /**
   * @x-auditable true
   */
  id: string;
  settings: {
    /**
     * @x-auditable true
     */
    match: string;
    /**
     * @x-auditable true
     */
    variable: string;
  };
};

export type ZarazWorkerVariable = {
  /**
   * @x-auditable true
   */
  name: string;
  /**
   * @x-auditable true
   */
  type: "worker";
  value: {
    /**
     * @x-auditable true
     */
    escapedWorkerName: string;
    /**
     * @x-auditable true
     */
    workerTag: string;
  };
};

/**
 * Zaraz configuration
 *
 * @example {"consent":{"cookieName":"zaraz-consent","customIntroDisclaimerDismissed":true,"enabled":false},"dataLayer":true,"debugKey":"my-debug-key","settings":{"autoInjectScript":true,"ecommerce":true,"initPath":"/i"},"tools":{"aJvt":{"actions":{"hrnc":{"actionType":"pageview","blockingTriggers":[],"data":{"__zaraz_setting_name":"Page view","ev":"PageView"},"firingTriggers":["Pageview"]}},"component":"facebook-pixel","defaultFields":{"testKey":"TEST123456"},"enabled":true,"name":"Facebook Pixel","permissions":["access_client_kv"],"settings":{"accessToken":"ABcdEFg","ecommerce":true,"property":"12345"},"type":"component"}},"triggers":{"ktBn":{"Pageview":{"clientRules":[],"description":"All page loads","excludeRules":[],"loadRules":[{"match":"{{ client.__zarazTrack }}","op":"EQUALS","value":"Pageview"}],"name":"Pageview","system":"pageload"}}},"variables":{"Autd":{"name":"ip","type":"string","value":"{{ system.device.ip }}"}},"zarazVersion":43}
 */
export type ZarazZarazConfigBase = {
  /**
   * Cloudflare Monitoring settings.
   */
  analytics?: {
    /**
     * Consent purpose assigned to Monitoring.
     *
     * @x-auditable true
     */
    defaultPurpose?: string;
    /**
     * Whether Advanced Monitoring reports are enabled.
     *
     * @x-auditable true
     */
    enabled?: boolean;
    /**
     * Session expiration time (seconds).
     *
     * @maximum 86400
     * @minimum 60
     * @x-auditable true
     */
    sessionExpTime?: number;
  };
  /**
   * Consent management configuration.
   */
  consent?: {
    buttonTextTranslations?: {
      /**
       * Object where keys are language codes
       */
      accept_all: {
        [key: string]: string;
      };
      /**
       * Object where keys are language codes
       */
      confirm_my_choices: {
        [key: string]: string;
      };
      /**
       * Object where keys are language codes
       */
      reject_all: {
        [key: string]: string;
      };
    };
    /**
     * @x-auditable true
     */
    companyEmail?: string;
    /**
     * @x-auditable true
     */
    companyName?: string;
    /**
     * @x-auditable true
     */
    companyStreetAddress?: string;
    /**
     * @x-auditable true
     */
    consentModalIntroHTML?: string;
    /**
     * Object where keys are language codes
     */
    consentModalIntroHTMLWithTranslations?: {
      [key: string]: string;
    };
    /**
     * @x-auditable true
     */
    cookieName?: string;
    /**
     * @x-auditable true
     */
    customCSS?: string;
    /**
     * @x-auditable true
     */
    customIntroDisclaimerDismissed?: boolean;
    /**
     * @x-auditable true
     */
    defaultLanguage?: string;
    enabled: boolean;
    /**
     * @x-auditable true
     */
    hideModal?: boolean;
    /**
     * Object where keys are purpose alpha-numeric IDs
     */
    purposes?: {
      [key: string]: {
        /**
         * @x-auditable true
         */
        description: string;
        /**
         * @x-auditable true
         */
        name: string;
      };
    };
    /**
     * Object where keys are purpose alpha-numeric IDs
     */
    purposesWithTranslations?: {
      [key: string]: {
        /**
         * Object where keys are language codes
         */
        description: {
          [key: string]: string;
        };
        /**
         * Object where keys are language codes
         */
        name: {
          [key: string]: string;
        };
        /**
         * @x-auditable true
         */
        order: number;
      };
    };
    tcfCompliant?: boolean;
  };
  /**
   * Data layer compatibility mode enabled.
   *
   * @x-auditable true
   */
  dataLayer: boolean;
  /**
   * The key for Zaraz debug mode.
   *
   * @x-auditable true
   */
  debugKey: string;
  /**
   * Single Page Application support enabled.
   *
   * @x-auditable true
   */
  historyChange?: boolean;
  /**
   * General Zaraz settings.
   */
  settings: {
    /**
     * Automatic injection of Zaraz scripts enabled.
     *
     * @x-auditable true
     */
    autoInjectScript: boolean;
    /**
     * Details of the worker that receives and edits Zaraz Context object.
     */
    contextEnricher?: {
      /**
       * @x-auditable true
       */
      escapedWorkerName: string;
      /**
       * @x-auditable true
       */
      workerTag: string;
    };
    /**
     * The domain Zaraz will use for writing and reading its cookies.
     *
     * @x-auditable true
     */
    cookieDomain?: string;
    /**
     * Ecommerce API enabled.
     *
     * @x-auditable true
     */
    ecommerce?: boolean;
    /**
     * Custom endpoint for server-side track events.
     *
     * @x-auditable true
     */
    eventsApiPath?: string;
    /**
     * Hiding external referrer URL enabled.
     *
     * @x-auditable true
     */
    hideExternalReferer?: boolean;
    /**
     * Trimming IP address enabled.
     *
     * @x-auditable true
     */
    hideIPAddress?: boolean;
    /**
     * Removing URL query params enabled.
     *
     * @x-auditable true
     */
    hideQueryParams?: boolean;
    /**
     * Removing sensitive data from User Aagent string enabled.
     */
    hideUserAgent?: boolean;
    /**
     * Custom endpoint for Zaraz init script.
     *
     * @x-auditable true
     */
    initPath?: string;
    /**
     * Injection of Zaraz scripts into iframes enabled.
     *
     * @x-auditable true
     */
    injectIframes?: boolean;
    /**
     * Custom path for Managed Components server functionalities.
     *
     * @x-auditable true
     */
    mcRootPath?: string;
    /**
     * Custom endpoint for Zaraz main script.
     *
     * @x-auditable true
     */
    scriptPath?: string;
    /**
     * Custom endpoint for Zaraz tracking requests.
     *
     * @x-auditable true
     */
    trackPath?: string;
  };
  /**
   * Triggers set up under Zaraz configuration, where key is the trigger alpha-numeric ID and value is the trigger configuration.
   */
  triggers: {
    [key: string]: {
      /**
       * Trigger description.
       *
       * @x-auditable true
       */
      description?: string;
      /**
       * Rules defining when the trigger is not fired.
       */
      excludeRules: (
        | ZarazLoadRule
        | ZarazClickListenerRule
        | ZarazTimerRule
        | ZarazFormSubmissionRule
        | ZarazVariableMatchRule
        | ZarazScrollDepthRule
        | ZarazElementVisibilityRule
      )[];
      /**
       * Rules defining when the trigger is fired.
       */
      loadRules: (
        | ZarazLoadRule
        | ZarazClickListenerRule
        | ZarazTimerRule
        | ZarazFormSubmissionRule
        | ZarazVariableMatchRule
        | ZarazScrollDepthRule
        | ZarazElementVisibilityRule
      )[];
      /**
       * Trigger name.
       *
       * @x-auditable true
       */
      name: string;
      /**
       * @x-auditable true
       */
      system?: "pageload";
    };
  };
  /**
   * Variables set up under Zaraz configuration, where key is the variable alpha-numeric ID and value is the variable configuration. Values of variables of type secret are not included.
   */
  variables: {
    [key: string]:
      | ZarazStringVariable
      | ZarazSecretVariable
      | ZarazWorkerVariable;
  };
  /**
   * Zaraz internal version of the config.
   *
   * @x-auditable true
   */
  zarazVersion: number;
};

/**
 * Zaraz configuration
 *
 * @example {"consent":{"cookieName":"zaraz-consent","customIntroDisclaimerDismissed":true,"enabled":false},"dataLayer":true,"debugKey":"my-debug-key","settings":{"autoInjectScript":true,"ecommerce":true,"initPath":"/i"},"tools":{"aJvt":{"actions":{"hrnc":{"actionType":"pageview","blockingTriggers":[],"data":{"__zaraz_setting_name":"Page view","ev":"PageView"},"firingTriggers":["Pageview"]}},"component":"facebook-pixel","defaultFields":{"testKey":"TEST123456"},"enabled":true,"name":"Facebook Pixel","permissions":["access_client_kv"],"settings":{"accessToken":"ABcdEFg","ecommerce":true,"property":"12345"},"type":"component"}},"triggers":{"ktBn":{"Pageview":{"clientRules":[],"description":"All page loads","excludeRules":[],"loadRules":[{"match":"{{ client.__zarazTrack }}","op":"EQUALS","value":"Pageview"}],"name":"Pageview","system":"pageload"}}},"variables":{"Autd":{"name":"ip","type":"string","value":"{{ system.device.ip }}"}},"zarazVersion":43}
 */
export type ZarazZarazConfigBody = ZarazZarazConfigBase & {
  /**
   * Tools set up under Zaraz configuration, where key is the alpha-numeric tool ID and value is the tool configuration object.
   */
  tools?: {
    [key: string]: ZarazManagedComponent | ZarazCustomManagedComponent;
  };
};

export type ZarazZarazConfigHistoryResponse = ZarazApiResponseCommon & {
  /**
   * Object where keys are numericc onfiguration IDs
   *
   * @example {"12345":{"config":{"consent":{"cookieName":"zaraz-consent","customIntroDisclaimerDismissed":true,"enabled":false},"dataLayer":true,"debugKey":"my-debug-key","settings":{"autoInjectScript":true},"tools":{"aJvt":{"component":"facebook-pixel","defaultFields":{"testKey":"TEST123456"},"enabled":true,"name":"Facebook Pixel","neoEvents":[{"actionType":"pageview","blockingTriggers":[],"data":{"__zaraz_setting_name":"Page view","ev":"PageView"},"firingTriggers":["Pageview"]}],"permissions":["access_client_kv"],"settings":{"accessToken":"ABcdEFg","ecommerce":true,"property":"12345"},"type":"component"}},"triggers":{"ktBn":{"Pageview":{"clientRules":[],"description":"All page loads","excludeRules":[],"loadRules":[{"match":"{{ client.__zarazTrack }}","op":"EQUALS","value":"Pageview"}],"name":"Pageview","system":"pageload"}}},"variables":{"Autd":{"name":"ip","type":"string","value":"{{ system.device.ip }}"}},"zarazVersion":43},"createdAt":"2023-02-23T05:05:55.155273Z","id":12345,"updatedAt":"2023-02-23T05:05:55.155273Z","userId":"278d0d0g123cd8e49d45ea64f12faa37"},"23456":null}
   */
  result?: {
    [key: string]: ZarazZarazConfigRowBase &
      ({
        config: ZarazZarazConfigReturn;
      } | null);
  };
};

export type ZarazZarazConfigResponse = ZarazApiResponseCommon & {
  result?: ZarazZarazConfigReturn;
};

/**
 * Zaraz configuration
 *
 * @example {"consent":{"cookieName":"zaraz-consent","customIntroDisclaimerDismissed":true,"enabled":false},"dataLayer":true,"debugKey":"my-debug-key","settings":{"autoInjectScript":true,"ecommerce":true,"initPath":"/i"},"tools":{"aJvt":{"actions":{"hrnc":{"actionType":"pageview","blockingTriggers":[],"data":{"__zaraz_setting_name":"Page view","ev":"PageView"},"firingTriggers":["Pageview"]}},"component":"facebook-pixel","defaultFields":{"testKey":"TEST123456"},"enabled":true,"name":"Facebook Pixel","permissions":["access_client_kv"],"settings":{"accessToken":"ABcdEFg","ecommerce":true,"property":"12345"},"type":"component"}},"triggers":{"ktBn":{"Pageview":{"clientRules":[],"description":"All page loads","excludeRules":[],"loadRules":[{"match":"{{ client.__zarazTrack }}","op":"EQUALS","value":"Pageview"}],"name":"Pageview","system":"pageload"}}},"variables":{"Autd":{"name":"ip","type":"string","value":"{{ system.device.ip }}"}},"zarazVersion":43}
 */
export type ZarazZarazConfigReturn = ZarazZarazConfigBase & {
  /**
   * Tools set up under Zaraz configuration, where key is the alpha-numeric tool ID and value is the tool configuration object.
   */
  tools?: {
    [key: string]: ZarazManagedComponent | ZarazCustomManagedComponent;
  };
};

export type ZarazZarazConfigRowBase = {
  /**
   * Date and time the configuration was created
   *
   * @format date-time
   * @x-auditable true
   */
  createdAt: string;
  /**
   * ID of the configuration
   *
   * @x-auditable true
   */
  id: number;
  /**
   * Date and time the configuration was last updated
   *
   * @format date-time
   * @x-auditable true
   */
  updatedAt: string;
  /**
   * Alpha-numeric ID of the account user who published the configuration
   *
   * @x-auditable true
   */
  userId: string;
};

export type ZarazZarazHistoryResponse = ZarazApiResponseCommon & {
  result?: (ZarazZarazConfigRowBase & {
    /**
     * Configuration description provided by the user who published this configuration
     */
    description: string;
  })[];
};

/**
 * Zaraz workflow
 *
 * @x-auditable true
 */
export type ZarazZarazWorkflow = "realtime" | "preview";

export type ZarazZarazWorkflowResponse = ZarazApiResponseCommon & {
  result?: ZarazZarazWorkflow;
};

export type ZarazZoneIdentifier = ZarazIdentifier;

export type ZeroTrustGatewayAccountLogOptions = {
  /**
   * Log all requests to this service.
   *
   * @default false
   * @example false
   * @x-auditable true
   */
  log_all?: boolean;
  /**
   * Log only blocking requests to this service.
   *
   * @default false
   * @example true
   * @x-auditable true
   */
  log_blocks?: boolean;
};

/**
 * The action to preform when the associated traffic, identity, and device posture expressions are either absent or evaluate to `true`.
 *
 * @example allow
 * @x-auditable true
 */
export type ZeroTrustGatewayAction =
  | "on"
  | "off"
  | "allow"
  | "block"
  | "scan"
  | "noscan"
  | "safesearch"
  | "ytrestricted"
  | "isolate"
  | "noisolate"
  | "override"
  | "l4_override"
  | "egress"
  | "resolve"
  | "quarantine"
  | "redirect";

/**
 * Activity log settings.
 */
export type ZeroTrustGatewayActivityLogSettings = {
  /**
   * Enable activity logging.
   *
   * @example true
   * @x-auditable true
   */
  enabled?: boolean;
} | null;

/**
 * Anti-virus settings.
 */
export type ZeroTrustGatewayAntiVirusSettings = {
  enabled_download_phase?: ZeroTrustGatewayEnabledDownloadPhase;
  enabled_upload_phase?: ZeroTrustGatewayEnabledUploadPhase;
  fail_closed?: ZeroTrustGatewayFailClosed;
  notification_settings?: ZeroTrustGatewayNotificationSettings;
} | null;

export type ZeroTrustGatewayApiResponseCollection =
  ZeroTrustGatewayApiResponseCommon & {
    result_info?: ZeroTrustGatewayResultInfo;
  };

export type ZeroTrustGatewayApiResponseCommon = {
  errors: ZeroTrustGatewayMessages;
  messages: ZeroTrustGatewayMessages;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type ZeroTrustGatewayApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: ZeroTrustGatewayMessages;
  messages: ZeroTrustGatewayMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

export type ZeroTrustGatewayApiResponseSingle =
  ZeroTrustGatewayApiResponseCommon;

export type ZeroTrustGatewayAppTypes =
  | ZeroTrustGatewayApplication
  | ZeroTrustGatewayApplicationType;

/**
 * The name of the application or application type.
 *
 * @example Facebook
 * @x-auditable true
 */
export type ZeroTrustGatewayAppTypesComponentsSchemasName = string;

export type ZeroTrustGatewayAppTypesComponentsSchemasResponseCollection =
  ZeroTrustGatewayApiResponseCollection & {
    result?: ZeroTrustGatewayAppTypes[];
  };

/**
 * The identifier for this application. There is only one application per ID.
 *
 * @x-auditable true
 */
export type ZeroTrustGatewayAppId = number;

/**
 * The identifier for the type of this application. There can be many applications with the same type. This refers to the `id` of a returned application type.
 *
 * @x-auditable true
 */
export type ZeroTrustGatewayAppTypeId = number;

export type ZeroTrustGatewayApplication = {
  application_type_id?: ZeroTrustGatewayAppTypeId;
  created_at?: ZeroTrustGatewayTimestamp;
  id?: ZeroTrustGatewayAppId;
  name?: ZeroTrustGatewayAppTypesComponentsSchemasName;
};

export type ZeroTrustGatewayApplicationType = {
  created_at?: ZeroTrustGatewayTimestamp;
  /**
   * A short summary of applications with this type.
   *
   * @example Applications used to communicate or collaborate in a business setting.
   */
  description?: string;
  id?: ZeroTrustGatewayAppTypeId;
  name?: ZeroTrustGatewayAppTypesComponentsSchemasName;
};

export type ZeroTrustGatewayAuditSshSettingsComponentsSchemasSingleResponse =
  ZeroTrustGatewayApiResponseSingle & {
    result?: ZeroTrustGatewaySettings;
  };

/**
 * Seed ID
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 * @x-auditable true
 */
export type ZeroTrustGatewayAuditSshSettingsComponentsSchemasUuid = string;

/**
 * True if the category is in beta and subject to change.
 *
 * @example false
 * @x-auditable true
 */
export type ZeroTrustGatewayBeta = boolean;

/**
 * The deployment status of the certificate on Cloudflare's edge. Certificates in the 'available' (previously called 'active') state may be used for Gateway TLS interception.
 *
 * @x-auditable true
 */
export type ZeroTrustGatewayBindingStatus =
  | "pending_deployment"
  | "available"
  | "pending_deletion"
  | "inactive";

/**
 * Block page layout settings.
 */
export type ZeroTrustGatewayBlockPageSettings = {
  /**
   * If mode is customized_block_page: block page background color in #rrggbb format.
   *
   * @x-auditable true
   */
  background_color?: string;
  /**
   * Enable only cipher suites and TLS versions compliant with FIPS 140-2.
   *
   * @example true
   * @x-auditable true
   */
  enabled?: boolean;
  /**
   * If mode is customized_block_page: block page footer text.
   *
   * @example --footer--
   * @x-auditable true
   */
  footer_text?: string;
  /**
   * If mode is customized_block_page: block page header text.
   *
   * @example --header--
   * @x-auditable true
   */
  header_text?: string;
  /**
   * If mode is redirect_uri: when enabled, context will be appended to target_uri as query parameters.
   *
   * @x-auditable true
   */
  include_context?: boolean;
  /**
   * If mode is customized_block_page: full URL to the logo file.
   *
   * @example https://logos.com/a.png
   * @x-auditable true
   */
  logo_path?: string;
  /**
   * If mode is customized_block_page: admin email for users to contact.
   *
   * @example admin@example.com
   * @x-auditable true
   */
  mailto_address?: string;
  /**
   * If mode is customized_block_page: subject line for emails created from block page.
   *
   * @example Blocked User Inquiry
   * @x-auditable true
   */
  mailto_subject?: string;
  /**
   * Controls whether the user is redirected to a Cloudflare-hosted block page or to a customer-provided URI.
   *
   * @default customized_block_page
   * @x-auditable true
   */
  mode?: "customized_block_page" | "redirect_uri";
  /**
   * If mode is customized_block_page: block page title.
   *
   * @example Cloudflare
   * @x-auditable true
   */
  name?: string;
  /**
   * This setting was shared via the Orgs API and cannot be edited by the current account
   *
   * @x-auditable true
   */
  read_only?: boolean;
  /**
   * Account tag of account that shared this setting
   *
   * @x-auditable true
   */
  source_account?: string;
  /**
   * If mode is customized_block_page: suppress detailed info at the bottom of the block page.
   *
   * @example false
   */
  suppress_footer?: boolean;
  /**
   * If mode is redirect_uri: URI to which the user should be redirected.
   *
   * @format uri
   * @x-auditable true
   */
  target_uri?: string;
} | null;

/**
 * DLP body scanning settings.
 */
export type ZeroTrustGatewayBodyScanningSettings = {
  /**
   * Set the inspection mode to either `deep` or `shallow`.
   *
   * @example deep
   * @x-auditable true
   */
  inspection_mode?: string;
} | null;

/**
 * Browser isolation settings.
 */
export type ZeroTrustGatewayBrowserIsolationSettings = {
  /**
   * Enable non-identity onramp support for Browser Isolation.
   *
   * @example true
   * @x-auditable true
   */
  non_identity_enabled?: boolean;
  /**
   * Enable Clientless Browser Isolation.
   *
   * @example true
   * @x-auditable true
   */
  url_browser_isolation_enabled?: boolean;
} | null;

export type ZeroTrustGatewayCategories = {
  beta?: ZeroTrustGatewayBeta;
  ["class"]?: ZeroTrustGatewayClass;
  description?: ZeroTrustGatewayComponentsSchemasDescription;
  id?: ZeroTrustGatewayId;
  name?: ZeroTrustGatewayCategoriesComponentsSchemasName;
  /**
   * All subcategories for this category.
   */
  subcategories?: ZeroTrustGatewaySubcategory[];
};

/**
 * The name of the category.
 *
 * @example Education
 */
export type ZeroTrustGatewayCategoriesComponentsSchemasName = string;

export type ZeroTrustGatewayCategoriesComponentsSchemasResponseCollection =
  ZeroTrustGatewayApiResponseCollection & {
    result?: ZeroTrustGatewayCategories[];
  };

/**
 * Certificate settings for Gateway TLS interception. If not specified, the Cloudflare Root CA will be used.
 */
export type ZeroTrustGatewayCertificateSettings = {
  /**
   * UUID of certificate to be used for interception. Certificate must be available (previously called 'active') on the edge. A nil UUID will indicate the Cloudflare Root CA should be used.
   *
   * @example d1b364c5-1311-466e-a194-f0e943e0799f
   * @x-auditable true
   */
  id: string;
} | null;

export type ZeroTrustGatewayCertificates = {
  binding_status?: ZeroTrustGatewayBindingStatus;
  /**
   * The CA certificate
   *
   * @example -----BEGIN CERTIFICATE-----\nMIIDmDCCAoCgAwIBAgIUKTOAZNjcXVZRj4oQt0SHsl1c1vMwDQYJKoZIhvcNAQELBQAwUTELMAkGA1UEBhMCVVMxFjAUBgNVBAgMDVNhbiBGcmFuY2lzY28xEzARBgNVBAcMCkNhbGlmb3JuaWExFTATBgNVBAoMDEV4YW1wbGUgSW5jLjAgFw0yMjExMjIxNjU5NDdaGA8yMTIyMTAyOTE2NTk0N1owUTELMAkGA1UEBhMCVVMxFjAUBgNVBAgMDVNhbiBGcmFuY2lzY28xEzARBgNVBAcMCkNhbGlmb3JuaWExFTATBgNVBAoMDEV4YW1wbGUgSW5jLjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMRcORwgJFTdcG/2GKI+cFYiOBNDKjCZUXEOvXWY42BkH9wxiMT869CO+enA1w5pIrXow6kCM1sQspHHaVmJUlotEMJxyoLFfA/8Kt1EKFyobOjuZs2SwyVyJ2sStvQuUQEosULZCNGZEqoH5g6zhMPxaxm7ZLrrsDZ9maNGVqo7EWLWHrZ57Q/5MtTrbxQL+eXjUmJ9K3kS+3uEwMdqR6Z3BluU1ivanpPc1CN2GNhdO0/hSY4YkGEnuLsqJyDd3cIiB1MxuCBJ4ZaqOd2viV1WcP3oU3dxVPm4MWyfYIldMWB14FahScxLhWdRnM9YZ/i9IFcLypXsuz7DjrJPtPUCAwEAAaNmMGQwHQYDVR0OBBYEFP5JzLUawNF+c3AXsYTEWHh7z2czMB8GA1UdIwQYMBaAFP5JzLUawNF+c3AXsYTEWHh7z2czMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEBMA0GCSqGSIb3DQEBCwUAA4IBAQBc+Be7NDhpE09y7hLPZGRPl1cSKBw4RI0XIv6rlbSTFs5EebpTGjhx/whNxwEZhB9HZ7111Oa1YlT8xkI9DshB78mjAHCKBAJ76moK8tkG0aqdYpJ4ZcJTVBB7l98Rvgc7zfTii7WemTy72deBbSeiEtXavm4EF0mWjHhQ5Nxpnp00Bqn5g1x8CyTDypgmugnep+xG+iFzNmTdsz7WI9T/7kDMXqB7M/FPWBORyS98OJqNDswCLF8bIZYwUBEe+bRHFomoShMzaC3tvim7WCb16noDkSTMlfKO4pnvKhpcVdSgwcruATV7y+W+Lvmz2OT/Gui4JhqeoTewsxndhDDE\n-----END CERTIFICATE-----\n
   */
  certificate?: string;
  created_at?: ZeroTrustGatewayReadOnlyTimestamp;
  expires_on?: ZeroTrustGatewayReadOnlyTimestamp;
  /**
   * The SHA256 fingerprint of the certificate.
   *
   * @example E9:19:49:AA:DD:D8:1E:C1:20:2A:D8:22:BF:A5:F8:FC:1A:F7:10:9F:C7:5B:69:AB:0:31:91:8B:61:B4:BF:1C
   * @x-auditable true
   */
  fingerprint?: string;
  id?: ZeroTrustGatewayUuid;
  /**
   * Use this certificate for Gateway TLS interception
   *
   * @default false
   */
  in_use?: boolean;
  /**
   * The organization that issued the certificate.
   *
   * @example Example Inc.
   * @x-auditable true
   */
  issuer_org?: string;
  /**
   * The entire issuer field of the certificate.
   *
   * @example O=Example Inc.,L=California,ST=San Francisco,C=US
   * @x-auditable true
   */
  issuer_raw?: string;
  type?: ZeroTrustGatewayType;
  updated_at?: ZeroTrustGatewayReadOnlyTimestamp;
  uploaded_on?: ZeroTrustGatewayReadOnlyTimestamp;
};

/**
 * Cloudflare account ID.
 *
 * @example 699d98642c564d2e855e9661899b7252
 * @maxLength 32
 */
export type ZeroTrustGatewayCfAccountId = string;

/**
 * Which account types are allowed to create policies based on this category. `blocked` categories are blocked unconditionally for all accounts. `removalPending` categories can be removed from policies but not added. `noBlock` categories cannot be blocked.
 *
 * @example premium
 * @x-auditable true
 */
export type ZeroTrustGatewayClass =
  | "free"
  | "premium"
  | "blocked"
  | "removalPending"
  | "noBlock";

/**
 * True if the location is the default location.
 *
 * @default false
 * @example false
 * @x-auditable true
 */
export type ZeroTrustGatewayClientDefault = boolean;

/**
 * A short summary of domains in the category.
 *
 * @example Sites related to educational content that are not included in other categories such as Science, Technology or Educational institutions.
 * @x-auditable true
 */
export type ZeroTrustGatewayComponentsSchemasDescription = string;

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type ZeroTrustGatewayComponentsSchemasIdentifier = string;

/**
 * The name of the rule.
 *
 * @example block bad websites
 * @x-auditable true
 */
export type ZeroTrustGatewayComponentsSchemasName = string;

export type ZeroTrustGatewayComponentsSchemasResponseCollection =
  ZeroTrustGatewayApiResponseCollection & {
    result?: ZeroTrustGatewayLocations[];
  };

export type ZeroTrustGatewayComponentsSchemasSingleResponse =
  ZeroTrustGatewayApiResponseSingle & {
    result?: ZeroTrustGatewayRules;
  };

/**
 * @example ed35569b41ce4d1facfe683550f54086
 * @x-auditable true
 */
export type ZeroTrustGatewayComponentsSchemasUuid = string;

/**
 * The number of items in the list.
 *
 * @example 20
 */
export type ZeroTrustGatewayCount = number;

/**
 * Custom certificate settings for BYO-PKI. (deprecated and replaced by `certificate`)
 *
 * @deprecated true
 */
export type ZeroTrustGatewayCustomCertificateSettings = {
  /**
   * Certificate status (internal).
   *
   * @example pending_deployment
   * @x-auditable true
   */
  binding_status?: string;
  /**
   * Enable use of custom certificate authority for signing Gateway traffic.
   *
   * @example true
   * @x-auditable true
   */
  enabled: boolean;
  /**
   * UUID of certificate (ID from MTLS certificate store).
   *
   * @example d1b364c5-1311-466e-a194-f0e943e0799f
   * @x-auditable true
   */
  id?: string;
  /**
   * @format date-time
   */
  updated_at?: string;
} | null;

/**
 * Date of deletion, if any.
 *
 * @format date-time
 */
export type ZeroTrustGatewayDeletedAt = string | null;

/**
 * The description of the list.
 *
 * @example The serial numbers for administrators
 * @x-auditable true
 */
export type ZeroTrustGatewayDescription = string;

/**
 * The description of the list item, if present
 *
 * @example Austin office IP
 * @minimum 0
 */
export type ZeroTrustGatewayDescriptionItem = string;

/**
 * The wirefilter expression used for device posture check matching.
 *
 * @default
 * @example any(device_posture.checks.passed[*] in {"1308749e-fcfb-4ebc-b051-fe022b632644"})
 * @x-auditable true
 */
export type ZeroTrustGatewayDevicePosture = string;

/**
 * The identifier of the pair of IPv4 addresses assigned to this location.
 *
 * @example 0e4a32c6-6fb8-4858-9296-98f51631e8e6
 * @x-auditable true
 */
export type ZeroTrustGatewayDnsDestinationIpsIdRead = string;

/**
 * The identifier of the pair of IPv4 addresses assigned to this location. When creating a location, if this field is absent or set with null, the pair of shared IPv4 addresses (0e4a32c6-6fb8-4858-9296-98f51631e8e6) is auto-assigned. When updating a location, if the field is absent or set with null, the pre-assigned pair remains unchanged.
 *
 * @example 0e4a32c6-6fb8-4858-9296-98f51631e8e6
 * @x-auditable true
 */
export type ZeroTrustGatewayDnsDestinationIpsIdWrite = string;

/**
 * The uuid identifier of the IPv6 block brought to the gateway, so that this location's IPv6 address is allocated from the Bring Your Own Ipv6(BYOIPv6) block and not from the standard CloudFlare IPv6 block.
 *
 * @example b08f7231-d458-495c-98ef-190604c9ee83
 * @x-auditable true
 */
export type ZeroTrustGatewayDnsDestinationIpv6BlockId = string | null;

export type ZeroTrustGatewayDnsResolverSettingsV4 = {
  /**
   * IPv4 address of upstream resolver.
   *
   * @example 2.2.2.2
   * @x-auditable true
   */
  ip: string;
  /**
   * A port number to use for upstream resolver. Defaults to 53 if unspecified.
   *
   * @example 5053
   * @x-auditable true
   */
  port?: number;
  /**
   * Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
   *
   * @example true
   * @x-auditable true
   */
  route_through_private_network?: boolean;
  /**
   * Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
   *
   * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
   * @x-auditable true
   */
  vnet_id?: string;
};

export type ZeroTrustGatewayDnsResolverSettingsV6 = {
  /**
   * IPv6 address of upstream resolver.
   *
   * @example 2001:DB8::
   * @x-auditable true
   */
  ip: string;
  /**
   * A port number to use for upstream resolver. Defaults to 53 if unspecified.
   *
   * @example 5053
   * @x-auditable true
   */
  port?: number;
  /**
   * Whether to connect to this resolver over a private network. Must be set when vnet_id is set.
   *
   * @example true
   * @x-auditable true
   */
  route_through_private_network?: boolean;
  /**
   * Optionally specify a virtual network for this resolver. Uses default virtual network id if omitted.
   *
   * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
   * @x-auditable true
   */
  vnet_id?: string;
};

export type ZeroTrustGatewayDohEndpoint = {
  /**
   * True if the endpoint is enabled for this location.
   *
   * @example true
   * @x-auditable true
   */
  enabled?: boolean;
  networks?: ZeroTrustGatewayIpNetworks;
  /**
   * True if the endpoint requires [user identity](https://developers.cloudflare.com/cloudflare-one/connections/connect-devices/agentless/dns/dns-over-https/#filter-doh-requests-by-user) authentication.
   *
   * @example true
   * @x-auditable true
   */
  require_token?: boolean;
};

export type ZeroTrustGatewayDotEndpoint = {
  /**
   * True if the endpoint is enabled for this location.
   *
   * @example true
   * @x-auditable true
   */
  enabled?: boolean;
  networks?: ZeroTrustGatewayIpNetworks;
};

/**
 * True if the location needs to resolve EDNS queries.
 *
 * @default false
 * @example false
 * @x-auditable true
 */
export type ZeroTrustGatewayEcsSupport = boolean;

export type ZeroTrustGatewayEmptyResponse =
  ZeroTrustGatewayApiResponseSingle & {
    result?: Record<string, any>;
  };

/**
 * True if the rule is enabled.
 *
 * @default false
 * @example true
 * @x-auditable true
 */
export type ZeroTrustGatewayEnabled = boolean;

/**
 * Enable anti-virus scanning on downloads.
 *
 * @example false
 * @x-auditable true
 */
export type ZeroTrustGatewayEnabledDownloadPhase = boolean;

/**
 * Enable anti-virus scanning on uploads.
 *
 * @example false
 * @x-auditable true
 */
export type ZeroTrustGatewayEnabledUploadPhase = boolean;

/**
 * The destination endpoints configured for this location. When updating a location, if this field is absent or set with null, the endpoints configuration remains unchanged.
 */
export type ZeroTrustGatewayEndpoints = {
  doh?: ZeroTrustGatewayDohEndpoint;
  dot?: ZeroTrustGatewayDotEndpoint;
  ipv4?: ZeroTrustGatewayIpv4Endpoint;
  ipv6?: ZeroTrustGatewayIpv6Endpoint;
};

/**
 * The expiration time stamp and default duration of a DNS policy. Takes
 * precedence over the policy's `schedule` configuration, if any.
 *
 * This does not apply to HTTP or network policies.
 */
export type ZeroTrustGatewayExpiration = {
  /**
   * The default duration a policy will be active in minutes. Must be set in order to use the `reset_expiration` endpoint on this rule.
   *
   * @example 10
   * @minimum 5
   * @x-auditable true
   */
  duration?: number;
  /**
   * Whether the policy has expired.
   *
   * @example false
   * @x-auditable true
   */
  expired?: boolean;
  /**
   * The time stamp at which the policy will expire and cease to be
   * applied.
   *
   * Must adhere to RFC 3339 and include a UTC offset. Non-zero
   * offsets are accepted but will be converted to the equivalent
   * value with offset zero (UTC+00:00) and will be returned as time
   * stamps with offset zero denoted by a trailing 'Z'.
   *
   * Policies with an expiration do not consider the timezone of
   * clients they are applied to, and expire "globally" at the point
   * given by their `expires_at` value.
   *
   * @example 2014-01-01T05:20:20Z
   * @format date-time
   * @x-auditable true
   */
  expires_at: ZeroTrustGatewayTimestamp & string;
} | null;

/**
 * Extended e-mail matching settings.
 */
export type ZeroTrustGatewayExtendedEmailMatching = {
  /**
   * Enable matching all variants of user emails (with + or . modifiers) used as criteria in Firewall policies.
   *
   * @example true
   * @x-auditable true
   */
  enabled?: boolean;
  /**
   * This setting was shared via the Orgs API and cannot be edited by the current account
   *
   * @x-auditable true
   */
  read_only?: boolean;
  /**
   * Account tag of account that shared this setting
   *
   * @x-auditable true
   */
  source_account?: string;
} | null;

/**
 * Block requests for files that cannot be scanned.
 *
 * @example false
 * @x-auditable true
 */
export type ZeroTrustGatewayFailClosed = boolean;

/**
 * The protocol or layer to evaluate the traffic, identity, and device posture expressions.
 *
 * @example http
 */
export type ZeroTrustGatewayFilters = (
  | "http"
  | "dns"
  | "l4"
  | "egress"
  | "dns_resolver"
)[];

/**
 * FIPS settings.
 */
export type ZeroTrustGatewayFipsSettings = {
  /**
   * Enable only cipher suites and TLS versions compliant with FIPS 140-2.
   *
   * @example true
   * @x-auditable true
   */
  tls?: boolean;
} | null;

export type ZeroTrustGatewayGatewayAccountLoggingSettings = {
  /**
   * Redact personally identifiable information from activity logging (PII fields are: source IP, user email, user ID, device ID, URL, referrer, user agent).
   *
   * @default false
   * @example true
   * @x-auditable true
   */
  redact_pii?: boolean;
  /**
   * Logging settings by rule type.
   */
  settings_by_rule_type?: {
    dns?: ZeroTrustGatewayAccountLogOptions;
    http?: ZeroTrustGatewayAccountLogOptions;
    l4?: ZeroTrustGatewayAccountLogOptions;
  };
};

export type ZeroTrustGatewayGatewayAccountLoggingSettingsResponse =
  ZeroTrustGatewayApiResponseSingle & {
    result?: ZeroTrustGatewayGatewayAccountLoggingSettings;
  };

/**
 * Account settings
 */
export type ZeroTrustGatewayGatewayAccountSettings = {
  /**
   * Account settings
   */
  settings?: {
    activity_log?: ZeroTrustGatewayActivityLogSettings;
    antivirus?: ZeroTrustGatewayAntiVirusSettings;
    block_page?: ZeroTrustGatewayBlockPageSettings;
    body_scanning?: ZeroTrustGatewayBodyScanningSettings;
    browser_isolation?: ZeroTrustGatewayBrowserIsolationSettings;
    certificate?: ZeroTrustGatewayCertificateSettings;
    custom_certificate?: ZeroTrustGatewayCustomCertificateSettings;
    extended_email_matching?: ZeroTrustGatewayExtendedEmailMatching;
    fips?: ZeroTrustGatewayFipsSettings;
    host_selector?: ZeroTrustGatewayHostSelectorSettings;
    protocol_detection?: ZeroTrustGatewayProtocolDetection;
    sandbox?: ZeroTrustGatewaySandbox;
    tls_decrypt?: ZeroTrustGatewayTlsSettings;
  };
};

export type ZeroTrustGatewayGatewayAccount =
  ZeroTrustGatewayApiResponseSingle & {
    result?: {
      gateway_tag?: ZeroTrustGatewayGatewayTag;
      id?: ZeroTrustGatewayCfAccountId;
      provider_name?: ZeroTrustGatewayProviderName;
    };
  };

export type ZeroTrustGatewayGatewayAccountConfig =
  ZeroTrustGatewayApiResponseSingle & {
    /**
     * Account settings
     */
    result?: ZeroTrustGatewayGatewayAccountSettings & {
      created_at?: ZeroTrustGatewayReadOnlyTimestamp;
      updated_at?: ZeroTrustGatewayReadOnlyTimestamp;
    };
  };

/**
 * Gateway internal ID.
 *
 * @example f174e90afafe4643bbbc4a0ed4fc8415
 * @maxLength 32
 */
export type ZeroTrustGatewayGatewayTag = string;

export type ZeroTrustGatewayGenerateCertRequest = {
  /**
   * Number of days the generated certificate will be valid, minimum 1 day and maximum 30 years. Defaults to 5 years. In terraform, validity_period_days can only be used while creating a certificate, and this CAN NOT be used to extend the validity of an already generated certificate.
   *
   * @example 1826
   * @x-auditable true
   */
  validity_period_days?: number;
};

/**
 * Setting to enable host selector in egress policies.
 */
export type ZeroTrustGatewayHostSelectorSettings = {
  /**
   * Enable filtering via hosts for egress policies.
   *
   * @example false
   * @x-auditable true
   */
  enabled?: boolean;
} | null;

/**
 * The identifier for this category. There is only one category per ID.
 *
 * @x-auditable true
 */
export type ZeroTrustGatewayId = number;

/**
 * @example 699d98642c564d2e855e9661899b7252
 */
export type ZeroTrustGatewayIdentifier = string;

/**
 * The wirefilter expression used for identity matching.
 *
 * @default
 * @example any(identity.groups.name[*] in {"finance"})
 * @x-auditable true
 */
export type ZeroTrustGatewayIdentity = string;

/**
 * IPV6 destination ip assigned to this location. DNS requests sent to this IP will counted as the request under this location. This field is auto-generated by Gateway.
 *
 * @example 2001:0db8:85a3:0000:0000:8a2e:0370:7334
 * @x-auditable true
 */
export type ZeroTrustGatewayIp = string;

export type ZeroTrustGatewayIpNetwork = {
  /**
   * The IP address or IP CIDR.
   *
   * @example 2001:85a3::/64
   * @x-auditable true
   */
  network: string;
};

/**
 * A list of allowed source IP network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
 */
export type ZeroTrustGatewayIpNetworks = ZeroTrustGatewayIpNetwork[];

/**
 * A list of CIDRs to restrict ingress connections.
 */
export type ZeroTrustGatewayIps = string[];

export type ZeroTrustGatewayIpv4Endpoint = {
  /**
   * True if the endpoint is enabled for this location.
   *
   * @example true
   * @x-auditable true
   */
  enabled?: boolean;
};

export type ZeroTrustGatewayIpv4Network = {
  /**
   * The IPv4 address or IPv4 CIDR. IPv4 CIDRs are limited to a maximum of /24.
   *
   * @example 192.0.2.1/32
   * @x-auditable true
   */
  network: string;
};

/**
 * A list of network ranges that requests from this location would originate from. A non-empty list is only effective if the ipv4 endpoint is enabled for this location.
 */
export type ZeroTrustGatewayIpv4Networks = ZeroTrustGatewayIpv4Network[];

export type ZeroTrustGatewayIpv6Endpoint = {
  /**
   * True if the endpoint is enabled for this location.
   *
   * @example true
   * @x-auditable true
   */
  enabled?: boolean;
  networks?: ZeroTrustGatewayIpv6Networks;
};

export type ZeroTrustGatewayIpv6Network = {
  /**
   * The IPv6 address or IPv6 CIDR.
   *
   * @example 2001:85a3::/64
   * @x-auditable true
   */
  network: string;
};

/**
 * A list of allowed source IPv6 network ranges for this endpoint. When empty, all source IPs are allowed. A non-empty list is only effective if the endpoint is enabled for this location.
 */
export type ZeroTrustGatewayIpv6Networks = ZeroTrustGatewayIpv6Network[];

/**
 * The items in the list.
 */
export type ZeroTrustGatewayItems = {
  created_at?: ZeroTrustGatewayReadOnlyTimestamp;
  description?: ZeroTrustGatewayDescriptionItem;
  value?: ZeroTrustGatewayValue;
}[];

/**
 * items to add to the list.
 */
export type ZeroTrustGatewayItemsInput = {
  description?: ZeroTrustGatewayDescriptionItem;
  value?: ZeroTrustGatewayValue;
}[];

export type ZeroTrustGatewayListItemResponseCollection =
  ZeroTrustGatewayApiResponseCollection & {
    result?: ZeroTrustGatewayItems[];
  } & {
    result_info?: {
      /**
       * Total results returned based on your search parameters.
       *
       * @example 1
       */
      count?: number;
      /**
       * Current page within paginated list of results.
       *
       * @example 1
       */
      page?: number;
      /**
       * Number of results per page of results.
       *
       * @example 20
       */
      per_page?: number;
      /**
       * Total results available without any search parameters.
       *
       * @example 2000
       */
      total_count?: number;
    };
  };

/**
 * @x-auditable true
 */
export type ZeroTrustGatewayListSingleResponse =
  ZeroTrustGatewayApiResponseSingle & {
    result?: ZeroTrustGatewayLists;
  };

export type ZeroTrustGatewayLists = {
  count?: ZeroTrustGatewayCount;
  created_at?: ZeroTrustGatewayReadOnlyTimestamp;
  description?: ZeroTrustGatewayDescription;
  id?: ZeroTrustGatewaySchemasUuid;
  items?: ZeroTrustGatewayItems;
  name?: ZeroTrustGatewayName;
  type?: ZeroTrustGatewaySchemasType;
  updated_at?: ZeroTrustGatewayReadOnlyTimestamp;
};

export type ZeroTrustGatewayLocations = {
  client_default?: ZeroTrustGatewayClientDefault;
  created_at?: ZeroTrustGatewayReadOnlyTimestamp;
  dns_destination_ips_id?: ZeroTrustGatewayDnsDestinationIpsIdRead;
  dns_destination_ipv6_block_id?: ZeroTrustGatewayDnsDestinationIpv6BlockId;
  doh_subdomain?: ZeroTrustGatewaySubdomain;
  ecs_support?: ZeroTrustGatewayEcsSupport;
  endpoints?: ZeroTrustGatewayEndpoints;
  id?: ZeroTrustGatewayComponentsSchemasUuid;
  ip?: ZeroTrustGatewayIp;
  /**
   * The primary destination IPv4 address from the pair identified by the dns_destination_ips_id. This field is read-only.
   *
   * @example 172.64.36.1
   */
  ipv4_destination?: string;
  /**
   * The backup destination IPv4 address from the pair identified by the dns_destination_ips_id. This field is read-only.
   *
   * @example 172.64.36.2
   */
  ipv4_destination_backup?: string;
  name?: ZeroTrustGatewaySchemasName;
  networks?: ZeroTrustGatewayIpv4Networks;
  updated_at?: ZeroTrustGatewayReadOnlyTimestamp;
};

export type ZeroTrustGatewayMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * The name of the list.
 *
 * @example Admin Serial Numbers
 * @x-auditable true
 */
export type ZeroTrustGatewayName = string;

/**
 * The rule cannot be shared via the Orgs API
 *
 * @x-auditable true
 */
export type ZeroTrustGatewayNotSharable = boolean;

/**
 * Configure a message to display on the user's device when an antivirus search is performed.
 */
export type ZeroTrustGatewayNotificationSettings = {
  /**
   * Set notification on
   *
   * @x-auditable true
   */
  enabled?: boolean;
  /**
   * If true, context information will be passed as query parameters
   *
   * @x-auditable true
   */
  include_context?: boolean;
  /**
   * Customize the message shown in the notification.
   *
   * @x-auditable true
   */
  msg?: string;
  /**
   * Optional URL to direct users to additional information. If not set, the notification will open a block page.
   *
   * @x-auditable true
   */
  support_url?: string;
} | null;

/**
 * Precedence sets the order of your rules. Lower values indicate higher precedence. At each processing phase, applicable rules are evaluated in ascending order of this value. Refer to [Order of enforcement](http://developers.cloudflare.com/learning-paths/secure-internet-traffic/understand-policies/order-of-enforcement/#manage-precedence-with-terraform) docs on how to manage precedence via Terraform.
 *
 * @x-auditable true
 */
export type ZeroTrustGatewayPrecedence = number;

/**
 * Protocol Detection settings.
 */
export type ZeroTrustGatewayProtocolDetection = {
  /**
   * Enable detecting protocol on initial bytes of client traffic.
   *
   * @example true
   * @x-auditable true
   */
  enabled?: boolean;
} | null;

/**
 * The name of the provider. Usually Cloudflare.
 *
 * @example Cloudflare
 */
export type ZeroTrustGatewayProviderName = string;

export type ZeroTrustGatewayProxyEndpoints = {
  created_at?: ZeroTrustGatewayReadOnlyTimestamp;
  id?: ZeroTrustGatewayComponentsSchemasUuid;
  ips?: ZeroTrustGatewayIps;
  name?: ZeroTrustGatewayProxyEndpointsComponentsSchemasName;
  subdomain?: ZeroTrustGatewaySchemasSubdomain;
  updated_at?: ZeroTrustGatewayReadOnlyTimestamp;
};

/**
 * The name of the proxy endpoint.
 *
 * @example Devops team
 * @x-auditable true
 */
export type ZeroTrustGatewayProxyEndpointsComponentsSchemasName = string;

export type ZeroTrustGatewayProxyEndpointsComponentsSchemasResponseCollection =
  ZeroTrustGatewayApiResponseCollection & {
    result?: ZeroTrustGatewayProxyEndpoints[];
  };

export type ZeroTrustGatewayProxyEndpointsComponentsSchemasSingleResponse =
  ZeroTrustGatewayApiResponseSingle & {
    result?: ZeroTrustGatewayProxyEndpoints;
  };

/**
 * Base64 encoded HPKE public key used to encrypt all your ssh session logs. https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/use-cases/ssh/ssh-infrastructure-access/#enable-ssh-command-logging
 *
 * @example 1pyl6I1tL7xfJuFYVzXlUW8uXXlpxegHXBzGCBKaSFA=
 * @x-auditable true
 */
export type ZeroTrustGatewayPublicKey = string;

/**
 * The rule was shared via the Orgs API and cannot be edited by the current account
 *
 * @x-auditable true
 */
export type ZeroTrustGatewayReadOnly = boolean;

/**
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 */
export type ZeroTrustGatewayReadOnlyTimestamp = string;

export type ZeroTrustGatewayResponseCollection =
  ZeroTrustGatewayApiResponseCollection & {
    result?: ZeroTrustGatewayCertificates[];
  };

export type ZeroTrustGatewayResultInfo = {
  /**
   * Total number of results for the requested service
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters
   *
   * @example 2000
   */
  total_count?: number;
};

/**
 * Additional settings that modify the rule's action.
 */
export type ZeroTrustGatewayRuleSettings = {
  /**
   * Add custom headers to allowed requests, in the form of key-value pairs. Keys are header names, pointing to an array with its header value(s).
   *
   * @example {"My-Next-Header":["foo","bar"],"X-Custom-Header-Name":["somecustomvalue"]}
   */
  add_headers?: {
    [key: string]: string;
  } | null;
  /**
   * Set by parent MSP accounts to enable their children to bypass this rule.
   *
   * @example false
   * @x-auditable true
   */
  allow_child_bypass?: boolean | null;
  /**
   * Settings for the Audit SSH action.
   */
  audit_ssh?: {
    /**
     * Enable to turn on SSH command logging.
     *
     * @example false
     * @x-auditable true
     */
    command_logging?: boolean;
  } | null;
  /**
   * Configure how browser isolation behaves.
   */
  biso_admin_controls?: {
    /**
     * Configure whether copy is enabled or not. When set with "remote_only", copying isolated content from the remote browser to the user's local clipboard is disabled. When absent, copy is enabled. Only applies when `version == "v2"`.
     *
     * @example remote_only
     * @x-auditable true
     */
    copy?: "enabled" | "disabled" | "remote_only";
    /**
     * Set to false to enable copy-pasting. Only applies when `version == "v1"`.
     *
     * @default false
     * @example false
     * @x-auditable true
     */
    dcp?: boolean;
    /**
     * Set to false to enable downloading. Only applies when `version == "v1"`.
     *
     * @default false
     * @example false
     * @x-auditable true
     */
    dd?: boolean;
    /**
     * Set to false to enable keyboard usage. Only applies when `version == "v1"`.
     *
     * @default false
     * @example false
     * @x-auditable true
     */
    dk?: boolean;
    /**
     * Configure whether downloading enabled or not. When set with "remote_only", downloads are only available for viewing. Only applies when `version == "v2"`.
     *
     * @example enabled
     * @x-auditable true
     */
    download?: "enabled" | "disabled" | "remote_only";
    /**
     * Set to false to enable printing. Only applies when `version == "v1"`.
     *
     * @default false
     * @example false
     * @x-auditable true
     */
    dp?: boolean;
    /**
     * Set to false to enable uploading. Only applies when `version == "v1"`.
     *
     * @default false
     * @example false
     * @x-auditable true
     */
    du?: boolean;
    /**
     * Configure whether keyboard usage is enabled or not. When absent, keyboard usage is enabled. Only applies when `version == "v2"`.
     *
     * @example enabled
     * @x-auditable true
     */
    keyboard?: "enabled" | "disabled";
    /**
     * Configure whether pasting is enabled or not. When set with "remote_only", pasting content from the user's local clipboard into isolated pages is disabled. When absent, paste is enabled. Only applies when `version == "v2"`.
     *
     * @example enabled
     * @x-auditable true
     */
    paste?: "enabled" | "disabled" | "remote_only";
    /**
     * Configure whether printing is enabled or not. When absent, printing is enabled. Only applies when `version == "v2"`.
     *
     * @example enabled
     * @x-auditable true
     */
    printing?: "enabled" | "disabled";
    /**
     * Configure whether uploading is enabled or not. When absent, uploading is enabled. Only applies when `version == "v2"`.
     *
     * @example enabled
     * @x-auditable true
     */
    upload?: "enabled" | "disabled";
    /**
     * Indicates which version of the browser isolation controls should apply.
     *
     * @default v1
     * @x-auditable true
     */
    version?: "v1" | "v2";
  } | null;
  /**
   * Custom block page settings. If missing/null, blocking will use the the account settings.
   */
  block_page?: {
    /**
     * If true, context information will be passed as query parameters
     *
     * @x-auditable true
     */
    include_context?: boolean;
    /**
     * URI to which the user will be redirected
     *
     * @format uri
     * @x-auditable true
     */
    target_uri: string;
  } | null;
  /**
   * Enable the custom block page.
   *
   * @example true
   * @x-auditable true
   */
  block_page_enabled?: boolean;
  /**
   * The text describing why this block occurred, displayed on the custom block page (if enabled).
   *
   * @example This website is a security risk
   * @x-auditable true
   */
  block_reason?: string;
  /**
   * Set by children MSP accounts to bypass their parent's rules.
   *
   * @example false
   * @x-auditable true
   */
  bypass_parent_rule?: boolean | null;
  /**
   * Configure how session check behaves.
   */
  check_session?: {
    /**
     * Configure how fresh the session needs to be to be considered valid.
     *
     * @example 300s
     * @x-auditable true
     */
    duration?: string;
    /**
     * Set to true to enable session enforcement.
     *
     * @example true
     * @x-auditable true
     */
    enforce?: boolean;
  } | null;
  /**
   * Add your own custom resolvers to route queries that match the resolver policy. Cannot be used when 'resolve_dns_through_cloudflare' or 'resolve_dns_internally' are set. DNS queries will route to the address closest to their origin. Only valid when a rule's action is set to 'resolve'.
   */
  dns_resolvers?: {
    ipv4?: ZeroTrustGatewayDnsResolverSettingsV4[];
    ipv6?: ZeroTrustGatewayDnsResolverSettingsV6[];
  } | null;
  /**
   * Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs.
   */
  egress?: {
    /**
     * The IPv4 address to be used for egress.
     *
     * @example 192.0.2.2
     * @x-auditable true
     */
    ipv4?: string;
    /**
     * The fallback IPv4 address to be used for egress in the event of an error egressing with the primary IPv4. Can be '0.0.0.0' to indicate local egress via WARP IPs.
     *
     * @example 192.0.2.3
     * @x-auditable true
     */
    ipv4_fallback?: string;
    /**
     * The IPv6 range to be used for egress.
     *
     * @example 2001:DB8::/64
     * @x-auditable true
     */
    ipv6?: string;
  } | null;
  /**
   * Set to true, to ignore the category matches at CNAME domains in a response. If unchecked, the categories in this rule will be checked against all the CNAME domain categories in a response.
   *
   * @example true
   * @x-auditable true
   */
  ignore_cname_category_matches?: boolean;
  /**
   * INSECURE - disable DNSSEC validation (for Allow actions).
   *
   * @example false
   * @x-auditable true
   */
  insecure_disable_dnssec_validation?: boolean;
  /**
   * Set to true to enable IPs in DNS resolver category blocks. By default categories only block based on domain names.
   *
   * @example true
   * @x-auditable true
   */
  ip_categories?: boolean;
  /**
   * Set to true to include IPs in DNS resolver indicator feed blocks. By default indicator feeds only block based on domain names.
   *
   * @example true
   * @x-auditable true
   */
  ip_indicator_feeds?: boolean;
  /**
   * Send matching traffic to the supplied destination IP address and port.
   */
  l4override?: {
    /**
     * IPv4 or IPv6 address.
     *
     * @example 1.1.1.1
     * @x-auditable true
     */
    ip?: string;
    /**
     * A port number to use for TCP/UDP overrides.
     *
     * @x-auditable true
     */
    port?: number;
  } | null;
  /**
   * Configure a notification to display on the user's device when this rule is matched.
   */
  notification_settings?: {
    /**
     * Set notification on
     *
     * @x-auditable true
     */
    enabled?: boolean;
    /**
     * If true, context information will be passed as query parameters
     *
     * @x-auditable true
     */
    include_context?: boolean;
    /**
     * Customize the message shown in the notification.
     *
     * @x-auditable true
     */
    msg?: string;
    /**
     * Optional URL to direct users to additional information. If not set, the notification will open a block page.
     *
     * @x-auditable true
     */
    support_url?: string;
  } | null;
  /**
   * Override matching DNS queries with a hostname.
   *
   * @example example.com
   * @x-auditable true
   */
  override_host?: string;
  /**
   * Override matching DNS queries with an IP or set of IPs.
   *
   * @example 1.1.1.1
   * @example 2.2.2.2
   */
  override_ips?: string[] | null;
  /**
   * Configure DLP payload logging.
   */
  payload_log?: {
    /**
     * Set to true to enable DLP payload logging for this rule.
     *
     * @example true
     * @x-auditable true
     */
    enabled?: boolean;
  } | null;
  /**
   * Settings that apply to quarantine rules
   */
  quarantine?: {
    /**
     * Types of files to sandbox.
     */
    file_types?: (
      | "exe"
      | "pdf"
      | "doc"
      | "docm"
      | "docx"
      | "rtf"
      | "ppt"
      | "pptx"
      | "xls"
      | "xlsm"
      | "xlsx"
      | "zip"
      | "rar"
    )[];
  } | null;
  /**
   * Settings that apply to redirect rules
   */
  redirect?: {
    /**
     * If true, context information will be passed as query parameters
     *
     * @x-auditable true
     */
    include_context?: boolean;
    /**
     * If true, the path and query parameters from the original request will be appended to target_uri
     *
     * @x-auditable true
     */
    preserve_path_and_query?: boolean;
    /**
     * URI to which the user will be redirected
     *
     * @format uri
     * @x-auditable true
     */
    target_uri: string;
  } | null;
  /**
   * Configure to forward the query to the internal DNS service, passing the specified 'view_id' as input. Cannot be set when 'dns_resolvers' are specified or 'resolve_dns_through_cloudflare' is set. Only valid when a rule's action is set to 'resolve'.
   */
  resolve_dns_internally?: {
    /**
     * The fallback behavior to apply when the internal DNS response code is different from 'NOERROR' or when the response data only contains CNAME records for 'A' or 'AAAA' queries.
     *
     * @x-auditable true
     */
    fallback?: "none" | "public_dns";
    /**
     * The internal DNS view identifier that's passed to the internal DNS service.
     *
     * @x-auditable true
     */
    view_id?: string;
  } | null;
  /**
   * Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot be set when 'dns_resolvers' are specified or 'resolve_dns_internally' is set. Only valid when a rule's action is set to 'resolve'.
   *
   * @example true
   * @x-auditable true
   */
  resolve_dns_through_cloudflare?: boolean | null;
  /**
   * Configure behavior when an upstream cert is invalid or an SSL error occurs.
   */
  untrusted_cert?: {
    /**
     * The action performed when an untrusted certificate is seen. The default action is an error with HTTP code 526.
     *
     * @example error
     * @x-auditable true
     */
    action?: "pass_through" | "block" | "error";
  } | null;
};

export type ZeroTrustGatewayRules = {
  action?: ZeroTrustGatewayAction;
  created_at?: ZeroTrustGatewayReadOnlyTimestamp;
  deleted_at?: ZeroTrustGatewayDeletedAt;
  description?: ZeroTrustGatewaySchemasDescription;
  device_posture?: ZeroTrustGatewayDevicePosture;
  enabled?: ZeroTrustGatewayEnabled;
  expiration?: ZeroTrustGatewayExpiration;
  filters?: ZeroTrustGatewayFilters;
  id?: ZeroTrustGatewayRulesComponentsSchemasUuid;
  identity?: ZeroTrustGatewayIdentity;
  name?: ZeroTrustGatewayComponentsSchemasName;
  not_sharable?: ZeroTrustGatewayNotSharable;
  precedence?: ZeroTrustGatewayPrecedence;
  read_only?: ZeroTrustGatewayReadOnly;
  rule_settings?: ZeroTrustGatewayRuleSettings;
  schedule?: ZeroTrustGatewaySchedule;
  source_account?: ZeroTrustGatewaySourceAccount;
  traffic?: ZeroTrustGatewayTraffic;
  updated_at?: ZeroTrustGatewayReadOnlyTimestamp;
  version?: ZeroTrustGatewayVersion;
  warning_status?: ZeroTrustGatewayWarningStatus;
};

export type ZeroTrustGatewayRulesComponentsSchemasResponseCollection =
  ZeroTrustGatewayApiResponseCollection & {
    result?: ZeroTrustGatewayRules[];
  };

/**
 * The API resource UUID.
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 * @x-auditable true
 */
export type ZeroTrustGatewayRulesComponentsSchemasUuid = string;

/**
 * Sandbox settings.
 */
export type ZeroTrustGatewaySandbox = {
  /**
   * Enable sandbox.
   *
   * @example true
   * @x-auditable true
   */
  enabled?: boolean;
  /**
   * Action to take when the file cannot be scanned.
   *
   * @x-auditable true
   */
  fallback_action?: "allow" | "block";
} | null;

/**
 * The schedule for activating DNS policies. This does not apply to HTTP or network policies.
 */
export type ZeroTrustGatewaySchedule = {
  /**
   * The time intervals when the rule will be active on Fridays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Fridays.
   *
   * @example 08:00-12:30,13:30-17:00
   * @x-auditable true
   */
  fri?: string;
  /**
   * The time intervals when the rule will be active on Mondays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Mondays.
   *
   * @example 08:00-12:30,13:30-17:00
   * @x-auditable true
   */
  mon?: string;
  /**
   * The time intervals when the rule will be active on Saturdays, in increasing order from 00:00-24:00.  If this parameter is omitted, the rule will be deactivated on Saturdays.
   *
   * @example 08:00-12:30,13:30-17:00
   * @x-auditable true
   */
  sat?: string;
  /**
   * The time intervals when the rule will be active on Sundays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Sundays.
   *
   * @example 08:00-12:30,13:30-17:00
   * @x-auditable true
   */
  sun?: string;
  /**
   * The time intervals when the rule will be active on Thursdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Thursdays.
   *
   * @example 08:00-12:30,13:30-17:00
   * @x-auditable true
   */
  thu?: string;
  /**
   * The time zone the rule will be evaluated against. If a [valid time zone city name](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List) is provided, Gateway will always use the current time at that time zone. If this parameter is omitted, then Gateway will use the time zone inferred from the user's source IP to evaluate the rule. If Gateway cannot determine the time zone from the IP, we will fall back to the time zone of the user's connected data center.
   *
   * @example America/New York
   * @x-auditable true
   */
  time_zone?: string;
  /**
   * The time intervals when the rule will be active on Tuesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Tuesdays.
   *
   * @example 08:00-12:30,13:30-17:00
   * @x-auditable true
   */
  tue?: string;
  /**
   * The time intervals when the rule will be active on Wednesdays, in increasing order from 00:00-24:00. If this parameter is omitted, the rule will be deactivated on Wednesdays.
   *
   * @example 08:00-12:30,13:30-17:00
   * @x-auditable true
   */
  wed?: string;
} | null;

/**
 * The description of the rule.
 *
 * @example Block bad websites based on their host name.
 * @x-auditable true
 */
export type ZeroTrustGatewaySchemasDescription = string;

/**
 * @example 699d98642c564d2e855e9661899b7252
 * @x-auditable true
 */
export type ZeroTrustGatewaySchemasIdentifier = string;

/**
 * The name of the location.
 *
 * @example Austin Office Location
 * @x-auditable true
 */
export type ZeroTrustGatewaySchemasName = string;

export type ZeroTrustGatewaySchemasResponseCollection =
  ZeroTrustGatewayApiResponseCollection & {
    result?: ZeroTrustGatewayLists[];
  };

export type ZeroTrustGatewaySchemasSingleResponse =
  ZeroTrustGatewayApiResponseSingle & {
    result?: ZeroTrustGatewayLocations;
  };

/**
 * The subdomain to be used as the destination in the proxy client.
 *
 * @example oli3n9zkz5.proxy.cloudflare-gateway.com
 * @x-auditable true
 */
export type ZeroTrustGatewaySchemasSubdomain = string;

/**
 * The type of list.
 *
 * @example SERIAL
 * @x-auditable true
 */
export type ZeroTrustGatewaySchemasType =
  | "SERIAL"
  | "URL"
  | "DOMAIN"
  | "EMAIL"
  | "IP";

/**
 * API Resource UUID tag.
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 * @x-auditable true
 */
export type ZeroTrustGatewaySchemasUuid = string;

export type ZeroTrustGatewaySettings = {
  created_at?: ZeroTrustGatewayReadOnlyTimestamp;
  public_key?: ZeroTrustGatewayPublicKey;
  seed_id?: ZeroTrustGatewayAuditSshSettingsComponentsSchemasUuid;
  updated_at?: ZeroTrustGatewayReadOnlyTimestamp;
};

export type ZeroTrustGatewaySingleResponse =
  ZeroTrustGatewayApiResponseSingle & {
    result?: ZeroTrustGatewayCertificates;
  };

export type ZeroTrustGatewaySingleResponseWithListItems =
  ZeroTrustGatewayApiResponseSingle & {
    result?: {
      created_at?: ZeroTrustGatewayReadOnlyTimestamp;
      description?: ZeroTrustGatewayDescription;
      id?: ZeroTrustGatewaySchemasUuid;
      items?: ZeroTrustGatewayItems;
      name?: ZeroTrustGatewayName;
      type?: ZeroTrustGatewaySchemasType;
      updated_at?: ZeroTrustGatewayReadOnlyTimestamp;
    };
  };

/**
 * account tag of account that created the rule
 *
 * @x-auditable true
 */
export type ZeroTrustGatewaySourceAccount = string;

export type ZeroTrustGatewaySubcategory = {
  beta?: ZeroTrustGatewayBeta;
  ["class"]?: ZeroTrustGatewayClass;
  description?: ZeroTrustGatewayComponentsSchemasDescription;
  id?: ZeroTrustGatewayId;
  name?: ZeroTrustGatewayCategoriesComponentsSchemasName;
};

/**
 * The DNS over HTTPS domain to send DNS requests to. This field is auto-generated by Gateway.
 *
 * @example oli3n9zkz5
 * @x-auditable true
 */
export type ZeroTrustGatewaySubdomain = string;

/**
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 */
export type ZeroTrustGatewayTimestamp = string;

/**
 * TLS interception settings.
 */
export type ZeroTrustGatewayTlsSettings = {
  /**
   * Enable inspecting encrypted HTTP traffic.
   *
   * @example true
   * @x-auditable true
   */
  enabled?: boolean;
} | null;

/**
 * The wirefilter expression used for traffic matching.
 *
 * @default
 * @example http.request.uri matches ".*a/partial/uri.*" and http.request.host in $01302951-49f9-47c9-a400-0297e60b6a10
 * @x-auditable true
 */
export type ZeroTrustGatewayTraffic = string;

/**
 * The type of certificate, either BYO-PKI (custom) or Gateway-managed.
 *
 * @example gateway_managed
 * @x-auditable true
 */
export type ZeroTrustGatewayType = "custom" | "gateway_managed";

/**
 * Certificate UUID tag.
 *
 * @example f174e90a-fafe-4643-bbbc-4a0ed4fc8415
 * @maxLength 36
 * @x-auditable true
 */
export type ZeroTrustGatewayUuid = string;

/**
 * The value of the item in a list.
 *
 * @example 8GE8721REF
 * @x-auditable true
 */
export type ZeroTrustGatewayValue = string;

/**
 * version number of the rule
 *
 * @example 1
 * @x-auditable true
 */
export type ZeroTrustGatewayVersion = number;

/**
 * Warning for a misconfigured rule, if any.
 */
export type ZeroTrustGatewayWarningStatus = string | null;

export type ZoneActivationApiResponseCommon = {
  errors: ZoneActivationMessages;
  messages: ZoneActivationMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type ZoneActivationApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: ZoneActivationMessages;
  messages: ZoneActivationMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type ZoneActivationApiResponseSingle = ZoneActivationApiResponseCommon;

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type ZoneActivationIdentifier = string;

export type ZoneActivationMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

export type ZoneAnalyticsApiApiResponseCommon = {
  errors: ZoneAnalyticsApiMessages;
  messages: ZoneAnalyticsApiMessages;
  result: Record<string, any> | any[] | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type ZoneAnalyticsApiApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: ZoneAnalyticsApiMessages;
  messages: ZoneAnalyticsApiMessages;
  result: any | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: false;
};

export type ZoneAnalyticsApiApiResponseSingle = {
  errors: ZoneAnalyticsApiMessages;
  messages: ZoneAnalyticsApiMessages;
  result: (Record<string, any> | null) | (string | null) | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

/**
 * Breakdown of totals for bandwidth in the form of bytes.
 */
export type ZoneAnalyticsApiBandwidth = {
  /**
   * The total number of bytes served within the time frame.
   */
  all?: number;
  /**
   * The number of bytes that were cached (and served) by Cloudflare.
   */
  cached?: number;
  /**
   * A variable list of key/value pairs where the key represents the type of content served, and the value is the number in bytes served.
   *
   * @example {"css":237421,"gif":1234242,"html":1231290,"javascript":123245,"jpeg":784278}
   */
  content_type?: Record<string, any>;
  /**
   * A variable list of key/value pairs where the key is a two-digit country code and the value is the number of bytes served to that country.
   *
   * @example {"AG":2342483,"GI":984753,"US":123145433}
   */
  country?: Record<string, any>;
  /**
   * A break down of bytes served over HTTPS.
   */
  ssl?: {
    /**
     * The number of bytes served over HTTPS.
     */
    encrypted?: number;
    /**
     * The number of bytes served over HTTP.
     */
    unencrypted?: number;
  };
  /**
   * A breakdown of requests by their SSL protocol.
   */
  ssl_protocols?: {
    /**
     * The number of requests served over TLS v1.0.
     */
    TLSv1?: number;
    /**
     * The number of requests served over TLS v1.1.
     */
    ["TLSv1.1"]?: number;
    /**
     * The number of requests served over TLS v1.2.
     */
    ["TLSv1.2"]?: number;
    /**
     * The number of requests served over TLS v1.3.
     */
    ["TLSv1.3"]?: number;
    /**
     * The number of requests served over HTTP.
     */
    none?: number;
  };
  /**
   * The number of bytes that were fetched and served from the origin server.
   */
  uncached?: number;
};

/**
 * Breakdown of totals for bandwidth in the form of bytes.
 */
export type ZoneAnalyticsApiBandwidthByColo = {
  /**
   * The total number of bytes served within the time frame.
   */
  all?: number;
  /**
   * The number of bytes that were cached (and served) by Cloudflare.
   */
  cached?: number;
  /**
   * The number of bytes that were fetched and served from the origin server.
   */
  uncached?: number;
};

export type ZoneAnalyticsApiColoResponse = ZoneAnalyticsApiApiResponseSingle & {
  query?: ZoneAnalyticsApiQueryResponse;
  result?: ZoneAnalyticsApiDatacenters;
};

/**
 * Totals and timeseries data.
 */
export type ZoneAnalyticsApiDashboard = {
  timeseries?: ZoneAnalyticsApiTimeseries;
  totals?: ZoneAnalyticsApiTotals;
};

export type ZoneAnalyticsApiDashboardResponse =
  ZoneAnalyticsApiApiResponseSingle & {
    query?: ZoneAnalyticsApiQueryResponse;
    result?: ZoneAnalyticsApiDashboard;
  };

/**
 * A breakdown of all dashboard analytics data by co-locations. This is limited to Enterprise zones only.
 */
export type ZoneAnalyticsApiDatacenters = {
  /**
   * The airport code identifer for the co-location.
   *
   * @example SFO
   */
  colo_id?: string;
  timeseries?: ZoneAnalyticsApiTimeseriesByColo;
  totals?: ZoneAnalyticsApiTotalsByColo;
}[];

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type ZoneAnalyticsApiIdentifier = string;

export type ZoneAnalyticsApiMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * Breakdown of totals for pageviews.
 */
export type ZoneAnalyticsApiPageviews = {
  /**
   * The total number of pageviews served within the time range.
   */
  all?: number;
  /**
   * A variable list of key/value pairs representing the search engine and number of hits.
   *
   * @example {"baidubot":1345,"bingbot":5372,"googlebot":35272,"pingdom":13435}
   */
  search_engine?: Record<string, any>;
};

/**
 * The exact parameters/timestamps the analytics service used to return data.
 */
export type ZoneAnalyticsApiQueryResponse = {
  since?: ZoneAnalyticsApiSince;
  /**
   * The amount of time (in minutes) that each data point in the timeseries represents. The granularity of the time-series returned (e.g. each bucket in the time series representing 1-minute vs 1-day) is calculated by the API based on the time-range provided to the API.
   */
  time_delta?: number;
  until?: ZoneAnalyticsApiUntil;
};

/**
 * Breakdown of totals for requests.
 */
export type ZoneAnalyticsApiRequests = {
  /**
   * Total number of requests served.
   */
  all?: number;
  /**
   * Total number of cached requests served.
   */
  cached?: number;
  /**
   * A variable list of key/value pairs where the key represents the type of content served, and the value is the number of requests.
   *
   * @example {"css":15343,"gif":23178,"html":1234213,"javascript":318236,"jpeg":1982048}
   */
  content_type?: Record<string, any>;
  /**
   * A variable list of key/value pairs where the key is a two-digit country code and the value is the number of requests served to that country.
   *
   * @example {"AG":37298,"GI":293846,"US":4181364}
   */
  country?: Record<string, any>;
  /**
   * Key/value pairs where the key is a HTTP status code and the value is the number of requests served with that code.
   *
   * @example {"200":13496983,"301":283,"400":187936,"402":1828,"404":1293}
   */
  http_status?: {
    [key: string]: any;
  };
  /**
   * A break down of requests served over HTTPS.
   */
  ssl?: {
    /**
     * The number of requests served over HTTPS.
     */
    encrypted?: number;
    /**
     * The number of requests served over HTTP.
     */
    unencrypted?: number;
  };
  /**
   * A breakdown of requests by their SSL protocol.
   */
  ssl_protocols?: {
    /**
     * The number of requests served over TLS v1.0.
     */
    TLSv1?: number;
    /**
     * The number of requests served over TLS v1.1.
     */
    ["TLSv1.1"]?: number;
    /**
     * The number of requests served over TLS v1.2.
     */
    ["TLSv1.2"]?: number;
    /**
     * The number of requests served over TLS v1.3.
     */
    ["TLSv1.3"]?: number;
    /**
     * The number of requests served over HTTP.
     */
    none?: number;
  };
  /**
   * Total number of requests served from the origin.
   */
  uncached?: number;
};

/**
 * Breakdown of totals for requests.
 */
export type ZoneAnalyticsApiRequestsByColo = {
  /**
   * Total number of requests served.
   */
  all?: number;
  /**
   * Total number of cached requests served.
   */
  cached?: number;
  /**
   * Key/value pairs where the key is a two-digit country code and the value is the number of requests served to that country.
   *
   * @example {"AG":37298,"GI":293846,"US":4181364}
   */
  country?: {
    [key: string]: any;
  };
  /**
   * A variable list of key/value pairs where the key is a HTTP status code and the value is the number of requests with that code served.
   *
   * @example {"200":13496983,"301":283,"400":187936,"402":1828,"404":1293}
   */
  http_status?: Record<string, any>;
  /**
   * Total number of requests served from the origin.
   */
  uncached?: number;
};

/**
 * The (inclusive) beginning of the requested time frame. This value can be a negative integer representing the number of minutes in the past relative to time the request is made, or can be an absolute timestamp that conforms to RFC 3339. At this point in time, it cannot exceed a time in the past greater than one year.
 *
 * Ranges that the Cloudflare web application provides will provide the following period length for each point:
 * - Last 60 minutes (from -59 to -1): 1 minute resolution
 * - Last 7 hours (from -419 to -60): 15 minutes resolution
 * - Last 15 hours (from -899 to -420): 30 minutes resolution
 * - Last 72 hours (from -4320 to -900): 1 hour resolution
 * - Older than 3 days (-525600 to -4320): 1 day resolution.
 *
 * @default -10080
 * @example 2015-01-01T12:23:00Z
 */
export type ZoneAnalyticsApiSince = string | number;

/**
 * Breakdown of totals for threats.
 */
export type ZoneAnalyticsApiThreats = {
  /**
   * The total number of identifiable threats received over the time frame.
   */
  all?: number;
  /**
   * A list of key/value pairs where the key is a two-digit country code and the value is the number of malicious requests received from that country.
   *
   * @example {"AU":91,"CN":523423,"US":123}
   */
  country?: Record<string, any>;
  /**
   * The list of key/value pairs where the key is a threat category and the value is the number of requests.
   *
   * @example {"hot.ban.unknown":5324,"macro.chl.captchaErr":1341,"macro.chl.jschlErr":5323,"user.ban.ip":123}
   */
  type?: Record<string, any>;
};

/**
 * Time deltas containing metadata about each bucket of time. The number of buckets (resolution) is determined by the amount of time between the since and until parameters.
 */
export type ZoneAnalyticsApiTimeseries = {
  bandwidth?: ZoneAnalyticsApiBandwidth;
  pageviews?: ZoneAnalyticsApiPageviews;
  requests?: ZoneAnalyticsApiRequests;
  since?: ZoneAnalyticsApiSince;
  threats?: ZoneAnalyticsApiThreats;
  uniques?: ZoneAnalyticsApiUniques;
  until?: ZoneAnalyticsApiUntil;
}[];

/**
 * Time deltas containing metadata about each bucket of time. The number of buckets (resolution) is determined by the amount of time between the since and until parameters.
 */
export type ZoneAnalyticsApiTimeseriesByColo = {
  bandwidth?: ZoneAnalyticsApiBandwidthByColo;
  requests?: ZoneAnalyticsApiRequestsByColo;
  since?: ZoneAnalyticsApiSince;
  threats?: ZoneAnalyticsApiThreats;
  until?: ZoneAnalyticsApiUntil;
}[];

/**
 * Breakdown of totals by data type.
 */
export type ZoneAnalyticsApiTotals = {
  bandwidth?: ZoneAnalyticsApiBandwidth;
  pageviews?: ZoneAnalyticsApiPageviews;
  requests?: ZoneAnalyticsApiRequests;
  since?: ZoneAnalyticsApiSince;
  threats?: ZoneAnalyticsApiThreats;
  uniques?: ZoneAnalyticsApiUniques;
  until?: ZoneAnalyticsApiUntil;
};

/**
 * Breakdown of totals by data type.
 */
export type ZoneAnalyticsApiTotalsByColo = {
  bandwidth?: ZoneAnalyticsApiBandwidthByColo;
  requests?: ZoneAnalyticsApiRequestsByColo;
  since?: ZoneAnalyticsApiSince;
  threats?: ZoneAnalyticsApiThreats;
  until?: ZoneAnalyticsApiUntil;
};

export type ZoneAnalyticsApiUniques = {
  /**
   * Total number of unique IP addresses within the time range.
   */
  all?: number;
};

/**
 * The (exclusive) end of the requested time frame. This value can be a negative integer representing the number of minutes in the past relative to time the request is made, or can be an absolute timestamp that conforms to RFC 3339. If omitted, the time of the request is used.
 *
 * @default 0
 * @example 2015-01-02T12:23:00Z
 */
export type ZoneAnalyticsApiUntil = string | number;

/**
 * 0-RTT session resumption enabled for this zone.
 */
export type Zones0rtt = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example 0rtt
   */
  id: "0rtt";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: Zones0rttValue;
};

/**
 * Value of the 0-RTT setting.
 *
 * @default off
 */
export type Zones0rttValue = "on" | "off";

/**
 * The set of actions to perform if the targets of this rule match the
 * request. Actions can redirect to another URL or override settings, but
 * not both.
 *
 * @example {"id":"browser_check","value":"on"}
 */
export type ZonesActions = (
  | ZonesAlwaysUseHttps
  | ZonesAutomaticHttpsRewrites
  | ZonesBrowserCacheTtl
  | ZonesBrowserCheck
  | ZonesBypassCacheOnCookie
  | ZonesCacheByDeviceType
  | ZonesCacheDeceptionArmor
  | ZonesCacheKeyFields
  | ZonesCacheLevel
  | ZonesCacheOnCookie
  | ZonesCacheTtlByStatus
  | ZonesDisableApps
  | ZonesDisablePerformance
  | ZonesDisableSecurity
  | ZonesDisableZaraz
  | ZonesEdgeCacheTtl
  | ZonesEmailObfuscation
  | ZonesExplicitCacheControl
  | ZonesForwardingUrl
  | ZonesHostHeaderOverride
  | ZonesIpGeolocation
  | ZonesMirage
  | ZonesOpportunisticEncryption
  | ZonesOriginErrorPagePassThru
  | ZonesPolish
  | ZonesResolveOverride
  | ZonesRespectStrongEtag
  | ZonesResponseBuffering
  | ZonesRocketLoader
  | ZonesSecurityLevel
  | ZonesSortQueryStringForCache
  | ZonesSsl
  | ZonesTrueClientIpHeader
  | ZonesWaf
)[];

/**
 * Advanced protection from Distributed Denial of Service (DDoS) attacks on your website. This is an uneditable value that is 'on' in the case of Business and Enterprise zones.
 */
export type ZonesAdvancedDdos = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example advanced_ddos
   */
  id: "advanced_ddos";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesAdvancedDdosValue;
};

/**
 * Value of the zone setting.
 * Notes: Defaults to on for Business+ plans
 *
 * @default off
 */
export type ZonesAdvancedDdosValue = "on" | "off";

/**
 * When enabled, Cloudflare serves limited copies of web pages available from the [Internet Archive's Wayback Machine](https://archive.org/web/) if your server is offline. Refer to [Always Online](https://developers.cloudflare.com/cache/about/always-online) for more information.
 */
export type ZonesAlwaysOnline = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example always_online
   */
  id: "always_online";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesAlwaysOnlineValue;
};

/**
 * Value of the zone setting.
 *
 * @default on
 */
export type ZonesAlwaysOnlineValue = "on" | "off";

export type ZonesAlwaysUseHttps = {
  /**
   * If enabled, any `http://`` URL is converted to `https://` through a
   * 301 redirect.
   *
   * @x-auditable true
   */
  id?: "always_use_https";
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesAlwaysUseHttpsValue = "on" | "off";

export type ZonesApiResponseCommon = {
  errors: ZonesMessages;
  messages: ZonesMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: boolean;
};

export type ZonesApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: ZonesMessages;
  messages: ZonesMessages;
  result: Record<string, any> | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: boolean;
};

export type ZonesApiResponseSingle = ZonesSchemasApiResponseCommon;

export type ZonesApiResponseSingleId = ZonesApiResponseCommon & {
  result?: {
    id: ZonesIdentifier;
  } | null;
};

export type ZonesAutomaticHttpsRewrites = {
  /**
   * Turn on or off Automatic HTTPS Rewrites.
   *
   * @x-auditable true
   */
  id?: "automatic_https_rewrites";
  /**
   * The status of Automatic HTTPS Rewrites.
   *
   * @example on
   * @x-auditable true
   */
  value?: "on" | "off";
};

/**
 * Value of the zone setting.
 * Notes: Default value depends on the zone's plan level.
 *
 * @default on
 */
export type ZonesAutomaticHttpsRewritesValue = "on" | "off";

export type ZonesAutomaticPlatformOptimization = {
  /**
   * Indicates whether or not [cache by device type](https://developers.cloudflare.com/automatic-platform-optimization/reference/cache-device-type/) is enabled.
   *
   * @example false
   */
  cache_by_device_type: boolean;
  /**
   * Indicates whether or not Cloudflare proxy is enabled.
   *
   * @default false
   * @example true
   */
  cf: boolean;
  /**
   * Indicates whether or not Automatic Platform Optimization is enabled.
   *
   * @default false
   * @example true
   */
  enabled: boolean;
  /**
   * An array of hostnames where Automatic Platform Optimization for WordPress is activated.
   *
   * @example www.example.com
   * @example example.com
   * @example shop.example.com
   */
  hostnames: string[];
  /**
   * Indicates whether or not site is powered by WordPress.
   *
   * @default false
   * @example true
   */
  wordpress: boolean;
  /**
   * Indicates whether or not [Cloudflare for WordPress plugin](https://wordpress.org/plugins/cloudflare/) is installed.
   *
   * @default false
   * @example true
   */
  wp_plugin: boolean;
};

export type ZonesBase = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * Identifier of the zone setting.
   *
   * @example development_mode
   */
  id: string;
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: void;
};

/**
 * When the client requesting an asset supports the Brotli compression algorithm, Cloudflare will serve a Brotli compressed version of the asset.
 */
export type ZonesBrotli = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example brotli
   */
  id: "brotli";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesBrotliValue;
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesBrotliValue = "off" | "on";

export type ZonesBrowserCacheTtl = {
  /**
   * Control how long resources cached by client browsers remain valid.
   *
   * @x-auditable true
   */
  id?: "browser_cache_ttl";
  /**
   * The number of seconds to cache resources for. The API prohibits
   * setting this to 0 for non-Enterprise domains.
   *
   * @example 30
   * @maximum 31536000
   * @minimum 0
   * @x-auditable true
   */
  value?: number;
};

/**
 * Value of the zone setting.
 * Notes: Setting a TTL of 0 is equivalent to selecting `Respect Existing Headers`
 *
 * @default 14400
 */
export type ZonesBrowserCacheTtlValue =
  | 0
  | 30
  | 60
  | 120
  | 300
  | 1200
  | 1800
  | 3600
  | 7200
  | 10800
  | 14400
  | 18000
  | 28800
  | 43200
  | 57600
  | 72000
  | 86400
  | 172800
  | 259200
  | 345600
  | 432000
  | 691200
  | 1382400
  | 2073600
  | 2678400
  | 5356800
  | 16070400
  | 31536000;

export type ZonesBrowserCheck = {
  /**
   * Inspect the visitor's browser for headers commonly associated with
   * spammers and certain bots.
   *
   * @x-auditable true
   */
  id?: "browser_check";
  /**
   * The status of Browser Integrity Check.
   *
   * @example on
   * @x-auditable true
   */
  value?: "on" | "off";
};

/**
 * Value of the zone setting.
 *
 * @default on
 */
export type ZonesBrowserCheckValue = "on" | "off";

export type ZonesBypassCacheOnCookie = {
  /**
   * Bypass cache and fetch resources from the origin server if a regular
   * expression matches against a cookie name present in the request.
   *
   * @x-auditable true
   */
  id?: "bypass_cache_on_cookie";
  /**
   * The regular expression to use for matching cookie names in the
   * request. Refer to [Bypass Cache on Cookie
   * setting](https://developers.cloudflare.com/rules/page-rules/reference/additional-reference/#bypass-cache-on-cookie-setting)
   * to learn about limited regular expression support.
   *
   * @example bypass=.*|PHPSESSID=.*
   * @maxLength 150
   * @minLength 1
   * @x-auditable true
   */
  value?: string;
};

/**
 * Aegis provides dedicated egress IPs (from Cloudflare to your origin) for your layer 7 WAF and CDN services. The egress IPs are reserved exclusively for your account so that you can increase your origin security by only allowing traffic from a small list of IP addresses.
 */
export type ZonesCacheRulesAegis = {
  /**
   * ID of the zone setting.
   *
   * @x-auditable true
   * @example aegis
   */
  id: "aegis";
  /**
   * Last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string | null;
  value?: ZonesCacheRulesAegisValue;
};

/**
 * Value of the zone setting.
 */
export type ZonesCacheRulesAegisValue = {
  /**
   * Whether the feature is enabled or not.
   *
   * @x-auditable true
   */
  enabled?: boolean;
  /**
   * Egress pool id which refers to a grouping of dedicated egress IPs through which Cloudflare will connect to origin.
   *
   * @example pool-id
   * @x-auditable true
   */
  pool_id?: string;
};

export type ZonesCacheRulesBase = {
  /**
   * Identifier of the zone setting.
   *
   * @x-auditable true
   */
  id: string;
  /**
   * Last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string | null;
};

/**
 * Origin H2 Max Streams configures the max number of concurrent requests that Cloudflare will send within the same connection when communicating with the origin server, if the origin supports it. Note that if your origin does not support H2 multiplexing, 5xx errors may be observed, particularly 520s. Also note that the default value is `100` for all plan types except Enterprise where it is `1`. `1` means that H2 multiplexing is disabled.
 */
export type ZonesCacheRulesOriginH2MaxStreams = {
  /**
   * Value of the zone setting.
   *
   * @x-auditable true
   * @example origin_h2_max_streams
   */
  id: "origin_h2_max_streams";
  /**
   * Last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string | null;
  value?: ZonesCacheRulesOriginH2MaxStreamsValue;
};

/**
 * Value of the Origin H2 Max Streams Setting.
 *
 * @example 50
 * @maximum 1000
 * @minimum 1
 * @x-auditable true
 */
export type ZonesCacheRulesOriginH2MaxStreamsValue = number;

/**
 * Origin Max HTTP Setting Version sets the highest HTTP version Cloudflare will attempt to use with your origin. This setting allows Cloudflare to make HTTP/2 requests to your origin. (Refer to [Enable HTTP/2 to Origin](https://developers.cloudflare.com/cache/how-to/enable-http2-to-origin/), for more information.). The default value is "2" for all plan types except Enterprise where it is "1"
 */
export type ZonesCacheRulesOriginMaxHttpVersion = {
  /**
   * Value of the zone setting.
   *
   * @x-auditable true
   * @example origin_max_http_version
   */
  id: "origin_max_http_version";
  /**
   * Last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   * @x-auditable true
   */
  modified_on?: string | null;
  value?: ZonesCacheRulesOriginMaxHttpVersionValue;
};

/**
 * Value of the Origin Max HTTP Version Setting.
 *
 * @x-auditable true
 */
export type ZonesCacheRulesOriginMaxHttpVersionValue = "2" | "1";

export type ZonesCacheByDeviceType = {
  /**
   * Separate cached content based on the visitor's device type.
   *
   * @x-auditable true
   */
  id?: "cache_by_device_type";
  /**
   * The status of Cache By Device Type.
   *
   * @example on
   * @x-auditable true
   */
  value?: "on" | "off";
};

export type ZonesCacheDeceptionArmor = {
  /**
   * Protect from web cache deception attacks while still allowing static
   * assets to be cached. This setting verifies that the URL's extension
   * matches the returned `Content-Type`.
   *
   * @x-auditable true
   */
  id?: "cache_deception_armor";
  /**
   * The status of Cache Deception Armor.
   *
   * @example on
   * @x-auditable true
   */
  value?: "on" | "off";
};

export type ZonesCacheKeyFields = {
  /**
   * Control specifically what variables to include when deciding which
   * resources to cache. This allows customers to determine what to cache
   * based on something other than just the URL.
   */
  id?: "cache_key_fields";
  value?: {
    /**
     * Controls which cookies appear in the Cache Key.
     */
    cookie?: {
      /**
       * A list of cookies to check for the presence of, without
       * including their actual values.
       *
       * @example foo
       * @example bar
       * @maxItems 50
       * @minItems 1
       */
      check_presence?: string[];
      /**
       * A list of cookies to include.
       *
       * @example foo
       * @example bar
       * @maxItems 50
       * @minItems 1
       */
      include?: string[];
    };
    /**
     * Controls which headers go into the Cache Key. Exactly one of
     * `include` or `exclude` is expected.
     */
    header?: {
      /**
       * A list of headers to check for the presence of, without
       * including their actual values.
       *
       * @example foo
       * @example bar
       * @maxItems 50
       * @minItems 1
       */
      check_presence?: string[];
      /**
       * A list of headers to ignore.
       *
       * @example foo
       * @example bar
       * @maxItems 50
       * @minItems 1
       */
      exclude?: string[];
      /**
       * A list of headers to include.
       *
       * @example foo
       * @example bar
       * @maxItems 50
       * @minItems 1
       */
      include?: string[];
    };
    /**
     * Determines which host header to include in the Cache Key.
     */
    host?: {
      /**
       * Whether to include the Host header in the HTTP request sent
       * to the origin.
       */
      resolved?: boolean;
    };
    /**
     * Controls which URL query string parameters go into the Cache
     * Key. Exactly one of `include` or `exclude` is expected.
     */
    query_string?: {
      exclude?: "*" | string[];
      include?: "*" | string[];
    };
    /**
     * Feature fields to add features about the end-user (client) into
     * the Cache Key.
     */
    user?: {
      /**
       * Classifies a request as `mobile`, `desktop`, or `tablet`
       * based on the User Agent.
       */
      device_type?: boolean;
      /**
       * Includes the client's country, derived from the IP address.
       */
      geo?: boolean;
      /**
       * Includes the first language code contained in the
       * `Accept-Language` header sent by the client.
       */
      lang?: boolean;
    };
  };
};

export type ZonesCacheLevel = {
  /**
   * Apply custom caching based on the option selected.
   *
   * @x-auditable true
   */
  id?: "cache_level";
  /**
   * * `bypass`: Cloudflare does not cache.
   * * `basic`: Delivers resources from cache when there is no query
   *   string.
   * * `simplified`: Delivers the same resource to everyone independent
   *   of the query string.
   * * `aggressive`: Caches all static content that has a query string.
   * * `cache_everything`: Treats all content as static and caches all
   *   file types beyond the [Cloudflare default cached
   *   content](https://developers.cloudflare.com/cache/concepts/default-cache-behavior/#default-cached-file-extensions).
   *
   * @example bypass
   * @x-auditable true
   */
  value?: "bypass" | "basic" | "simplified" | "aggressive" | "cache_everything";
};

/**
 * Value of the zone setting.
 *
 * @default aggressive
 */
export type ZonesCacheLevelValue = "aggressive" | "basic" | "simplified";

export type ZonesCacheOnCookie = {
  /**
   * Apply the Cache Everything option (Cache Level setting) based on a
   * regular expression match against a cookie name.
   *
   * @x-auditable true
   */
  id?: "cache_on_cookie";
  /**
   * The regular expression to use for matching cookie names in the
   * request.
   *
   * @example bypass=.*|PHPSESSID=.*
   * @maxLength 150
   * @minLength 1
   * @x-auditable true
   */
  value?: string;
};

export type ZonesCacheTtlByStatus = {
  /**
   * Enterprise customers can set cache time-to-live (TTL) based on the
   * response status from the origin web server. Cache TTL refers to the
   * duration of a resource in the Cloudflare network before being
   * marked as stale or discarded from cache. Status codes are returned
   * by a resource's origin. Setting cache TTL based on response status
   * overrides the default cache behavior (standard caching) for static
   * files and overrides cache instructions sent by the origin web
   * server. To cache non-static assets, set a Cache Level of Cache
   * Everything using a Page Rule. Setting no-store Cache-Control or a
   * low TTL (using `max-age`/`s-maxage`) increases requests to origin
   * web servers and decreases performance.
   *
   * @x-auditable true
   */
  id?: "cache_ttl_by_status";
  /**
   * A JSON object containing status codes and their corresponding TTLs.
   * Each key-value pair in the cache TTL by status cache rule has the
   * following syntax
   * - `status_code`: An integer value such as 200 or 500. status_code
   *   matches the exact status code from the origin web server. Valid
   *   status codes are between 100-999.
   * - `status_code_range`: Integer values for from and to.
   *   status_code_range matches any status code from the origin web
   *   server within the specified range.
   * - `value`: An integer value that defines the duration an asset is
   *   valid in seconds or one of the following strings: no-store
   *   (equivalent to -1), no-cache (equivalent to 0).
   *
   * @example {"200-299":86400,"300-499":"no-cache","500-599":"no-store"}
   */
  value?: {
    [key: string]: ("no-cache" | "no-store") | number;
  };
};

/**
 * Specify how long a visitor is allowed access to your site after successfully completing a challenge (such as a CAPTCHA). After the TTL has expired the visitor will have to complete a new challenge. We recommend a 15 - 45 minute setting and will attempt to honor any setting above 45 minutes. (https://support.cloudflare.com/hc/en-us/articles/200170136).
 */
export type ZonesChallengeTtl = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example challenge_ttl
   */
  id: "challenge_ttl";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesChallengeTtlValue;
};

/**
 * Value of the zone setting.
 *
 * @default 1800
 */
export type ZonesChallengeTtlValue =
  | 300
  | 900
  | 1800
  | 2700
  | 3600
  | 7200
  | 10800
  | 14400
  | 28800
  | 57600
  | 86400
  | 604800
  | 2592000
  | 31536000;

/**
 * Determines whether or not the china network is enabled.
 */
export type ZonesChinaNetworkEnabled = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example china_network_enabled
   */
  id: "china_network_enabled";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesChinaNetworkEnabledValue;
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesChinaNetworkEnabledValue = "on" | "off";

/**
 * An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
 */
export type ZonesCiphers = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example ciphers
   */
  id: "ciphers";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesCiphersValue;
};

/**
 * Value of the zone setting.
 *
 * @example ECDHE-RSA-AES128-GCM-SHA256
 * @example AES128-SHA
 * @uniqueItems true
 */
export type ZonesCiphersValue = string[];

/**
 * Whether or not cname flattening is on.
 *
 * @deprecated true
 * @x-stainless-deprecation-message This zone setting is deprecated; please use the DNS Settings route instead. More information at https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#2025-03-21
 */
export type ZonesCnameFlattening = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * How to flatten the cname destination.
   *
   * @example development_mode
   */
  id: "cname_flattening";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesCnameFlatteningValue;
};

/**
 * Value of the cname flattening setting.
 *
 * @default flatten_at_root
 * @deprecated true
 * @x-stainless-deprecation-message This zone setting is deprecated; please use the DNS Settings route instead. More information at https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#2025-03-21
 */
export type ZonesCnameFlatteningValue = "flatten_at_root" | "flatten_all";

export type ZonesComponentsSchemasApiResponseCommon = {
  errors: ZonesMessages;
  messages: ZonesMessages;
  result: Record<string, any> | any[] | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type ZonesComponentsSchemasApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: ZonesMessages;
  messages: ZonesMessages;
  result: Record<string, any> | null;
  /**
   * Whether the API call was successful
   *
   * @example false
   */
  success: boolean;
};

/**
 * The timestamp of when the Page Rule was created.
 *
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type ZonesCreatedOn = string;

/**
 * Development Mode temporarily allows you to enter development mode for your websites if you need to make changes to your site. This will bypass Cloudflare's accelerated cache and slow down your site, but is useful if you are making changes to cacheable content (like images, css, or JavaScript) and would like to see those changes right away. Once entered, development mode will last for 3 hours and then automatically toggle off.
 */
export type ZonesDevelopmentMode = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example development_mode
   */
  id: "development_mode";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesDevelopmentModeValue;
  /**
   * Value of the zone setting.
   * Notes: The interval (in seconds) from when development mode expires (positive integer) or last expired (negative integer) for the domain. If development mode has never been enabled, this value is false.
   *
   * @example 3600
   */
  time_remaining?: number;
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesDevelopmentModeValue = "on" | "off";

export type ZonesDisableApps = {
  /**
   * Turn off all active [Cloudflare Apps](https://developers.cloudflare.com/support/more-dashboard-apps/cloudflare-apps/)
   * (deprecated).
   *
   * @x-auditable true
   */
  id?: "disable_apps";
};

export type ZonesDisablePerformance = {
  /**
   * Turn off
   * [Rocket Loader](https://developers.cloudflare.com/speed/optimization/content/rocket-loader/),
   * [Mirage](https://developers.cloudflare.com/speed/optimization/images/mirage/), and
   * [Polish](https://developers.cloudflare.com/images/polish/).
   *
   * @x-auditable true
   */
  id?: "disable_performance";
};

export type ZonesDisableSecurity = {
  /**
   * Turn off
   * [Email Obfuscation](https://developers.cloudflare.com/waf/tools/scrape-shield/email-address-obfuscation/),
   * [Rate Limiting (previous version, deprecated)](https://developers.cloudflare.com/waf/reference/legacy/old-rate-limiting/),
   * [Scrape Shield](https://developers.cloudflare.com/waf/tools/scrape-shield/),
   * [URL (Zone) Lockdown](https://developers.cloudflare.com/waf/tools/zone-lockdown/), and
   * [WAF managed rules (previous version, deprecated)](https://developers.cloudflare.com/waf/reference/legacy/old-waf-managed-rules/).
   *
   * @x-auditable true
   */
  id?: "disable_security";
};

export type ZonesDisableZaraz = {
  /**
   * Turn off [Zaraz](https://developers.cloudflare.com/zaraz/).
   *
   * @x-auditable true
   */
  id?: "disable_zaraz";
};

/**
 * When enabled, Cloudflare will attempt to speed up overall page loads by serving `103` responses with `Link` headers from the final response. Refer to [Early Hints](https://developers.cloudflare.com/cache/about/early-hints) for more information.
 */
export type ZonesEarlyHints = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example early_hints
   */
  id: "early_hints";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesEarlyHintsValue;
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesEarlyHintsValue = "on" | "off";

export type ZonesEdgeCacheTtl = {
  /**
   * Specify how long to cache a resource in the Cloudflare global
   * network. *Edge Cache TTL* is not visible in response headers.
   *
   * @x-auditable true
   */
  id?: "edge_cache_ttl";
  /**
   * @maximum 31536000
   * @minimum 1
   * @x-auditable true
   */
  value?: number;
};

/**
 * Value of the zone setting.
 * Notes: The minimum TTL available depends on the plan level of the zone. (Enterprise = 30, Business = 1800, Pro = 3600, Free = 7200)
 *
 * @default 7200
 */
export type ZonesEdgeCacheTtlValue =
  | 30
  | 60
  | 300
  | 1200
  | 1800
  | 3600
  | 7200
  | 10800
  | 14400
  | 18000
  | 28800
  | 43200
  | 57600
  | 72000
  | 86400
  | 172800
  | 259200
  | 345600
  | 432000
  | 518400
  | 604800;

export type ZonesEmailObfuscation = {
  /**
   * Turn on or off **Email Obfuscation**.
   *
   * @x-auditable true
   */
  id?: "email_obfuscation";
  /**
   * The status of Email Obfuscation.
   *
   * @example on
   * @x-auditable true
   */
  value?: "on" | "off";
};

/**
 * Value of the zone setting.
 *
 * @default on
 */
export type ZonesEmailObfuscationValue = "on" | "off";

export type ZonesExplicitCacheControl = {
  /**
   * Origin Cache Control is enabled by default for Free, Pro, and
   * Business domains and disabled by default for Enterprise domains.
   *
   * @x-auditable true
   */
  id?: "explicit_cache_control";
  /**
   * The status of Origin Cache Control.
   *
   * @example on
   * @x-auditable true
   */
  value?: "on" | "off";
};

export type ZonesForwardingUrl = {
  /**
   * Redirects one URL to another using an `HTTP 301/302` redirect. Refer
   * to [Wildcard matching and referencing](https://developers.cloudflare.com/rules/page-rules/reference/wildcard-matching/).
   *
   * @example forwarding_url
   * @x-auditable true
   */
  id?: "forwarding_url";
  value?: {
    /**
     * The status code to use for the URL redirect. 301 is a permanent
     * redirect. 302 is a temporary redirect.
     *
     * @example temporary
     * @x-auditable true
     */
    status_code?: 301 | 302;
    /**
     * The URL to redirect the request to.
     * Notes: ${num} refers to the position of '*' in the constraint value.
     *
     * @example http://www.example.com/somewhere/$1/astring/$2/anotherstring/$3
     * @maxLength 1500
     * @x-auditable true
     */
    url?: string;
  };
};

/**
 * HTTP/2 Edge Prioritization optimises the delivery of resources served through HTTP/2 to improve page load performance. It also supports fine control of content delivery when used in conjunction with Workers.
 */
export type ZonesH2Prioritization = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example h2_prioritization
   */
  id: "h2_prioritization";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesH2PrioritizationValue;
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesH2PrioritizationValue = "on" | "off" | "custom";

export type ZonesHostHeaderOverride = {
  /**
   * Apply a specific host header.
   *
   * @x-auditable true
   */
  id?: "host_header_override";
  /**
   * The hostname to use in the `Host` header
   *
   * @example example.com
   * @minLength 1
   * @x-auditable true
   */
  value?: string;
};

/**
 * When enabled, the Hotlink Protection option ensures that other sites cannot suck up your bandwidth by building pages that use images hosted on your site. Anytime a request for an image on your site hits Cloudflare, we check to ensure that it's not another site requesting them. People will still be able to download and view images from your page, but other sites won't be able to steal them for use on their own pages. (https://support.cloudflare.com/hc/en-us/articles/200170026).
 */
export type ZonesHotlinkProtection = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example hotlink_protection
   */
  id: "hotlink_protection";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesHotlinkProtectionValue;
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesHotlinkProtectionValue = "on" | "off";

/**
 * HTTP2 enabled for this zone.
 */
export type ZonesHttp2 = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example http2
   */
  id: "http2";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesHttp2Value;
};

/**
 * Value of the HTTP2 setting.
 *
 * @default off
 */
export type ZonesHttp2Value = "on" | "off";

/**
 * HTTP3 enabled for this zone.
 */
export type ZonesHttp3 = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example http3
   */
  id: "http3";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesHttp3Value;
};

/**
 * Value of the HTTP3 setting.
 *
 * @default off
 */
export type ZonesHttp3Value = "on" | "off";

/**
 * Identifier
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 */
export type ZonesIdentifier = string;

/**
 * Image Transformations provides on-demand resizing, conversion and optimization for images served through Cloudflare's network. Refer to the [Image Transformations documentation](https://developers.cloudflare.com/images/) for more information.
 */
export type ZonesImageResizing = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example image_resizing
   */
  id: "image_resizing";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesImageResizingValue;
};

/**
 * Whether the feature is enabled, disabled, or enabled in `open proxy` mode.
 *
 * @default off
 */
export type ZonesImageResizingValue = "on" | "off" | "open";

export type ZonesIpGeolocation = {
  /**
   * Cloudflare adds a CF-IPCountry HTTP header containing the country code that corresponds to the visitor.
   *
   * @example ip_geolocation
   * @x-auditable true
   */
  id?: "ip_geolocation";
  /**
   * The status of adding the IP Geolocation Header.
   *
   * @example on
   * @x-auditable true
   */
  value?: "on" | "off";
};

/**
 * Value of the zone setting.
 *
 * @default on
 */
export type ZonesIpGeolocationValue = "on" | "off";

/**
 * Enable IPv6 on all subdomains that are Cloudflare enabled.  (https://support.cloudflare.com/hc/en-us/articles/200168586).
 */
export type ZonesIpv6 = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example ipv6
   */
  id: "ipv6";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesIpv6Value;
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesIpv6Value = "off" | "on";

/**
 * Maximum size of an allowable upload.
 */
export type ZonesMaxUpload = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * identifier of the zone setting.
   *
   * @example max_upload
   */
  id: "max_upload";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesMaxUploadValue;
};

/**
 * Value of the zone setting.
 * Notes: The size depends on the plan level of the zone. (Enterprise = 500, Business = 200, Pro = 100, Free = 100)
 *
 * @default 100
 */
export type ZonesMaxUploadValue =
  | 100
  | 125
  | 150
  | 175
  | 200
  | 225
  | 250
  | 275
  | 300
  | 325
  | 350
  | 375
  | 400
  | 425
  | 450
  | 475
  | 500
  | 1000;

export type ZonesMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  message: string;
}[];

/**
 * Only accepts HTTPS requests that use at least the TLS protocol version specified. For example, if TLS 1.1 is selected, TLS 1.0 connections will be rejected, while 1.1, 1.2, and 1.3 (if enabled) will be permitted.
 *
 * @default 1.0
 */
export type ZonesMinTlsVersion = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example min_tls_version
   */
  id: "min_tls_version";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesMinTlsVersionValue;
};

/**
 * Value of the zone setting.
 *
 * @default 1.0
 */
export type ZonesMinTlsVersionValue = "1.0" | "1.1" | "1.2" | "1.3";

export type ZonesMirage = {
  /**
   * Cloudflare Mirage reduces bandwidth used by images in mobile browsers.
   * It can accelerate loading of image-heavy websites on very slow mobile connections and HTTP/1.
   *
   * @example mirage
   * @x-auditable true
   */
  id?: "mirage";
  /**
   * The status of Mirage.
   *
   * @example on
   * @x-auditable true
   */
  value?: "on" | "off";
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesMirageValue = "on" | "off";

/**
 * The timestamp of when the Page Rule was last modified.
 *
 * @example 2014-01-01T05:20:00.12345Z
 * @format date-time
 * @x-auditable true
 */
export type ZonesModifiedOn = string;

export type ZonesMultipleSettings = (
  | Zones0rtt
  | ZonesAdvancedDdos
  | ZonesCacheRulesAegis
  | ZonesAlwaysOnline
  | ZonesSchemasAlwaysUseHttps
  | ZonesSchemasAutomaticHttpsRewrites
  | ZonesBrotli
  | ZonesSchemasBrowserCacheTtl
  | ZonesSchemasBrowserCheck
  | ZonesSchemasCacheLevel
  | ZonesChallengeTtl
  | ZonesChinaNetworkEnabled
  | ZonesCiphers
  | ZonesCnameFlattening
  | ZonesDevelopmentMode
  | ZonesEarlyHints
  | ZonesSchemasEdgeCacheTtl
  | ZonesSchemasEmailObfuscation
  | ZonesH2Prioritization
  | ZonesHotlinkProtection
  | ZonesHttp2
  | ZonesHttp3
  | ZonesSchemasIpGeolocation
  | ZonesIpv6
  | ZonesMaxUpload
  | ZonesMinTlsVersion
  | ZonesSchemasMirage
  | ZonesNel
  | ZonesSchemasOpportunisticEncryption
  | ZonesOpportunisticOnion
  | ZonesOrangeToOrange
  | ZonesSchemasOriginErrorPagePassThru
  | ZonesCacheRulesOriginH2MaxStreams
  | ZonesCacheRulesOriginMaxHttpVersion
  | ZonesSchemasPolish
  | ZonesPrefetchPreload
  | ZonesPrivacyPass
  | ZonesProxyReadTimeout
  | ZonesPseudoIpv4
  | ZonesReplaceInsecureJs
  | ZonesSchemasResponseBuffering
  | ZonesSchemasRocketLoader
  | ZonesSchemasAutomaticPlatformOptimization
  | ZonesSecurityHeader
  | ZonesSchemasSecurityLevel
  | ZonesServerSideExclude
  | ZonesSha1Support
  | ZonesSchemasSortQueryStringForCache
  | ZonesSchemasSsl
  | ZonesSslRecommender
  | ZonesTls12Only
  | ZonesTls13
  | ZonesTlsClientAuth
  | ZonesSchemasTrueClientIpHeader
  | ZonesSchemasWaf
  | ZonesWebp
  | ZonesWebsockets
)[];

/**
 * The domain name.
 *
 * @example example.com
 * @maxLength 253
 * @pattern ^([a-zA-Z0-9][\-a-zA-Z0-9]*\.)+[\-a-zA-Z0-9]{2,20}$
 */
export type ZonesName = string;

/**
 * Enable Network Error Logging reporting on your zone. (Beta)
 */
export type ZonesNel = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * Zone setting identifier.
   *
   * @example nel
   */
  id: "nel";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesNelValue;
};

/**
 * Value of the zone setting.
 *
 * @default {"enabled":false}
 */
export type ZonesNelValue = {
  /**
   * @default false
   * @example false
   */
  enabled?: boolean;
};

export type ZonesOpportunisticEncryption = {
  /**
   * Opportunistic Encryption allows browsers to access HTTP URIs over an encrypted TLS channel.
   * It's not a substitute for HTTPS, but provides additional security for otherwise vulnerable requests.
   *
   * @example opportunistic_encryption
   * @x-auditable true
   */
  id?: "opportunistic_encryption";
  /**
   * The status of Opportunistic Encryption.
   *
   * @example on
   * @x-auditable true
   */
  value?: "on" | "off";
};

/**
 * Value of the zone setting.
 * Notes: Default value depends on the zone's plan level.
 *
 * @default on
 */
export type ZonesOpportunisticEncryptionValue = "on" | "off";

/**
 * Add an Alt-Svc header to all legitimate requests from Tor, allowing the connection to use our onion services instead of exit nodes.
 *
 * @default off
 */
export type ZonesOpportunisticOnion = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example opportunistic_onion
   */
  id: "opportunistic_onion";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesOpportunisticOnionValue;
};

/**
 * Value of the zone setting.
 * Notes: Default value depends on the zone's plan level.
 *
 * @default off
 */
export type ZonesOpportunisticOnionValue = "on" | "off";

/**
 * Orange to Orange (O2O) allows zones on Cloudflare to CNAME to other zones also on Cloudflare.
 */
export type ZonesOrangeToOrange = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example orange_to_orange
   */
  id: "orange_to_orange";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesOrangeToOrangeValue;
};

/**
 * Value of the zone setting.
 *
 * @default on
 */
export type ZonesOrangeToOrangeValue = "on" | "off";

export type ZonesOriginErrorPagePassThru = {
  /**
   * Turn on or off Cloudflare error pages generated from issues sent from the origin server. If enabled, this setting triggers error pages issued by the origin.
   *
   * @example origin_error_page_pass_thru
   * @x-auditable true
   */
  id?: "origin_error_page_pass_thru";
  /**
   * The status of Origin Error Page Passthru.
   *
   * @example on
   * @x-auditable true
   */
  value?: "on" | "off";
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesOriginErrorPagePassThruValue = "on" | "off";

export type ZonesPageRule = {
  actions: ZonesActions;
  created_on: ZonesCreatedOn;
  id: ZonesSchemasIdentifier;
  modified_on: ZonesModifiedOn;
  priority: ZonesPriority;
  status: ZonesStatus;
  targets: ZonesTargets;
};

/**
 * Indicates whether the zone is only using Cloudflare DNS services. A
 * true value means the zone will not receive security or performance
 * benefits.
 *
 * @default false
 */
export type ZonesPaused = boolean;

export type ZonesPolish = {
  /**
   * Apply options from the Polish feature of the Cloudflare Speed app.
   *
   * @example polish
   * @x-auditable true
   */
  id?: "polish";
  /**
   * The level of Polish you want applied to your origin.
   *
   * @example lossless
   * @x-auditable true
   */
  value?: "off" | "lossless" | "lossy";
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesPolishValue = "off" | "lossless" | "lossy";

/**
 * Cloudflare will prefetch any URLs that are included in the response headers. This is limited to Enterprise Zones.
 *
 * @default off
 */
export type ZonesPrefetchPreload = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example prefetch_preload
   */
  id: "prefetch_preload";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesPrefetchPreloadValue;
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesPrefetchPreloadValue = "on" | "off";

/**
 * The priority of the rule, used to define which Page Rule is processed
 * over another. A higher number indicates a higher priority. For example,
 * if you have a catch-all Page Rule (rule A: `/images/*`) but want a more
 * specific Page Rule to take precedence (rule B: `/images/special/*`),
 * specify a higher priority for rule B so it overrides rule A.
 *
 * @default 1
 * @x-auditable true
 */
export type ZonesPriority = number;

/**
 * Privacy Pass v1 was a browser extension developed by the Privacy Pass Team to improve the browsing experience for your visitors by allowing users to reduce the number of CAPTCHAs shown. (https://support.cloudflare.com/hc/en-us/articles/115001992652-Privacy-Pass).
 *
 * @default off
 * @deprecated true
 * @x-stainless-deprecation-message Privacy Pass v1 was deprecated in 2023. (Announcement - https://blog.cloudflare.com/privacy-pass-standard/) and (API deprecation details - https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#2024-03-31)
 */
export type ZonesPrivacyPass = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example privacy_pass
   */
  id: "privacy_pass";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesPrivacyPassValue;
};

/**
 * Value of the Privacy Pass v1 (deprecated) zone setting
 *
 * @default off
 * @deprecated true
 * @x-stainless-deprecation-message Privacy Pass v1 was deprecated in 2023. (Announcement - https://blog.cloudflare.com/privacy-pass-standard/) and (API deprecation details - https://developers.cloudflare.com/fundamentals/api/reference/deprecations/#2024-03-31)
 */
export type ZonesPrivacyPassValue = "on" | "off";

/**
 * Maximum time between two read operations from origin.
 */
export type ZonesProxyReadTimeout = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example proxy_read_timeout
   */
  id: "proxy_read_timeout";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesProxyReadTimeoutValue;
};

/**
 * Value of the zone setting.
 * Notes: Value must be between 1 and 6000
 *
 * @default 100
 */
export type ZonesProxyReadTimeoutValue = number;

/**
 * The value set for the Pseudo IPv4 setting.
 */
export type ZonesPseudoIpv4 = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * Value of the Pseudo IPv4 setting.
   *
   * @example development_mode
   * @default pseudo_ipv4
   */
  id: "pseudo_ipv4";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesPseudoIpv4Value;
};

/**
 * Value of the Pseudo IPv4 setting.
 *
 * @default off
 */
export type ZonesPseudoIpv4Value = "off" | "add_header" | "overwrite_header";

/**
 * Automatically replace insecure JavaScript libraries with safer and faster alternatives provided under cdnjs and powered by Cloudflare. Currently supports the following libraries: Polyfill under polyfill.io.
 */
export type ZonesReplaceInsecureJs = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example replace_insecure_js
   */
  id: "replace_insecure_js";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesReplaceInsecureJsValue;
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesReplaceInsecureJsValue = "on" | "off";

export type ZonesResolveOverride = {
  /**
   * Change the origin address to the value specified in this setting.
   *
   * @example resolve_override
   * @x-auditable true
   */
  id?: "resolve_override";
  /**
   * The origin address you want to override with.
   *
   * @example example.com
   * @x-auditable true
   */
  value?: string;
};

export type ZonesRespectStrongEtag = {
  /**
   * Turn on or off byte-for-byte equivalency checks between the
   * Cloudflare cache and the origin server.
   *
   * @x-auditable true
   */
  id?: "respect_strong_etag";
  /**
   * The status of Respect Strong ETags
   *
   * @example on
   * @x-auditable true
   */
  value?: "on" | "off";
};

export type ZonesResponseBuffering = {
  /**
   * Turn on or off whether Cloudflare should wait for an entire file
   * from the origin server before forwarding it to the site visitor. By
   * default, Cloudflare sends packets to the client as they arrive from
   * the origin server.
   *
   * @x-auditable true
   */
  id?: "response_buffering";
  /**
   * The status of Response Buffering
   *
   * @example on
   * @x-auditable true
   */
  value?: "on" | "off";
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesResponseBufferingValue = "on" | "off";

export type ZonesResultInfo = {
  /**
   * Total number of results for the requested service.
   *
   * @example 1
   */
  count?: number;
  /**
   * Current page within paginated list of results.
   *
   * @example 1
   */
  page?: number;
  /**
   * Number of results per page of results.
   *
   * @example 20
   */
  per_page?: number;
  /**
   * Total results available without any search parameters.
   *
   * @example 2000
   */
  total_count?: number;
  /**
   * Total number of pages
   *
   * @example 100
   */
  total_pages?: number;
};

export type ZonesRocketLoader = {
  /**
   * Turn on or off Rocket Loader in the Cloudflare Speed app.
   *
   * @x-auditable true
   */
  id?: "rocket_loader";
  /**
   * The status of Rocket Loader
   *
   * @example on
   * @x-auditable true
   */
  value?: "on" | "off";
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesRocketLoaderValue = "on" | "off";

/**
 * Reply to all requests for URLs that use "http" with a 301 redirect to the equivalent "https" URL. If you only want to redirect for a subset of requests, consider creating an "Always use HTTPS" page rule.
 *
 * @default off
 */
export type ZonesSchemasAlwaysUseHttps = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example always_use_https
   */
  id: "always_use_https";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesAlwaysUseHttpsValue;
};

export type ZonesSchemasApiResponseCommon = {
  errors: ZonesSchemasMessages;
  messages: ZonesSchemasMessages;
  /**
   * Whether the API call was successful.
   *
   * @example true
   */
  success: true;
};

export type ZonesSchemasApiResponseCommonFailure = {
  /**
   * @example {"code":7003,"message":"No route for the URI"}
   * @minLength 1
   */
  errors: ZonesSchemasMessages;
  messages: ZonesSchemasMessages;
  result: any | null;
  /**
   * Whether the API call was successful.
   *
   * @example false
   */
  success: false;
};

export type ZonesSchemasApiResponseSingle = {
  errors: ZonesMessages;
  messages: ZonesMessages;
  result: Record<string, any> | string | string;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: true;
};

export type ZonesSchemasApiResponseSingleId = ZonesSchemasApiResponseCommon & {
  result?: {
    id: ZonesSchemasIdentifier;
  } | null;
};

/**
 * Enable the Automatic HTTPS Rewrites feature for this zone.
 *
 * @default off
 */
export type ZonesSchemasAutomaticHttpsRewrites = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example automatic_https_rewrites
   */
  id: "automatic_https_rewrites";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesAutomaticHttpsRewritesValue;
};

/**
 * [Automatic Platform Optimization for WordPress](https://developers.cloudflare.com/automatic-platform-optimization/) serves your WordPress site from Cloudflare's edge network and caches third-party fonts.
 */
export type ZonesSchemasAutomaticPlatformOptimization = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example automatic_platform_optimization
   */
  id: "automatic_platform_optimization";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesAutomaticPlatformOptimization;
};

/**
 * Browser Cache TTL (in seconds) specifies how long Cloudflare-cached resources will remain on your visitors' computers. Cloudflare will honor any larger times specified by your server. (https://support.cloudflare.com/hc/en-us/articles/200168276).
 */
export type ZonesSchemasBrowserCacheTtl = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example browser_cache_ttl
   */
  id: "browser_cache_ttl";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesBrowserCacheTtlValue;
};

/**
 * Browser Integrity Check is similar to Bad Behavior and looks for common HTTP headers abused most commonly by spammers and denies access to your page.  It will also challenge visitors that do not have a user agent or a non standard user agent (also commonly used by abuse bots, crawlers or visitors). (https://support.cloudflare.com/hc/en-us/articles/200170086).
 */
export type ZonesSchemasBrowserCheck = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example browser_check
   */
  id: "browser_check";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesBrowserCheckValue;
};

/**
 * Cache Level functions based off the setting level. The basic setting will cache most static resources (i.e., css, images, and JavaScript). The simplified setting will ignore the query string when delivering a cached resource. The aggressive setting will cache all static resources, including ones with a query string. (https://support.cloudflare.com/hc/en-us/articles/200168256).
 */
export type ZonesSchemasCacheLevel = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example cache_level
   */
  id: "cache_level";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesCacheLevelValue;
};

/**
 * Time (in seconds) that a resource will be ensured to remain on Cloudflare's cache servers.
 */
export type ZonesSchemasEdgeCacheTtl = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example edge_cache_ttl
   */
  id: "edge_cache_ttl";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesEdgeCacheTtlValue;
};

/**
 * Encrypt email adresses on your web page from bots, while keeping them visible to humans. (https://support.cloudflare.com/hc/en-us/articles/200170016).
 */
export type ZonesSchemasEmailObfuscation = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example email_obfuscation
   */
  id: "email_obfuscation";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesEmailObfuscationValue;
};

/**
 * Identifier.
 *
 * @example 023e105f4ecef8ad9ca31a8372d0c353
 * @maxLength 32
 * @x-auditable true
 */
export type ZonesSchemasIdentifier = string;

/**
 * Enable IP Geolocation to have Cloudflare geolocate visitors to your website and pass the country code to you. (https://support.cloudflare.com/hc/en-us/articles/200168236).
 */
export type ZonesSchemasIpGeolocation = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example ip_geolocation
   */
  id: "ip_geolocation";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesIpGeolocationValue;
};

export type ZonesSchemasMessages = {
  /**
   * @minimum 1000
   */
  code: number;
  documentation_url?: string;
  message: string;
  source?: {
    pointer?: string;
  };
}[];

/**
 * Automatically optimize image loading for website visitors on mobile
 * devices. Refer to [our blog post](http://blog.cloudflare.com/mirage2-solving-mobile-speed)
 * for more information.
 */
export type ZonesSchemasMirage = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example mirage
   */
  id: "mirage";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesMirageValue;
};

/**
 * Enables the Opportunistic Encryption feature for a zone.
 */
export type ZonesSchemasOpportunisticEncryption = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example opportunistic_encryption
   */
  id: "opportunistic_encryption";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesOpportunisticEncryptionValue;
};

/**
 * Cloudflare will proxy customer error pages on any 502,504 errors on origin server instead of showing a default Cloudflare error page. This does not apply to 522 errors and is limited to Enterprise Zones.
 *
 * @default off
 */
export type ZonesSchemasOriginErrorPagePassThru = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example origin_error_page_pass_thru
   */
  id: "origin_error_page_pass_thru";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesOriginErrorPagePassThruValue;
};

/**
 * Removes metadata and compresses your images for faster page load times. Basic (Lossless): Reduce the size of PNG, JPEG, and GIF files - no impact on visual quality. Basic + JPEG (Lossy): Further reduce the size of JPEG files for faster image loading. Larger JPEGs are converted to progressive images, loading a lower-resolution image first and ending in a higher-resolution version. Not recommended for hi-res photography sites.
 */
export type ZonesSchemasPolish = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example polish
   */
  id: "polish";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesPolishValue;
};

/**
 * Enables or disables buffering of responses from the proxied server. Cloudflare may buffer the whole payload to deliver it at once to the client versus allowing it to be delivered in chunks. By default, the proxied server streams directly and is not buffered by Cloudflare. This is limited to Enterprise Zones.
 *
 * @default off
 */
export type ZonesSchemasResponseBuffering = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example response_buffering
   */
  id: "response_buffering";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesResponseBufferingValue;
};

/**
 * Rocket Loader is a general-purpose asynchronous JavaScript optimisation that prioritises rendering your content while loading your site's Javascript asynchronously. Turning on Rocket Loader will immediately improve a web page's rendering time sometimes measured as Time to First Paint (TTFP), and also the `window.onload` time (assuming there is JavaScript on the page). This can have a positive impact on your Google search ranking. When turned on, Rocket Loader will automatically defer the loading of all Javascript referenced in your HTML, with no configuration required. Refer to [Understanding Rocket Loader](https://support.cloudflare.com/hc/articles/200168056) for more information.
 */
export type ZonesSchemasRocketLoader = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example rocket_loader
   */
  id: "rocket_loader";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesRocketLoaderValue;
};

/**
 * Choose the appropriate security profile for your website, which will automatically adjust each of the security settings. If you choose to customize an individual security setting, the profile will become Custom. (https://support.cloudflare.com/hc/en-us/articles/200170056).
 */
export type ZonesSchemasSecurityLevel = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example security_level
   */
  id: "security_level";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesSecurityLevelValue;
};

/**
 * Cloudflare will treat files with the same query strings as the same file in cache, regardless of the order of the query strings. This is limited to Enterprise Zones.
 *
 * @default off
 */
export type ZonesSchemasSortQueryStringForCache = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example sort_query_string_for_cache
   */
  id: "sort_query_string_for_cache";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesSortQueryStringForCacheValue;
};

/**
 * SSL encrypts your visitor's connection and safeguards credit card numbers and other personal data to and from your website. SSL can take up to 5 minutes to fully activate. Requires Cloudflare active on your root domain or www domain. Off: no SSL between the visitor and Cloudflare, and no SSL between Cloudflare and your web server  (all HTTP traffic). Flexible: SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, but no SSL between Cloudflare and your web server. You don't need to have an SSL cert on your web server, but your vistors will still see the site as being HTTPS enabled. Full:  SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have your own SSL cert or self-signed cert at the very least. Full (Strict): SSL between the visitor and Cloudflare -- visitor sees HTTPS on your site, and SSL between Cloudflare and your web server. You'll need to have a valid SSL certificate installed on your web server. This certificate must be signed by a certificate authority, have an expiration date in the future, and respond for the request domain name (hostname). (https://support.cloudflare.com/hc/en-us/articles/200170416).
 */
export type ZonesSchemasSsl = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example ssl
   */
  id: "ssl";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesSslValue;
};

/**
 * Allows customer to continue to use True Client IP (Akamai feature) in the headers we send to the origin. This is limited to Enterprise Zones.
 *
 * @default off
 */
export type ZonesSchemasTrueClientIpHeader = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example true_client_ip_header
   */
  id: "true_client_ip_header";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesTrueClientIpHeaderValue;
};

/**
 * The WAF examines HTTP requests to your website.  It inspects both GET and POST requests and applies rules to help filter out illegitimate traffic from legitimate website visitors. The Cloudflare WAF inspects website addresses or URLs to detect anything out of the ordinary. If the Cloudflare WAF determines suspicious user behavior, then the WAF will 'challenge' the web visitor with a page that asks them to submit a CAPTCHA successfully  to continue their action. If the challenge is failed, the action will be stopped. What this means is that Cloudflare's WAF will block any traffic identified as illegitimate before it reaches your origin web server. (https://support.cloudflare.com/hc/en-us/articles/200172016).
 */
export type ZonesSchemasWaf = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example waf
   */
  id: "waf";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesWafValue;
};

/**
 * Cloudflare security header for a zone.
 */
export type ZonesSecurityHeader = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone's security header.
   *
   * @example security_header
   */
  id: "security_header";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesSecurityHeaderValue;
};

/**
 * @default {"strict_transport_security":{"enabled":true,"include_subdomains":true,"max_age":86400,"nosniff":true,"preload":false}}
 */
export type ZonesSecurityHeaderValue = {
  /**
   * Strict Transport Security.
   */
  strict_transport_security?: {
    /**
     * Whether or not strict transport security is enabled.
     *
     * @example true
     */
    enabled?: boolean;
    /**
     * Include all subdomains for strict transport security.
     *
     * @example true
     */
    include_subdomains?: boolean;
    /**
     * Max age in seconds of the strict transport security.
     *
     * @example 86400
     */
    max_age?: number;
    /**
     * Whether or not to include 'X-Content-Type-Options: nosniff' header.
     *
     * @example true
     */
    nosniff?: boolean;
    /**
     * Enable automatic preload of the HSTS configuration.
     *
     * @example true
     */
    preload?: boolean;
  };
};

export type ZonesSecurityLevel = {
  /**
   * Control options for the **Security Level** feature from the **Security** app.
   *
   * @x-auditable true
   */
  id?: "security_level";
  /**
   * @example under_attack
   * @x-auditable true
   */
  value?:
    | "off"
    | "essentially_off"
    | "low"
    | "medium"
    | "high"
    | "under_attack";
};

/**
 * Value of the zone setting.
 *
 * @default medium
 */
export type ZonesSecurityLevelValue =
  | "off"
  | "essentially_off"
  | "low"
  | "medium"
  | "high"
  | "under_attack";

/**
 * If there is sensitive content on your website that you want visible to real visitors, but that you want to hide from suspicious visitors, all you have to do is wrap the content with Cloudflare SSE tags. Wrap any content that you want to be excluded from suspicious visitors in the following SSE tags: <!--sse--><!--/sse-->. For example: <!--sse-->  Bad visitors won't see my phone number, 555-555-5555 <!--/sse-->. Note: SSE only will work with HTML. If you have HTML minification enabled, you won't see the SSE tags in your HTML source when it's served through Cloudflare. SSE will still function in this case, as Cloudflare's HTML minification and SSE functionality occur on-the-fly as the resource moves through our network to the visitor's computer. (https://support.cloudflare.com/hc/en-us/articles/200170036).
 */
export type ZonesServerSideExclude = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example server_side_exclude
   */
  id: "server_side_exclude";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesServerSideExcludeValue;
};

/**
 * Value of the zone setting.
 *
 * @default on
 */
export type ZonesServerSideExcludeValue = "on" | "off";

export type ZonesSetting =
  | Zones0rtt
  | ZonesAdvancedDdos
  | ZonesCacheRulesAegis
  | ZonesAlwaysOnline
  | ZonesSchemasAlwaysUseHttps
  | ZonesSchemasAutomaticHttpsRewrites
  | ZonesBrotli
  | ZonesSchemasBrowserCacheTtl
  | ZonesSchemasBrowserCheck
  | ZonesSchemasCacheLevel
  | ZonesChallengeTtl
  | ZonesChinaNetworkEnabled
  | ZonesCiphers
  | ZonesCnameFlattening
  | ZonesDevelopmentMode
  | ZonesEarlyHints
  | ZonesSchemasEdgeCacheTtl
  | ZonesSchemasEmailObfuscation
  | ZonesH2Prioritization
  | ZonesHotlinkProtection
  | ZonesHttp2
  | ZonesHttp3
  | ZonesImageResizing
  | ZonesSchemasIpGeolocation
  | ZonesIpv6
  | ZonesMaxUpload
  | ZonesMinTlsVersion
  | ZonesSchemasMirage
  | ZonesNel
  | ZonesSchemasOpportunisticEncryption
  | ZonesOpportunisticOnion
  | ZonesOrangeToOrange
  | ZonesSchemasOriginErrorPagePassThru
  | ZonesCacheRulesOriginH2MaxStreams
  | ZonesCacheRulesOriginMaxHttpVersion
  | ZonesSchemasPolish
  | ZonesPrefetchPreload
  | ZonesPrivacyPass
  | ZonesProxyReadTimeout
  | ZonesPseudoIpv4
  | ZonesReplaceInsecureJs
  | ZonesSchemasResponseBuffering
  | ZonesSchemasRocketLoader
  | ZonesSchemasAutomaticPlatformOptimization
  | ZonesSecurityHeader
  | ZonesSchemasSecurityLevel
  | ZonesServerSideExclude
  | ZonesSha1Support
  | ZonesSchemasSortQueryStringForCache
  | ZonesSchemasSsl
  | ZonesSslRecommender
  | ZonesTls12Only
  | ZonesTls13
  | ZonesTlsClientAuth
  | ZonesTransformations
  | ZonesTransformationsAllowedOrigins
  | ZonesSchemasTrueClientIpHeader
  | ZonesSchemasWaf
  | ZonesWebp
  | ZonesWebsockets;

/**
 * Setting name
 *
 * @example always_online
 */
export type ZonesSettingName = string;

export type ZonesSettingReadonly = false;

/**
 * Value of the zone setting.
 */
export type ZonesSettingToggle = "on" | "off";

export type ZonesSettingValue =
  | Zones0rttValue
  | ZonesAdvancedDdosValue
  | ZonesCacheRulesAegisValue
  | ZonesAlwaysOnlineValue
  | ZonesAlwaysUseHttpsValue
  | ZonesAutomaticHttpsRewritesValue
  | ZonesBrotliValue
  | ZonesBrowserCacheTtlValue
  | ZonesBrowserCheckValue
  | ZonesCacheLevelValue
  | ZonesChallengeTtlValue
  | ZonesChinaNetworkEnabledValue
  | ZonesCiphersValue
  | ZonesCnameFlatteningValue
  | ZonesDevelopmentModeValue
  | ZonesEarlyHintsValue
  | ZonesEdgeCacheTtlValue
  | ZonesEmailObfuscationValue
  | ZonesH2PrioritizationValue
  | ZonesHotlinkProtectionValue
  | ZonesHttp2Value
  | ZonesHttp3Value
  | ZonesImageResizingValue
  | ZonesIpGeolocationValue
  | ZonesIpv6Value
  | ZonesMaxUploadValue
  | ZonesMinTlsVersionValue
  | ZonesMirageValue
  | ZonesNelValue
  | ZonesOpportunisticEncryptionValue
  | ZonesOpportunisticOnionValue
  | ZonesOrangeToOrangeValue
  | ZonesOriginErrorPagePassThruValue
  | ZonesCacheRulesOriginH2MaxStreamsValue
  | ZonesCacheRulesOriginMaxHttpVersionValue
  | ZonesPolishValue
  | ZonesPrefetchPreloadValue
  | ZonesPrivacyPassValue
  | ZonesProxyReadTimeoutValue
  | ZonesPseudoIpv4Value
  | ZonesReplaceInsecureJsValue
  | ZonesResponseBufferingValue
  | ZonesRocketLoaderValue
  | ZonesAutomaticPlatformOptimization
  | ZonesSecurityHeaderValue
  | ZonesSecurityLevelValue
  | ZonesServerSideExcludeValue
  | ZonesSha1SupportValue
  | ZonesSortQueryStringForCacheValue
  | ZonesSslValue
  | ZonesTls12OnlyValue
  | ZonesTls13Value
  | ZonesTlsClientAuthValue
  | ZonesTrueClientIpHeaderValue
  | ZonesWafValue
  | ZonesWebpValue
  | ZonesWebsocketsValue;

export type ZonesSettingWritable = true;

/**
 * Settings available for the zone.
 *
 * @example {"id":"browser_check","properties":[{"name":"value","type":"toggle"}]}
 * @example {"id":"browser_cache_ttl","properties":[{"max":31536000,"min":1800,"name":"value","suggested_values":[1800,3600,7200,10800,14400,18000,28800,43200,57600,72000,86400,172800,259200,345600,432000,691200,1382400,2073600,2678400,5356800,16070400,31536000],"type":"range"}]}
 * @example {"id":"browser_check","properties":[{"name":"value","type":"toggle"}]}
 * @example {"id":"cache_key_fields","properties":[{"name":"value","properties":[{"allowEmpty":true,"choices":["include","exclude"],"multiple":false,"name":"query_string","type":"select"},{"allowEmpty":true,"choices":["include","exclude","check_presence"],"multiple":true,"name":"header","type":"select"},{"allowEmpty":false,"choices":["resolved"],"multiple":true,"name":"host","type":"select"},{"allowEmpty":true,"choices":["include","check_presence"],"multiple":true,"name":"cookie","type":"select"},{"allowEmpty":false,"choices":["device_type","geo","lang"],"multiple":true,"name":"user","type":"select"}],"type":"object"}]}
 * @example {"id":"cache_deception_armor","properties":[{"name":"value","type":"toggle"}]}
 * @example {"id":"cache_level","properties":[{"choices":["bypass","basic","simplified","aggressive","cache_everything"],"multiple":false,"name":"value","type":"select"}]}
 * @example {"id":"cache_ttl_by_status","properties":[{"allowEmpty":false,"name":"value","type":"object"}]}
 * @example {"id":"disable_apps","properties":[]}
 * @example {"id":"disable_performance","properties":[]}
 * @example {"id":"disable_security","properties":[]}
 * @example {"id":"edge_cache_ttl","properties":[{"max":2419200,"min":7200,"name":"value","suggested_values":[7200,10800,14400,18000,28800,43200,57600,72000,86400,172800,259200,345600,432000,518400,604800,1209600,2419200],"type":"range"}]}
 * @example {"id":"email_obfuscation","properties":[{"name":"value","type":"toggle"}]}
 * @example {"id":"forwarding_url","properties":[{"choices":[301,302],"multiple":false,"name":"status_code","type":"choice"},{"name":"url","type":"forwardingUrl"}]}
 * @example {"id":"ip_geolocation","properties":[{"name":"value","type":"toggle"}]}
 * @example {"id":"explicit_cache_control","properties":[{"name":"value","type":"toggle"}]}
 * @example {"id":"rocket_loader","properties":[{"name":"value","type":"toggle"}]}
 * @example {"id":"security_level","properties":[{"choices":["essentially_off","low","medium","high","under_attack"],"multiple":false,"name":"value","type":"select"}]}
 * @example {"id":"server_side_exclude","properties":[{"name":"value","type":"toggle"}]}
 * @example {"id":"ssl","properties":[{"choices":["off","flexible","full","strict"],"multiple":false,"name":"value","type":"choice"}]}
 */
export type ZonesSettings = Record<string, any>[];

export type ZonesSettingsApiComponentsSchemasApiResponseCommon = {
  errors: ZonesMessages;
  messages: ZonesMessages;
  /**
   * Whether the API call was successful
   *
   * @example true
   */
  success: boolean;
};

/**
 * Allow SHA1 support.
 */
export type ZonesSha1Support = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * Zone setting identifier.
   *
   * @example sha1_support
   */
  id: "sha1_support";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesSha1SupportValue;
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesSha1SupportValue = "off" | "on";

export type ZonesSortQueryStringForCache = {
  /**
   * Turn on or off the reordering of query strings. When query strings have the same structure, caching improves.
   *
   * @example sort_query_string_for_cache
   * @x-auditable true
   */
  id?: "sort_query_string_for_cache";
  /**
   * The status of Query String Sort
   *
   * @example on
   * @x-auditable true
   */
  value?: "on" | "off";
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesSortQueryStringForCacheValue = "on" | "off";

export type ZonesSsl = {
  /**
   * Control options for the SSL feature of the Edge Certificates tab in the Cloudflare SSL/TLS app.
   *
   * @x-auditable true
   */
  id?: "ssl";
  /**
   * The encryption mode that Cloudflare uses to connect to your origin server.
   *
   * @example full
   * @x-auditable true
   */
  value?: "off" | "flexible" | "full" | "strict" | "origin_pull";
};

/**
 * Enrollment in the SSL/TLS Recommender service which tries to detect and recommend (by sending periodic emails) the most secure SSL/TLS setting your origin servers support.
 */
export type ZonesSslRecommender = {
  enabled?: ZonesSslRecommenderEnabled;
  /**
   * Enrollment value for SSL/TLS Recommender.
   *
   * @example ssl_recommender
   */
  id?: "ssl_recommender";
};

/**
 * ssl-recommender enrollment setting.
 *
 * @default false
 */
export type ZonesSslRecommenderEnabled = boolean;

/**
 * Value of the zone setting.
 * Notes: Depends on the zone's plan level
 *
 * @default off
 */
export type ZonesSslValue = "off" | "flexible" | "full" | "strict";

/**
 * The status of the Page Rule.
 *
 * @default disabled
 * @example active
 * @x-auditable true
 */
export type ZonesStatus = "active" | "disabled";

/**
 * String constraint.
 */
export type ZonesStringConstraint = {
  /**
   * The matches operator can use asterisks and pipes as wildcard and 'or' operators.
   *
   * @default contains
   * @x-auditable true
   */
  operator: "matches" | "contains" | "equals" | "not_equal" | "not_contain";
  /**
   * The value to apply the operator to.
   *
   * @x-auditable true
   */
  value: string;
};

/**
 * A request condition target.
 */
export type ZonesTarget = ZonesUrlTarget;

/**
 * The rule targets to evaluate on each request.
 *
 * @example {"constraint":{"operator":"matches","value":"*example.com/images/*"},"target":"url"}
 */
export type ZonesTargets = ZonesTarget[];

/**
 * Only allows TLS1.2.
 */
export type ZonesTls12Only = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * Zone setting identifier.
   *
   * @example tls_1_2_only
   */
  id: "tls_1_2_only";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesTls12OnlyValue;
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesTls12OnlyValue = "off" | "on";

/**
 * Enables Crypto TLS 1.3 feature for a zone.
 *
 * @default off
 */
export type ZonesTls13 = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example tls_1_3
   */
  id: "tls_1_3";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesTls13Value;
};

/**
 * Value of the zone setting.
 * Notes: Default value depends on the zone's plan level.
 *
 * @default off
 */
export type ZonesTls13Value = "on" | "off" | "zrt";

/**
 * TLS Client Auth requires Cloudflare to connect to your origin server using a client certificate (Enterprise Only).
 */
export type ZonesTlsClientAuth = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example tls_client_auth
   */
  id: "tls_client_auth";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesTlsClientAuthValue;
};

/**
 * value of the zone setting.
 *
 * @default on
 */
export type ZonesTlsClientAuthValue = "on" | "off";

/**
 * Media Transformations provides on-demand resizing, conversion and optimization for images and video served through Cloudflare's network. Refer to the [Image Transformations](https://developers.cloudflare.com/images/) and [Video Transformations](https://developers.cloudflare.com/stream/transform-videos/#getting-started) documentation for more information.
 */
export type ZonesTransformations = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting. Shared between Image Transformations and Video Transformations.
   *
   * @example transformations
   */
  id: "transformations";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesImageResizingValue;
};

/**
 * Media Transformations Allowed Origins restricts transformations for images and video served through Cloudflare's network. Refer to the [Image Transformations](https://developers.cloudflare.com/images/) and [Video Transformations](https://developers.cloudflare.com/stream/transform-videos/#getting-started) documentation for more information.
 */
export type ZonesTransformationsAllowedOrigins = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting. Shared between Image Transformations and Video Transformations.
   *
   * @example transformations_allowed_origins
   */
  id: "transformations_allowed_origins";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesTransformationsAllowedOriginsValue;
};

/**
 * Comma-separated list of allowed origins.
 * Refer to the [Image Transformations](https://developers.cloudflare.com/images/transform-images/sources/) and [Video Transformations](https://developers.cloudflare.com/stream/transform-videos/#getting-started) documentation for more information.
 */
export type ZonesTransformationsAllowedOriginsValue = string;

export type ZonesTrueClientIpHeader = {
  /**
   * Turn on or off the True-Client-IP Header feature of the Cloudflare Network app.
   *
   * @example true_client_ip_header
   * @x-auditable true
   */
  id?: "true_client_ip_header";
  /**
   * The status of True Client IP Header.
   *
   * @example on
   * @x-auditable true
   */
  value?: "on" | "off";
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesTrueClientIpHeaderValue = "on" | "off";

/**
 * A full zone implies that DNS is hosted with Cloudflare. A partial zone is
 * typically a partner-hosted zone or a CNAME setup.
 *
 * @default full
 * @example full
 */
export type ZonesType = "full" | "partial" | "secondary" | "internal";

/**
 * URL target.
 */
export type ZonesUrlTarget = {
  /**
   * String constraint.
   */
  constraint?: {
    /**
     * The matches operator can use asterisks and pipes as wildcard and 'or' operators.
     *
     * @default contains
     * @x-auditable true
     */
    operator: "matches" | "contains" | "equals" | "not_equal" | "not_contain";
    /**
     * The URL pattern to match against the current request. The pattern may contain up to four asterisks ('*') as placeholders.
     *
     * @x-auditable true
     * @example *example.com/images/*
     * @pattern ^(https?://)?(([-a-zA-Z0-9*]*\.)+[-a-zA-Z0-9]{2,20})(:(8080|8443|443|80))?(/[\S]+)?$
     */
    value: string;
  };
  /**
   * A target based on the URL of the request.
   *
   * @example url
   * @x-auditable true
   */
  target?: "url";
};

/**
 * An array of domains used for custom name servers. This is only
 * available for Business and Enterprise plans.
 *
 * @example ns1.example.com
 * @example ns2.example.com
 */
export type ZonesVanityNameServers = string[];

export type ZonesWaf = {
  /**
   * Turn on or off [WAF managed rules (previous version, deprecated)](https://developers.cloudflare.com/waf/reference/legacy/old-waf-managed-rules/).
   * You cannot enable or disable individual WAF managed rules via Page Rules.
   *
   * @example waf
   * @x-auditable true
   */
  id?: "waf";
  /**
   * The status of WAF managed rules (previous version).
   *
   * @example on
   * @x-auditable true
   */
  value?: "on" | "off";
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesWafValue = "on" | "off";

/**
 * When the client requesting the image supports the WebP image codec, and WebP offers a performance advantage over the original image format, Cloudflare will serve a WebP version of the original image.
 */
export type ZonesWebp = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example webp
   */
  id: "webp";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesWebpValue;
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesWebpValue = "off" | "on";

/**
 * WebSockets are open connections sustained between the client and the origin server. Inside a WebSockets connection, the client and the origin can pass data back and forth without having to reestablish sessions. This makes exchanging data within a WebSockets connection fast. WebSockets are often used for real-time applications such as live chat and gaming. For more information refer to [Can I use Cloudflare with Websockets](https://support.cloudflare.com/hc/en-us/articles/200169466-Can-I-use-Cloudflare-with-WebSockets-).
 */
export type ZonesWebsockets = {
  /**
   * Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
   *
   * @default true
   */
  editable?: true | false;
  /**
   * ID of the zone setting.
   *
   * @example websockets
   */
  id: "websockets";
  /**
   * last time this setting was modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on?: string | null;
  /**
   * Current value of the zone setting.
   *
   * @example on
   */
  value: ZonesWebsocketsValue;
};

/**
 * Value of the zone setting.
 *
 * @default off
 */
export type ZonesWebsocketsValue = "off" | "on";

export type ZonesZone = {
  /**
   * The account the zone belongs to.
   */
  account: {
    id?: ZonesIdentifier;
    /**
     * The name of the account.
     *
     * @example Example Account Name
     */
    name?: string;
  };
  /**
   * The last time proof of ownership was detected and the zone was made
   * active.
   *
   * @example 2014-01-02T00:01:00.12345Z
   * @format date-time
   */
  activated_on: string | null;
  /**
   * Allows the customer to use a custom apex.
   * *Tenants Only Configuration*.
   *
   * @example cdn.cloudflare.com
   */
  cname_suffix?: string;
  /**
   * When the zone was created.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  created_on: string;
  /**
   * The interval (in seconds) from when development mode expires
   * (positive integer) or last expired (negative integer) for the
   * domain. If development mode has never been enabled, this value is 0.
   *
   * @example 7200
   */
  development_mode: number;
  id: ZonesIdentifier;
  /**
   * Metadata about the zone.
   */
  meta: {
    /**
     * The zone is only configured for CDN.
     *
     * @example true
     */
    cdn_only?: boolean;
    /**
     * Number of Custom Certificates the zone can have.
     *
     * @example 1
     */
    custom_certificate_quota?: number;
    /**
     * The zone is only configured for DNS.
     *
     * @example true
     */
    dns_only?: boolean;
    /**
     * The zone is setup with Foundation DNS.
     *
     * @example true
     */
    foundation_dns?: boolean;
    /**
     * Number of Page Rules a zone can have.
     *
     * @example 100
     */
    page_rule_quota?: number;
    /**
     * The zone has been flagged for phishing.
     *
     * @example false
     */
    phishing_detected?: boolean;
    /**
     * @example 2
     */
    step?: number;
  };
  /**
   * When the zone was last modified.
   *
   * @example 2014-01-01T05:20:00.12345Z
   * @format date-time
   */
  modified_on: string;
  /**
   * The domain name.
   *
   * @example example.com
   * @maxLength 253
   * @pattern ^([a-zA-Z0-9][\-a-zA-Z0-9]*\.)+[\-a-zA-Z0-9]{2,20}$
   */
  name: string;
  /**
   * The name servers Cloudflare assigns to a zone.
   *
   * @example bob.ns.cloudflare.com
   * @example lola.ns.cloudflare.com
   */
  name_servers: string[];
  /**
   * DNS host at the time of switching to Cloudflare.
   *
   * @example NameCheap
   * @maxLength 50
   */
  original_dnshost: string | null;
  /**
   * Original name servers before moving to Cloudflare.
   *
   * @example ns1.originaldnshost.com
   * @example ns2.originaldnshost.com
   */
  original_name_servers: string[] | null;
  /**
   * Registrar for the domain at the time of switching to Cloudflare.
   *
   * @example GoDaddy
   */
  original_registrar: string | null;
  /**
   * The owner of the zone.
   */
  owner: {
    id?: ZonesIdentifier;
    /**
     * Name of the owner.
     *
     * @example Example Org
     */
    name?: string;
    /**
     * The type of owner.
     *
     * @example organization
     */
    type?: string;
  };
  paused?: ZonesPaused;
  /**
   * Legacy permissions based on legacy user membership information.
   *
   * @deprecated true
   * @x-stainless-message This has been replaced by Account memberships.
   */
  permissions?: string[];
  /**
     * A Zones subscription information.
     *
     * @deprecated true
     * @x-stainless-message Please use the `/zones/{zone_id}/subscription` API
    to update a zone's plan. Changing this value will create/cancel
    associated subscriptions. To view available plans for this zone,
    see [Zone Plans](https://developers.cloudflare.com/api/resources/zones/subresources/plans/).
     */
  plan: {
    /**
     * States if the subscription can be activated.
     *
     * @example false
     */
    can_subscribe?: boolean;
    /**
     * The denomination of the customer.
     *
     * @example USD
     */
    currency?: string;
    /**
     * If this Zone is managed by another company.
     *
     * @example false
     */
    externally_managed?: boolean;
    /**
     * How often the customer is billed.
     *
     * @example monthly
     */
    frequency?: string;
    id?: ZonesIdentifier;
    /**
     * States if the subscription active.
     *
     * @example false
     */
    is_subscribed?: boolean;
    /**
     * If the legacy discount applies to this Zone.
     *
     * @example false
     */
    legacy_discount?: boolean;
    /**
     * The legacy name of the plan.
     *
     * @example free
     */
    legacy_id?: string;
    /**
     * Name of the owner.
     *
     * @example Example Org
     */
    name?: string;
    /**
     * How much the customer is paying.
     *
     * @example 10.99
     */
    price?: number;
  };
  /**
   * The zone status on Cloudflare.
   *
   * @example active
   */
  status?: "initializing" | "pending" | "active" | "moved";
  /**
   * The root organizational unit that this zone belongs to (such as a tenant or organization).
   */
  tenant?: {
    id?: ZonesIdentifier;
    /**
     * The name of the Tenant account.
     *
     * @example Example Account Name
     */
    name?: string;
  };
  /**
   * The immediate parent organizational unit that this zone belongs to (such as under a tenant or sub-organization).
   */
  tenant_unit?: {
    id?: ZonesIdentifier;
  };
  type?: ZonesType;
  /**
   * An array of domains used for custom name servers. This is only available for Business and Enterprise plans.
   *
   * @example ns1.example.com
   * @example ns2.example.com
   */
  vanity_name_servers?: string[];
  /**
   * Verification key for partial zone setup.
   *
   * @example 284344499-1084221259
   */
  verification_key?: string;
};

export type ZonesZoneSettingsResponseCollection =
  ZonesSettingsApiComponentsSchemasApiResponseCommon & {
    result?: (
      | Zones0rtt
      | ZonesAdvancedDdos
      | ZonesCacheRulesAegis
      | ZonesAlwaysOnline
      | ZonesSchemasAlwaysUseHttps
      | ZonesSchemasAutomaticHttpsRewrites
      | ZonesBrotli
      | ZonesSchemasBrowserCacheTtl
      | ZonesSchemasBrowserCheck
      | ZonesSchemasCacheLevel
      | ZonesChallengeTtl
      | ZonesCiphers
      | ZonesCnameFlattening
      | ZonesDevelopmentMode
      | ZonesEarlyHints
      | ZonesSchemasEdgeCacheTtl
      | ZonesSchemasEmailObfuscation
      | ZonesH2Prioritization
      | ZonesHotlinkProtection
      | ZonesHttp2
      | ZonesHttp3
      | ZonesImageResizing
      | ZonesSchemasIpGeolocation
      | ZonesIpv6
      | ZonesMaxUpload
      | ZonesMinTlsVersion
      | ZonesSchemasMirage
      | ZonesNel
      | ZonesSchemasOpportunisticEncryption
      | ZonesOpportunisticOnion
      | ZonesOrangeToOrange
      | ZonesSchemasOriginErrorPagePassThru
      | ZonesCacheRulesOriginH2MaxStreams
      | ZonesCacheRulesOriginMaxHttpVersion
      | ZonesSchemasPolish
      | ZonesPrefetchPreload
      | ZonesPrivacyPass
      | ZonesProxyReadTimeout
      | ZonesPseudoIpv4
      | ZonesReplaceInsecureJs
      | ZonesSchemasResponseBuffering
      | ZonesSchemasRocketLoader
      | ZonesSchemasAutomaticPlatformOptimization
      | ZonesSecurityHeader
      | ZonesSchemasSecurityLevel
      | ZonesServerSideExclude
      | ZonesSha1Support
      | ZonesSchemasSortQueryStringForCache
      | ZonesSchemasSsl
      | ZonesSslRecommender
      | ZonesTls12Only
      | ZonesTls13
      | ZonesTlsClientAuth
      | ZonesTransformations
      | ZonesTransformationsAllowedOrigins
      | ZonesSchemasTrueClientIpHeader
      | ZonesSchemasWaf
      | ZonesWebp
      | ZonesWebsockets
    )[];
  };

export type ZonesZoneSettingsSingleRequest =
  | {
      enabled?: ZonesSslRecommenderEnabled;
    }
  | {
      value?: ZonesSettingValue;
    };

/**
 * A component value for a subscription.
 */
export type BillSubsApiComponentValue2 = {
  /**
   * The default amount assigned.
   *
   * @example 5
   */
  ["default"]?: number;
  /**
   * The name of the component value.
   *
   * @example page_rules
   */
  name?: string;
  /**
   * The unit price for the component value.
   *
   * @example 5
   */
  price?: number;
  /**
   * The amount of the component value assigned.
   *
   * @example 20
   */
  value?: number;
};

/**
 * The rate plan applied to the subscription.
 */
export type BillSubsApiRatePlan2 = {
  /**
   * The currency applied to the rate plan subscription.
   *
   * @example USD
   */
  currency?: string;
  /**
   * Whether this rate plan is managed externally from Cloudflare.
   *
   * @example false
   */
  externally_managed?: boolean;
  /**
   * The ID of the rate plan.
   *
   * @example free
   */
  id?: string;
  /**
   * Whether a rate plan is enterprise-based (or newly adopted term contract).
   *
   * @example false
   */
  is_contract?: boolean;
  /**
   * The full name of the rate plan.
   *
   * @example Business Plan
   */
  public_name?: string;
  /**
   * The scope that this rate plan applies to.
   *
   * @example zone
   */
  scope?: string;
  /**
   * The list of sets this rate plan applies to.
   */
  sets?: string[];
};

export type DnsFirewallDnsFirewallReverseDnsResponse2 =
  DnsFirewallApiResponseSingle & {
    result?: DnsFirewallDnsFirewallReverseDnsResponse;
  };

/**
 * If true, filter events where the origin status is healthy. If false, filter events where the origin status is unhealthy.
 *
 * @default true
 * @example true
 * @x-auditable true
 */
export type LoadBalancingOriginHealthy2 = boolean;

/**
 * Details about a live input.
 */
export type StreamLiveInput2 = {
  created?: StreamLiveInputCreated;
  deleteRecordingAfterDays?: StreamLiveInputRecordingDeletion;
  meta?: StreamLiveInputMetadata;
  modified?: StreamLiveInputModified;
  recording?: StreamLiveInputRecordingSettings;
  rtmps?: StreamInputRtmps;
  rtmpsPlayback?: StreamPlaybackRtmps;
  srt?: StreamInputSrt;
  srtPlayback?: StreamPlaybackSrt;
  status?: StreamLiveInputStatus;
  uid?: StreamLiveInputIdentifier;
  webRTC?: StreamInputWebrtc;
  webRTCPlayback?: StreamPlaybackWebrtc;
};

export type StreamWatermarkAtUpload2 = {
  /**
   * The unique identifier for the watermark profile.
   *
   * @example ea95132c15732412d22c1476fa83f27a
   * @maxLength 32
   * @x-auditable true
   */
  uid?: string;
};
